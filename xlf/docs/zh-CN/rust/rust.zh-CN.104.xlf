<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="676fb636ec3ef59315a4dc9ef64f5fbe3403351d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0051a5a0c2153685b22e3e481253428438ae9b0d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;code&gt;CString&lt;/code&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">这样， &lt;code&gt;CString&lt;/code&gt; 在 &lt;code&gt;hello&lt;/code&gt; 中的生存期包含 &lt;code&gt;ptr&lt;/code&gt; 和 &lt;code&gt;unsafe&lt;/code&gt; 块的生存期。</target>
        </trans-unit>
        <trans-unit id="6a66e53cbccdcf1dd0b129068e28220aa1da407b" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be23e02db6f58e9303929f35bcf996dc6954c461" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87576c37932e7e920719c7c3053295204953101" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">这将总是&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c37af121800fff05f23ea7195ec86eae7b112d6" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt;</source>
          <target state="translated">这将总是&lt;a href=&quot;macro.panic&quot;&gt;惊慌！&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7ba30b4423020d7c6174593849644ce672a970c" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt; because &lt;code&gt;unimplemented!&lt;/code&gt; is just a shorthand for &lt;code&gt;panic!&lt;/code&gt; with a fixed, specific message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9dc67930c6219a678b4690efb3c9a2b4b3cc3e" translate="yes" xml:space="preserve">
          <source>This will be a max-heap.</source>
          <target state="translated">这将是一个最大的堆。</target>
        </trans-unit>
        <trans-unit id="835f899ffcb476aee6b318f9e24a76f9e21b8043" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61949&quot;&gt;issue-61949&lt;/a&gt; for this limitation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850691bcf932c0c55cd89eb4535ca90e22acf61f" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the tracking issue for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49146&quot;&gt;conditionals&lt;/a&gt; or &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;loops&lt;/a&gt; in a const context for the current status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fffbe8e22b797d8b6890d54d873414453d3490a" translate="yes" xml:space="preserve">
          <source>This will cause an error:</source>
          <target state="translated">这将导致一个错误。</target>
        </trans-unit>
        <trans-unit id="5b06471f77c7403c58187c73c7a664a50663e032" translate="yes" xml:space="preserve">
          <source>This will commonly, but not always, be a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; or &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常，但并非总是如此，它是 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 或&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a8b17614cf7c240a7a1eb116da8eea5f59c7b71" translate="yes" xml:space="preserve">
          <source>This will compile, because it has the constraint on the type parameter:</source>
          <target state="translated">这将被编译,因为它有类型参数的约束。</target>
        </trans-unit>
        <trans-unit id="3520fed49c822ab60288ef2f8f669d15b4a41e6f" translate="yes" xml:space="preserve">
          <source>This will compile:</source>
          <target state="translated">这样就可以编译了。</target>
        </trans-unit>
        <trans-unit id="49cc821a81b4f339dbb259efc2d82e6ee470759f" translate="yes" xml:space="preserve">
          <source>This will create a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This conversion is very inexpensive, and so generally, functions will accept &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific reason.</source>
          <target state="translated">这将创建一个&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;从 &lt;code&gt;String&lt;/code&gt; ，并传递它，这种转换是非常便宜，所以一般情况下，功能将接受&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; S作为参数，除非他们需要一个 &lt;code&gt;String&lt;/code&gt; 因为某种特定原因。</target>
        </trans-unit>
        <trans-unit id="1b5cc9b9f228f1bae8ee73a71afeed4d549dd793" translate="yes" xml:space="preserve">
          <source>This will create a thread using default parameters of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt;, if you want to specify the stack size or the name of the thread, use this API instead.</source>
          <target state="translated">这将使用&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; 的&lt;/a&gt;默认参数创建一个线程，如果您想指定堆栈大小或线程名称，请改用此API。</target>
        </trans-unit>
        <trans-unit id="e391cc107c46641450ffa0654fcfb8cbca70a73b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../rc/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">这将减少强引用计数。如果强引用计数达到零，那么仅有的其他引用（如果有）为&lt;a href=&quot;../rc/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;，因此我们 &lt;code&gt;drop&lt;/code&gt; 内部值。</target>
        </trans-unit>
        <trans-unit id="97b7f84f70f9d3f5d6303968924e2733780bc78b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../sync/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">这将减少强引用计数。如果强引用计数达到零，那么仅有的其他引用（如果有）为&lt;a href=&quot;../sync/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;，因此我们 &lt;code&gt;drop&lt;/code&gt; 内部值。</target>
        </trans-unit>
        <trans-unit id="b917396cbcb63b72ec008aadc499d642c7abbf61" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">这将减少强引用计数。如果强引用计数达到零，那么仅有的其他引用（如果有）为&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;，因此我们 &lt;code&gt;drop&lt;/code&gt; 内部值。</target>
        </trans-unit>
        <trans-unit id="0e9819c7b2177172935ef1092ecc4f74eaf1578f" translate="yes" xml:space="preserve">
          <source>This will drop any excess capacity.</source>
          <target state="translated">这将掉落任何多余的容量。</target>
        </trans-unit>
        <trans-unit id="354a015dbdb2ab35ae4e0b061d1f50f5025f7cbe" translate="yes" xml:space="preserve">
          <source>This will escape characters with the Rust syntax of the form &lt;code&gt;\u{NNNNNN}&lt;/code&gt; where &lt;code&gt;NNNNNN&lt;/code&gt; is a hexadecimal representation.</source>
          <target state="translated">这将使用 &lt;code&gt;\u{NNNNNN}&lt;/code&gt; 格式的Rust语法转义字符，其中 &lt;code&gt;NNNNNN&lt;/code&gt; 是十六进制表示形式。</target>
        </trans-unit>
        <trans-unit id="c51882eef9b6927fb20dc2b079d5f33d822ffcef" translate="yes" xml:space="preserve">
          <source>This will escape the characters similar to the &lt;code&gt;Debug&lt;/code&gt; implementations of &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">这将转义类似于 &lt;code&gt;str&lt;/code&gt; 或 &lt;code&gt;char&lt;/code&gt; 的 &lt;code&gt;Debug&lt;/code&gt; 实现的字符。</target>
        </trans-unit>
        <trans-unit id="7463a3fbad059d7822b7a64865f64ec71f56ca6c" translate="yes" xml:space="preserve">
          <source>This will fail because the compiler does not know which instance of &lt;code&gt;Foo&lt;/code&gt; to call &lt;code&gt;bar&lt;/code&gt; on. Change &lt;code&gt;Foo::bar()&lt;/code&gt; to &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; to resolve the error.</source>
          <target state="translated">这将失败，因为编译器不知道在哪个 &lt;code&gt;Foo&lt;/code&gt; 实例上调用 &lt;code&gt;bar&lt;/code&gt; 。将 &lt;code&gt;Foo::bar()&lt;/code&gt; 更改为 &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; 可解决该错误。</target>
        </trans-unit>
        <trans-unit id="b95565727f175f666e1822f4733ae91ef6a1780e" translate="yes" xml:space="preserve">
          <source>This will fail to compile because we cannot implement a trait for a type if both the trait and the type are not defined by the current crate. This is due to Rust's orphaning rules. To bypass this, you can implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">这将无法编译，因为如果当前包装箱中未同时定义特征和类型，则无法为该类型实现特征。这是由于Rust的孤立规则。要绕过它，您可以直接实现&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8648eb6ea2730446e0cfb046319d740aba54d8bb" translate="yes" xml:space="preserve">
          <source>This will fail to compile in older versions of the language because Rust's orphaning rules used to be a little bit more strict. To bypass this, you could implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c41f14d1e2c5310aaa0b927129f701a7031c03a" translate="yes" xml:space="preserve">
          <source>This will invoke the &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; macro if the provided expression cannot be evaluated to &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">这会引起&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;如果提供的表达式无法在运行时评估为 &lt;code&gt;true&lt;/code&gt; ，则为宏。</target>
        </trans-unit>
        <trans-unit id="2deb5f847f234caa59a2e70f4ab65edaeb2fdead" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet.</source>
          <target state="translated">如果这个线程还没有引用这个键,这将懒惰地初始化这个值。</target>
        </trans-unit>
        <trans-unit id="2be746d77ee47101c5a961aeebfbec50b6101d49" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an &lt;a href=&quot;struct.accesserror&quot;&gt;&lt;code&gt;AccessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该线程尚未引用此键，则将延迟初始化该值。如果密钥已被销毁（如果在析构函数中调用此密钥，则可能会发生），此函数将返回&lt;a href=&quot;struct.accesserror&quot;&gt; &lt;code&gt;AccessError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3800eafd69cf59aa81eb6bb72cb9493004b5c43e" translate="yes" xml:space="preserve">
          <source>This will make &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; persist for the remainder of your shell session. It can be unset with the &lt;code&gt;Remove-Item&lt;/code&gt; cmdlet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b457d7ac05dde73ffae7dfa5283d452dba90a68" translate="yes" xml:space="preserve">
          <source>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</source>
          <target state="translated">这不会打印任何值,因为我们只是创建了一个迭代器,而不是使用它。编译器会警告我们这种行为。</target>
        </trans-unit>
        <trans-unit id="7884f03c74d608aa53fe96a0fe19b6f01fc64a4e" translate="yes" xml:space="preserve">
          <source>This will not work if the new name is on a different mount point.</source>
          <target state="translated">如果新名称在不同的挂载点上,这将无法使用。</target>
        </trans-unit>
        <trans-unit id="29502fa64160996ff78f02e55cbb4b83b39e3b0d" translate="yes" xml:space="preserve">
          <source>This will not:</source>
          <target state="translated">这不会。</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">这将输出以下内容。</target>
        </trans-unit>
        <trans-unit id="01e646d50274ee113a75cb82fc9f837874518988" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;append&lt;/code&gt; flags on the &lt;code&gt;OpenOptions&lt;/code&gt; structure. This method provides fine-grained control over the permissions to read, write and append data, attributes (like hidden and system), and extended attributes.</source>
          <target state="translated">这将覆盖 &lt;code&gt;OpenOptions&lt;/code&gt; 结构上的 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;append&lt;/code&gt; 标志。此方法提供对读取，写入和附加数据，属性（如隐藏属性和系统属性）和扩展属性的权限的细粒度控制。</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475997c398cd5b2921c0cb8cd3f062a1e5e787e7" translate="yes" xml:space="preserve">
          <source>This will print &quot;('a', 1), ('b', 2), ('c', 3)&quot;.</source>
          <target state="translated">这将打印&quot;('a',1),('b',2),('c',3)&quot;。</target>
        </trans-unit>
        <trans-unit id="3a5f8c78def77453ab00074a3cd30ff4dd27218b" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, each on their own line.</source>
          <target state="translated">这将打印 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;5&lt;/code&gt; ，每行一行。</target>
        </trans-unit>
        <trans-unit id="45cc5d4168a6948db8686b2c0a8d37fbb64175cc" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt;.</source>
          <target state="translated">这将打印 &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3cd6bbcdf4b75c4bbd0f80ed7b9518ac88ecb8" translate="yes" xml:space="preserve">
          <source>This will print the numbers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt;, each on their own line.</source>
          <target state="translated">这将在各自的行上打印数字 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a40fac0ea22a56e98579c9cc97554e4f4a65b5bb" translate="yes" xml:space="preserve">
          <source>This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?</source>
          <target state="translated">这将打印出1到5的数字,每个数字都在它们自己的行上。但是你会注意到一些东西:我们从来没有在我们的向量上调用任何东西来产生迭代器。那是什么原因呢?</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">这将打印。</target>
        </trans-unit>
        <trans-unit id="e3f9d6eebc7d0a9c3006485e1bf2fe9250c18991" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;send&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">这将导致 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; ， &lt;code&gt;recv&lt;/code&gt; 和 &lt;code&gt;send&lt;/code&gt; 操作变得无阻塞，即立即从其调用返回。如果IO操作成功，则返回 &lt;code&gt;Ok&lt;/code&gt; ，并且无需采取进一步措施。如果IO操作无法完成并且需要重试，则返回类型为&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;的错误。</target>
        </trans-unit>
        <trans-unit id="4b3da21af1f8f50bfb5fb08b425cfbfeb0c3196a" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;recv&lt;/code&gt;, &lt;code&gt;recv_from&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;send_to&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">这将导致 &lt;code&gt;recv&lt;/code&gt; ， &lt;code&gt;recv_from&lt;/code&gt; ， &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;send_to&lt;/code&gt; 操作变为非阻塞，即立即从其调用返回。如果IO操作成功，则返回 &lt;code&gt;Ok&lt;/code&gt; ，无需采取进一步措施。如果IO操作无法完成并且需要重试，则返回类型为&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;的错误。</target>
        </trans-unit>
        <trans-unit id="5f9e536d8780a7dfeadd69ff71cc712be79eb591" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../../../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e7ab507f523fe704d7f615781e7105b958a139" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">这将导致 &lt;code&gt;accept&lt;/code&gt; 操作变得非阻塞，即立即从其调用返回。如果IO操作成功，则返回 &lt;code&gt;Ok&lt;/code&gt; ，无需采取进一步措施。如果IO操作无法完成并且需要重试，则返回类型为&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;的错误。</target>
        </trans-unit>
        <trans-unit id="b55e73be7a2382bca6297d35304f77d90844f6fa" translate="yes" xml:space="preserve">
          <source>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</source>
          <target state="translated">这将检索存储在底层套接字中的错误,并在过程中清除该字段。这对于在调用之间检查错误很有用。</target>
        </trans-unit>
        <trans-unit id="88ce8a4d0f2f6725fab10313d205fd945723d024" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Metadata&lt;/code&gt; instance was created from a call to &lt;code&gt;DirEntry::metadata&lt;/code&gt;. If this &lt;code&gt;Metadata&lt;/code&gt; was created by using &lt;code&gt;fs::metadata&lt;/code&gt; or &lt;code&gt;File::metadata&lt;/code&gt;, then this will return &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f194e7c7453fbebb97c4d612baa72decde0dd60" translate="yes" xml:space="preserve">
          <source>This will return an error when the IP version of the local socket does not match that returned from &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当本地套接字的IP版本与&lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt;返回的IP版本不匹配时，这将返回错误。</target>
        </trans-unit>
        <trans-unit id="fc0cdcc30572aec7d1df1cbb47d079cf5a14ac66" translate="yes" xml:space="preserve">
          <source>This will succeed even if there are outstanding weak references.</source>
          <target state="translated">即使有突出的弱项参考,也会成功。</target>
        </trans-unit>
        <trans-unit id="2bd1f4c0ae47dc79d8ec8c7bba4ba6b5d8664eba" translate="yes" xml:space="preserve">
          <source>This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers.</source>
          <target state="translated">这将使用 &lt;code&gt;clone&lt;/code&gt; 来复制表达式，因此应谨慎使用具有非标准 &lt;code&gt;Clone&lt;/code&gt; 实现的类型。例如， &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; 将创建一个向量，其中有五个引用指向相同的装箱整数值，而不是五个引用指向独立装箱整数的值。</target>
        </trans-unit>
        <trans-unit id="1af0f8715542d97c1e40ad188906242d9ebb10f7" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;Box&lt;/code&gt; is a pointer, so its size is well-known.</source>
          <target state="translated">之所以 &lt;code&gt;Box&lt;/code&gt; 是因为Box是一个指针，因此它的大小是众所周知的。</target>
        </trans-unit>
        <trans-unit id="e6ae7145b95212826784b081e816d005693796fd" translate="yes" xml:space="preserve">
          <source>This works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the &lt;code&gt;Screen&lt;/code&gt; struct using a generic type and a trait bound as in Listing 17-6:</source>
          <target state="translated">这与定义使用带有特征边界的泛型类型参数的结构的工作方式不同。泛型类型参数一次只能用一种具体类型代替，而特征对象允许在运行时为特征对象填充多种具体类型。例如，我们可以使用通用类型和特征绑定来定义 &lt;code&gt;Screen&lt;/code&gt; 结构，如清单17-6所示：</target>
        </trans-unit>
        <trans-unit id="a99f3af5ecd17821d147ce27f764af7ca400396e" translate="yes" xml:space="preserve">
          <source>This works fine, but when the method gains generic parameters, we can have a problem.</source>
          <target state="translated">这很好用,但当方法获得通用参数时,我们就会出现问题。</target>
        </trans-unit>
        <trans-unit id="d71531129bdd4b29a09ed683d862d9540e2e5d1c" translate="yes" xml:space="preserve">
          <source>This works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data &lt;em&gt;does&lt;/em&gt; get copied.</source>
          <target state="translated">这工作得很好，并且显式地产生了图4-3所示的行为，在该行为中&lt;em&gt;确实&lt;/em&gt;复制了堆数据。</target>
        </trans-unit>
        <trans-unit id="bfbfb994099b13008a48f4d00df577d26e30661c" translate="yes" xml:space="preserve">
          <source>This works without any problems. Ownership is moved out, and nothing is deallocated.</source>
          <target state="translated">这个工作没有任何问题。所有权被迁出,没有任何东西被转移。</target>
        </trans-unit>
        <trans-unit id="6c438e4eca96ad10f658e6fd464bdd00bbab9e0b" translate="yes" xml:space="preserve">
          <source>This wrapper helps with explicitly documenting the drop order dependencies between fields of the type:</source>
          <target state="translated">这个包装器有助于显式地记录该类型字段之间的顺序依赖关系。</target>
        </trans-unit>
        <trans-unit id="77c94458816b78e926120564c533b185a38f9981" translate="yes" xml:space="preserve">
          <source>This wrapper is 0-cost.</source>
          <target state="translated">这个包装物是0成本的。</target>
        </trans-unit>
        <trans-unit id="bb9a9b150cc6f7bfa7d25085c5da29bd09b9aebf" translate="yes" xml:space="preserve">
          <source>This zero-sized type &lt;em&gt;coerces&lt;/em&gt; to a regular function pointer. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf6fbbeb84fc23d69997d38f588cc8535a0a6a" translate="yes" xml:space="preserve">
          <source>Though they both have scary names, &lt;code&gt;PhantomData&lt;/code&gt; and 'phantom types' are related, but not identical. A phantom type parameter is simply a type parameter which is never used. In Rust, this often causes the compiler to complain, and the solution is to add a &quot;dummy&quot; use by way of &lt;code&gt;PhantomData&lt;/code&gt;.</source>
          <target state="translated">尽管它们都有可怕的名称，但 &lt;code&gt;PhantomData&lt;/code&gt; 和&amp;ldquo;幻像类型&amp;rdquo;是相关的，但并不完全相同。幻像类型参数只是从未使用过的类型参数。在Rust中，这通常会导致编译器抱怨，解决方案是通过 &lt;code&gt;PhantomData&lt;/code&gt; 添加&amp;ldquo;虚拟&amp;rdquo;使用。</target>
        </trans-unit>
        <trans-unit id="394004c26aaecc036ffcf91c8fc18935b18646a0" translate="yes" xml:space="preserve">
          <source>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</source>
          <target state="translated">虽然这个例子看起来很无害,也很容易解决,但当遇到消耗值的函数时,问题就很明显了。</target>
        </trans-unit>
        <trans-unit id="68fc8c5fcce31dacdf37236f648493191d2504be" translate="yes" xml:space="preserve">
          <source>Though this method is safe for any two pointers, note that its result will be mostly useless if the two pointers aren't into the same allocated object, for example if they point to two different local variables.</source>
          <target state="translated">虽然这个方法对任何两个指针都是安全的,但要注意的是,如果两个指针不是进入同一个分配的对象,比如它们指向两个不同的局部变量,那么这个方法的结果将大部分是无用的。</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">螺纹安全</target>
        </trans-unit>
        <trans-unit id="8acbe8abc881f5530528aa5ba52eb0a3d5f4e21c" translate="yes" xml:space="preserve">
          <source>Thread factory, which can be used in order to configure the properties of a new thread.</source>
          <target state="translated">线程工厂,可以用来配置新线程的属性。</target>
        </trans-unit>
        <trans-unit id="3f259cba637903dc7da0506c4d921b66c4b2c1d2" translate="yes" xml:space="preserve">
          <source>Thread with a specified name:</source>
          <target state="translated">有指定名称的线程。</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">线程本地存储</target>
        </trans-unit>
        <trans-unit id="031ccc205829651d22cb916d91b65f0a8f208375" translate="yes" xml:space="preserve">
          <source>Thread::borrow</source>
          <target state="translated">Thread::borrow</target>
        </trans-unit>
        <trans-unit id="c95c792ba6b184afddca7a8e36aefd1fbf1d6ade" translate="yes" xml:space="preserve">
          <source>Thread::borrow_mut</source>
          <target state="translated">Thread::borrow_mut</target>
        </trans-unit>
        <trans-unit id="dbb6daabaec761c7c46cdca4426de7d2af20b09f" translate="yes" xml:space="preserve">
          <source>Thread::clone</source>
          <target state="translated">Thread::clone</target>
        </trans-unit>
        <trans-unit id="e27a758e7d203684411b93372f7af767f3888a92" translate="yes" xml:space="preserve">
          <source>Thread::clone_from</source>
          <target state="translated">Thread::clone_from</target>
        </trans-unit>
        <trans-unit id="21aa2dd81c0fa05128232b310f0bc9892cddef0b" translate="yes" xml:space="preserve">
          <source>Thread::clone_into</source>
          <target state="translated">Thread::clone_into</target>
        </trans-unit>
        <trans-unit id="070b95410e1e4362fb02748c2208a536c3a47c62" translate="yes" xml:space="preserve">
          <source>Thread::fmt</source>
          <target state="translated">Thread::fmt</target>
        </trans-unit>
        <trans-unit id="15bec62911f03b003cb69d406b3848ca01770f8f" translate="yes" xml:space="preserve">
          <source>Thread::from</source>
          <target state="translated">Thread::from</target>
        </trans-unit>
        <trans-unit id="4a91eeba81f613beaaf6029aae0e32dad80d38b8" translate="yes" xml:space="preserve">
          <source>Thread::id</source>
          <target state="translated">Thread::id</target>
        </trans-unit>
        <trans-unit id="b2a4ffaaac236ade773000faaa7bef3c1f0cc8f6" translate="yes" xml:space="preserve">
          <source>Thread::into</source>
          <target state="translated">Thread::into</target>
        </trans-unit>
        <trans-unit id="344f7d7a1faf3f99cb05399e695391adc35f7d18" translate="yes" xml:space="preserve">
          <source>Thread::name</source>
          <target state="translated">Thread::name</target>
        </trans-unit>
        <trans-unit id="2dcbcae4f337ba144bfa61f602dbf53a215ffbaa" translate="yes" xml:space="preserve">
          <source>Thread::to_owned</source>
          <target state="translated">Thread::to_owned</target>
        </trans-unit>
        <trans-unit id="08e8a562777dded639d27f7f44cfadcf3bf00a5e" translate="yes" xml:space="preserve">
          <source>Thread::try_from</source>
          <target state="translated">Thread::try_from</target>
        </trans-unit>
        <trans-unit id="ea003eda575d811cf577619ef02836592885180a" translate="yes" xml:space="preserve">
          <source>Thread::try_into</source>
          <target state="translated">Thread::try_into</target>
        </trans-unit>
        <trans-unit id="ee3875fc112ad5bc121f3e391fcecb3da4daa377" translate="yes" xml:space="preserve">
          <source>Thread::type_id</source>
          <target state="translated">Thread::type_id</target>
        </trans-unit>
        <trans-unit id="a2b67a0f80271fce8e8b3bd5ec25f2445ebea8c7" translate="yes" xml:space="preserve">
          <source>Thread::unpark</source>
          <target state="translated">Thread::unpark</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="e1f6247a7eef6633e4e5d83608be9b3187e0c969" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow</source>
          <target state="translated">ThreadId::borrow</target>
        </trans-unit>
        <trans-unit id="22f5c0c99a3c51f5db8e51f093d172c44439f9bc" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow_mut</source>
          <target state="translated">ThreadId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f272ac73f50e66007497d727840b4334ee1f128b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone</source>
          <target state="translated">ThreadId::clone</target>
        </trans-unit>
        <trans-unit id="6c35d53945f00e081a8257913c3ad292495b0c89" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_from</source>
          <target state="translated">ThreadId::clone_from</target>
        </trans-unit>
        <trans-unit id="9abe12a7685c82abc8d5bcbb6509a690fccefb0b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_into</source>
          <target state="translated">ThreadId::clone_into</target>
        </trans-unit>
        <trans-unit id="1fcd1d752fe2d53f1b3acff5f74fcaa56fbea5a4" translate="yes" xml:space="preserve">
          <source>ThreadId::eq</source>
          <target state="translated">ThreadId::eq</target>
        </trans-unit>
        <trans-unit id="02c70e2223708a5777dae53420e0c974498720e0" translate="yes" xml:space="preserve">
          <source>ThreadId::fmt</source>
          <target state="translated">ThreadId::fmt</target>
        </trans-unit>
        <trans-unit id="b838b903c39a24240409358be89ed6329a9df09a" translate="yes" xml:space="preserve">
          <source>ThreadId::from</source>
          <target state="translated">ThreadId::from</target>
        </trans-unit>
        <trans-unit id="ddc023441f52408bece6bf2ff774b50209750066" translate="yes" xml:space="preserve">
          <source>ThreadId::hash</source>
          <target state="translated">ThreadId::hash</target>
        </trans-unit>
        <trans-unit id="8244a05f09ebefd9016fbce0f8394db6f762584b" translate="yes" xml:space="preserve">
          <source>ThreadId::hash_slice</source>
          <target state="translated">ThreadId::hash_slice</target>
        </trans-unit>
        <trans-unit id="fd5bfcfa29d7d00b83774a3201acbc0e51fa4872" translate="yes" xml:space="preserve">
          <source>ThreadId::into</source>
          <target state="translated">ThreadId::into</target>
        </trans-unit>
        <trans-unit id="a87f4470467c3e753de867438c3b5d2edf68e527" translate="yes" xml:space="preserve">
          <source>ThreadId::ne</source>
          <target state="translated">ThreadId::ne</target>
        </trans-unit>
        <trans-unit id="3cd41ae993fc3fddaa9fb843d50a8938bb01dd02" translate="yes" xml:space="preserve">
          <source>ThreadId::to_owned</source>
          <target state="translated">ThreadId::to_owned</target>
        </trans-unit>
        <trans-unit id="c7ce06f7b4875caccd8b2ef7310bb3589387aaa7" translate="yes" xml:space="preserve">
          <source>ThreadId::try_from</source>
          <target state="translated">ThreadId::try_from</target>
        </trans-unit>
        <trans-unit id="1723d15638b0712b0610f447b496de925bf9fce1" translate="yes" xml:space="preserve">
          <source>ThreadId::try_into</source>
          <target state="translated">ThreadId::try_into</target>
        </trans-unit>
        <trans-unit id="586fd641683540c80a212ba3dd698b0a2d8e64c3" translate="yes" xml:space="preserve">
          <source>ThreadId::type_id</source>
          <target state="translated">ThreadId::type_id</target>
        </trans-unit>
        <trans-unit id="c8f829eec28b00e160b939476f6112a322b89854" translate="yes" xml:space="preserve">
          <source>Threads are able to have associated names for identification purposes. By default, spawned threads are unnamed. To specify a name for a thread, build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired thread name to &lt;a href=&quot;struct.builder#method.name&quot;&gt;&lt;code&gt;Builder::name&lt;/code&gt;&lt;/a&gt;. To retrieve the thread name from within the thread, use &lt;a href=&quot;struct.thread#method.name&quot;&gt;&lt;code&gt;Thread::name&lt;/code&gt;&lt;/a&gt;. A couple examples of where the name of a thread gets used:</source>
          <target state="translated">线程能够具有关联的名称以用于识别。默认情况下，生成的线程是未命名的。要为线程指定名称，请使用&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt;构建线程，然后将所需的线程名称传递给&lt;a href=&quot;struct.builder#method.name&quot;&gt; &lt;code&gt;Builder::name&lt;/code&gt; &lt;/a&gt;。要从线程内部检索线程名称，请使用&lt;a href=&quot;struct.thread#method.name&quot;&gt; &lt;code&gt;Thread::name&lt;/code&gt; &lt;/a&gt;。几个使用线程名称的地方的例子：</target>
        </trans-unit>
        <trans-unit id="fac19ffa706cd7f7c61cd4298da14db7d3225341" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; type, which you can get in one of two ways:</source>
          <target state="translated">线程通过&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;类型表示，您可以通过以下两种方式之一来获取：</target>
        </trans-unit>
        <trans-unit id="dfac2e4a30b24c7a0b51fc7ce730d2b041ad7fac" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;code&gt;Thread&lt;/code&gt; type, which you can get in one of two ways:</source>
          <target state="translated">线程通过 &lt;code&gt;Thread&lt;/code&gt; 类型表示，您可以通过以下两种方式之一来获取：</target>
        </trans-unit>
        <trans-unit id="61ca9f4a8a357e814dec07995e4960f9fb1789c1" translate="yes" xml:space="preserve">
          <source>Threads by default have no name specified:</source>
          <target state="translated">默认情况下,线程没有指定名称。</target>
        </trans-unit>
        <trans-unit id="968a06f03211a8e28589507e83ecbad68bacd321" translate="yes" xml:space="preserve">
          <source>Three examples of &lt;code&gt;extern crate&lt;/code&gt; declarations:</source>
          <target state="translated">&lt;code&gt;extern crate&lt;/code&gt; 声明的三个示例：</target>
        </trans-unit>
        <trans-unit id="adf3f084c350f9e4e1af9b596fea76609465c5c2" translate="yes" xml:space="preserve">
          <source>Throughout the book, you&amp;rsquo;ve seen examples of many kinds of patterns. In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</source>
          <target state="translated">在整本书中，您已经看到了多种模式的示例。在本节中，我们收集了模式中所有有效的语法，并讨论了为什么可能要使用每个语法。</target>
        </trans-unit>
        <trans-unit id="60bf7601d61de03ae0783bd8d23bcd9c972360eb" translate="yes" xml:space="preserve">
          <source>Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;. Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">在整个文档中，我们将遵循一些约定。对于所有操作，集合的大小用n表示。如果该操作涉及另一个集合，则它包含m个元素。带有&lt;em&gt;摊余&lt;/em&gt;成本的工序带有 &lt;code&gt;*&lt;/code&gt; 后缀。&lt;em&gt;预期&lt;/em&gt;成本的运算后带有 &lt;code&gt;~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="238f30330684e8f9c133d5faa32478b32bb7092d" translate="yes" xml:space="preserve">
          <source>Throughout this book, we&amp;rsquo;ve used &lt;code&gt;let&lt;/code&gt; like this hundreds of times, and although you might not have realized it, you were using patterns! More formally, a &lt;code&gt;let&lt;/code&gt; statement looks like this:</source>
          <target state="translated">在本书中，我们已经使用 &lt;code&gt;let&lt;/code&gt; 了数百次，尽管您可能没有意识到，但是您正在使用模式！更正式地说， &lt;code&gt;let&lt;/code&gt; 语句如下所示：</target>
        </trans-unit>
        <trans-unit id="3b79edbe5b3429757c6a6c5658f9e500a2a9f5f8" translate="yes" xml:space="preserve">
          <source>Thus the pattern of &lt;code&gt;yield&lt;/code&gt;ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.</source>
          <target state="translated">因此，在实现低级共享资源或同步原语时，轮询失败后的 &lt;code&gt;yield&lt;/code&gt; 模式相当普遍。</target>
        </trans-unit>
        <trans-unit id="821dfcf79b1432754988865d9447fbfdba546e04" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ref&lt;/code&gt; is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</source>
          <target state="translated">因此， &lt;code&gt;ref&lt;/code&gt; 不是要匹配的对象。其目的专门是使匹配的绑定成为参考，而不是潜在地复制或移动匹配的内容。</target>
        </trans-unit>
        <trans-unit id="f25396ffdb747466e5fd6748ffb6e2945d105f98" translate="yes" xml:space="preserve">
          <source>Thus, a sensible way to handle a thread panic is to either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="667c88e4323d998577ae614b3d0f0d63105deed4" translate="yes" xml:space="preserve">
          <source>Time complexity</source>
          <target state="translated">时间复杂度</target>
        </trans-unit>
        <trans-unit id="87e54a385b9de69cf35ac4ab359d69ed9aa1950a" translate="yes" xml:space="preserve">
          <source>To &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;</source>
          <target state="translated">要 &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; 还是不要 &lt;code&gt;panic!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c0ba38264d0a297ae9df50179b24027837bbba6" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;RHS&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">要添加 &lt;code&gt;Millimeters&lt;/code&gt; 和 &lt;code&gt;Meters&lt;/code&gt; ，我们指定 &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; 来设置 &lt;code&gt;RHS&lt;/code&gt; 类型参数的值，而不是使用默认的 &lt;code&gt;Self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cba3d2f6052bb257fd3b265e03522cd76a90182d" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;Rhs&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e27f28761495c993b1d146a55214b33393a503" translate="yes" xml:space="preserve">
          <source>To allow customization in specific cases most users won&amp;rsquo;t need</source>
          <target state="translated">要允许在特定情况下进行自定义，大多数用户不需要</target>
        </trans-unit>
        <trans-unit id="b1d5c30e2acf4bd68628daf0a08fcdb7d03b4380" translate="yes" xml:space="preserve">
          <source>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</source>
          <target state="translated">为了帮助进行适当的设计,下面的场景被明确声明为单线程代码的合法场景。</target>
        </trans-unit>
        <trans-unit id="3ff5f80d30f1f493faf134bdcac7192bc4fe0c89" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Arc&lt;/code&gt; using &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt;&lt;code&gt;Arc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了避免内存泄漏的指针必须被转换回一 &lt;code&gt;Arc&lt;/code&gt; 使用&lt;a href=&quot;struct.arc#method.from_raw&quot;&gt; &lt;code&gt;Arc::from_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1e40b418899dc58e251a0e3e3662f5034b84fa8" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Rc&lt;/code&gt; using &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt;&lt;code&gt;Rc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了避免内存泄漏的指针必须被转换回一个 &lt;code&gt;Rc&lt;/code&gt; 使用&lt;a href=&quot;struct.rc#method.from_raw&quot;&gt; &lt;code&gt;Rc::from_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a5ee855a608ecd864fa2e7b73853f23dfbb067b" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; references that alias, the returned slice borrows its lifetime from the iterator the method is applied on.</source>
          <target state="translated">为避免创建引用该别名的 &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; ，返回的切片从应用该方法的迭代器借用其生存期。</target>
        </trans-unit>
        <trans-unit id="ffa0cd99296c4663ce93793ddad7c9407847a5e2" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut&lt;/code&gt; references that alias, this is forced to consume the iterator.</source>
          <target state="translated">为了避免创建 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 别名的＆mut引用，这被强制使用迭代器。</target>
        </trans-unit>
        <trans-unit id="1aefc821eaa401be8625ea8100fecfc992fdeed8" translate="yes" xml:space="preserve">
          <source>To avoid having &lt;code&gt;common&lt;/code&gt; appear in the test output, instead of creating &lt;em&gt;tests/common.rs&lt;/em&gt;, we&amp;rsquo;ll create &lt;em&gt;tests/common/mod.rs&lt;/em&gt;. This is an alternate naming convention that Rust also understands. Naming the file this way tells Rust not to treat the &lt;code&gt;common&lt;/code&gt; module as an integration test file. When we move the &lt;code&gt;setup&lt;/code&gt; function code into &lt;em&gt;tests/common/mod.rs&lt;/em&gt; and delete the &lt;em&gt;tests/common.rs&lt;/em&gt; file, the section in the test output will no longer appear. Files in subdirectories of the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t get compiled as separate crates or have sections in the test output.</source>
          <target state="translated">为了避免 &lt;code&gt;common&lt;/code&gt; 出现在测试输出，而不是创建&lt;em&gt;测试/ common.rs&lt;/em&gt;，我们将创建&lt;em&gt;测试/普通/ mod.rs&lt;/em&gt;。这是Rust也可以理解的另一种命名约定。用这种方式命名文件告诉Rust不要将 &lt;code&gt;common&lt;/code&gt; 模块视为集成测试文件。当我们将 &lt;code&gt;setup&lt;/code&gt; 功能代码移至&lt;em&gt;tests / common / mod.rs&lt;/em&gt;并删除&lt;em&gt;tests / common.rs&lt;/em&gt;文件时，测试输出中的部分将不再出现。&lt;em&gt;测试&lt;/em&gt;目录子目录中的文件不会被编译为单独的板条箱，也不会在测试输出中包含节。</target>
        </trans-unit>
        <trans-unit id="3621c2a13fc7da454e2221c729cf687e93b1bda8" translate="yes" xml:space="preserve">
          <source>To avoid it, you have to replace the non-constant value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7a1a1787370230342d01e7d26cc5eb0fdaf231" translate="yes" xml:space="preserve">
          <source>To avoid the error there are a couple of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1645dd8754fa06f0f760253ea0a8f05162d861bf" translate="yes" xml:space="preserve">
          <source>To avoid this error, first bind the temporary to a named local variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ceede3cc5738536ea015edb67ed85c3d3dcd2e" translate="yes" xml:space="preserve">
          <source>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</source>
          <target state="translated">为了避免这个错误,你必须只保留其中的一个,而删除其他的。所以,让我们拿我们的例子来修复它。</target>
        </trans-unit>
        <trans-unit id="a30b99a191595831b8cb7e0383bc895012a3666a" translate="yes" xml:space="preserve">
          <source>To avoid this kind of error, ensure that at least one local type is referenced by the &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">为了避免这种错误，请确保 &lt;code&gt;impl&lt;/code&gt; 引用了至少一个本地类型：</target>
        </trans-unit>
        <trans-unit id="a83579bf275c61511e259b0f6a5393712638d88c" translate="yes" xml:space="preserve">
          <source>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</source>
          <target state="translated">为了避免这些问题,你必须让类型正确匹配。所以我们可以像这样修复前面的例子。</target>
        </trans-unit>
        <trans-unit id="8cca79e59af2d0e450f9f7893d8b74973a17a0c1" translate="yes" xml:space="preserve">
          <source>To be able to index into a type it needs to implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait. Example:</source>
          <target state="translated">为了能够索引到类型，它需要实现 &lt;code&gt;std::ops::Index&lt;/code&gt; 特性。例：</target>
        </trans-unit>
        <trans-unit id="e0c4569eca23f12e74ce8e43ea0b16ae30221104" translate="yes" xml:space="preserve">
          <source>To be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.</source>
          <target state="translated">要说明的是:大多数功能将在所有版本上都可用。使用任何Rust版本的开发者都会随着新的稳定版本的发布而继续看到改进。然而,在某些情况下,主要是当新的关键字被添加时,一些新功能可能只在以后的版本中可用。如果您想利用这些功能,您需要切换版本。</target>
        </trans-unit>
        <trans-unit id="28519d7825ab9ef768276a220fcc5248c6cfd08d" translate="yes" xml:space="preserve">
          <source>To be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.</source>
          <target state="translated">一个匹配器必须满足以下三个不变量才有效。FIRST和FOLLOW的定义将在后面描述。</target>
        </trans-unit>
        <trans-unit id="4dcb6216e57dabede5c512636b8402fc6577f67d" translate="yes" xml:space="preserve">
          <source>To better understand how these work in Rust, read the &lt;a href=&quot;book/ch13-01-closures&quot;&gt;Closures&lt;/a&gt; chapter of the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27f02149ea4da378573490ec467ba6b8b5c842f" translate="yes" xml:space="preserve">
          <source>To better understand why we need two separate loops, imagine a scenario with two workers. If we used a single loop to iterate through each worker, on the first iteration a terminate message would be sent down the channel and &lt;code&gt;join&lt;/code&gt; called on the first worker&amp;rsquo;s thread. If that first worker was busy processing a request at that moment, the second worker would pick up the terminate message from the channel and shut down. We would be left waiting on the first worker to shut down, but it never would because the second thread picked up the terminate message. Deadlock!</source>
          <target state="translated">为了更好地理解为什么我们需要两个单独的循环，请设想一个有两个工作人员的场景。如果我们使用单个循环迭代每个工作程序，则在第一个迭代中，终止消息将在通道上发送，并在第一个工作程序的线程上调用 &lt;code&gt;join&lt;/code&gt; 。如果第一位员工当时正忙于处理请求，则第二位员工将从通道中接收终止消息并关闭。我们将等待第一个工作程序关闭，但绝不会因为第二个线程接收到了终止消息。僵局！</target>
        </trans-unit>
        <trans-unit id="a92bd1b796549d070a95e516f74d8da028284983" translate="yes" xml:space="preserve">
          <source>To bind the matched value of a pattern to a variable, use the syntax &lt;code&gt;variable @ subpattern&lt;/code&gt;. For example, the following binds the value 2 to &lt;code&gt;e&lt;/code&gt; (not the entire range: the range here is a range subpattern).</source>
          <target state="translated">要将模式的匹配值绑定到变量，请使用语法 &lt;code&gt;variable @ subpattern&lt;/code&gt; 。例如，以下内容将值2绑定到 &lt;code&gt;e&lt;/code&gt; （而不是整个范围：此​​处的范围是范围子模式）。</target>
        </trans-unit>
        <trans-unit id="b830c9413c38579d4ef7795bcf7bbde269208939" translate="yes" xml:space="preserve">
          <source>To build or modify paths, use &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要构建或修改路径，请使用&lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bfa1e223892bc7e4bd4f7e711edfd1f7972be85d" translate="yes" xml:space="preserve">
          <source>To calculate the layout of a &lt;code&gt;#[repr(C)]&lt;/code&gt; structure and the offsets of the fields from its fields' layouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a716f5c06d1b56904d9c9ecdfaef8a89e71a7435" translate="yes" xml:space="preserve">
          <source>To calculate the value of &lt;code&gt;prediction&lt;/code&gt;, this code iterates through each of the 12 values in &lt;code&gt;coefficients&lt;/code&gt; and uses the &lt;code&gt;zip&lt;/code&gt; method to pair the coefficient values with the previous 12 values in &lt;code&gt;buffer&lt;/code&gt;. Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum &lt;code&gt;qlp_shift&lt;/code&gt; bits to the right.</source>
          <target state="translated">为了计算 &lt;code&gt;prediction&lt;/code&gt; 值，此代码循环访问 &lt;code&gt;coefficients&lt;/code&gt; 中的12个值，并使用 &lt;code&gt;zip&lt;/code&gt; 方法将系数值与 &lt;code&gt;buffer&lt;/code&gt; 的前12个值配对。然后，对于每一对，我们将这些值相乘，对所有结果求和，然后将求和 &lt;code&gt;qlp_shift&lt;/code&gt; 位中的位右移。</target>
        </trans-unit>
        <trans-unit id="e1e36c60ac0b0cf3c0b11863470e32d28a059d98" translate="yes" xml:space="preserve">
          <source>To call the &lt;code&gt;fly&lt;/code&gt; methods from either the &lt;code&gt;Pilot&lt;/code&gt; trait or the &lt;code&gt;Wizard&lt;/code&gt; trait, we need to use more explicit syntax to specify which &lt;code&gt;fly&lt;/code&gt; method we mean. Listing 19-18 demonstrates this syntax.</source>
          <target state="translated">要从&amp;ldquo; &lt;code&gt;Pilot&lt;/code&gt; 特征或&amp;ldquo; &lt;code&gt;Wizard&lt;/code&gt; 特征调用 &lt;code&gt;fly&lt;/code&gt; 方法，我们需要使用更明确的语法来指定我们所指的 &lt;code&gt;fly&lt;/code&gt; 方法。清单19-18演示了这种语法。</target>
        </trans-unit>
        <trans-unit id="5c07c5eaca75954c044b220e0d9378c6ce45b1a4" translate="yes" xml:space="preserve">
          <source>To call this associated function, we use the &lt;code&gt;::&lt;/code&gt; syntax with the struct name; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; is an example. This function is namespaced by the struct: the &lt;code&gt;::&lt;/code&gt; syntax is used for both associated functions and namespaces created by modules. We&amp;rsquo;ll discuss modules in Chapter 7.</source>
          <target state="translated">要调用此关联函数，我们将 &lt;code&gt;::&lt;/code&gt; 语法与结构名一起使用； &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; 是一个例子。这个功能是通过该结构的命名空间：在 &lt;code&gt;::&lt;/code&gt; 语法用于通过模块创建的两个相关联的功能和命名空间。我们将在第7章中讨论模块。</target>
        </trans-unit>
        <trans-unit id="191c93d8beeacd6897f106d1c47af3f257c7dd5f" translate="yes" xml:space="preserve">
          <source>To call this code with only those types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we can add &lt;code&gt;Copy&lt;/code&gt; to the trait bounds of &lt;code&gt;T&lt;/code&gt;! Listing 10-15 shows the complete code of a generic &lt;code&gt;largest&lt;/code&gt; function that will compile as long as the types of the values in the slice that we pass into the function implement the &lt;code&gt;PartialOrd&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Copy&lt;/code&gt; traits, like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; do.</source>
          <target state="translated">要仅使用实现 &lt;code&gt;Copy&lt;/code&gt; 特征的那些类型来调用此代码，我们可以将 &lt;code&gt;Copy&lt;/code&gt; 添加到 &lt;code&gt;T&lt;/code&gt; 的特征边界！清单10-15显示了一个通用的 &lt;code&gt;largest&lt;/code&gt; 函数的完整代码，只要我们传递给该函数的slice中的值的类型实现 &lt;code&gt;PartialOrd&lt;/code&gt; &lt;em&gt;和&lt;/em&gt; &lt;code&gt;Copy&lt;/code&gt; 特性，就可以编译该代码，例如 &lt;code&gt;i32&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; do。</target>
        </trans-unit>
        <trans-unit id="2ae7caef9479d77c77a3d3a0a7f430defd27a454" translate="yes" xml:space="preserve">
          <source>To change the value that the mutable reference refers to, we have to use the dereference operator (&lt;code&gt;*&lt;/code&gt;) to get to the value in &lt;code&gt;i&lt;/code&gt; before we can use the &lt;code&gt;+=&lt;/code&gt; operator. We&amp;rsquo;ll talk more about the dereference operator in the &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;Following the Pointer to the Value with the Dereference Operator&amp;rdquo;&lt;/a&gt; section of Chapter 15.</source>
          <target state="translated">要更改可变引用所引用的值，必须先使用解引用运算符（ &lt;code&gt;*&lt;/code&gt; ）来获取 &lt;code&gt;i&lt;/code&gt; 中的值，然后才能使用 &lt;code&gt;+=&lt;/code&gt; 运算符。我们将在第15章的&lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;使用指向&lt;/a&gt;引用运算符跟随指针到值&amp;rdquo;部分中详细讨论指向引用运算符。</target>
        </trans-unit>
        <trans-unit id="ff93ea5d521caed491ca6edf931b71effa3ca726" translate="yes" xml:space="preserve">
          <source>To check whether you have Rust installed correctly, open a shell and enter this line:</source>
          <target state="translated">要检查你是否正确安装了Rust,打开一个shell并输入这一行。</target>
        </trans-unit>
        <trans-unit id="b81a5a29868dab97f44f48c2bd716ec3edc16d7e" translate="yes" xml:space="preserve">
          <source>To combine &lt;code&gt;repr(transparent)&lt;/code&gt; with type parameters, &lt;code&gt;PhantomData&lt;/code&gt; may be useful:</source>
          <target state="translated">要将 &lt;code&gt;repr(transparent)&lt;/code&gt; 与类型参数结合使用， &lt;code&gt;PhantomData&lt;/code&gt; 可能有用：</target>
        </trans-unit>
        <trans-unit id="ac3f03b22205947cc54e2019b2f0993969841a80" translate="yes" xml:space="preserve">
          <source>To confuse things further, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;on the Web&lt;/a&gt;&lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, and &lt;code&gt;windows-1252&lt;/code&gt; are all aliases for a superset of Windows-1252 that fills the remaining blanks with corresponding C0 and C1 control codes.</source>
          <target state="translated">更令人困惑的是，&lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;在Web &lt;/a&gt; &lt;code&gt;ascii&lt;/code&gt; 上， &lt;code&gt;iso-8859-1&lt;/code&gt; 和 &lt;code&gt;windows-1252&lt;/code&gt; 都是Windows-1252超集的别名，该超集用相应的C0和C1控制代码填充了其余空白。</target>
        </trans-unit>
        <trans-unit id="9e961e97b1bab5bb4d05da5fe7c2fc74357a8b93" translate="yes" xml:space="preserve">
          <source>To consume the old state, the &lt;code&gt;request_review&lt;/code&gt; method needs to take ownership of the state value. This is where the &lt;code&gt;Option&lt;/code&gt; in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; comes in: we call the &lt;code&gt;take&lt;/code&gt; method to take the &lt;code&gt;Some&lt;/code&gt; value out of the &lt;code&gt;state&lt;/code&gt; field and leave a &lt;code&gt;None&lt;/code&gt; in its place, because Rust doesn&amp;rsquo;t let us have unpopulated fields in structs. This lets us move the &lt;code&gt;state&lt;/code&gt; value out of &lt;code&gt;Post&lt;/code&gt; rather than borrowing it. Then we&amp;rsquo;ll set the post&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; value to the result of this operation.</source>
          <target state="translated">要使用旧状态， &lt;code&gt;request_review&lt;/code&gt; 方法需要取得状态值的所有权。这是该 &lt;code&gt;Option&lt;/code&gt; 的 &lt;code&gt;state&lt;/code&gt; 的领域 &lt;code&gt;Post&lt;/code&gt; 进来：我们所说的 &lt;code&gt;take&lt;/code&gt; 方法采取 &lt;code&gt;Some&lt;/code&gt; 价值出来的 &lt;code&gt;state&lt;/code&gt; 领域，并留下一个 &lt;code&gt;None&lt;/code&gt; 在它的位置，因为锈病不会让我们在结构无人居住领域。这使我们可以将 &lt;code&gt;state&lt;/code&gt; 值移出 &lt;code&gt;Post&lt;/code&gt; 而不是借用它。然后，我们将帖子的 &lt;code&gt;state&lt;/code&gt; 值设置为此操作的结果。</target>
        </trans-unit>
        <trans-unit id="f337e083c37a19b6c9f78383e9d486a4274f1380" translate="yes" xml:space="preserve">
          <source>To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise &quot;you used a private item of another module and weren't allowed to.&quot;</source>
          <target state="translated">为了控制接口是否可以跨模块使用,Rust会检查每一个项的使用情况,看是否应该被允许。这时就会产生隐私警告,否则就会出现 &quot;你使用了另一个模块的私有项目,但不允许 &quot;的情况。</target>
        </trans-unit>
        <trans-unit id="ba21f5abea5c571067a1a7d57de3d3aa5bc54641" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;../string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">要将单个值转换为字符串，请使用&lt;a href=&quot;../string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt;方法。这将使用&lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;格式特征。</target>
        </trans-unit>
        <trans-unit id="3cb338cb9ed195af952f18624a8d65c1ca64787f" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">要将单个值转换为字符串，请使用&lt;a href=&quot;string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt;方法。这将使用&lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;格式特征。</target>
        </trans-unit>
        <trans-unit id="015234ea3f6220712aedf5ea26711d734042f76e" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;match&lt;/code&gt; expression that compares the values of the outer &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We&amp;rsquo;ll talk about match guards later in the &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;Extra Conditionals with Match Guards&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">要创建一个比较外部 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的值的 &lt;code&gt;match&lt;/code&gt; 表达式，而不是引入阴影变量，我们需要使用匹配保护条件。稍后，我们将在&lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;带有&lt;/a&gt;防卫队​​的附加条件&amp;rdquo;部分中讨论防卫队。</target>
        </trans-unit>
        <trans-unit id="d6a361bf034a44065bf4d983adf9bd5159e505a7" translate="yes" xml:space="preserve">
          <source>To create a new thread, we call the &lt;code&gt;thread::spawn&lt;/code&gt; function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</source>
          <target state="translated">为了创建一个新线程，我们调用 &lt;code&gt;thread::spawn&lt;/code&gt; 函数，并给它传递一个闭包（我们在第13章中讨论了闭包），其中包含了我们要在新线程中运行的代码。清单16-1中的示例打印主线程中的一些文本，以及新线程中的其他文本：</target>
        </trans-unit>
        <trans-unit id="aa89b2295fcdc6f9c080aa3a4a8e8468c77980e1" translate="yes" xml:space="preserve">
          <source>To create a new, empty vector, we can call the &lt;code&gt;Vec::new&lt;/code&gt; function, as shown in Listing 8-1.</source>
          <target state="translated">要创建一个新的空向量，我们可以调用 &lt;code&gt;Vec::new&lt;/code&gt; 函数，如清单8-1所示。</target>
        </trans-unit>
        <trans-unit id="1a88aa76c7ad4f90214c55053637e980f11dd3a9" translate="yes" xml:space="preserve">
          <source>To create a vector and then add elements to it, we can use the &lt;code&gt;push&lt;/code&gt; method, as shown in Listing 8-3.</source>
          <target state="translated">要创建一个向量，然后向其中添加元素，我们可以使用 &lt;code&gt;push&lt;/code&gt; 方法，如清单8-3所示。</target>
        </trans-unit>
        <trans-unit id="00c0015adacecd8350d6133979871ae1b1edfe94" translate="yes" xml:space="preserve">
          <source>To define a &lt;code&gt;Point&lt;/code&gt; struct where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we can change the definition of &lt;code&gt;Point&lt;/code&gt; to be generic over types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">要定义 &lt;code&gt;Point&lt;/code&gt; 结构，其中 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都是泛型但可以具有不同的类型，我们可以使用多个泛型类型参数。例如，清单10-8，我们可以改变的定义 &lt;code&gt;Point&lt;/code&gt; 到超过类型通用 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 其中 &lt;code&gt;x&lt;/code&gt; 是式 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是类型的 &lt;code&gt;U&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48e3d6adfbf70e45f3b29de0115bced82f45c8ba" translate="yes" xml:space="preserve">
          <source>To define a macro, you use the &lt;code&gt;macro_rules!&lt;/code&gt; construct. Let&amp;rsquo;s explore how to use &lt;code&gt;macro_rules!&lt;/code&gt; by looking at how the &lt;code&gt;vec!&lt;/code&gt; macro is defined. Chapter 8 covered how we can use the &lt;code&gt;vec!&lt;/code&gt; macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:</source>
          <target state="translated">要定义宏，请使用 &lt;code&gt;macro_rules!&lt;/code&gt; 构造。让我们探索如何使用 &lt;code&gt;macro_rules!&lt;/code&gt; 通过看如何 &lt;code&gt;vec!&lt;/code&gt; 宏已定义。第8章介绍了如何使用 &lt;code&gt;vec!&lt;/code&gt; 宏以创建具有特定值的新向量。例如，下面的宏创建一个包含三个整数的新向量：</target>
        </trans-unit>
        <trans-unit id="0305c11d131bdcb2f62d25c1e047d31c7b279a29" translate="yes" xml:space="preserve">
          <source>To define a struct, we enter the keyword &lt;code&gt;struct&lt;/code&gt; and name the entire struct. A struct&amp;rsquo;s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call &lt;em&gt;fields&lt;/em&gt;. For example, Listing 5-1 shows a struct that stores information about a user account.</source>
          <target state="translated">要定义一个结构，我们输入关键字 &lt;code&gt;struct&lt;/code&gt; 并命名整个结构。结构的名称应描述分组在一起的数据的重要性。然后，在大括号内，定义数据段的名称和类型，我们将其称为&lt;em&gt;field&lt;/em&gt;。例如，清单5-1显示了一个存储有关用户帐户信息的结构。</target>
        </trans-unit>
        <trans-unit id="8f9b83d2cc8d6fc88b967504ac913c99c3032360" translate="yes" xml:space="preserve">
          <source>To define a tuple struct, start with the &lt;code&gt;struct&lt;/code&gt; keyword and the struct name followed by the types in the tuple. For example, here are definitions and usages of two tuple structs named &lt;code&gt;Color&lt;/code&gt; and &lt;code&gt;Point&lt;/code&gt;:</source>
          <target state="translated">要定义元组结构，请以 &lt;code&gt;struct&lt;/code&gt; 关键字和结构名称开头，后跟元组中的类型。例如，以下是两个名为 &lt;code&gt;Color&lt;/code&gt; 和 &lt;code&gt;Point&lt;/code&gt; 的元组结构的定义和用法：</target>
        </trans-unit>
        <trans-unit id="bf22e9ab26d9ba6ee6b2e46fe0b19d5124fc0343" translate="yes" xml:space="preserve">
          <source>To define the function within the context of &lt;code&gt;Rectangle&lt;/code&gt;, we start an &lt;code&gt;impl&lt;/code&gt; (implementation) block. Then we move the &lt;code&gt;area&lt;/code&gt; function within the &lt;code&gt;impl&lt;/code&gt; curly brackets and change the first (and in this case, only) parameter to be &lt;code&gt;self&lt;/code&gt; in the signature and everywhere within the body. In &lt;code&gt;main&lt;/code&gt;, where we called the &lt;code&gt;area&lt;/code&gt; function and passed &lt;code&gt;rect1&lt;/code&gt; as an argument, we can instead use &lt;em&gt;method syntax&lt;/em&gt; to call the &lt;code&gt;area&lt;/code&gt; method on our &lt;code&gt;Rectangle&lt;/code&gt; instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</source>
          <target state="translated">为了在 &lt;code&gt;Rectangle&lt;/code&gt; 的上下文中定义函数，我们启动一个 &lt;code&gt;impl&lt;/code&gt; （实现）块。然后，我们将 &lt;code&gt;area&lt;/code&gt; 函数移动到 &lt;code&gt;impl&lt;/code&gt; 大括号内，并将第一个（在这种情况下，仅）参数更改为签名中以及正文中各处的 &lt;code&gt;self&lt;/code&gt; 。在 &lt;code&gt;main&lt;/code&gt; 中，我们调用了 &lt;code&gt;area&lt;/code&gt; 函数并传递了 &lt;code&gt;rect1&lt;/code&gt; 作为参数，我们可以改用&lt;em&gt;方法语法&lt;/em&gt;在 &lt;code&gt;Rectangle&lt;/code&gt; 实例上调用 &lt;code&gt;area&lt;/code&gt; 方法。方法的语法在实例之后：我们在方法名称，括号和任何参数后面添加一个点。</target>
        </trans-unit>
        <trans-unit id="2de6b544c44b76668f6d2936d8d501f7f9f3abad" translate="yes" xml:space="preserve">
          <source>To demonstrate how to run a subset of tests, we&amp;rsquo;ll create three tests for our &lt;code&gt;add_two&lt;/code&gt; function, as shown in Listing 11-11, and choose which ones to run.</source>
          <target state="translated">为了演示如何运行测试的子集，我们将为 &lt;code&gt;add_two&lt;/code&gt; 函数创建三个测试，如清单11-11所示，然后选择要运行的测试。</target>
        </trans-unit>
        <trans-unit id="e75dc3dfe6b153a0ceea282766b5c4d1615452e1" translate="yes" xml:space="preserve">
          <source>To demonstrate, let&amp;rsquo;s create an iterator that will only ever count from 1 to 5. First, we&amp;rsquo;ll create a struct to hold some values. Then we&amp;rsquo;ll make this struct into an iterator by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait and using the values in that implementation.</source>
          <target state="translated">为了演示，让我们创建一个只会从1到5计数的迭代器。首先，我们将创建一个结构来保存一些值。然后，通过实现 &lt;code&gt;Iterator&lt;/code&gt; trait并使用该实现中的值，使该结构成为迭代器。</target>
        </trans-unit>
        <trans-unit id="b6b548838142d67d34f12bfbc64f7cdb12a47cc6" translate="yes" xml:space="preserve">
          <source>To determine how much space to allocate for a &lt;code&gt;Message&lt;/code&gt; value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that &lt;code&gt;Message::Quit&lt;/code&gt; doesn&amp;rsquo;t need any space, &lt;code&gt;Message::Move&lt;/code&gt; needs enough space to store two &lt;code&gt;i32&lt;/code&gt; values, and so forth. Because only one variant will be used, the most space a &lt;code&gt;Message&lt;/code&gt; value will need is the space it would take to store the largest of its variants.</source>
          <target state="translated">为了确定为 &lt;code&gt;Message&lt;/code&gt; 值分配多少空间，Rust会遍历每个变体以查看哪个变体需要最多的空间。 Rust看到 &lt;code&gt;Message::Quit&lt;/code&gt; 不需要任何空间， &lt;code&gt;Message::Move&lt;/code&gt; 需要足够的空间来存储两个 &lt;code&gt;i32&lt;/code&gt; 值，依此类推。因为将仅使用一个变体，所以 &lt;code&gt;Message&lt;/code&gt; 值所需的最大空间就是存储最大变体所需的空间。</target>
        </trans-unit>
        <trans-unit id="375df8edff8c14a24952e9e1d54e255a42b357a9" translate="yes" xml:space="preserve">
          <source>To determine if a &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, we need to check if &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. However, to do this check, we need to determine that &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. To determine this, we check if &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, and so on. This is clearly a recursive requirement that can't be resolved directly.</source>
          <target state="translated">要确定 &lt;code&gt;T&lt;/code&gt; 是否为 &lt;code&gt;Foo&lt;/code&gt; ，我们需要检查 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 是否为 &lt;code&gt;Foo&lt;/code&gt; 。但是，要执行此检查，我们需要确定 &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 是 &lt;code&gt;Foo&lt;/code&gt; 。为了确定这一点，我们检查 &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 是否为 &lt;code&gt;Foo&lt;/code&gt; ，依此类推。显然，这是一个递归要求，无法直接解决。</target>
        </trans-unit>
        <trans-unit id="b8666f35753eb530d957bee0ef54848c41571aca" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要确定 &lt;code&gt;Duration&lt;/code&gt; 表示的总秒数，请结合使用 &lt;code&gt;as_secs&lt;/code&gt; 和&lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="08d2c31864b299072e74b4018700dfb17575ecb3" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c73fc588227a5e5b304d8e85115a9b2d547b13e" translate="yes" xml:space="preserve">
          <source>To determine whether to use loops or iterators, you need to know which version of our &lt;code&gt;search&lt;/code&gt; functions is faster: the version with an explicit &lt;code&gt;for&lt;/code&gt; loop or the version with iterators.</source>
          <target state="translated">要确定是使用循环还是迭代器，您需要知道 &lt;code&gt;search&lt;/code&gt; 功能的哪个版本更快：带显式 &lt;code&gt;for&lt;/code&gt; 循环的版本或带迭代器的版本。</target>
        </trans-unit>
        <trans-unit id="235f6ddc8fb93b9bc27bd450e93516c6f056381f" translate="yes" xml:space="preserve">
          <source>To disambiguate and tell Rust that we want to use the implementation of &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt;, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</source>
          <target state="translated">为了消除歧义并告诉Rust我们要使用 &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt; 的实现，我们需要使用完全限定的语法。清单19-21演示了如何使用完全限定的语法。</target>
        </trans-unit>
        <trans-unit id="f6bc5e83e5f978fc7521ec1ad0ec48fc0bc1e6d4" translate="yes" xml:space="preserve">
          <source>To do this in a language with inheritance, we might define a class named &lt;code&gt;Component&lt;/code&gt; that has a method named &lt;code&gt;draw&lt;/code&gt; on it. The other classes, such as &lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Image&lt;/code&gt;, and &lt;code&gt;SelectBox&lt;/code&gt;, would inherit from &lt;code&gt;Component&lt;/code&gt; and thus inherit the &lt;code&gt;draw&lt;/code&gt; method. They could each override the &lt;code&gt;draw&lt;/code&gt; method to define their custom behavior, but the framework could treat all of the types as if they were &lt;code&gt;Component&lt;/code&gt; instances and call &lt;code&gt;draw&lt;/code&gt; on them. But because Rust doesn&amp;rsquo;t have inheritance, we need another way to structure the &lt;code&gt;gui&lt;/code&gt; library to allow users to extend it with new types.</source>
          <target state="translated">要使用具有继承性的语言来执行此操作，我们可以定义一个名为 &lt;code&gt;Component&lt;/code&gt; 的类，该类具有一个名为 &lt;code&gt;draw&lt;/code&gt; 的方法。其他类（例如 &lt;code&gt;Button&lt;/code&gt; ， &lt;code&gt;Image&lt;/code&gt; 和 &lt;code&gt;SelectBox&lt;/code&gt; )将从 &lt;code&gt;Component&lt;/code&gt; 继承，从而继承 &lt;code&gt;draw&lt;/code&gt; 方法。他们可以在每个覆盖的 &lt;code&gt;draw&lt;/code&gt; 方法来定义自己的定制行为，但框架可以治疗所有类型的，好像他们是 &lt;code&gt;Component&lt;/code&gt; 实例并调用 &lt;code&gt;draw&lt;/code&gt; 他们。但是因为Rust没有继承，所以我们需要另一种方式来构造 &lt;code&gt;gui&lt;/code&gt; 库，以允许用户使用新类型扩展它。</target>
        </trans-unit>
        <trans-unit id="4978131923d35532be220aa91636f57efe0f7f12" translate="yes" xml:space="preserve">
          <source>To easily implement the Clone trait, you can also use &lt;code&gt;#[derive(Clone)]&lt;/code&gt;. Example:</source>
          <target state="translated">为了轻松实现Clone特质，您还可以使用 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="d0cd2dd965d6ad9f646e83059dd95c728c0a97cf" translate="yes" xml:space="preserve">
          <source>To eliminate this duplication, we can create an abstraction by defining a function that operates on any list of integers given to it in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.</source>
          <target state="translated">为了消除这种重复,我们可以通过定义一个函数来创建一个抽象的概念,这个函数可以对参数中给它的任何整数列表进行操作。这个解决方案使我们的代码更加清晰,让我们可以抽象地表达在列表中寻找最大数字的概念。</target>
        </trans-unit>
        <trans-unit id="29cf48fa5d156f2e83366c6a4eab852452303d3f" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;minigrep&lt;/code&gt; to read the values of command line arguments we pass to it, we&amp;rsquo;ll need a function provided in Rust&amp;rsquo;s standard library, which is &lt;code&gt;std::env::args&lt;/code&gt;. This function returns an iterator of the command line arguments that were given to &lt;code&gt;minigrep&lt;/code&gt;. We&amp;rsquo;ll cover iterators fully in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the &lt;code&gt;collect&lt;/code&gt; method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.</source>
          <target state="translated">为了使 &lt;code&gt;minigrep&lt;/code&gt; 能够读取传递给它的命令行参数的值，我们需要Rust的标准库中提供的函数 &lt;code&gt;std::env::args&lt;/code&gt; 。此函数返回给 &lt;code&gt;minigrep&lt;/code&gt; 的命令行参数的迭代器。我们将在&lt;a href=&quot;ch13-00-functional-features&quot;&gt;第13章中&lt;/a&gt;全面介绍迭代器。现在，您只需要了解有关迭代器的两个细节：迭代器会生成一系列值，并且我们可以在迭代器上调用 &lt;code&gt;collect&lt;/code&gt; 方法，以将其转换为一个集合，例如向量，其中包含迭代器生成的所有元素。</target>
        </trans-unit>
        <trans-unit id="ad43deb7c3d4847ed4f9b3c47149e285bd2d149c" translate="yes" xml:space="preserve">
          <source>To enable multiple ownership, Rust has a type called &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, which is an abbreviation for &lt;em&gt;reference counting&lt;/em&gt;. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</source>
          <target state="translated">为了启用多重所有权，Rust具有一个称为 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 的类型，这是&lt;em&gt;引用计数&lt;/em&gt;的缩写。所述 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 型跟踪引用的数目的到其确定值是否仍在使用的值。如果某个值的引用为零，则可以清除该值，而不会导致任何引用无效。</target>
        </trans-unit>
        <trans-unit id="e59e1050701d5494b23014e46f9317fad2eac0b0" translate="yes" xml:space="preserve">
          <source>To enable this feature on a nightly version of rustc, add the &lt;code&gt;const_fn&lt;/code&gt; feature flag:</source>
          <target state="translated">要在每晚版本的rustc上启用此功能，请添加 &lt;code&gt;const_fn&lt;/code&gt; 功能标记：</target>
        </trans-unit>
        <trans-unit id="d24a8c41c8e51812d2f6a3d4df4d4bc30f42fd94" translate="yes" xml:space="preserve">
          <source>To ensure memory safety, there&amp;rsquo;s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers &lt;code&gt;s1&lt;/code&gt; to no longer be valid and, therefore, Rust doesn&amp;rsquo;t need to free anything when &lt;code&gt;s1&lt;/code&gt; goes out of scope. Check out what happens when you try to use &lt;code&gt;s1&lt;/code&gt; after &lt;code&gt;s2&lt;/code&gt; is created; it won&amp;rsquo;t work:</source>
          <target state="translated">为了确保内存安全，在Rust中，在这种情况下会发生的事情还有一个细节。Rust不会尝试复制分配的内存，而是认为 &lt;code&gt;s1&lt;/code&gt; 不再有效，因此，当 &lt;code&gt;s1&lt;/code&gt; 超出范围时，Rust不需要释放任何内容。检查创建 &lt;code&gt;s2&lt;/code&gt; 之后尝试使用 &lt;code&gt;s1&lt;/code&gt; 会发生什么情况；它不起作用：</target>
        </trans-unit>
        <trans-unit id="44d8c4aeacd237bf73174a5745772ccb9ea1f421" translate="yes" xml:space="preserve">
          <source>To ensure soundness, Safe Rust is restricted enough that it can be automatically checked. Sometimes, however, it is necessary to write code that is correct for reasons which are too clever for the compiler to understand. In those cases, you need to use Unsafe Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccd9133d33f00e1b04fd5409b4bd62ab4182d4d" translate="yes" xml:space="preserve">
          <source>To extend a type without breaking existing code</source>
          <target state="translated">要在不破坏现有代码的情况下扩展一个类型</target>
        </trans-unit>
        <trans-unit id="986aa5a06f6c7eab4fbf8758ab21e34c28998b7b" translate="yes" xml:space="preserve">
          <source>To find the largest number in two different lists of numbers, we can duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.</source>
          <target state="translated">为了在两个不同的数字列表中找到最大的数字,我们可以重复清单10-1中的代码,并在程序中两个不同的地方使用相同的逻辑,如清单10-2所示。</target>
        </trans-unit>
        <trans-unit id="05412e512ad05fb982373163c001384a6dc6dc41" translate="yes" xml:space="preserve">
          <source>To fix such code, put them in an extern &quot;C&quot; block:</source>
          <target state="translated">要修正这样的代码,把它们放在一个外部的 &quot;C &quot;块中。</target>
        </trans-unit>
        <trans-unit id="3f641101a15aa5663f425af7eca864860358c2b4" translate="yes" xml:space="preserve">
          <source>To fix the compiler error in Listing 16-3, we can use the error message&amp;rsquo;s advice:</source>
          <target state="translated">要修复清单16-3中的编译器错误，我们可以使用错误消息的建议：</target>
        </trans-unit>
        <trans-unit id="35eb0225e4203818949db81d35253471e9bc1946" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove patterns (&lt;code&gt;_&lt;/code&gt; is allowed though). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4b2f5b453763912d29b2bc8e5d29a39885b8b2" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove the duplicate declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a982630d24bce9f0c2bacf99524398a473cc7ece" translate="yes" xml:space="preserve">
          <source>To fix the previous code example, we derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a70249adaf4eb50343b8e3cb8c112aee0c4394d" translate="yes" xml:space="preserve">
          <source>To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using &lt;code&gt;let&lt;/code&gt;, we can use &lt;code&gt;if let&lt;/code&gt;. Then if the pattern doesn&amp;rsquo;t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</source>
          <target state="translated">为了解决需要可重构模式的不可重构模式的问题，我们可以更改使用该模式的代码：代替使用 &lt;code&gt;let&lt;/code&gt; ，可以使用 &lt;code&gt;if let&lt;/code&gt; 。然后，如果模式不匹配，则代码将跳过大括号中的代码，从而提供一种有效地继续执行的方法。清单18-9显示了如何修复清单18-8中的代码。</target>
        </trans-unit>
        <trans-unit id="3d38f12fb6a882b38564fce2f1f7c9cb9d1796dd" translate="yes" xml:space="preserve">
          <source>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</source>
          <target state="translated">要解决这个问题,可以删除未知的元项目,或者如果你提供了错误的名称,可以重新命名它。</target>
        </trans-unit>
        <trans-unit id="ff15ef440d8fd65fc53847fcd7d27134b37684e0" translate="yes" xml:space="preserve">
          <source>To fix the problem, remove all but one of the meta items with the same key.</source>
          <target state="translated">要解决这个问题,除了一个相同键的元项目外,其他都要删除。</target>
        </trans-unit>
        <trans-unit id="ea6969ed4bf2de9ff5e1987bde2a5974361798c0" translate="yes" xml:space="preserve">
          <source>To fix this and consume the iterator, we&amp;rsquo;ll use the &lt;code&gt;collect&lt;/code&gt; method, which we used in Chapter 12 with &lt;code&gt;env::args&lt;/code&gt; in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.</source>
          <target state="translated">为了解决这个问题并使用迭代器，我们将使用 &lt;code&gt;collect&lt;/code&gt; 方法，该方法在第12章中与清单12-1中的 &lt;code&gt;env::args&lt;/code&gt; 一起使用。此方法使用迭代器，并将结果值收集到收集数据类型中。</target>
        </trans-unit>
        <trans-unit id="7ddafefb4eada6e20a8873619c096afec9d9e821" translate="yes" xml:space="preserve">
          <source>To fix this error we need to spell out &lt;code&gt;Self&lt;/code&gt; to &lt;code&gt;S&amp;lt;'a&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00f739419dcbd64823b1ea3abe0a10a9be4cbba" translate="yes" xml:space="preserve">
          <source>To fix this error, add a &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b190c393f2e104afe11b9ff6d75785abc13b4fac" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing digits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f9240b7df9e2cdcc942864074f152c08f49afd" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing double quote at the end of the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a45c1a4916fd6685c913af98c59a6ca44a92d9" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing quote:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bc23db223a3a7adb6fd2ea01135a7a51e21b23" translate="yes" xml:space="preserve">
          <source>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</source>
          <target state="translated">要解决这个错误,请检查你没有拼错字段的名称,或者字段确实存在。例子:</target>
        </trans-unit>
        <trans-unit id="75b750ac4b7d89ba0d9d76afc4c969c263359a34" translate="yes" xml:space="preserve">
          <source>To fix this error, compile your code for a Rust target that supports the TrustZone-M extension. The current possible targets are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f0d68c9258ec3385682a9e7888b4d82a961453" translate="yes" xml:space="preserve">
          <source>To fix this error, declare &lt;code&gt;ss&lt;/code&gt; as mutable by using the &lt;code&gt;mut&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a10ae82ce30bea6273b20c3ae88287f346a01ba" translate="yes" xml:space="preserve">
          <source>To fix this error, declare your entry function with a C ABI, using &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4c03a79b5dd9aa983287afa6ca9be17b72579d" translate="yes" xml:space="preserve">
          <source>To fix this error, don't try to cast directly between thin and fat pointers.</source>
          <target state="translated">为了解决这个错误,不要尝试在瘦指针和胖指针之间直接投掷。</target>
        </trans-unit>
        <trans-unit id="851cef01fbc24aa508b07321c6a80e736f5740f3" translate="yes" xml:space="preserve">
          <source>To fix this error, either lessen the expected lifetime or find a way to not have to use this reference outside of its current scope (by running the code directly in the same block for example?):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf449e499fd02815621561773f0782493f1f5ff" translate="yes" xml:space="preserve">
          <source>To fix this error, either split into multiple match arms:</source>
          <target state="translated">要解决这个错误,要么拆成多个比赛臂。</target>
        </trans-unit>
        <trans-unit id="4a625dc9e5fa99f625b4f36ca500334a72e9f93e" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d5e036d18215af29bf5d6026ec79c924cc4630" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</source>
          <target state="translated">要解决这个错误,请确保在尝试访问变量之前,你没有任何其他引用。</target>
        </trans-unit>
        <trans-unit id="c41c6753158354db97000bee3e6d1e71d162a5c2" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure the match arm kind is the same as the expression matched.</source>
          <target state="translated">要修复这个错误,请确保匹配臂种类与匹配的表达式相同。</target>
        </trans-unit>
        <trans-unit id="0e0f8c883662f36aaeadf872304efd94871b85a2" translate="yes" xml:space="preserve">
          <source>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</source>
          <target state="translated">要解决这个错误,只需更改绑定的名称,以避免影子以下之一。</target>
        </trans-unit>
        <trans-unit id="547cd595fdb912c2692881e0fc69f7e09c4e06b4" translate="yes" xml:space="preserve">
          <source>To fix this error, just specify the type of the variable. Example:</source>
          <target state="translated">要解决这个错误,只需指定变量的类型。例子:</target>
        </trans-unit>
        <trans-unit id="ac9826f4a5f0aca5be2cbd8435bee957e2a23961" translate="yes" xml:space="preserve">
          <source>To fix this error, just use the same mode in both cases. Generally using &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; where not already used will fix this:</source>
          <target state="translated">要解决此错误，在两种情况下只需使用相同的模式即可。通常在尚未使用的地方使用 &lt;code&gt;ref&lt;/code&gt; 或 &lt;code&gt;ref mut&lt;/code&gt; 可以解决此问题：</target>
        </trans-unit>
        <trans-unit id="f5f3bd9b98cede2f9883569f89f15b8f146e95f8" translate="yes" xml:space="preserve">
          <source>To fix this error, please be sure that the module is in scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130e6cb76ab8ba2e39f9316003d15648f16e824e" translate="yes" xml:space="preserve">
          <source>To fix this error, please check that this type implements this binary operation. Example:</source>
          <target state="translated">要修复这个错误,请检查这个类型是否实现了这个二进制操作。例子:</target>
        </trans-unit>
        <trans-unit id="5f8bccc6c37b14540562ff31ba77c03a4a691b62" translate="yes" xml:space="preserve">
          <source>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</source>
          <target state="translated">为了解决这个错误,请确保结构的所有字段都是公共的,或者实现一个函数以方便实例化。例子:请确保结构的所有字段都是公共的,或者实现一个函数以方便实例化。</target>
        </trans-unit>
        <trans-unit id="342e8c2f7a1ada9b484baabdc9d06d406ca80a54" translate="yes" xml:space="preserve">
          <source>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</source>
          <target state="translated">为了解决这个错误,请在类型上实现一个特质或将其封装在一个结构中。例子:</target>
        </trans-unit>
        <trans-unit id="befadb1ed4ec4a8c074944e9002910bb635c2bda" translate="yes" xml:space="preserve">
          <source>To fix this error, please remove the visibility qualifier when it is not required. Example:</source>
          <target state="translated">为了解决这个错误,请在不需要的时候去掉可见性限定词。例如:</target>
        </trans-unit>
        <trans-unit id="dd5bba6de2aa5f4e39e98433e92b409c0d3ccac5" translate="yes" xml:space="preserve">
          <source>To fix this error, please replace the value with a constant. Example:</source>
          <target state="translated">要解决这个错误,请用一个常数来代替该值。例子:</target>
        </trans-unit>
        <trans-unit id="29332719480b2d3d455368380fd1815d30eebf29" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</source>
          <target state="translated">要修复这个错误,请确认方法名没有拼写错误,并确认你确实实现了正确的特征项。例子:请确认方法名称没有拼错,并确认你确实实现了正确的性状项。</target>
        </trans-unit>
        <trans-unit id="d6526d13f1c406efebc4022cedccc7bfc1d5dbc7" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</source>
          <target state="translated">要修复这个错误,请确认您没有拼错类型名称,您确实声明了它或将它导入到作用域中。例子。</target>
        </trans-unit>
        <trans-unit id="e76357808cad4720013a780f0b9c4aca40fe0097" translate="yes" xml:space="preserve">
          <source>To fix this error, remove the null characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0aa8ad2a46bb3a87624f0ae14dc2151334230f" translate="yes" xml:space="preserve">
          <source>To fix this error, replace the pattern argument with a regular one. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5459bb70fc45530a8171a7e09df41fa4c970e0d5" translate="yes" xml:space="preserve">
          <source>To fix this error, use a concrete type for the const parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca68924d905d97b9f1af1bea1e0a2d8cf16561fb" translate="yes" xml:space="preserve">
          <source>To fix this error, we need to move the &lt;code&gt;Shark&lt;/code&gt; struct inside the &lt;code&gt;Sea&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140824e6ec67ac2a81b7a4c3bb6daa38bc47f6d7" translate="yes" xml:space="preserve">
          <source>To fix this error, you can declare &lt;code&gt;create_some&lt;/code&gt; as a constant function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da3993819cb20099d5b634dd66120eb7048a481" translate="yes" xml:space="preserve">
          <source>To fix this error, you can finish using the closure before using the captured variable:</source>
          <target state="translated">为了解决这个错误,你可以在使用捕获的变量之前完成使用闭包。</target>
        </trans-unit>
        <trans-unit id="271f576e3469a4d5c3d47381caa4c74a644868c6" translate="yes" xml:space="preserve">
          <source>To fix this error, you can use the tuple pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3282af9d0d83b5725d812a840935cf798392f05" translate="yes" xml:space="preserve">
          <source>To fix this error, you have to move &lt;code&gt;yield&lt;/code&gt; out of the &lt;code&gt;async&lt;/code&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62676a2c0346704243e5e296c782b376a8f848ca" translate="yes" xml:space="preserve">
          <source>To fix this error, you have two solutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18371bc4c07ba0c41f6206f4861a5d76f0f6e55" translate="yes" xml:space="preserve">
          <source>To fix this error, you need to mark all the parent implementations as default. Example:</source>
          <target state="translated">为了解决这个错误,你需要将所有的父实现标记为默认。例子:</target>
        </trans-unit>
        <trans-unit id="cf4fd1eefb95ff6d8562a2c0c639ea77e8a69e6e" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">要解决此问题，请在参数中使用生命周期，或使用 &lt;code&gt;'static&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="9bc21023f3e82d02ae5ca480adede6bb29ef608c" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use the &lt;code&gt;'static&lt;/code&gt; lifetime. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2e9d61c37258f8ed9cce9fe2929803d6d2313b" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the inputs, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">要解决此问题，请在输入中使用生命周期，或使用 &lt;code&gt;'static&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="1c9273cf829edc7ecc1d2ffb40566c6ec5264a53" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the generics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d656f4427ec08945a130e9ab24f44d356e73c6" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the return keyword or move the expression into a function. Example:</source>
          <target state="translated">要解决这个问题,只需删除返回关键字或将表达式移到函数中即可。例子:</target>
        </trans-unit>
        <trans-unit id="f7f17c649ffe42ea1218c2db05314ba8b680b067" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the super trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6045b449bd1ac38773b2f91ba227f233a40af26b" translate="yes" xml:space="preserve">
          <source>To fix this issue, the lifetime in the const generic need to be changed to &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9924221c408a112fe763d167c1b4a29e5c450e04" translate="yes" xml:space="preserve">
          <source>To fix this issue, you have to rename at least one of the two imports. Example:</source>
          <target state="translated">要解决这个问题,你必须重命名两个进口中的至少一个。例子:</target>
        </trans-unit>
        <trans-unit id="8b92f6f0312b161fc6e42dd1de00eb946169f081" translate="yes" xml:space="preserve">
          <source>To fix this problem, we&amp;rsquo;ll modify the threads so they listen for either a &lt;code&gt;Job&lt;/code&gt; to run or a signal that they should stop listening and exit the infinite loop. Instead of &lt;code&gt;Job&lt;/code&gt; instances, our channel will send one of these two enum variants.</source>
          <target state="translated">要解决此问题，我们将修改线程，以便它们侦听要运行的 &lt;code&gt;Job&lt;/code&gt; 或它们应停止侦听并退出无限循环的信号。我们的频道将发送这两个枚举变量之一，而不是 &lt;code&gt;Job&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="c3ddf887a4b5f979d5c4754fbe5d3842c28e8398" translate="yes" xml:space="preserve">
          <source>To fix this problem, you can do either of these things:</source>
          <target state="translated">要解决这个问题,你可以做这些事情之一。</target>
        </trans-unit>
        <trans-unit id="d1040dc78ad7b42b1b39bcb93179f38486776a0b" translate="yes" xml:space="preserve">
          <source>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</source>
          <target state="translated">为了解决这个问题,你需要创建一个局部变量来存储值,而不是依赖一个临时变量。例如,你可以将原来的程序改成以下内容。</target>
        </trans-unit>
        <trans-unit id="038c4ea9697da9d94b0b431c704689f74be084b1" translate="yes" xml:space="preserve">
          <source>To fix this we have to define the lifetime at the function or impl level and use that lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;. For example you can define the lifetime at the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396fe77bfe601f99ac29d2d6217b45f0b4c303c2" translate="yes" xml:space="preserve">
          <source>To fix this we have to use the labeled block properly. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360a9b00506f1addbb3267f917ea23dd8584e790" translate="yes" xml:space="preserve">
          <source>To fix this, add a label specifying which loop is being broken out of:</source>
          <target state="translated">要解决这个问题,可以添加一个标签,指定哪个循环被断开。</target>
        </trans-unit>
        <trans-unit id="4f4f5291163064ff6fda56abd889a7618c40d282" translate="yes" xml:space="preserve">
          <source>To fix this, add an implementation for each default method from the trait:</source>
          <target state="translated">为了解决这个问题,从trait中为每个默认方法添加一个实现。</target>
        </trans-unit>
        <trans-unit id="56a92651d517e6a1850a1ad3d4745e7b392eba21" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for that crate as well. Building the &lt;code&gt;adder&lt;/code&gt; crate will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in the workspace using the &lt;code&gt;rand&lt;/code&gt; crate will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="translated">要解决此问题，请编辑 &lt;code&gt;adder&lt;/code&gt; 板条箱的&lt;em&gt;Cargo.toml&lt;/em&gt;文件，并指出 &lt;code&gt;rand&lt;/code&gt; 也是该板条箱的依赖项。构建 &lt;code&gt;adder&lt;/code&gt; 箱子将增加 &lt;code&gt;rand&lt;/code&gt; 到依赖关系列表 &lt;code&gt;adder&lt;/code&gt; 在&lt;em&gt;Cargo.lock&lt;/em&gt;，但没有额外的副本 &lt;code&gt;rand&lt;/code&gt; 将被下载。 Cargo确保使用 &lt;code&gt;rand&lt;/code&gt; 板条箱的工作区中的每个板条箱都将使用相同的版本。在工作区中使用相同版本的 &lt;code&gt;rand&lt;/code&gt; 可以节省空间，因为我们不会有多个副本，并确保工作区中的板条箱彼此兼容。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d9a4693a46d51eb0d6120d0488c70fc938ea0de" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for it as well. Building the &lt;code&gt;adder&lt;/code&gt; package will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in every package in the workspace using the &lt;code&gt;rand&lt;/code&gt; package will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd753bd45e01fa10b5929e59eda068f06c82e05" translate="yes" xml:space="preserve">
          <source>To fix this, either remove the outer reference:</source>
          <target state="translated">要解决这个问题,要么去掉外指。</target>
        </trans-unit>
        <trans-unit id="cb0074c2565e11e981fa6efe9e6d5af9f075e607" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that any declared variables are initialized before being used. Example:</source>
          <target state="translated">为了解决这个问题,请确保在使用之前对所有声明的变量进行初始化。例子:</target>
        </trans-unit>
        <trans-unit id="437601cd4925a7106ff21615c74bc484d85aef14" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</source>
          <target state="translated">要解决这个问题,请确保名称的拼写正确,并且使用了初始化器的正确形式。</target>
        </trans-unit>
        <trans-unit id="890f488bd89f18960203be014ab27fb39dfc6d22" translate="yes" xml:space="preserve">
          <source>To fix this, it is suggested to use a &lt;code&gt;where Self: Sized&lt;/code&gt; bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</source>
          <target state="translated">要解决此问题，如果您不想使用类型参数调用该方法，建议使用与上述子错误的修复类似的 &lt;code&gt;where Self: Sized&lt;/code&gt; 限制：</target>
        </trans-unit>
        <trans-unit id="c7b0cc36b1cf18605167b9e261109b879dd0c485" translate="yes" xml:space="preserve">
          <source>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</source>
          <target state="translated">为了解决这个问题,请手动设置下一个枚举值,或者将具有最大值的枚举变量放在枚举的最后。例子</target>
        </trans-unit>
        <trans-unit id="fa4bb08fcba49cd98aef8848abbf20a6a3f3bfcb" translate="yes" xml:space="preserve">
          <source>To fix this, replace the generic parameter with the specializations that you need:</source>
          <target state="translated">要解决这个问题,请用你需要的专业参数替换通用参数。</target>
        </trans-unit>
        <trans-unit id="0f9e6f402abcaecb02615cbeb4f9eaf1b18503a7" translate="yes" xml:space="preserve">
          <source>To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">为了解决这个问题,可以将该值提取为const,然后使用。</target>
        </trans-unit>
        <trans-unit id="34e96f574d6d4b3f0139f4794453e1b644fdb7fa" translate="yes" xml:space="preserve">
          <source>To fix this, we implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; and satisfy the constraint that &lt;code&gt;OutlinePrint&lt;/code&gt; requires, like so:</source>
          <target state="translated">为了解决这个问题，我们实现了 &lt;code&gt;Point&lt;/code&gt; on &lt;code&gt;Display&lt;/code&gt; 并满足 &lt;code&gt;OutlinePrint&lt;/code&gt; 所需的约束，如下所示：</target>
        </trans-unit>
        <trans-unit id="1afba8b0958bf7d54c00a1e357d6112f94820fbc" translate="yes" xml:space="preserve">
          <source>To fix this, you must reference the lifetime &lt;code&gt;'x&lt;/code&gt; from the return type. For example, changing the return type to &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; would work:</source>
          <target state="translated">要解决此问题，必须从返回类型引用生存期 &lt;code&gt;'x&lt;/code&gt; 。例如，将返回类型更改为 &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; 将起作用：</target>
        </trans-unit>
        <trans-unit id="b2c5b5034aa90905612a009b913793af12d3e3ac" translate="yes" xml:space="preserve">
          <source>To further refine the game&amp;rsquo;s behavior, rather than crashing the program when the user inputs a non-number, let&amp;rsquo;s make the game ignore a non-number so the user can continue guessing. We can do that by altering the line where &lt;code&gt;guess&lt;/code&gt; is converted from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;u32&lt;/code&gt;, as shown in Listing 2-5.</source>
          <target state="translated">为了进一步完善游戏的行为，而不是在用户输入非数字时使程序崩溃，我们让游戏忽略非数字，以便用户继续猜测。我们可以通过更改将 &lt;code&gt;guess&lt;/code&gt; 从 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;u32&lt;/code&gt; 的行来做到这一点，如清单2-5所示。</target>
        </trans-unit>
        <trans-unit id="bea9207f63bde7916694d159ff6b4254f0892dc5" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要获取可变的字符串切片，请参见&lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="baed129549ca4f37d13996fe220fb567ab069ac8" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8139e232eb226615d326fd45327940952c09f923" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0238d96367a691acb632dbf4d73cc5fd2a706ad9" translate="yes" xml:space="preserve">
          <source>To get a pointer to a boxed value, dereference the box:</source>
          <target state="translated">要获得一个指向盒状值的指针,取消对盒状值的引用。</target>
        </trans-unit>
        <trans-unit id="8f1e8a2f8899e777c3546c1b586cd81156849069" translate="yes" xml:space="preserve">
          <source>To get a specific value from a struct, we can use dot notation. If we wanted just this user&amp;rsquo;s email address, we could use &lt;code&gt;user1.email&lt;/code&gt; wherever we wanted to use this value. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the &lt;code&gt;email&lt;/code&gt; field of a mutable &lt;code&gt;User&lt;/code&gt; instance.</source>
          <target state="translated">要从结构中获取特定值，我们可以使用点表示法。如果只需要该用户的电子邮件地址，则可以在需要使用此值的任何地方使用 &lt;code&gt;user1.email&lt;/code&gt; 。如果实例是可变的，则可以通过使用点表示法并将其分配给特定字段来更改值。清单5-3显示了如何更改可变 &lt;code&gt;User&lt;/code&gt; 实例的 &lt;code&gt;email&lt;/code&gt; 字段中的值。</target>
        </trans-unit>
        <trans-unit id="ffd19be588eb8df1e329d2bc1905f6d517e8c370" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要获取不可变的字符串切片，请参见&lt;a href=&quot;#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="4160b8923a79d4ccc00d36a66c387740f16ca557" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce6e3247525a78442e0ee3f76231a67e813fe82" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29270bb604499679be31005db9630fdff3a329f3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要获取不可变的字符串切片，请参见&lt;a href=&quot;#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="1773350f816d14b08d14b8fc6f4503505910e146" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130eb39bd47cd566af1912b3ccb9f5e133aeacd3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bbcb0bb220df37e8c688ef821b8733765b09b5" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要获取可变的字符串切片，请参见&lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7b8786ffc3edfea977e5fb933b851cad79af05d7" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f032d280d4b30ddfbcd15e779b494aafdce282" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0349cd0d37a5287741f4237e8c49df43c4e0c6" translate="yes" xml:space="preserve">
          <source>To get this out of the way: you should probably just use &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison. Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a good enough choice to get started.</source>
          <target state="translated">为了避免这种情况：您可能应该只使用&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;。这两个集合涵盖了通用数据存储和处理的大多数用例。他们非常擅长于做自己的工作。标准库中的所有其他集合都有特定的用例，在这些用例中它们是最佳选择，但相比之下，这些用例只是边缘&lt;em&gt;领域&lt;/em&gt;。即使 &lt;code&gt;Vec&lt;/code&gt; 和 &lt;code&gt;HashMap&lt;/code&gt; 在技​​术上不是最佳选择，它们也可能是入门的不错选择。</target>
        </trans-unit>
        <trans-unit id="18773042303056fd8c79476f3616f355ff443a51" translate="yes" xml:space="preserve">
          <source>To handle the error case and print a user-friendly message, we need to update &lt;code&gt;main&lt;/code&gt; to handle the &lt;code&gt;Result&lt;/code&gt; being returned by &lt;code&gt;Config::new&lt;/code&gt;, as shown in Listing 12-10. We&amp;rsquo;ll also take the responsibility of exiting the command line tool with a nonzero error code from &lt;code&gt;panic!&lt;/code&gt; and implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.</source>
          <target state="translated">为了处理错误情况并输出一条用户友好的消息，我们需要更新 &lt;code&gt;main&lt;/code&gt; 以处理 &lt;code&gt;Config::new&lt;/code&gt; 返回的 &lt;code&gt;Result&lt;/code&gt; ，如清单12-10所示。我们还将负责从 &lt;code&gt;panic!&lt;/code&gt; 中退出带有非零错误代码的命令行工具！并手动实施。非零退出状态是一种约定，用于向调用我们的程序的进程发出信号，告知该程序以错误状态退出。</target>
        </trans-unit>
        <trans-unit id="482ebf3be5fe8298225b2e8f09ccc5e7f7c51bf1" translate="yes" xml:space="preserve">
          <source>To help IDE integration, the Rust project distributes the &lt;em&gt;Rust Language Server&lt;/em&gt; (&lt;code&gt;rls&lt;/code&gt;). This tool speaks the &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt;, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use the &lt;code&gt;rls&lt;/code&gt;, such as &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;the Rust plug-in for Visual Studio Code&lt;/a&gt;.</source>
          <target state="translated">为了帮助集成IDE，Rust项目分发了&lt;em&gt;Rust语言服务器&lt;/em&gt;（ &lt;code&gt;rls&lt;/code&gt; ）。该工具使用&lt;a href=&quot;http://langserver.org/&quot;&gt;语言服务器协议&lt;/a&gt;，这是IDE和编程语言相互通信的规范。不同的客户端可以使用 &lt;code&gt;rls&lt;/code&gt; ，例如&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio Code的Rust插件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20b8f11e3eb504aaf128f283d04500f6915052b5" translate="yes" xml:space="preserve">
          <source>To illustrate situations where closures that can capture their environment are useful as function parameters, let&amp;rsquo;s move on to our next topic: iterators.</source>
          <target state="translated">为了说明可以捕获其环境的闭包用作函数参数的情况，让我们继续下一个主题：迭代器。</target>
        </trans-unit>
        <trans-unit id="6bb8bf87527987f23e438b1c1bc78391e818826e" translate="yes" xml:space="preserve">
          <source>To illustrate the rules of ownership, we need a data type that is more complex than the ones we covered in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3. The types covered previously are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data.</source>
          <target state="translated">为了说明所有权规则，我们需要一个比第3章&lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;数据类型&amp;rdquo;&lt;/a&gt;部分介绍的数据类型更复杂的数据类型。先前介绍的类型都存储在堆栈中，并在其作用域弹出时从堆栈中弹出。结束了，但是我们想查看存储在堆上的数据，并探索Rust如何知道何时清理该数据。</target>
        </trans-unit>
        <trans-unit id="60712450a97e23097bf6dbe8ed26e2265884e8b7" translate="yes" xml:space="preserve">
          <source>To implement the behavior we want &lt;code&gt;gui&lt;/code&gt; to have, we&amp;rsquo;ll define a trait named &lt;code&gt;Draw&lt;/code&gt; that will have one method named &lt;code&gt;draw&lt;/code&gt;. Then we can define a vector that takes a &lt;em&gt;trait object&lt;/em&gt;. A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a &lt;code&gt;&amp;amp;&lt;/code&gt; reference or a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, then the &lt;code&gt;dyn&lt;/code&gt; keyword, and then specifying the relevant trait. (We&amp;rsquo;ll talk about the reason trait objects must use a pointer in Chapter 19 in the section &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;Dynamically Sized Types and the &lt;code&gt;Sized&lt;/code&gt; Trait.&amp;rdquo;&lt;/a&gt;) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust&amp;rsquo;s type system will ensure at compile time that any value used in that context will implement the trait object&amp;rsquo;s trait. Consequently, we don&amp;rsquo;t need to know all the possible types at compile time.</source>
          <target state="translated">为了实现 &lt;code&gt;gui&lt;/code&gt; 想要的行为，我们将定义一个名为 &lt;code&gt;Draw&lt;/code&gt; 的特征，该特征将具有一个名为 &lt;code&gt;draw&lt;/code&gt; 的方法。然后我们可以定义一个接受&lt;em&gt;特征对象&lt;/em&gt;的向量。特征对象既指向实现我们指定特征的类型的实例，也指向用于在运行时查找该类型的特征方法的表。通过指定某种指针（例如 &lt;code&gt;&amp;amp;&lt;/code&gt; 引用或 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 智能指针），然后指定 &lt;code&gt;dyn&lt;/code&gt; 关键字，然后指定相关特征，可以创建特征对象。 （我们将在第19章&lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;动态大小类型和&lt;/a&gt; &lt;code&gt;Sized&lt;/code&gt; 确定的部分&amp;rdquo;中讨论特征对象必须使用指针的原因。特征。&amp;rdquo; ）我们可以使用特征对象代替泛型或具体类型。无论我们在哪里使用trait对象，Rust的类型系统都将确保在编译时在该上下文中使用的任何值都将实现trait对象的trait。因此，我们不需要在编译时就知道所有可能的类型。</target>
        </trans-unit>
        <trans-unit id="f5e8a5c28a454d1f90112a6c60c0f8aea2b5196d" translate="yes" xml:space="preserve">
          <source>To improve our program, we&amp;rsquo;ll fix four problems that have to do with the program&amp;rsquo;s structure and how it&amp;rsquo;s handling potential errors.</source>
          <target state="translated">为了改进我们的程序，我们将修复与程序的结构以及如何处理潜在错误有关的四个问题。</target>
        </trans-unit>
        <trans-unit id="bf9b4462d1a02f4d70e5d13cf8540c79a5e14d1a" translate="yes" xml:space="preserve">
          <source>To incorporate the &lt;code&gt;Message&lt;/code&gt; enum, we need to change &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; in two places: the definition of &lt;code&gt;ThreadPool&lt;/code&gt; and the signature of &lt;code&gt;Worker::new&lt;/code&gt;. The &lt;code&gt;execute&lt;/code&gt; method of &lt;code&gt;ThreadPool&lt;/code&gt; needs to send jobs wrapped in the &lt;code&gt;Message::NewJob&lt;/code&gt; variant. Then, in &lt;code&gt;Worker::new&lt;/code&gt; where a &lt;code&gt;Message&lt;/code&gt; is received from the channel, the job will be processed if the &lt;code&gt;NewJob&lt;/code&gt; variant is received, and the thread will break out of the loop if the &lt;code&gt;Terminate&lt;/code&gt; variant is received.</source>
          <target state="translated">为了合并 &lt;code&gt;Message&lt;/code&gt; 枚举，我们需要在两个地方将 &lt;code&gt;Job&lt;/code&gt; 更改为 &lt;code&gt;Message&lt;/code&gt; ： &lt;code&gt;ThreadPool&lt;/code&gt; 的定义和 &lt;code&gt;Worker::new&lt;/code&gt; 的签名。 &lt;code&gt;ThreadPool&lt;/code&gt; 的 &lt;code&gt;execute&lt;/code&gt; 方法需要发送包装在 &lt;code&gt;Message::NewJob&lt;/code&gt; 变量中的作业。然后，在 &lt;code&gt;Worker::new&lt;/code&gt; 其中 &lt;code&gt;Message&lt;/code&gt; 是从信道接收，该作业将被如果处理的 &lt;code&gt;NewJob&lt;/code&gt; 接收变体中，并且如果该线程将中断环路的出 &lt;code&gt;Terminate&lt;/code&gt; 接收的变体。</target>
        </trans-unit>
        <trans-unit id="0f9206704ddf29e2ebea715304ccfd9e3f3ba5f3" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;rustfmt&lt;/code&gt;, enter the following:</source>
          <target state="translated">要安装 &lt;code&gt;rustfmt&lt;/code&gt; ，请输入以下内容：</target>
        </trans-unit>
        <trans-unit id="35fe5fa9574aed79cc4c533785f5e0d142e0e320" translate="yes" xml:space="preserve">
          <source>To install Clippy, enter the following:</source>
          <target state="translated">要安装Clippy,请输入以下内容。</target>
        </trans-unit>
        <trans-unit id="44d584ca391c2045c83ab8a58e67b2e401ab33be" translate="yes" xml:space="preserve">
          <source>To install the &lt;code&gt;rls&lt;/code&gt;, enter the following:</source>
          <target state="translated">要安装 &lt;code&gt;rls&lt;/code&gt; ，请输入以下内容：</target>
        </trans-unit>
        <trans-unit id="71a54c2518d0f86ead8ba016e32755cf1ca226ed" translate="yes" xml:space="preserve">
          <source>To interact with a &lt;code&gt;Formatter&lt;/code&gt;, you'll call various methods to change the various options related to formatting. For examples, please see the documentation of the methods defined on &lt;code&gt;Formatter&lt;/code&gt; below.</source>
          <target state="translated">要与 &lt;code&gt;Formatter&lt;/code&gt; 进行交互，您将调用各种方法来更改与格式化有关的各种选项。有关示例，请参阅下面的 &lt;code&gt;Formatter&lt;/code&gt; 上定义的方法的文档。</target>
        </trans-unit>
        <trans-unit id="b498caa788bb95865cf7ae29f319574a69dd854b" translate="yes" xml:space="preserve">
          <source>To isolate unsafe code as much as possible, it&amp;rsquo;s best to enclose unsafe code within a safe abstraction and provide a safe API, which we&amp;rsquo;ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of &lt;code&gt;unsafe&lt;/code&gt; from leaking out into all the places that you or your users might want to use the functionality implemented with &lt;code&gt;unsafe&lt;/code&gt; code, because using a safe abstraction is safe.</source>
          <target state="translated">为了尽可能地隔离不安全的代码，最好将不安全的代码包含在安全的抽象中并提供安全的API，我们将在本章的后面部分讨论不安全的函数和方法时对此进行讨论。标准库的某些部分实现为对已审核的不安全代码的安全抽象。在安全抽象中包装不安全代码可以防止 &lt;code&gt;unsafe&lt;/code&gt; 使用的情况泄漏到您或您的用户可能希望使用通过 &lt;code&gt;unsafe&lt;/code&gt; 代码实现的功能的所有位置，因为使用安全抽象是安全的。</target>
        </trans-unit>
        <trans-unit id="a6753382b748af96b119a035edd05c7a836b948d" translate="yes" xml:space="preserve">
          <source>To learn about the other kinds of collections provided by the standard library, see &lt;a href=&quot;../std/collections/index&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">要了解标准库提供的其他种类的集合，请参阅&lt;a href=&quot;../std/collections/index&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dbbd03b2e667a7e6b225ed1de228878e32e5817" translate="yes" xml:space="preserve">
          <source>To learn more about allowing access, see the documentation for the &lt;a href=&quot;keyword.pub&quot;&gt;&lt;code&gt;pub&lt;/code&gt;&lt;/a&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2736d1e6ef2a3faad24038e53f6bde645f76d87" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非ASCII字符外，要小写ASCII字符，请使用&lt;a href=&quot;#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e94e0d4cfd63a504442f11c93df0afa614a2f0d4" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非ASCII字符外，要小写ASCII字符，请使用&lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt; &lt;code&gt;str::to_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63a5fbbc07007136d2c958a62c0c4ca27bbb449c" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab2513e3de2d60d109900818fb2429fd91b99d2" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要就地小写值，请使用&lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef146744579c27e21ed699daf39b3a3250767c77" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要就地小写值，请使用&lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67608258687aa72b226fb9d75937d3aa5583b343" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6481a0667301c8cf17a1fc74a4e7ea446e2ab9" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a33f76160389c879809056277f95cb426933c88" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cfe6c801715fff699dce762afc98ca7e8ff1fa" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0549668b9dec3f8fe6cc76087d773d360d9c8f" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;struct.osstr#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd861f60ceee6cd011393e0efbd8975fcac733a1" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e4a3f169edf0cfb32c3841ee2bea7479d1a5e1" translate="yes" xml:space="preserve">
          <source>To make a struct that holds a closure, we need to specify the type of the closure, because a struct definition needs to know the types of each of its fields. Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different. To define structs, enums, or function parameters that use closures, we use generics and trait bounds, as we discussed in Chapter 10.</source>
          <target state="translated">要制作一个容纳闭包的结构,我们需要指定闭包的类型,因为一个结构定义需要知道它的每个字段的类型。每个闭包实例都有自己唯一的匿名类型:也就是说,即使两个闭包具有相同的签名,它们的类型仍然被认为是不同的。为了定义使用闭包的结构、枚举或函数参数,我们使用了泛型和特质边界,正如我们在第10章中讨论的那样。</target>
        </trans-unit>
        <trans-unit id="f551bbd5751f05a17c69a727dd31a7a20561b4f8" translate="yes" xml:space="preserve">
          <source>To make it valid, write the following:</source>
          <target state="translated">为了使其有效,请写出以下内容。</target>
        </trans-unit>
        <trans-unit id="11b284dcb2ba4ceac9f02b253f7b17b9698ddf3b" translate="yes" xml:space="preserve">
          <source>To make struct &lt;code&gt;Bar&lt;/code&gt; only visible in module &lt;code&gt;foo&lt;/code&gt; the &lt;code&gt;in&lt;/code&gt; keyword should be used:</source>
          <target state="translated">为了使结构 &lt;code&gt;Bar&lt;/code&gt; 仅模块可见 &lt;code&gt;foo&lt;/code&gt; 的 &lt;code&gt;in&lt;/code&gt; 关键字应使用：</target>
        </trans-unit>
        <trans-unit id="fc2021393a94974377e271f291f7d97ada3aa985" translate="yes" xml:space="preserve">
          <source>To make the child node aware of its parent, we need to add a &lt;code&gt;parent&lt;/code&gt; field to our &lt;code&gt;Node&lt;/code&gt; struct definition. The trouble is in deciding what the type of &lt;code&gt;parent&lt;/code&gt; should be. We know it can&amp;rsquo;t contain an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, because that would create a reference cycle with &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;branch.children&lt;/code&gt; pointing to &lt;code&gt;leaf&lt;/code&gt;, which would cause their &lt;code&gt;strong_count&lt;/code&gt; values to never be 0.</source>
          <target state="translated">为了使子节点知道其父节点，我们需要在 &lt;code&gt;Node&lt;/code&gt; 的结构定义中添加一个 &lt;code&gt;parent&lt;/code&gt; 字段。问题在于确定 &lt;code&gt;parent&lt;/code&gt; 的类型。我们知道它不能包含 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; ，因为这将创建一个参考循环，其中 &lt;code&gt;leaf.parent&lt;/code&gt; 指向 &lt;code&gt;branch&lt;/code&gt; ， &lt;code&gt;branch.children&lt;/code&gt; 指向 &lt;code&gt;leaf&lt;/code&gt; ，这将导致它们的 &lt;code&gt;strong_count&lt;/code&gt; 值永远不会为0。</target>
        </trans-unit>
        <trans-unit id="d22320c45b662fb11c8113dfcbe82f4c5091e1e8" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b483d37995579653b3a66a999867efa81ab8f9" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;code&gt;Drop&lt;/code&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="translated">为了使此工作有效，列表中的每个元素都有指向其前任和后任的指针。只能在固定元素时添加元素，因为四处移动元素会使指针无效。此外，链表元素的 &lt;code&gt;Drop&lt;/code&gt; 实现将修补其前任和后继的指针，以将自身从列表中删除。</target>
        </trans-unit>
        <trans-unit id="addd7b5a3eab2bcc498269d4b5030ddd2652429e" translate="yes" xml:space="preserve">
          <source>To many people, polymorphism is synonymous with inheritance. But it&amp;rsquo;s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</source>
          <target state="translated">对许多人来说，多态是继承的代名词。但这实际上是一个更通用的概念，指的是可以使用多种类型的数据的代码。对于继承，这些类型通常是子类。</target>
        </trans-unit>
        <trans-unit id="e542c92de7f2ff8b0e65e4059a685882563b6c24" translate="yes" xml:space="preserve">
          <source>To measure elapsed time reliably, use &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1808ba5fbc9308fb8282df842ce731348ff5abf" translate="yes" xml:space="preserve">
          <source>To model pointers to opaque types in FFI, until &lt;code&gt;extern type&lt;/code&gt; is stabilized, it is recommended to use a newtype wrapper around an empty byte array. See the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; for details.</source>
          <target state="translated">要在FFI中为指向不透明类型的指针建模，直到稳定 &lt;code&gt;extern type&lt;/code&gt; ，建议在空字节数组周围使用新类型包装器。有关详细信息，请参见&lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92f1c0826630a6e44e7c7249d92c4a26d91785e3" translate="yes" xml:space="preserve">
          <source>To obtain error description as a string, use &lt;code&gt;to_string()&lt;/code&gt;.</source>
          <target state="translated">要获取错误描述作为字符串，请使用 &lt;code&gt;to_string()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0354419a51c55b7a4f425ab3291d7b635b1d30c9" translate="yes" xml:space="preserve">
          <source>To parameterize the types in the new function we&amp;rsquo;ll define, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we&amp;rsquo;ll use &lt;code&gt;T&lt;/code&gt; because, by convention, parameter names in Rust are short, often just a letter, and Rust&amp;rsquo;s type-naming convention is CamelCase. Short for &amp;ldquo;type,&amp;rdquo; &lt;code&gt;T&lt;/code&gt; is the default choice of most Rust programmers.</source>
          <target state="translated">为了在我们将要定义的新函数中对类型进行参数化，我们需要命名类型参数，就像对函数的value参数进行命名一样。您可以使用任何标识符作为类型参数名称。但是我们将使用 &lt;code&gt;T&lt;/code&gt; ,因为按照惯例，Rust中的参数名称很短，通常只是一个字母，Rust的类型命名惯例是CamelCase。 &lt;code&gt;T&lt;/code&gt; 是&amp;ldquo;类型&amp;rdquo;的缩写，是大多数Rust程序员的默认选择。</target>
        </trans-unit>
        <trans-unit id="075fa626d389c13dd84df398e2b600267ba414fd" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="translated">要解析路径，您可以从&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;切片创建&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;切片并开始提出问题：</target>
        </trans-unit>
        <trans-unit id="a91f9eb8a09ec43223d4a3a69ca02691cc9a5535" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f45d830d337ce8a4f493ea8b6014f97c0fb6eb" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要传递单个参数，请参见&lt;a href=&quot;#method.arg&quot;&gt; &lt;code&gt;arg&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30a7bace681f793e8820181cf7574f94401b280d" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3d970a69fb7cac0396fffe3d7483eb856d59e9" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要传递多个参数，请参见&lt;a href=&quot;#method.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f24e6cb8e923f8cee5441a6183ab318931f04cf1" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc2c49e6f2624612dfa9af5bb72c9d5988a62aa" translate="yes" xml:space="preserve">
          <source>To perform async recursion, the &lt;code&gt;async fn&lt;/code&gt; needs to be desugared such that the &lt;code&gt;Future&lt;/code&gt; is explicit in the return type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6d76d570505ba666bcda7baecd5871dcf2d3a2" translate="yes" xml:space="preserve">
          <source>To prevent this scenario, we first put all of our &lt;code&gt;Terminate&lt;/code&gt; messages on the channel in one loop; then we join on all the threads in another loop. Each worker will stop receiving requests on the channel once it gets a terminate message. So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before &lt;code&gt;join&lt;/code&gt; is called on its thread.</source>
          <target state="translated">为避免这种情况，我们首先将所有 &lt;code&gt;Terminate&lt;/code&gt; 消息放在一个循环中；然后我们在另一个循环中加入所有线程。一旦收到终止消息，每个工作人员将停止在通道上接收请求。因此，我们可以确定，如果发送的终止消息数量与工作线程数相同，则每个工作线程都会在线程调用 &lt;code&gt;join&lt;/code&gt; 之前收到终止消息。</target>
        </trans-unit>
        <trans-unit id="add5b6cf5a307a5e6af227f8cc2b7b101db763e7" translate="yes" xml:space="preserve">
          <source>To protect your program from this sort of vulnerability, if you try to read an element at an index that doesn&amp;rsquo;t exist, Rust will stop execution and refuse to continue. Let&amp;rsquo;s try it and see:</source>
          <target state="translated">为了保护您的程序免受此类漏洞的侵害，如果您尝试在不存在的索引处读取元素，Rust将停止执行并拒绝继续执行。让我们尝试一下，看看：</target>
        </trans-unit>
        <trans-unit id="fb3ab9d085bae205d404a7ba202d1b27f55784c2" translate="yes" xml:space="preserve">
          <source>To recover from a poisoned mutex:</source>
          <target state="translated">要想从中毒的哑铃中恢复过来。</target>
        </trans-unit>
        <trans-unit id="e0f842e4093b64f03623cd49c1c17718cfbe95dc" translate="yes" xml:space="preserve">
          <source>To remove the internal organization from the public API, we can modify the &lt;code&gt;art&lt;/code&gt; crate code in Listing 14-3 to add &lt;code&gt;pub use&lt;/code&gt; statements to re-export the items at the top level, as shown in Listing 14-5:</source>
          <target state="translated">要从公共API中删除内部组织，我们可以修改清单14-3中的 &lt;code&gt;art&lt;/code&gt; crate代码，以添加 &lt;code&gt;pub use&lt;/code&gt; 语句以在顶层重新导出项目，如清单14-5所示：</target>
        </trans-unit>
        <trans-unit id="5b0280b8819ec3479f9646e558c6310c8632f058" translate="yes" xml:space="preserve">
          <source>To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</source>
          <target state="translated">为了解决模棱两可的问题,程序员可以使用更具体的路径、类型或特征来引用他们想要的方法或函数。</target>
        </trans-unit>
        <trans-unit id="40806bdac66961c97f14caf3bdb5bd4161107da4" translate="yes" xml:space="preserve">
          <source>To resolve this error use the concrete type:</source>
          <target state="translated">为了解决这个错误,使用具体类型。</target>
        </trans-unit>
        <trans-unit id="bba50911f39e97c448e79f8065cbe76ff37d962c" translate="yes" xml:space="preserve">
          <source>To resolve this error, use a concrete type for the intermediate expression:</source>
          <target state="translated">要解决这个错误,请为中间表达式使用具体类型。</target>
        </trans-unit>
        <trans-unit id="336222d4e74857a65248fce76ba73fa02fe1c00a" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;#method.to_ascii_lowercase&quot;&gt;&lt;code&gt;to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要返回新的小写值而不修改现有值，请使用&lt;a href=&quot;#method.to_ascii_lowercase&quot;&gt; &lt;code&gt;to_ascii_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6eff45b987ef30ba84b5033a569d4671d667c28" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;#tymethod.to_ascii_lowercase&quot;&gt;&lt;code&gt;to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要返回新的小写值而不修改现有值，请使用&lt;a href=&quot;#tymethod.to_ascii_lowercase&quot;&gt; &lt;code&gt;to_ascii_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a6b8af0a2d7bad5168dd7563a5faab87aca3dc2" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;struct.osstr#method.to_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99049f339cacaaabe4b0c50ed3b0d3a63d16bda2" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;trait.asciiext#tymethod.to_ascii_lowercase&quot;&gt;&lt;code&gt;to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc2431e450771dead21af33dda64aadfaf2de37" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;#method.to_ascii_uppercase&quot;&gt;&lt;code&gt;to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要返回新的大写值而不修改现有值，请使用&lt;a href=&quot;#method.to_ascii_uppercase&quot;&gt; &lt;code&gt;to_ascii_uppercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f98861983753d9167b54a4036b6c14ee7465a79" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;#tymethod.to_ascii_uppercase&quot;&gt;&lt;code&gt;to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要返回新的大写值而不修改现有值，请使用&lt;a href=&quot;#tymethod.to_ascii_uppercase&quot;&gt; &lt;code&gt;to_ascii_uppercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b269c5e12c3307032fd7c3ae09e5e6e5ef1b2811" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;struct.osstr#method.to_ascii_uppercase&quot;&gt;&lt;code&gt;OsStr::to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bdcca7b53a29d96e387d59f21508e247003424" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;trait.asciiext#tymethod.to_ascii_uppercase&quot;&gt;&lt;code&gt;to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3eb99467dbfaa372dd0858f79acae31153782c2" translate="yes" xml:space="preserve">
          <source>To round out this project, we&amp;rsquo;ll briefly demonstrate how to work with environment variables and how to print to standard error, both of which are useful when you&amp;rsquo;re writing command line programs.</source>
          <target state="translated">为了完善该项目，我们将简要演示如何使用环境变量以及如何将其打印为标准错误，这在编写命令行程序时都非常有用。</target>
        </trans-unit>
        <trans-unit id="1d354bd55577a0ae6fc2f95a62753d1f62548897" translate="yes" xml:space="preserve">
          <source>To run Clippy&amp;rsquo;s lints on any Cargo project, enter the following:</source>
          <target state="translated">要在任何Cargo项目上运行Clippy的棉绒，请输入以下内容：</target>
        </trans-unit>
        <trans-unit id="38b636b1ad46eb0add3e75f7e9d97cbfc1d6f9d8" translate="yes" xml:space="preserve">
          <source>To run the binary crate from the &lt;em&gt;add&lt;/em&gt; directory, we can specify which package in the workspace we want to run by using the &lt;code&gt;-p&lt;/code&gt; argument and the package name with &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d744134b2344eca07ba0f4cf9819619cc570948e" translate="yes" xml:space="preserve">
          <source>To run the binary crate from the &lt;em&gt;add&lt;/em&gt; directory, we need to specify which package in the workspace we want to use by using the &lt;code&gt;-p&lt;/code&gt; argument and the package name with &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">要从&lt;em&gt;add&lt;/em&gt;目录运行二进制板条箱，我们需要通过使用 &lt;code&gt;-p&lt;/code&gt; 参数和带有 &lt;code&gt;cargo run&lt;/code&gt; 的软件包名称来指定工作空间中要使用的软件包：</target>
        </trans-unit>
        <trans-unit id="8bc4f6782a835ae358ae31b6f96421e46fc704f9" translate="yes" xml:space="preserve">
          <source>To see deref coercion in action, let&amp;rsquo;s use the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we defined in Listing 15-8 as well as the implementation of &lt;code&gt;Deref&lt;/code&gt; that we added in Listing 15-10. Listing 15-11 shows the definition of a function that has a string slice parameter:</source>
          <target state="translated">要查看实际的deref强制，让我们使用清单15-8中定义的 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 类型以及清单15-10中添加的 &lt;code&gt;Deref&lt;/code&gt; 的实现。清单15-11显示了具有字符串切片参数的函数的定义：</target>
        </trans-unit>
        <trans-unit id="0acf6acdd95133438e45baebe84203f1ed05a023" translate="yes" xml:space="preserve">
          <source>To see destructors in action, let's take a look at the following program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d871d99b751923bfc8199196805ccdb06df1da" translate="yes" xml:space="preserve">
          <source>To see the pattern matching aspect of &lt;code&gt;let&lt;/code&gt; more clearly, consider Listing 18-4, which uses a pattern with &lt;code&gt;let&lt;/code&gt; to destructure a tuple.</source>
          <target state="translated">要更清楚地了解 &lt;code&gt;let&lt;/code&gt; 的模式匹配方面，请考虑清单18-4，它使用带有 &lt;code&gt;let&lt;/code&gt; 的模式对元组进行解构。</target>
        </trans-unit>
        <trans-unit id="76ec71028cdc11f78838d4138f08838dc91ccb67" translate="yes" xml:space="preserve">
          <source>To see this code in action, let&amp;rsquo;s modify &lt;code&gt;main&lt;/code&gt; to accept only two requests before gracefully shutting down the server, as shown in Listing 20-25.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7f1edd4187697ed5c2e4f6dc220a6d712ca92f" translate="yes" xml:space="preserve">
          <source>To see this code in action, let&amp;rsquo;s modify &lt;code&gt;main&lt;/code&gt; to accept only two requests before gracefully shutting down the server, as shown in Listing 20-26.</source>
          <target state="translated">为了查看该代码的实际效果，让我们修改 &lt;code&gt;main&lt;/code&gt; 以在正常关闭服务器之前仅接受两个请求，如清单20-26所示。</target>
        </trans-unit>
        <trans-unit id="a7940de3192aef0247f83e244b60b2d3b6e58939" translate="yes" xml:space="preserve">
          <source>To see what happens when a &lt;code&gt;should_panic&lt;/code&gt; test with an &lt;code&gt;expected&lt;/code&gt; message fails, let&amp;rsquo;s again introduce a bug into our code by swapping the bodies of the &lt;code&gt;if value &amp;lt; 1&lt;/code&gt; and the &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; blocks:</source>
          <target state="translated">要查看在带有 &lt;code&gt;expected&lt;/code&gt; 消息的 &lt;code&gt;should_panic&lt;/code&gt; 测试失败时会发生什么，让我们通过交换 &lt;code&gt;if value &amp;lt; 1&lt;/code&gt; 和 &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; 块的主体，再次在我们的代码中引入错误：</target>
        </trans-unit>
        <trans-unit id="8576f35029f2c29efb15d99933a9de10a34dcb7b" translate="yes" xml:space="preserve">
          <source>To see why that last example was allowed, you need to understand the general rule. Unfortunately this rule is a bit tricky to state. Consider an &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">要了解为什么允许使用最后一个示例，您需要了解一般规则。不幸的是，该规则很难说明。考虑一下 &lt;code&gt;impl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a14fdfe6208af1cb452de86927ad706e8201fb30" translate="yes" xml:space="preserve">
          <source>To seek without discarding the internal buffer, use &lt;a href=&quot;struct.bufreader#method.seek_relative&quot;&gt;&lt;code&gt;BufReader::seek_relative&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要查找而不丢弃内部缓冲区，请使用&lt;a href=&quot;struct.bufreader#method.seek_relative&quot;&gt; &lt;code&gt;BufReader::seek_relative&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d7ebdd071ebe03ef9670cc1129fd6804ce04dfa" translate="yes" xml:space="preserve">
          <source>To service better ergonomics, patterns operate in different &lt;em&gt;binding modes&lt;/em&gt; in order to make it easier to bind references to values. When a reference value is matched by a non-reference pattern, it will be automatically treated as a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; binding. Example:</source>
          <target state="translated">为了提供更好的人体工程学设计，模式可以在不同的&lt;em&gt;绑定模式下运行&lt;/em&gt;，以便更轻松地将引用绑定到值。当参考值与非参考模式匹配时，它将被自动视为 &lt;code&gt;ref&lt;/code&gt; 或 &lt;code&gt;ref mut&lt;/code&gt; 绑定。例：</target>
        </trans-unit>
        <trans-unit id="a3d0badb6b5b316657f5cb3fda3963d136213146" translate="yes" xml:space="preserve">
          <source>To set up a new project, go to the &lt;em&gt;projects&lt;/em&gt; directory that you created in Chapter 1 and make a new project using Cargo, like so:</source>
          <target state="translated">要设置一个新项目，请转到您在第1章中创建的&lt;em&gt;projects&lt;/em&gt;目录，然后使用Cargo创建一个新项目，如下所示：</target>
        </trans-unit>
        <trans-unit id="58b49ff05dd6fb8ece812d318c3efc42db98cdbb" translate="yes" xml:space="preserve">
          <source>To show Rust where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. If we want to call a function, we need to know its path.</source>
          <target state="translated">为了让 Rust 知道在模块树中哪里可以找到一个项目,我们使用了一个路径,就像我们在浏览文件系统时使用路径一样。如果我们想调用一个函数,我们需要知道它的路径。</target>
        </trans-unit>
        <trans-unit id="da1e1e9f2dd7b1c40ddec9ecef1f4d928ddb4f25" translate="yes" xml:space="preserve">
          <source>To silence this warning, edit your code to use an explicit bound. Most of the time, this means that you will want to change the signature of a function that you are calling. For example, if the error is reported on a call like &lt;code&gt;foo(x)&lt;/code&gt;, and &lt;code&gt;foo&lt;/code&gt; is defined as follows:</source>
          <target state="translated">要使此警告静音，请编辑代码以使用显式绑定。大多数情况下，这意味着您将要更改所调用函数的签名。例如，如果报告了类似的呼叫错误 &lt;code&gt;foo(x)&lt;/code&gt; ，和 &lt;code&gt;foo&lt;/code&gt; 定义如下：</target>
        </trans-unit>
        <trans-unit id="0ae8db76a02a996f64985b9fc49d037c6c1ea0c5" translate="yes" xml:space="preserve">
          <source>To solve this error you can use conditional compilation:</source>
          <target state="translated">为了解决这个错误,你可以使用条件编译。</target>
        </trans-unit>
        <trans-unit id="384aa431a554e0c72ecb63fe411f4d1d9ac5425c" translate="yes" xml:space="preserve">
          <source>To solve this error, please ensure that the trait is also public. The trait can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with &lt;code&gt;pub&lt;/code&gt;. Example:</source>
          <target state="translated">要解决此错误，请确保该特征也是公开的。可以通过将其放入私有内部模块来使其无法访问，但是仍然必须用 &lt;code&gt;pub&lt;/code&gt; 标记。例：</target>
        </trans-unit>
        <trans-unit id="e8fd0f72a971d26cc1bbb2830412854500357f79" translate="yes" xml:space="preserve">
          <source>To solve this error, please ensure that the type is also public. The type can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with &lt;code&gt;pub&lt;/code&gt;. Example:</source>
          <target state="translated">要解决此错误，请确保该类型也是公共的。可以通过将其放入私有内部模块来使该类型不可访问，但仍必须用 &lt;code&gt;pub&lt;/code&gt; 标记。例：</target>
        </trans-unit>
        <trans-unit id="3cffb477b8b527a4ad5d6a5090b9a2b24adc51f1" translate="yes" xml:space="preserve">
          <source>To solve this error, please move the type bindings in the type parameter declaration:</source>
          <target state="translated">为了解决这个错误,请将类型参数声明中的类型绑定移动。</target>
        </trans-unit>
        <trans-unit id="4a77dd198bd76ba335ad5b87d56789f39f1b6b5e" translate="yes" xml:space="preserve">
          <source>To solve this error, the best solution is generally to keep the path before the item when using it. Example:</source>
          <target state="translated">要解决这个错误,最好的办法一般是在使用项目时,保留项目前的路径。例如</target>
        </trans-unit>
        <trans-unit id="e0683b0386295fb5b1a3a7f5a6c76d0ac644fc3b" translate="yes" xml:space="preserve">
          <source>To solve this issue, multiple solutions are available. First, is it required for this variable to be used in more than one closure at a time? If it is the case, use reference counted types such as &lt;code&gt;Rc&lt;/code&gt; (or &lt;code&gt;Arc&lt;/code&gt; if it runs concurrently):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f267efd7ba6e9990897495f245eaad001164fa" translate="yes" xml:space="preserve">
          <source>To solve, ensure that the trait object has at least one trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8595d9620d15e23dd7e60f0c946808adb0c94b9" translate="yes" xml:space="preserve">
          <source>To split by Unicode &lt;code&gt;Whitespace&lt;/code&gt; instead, use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要改为按Unicode &lt;code&gt;Whitespace&lt;/code&gt; 分割，请使用&lt;a href=&quot;#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4419c6b42b03b7ee73a5252ee2ba8b90aa54d16" translate="yes" xml:space="preserve">
          <source>To split by Unicode &lt;code&gt;Whitespace&lt;/code&gt; instead, use &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008a095ac9e41d95c26562938b70663fdac5db0b" translate="yes" xml:space="preserve">
          <source>To split by Unicode &lt;code&gt;Whitespace&lt;/code&gt; instead, use &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39efc8d301c98f5b54ae3dfd338106520f5157d1" translate="yes" xml:space="preserve">
          <source>To start defining the procedural macro, place the code in Listing 19-31 into your &lt;em&gt;src/lib.rs&lt;/em&gt; file for the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate. Note that this code won&amp;rsquo;t compile until we add a definition for the &lt;code&gt;impl_hello_macro&lt;/code&gt; function.</source>
          <target state="translated">要开始定义过程宏，请将清单19-31中的代码放入 &lt;code&gt;hello_macro_derive&lt;/code&gt; 板条箱的&lt;em&gt;src / lib.rs&lt;/em&gt;文件中。请注意，直到我们为 &lt;code&gt;impl_hello_macro&lt;/code&gt; 函数添加定义后，该代码才会编译。</target>
        </trans-unit>
        <trans-unit id="4cd7a51fb6e1263e5fbdd69b060072fe94d9dc2f" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;ll build a tree with nodes that know about their child nodes. We&amp;rsquo;ll create a struct named &lt;code&gt;Node&lt;/code&gt; that holds its own &lt;code&gt;i32&lt;/code&gt; value as well as references to its children &lt;code&gt;Node&lt;/code&gt; values:</source>
          <target state="translated">首先，我们将建立一个带有知道其子节点的节点的树。我们将创建一个名为 &lt;code&gt;Node&lt;/code&gt; 的结构，该结构保留自己的 &lt;code&gt;i32&lt;/code&gt; 值以及对其子 &lt;code&gt;Node&lt;/code&gt; 值的引用：</target>
        </trans-unit>
        <trans-unit id="e88b248a81f262510bb36c205a0d4dc2d7d064a2" translate="yes" xml:space="preserve">
          <source>To structure our crate in the same way that a real restaurant works, we can organize the functions into nested modules. Create a new library named &lt;code&gt;restaurant&lt;/code&gt; by running &lt;code&gt;cargo new --lib restaurant&lt;/code&gt;; then put the code in Listing 7-1 into &lt;em&gt;src/lib.rs&lt;/em&gt; to define some modules and function signatures.</source>
          <target state="translated">为了以与实际餐厅相同的方式构造板条箱，我们可以将功能组织到嵌套模块中。通过运行 &lt;code&gt;cargo new --lib restaurant&lt;/code&gt; 创建一个名为 &lt;code&gt;restaurant&lt;/code&gt; 的新库；然后将清单7-1中的代码放入&lt;em&gt;src / lib.rs中，&lt;/em&gt;以定义一些模块和函数签名。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="314819f76bd8c5d973c493b80242bed1a2fc84f6" translate="yes" xml:space="preserve">
          <source>To summarize, here you can find the full grammar of format strings. The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by &lt;code&gt;{}&lt;/code&gt; instead of the C-like &lt;code&gt;%&lt;/code&gt;. The actual grammar for the formatting syntax is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f66b79eaf886d6c72a892191c1e18c1c1df90d3" translate="yes" xml:space="preserve">
          <source>To summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of &lt;code&gt;String&lt;/code&gt; data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</source>
          <target state="translated">总而言之，字符串很复杂。对于如何将这种复杂性呈现给程序员，不同的编程语言做出了不同的选择。Rust选择将正确处理 &lt;code&gt;String&lt;/code&gt; 数据作为所有Rust程序的默认行为，这意味着程序员必须在处理UTF-8数据方面投入更多精力。与其他编程语言相比，这种折衷会带来更多的字符串复杂性，但是这可以防止您在开发生命周期的后期不得不处理涉及非ASCII字符的错误。</target>
        </trans-unit>
        <trans-unit id="de7e750f454d2e6ac7a8ffdfb7a0160a0d2868ee" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;let mut guess = String::new();&lt;/code&gt; line has created a mutable variable that is currently bound to a new, empty instance of a &lt;code&gt;String&lt;/code&gt;. Whew!</source>
          <target state="translated">总而言之， &lt;code&gt;let mut guess = String::new();&lt;/code&gt; 行创建了一个可变变量，该变量当前绑定到 &lt;code&gt;String&lt;/code&gt; 的新的空实例。ew！</target>
        </trans-unit>
        <trans-unit id="9cb396520770d271c92551f4d7e0bcd83c651b95" translate="yes" xml:space="preserve">
          <source>To switch to unsafe Rust, use the &lt;code&gt;unsafe&lt;/code&gt; keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust, called &lt;em&gt;unsafe superpowers&lt;/em&gt;, that you can&amp;rsquo;t in safe Rust. Those superpowers include the ability to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43e14ce7587570f1bef4bdb30b6cbaa4b75f17f" translate="yes" xml:space="preserve">
          <source>To switch to unsafe Rust, use the &lt;code&gt;unsafe&lt;/code&gt; keyword and then start a new block that holds the unsafe code. You can take four actions in unsafe Rust, called &lt;em&gt;unsafe superpowers&lt;/em&gt;, that you can&amp;rsquo;t in safe Rust. Those superpowers include the ability to:</source>
          <target state="translated">要切换到不安全的Rust，请使用 &lt;code&gt;unsafe&lt;/code&gt; 关键字，然后启动一个包含不安全代码的新块。您可以在不安全的Rust中执行四个操作，称为&lt;em&gt;不安全的超级大国&lt;/em&gt;，而您不能在安全的Rust中进行。这些超级大国具备以下能力：</target>
        </trans-unit>
        <trans-unit id="11f1d9981c2d0b02d68889e44295f6ab0f30c56d" translate="yes" xml:space="preserve">
          <source>To terminate a raw string, you have to have the same number of &lt;code&gt;#&lt;/code&gt; at the end as at the beginning. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31217910df272b1f25ece09faa304c39aefdc3a5" translate="yes" xml:space="preserve">
          <source>To this:</source>
          <target state="translated">对此:</target>
        </trans-unit>
        <trans-unit id="057adfa85ddef458f115bd296031094452f5b4a0" translate="yes" xml:space="preserve">
          <source>To understand better how closures work in Rust, read: https://doc.rust-lang.org/book/ch13-01-closures.html</source>
          <target state="translated">为了更好地了解Rust中的闭包工作,请阅读:https://doc.rust-lang.org/book/ch13-01-closures.html。</target>
        </trans-unit>
        <trans-unit id="28d2bbf95b0b86d0881e2c7c6550fc005fe06275" translate="yes" xml:space="preserve">
          <source>To understand what this means, it is perhaps easier to consider a few examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87f629cfb96af20696ef3d804bdc670ac7c36a2" translate="yes" xml:space="preserve">
          <source>To understand when we might want to use structs, let&amp;rsquo;s write a program that calculates the area of a rectangle. We&amp;rsquo;ll start with single variables, and then refactor the program until we&amp;rsquo;re using structs instead.</source>
          <target state="translated">为了了解何时需要使用结构，让我们编写一个计算矩形面积的程序。我们将从单个变量开始，然后重构程序，直到我们改为使用结构。</target>
        </trans-unit>
        <trans-unit id="f3887dc1ab813c2423acfe9d57d029c4502fb78e" translate="yes" xml:space="preserve">
          <source>To uninstall Rust and &lt;code&gt;rustup&lt;/code&gt;, run the following uninstall script from your shell:</source>
          <target state="translated">要卸载Rust和 &lt;code&gt;rustup&lt;/code&gt; ，请从您的shell中运行以下卸载脚本：</target>
        </trans-unit>
        <trans-unit id="662f41af8eb574e21b57913c6f9a0bd1516cbc7a" translate="yes" xml:space="preserve">
          <source>To uppercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_uppercase&quot;&gt;&lt;code&gt;to_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非ASCII字符外，要大写ASCII字符，请使用&lt;a href=&quot;#method.to_uppercase&quot;&gt; &lt;code&gt;to_uppercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bae7e9e1be3baf0aecb5ead601705215f7341743" translate="yes" xml:space="preserve">
          <source>To uppercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_uppercase&quot;&gt;&lt;code&gt;str::to_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非ASCII字符外，要大写ASCII字符，请使用&lt;a href=&quot;../primitive.str#method.to_uppercase&quot;&gt; &lt;code&gt;str::to_uppercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ceeb5afb45130513f95c0c76f8c194cbc22cc90" translate="yes" xml:space="preserve">
          <source>To uppercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_uppercase&quot;&gt;&lt;code&gt;str::to_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c3dbee0cfe96289d27fa6bc805ddc167d97ef8" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要大写就地值，请使用&lt;a href=&quot;#method.make_ascii_uppercase&quot;&gt; &lt;code&gt;make_ascii_uppercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0fee41197e5788cb8d5e92ad9fa5f070d016314" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要大写就地值，请使用&lt;a href=&quot;#tymethod.make_ascii_uppercase&quot;&gt; &lt;code&gt;make_ascii_uppercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03872893861b26ce89768ebad491eb1be2bc29f7" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;../primitive.str#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ba625fbc6adb072f55ed4d3847b030100a31e3" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;../primitive.u8#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d877f3de3ce27771a5ff9e83ea6d9c1e61cdbd" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;primitive.str#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ebf88e0ca05fe29ac69ce486bd57ddd729efb8" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;primitive.u8#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad9a8481cb2cb5dd232df2f396463103d3a41d2" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;struct.osstr#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec9e0a0dd307f8b51434cf6c875a527cefcad70" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0a581c19fda5f34a2ecc353cab28485839d3f8" translate="yes" xml:space="preserve">
          <source>To use a default implementation to summarize instances of &lt;code&gt;NewsArticle&lt;/code&gt; instead of defining a custom implementation, we specify an empty &lt;code&gt;impl&lt;/code&gt; block with &lt;code&gt;impl Summary for NewsArticle {}&lt;/code&gt;.</source>
          <target state="translated">要使用默认实现来汇总 &lt;code&gt;NewsArticle&lt;/code&gt; 的实例，而不是定义自定义实现，我们 &lt;code&gt;impl Summary for NewsArticle {}&lt;/code&gt; 指定一个空的 &lt;code&gt;impl&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="9f435d65416d088237053151174da52702ca2759" translate="yes" xml:space="preserve">
          <source>To use a module from your current crate, add the &lt;code&gt;crate::&lt;/code&gt; prefix to the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbf67a283306a6366d793a3b3158fdc68b8ad73" translate="yes" xml:space="preserve">
          <source>To use a namespace itself in addition to some of its members, &lt;code&gt;self&lt;/code&gt; may appear as part of a brace-enclosed list of imports:</source>
          <target state="translated">要在名称空间的某些成员之外使用名称空间本身，则 &lt;code&gt;self&lt;/code&gt; 可能会出现在大括号括住的导入列表中：</target>
        </trans-unit>
        <trans-unit id="4b03ec43b2895de636748b67704c685a1fa98427" translate="yes" xml:space="preserve">
          <source>To use a pattern, we compare it to some value. If the pattern matches the value, we use the value parts in our code. Recall the &lt;code&gt;match&lt;/code&gt; expressions in Chapter 6 that used patterns, such as the coin-sorting machine example. If the value fits the shape of the pattern, we can use the named pieces. If it doesn&amp;rsquo;t, the code associated with the pattern won&amp;rsquo;t run.</source>
          <target state="translated">要使用模式，我们将其与某个值进行比较。如果模式与值匹配，则在代码中使用值部分。回忆第6章中使用模式的 &lt;code&gt;match&lt;/code&gt; 表达式，例如硬币分拣机示例。如果值适合图案的形状，则可以使用命名的片段。如果不是，则与模式关联的代码将不会运行。</target>
        </trans-unit>
        <trans-unit id="6cd526c3f5cdfb3e49b95a57c88c2fc1245de535" translate="yes" xml:space="preserve">
          <source>To use a slice type it generally has to be used behind a pointer for example as:</source>
          <target state="translated">如果要使用分片类型,一般要在指针后面使用,例如作为。</target>
        </trans-unit>
        <trans-unit id="1d9510373e7fd3a8d97cc9744e3544cf1ebe365c" translate="yes" xml:space="preserve">
          <source>To use a struct after we&amp;rsquo;ve defined it, we create an &lt;em&gt;instance&lt;/em&gt; of that struct by specifying concrete values for each of the fields. We create an instance by stating the name of the struct and then add curly brackets containing &lt;code&gt;key: value&lt;/code&gt; pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don&amp;rsquo;t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type. For example, we can declare a particular user as shown in Listing 5-2.</source>
          <target state="translated">要在定义结构后使用结构，我们通过为每个字段指定具体值来创建该结构的&lt;em&gt;实例&lt;/em&gt;。我们通过说明结构的名称来创建实例，然后添加包含 &lt;code&gt;key: value&lt;/code&gt; 对的大括号，其中key是字段的名称，而value是我们要存储在这些字段中的数据。我们不必按照在结构中声明它们的顺序来指定字段。换句话说，结构定义就像该类型的通用模板，实例用特定的数据填充该模板以创建该类型的值。例如，我们可以声明一个特定的用户，如清单5-2所示。</target>
        </trans-unit>
        <trans-unit id="27989b6610882b719a5ea410b5f71f23c1e34efa" translate="yes" xml:space="preserve">
          <source>To use this feature locally, you typically will use the &lt;code&gt;RUSTFLAGS&lt;/code&gt; environment variable to specify flags to the compiler through Cargo. For example to compile a statically linked binary on MSVC you would execute:</source>
          <target state="translated">要在本地使用此功能，通常将使用 &lt;code&gt;RUSTFLAGS&lt;/code&gt; 环境变量通过Cargo为编译器指定标志。例如，要在MSVC上编译静态链接的二进制文件，可以执行以下命令：</target>
        </trans-unit>
        <trans-unit id="aa8b8effb94e7abcaae16085a72643f10b8227aa" translate="yes" xml:space="preserve">
          <source>To use this version of &lt;code&gt;Summary&lt;/code&gt;, we only need to define &lt;code&gt;summarize_author&lt;/code&gt; when we implement the trait on a type:</source>
          <target state="translated">要使用此版本的 &lt;code&gt;Summary&lt;/code&gt; ，我们只需要定义 &lt;code&gt;summarize_author&lt;/code&gt; 当我们执行一个类型的特征：</target>
        </trans-unit>
        <trans-unit id="bc4c76af44cf81aae5a3bedd1a4fabcaf591ba2f" translate="yes" xml:space="preserve">
          <source>To wake up all threads, see &lt;a href=&quot;#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要唤醒所有线程，请参见&lt;a href=&quot;#method.notify_all&quot;&gt; &lt;code&gt;notify_all&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bba606e9595f006eac21496e730831a817fd203" translate="yes" xml:space="preserve">
          <source>To wake up all threads, see &lt;a href=&quot;struct.condvar#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d932c297a4d2b73e1f772e97d55db4b8e0dc93" translate="yes" xml:space="preserve">
          <source>To wake up only one thread, see &lt;a href=&quot;#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要仅唤醒一个线程，请参见&lt;a href=&quot;#method.notify_one&quot;&gt; &lt;code&gt;notify_one&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bee8651caa9f53e075921bde6a903cb8a56a8a73" translate="yes" xml:space="preserve">
          <source>To wake up only one thread, see &lt;a href=&quot;struct.condvar#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88cf3ca8e9feae5d3beb7bbd55b97e74623d342" translate="yes" xml:space="preserve">
          <source>To work around this restriction, consider &quot;hiding&quot; the value behind a reference: either &lt;code&gt;&amp;amp;x&lt;/code&gt; or &lt;code&gt;&amp;amp;mut x&lt;/code&gt;. Since a reference has a fixed size, this lets you move it around as usual. Example:</source>
          <target state="translated">要解决此限制，请考虑&amp;ldquo;隐藏&amp;rdquo;引用后面的值： &lt;code&gt;&amp;amp;x&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut x&lt;/code&gt; 。由于参考的大小是固定的，因此您可以像往常一样移动它。例：</target>
        </trans-unit>
        <trans-unit id="6500c202f483ded49d90dd12d80754b82fdf0dff" translate="yes" xml:space="preserve">
          <source>To work around this, it can be covered with a local type, &lt;code&gt;MyType&lt;/code&gt;:</source>
          <target state="translated">要解决此问题，可以使用局部类型 &lt;code&gt;MyType&lt;/code&gt; 进行覆盖：</target>
        </trans-unit>
        <trans-unit id="36dd8bd129ed7bbb15977196b4ec891eb2cbcdbb" translate="yes" xml:space="preserve">
          <source>To work around this, we can use &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; to create two distinct mutable sub-slices from a slice:</source>
          <target state="translated">要解决此问题，我们可以使用&lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt;从切片创建两个不同的可变子切片：</target>
        </trans-unit>
        <trans-unit id="24f7e027af97b0bcea482e03195ef7fce8ba5648" translate="yes" xml:space="preserve">
          <source>To work around this, we can use &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; to create two distinct sub-slices from a slice:</source>
          <target state="translated">要解决此问题，我们可以使用&lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt;从切片创建两个不同的子切片：</target>
        </trans-unit>
        <trans-unit id="88426551199f60d0c53bc995bbba2a8ae94e26e1" translate="yes" xml:space="preserve">
          <source>To work with DSTs, Rust has a particular trait called the &lt;code&gt;Sized&lt;/code&gt; trait to determine whether or not a type&amp;rsquo;s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on &lt;code&gt;Sized&lt;/code&gt; to every generic function. That is, a generic function definition like this:</source>
          <target state="translated">为了使用DST，Rust具有一个特殊的特性，称为 &lt;code&gt;Sized&lt;/code&gt; 特性，用于确定在编译时是否知道类型的大小。对于在编译时已知大小的所有内容，将自动实现此特征。另外，Rust 为每个泛型函数隐式地在 &lt;code&gt;Sized&lt;/code&gt; 上添加了一个界限。也就是说，通用函数定义如下：</target>
        </trans-unit>
        <trans-unit id="fb14220cb77cbb7e4cc1fc269b18360bfeb61f7b" translate="yes" xml:space="preserve">
          <source>To yank a version of a crate, run &lt;code&gt;cargo yank&lt;/code&gt; and specify which version you want to yank:</source>
          <target state="translated">要拉取一个木箱的版本，请运行 &lt;code&gt;cargo yank&lt;/code&gt; 并指定要拉取的版本：</target>
        </trans-unit>
        <trans-unit id="358ef599a863a7317d7b73949a61a65e9c8b5929" translate="yes" xml:space="preserve">
          <source>ToLowercase</source>
          <target state="translated">ToLowercase</target>
        </trans-unit>
        <trans-unit id="df38106c5dbe8437c114ca2d685149a2779acb46" translate="yes" xml:space="preserve">
          <source>ToLowercase::all</source>
          <target state="translated">ToLowercase::all</target>
        </trans-unit>
        <trans-unit id="bbeaa264c1c37f2bac007b1544ec3f5ad9fa247a" translate="yes" xml:space="preserve">
          <source>ToLowercase::any</source>
          <target state="translated">ToLowercase::any</target>
        </trans-unit>
        <trans-unit id="0a141811b0b02a8a6bc1f88e69b931b80579b5c2" translate="yes" xml:space="preserve">
          <source>ToLowercase::borrow</source>
          <target state="translated">ToLowercase::borrow</target>
        </trans-unit>
        <trans-unit id="cdeca1abdbe65f3026e21a79b8f904e797c979d8" translate="yes" xml:space="preserve">
          <source>ToLowercase::borrow_mut</source>
          <target state="translated">ToLowercase::borrow_mut</target>
        </trans-unit>
        <trans-unit id="04089a7fe4a382bdeab885ef9891fb5765277adf" translate="yes" xml:space="preserve">
          <source>ToLowercase::by_ref</source>
          <target state="translated">ToLowercase::by_ref</target>
        </trans-unit>
        <trans-unit id="a079ce9b966f7512985cc3db6325af88008cc5f5" translate="yes" xml:space="preserve">
          <source>ToLowercase::chain</source>
          <target state="translated">ToLowercase::chain</target>
        </trans-unit>
        <trans-unit id="34f89547554d65a0175fa66474bd90120ecce7b1" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone</source>
          <target state="translated">ToLowercase::clone</target>
        </trans-unit>
        <trans-unit id="0a39078458104a1579ea1ffbefc1eff627ca4db9" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone_from</source>
          <target state="translated">ToLowercase::clone_from</target>
        </trans-unit>
        <trans-unit id="69987693fa5c572002cf4a8687ae06044830821a" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone_into</source>
          <target state="translated">ToLowercase::clone_into</target>
        </trans-unit>
        <trans-unit id="121cb5982b6d466308c6295488de685c5924188f" translate="yes" xml:space="preserve">
          <source>ToLowercase::cloned</source>
          <target state="translated">ToLowercase::cloned</target>
        </trans-unit>
        <trans-unit id="2a56c21b2935dd999e82afb8be288b273e7d2e4e" translate="yes" xml:space="preserve">
          <source>ToLowercase::cmp</source>
          <target state="translated">ToLowercase::cmp</target>
        </trans-unit>
        <trans-unit id="9a83c4a51b2449ab4001a1ea57020189f34eb86e" translate="yes" xml:space="preserve">
          <source>ToLowercase::collect</source>
          <target state="translated">ToLowercase::collect</target>
        </trans-unit>
        <trans-unit id="fc76b0e4ac6af8ee61de5ea6000b4e90b61281f6" translate="yes" xml:space="preserve">
          <source>ToLowercase::copied</source>
          <target state="translated">ToLowercase::copied</target>
        </trans-unit>
        <trans-unit id="ebd8500418acdbe357cc1847a2d0349da2ad6802" translate="yes" xml:space="preserve">
          <source>ToLowercase::count</source>
          <target state="translated">ToLowercase::count</target>
        </trans-unit>
        <trans-unit id="46c2bfc1c56cb3945b434e3354e83dfe8b8c506d" translate="yes" xml:space="preserve">
          <source>ToLowercase::cycle</source>
          <target state="translated">ToLowercase::cycle</target>
        </trans-unit>
        <trans-unit id="17c64b13d578e62f4865fa3a426a453511fad16f" translate="yes" xml:space="preserve">
          <source>ToLowercase::enumerate</source>
          <target state="translated">ToLowercase::enumerate</target>
        </trans-unit>
        <trans-unit id="22c6e7593fef2063b7782e7156f48b60a1a13824" translate="yes" xml:space="preserve">
          <source>ToLowercase::eq</source>
          <target state="translated">ToLowercase::eq</target>
        </trans-unit>
        <trans-unit id="a97a62afe9c15bee17e74d16036987e2c4a3f22a" translate="yes" xml:space="preserve">
          <source>ToLowercase::filter</source>
          <target state="translated">ToLowercase::filter</target>
        </trans-unit>
        <trans-unit id="282e7712aa0755dc3cee721bbb60ae3056ffd1b8" translate="yes" xml:space="preserve">
          <source>ToLowercase::filter_map</source>
          <target state="translated">ToLowercase::filter_map</target>
        </trans-unit>
        <trans-unit id="5e623530b92901b135346a206054ea74de34c74b" translate="yes" xml:space="preserve">
          <source>ToLowercase::find</source>
          <target state="translated">ToLowercase::find</target>
        </trans-unit>
        <trans-unit id="8199273d20714ffb35f8bf63fc8de1aeeb62aaaf" translate="yes" xml:space="preserve">
          <source>ToLowercase::find_map</source>
          <target state="translated">ToLowercase::find_map</target>
        </trans-unit>
        <trans-unit id="4ed7f75d1d13393082ea7b8eeecf7e820cecc331" translate="yes" xml:space="preserve">
          <source>ToLowercase::flat_map</source>
          <target state="translated">ToLowercase::flat_map</target>
        </trans-unit>
        <trans-unit id="8faef9a1d718b76295200253966c7806e7cdc59c" translate="yes" xml:space="preserve">
          <source>ToLowercase::flatten</source>
          <target state="translated">ToLowercase::flatten</target>
        </trans-unit>
        <trans-unit id="d060a84d6f235fd2215550273860f38eeab5eccf" translate="yes" xml:space="preserve">
          <source>ToLowercase::fmt</source>
          <target state="translated">ToLowercase::fmt</target>
        </trans-unit>
        <trans-unit id="8131b5a5bcf84d17a43fb10e483ba9ff1d8d359c" translate="yes" xml:space="preserve">
          <source>ToLowercase::fold</source>
          <target state="translated">ToLowercase::fold</target>
        </trans-unit>
        <trans-unit id="327b78b92e355c99705bbf603c2bb143fa92d2e9" translate="yes" xml:space="preserve">
          <source>ToLowercase::for_each</source>
          <target state="translated">ToLowercase::for_each</target>
        </trans-unit>
        <trans-unit id="c1d00ad3539f24458681e04a1741cd54badd39cf" translate="yes" xml:space="preserve">
          <source>ToLowercase::from</source>
          <target state="translated">ToLowercase::from</target>
        </trans-unit>
        <trans-unit id="7d595874443f42a9e344ead1449f7c72a2522b74" translate="yes" xml:space="preserve">
          <source>ToLowercase::fuse</source>
          <target state="translated">ToLowercase::fuse</target>
        </trans-unit>
        <trans-unit id="5f012ebb8814c9cf77a450ef55b693640b7421e7" translate="yes" xml:space="preserve">
          <source>ToLowercase::ge</source>
          <target state="translated">ToLowercase::ge</target>
        </trans-unit>
        <trans-unit id="a451e0c1969a73439fef2468147038b278d489fd" translate="yes" xml:space="preserve">
          <source>ToLowercase::gt</source>
          <target state="translated">ToLowercase::gt</target>
        </trans-unit>
        <trans-unit id="642b22a76015cab4922545ce0b1b8fce9e09e5ed" translate="yes" xml:space="preserve">
          <source>ToLowercase::inspect</source>
          <target state="translated">ToLowercase::inspect</target>
        </trans-unit>
        <trans-unit id="7ca3893f4299d51675bc4e51e48ab78b6e95e7ae" translate="yes" xml:space="preserve">
          <source>ToLowercase::into</source>
          <target state="translated">ToLowercase::into</target>
        </trans-unit>
        <trans-unit id="9baa58c23f7e0d689b278ecfab3e39c8efae52c3" translate="yes" xml:space="preserve">
          <source>ToLowercase::into_iter</source>
          <target state="translated">ToLowercase::into_iter</target>
        </trans-unit>
        <trans-unit id="41740e63b2346c1e13490d8bb5f5d3524774e936" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_empty</source>
          <target state="translated">ToLowercase::is_empty</target>
        </trans-unit>
        <trans-unit id="0a3555fc3fa048af9c1a10c2d056047061c3acad" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted</source>
          <target state="translated">ToLowercase::is_sorted</target>
        </trans-unit>
        <trans-unit id="d1e0425d483ec70bb6984df2a767d8b9e4f434c4" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted_by</source>
          <target state="translated">ToLowercase::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="a66c5bf8964eab56ac90671d7ee744d61569a85f" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted_by_key</source>
          <target state="translated">ToLowercase::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f9ef704f171d5f967ad9a902b9e6c885aa657d95" translate="yes" xml:space="preserve">
          <source>ToLowercase::last</source>
          <target state="translated">ToLowercase::last</target>
        </trans-unit>
        <trans-unit id="d3f98dd839d26ad724880104a40c7e70d33d18c3" translate="yes" xml:space="preserve">
          <source>ToLowercase::le</source>
          <target state="translated">ToLowercase::le</target>
        </trans-unit>
        <trans-unit id="e1ba36fd3934ba511b5d0af5c6f135a35664771b" translate="yes" xml:space="preserve">
          <source>ToLowercase::len</source>
          <target state="translated">ToLowercase::len</target>
        </trans-unit>
        <trans-unit id="2eed1cdf88b1cb0a9fa1233f81e8f43967248498" translate="yes" xml:space="preserve">
          <source>ToLowercase::lt</source>
          <target state="translated">ToLowercase::lt</target>
        </trans-unit>
        <trans-unit id="e43226c948078b9cc9aebaa496f80af6656f0917" translate="yes" xml:space="preserve">
          <source>ToLowercase::map</source>
          <target state="translated">ToLowercase::map</target>
        </trans-unit>
        <trans-unit id="e0c53789432635e282bac9afc1520196b7c560e8" translate="yes" xml:space="preserve">
          <source>ToLowercase::max</source>
          <target state="translated">ToLowercase::max</target>
        </trans-unit>
        <trans-unit id="903a830f2d66f982a4644a703e0e8e4957273461" translate="yes" xml:space="preserve">
          <source>ToLowercase::max_by</source>
          <target state="translated">ToLowercase::max_by</target>
        </trans-unit>
        <trans-unit id="18bae373fc9373515a693f2601a3ad81cbde3459" translate="yes" xml:space="preserve">
          <source>ToLowercase::max_by_key</source>
          <target state="translated">ToLowercase::max_by_key</target>
        </trans-unit>
        <trans-unit id="bb9afa7050228536bbc7504f5c5dfc47a13e78c0" translate="yes" xml:space="preserve">
          <source>ToLowercase::min</source>
          <target state="translated">ToLowercase::min</target>
        </trans-unit>
        <trans-unit id="77c4813b999aa04010a0f28c8553bcc6214e1616" translate="yes" xml:space="preserve">
          <source>ToLowercase::min_by</source>
          <target state="translated">ToLowercase::min_by</target>
        </trans-unit>
        <trans-unit id="423a7c3614737a7cb7033368fb85813297ba5915" translate="yes" xml:space="preserve">
          <source>ToLowercase::min_by_key</source>
          <target state="translated">ToLowercase::min_by_key</target>
        </trans-unit>
        <trans-unit id="45cf81c6356fb6305106b81d4e38e7f435f86cc1" translate="yes" xml:space="preserve">
          <source>ToLowercase::ne</source>
          <target state="translated">ToLowercase::ne</target>
        </trans-unit>
        <trans-unit id="a71fc3ee26e013ac8645c417796e09cd264a122e" translate="yes" xml:space="preserve">
          <source>ToLowercase::next</source>
          <target state="translated">ToLowercase::next</target>
        </trans-unit>
        <trans-unit id="1911198040fb257baaa909fbd9e0ff4bd63738b2" translate="yes" xml:space="preserve">
          <source>ToLowercase::nth</source>
          <target state="translated">ToLowercase::nth</target>
        </trans-unit>
        <trans-unit id="8e0ec3fa9f7c6b4e02f5cdbcceafdedd84b428e3" translate="yes" xml:space="preserve">
          <source>ToLowercase::partial_cmp</source>
          <target state="translated">ToLowercase::partial_cmp</target>
        </trans-unit>
        <trans-unit id="47c77ae9e15794fc333d6ed8815d4414bb103610" translate="yes" xml:space="preserve">
          <source>ToLowercase::partition</source>
          <target state="translated">ToLowercase::partition</target>
        </trans-unit>
        <trans-unit id="75ec1c2334a1ca3250b6d8818285245c4e4389b7" translate="yes" xml:space="preserve">
          <source>ToLowercase::peekable</source>
          <target state="translated">ToLowercase::peekable</target>
        </trans-unit>
        <trans-unit id="5bd4eb545154844db83963b7bf6e24d4160c4184" translate="yes" xml:space="preserve">
          <source>ToLowercase::position</source>
          <target state="translated">ToLowercase::position</target>
        </trans-unit>
        <trans-unit id="da1c2a6ce254ef365fc893f21ebcfb9884ec4d92" translate="yes" xml:space="preserve">
          <source>ToLowercase::product</source>
          <target state="translated">ToLowercase::product</target>
        </trans-unit>
        <trans-unit id="7513906fb803029e9d762eb5a94c745eb5662524" translate="yes" xml:space="preserve">
          <source>ToLowercase::rev</source>
          <target state="translated">ToLowercase::rev</target>
        </trans-unit>
        <trans-unit id="418774bd5cf3162562c6090441d234e9d61a03d7" translate="yes" xml:space="preserve">
          <source>ToLowercase::rposition</source>
          <target state="translated">ToLowercase::rposition</target>
        </trans-unit>
        <trans-unit id="9b317c9f2c5a4d58ea3427624437ce70f6752c98" translate="yes" xml:space="preserve">
          <source>ToLowercase::scan</source>
          <target state="translated">ToLowercase::scan</target>
        </trans-unit>
        <trans-unit id="2347172afd0d4f896ed7b4c55d0f9d8e2916251b" translate="yes" xml:space="preserve">
          <source>ToLowercase::size_hint</source>
          <target state="translated">ToLowercase::size_hint</target>
        </trans-unit>
        <trans-unit id="418c2ea2c35afdc50dcf9a90930d3ce62e8f3999" translate="yes" xml:space="preserve">
          <source>ToLowercase::skip</source>
          <target state="translated">ToLowercase::skip</target>
        </trans-unit>
        <trans-unit id="95df49075bec9d23f70a04c44f6a727846e429e6" translate="yes" xml:space="preserve">
          <source>ToLowercase::skip_while</source>
          <target state="translated">ToLowercase::skip_while</target>
        </trans-unit>
        <trans-unit id="b9d44057d9ed2703572ffed49f6eca5288b3d100" translate="yes" xml:space="preserve">
          <source>ToLowercase::step_by</source>
          <target state="translated">ToLowercase::step_by</target>
        </trans-unit>
        <trans-unit id="12fc6d57d9454f947a272a38199873e4fabe30e6" translate="yes" xml:space="preserve">
          <source>ToLowercase::sum</source>
          <target state="translated">ToLowercase::sum</target>
        </trans-unit>
        <trans-unit id="0f151b1e0bb55576903eeeb5a1d3d1df40fa455c" translate="yes" xml:space="preserve">
          <source>ToLowercase::take</source>
          <target state="translated">ToLowercase::take</target>
        </trans-unit>
        <trans-unit id="bb7ec83ca1b296882f68aab3b80d313fe4becdda" translate="yes" xml:space="preserve">
          <source>ToLowercase::take_while</source>
          <target state="translated">ToLowercase::take_while</target>
        </trans-unit>
        <trans-unit id="4ee080cf3eb36fa9ffb413ea40781d5206121d04" translate="yes" xml:space="preserve">
          <source>ToLowercase::to_owned</source>
          <target state="translated">ToLowercase::to_owned</target>
        </trans-unit>
        <trans-unit id="89719f79b975bafdc49f6c2bf1b53c77dd82479f" translate="yes" xml:space="preserve">
          <source>ToLowercase::to_string</source>
          <target state="translated">ToLowercase::to_string</target>
        </trans-unit>
        <trans-unit id="02fb5f5e1e24ebbf9a57d55d395e203de6f1bb79" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_fold</source>
          <target state="translated">ToLowercase::try_fold</target>
        </trans-unit>
        <trans-unit id="24adb2676fd932bafa66d72575c91291c6415cb3" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_for_each</source>
          <target state="translated">ToLowercase::try_for_each</target>
        </trans-unit>
        <trans-unit id="ca18cfcbad0e84fa95fbec8b5bfb913cdebdfd50" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_from</source>
          <target state="translated">ToLowercase::try_from</target>
        </trans-unit>
        <trans-unit id="e06d04b43ebaa98937e8ae299a145ab53f8f8401" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_into</source>
          <target state="translated">ToLowercase::try_into</target>
        </trans-unit>
        <trans-unit id="37b6363c64db2b818bf5770928eeb9cb5799b27c" translate="yes" xml:space="preserve">
          <source>ToLowercase::type_id</source>
          <target state="translated">ToLowercase::type_id</target>
        </trans-unit>
        <trans-unit id="5dab7a97b855d1005e423aac5a301136ccbfbda8" translate="yes" xml:space="preserve">
          <source>ToLowercase::unzip</source>
          <target state="translated">ToLowercase::unzip</target>
        </trans-unit>
        <trans-unit id="8c6300316ee7d9e235cf97abcd7ffe7ee60f526a" translate="yes" xml:space="preserve">
          <source>ToLowercase::zip</source>
          <target state="translated">ToLowercase::zip</target>
        </trans-unit>
        <trans-unit id="6a954abfe9e5f07fb766f0356ed1234d8f9b2362" translate="yes" xml:space="preserve">
          <source>ToOwned</source>
          <target state="translated">ToOwned</target>
        </trans-unit>
        <trans-unit id="88395f188f7e1627b5813c10232224a853eb2ce1" translate="yes" xml:space="preserve">
          <source>ToOwned::clone_into</source>
          <target state="translated">ToOwned::clone_into</target>
        </trans-unit>
        <trans-unit id="b54aeb29a238430e61c4864d679de09e146fc8bd" translate="yes" xml:space="preserve">
          <source>ToOwned::to_owned</source>
          <target state="translated">ToOwned::to_owned</target>
        </trans-unit>
        <trans-unit id="db76836dc2d12f75bc694c079718628342759cd3" translate="yes" xml:space="preserve">
          <source>ToSocketAddrs</source>
          <target state="translated">ToSocketAddrs</target>
        </trans-unit>
        <trans-unit id="0fed83f8d392d8ac77157990f089f9649d9b7750" translate="yes" xml:space="preserve">
          <source>ToSocketAddrs::to_socket_addrs</source>
          <target state="translated">ToSocketAddrs::to_socket_addrs</target>
        </trans-unit>
        <trans-unit id="1dbc7385badbfda548fb27e2160a33cf32c0f545" translate="yes" xml:space="preserve">
          <source>ToString</source>
          <target state="translated">ToString</target>
        </trans-unit>
        <trans-unit id="44b9808561fdc5221237b58497f052b0ab411690" translate="yes" xml:space="preserve">
          <source>ToString::to_string</source>
          <target state="translated">ToString::to_string</target>
        </trans-unit>
        <trans-unit id="0e33b561569f62cb10ee567c1f64d4f901389c05" translate="yes" xml:space="preserve">
          <source>ToUppercase</source>
          <target state="translated">ToUppercase</target>
        </trans-unit>
        <trans-unit id="9ff9a36e95ac5564578763dcb0e10b5a089787be" translate="yes" xml:space="preserve">
          <source>ToUppercase::all</source>
          <target state="translated">ToUppercase::all</target>
        </trans-unit>
        <trans-unit id="65730a9e88411b06193ba55e82da8ee1907a8064" translate="yes" xml:space="preserve">
          <source>ToUppercase::any</source>
          <target state="translated">ToUppercase::any</target>
        </trans-unit>
        <trans-unit id="7bbc3824337aaeab2c429030633a1af5ed905e80" translate="yes" xml:space="preserve">
          <source>ToUppercase::borrow</source>
          <target state="translated">ToUppercase::borrow</target>
        </trans-unit>
        <trans-unit id="054e212cd833cb188e6198592b3d47a12224a8d7" translate="yes" xml:space="preserve">
          <source>ToUppercase::borrow_mut</source>
          <target state="translated">ToUppercase::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6cb0a8be2d9bacab3bc53f929148bf74eddc427a" translate="yes" xml:space="preserve">
          <source>ToUppercase::by_ref</source>
          <target state="translated">ToUppercase::by_ref</target>
        </trans-unit>
        <trans-unit id="f6523db9347a61697b6b9197bca2d6fba8a42d3c" translate="yes" xml:space="preserve">
          <source>ToUppercase::chain</source>
          <target state="translated">ToUppercase::chain</target>
        </trans-unit>
        <trans-unit id="c0aca2868b888310176cab83baeec3b2d775557f" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone</source>
          <target state="translated">ToUppercase::clone</target>
        </trans-unit>
        <trans-unit id="67fd93e201a873e97c66908ead7ceae8bc1e8a92" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone_from</source>
          <target state="translated">ToUppercase::clone_from</target>
        </trans-unit>
        <trans-unit id="b84ef7303ff66cf2803f532b77195b1cf5d457a1" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone_into</source>
          <target state="translated">ToUppercase::clone_into</target>
        </trans-unit>
        <trans-unit id="5ccbf12c4818e31f1595aa777831465b36f69a51" translate="yes" xml:space="preserve">
          <source>ToUppercase::cloned</source>
          <target state="translated">ToUppercase::cloned</target>
        </trans-unit>
        <trans-unit id="a8f2e905cd5750074d352d368e76df6b39f96427" translate="yes" xml:space="preserve">
          <source>ToUppercase::cmp</source>
          <target state="translated">ToUppercase::cmp</target>
        </trans-unit>
        <trans-unit id="1dc5a2f9004fb521903e5e5a3fd364dc11757205" translate="yes" xml:space="preserve">
          <source>ToUppercase::collect</source>
          <target state="translated">ToUppercase::collect</target>
        </trans-unit>
        <trans-unit id="af8f9ceea80fc5e950363e9318dd158d01a4d040" translate="yes" xml:space="preserve">
          <source>ToUppercase::copied</source>
          <target state="translated">ToUppercase::copied</target>
        </trans-unit>
        <trans-unit id="1366fc011a472ff5d53cde6f1ac86461228351e7" translate="yes" xml:space="preserve">
          <source>ToUppercase::count</source>
          <target state="translated">ToUppercase::count</target>
        </trans-unit>
        <trans-unit id="1184c3c693dff48405ca7548cca0ed458ff29830" translate="yes" xml:space="preserve">
          <source>ToUppercase::cycle</source>
          <target state="translated">ToUppercase::cycle</target>
        </trans-unit>
        <trans-unit id="4e91911466f6b5af4078b70e11c4d24775fe742f" translate="yes" xml:space="preserve">
          <source>ToUppercase::enumerate</source>
          <target state="translated">ToUppercase::enumerate</target>
        </trans-unit>
        <trans-unit id="7840d75ecceac6bb8014df3896750d9d72c6c4f4" translate="yes" xml:space="preserve">
          <source>ToUppercase::eq</source>
          <target state="translated">ToUppercase::eq</target>
        </trans-unit>
        <trans-unit id="2a9bfa9a45635d09ff4f0e7dbad7c78cf4865a99" translate="yes" xml:space="preserve">
          <source>ToUppercase::filter</source>
          <target state="translated">ToUppercase::filter</target>
        </trans-unit>
        <trans-unit id="a2ce94b0c7944e165ba6c67b1e1d6438853b3133" translate="yes" xml:space="preserve">
          <source>ToUppercase::filter_map</source>
          <target state="translated">ToUppercase::filter_map</target>
        </trans-unit>
        <trans-unit id="33b7908aaa91c2cca1edd3fbd1eb5ed2b7161ab8" translate="yes" xml:space="preserve">
          <source>ToUppercase::find</source>
          <target state="translated">ToUppercase::find</target>
        </trans-unit>
        <trans-unit id="26582c132713274fb6090fc39fe168d493ee012a" translate="yes" xml:space="preserve">
          <source>ToUppercase::find_map</source>
          <target state="translated">ToUppercase::find_map</target>
        </trans-unit>
        <trans-unit id="d2233ee6bb72d979bc01f41100247c5902cf0607" translate="yes" xml:space="preserve">
          <source>ToUppercase::flat_map</source>
          <target state="translated">ToUppercase::flat_map</target>
        </trans-unit>
        <trans-unit id="bc467f30c7752c24841765febf75cc9fdc574574" translate="yes" xml:space="preserve">
          <source>ToUppercase::flatten</source>
          <target state="translated">ToUppercase::flatten</target>
        </trans-unit>
        <trans-unit id="da04bbd5685fac2d5a4df3c9db6cca8ac3ddfa78" translate="yes" xml:space="preserve">
          <source>ToUppercase::fmt</source>
          <target state="translated">ToUppercase::fmt</target>
        </trans-unit>
        <trans-unit id="dab772b50aae344c74f698ba5170622c5f015ee3" translate="yes" xml:space="preserve">
          <source>ToUppercase::fold</source>
          <target state="translated">ToUppercase::fold</target>
        </trans-unit>
        <trans-unit id="771853b6cd0b3a3d225b473ef9703bb5e4303729" translate="yes" xml:space="preserve">
          <source>ToUppercase::for_each</source>
          <target state="translated">ToUppercase::for_each</target>
        </trans-unit>
        <trans-unit id="8ce8c4bb893f0605c572e1569c0a3c898fc706ea" translate="yes" xml:space="preserve">
          <source>ToUppercase::from</source>
          <target state="translated">ToUppercase::from</target>
        </trans-unit>
        <trans-unit id="e5bc2c74a5fd665c9a82c2a33e80270730f97b12" translate="yes" xml:space="preserve">
          <source>ToUppercase::fuse</source>
          <target state="translated">ToUppercase::fuse</target>
        </trans-unit>
        <trans-unit id="20067e8f8574346c33f6af0deb21cc95edf75430" translate="yes" xml:space="preserve">
          <source>ToUppercase::ge</source>
          <target state="translated">ToUppercase::ge</target>
        </trans-unit>
        <trans-unit id="d691aa9e30d434c7acd37842ea89626858043c5a" translate="yes" xml:space="preserve">
          <source>ToUppercase::gt</source>
          <target state="translated">ToUppercase::gt</target>
        </trans-unit>
        <trans-unit id="2c07bcd9aa88f2987da2c05609b8b051fbd0bd49" translate="yes" xml:space="preserve">
          <source>ToUppercase::inspect</source>
          <target state="translated">ToUppercase::inspect</target>
        </trans-unit>
        <trans-unit id="fdebac9771e781ff415a919dcfc0e2e2f813f95f" translate="yes" xml:space="preserve">
          <source>ToUppercase::into</source>
          <target state="translated">ToUppercase::into</target>
        </trans-unit>
        <trans-unit id="28c925e3769d53d774548da83c53adf049d9614e" translate="yes" xml:space="preserve">
          <source>ToUppercase::into_iter</source>
          <target state="translated">ToUppercase::into_iter</target>
        </trans-unit>
        <trans-unit id="bf3856a1c7cdbe8a6b0b5d5447d4f1dda66c5b87" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_empty</source>
          <target state="translated">ToUppercase::is_empty</target>
        </trans-unit>
        <trans-unit id="e56ebe838b86d90990ba23ebb8e7d7b475bfba70" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted</source>
          <target state="translated">ToUppercase::is_sorted</target>
        </trans-unit>
        <trans-unit id="e213f890c3567bf89ebbd96dd28396c3c8369989" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted_by</source>
          <target state="translated">ToUppercase::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="4214e06077f37c115583c69ea8457f9ca4ca03c8" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted_by_key</source>
          <target state="translated">ToUppercase::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="43c20634324c1e57c53610dd095c7b85f97be6a8" translate="yes" xml:space="preserve">
          <source>ToUppercase::last</source>
          <target state="translated">ToUppercase::last</target>
        </trans-unit>
        <trans-unit id="e15b9289846aa62aa7c399eec130546dddf92570" translate="yes" xml:space="preserve">
          <source>ToUppercase::le</source>
          <target state="translated">ToUppercase::le</target>
        </trans-unit>
        <trans-unit id="bf4ae1725f8c939f34b0f3698672e2eca8d46e36" translate="yes" xml:space="preserve">
          <source>ToUppercase::len</source>
          <target state="translated">ToUppercase::len</target>
        </trans-unit>
        <trans-unit id="6ef86484cb6e83aca67edc255bfe91855fddeaee" translate="yes" xml:space="preserve">
          <source>ToUppercase::lt</source>
          <target state="translated">ToUppercase::lt</target>
        </trans-unit>
        <trans-unit id="36fb30f84e7d12187cc3a5d20674f0ffa2e7e434" translate="yes" xml:space="preserve">
          <source>ToUppercase::map</source>
          <target state="translated">ToUppercase::map</target>
        </trans-unit>
        <trans-unit id="a5794f06c8f621ebfd36483cb2bdfba69962a46b" translate="yes" xml:space="preserve">
          <source>ToUppercase::max</source>
          <target state="translated">ToUppercase::max</target>
        </trans-unit>
        <trans-unit id="54ed5ffb42b174875a2cfcdf299aa03324e7d8e8" translate="yes" xml:space="preserve">
          <source>ToUppercase::max_by</source>
          <target state="translated">ToUppercase::max_by</target>
        </trans-unit>
        <trans-unit id="82140a942c03457466b33d70a38f8b426ee443a8" translate="yes" xml:space="preserve">
          <source>ToUppercase::max_by_key</source>
          <target state="translated">ToUppercase::max_by_key</target>
        </trans-unit>
        <trans-unit id="8c46ff457e70dbefd5377da1fe14a1d716feed69" translate="yes" xml:space="preserve">
          <source>ToUppercase::min</source>
          <target state="translated">ToUppercase::min</target>
        </trans-unit>
        <trans-unit id="1f4f06fa647a15bfd6777e3ad80989539da952c2" translate="yes" xml:space="preserve">
          <source>ToUppercase::min_by</source>
          <target state="translated">ToUppercase::min_by</target>
        </trans-unit>
        <trans-unit id="d2ca7b43662db6e83751c9781321c5f447b69b54" translate="yes" xml:space="preserve">
          <source>ToUppercase::min_by_key</source>
          <target state="translated">ToUppercase::min_by_key</target>
        </trans-unit>
        <trans-unit id="a2c10d642735dd01dd2230f6eb42d2d15de01ca4" translate="yes" xml:space="preserve">
          <source>ToUppercase::ne</source>
          <target state="translated">ToUppercase::ne</target>
        </trans-unit>
        <trans-unit id="bdcf8b574275972312b79411fc90c298fec5c707" translate="yes" xml:space="preserve">
          <source>ToUppercase::next</source>
          <target state="translated">ToUppercase::next</target>
        </trans-unit>
        <trans-unit id="d3b98223ff39c0cf8bc6901176a913dbb5af5a3f" translate="yes" xml:space="preserve">
          <source>ToUppercase::nth</source>
          <target state="translated">ToUppercase::nth</target>
        </trans-unit>
        <trans-unit id="ac55c59ffb3d1b90b5281f1cdb8221031a9f3d86" translate="yes" xml:space="preserve">
          <source>ToUppercase::partial_cmp</source>
          <target state="translated">ToUppercase::partial_cmp</target>
        </trans-unit>
        <trans-unit id="43ba4010531c56c76a71cac5c7783bb9326c06ff" translate="yes" xml:space="preserve">
          <source>ToUppercase::partition</source>
          <target state="translated">ToUppercase::partition</target>
        </trans-unit>
        <trans-unit id="8a67cd96d9e9df3939b7f6b2d037a84acda5915a" translate="yes" xml:space="preserve">
          <source>ToUppercase::peekable</source>
          <target state="translated">ToUppercase::peekable</target>
        </trans-unit>
        <trans-unit id="c5de4cd05b5eea91f6372ea13496d89698a886d9" translate="yes" xml:space="preserve">
          <source>ToUppercase::position</source>
          <target state="translated">ToUppercase::position</target>
        </trans-unit>
        <trans-unit id="3276e7acdf8a52ca46452466df5445f95d4c42ce" translate="yes" xml:space="preserve">
          <source>ToUppercase::product</source>
          <target state="translated">ToUppercase::product</target>
        </trans-unit>
        <trans-unit id="2ec3aca6fa0998e131a8dbb7e0429f53b8e20e3a" translate="yes" xml:space="preserve">
          <source>ToUppercase::rev</source>
          <target state="translated">ToUppercase::rev</target>
        </trans-unit>
        <trans-unit id="1f5b04931231d64a89f93330632ae0491d9a8306" translate="yes" xml:space="preserve">
          <source>ToUppercase::rposition</source>
          <target state="translated">ToUppercase::rposition</target>
        </trans-unit>
        <trans-unit id="bd0bd16a7f62be84e2b4f57e866e556615bf5f51" translate="yes" xml:space="preserve">
          <source>ToUppercase::scan</source>
          <target state="translated">ToUppercase::scan</target>
        </trans-unit>
        <trans-unit id="c12a079f9acc9eb022d00c3c9e691984df24e3dd" translate="yes" xml:space="preserve">
          <source>ToUppercase::size_hint</source>
          <target state="translated">ToUppercase::size_hint</target>
        </trans-unit>
        <trans-unit id="36cc8342ae3ebfcc66e29de8713ad4b5d25ed1ec" translate="yes" xml:space="preserve">
          <source>ToUppercase::skip</source>
          <target state="translated">ToUppercase::skip</target>
        </trans-unit>
        <trans-unit id="bc763b46d6ffe3cde30022e6b310b987fb4690fc" translate="yes" xml:space="preserve">
          <source>ToUppercase::skip_while</source>
          <target state="translated">ToUppercase::skip_while</target>
        </trans-unit>
        <trans-unit id="bdd73144830ccf5acc66a08a0eb4055b58dd100c" translate="yes" xml:space="preserve">
          <source>ToUppercase::step_by</source>
          <target state="translated">ToUppercase::step_by</target>
        </trans-unit>
        <trans-unit id="355510b3a2c94feee0516eb6236e6b26c520c86f" translate="yes" xml:space="preserve">
          <source>ToUppercase::sum</source>
          <target state="translated">ToUppercase::sum</target>
        </trans-unit>
        <trans-unit id="5f1bfaa41ae891ff2a87080b765b405813dfaf1e" translate="yes" xml:space="preserve">
          <source>ToUppercase::take</source>
          <target state="translated">ToUppercase::take</target>
        </trans-unit>
        <trans-unit id="ace4eaaac22836c883eb26f26b69083a1e81c44a" translate="yes" xml:space="preserve">
          <source>ToUppercase::take_while</source>
          <target state="translated">ToUppercase::take_while</target>
        </trans-unit>
        <trans-unit id="aeac81822411ec59962d593c1135903013fb64dd" translate="yes" xml:space="preserve">
          <source>ToUppercase::to_owned</source>
          <target state="translated">ToUppercase::to_owned</target>
        </trans-unit>
        <trans-unit id="c254c93eabb3947af47ca116107ff60db0f65f9f" translate="yes" xml:space="preserve">
          <source>ToUppercase::to_string</source>
          <target state="translated">ToUppercase::to_string</target>
        </trans-unit>
        <trans-unit id="9586835b3ffa68bc81bff272ded62df7bfd896a5" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_fold</source>
          <target state="translated">ToUppercase::try_fold</target>
        </trans-unit>
        <trans-unit id="3285dc30d7466785bb24e349a2a90f48ee1105df" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_for_each</source>
          <target state="translated">ToUppercase::try_for_each</target>
        </trans-unit>
        <trans-unit id="f78675d80da0fb2dc076781338842ee7388e6bbb" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_from</source>
          <target state="translated">ToUppercase::try_from</target>
        </trans-unit>
        <trans-unit id="bbc85f420c55ff506706c343e3d016f559155d33" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_into</source>
          <target state="translated">ToUppercase::try_into</target>
        </trans-unit>
        <trans-unit id="67c5523cb2fdea348c069bcedcae5b194e0fa100" translate="yes" xml:space="preserve">
          <source>ToUppercase::type_id</source>
          <target state="translated">ToUppercase::type_id</target>
        </trans-unit>
        <trans-unit id="59512192fd21e6e15883e4c5f16fa785a7ae4b9e" translate="yes" xml:space="preserve">
          <source>ToUppercase::unzip</source>
          <target state="translated">ToUppercase::unzip</target>
        </trans-unit>
        <trans-unit id="71c5320853e9bf97d3c8e47e587d200e6ab7e991" translate="yes" xml:space="preserve">
          <source>ToUppercase::zip</source>
          <target state="translated">ToUppercase::zip</target>
        </trans-unit>
        <trans-unit id="c38c6c1f3a2743f8626703abb302e403d20ff81c" translate="yes" xml:space="preserve">
          <source>Tokens</source>
          <target state="translated">Tokens</target>
        </trans-unit>
        <trans-unit id="23b07a92f99f26864b1d4cab09dbe7e6ffc01402" translate="yes" xml:space="preserve">
          <source>Tokens are primitive productions in the grammar defined by regular (non-recursive) languages. Rust source input can be broken down into the following kinds of tokens:</source>
          <target state="translated">令牌是常规(非递归)语言定义的语法中的原始产物。Rust源输入可以分解为以下几种标记。</target>
        </trans-unit>
        <trans-unit id="d3997b5b9595479642fa6a353b8f62de4c85bdb4" translate="yes" xml:space="preserve">
          <source>Too few type arguments were supplied for a function. For example:</source>
          <target state="translated">一个函数提供的类型参数太少。例如:</target>
        </trans-unit>
        <trans-unit id="b64cc80b4d048074e951f53af2266c9b980ecc1d" translate="yes" xml:space="preserve">
          <source>Too many type arguments were supplied for a function. For example:</source>
          <target state="translated">为一个函数提供了太多的类型参数。例如:</target>
        </trans-unit>
        <trans-unit id="3becdad8640a8a7664cb1587373bbed530e9eaef" translate="yes" xml:space="preserve">
          <source>Tool attributes</source>
          <target state="translated">工具属性</target>
        </trans-unit>
        <trans-unit id="298b5435880f729f28b40fb8cb4d6d358f7d7bda" translate="yes" xml:space="preserve">
          <source>Tool attributes are not available if the &lt;a href=&quot;items/modules#prelude-items&quot;&gt;&lt;code&gt;no_implicit_prelude&lt;/code&gt;&lt;/a&gt; attribute is used.</source>
          <target state="translated">如果使用&lt;a href=&quot;items/modules#prelude-items&quot;&gt; &lt;code&gt;no_implicit_prelude&lt;/code&gt; &lt;/a&gt;属性，则工具属性不可用。</target>
        </trans-unit>
        <trans-unit id="04ecf72079460c624f56de2aec19167e9b592e5f" translate="yes" xml:space="preserve">
          <source>Tool lint attributes</source>
          <target state="translated">工具绒毛属性</target>
        </trans-unit>
        <trans-unit id="9e4ff695f8d7f54d10234c8c693febf11bceeb0a" translate="yes" xml:space="preserve">
          <source>Tool lints allows using scoped lints, to &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt; or &lt;code&gt;forbid&lt;/code&gt; lints of certain tools.</source>
          <target state="translated">工具棉绒允许使用作用域棉绒，以 &lt;code&gt;allow&lt;/code&gt; ， &lt;code&gt;warn&lt;/code&gt; ， &lt;code&gt;deny&lt;/code&gt; 或 &lt;code&gt;forbid&lt;/code&gt; 某些工具的棉绒。</target>
        </trans-unit>
        <trans-unit id="b0cfacecf587078db6db43488caa6d580978c4bb" translate="yes" xml:space="preserve">
          <source>Tool lints only get checked when the associated tool is active. If a lint attribute, such as &lt;code&gt;allow&lt;/code&gt;, references a nonexistent tool lint, the compiler will not warn about the nonexistent lint until you use the tool.</source>
          <target state="translated">仅在关联的工具处于活动状态时才检查工具棉绒。如果一个lint属性（例如 &lt;code&gt;allow&lt;/code&gt; ）引用了一个不存在的工具皮棉，那么在您使用该工具之前，编译器不会警告不存在的皮棉。</target>
        </trans-unit>
        <trans-unit id="2b3bf7074f1000742128073f003a13e0d75375fa" translate="yes" xml:space="preserve">
          <source>Tracking the inebriation of customers at a bar</source>
          <target state="translated">追踪顾客在酒吧的醉酒情况。</target>
        </trans-unit>
        <trans-unit id="dad674e48704a92597b8a13244ba1d8ca29324b7" translate="yes" xml:space="preserve">
          <source>Trade-offs</source>
          <target state="translated">Trade-offs</target>
        </trans-unit>
        <trans-unit id="8a6c5b14d85fb7777855348d57172119a05a9066" translate="yes" xml:space="preserve">
          <source>Trade-offs of the State Pattern</source>
          <target state="translated">国家模式的权衡</target>
        </trans-unit>
        <trans-unit id="b36366d44b437b0f859e29f4614b0107cecfe355" translate="yes" xml:space="preserve">
          <source>Trait</source>
          <target state="translated">Trait</target>
        </trans-unit>
        <trans-unit id="7418cda1dddd9f707baf2b1acabeb7297ddae8f4" translate="yes" xml:space="preserve">
          <source>Trait Bound Syntax</source>
          <target state="translated">特质绑定语法</target>
        </trans-unit>
        <trans-unit id="79d040a039f209d4b088e4414045e49f19a318f9" translate="yes" xml:space="preserve">
          <source>Trait Implementation Coherence</source>
          <target state="translated">特质实施一致性</target>
        </trans-unit>
        <trans-unit id="26b898f7f42ac0607067211907cfe144baef2099" translate="yes" xml:space="preserve">
          <source>Trait Implementations</source>
          <target state="translated">特质实施</target>
        </trans-unit>
        <trans-unit id="29c33623e3eecc134b62bfbdf8421daa25449235" translate="yes" xml:space="preserve">
          <source>Trait Object Layout</source>
          <target state="translated">对象布局</target>
        </trans-unit>
        <trans-unit id="1d17f32f109df2cae8776e118c0cd08d010484eb" translate="yes" xml:space="preserve">
          <source>Trait Object Lifetime Bounds</source>
          <target state="translated">特质对象寿命界限</target>
        </trans-unit>
        <trans-unit id="0f2fa6f9f52d26ee86cd56ce4895853eea3665a6" translate="yes" xml:space="preserve">
          <source>Trait Objects Perform Dynamic Dispatch</source>
          <target state="translated">特质对象执行动态调度</target>
        </trans-unit>
        <trans-unit id="a75e14ab76ff0ab816d5d3c2937abd862e423b2f" translate="yes" xml:space="preserve">
          <source>Trait and lifetime bounds</source>
          <target state="translated">特质和寿命界限</target>
        </trans-unit>
        <trans-unit id="41af368f93d8a39d7122b161977ffe16f6a12e35" translate="yes" xml:space="preserve">
          <source>Trait and lifetime bounds are also used to name &lt;a href=&quot;types/trait-object&quot;&gt;trait objects&lt;/a&gt;.</source>
          <target state="translated">性状和终生界限也用于命名&lt;a href=&quot;types/trait-object&quot;&gt;特征对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="941497474640686e1a5e201b7a0add49b752830f" translate="yes" xml:space="preserve">
          <source>Trait bounds</source>
          <target state="translated">特质界限</target>
        </trans-unit>
        <trans-unit id="4fcf62d60d13dd717001ca9dd0618f2bf25f60fb" translate="yes" xml:space="preserve">
          <source>Trait for equality comparisons which are &lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_equivalence_relation&quot;&gt;partial equivalence relations&lt;/a&gt;.</source>
          <target state="translated">等式比较的特点是&lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_equivalence_relation&quot;&gt;部分等价关系&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef0a7e79d3d4953fe69d9a8d5ee6294c86326bfd" translate="yes" xml:space="preserve">
          <source>Trait for equality comparisons which are &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;等值关系&lt;/a&gt;的等值比较的特点。</target>
        </trans-unit>
        <trans-unit id="eac0088c6ab97a23265d057818a34fc5c7b03fb7" translate="yes" xml:space="preserve">
          <source>Trait for equality comparisons which are &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_equivalence_relation&quot;&gt;partial equivalence relations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cec9bd7b654341aff1af9f8d64c24f966f7b024" translate="yes" xml:space="preserve">
          <source>Trait for types that form a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order&quot;&gt;total order&lt;/a&gt;.</source>
          <target state="translated">特质形成一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order&quot;&gt;总订单&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eda5d9fc229c855a2ef6aa3c2bfb5731468bf0cc" translate="yes" xml:space="preserve">
          <source>Trait for values that can be compared for a sort-order.</source>
          <target state="translated">可以比较排序的值的特征。</target>
        </trans-unit>
        <trans-unit id="64186133cfc350eebda0888af60b096eb938c6a7" translate="yes" xml:space="preserve">
          <source>Trait implementations</source>
          <target state="translated">项目实施</target>
        </trans-unit>
        <trans-unit id="ddca8ab133e8a574bb0807189227aaf80ac0b4fc" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated constants that are members of the trait in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2ed29df58a98467df7b65482664c061f2e57d4" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated constants that are members of the trait in question. This error indicates that you attempted to implement an associated constant whose name does not match the name of any associated constant in the trait.</source>
          <target state="translated">特质实现只能实现属于相关特质成员的关联常量。这个错误表明你试图实现一个关联常量,而这个常量的名字与trait中的任何关联常量的名字都不匹配。</target>
        </trans-unit>
        <trans-unit id="826d4810ddc337c0170d557193ecb3f363cb0584" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated types that are members of the trait in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc82d5ecd28dae290ae968b51be9ef3018535288" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated types that are members of the trait in question. This error indicates that you attempted to implement an associated type whose name does not match the name of any associated type in the trait.</source>
          <target state="translated">特质实现只能实现属于相关特质成员的关联类型。这个错误表明你试图实现一个关联类型,其名称与trait中任何关联类型的名称不匹配。</target>
        </trans-unit>
        <trans-unit id="24048bbeb068432309ce266edfa2a054d72baec8" translate="yes" xml:space="preserve">
          <source>Trait items syntactically allow a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;&lt;em&gt;Visibility&lt;/em&gt;&lt;/a&gt; annotation, but this is rejected when the trait is validated. This allows items to be parsed with a unified syntax across different contexts where they are used. As an example, an empty &lt;code&gt;vis&lt;/code&gt; macro fragment specifier can be used for trait items, where the macro rule may be used in other situations where visibility is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93dc7d0661c7c1cf56a871254e1715d367179182" translate="yes" xml:space="preserve">
          <source>Trait methods cannot be declared &lt;code&gt;const&lt;/code&gt; by design. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/911&quot;&gt;RFC 911&lt;/a&gt;.</source>
          <target state="translated">特性不能通过设计声明为 &lt;code&gt;const&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/911&quot;&gt;RFC 911&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a51226ce6186ef57bc4f8d39074c6398e097981" translate="yes" xml:space="preserve">
          <source>Trait methods currently cannot take patterns as arguments.</source>
          <target state="translated">特质方法目前不能接受模式作为参数。</target>
        </trans-unit>
        <trans-unit id="2484ce752e551a673766cb07f53076cdd0470999" translate="yes" xml:space="preserve">
          <source>Trait objects</source>
          <target state="translated">特质对象</target>
        </trans-unit>
        <trans-unit id="d0ff67bb0a0ee2576fc48fed596bc8092c7aa725" translate="yes" xml:space="preserve">
          <source>Trait objects are a form of dynamic dispatch and use a dynamically sized type for the inner type. So, for a given trait &lt;code&gt;Trait&lt;/code&gt;, when &lt;code&gt;Trait&lt;/code&gt; is treated as a type, as in &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, the inner type is 'unsized'. In such cases the boxed pointer is a 'fat pointer' that contains an extra pointer to a table of methods (among other things) for dynamic dispatch. This design mandates some restrictions on the types of traits that are allowed to be used in trait objects, which are collectively termed as 'object safety' rules.</source>
          <target state="translated">特性对象是动态分配的一种形式，内部类型使用动态大小的类型。因此，对于给定的特征 &lt;code&gt;Trait&lt;/code&gt; ，当将 &lt;code&gt;Trait&lt;/code&gt; 视为类型时，如 &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; ，内部类型为'unsized'。在这种情况下，带框的指针是一个&amp;ldquo;胖指针&amp;rdquo;，其中包含一个额外的指针，用于动态分配方法表（除其他外）。此设计对允许在特征对象中使用的特征类型施加了一些限制，这些限制统称为&amp;ldquo;对象安全&amp;rdquo;规则。</target>
        </trans-unit>
        <trans-unit id="5ea53f21fe7d48d8c36beccecda99fd8c1606afe" translate="yes" xml:space="preserve">
          <source>Trait objects are written as the optional keyword &lt;code&gt;dyn&lt;/code&gt; followed by a set of trait bounds, but with the following restrictions on the trait bounds. All traits except the first trait must be auto traits, there may not be more than one lifetime, and opt-out bounds (e.g. &lt;code&gt;?Sized&lt;/code&gt;) are not allowed. Furthermore, paths to traits may be parenthesized.</source>
          <target state="translated">特性对象被写为可选关键字 &lt;code&gt;dyn&lt;/code&gt; ,后跟一组特征范围，但是对特征范围有以下限制。除第一个性状外，所有性状都必须是自动性状，一生不得超过一个，并且不允许选择退出范围（例如 &lt;code&gt;?Sized&lt;/code&gt; ）。此外，特质的路径可以加括号。</target>
        </trans-unit>
        <trans-unit id="59817a6fb01d811236061d6945ce61c60bbb6a8e" translate="yes" xml:space="preserve">
          <source>Trait objects have the same layout as the value the trait object is of.</source>
          <target state="translated">特质对象的布局与特质对象的值相同。</target>
        </trans-unit>
        <trans-unit id="1bbbb43369cd1da1e54ccdae8b4bbe0c9a735c31" translate="yes" xml:space="preserve">
          <source>Trait objects implement the base trait, its auto traits, and any &lt;a href=&quot;../items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt; of the base trait.</source>
          <target state="translated">特性对象实现基本特征，其自动特征以及该基本特征的所有&lt;a href=&quot;../items/traits#supertraits&quot;&gt;超&lt;/a&gt;特征。</target>
        </trans-unit>
        <trans-unit id="d4f37b1632bc74808bbd4522d9d582acfc5a118f" translate="yes" xml:space="preserve">
          <source>Trait objects like &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; can only be constructed when certain requirements are satisfied by the trait in question.</source>
          <target state="translated">仅当有关特征满足某些要求时，才能构造诸如 &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 类的特征对象。</target>
        </trans-unit>
        <trans-unit id="046dc44c748313b6f776a3acf8abdd3d74f9acc5" translate="yes" xml:space="preserve">
          <source>Trait objects need to have all associated types specified. Erroneous code example:</source>
          <target state="translated">特质对象需要指定所有相关类型。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="e77aaa69af7e604fc6cf7c5dbf4abb6705458260" translate="yes" xml:space="preserve">
          <source>Trait objects need to have all associated types specified. Please verify that all associated types of the trait were specified and the correct trait was used. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad068a7a9dcf8a835215d9d2bd6df82d37ea9f8e" translate="yes" xml:space="preserve">
          <source>Trait std::alloc::Alloc</source>
          <target state="translated">特质 std::alloc::Alloc</target>
        </trans-unit>
        <trans-unit id="863608218cf19a899841e79768deb9add49e00f3" translate="yes" xml:space="preserve">
          <source>Trait std::alloc::GlobalAlloc</source>
          <target state="translated">Trait std::alloc::GlobalAlloc</target>
        </trans-unit>
        <trans-unit id="392d8121c387b6100e7dca67e7c52d32a16a3def" translate="yes" xml:space="preserve">
          <source>Trait std::any::Any</source>
          <target state="translated">Std trait::any::Any</target>
        </trans-unit>
        <trans-unit id="0bdbfe0deda36628eacc51abdb83fdbfcea6cc11" translate="yes" xml:space="preserve">
          <source>Trait std::array::FixedSizeArray</source>
          <target state="translated">特质 std::array::FixedSizeArray</target>
        </trans-unit>
        <trans-unit id="1eb8a5154ce5a680a452312a74723021b34c3aaa" translate="yes" xml:space="preserve">
          <source>Trait std::ascii::AsciiExt</source>
          <target state="translated">Std trait::ascii::AsciiExt</target>
        </trans-unit>
        <trans-unit id="5de77502b5980be7c3473a72d6105527f1215243" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::Borrow</source>
          <target state="translated">特质 std::borrow::Borrow</target>
        </trans-unit>
        <trans-unit id="70f054dd274fb96a8db0596d418507c91adce6b6" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::BorrowMut</source>
          <target state="translated">Trait std::borrow::BorrowMut</target>
        </trans-unit>
        <trans-unit id="bbcce0cbc4cb2a4bf5264b04d903d25c0a192013" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::ToOwned</source>
          <target state="translated">特质 std::borrow::ToOwned</target>
        </trans-unit>
        <trans-unit id="f2b9f8276056ca658e39ee7a72fdcb03a7c37efb" translate="yes" xml:space="preserve">
          <source>Trait std::clone::Clone</source>
          <target state="translated">特质 std::clone::Clone</target>
        </trans-unit>
        <trans-unit id="7cd5d0fd30409561bc6e76fd837e1f62470836a8" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::Eq</source>
          <target state="translated">行 std::cmp::Eq</target>
        </trans-unit>
        <trans-unit id="246cf166657201c68115fb66fd9221b8ffeb9ec4" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::Ord</source>
          <target state="translated">行 std::cmp::Ord</target>
        </trans-unit>
        <trans-unit id="72ff4c9778d08578e0f03c27d9d6272685274d91" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::PartialEq</source>
          <target state="translated">Std::cmp::PartialEq行。</target>
        </trans-unit>
        <trans-unit id="4fde07025ebb4afc05e6897ef74b43fe5347e982" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::PartialOrd</source>
          <target state="translated">Std line::cmp::PartialOrd</target>
        </trans-unit>
        <trans-unit id="d870aa7cb7664d7c10835889d14c6b391cb4500e" translate="yes" xml:space="preserve">
          <source>Trait std::convert::AsMut</source>
          <target state="translated">Std line::convert::AsMut</target>
        </trans-unit>
        <trans-unit id="d445d52fad68586ece567104043e8c242d2c7a73" translate="yes" xml:space="preserve">
          <source>Trait std::convert::AsRef</source>
          <target state="translated">Std line::convert::AsRef)。</target>
        </trans-unit>
        <trans-unit id="1da7f8aa53cf47c39294631d860061958af42da6" translate="yes" xml:space="preserve">
          <source>Trait std::convert::From</source>
          <target state="translated">Std line::convert::From</target>
        </trans-unit>
        <trans-unit id="b6ffd418e0a0b6d0cb5548ea09febb34aa5a1ba4" translate="yes" xml:space="preserve">
          <source>Trait std::convert::Into</source>
          <target state="translated">Std line::convert::Into</target>
        </trans-unit>
        <trans-unit id="4d1380373e375c0e4553b789733d1a89b1fb0101" translate="yes" xml:space="preserve">
          <source>Trait std::convert::TryFrom</source>
          <target state="translated">Std line::convert::TryFrom</target>
        </trans-unit>
        <trans-unit id="052f060bad402d8a2cd358057bd4871783c01ba4" translate="yes" xml:space="preserve">
          <source>Trait std::convert::TryInto</source>
          <target state="translated">Std trait::convert::TryInto</target>
        </trans-unit>
        <trans-unit id="36871446454b625eddb2f384614252a30a76670d" translate="yes" xml:space="preserve">
          <source>Trait std::default::Default</source>
          <target state="translated">特质 std::default::Default</target>
        </trans-unit>
        <trans-unit id="adf0d0f8b00918a2c28aba66b14f04f6c4e0fded" translate="yes" xml:space="preserve">
          <source>Trait std::error::Error</source>
          <target state="translated">Std line::error::Error</target>
        </trans-unit>
        <trans-unit id="c2d288fe88fdd80f7dd81a3a1f2aeef5dc8ba7dc" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Binary</source>
          <target state="translated">Std trait::fmt::binary</target>
        </trans-unit>
        <trans-unit id="33f44cc3a6de7dd1507041a00c8faf2775c0c8df" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Debug</source>
          <target state="translated">特质 std::fmt::Debug</target>
        </trans-unit>
        <trans-unit id="245d17885bbc5448412416b59b0f51c9d9b68eac" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Display</source>
          <target state="translated">特质 std::fmt::Display</target>
        </trans-unit>
        <trans-unit id="c8de6a747580fa084cc85d42225e02c2e93e67d5" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::LowerExp</source>
          <target state="translated">特质 std::fmt::LowerExp.</target>
        </trans-unit>
        <trans-unit id="e725d6041bd9bc4d83fca5b07971b62d421e6e64" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::LowerHex</source>
          <target state="translated">特质 std::fmt::LowerHex</target>
        </trans-unit>
        <trans-unit id="194006985569f163bb35c90c3abcdbc7deec0e4a" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Octal</source>
          <target state="translated">Std::fmt::八进制线</target>
        </trans-unit>
        <trans-unit id="8a32cd848a50f19a4618eac36d5bd1b3a315cf4d" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Pointer</source>
          <target state="translated">Std line::fmt::指针</target>
        </trans-unit>
        <trans-unit id="8718228edc98337e120714c5797ad6fa1124ce31" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::UpperExp</source>
          <target state="translated">特质 std::fmt::UpperExp。</target>
        </trans-unit>
        <trans-unit id="26a977a1233b688edd74d1ce605bed2138e89350" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::UpperHex</source>
          <target state="translated">Std line::fmt::UpperHex</target>
        </trans-unit>
        <trans-unit id="0e6b8aa3448ea0d1e3124dcc61d87f01fb6bfd66" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Write</source>
          <target state="translated">Std line::fmt::Write</target>
        </trans-unit>
        <trans-unit id="e8d3634caaf52ad6c8639c87d834bc299c37f7d5" translate="yes" xml:space="preserve">
          <source>Trait std::future::Future</source>
          <target state="translated">特质 std::future::Future</target>
        </trans-unit>
        <trans-unit id="e9cb7ef33fdeeee2adf1be409e245554e4935f7b" translate="yes" xml:space="preserve">
          <source>Trait std::hash::BuildHasher</source>
          <target state="translated">Trait std::hash::BuildHasher</target>
        </trans-unit>
        <trans-unit id="c7747499a3fe2fcc70735dec924c847206626023" translate="yes" xml:space="preserve">
          <source>Trait std::hash::Hash</source>
          <target state="translated">Std line::hash::Hash</target>
        </trans-unit>
        <trans-unit id="2254c3bc605b18ffc7e9aa4bd6f57a17e5b13944" translate="yes" xml:space="preserve">
          <source>Trait std::hash::Hasher</source>
          <target state="translated">Std trait::hash::Hash</target>
        </trans-unit>
        <trans-unit id="fd3fa6f5ef1435b1cb913f92dfb4fe0a0ac0248a" translate="yes" xml:space="preserve">
          <source>Trait std::io::BufRead</source>
          <target state="translated">Std trait::io::BufRead</target>
        </trans-unit>
        <trans-unit id="4c4e965bc67dd33a7c09b8db70c86024088aa45b" translate="yes" xml:space="preserve">
          <source>Trait std::io::Read</source>
          <target state="translated">Std trait::io::Read</target>
        </trans-unit>
        <trans-unit id="5d0aac0ef2620914932ce91ac2b555eba9c75b6a" translate="yes" xml:space="preserve">
          <source>Trait std::io::Seek</source>
          <target state="translated">Std trait::io::Seek</target>
        </trans-unit>
        <trans-unit id="23c37542e0343a876f9566d6681875d507142219" translate="yes" xml:space="preserve">
          <source>Trait std::io::Write</source>
          <target state="translated">Std trait::io::Write</target>
        </trans-unit>
        <trans-unit id="557d86b90451662a5be206878fb6037c4adc186c" translate="yes" xml:space="preserve">
          <source>Trait std::iter::DoubleEndedIterator</source>
          <target state="translated">特质 std::iter::DoubleEndedIterator</target>
        </trans-unit>
        <trans-unit id="f1b39cf8be9a057d9577992deaebe45e596b1a85" translate="yes" xml:space="preserve">
          <source>Trait std::iter::ExactSizeIterator</source>
          <target state="translated">特质 std::iter::ExactSizeIterator</target>
        </trans-unit>
        <trans-unit id="993ad040e2e34adc2956488f0eb4db104a067cbf" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Extend</source>
          <target state="translated">Std trait::iter::Extend</target>
        </trans-unit>
        <trans-unit id="5d994406c4beb394a68ed1206fddfd385bea8323" translate="yes" xml:space="preserve">
          <source>Trait std::iter::FromIterator</source>
          <target state="translated">特质 std::iter::FromIterator</target>
        </trans-unit>
        <trans-unit id="2fce9eb181dd3ce47112a06174082d5e79cf74c2" translate="yes" xml:space="preserve">
          <source>Trait std::iter::FusedIterator</source>
          <target state="translated">特质 std::iter::FusedIterator</target>
        </trans-unit>
        <trans-unit id="e86b71b89c47a871b78ca20df617b375a62e7185" translate="yes" xml:space="preserve">
          <source>Trait std::iter::IntoIterator</source>
          <target state="translated">特质 std::iter::IntoIterator</target>
        </trans-unit>
        <trans-unit id="2da3e674c34b9eab7bfc5aeebb0e4f54178e88c3" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Iterator</source>
          <target state="translated">特质 std::iter::Iterator</target>
        </trans-unit>
        <trans-unit id="28c48f7585e0c72c08462070ebcfc21850b855dd" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Product</source>
          <target state="translated">特质 std::iter::Product</target>
        </trans-unit>
        <trans-unit id="4cd139b55d183603c0136ea95dadb637efaf38a2" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Step</source>
          <target state="translated">Std trait::iter::Step</target>
        </trans-unit>
        <trans-unit id="5db41fec6d94d07ed5a8c95c380992ba4e70704b" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Sum</source>
          <target state="translated">Std trait::iter::Sum</target>
        </trans-unit>
        <trans-unit id="d2c14fdb677cf9e40834e0c15272aef7a318414f" translate="yes" xml:space="preserve">
          <source>Trait std::iter::TrustedLen</source>
          <target state="translated">特质 std::iter::TrustedLen</target>
        </trans-unit>
        <trans-unit id="97864c14469b7b4a0942294bc953528cb554eb45" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Copy</source>
          <target state="translated">特质 std::marker::Copy</target>
        </trans-unit>
        <trans-unit id="d7b568be22b28c92ca0e71ed060c7b03cf03fb4f" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Send</source>
          <target state="translated">特质 std::marker::Send</target>
        </trans-unit>
        <trans-unit id="00852f537576ef249f511a14cf0e0d88604a985c" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Sized</source>
          <target state="translated">特质 std::marker::Sized</target>
        </trans-unit>
        <trans-unit id="259bdec063434c0a27f0691a2488a4567088a5e0" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Sync</source>
          <target state="translated">特质 std::marker::Sync</target>
        </trans-unit>
        <trans-unit id="3f94365e96f98d2913bb838b56a6cb437e2a3543" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Unpin</source>
          <target state="translated">特质 std::marker::Unpin</target>
        </trans-unit>
        <trans-unit id="311396699adc0c66b758dcec6485921335dcacf8" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Unsize</source>
          <target state="translated">特质 std::marker::Unsize</target>
        </trans-unit>
        <trans-unit id="56b1f3f0f786678bf876540fb69232e234007e31" translate="yes" xml:space="preserve">
          <source>Trait std::net::ToSocketAddrs</source>
          <target state="translated">Trait std::net::ToSocketAddrs</target>
        </trans-unit>
        <trans-unit id="37966fc5ec2acafba273f997b504b3bf34ed922b" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Add</source>
          <target state="translated">Std line::ops::Add</target>
        </trans-unit>
        <trans-unit id="eb2302d36fa57d1adc4a45dc1d240d27866b69da" translate="yes" xml:space="preserve">
          <source>Trait std::ops::AddAssign</source>
          <target state="translated">特质 std::OPS::AddAssign</target>
        </trans-unit>
        <trans-unit id="b5f5f47beac59c26ee424be54e3b7e3d95164b94" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitAnd</source>
          <target state="translated">Std line::ops::BitAnd</target>
        </trans-unit>
        <trans-unit id="fb181e8cea7de0ad56c4c91c6a0777e1d53fd765" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitAndAssign</source>
          <target state="translated">特质 std::OPS::BitAndAssign</target>
        </trans-unit>
        <trans-unit id="b888f514c1fa78a8e8fe84b58a6fbc1d25aaf2c1" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitOr</source>
          <target state="translated">Std line::ops::BitOr</target>
        </trans-unit>
        <trans-unit id="ca3ae8400b524007a326d21b18e44fb657bdb697" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitOrAssign</source>
          <target state="translated">特质 std::OPS::Bit或Assign</target>
        </trans-unit>
        <trans-unit id="8d18eaa27370f1eb1f6ce036dc60c1aa5493c417" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitXor</source>
          <target state="translated">Std line::ops::BitXor</target>
        </trans-unit>
        <trans-unit id="5961f53888aa07cd5cd15ed30fa1971a719c8b25" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitXorAssign</source>
          <target state="translated">特质 std::OPS::BitXorAssign</target>
        </trans-unit>
        <trans-unit id="5e9158651355d13bfdd0cc23ab8ae22e93570742" translate="yes" xml:space="preserve">
          <source>Trait std::ops::CoerceUnsized</source>
          <target state="translated">特质 std::OPS::CoerceUnsized</target>
        </trans-unit>
        <trans-unit id="e2225eef9926066643795abab6cb04cea79ce68b" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Deref</source>
          <target state="translated">Std trait::ops::Deref</target>
        </trans-unit>
        <trans-unit id="8071035f23a5d586519a8248517d2e29e7adcb51" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DerefMut</source>
          <target state="translated">特质 std::OPS::DerefMut</target>
        </trans-unit>
        <trans-unit id="1bdb82d5309eaed70f5481f05b19a4d41b5808d7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DispatchFromDyn</source>
          <target state="translated">Std trait::ops::DispatchFromDyn</target>
        </trans-unit>
        <trans-unit id="9119f5359ef3817ec9f0b7e45b3f1ecbc08a66ae" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Div</source>
          <target state="translated">Std trait::ops::Div</target>
        </trans-unit>
        <trans-unit id="f65e4311dbd340efad891a4945558b2592826b48" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DivAssign</source>
          <target state="translated">特质 std::OPS::DivAssign</target>
        </trans-unit>
        <trans-unit id="ead9d9ba97193a4d1ac24f05c905c8b13350ed9c" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Drop</source>
          <target state="translated">Std line::ops::Drop</target>
        </trans-unit>
        <trans-unit id="516e4c37897e1d20a60743aea36782c56e8156a9" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Fn</source>
          <target state="translated">Std line::ops::Fn</target>
        </trans-unit>
        <trans-unit id="77005c859f62996c3f249d5673d1b2c4d6da6a8e" translate="yes" xml:space="preserve">
          <source>Trait std::ops::FnMut</source>
          <target state="translated">Std line::ops::FnMut</target>
        </trans-unit>
        <trans-unit id="b435f6c3c75102c4c8177872a25a996a1ff95c72" translate="yes" xml:space="preserve">
          <source>Trait std::ops::FnOnce</source>
          <target state="translated">Std Feature::ops::FnOnce</target>
        </trans-unit>
        <trans-unit id="9aa827be880a5bea9bb3024a041653fb3a60ff06" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Generator</source>
          <target state="translated">特质 std::OPS::Generator</target>
        </trans-unit>
        <trans-unit id="59811c59bb31cbb96886cf966994463b72ad700c" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Index</source>
          <target state="translated">Std line::ops::Index</target>
        </trans-unit>
        <trans-unit id="1b08e9090daf7ede77089f8107e6507872bde2ab" translate="yes" xml:space="preserve">
          <source>Trait std::ops::IndexMut</source>
          <target state="translated">Std line::ops::IndexMut</target>
        </trans-unit>
        <trans-unit id="10babff383e103d1471a771d922a28289586b73a" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Mul</source>
          <target state="translated">Std trait::ops::Mul</target>
        </trans-unit>
        <trans-unit id="b32e6664a7b4d68e303b33188cda08fc977bd7b7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::MulAssign</source>
          <target state="translated">特质 std::OPS::MulAssign</target>
        </trans-unit>
        <trans-unit id="7244a7be2c4624654c9b462b1947447297e505fd" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Neg</source>
          <target state="translated">Std line::ops::Neg</target>
        </trans-unit>
        <trans-unit id="598dee8649518d42201f87386801464e34102c60" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Not</source>
          <target state="translated">Std line::ops::Not</target>
        </trans-unit>
        <trans-unit id="bc51ccaddf33118323d7fc1d905d959ce650d2fc" translate="yes" xml:space="preserve">
          <source>Trait std::ops::RangeBounds</source>
          <target state="translated">特质 std::ops::RangeBounds</target>
        </trans-unit>
        <trans-unit id="4ee55841b26a89cf9d805e3a28fb34dc38ab767a" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Rem</source>
          <target state="translated">Std line::ops::Rem</target>
        </trans-unit>
        <trans-unit id="a0e35ffe757b24704f0ad197b4f1a2195f4a4f69" translate="yes" xml:space="preserve">
          <source>Trait std::ops::RemAssign</source>
          <target state="translated">特质 std::OPS::RemAssign</target>
        </trans-unit>
        <trans-unit id="5922247946e4630b62a74e89d87c15ed9dbf8321" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Shl</source>
          <target state="translated">Std line::ops::Shl</target>
        </trans-unit>
        <trans-unit id="f84eeb046dfef53ab5217181c0fe9161eb7133b2" translate="yes" xml:space="preserve">
          <source>Trait std::ops::ShlAssign</source>
          <target state="translated">特质 std::OPS::ShlAssign</target>
        </trans-unit>
        <trans-unit id="55d865e44b6599da1d5b41d269ec7455a02e4d75" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Shr</source>
          <target state="translated">Std line::ops::Shr</target>
        </trans-unit>
        <trans-unit id="e7c92d6f8a50e1ae3b29a226a8335aff1fecf601" translate="yes" xml:space="preserve">
          <source>Trait std::ops::ShrAssign</source>
          <target state="translated">特征 std::ops::ShrAssign</target>
        </trans-unit>
        <trans-unit id="cbaeb43954d65c4471777365a4ccdaf3b98314da" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Sub</source>
          <target state="translated">Std line::ops::Sub</target>
        </trans-unit>
        <trans-unit id="60e6a61f8c88f9e6239b7053de7f86d23a70926d" translate="yes" xml:space="preserve">
          <source>Trait std::ops::SubAssign</source>
          <target state="translated">特质 std::OPS::SubAssign</target>
        </trans-unit>
        <trans-unit id="1e84214c3e8570e12d3f9ef3b558be6c152516f7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Try</source>
          <target state="translated">Std trait::ops::Try</target>
        </trans-unit>
        <trans-unit id="aee85e47c1ef28a026ccdb2b42dd67004cf6d92b" translate="yes" xml:space="preserve">
          <source>Trait std::os::linux::fs::MetadataExt</source>
          <target state="translated">Trait std::os::linux::fs::MetadataExt</target>
        </trans-unit>
        <trans-unit id="ce6f693798415e4676d8d1ff10beb4360e2b88ea" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::ffi::OsStrExt</source>
          <target state="translated">Std trait::os:unix::fi::OsStrExt</target>
        </trans-unit>
        <trans-unit id="ccee631397fcdd7aa7a9f0bce0da5d850063085b" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::ffi::OsStringExt</source>
          <target state="translated">Trait std::os::unix::fi::OsStringExt</target>
        </trans-unit>
        <trans-unit id="e621c9f13dd9d62e26bc7432de51e95d4d92457d" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::DirBuilderExt</source>
          <target state="translated">Trait std::os::unix::fs::DirBuilderExt</target>
        </trans-unit>
        <trans-unit id="0709fdc0b13d2f0cb5f5c17d0f41b133a5719e30" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::DirEntryExt</source>
          <target state="translated">Std trait::os::unix::fs::DirEntryExt</target>
        </trans-unit>
        <trans-unit id="030f7ec1f295cca2c02129cf381f726caf5a30ca" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::FileExt</source>
          <target state="translated">Std line::os::unix::fs::FileExt</target>
        </trans-unit>
        <trans-unit id="f955ea7fe9356c94c24f7600e345d8c1f23ecc81" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::FileTypeExt</source>
          <target state="translated">Std trait::os::unix::fs::FileTypeExt</target>
        </trans-unit>
        <trans-unit id="062f7bd7816b0a1187ddcd41fdc03811ea335026" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::MetadataExt</source>
          <target state="translated">Std trait::os::unix::fs::MetadataExt</target>
        </trans-unit>
        <trans-unit id="5cc7126ad859e04f63e6bf507db0f3f32c1e3609" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::OpenOptionsExt</source>
          <target state="translated">Std Feature::os::unix::fs::OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="7b61dfb2986a0864a907b937d464ff43d30cc28a" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::PermissionsExt</source>
          <target state="translated">Std trait::os::unix::fs::PermissionsExt</target>
        </trans-unit>
        <trans-unit id="029585bd86a69a9cb4ab7c864e7dc9b2373a14b3" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::AsRawFd</source>
          <target state="translated">Std trait::os:unix::io::AsRawFd</target>
        </trans-unit>
        <trans-unit id="e4e4a27468811544480dddf3c4047ee3d4694a0c" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::FromRawFd</source>
          <target state="translated">Std trait::os::unix::io::FromRawFd</target>
        </trans-unit>
        <trans-unit id="ad731bff461d938e10c799939e10ae14e837a1d4" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::IntoRawFd</source>
          <target state="translated">Std.stroke::os::unix::io::IntoRawFd</target>
        </trans-unit>
        <trans-unit id="e0e834bab744daaedf71c0c8937cc0857c11c815" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::process::CommandExt</source>
          <target state="translated">Std trait::os::unix::process::CommandExt</target>
        </trans-unit>
        <trans-unit id="3fdb072f5381c741536b73b80e58115bb5f3dc4d" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::process::ExitStatusExt</source>
          <target state="translated">Trait std::os::unix::process::ExitStatusExt</target>
        </trans-unit>
        <trans-unit id="398944c7337c4aa8b95b799fcb3bb79124d70d16" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::thread::JoinHandleExt</source>
          <target state="translated">Trait std::os::unix::thread::JoinHandleExt</target>
        </trans-unit>
        <trans-unit id="775a7a0c3bd36d7ff6360e6cd0ef765ee978cd67" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::ffi::OsStrExt</source>
          <target state="translated">Trait std::os::windows::fi::OsStrExt</target>
        </trans-unit>
        <trans-unit id="fef545ee7fe66334043f38cfbfbf352be492c487" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::ffi::OsStringExt</source>
          <target state="translated">Trait std::os::windows::fi::OsStringExt</target>
        </trans-unit>
        <trans-unit id="ecb052e97ecce0a67db913c47f009bfcbacc3af0" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::FileExt</source>
          <target state="translated">特质 std::os::windows::fs::FileExt</target>
        </trans-unit>
        <trans-unit id="91c8fb448f57a608a43c2c6a50e10bec34d5ab25" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::FileTypeExt</source>
          <target state="translated">Trait std::os::windows::fs::FileTypeExt</target>
        </trans-unit>
        <trans-unit id="48eaa197d2777c5eb543ac927807cb3bcfa429bf" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::MetadataExt</source>
          <target state="translated">Trait std::os::windows::fs::MetadataExt</target>
        </trans-unit>
        <trans-unit id="adfee6aa3be6cbe6237011186a8914e73584ae0c" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::OpenOptionsExt</source>
          <target state="translated">Std feature::os::windows::fs::OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="2cdd2fa8158633908c8d054d4d1297a0e8730a45" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::AsRawHandle</source>
          <target state="translated">Trait std::os::windows::io::AsRawHandle</target>
        </trans-unit>
        <trans-unit id="0d00fd25b06cb924c3fdd7f42d54ec1498a98e1b" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::AsRawSocket</source>
          <target state="translated">Std trait::os::windows::io::AsRawSocket</target>
        </trans-unit>
        <trans-unit id="61063f360cb8b5295929ae6072d8fe4c6d6e69db" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::FromRawHandle</source>
          <target state="translated">Trait std::os::windows::io::FromRawHandle</target>
        </trans-unit>
        <trans-unit id="7942dc2954f8548cc31aadda78e4bf28314f92d8" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::FromRawSocket</source>
          <target state="translated">Trait std::os::windows::io::FromRawSocket</target>
        </trans-unit>
        <trans-unit id="bb1fb08e33748cf05582377cef8603a0b7d61ea6" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::IntoRawHandle</source>
          <target state="translated">Trait std::os::windows::io::IntoRawHandle</target>
        </trans-unit>
        <trans-unit id="1fe8126ee24f29a74bcdb4233344f05c1aaeb804" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::IntoRawSocket</source>
          <target state="translated">Trait std::os::windows::io::IntoRawSocket</target>
        </trans-unit>
        <trans-unit id="03f13d9ed2758f8306f48846a3b40b6e4ee6fb67" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::process::CommandExt</source>
          <target state="translated">Trait std::os::windows::process::CommandExt</target>
        </trans-unit>
        <trans-unit id="5474211db770299d01cd13e53280d9a32e0a6eb8" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::process::ExitStatusExt</source>
          <target state="translated">Trait std::os::windows::process::Exit ExitStatusExt</target>
        </trans-unit>
        <trans-unit id="f12279b49645006e0e35a65e657e45472c813936" translate="yes" xml:space="preserve">
          <source>Trait std::panic::RefUnwindSafe</source>
          <target state="translated">特质 std::panic::RefUnwindSafe</target>
        </trans-unit>
        <trans-unit id="94584086fc586a7b81f5ac90f21ac1115c03a3ce" translate="yes" xml:space="preserve">
          <source>Trait std::panic::UnwindSafe</source>
          <target state="translated">Trait std::panic::UnwindSafe</target>
        </trans-unit>
        <trans-unit id="adb81f6851cec81b5352770932f85397129ab8a4" translate="yes" xml:space="preserve">
          <source>Trait std::process::Termination</source>
          <target state="translated">特质 std::process::Termination</target>
        </trans-unit>
        <trans-unit id="7640946c865124bdea836774595f3568b91b7998" translate="yes" xml:space="preserve">
          <source>Trait std::slice::SliceConcatExt</source>
          <target state="translated">Trait std::slice::SliceConcatExt</target>
        </trans-unit>
        <trans-unit id="f46e5f5628a346f08367c4e254d503cf40a8e630" translate="yes" xml:space="preserve">
          <source>Trait std::slice::SliceIndex</source>
          <target state="translated">特质 std::slice::SliceIndex</target>
        </trans-unit>
        <trans-unit id="376de5fab14024883dddc8825294275d1ab087fe" translate="yes" xml:space="preserve">
          <source>Trait std::str::FromStr</source>
          <target state="translated">Trait std::str::FromStr</target>
        </trans-unit>
        <trans-unit id="44dfa41c6566ca84e623c4ad35fe85e2a3871106" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::DoubleEndedSearcher</source>
          <target state="translated">特质 std::str::pattern::DoubleEndedSearcher</target>
        </trans-unit>
        <trans-unit id="60d7ae5ae877268eee71ef1b870695c55f5799dd" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::Pattern</source>
          <target state="translated">特质 std::str::pattern::Pattern</target>
        </trans-unit>
        <trans-unit id="57c9157b22b76a9e5814b9b5b2e9d0438b5d56c6" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::ReverseSearcher</source>
          <target state="translated">Trait std::str::pattern::ReverseSearcher</target>
        </trans-unit>
        <trans-unit id="c47b1d5d24f300a29158b5903ba66de94f2261c7" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::Searcher</source>
          <target state="translated">特质 std::str::pattern::Searcher</target>
        </trans-unit>
        <trans-unit id="44bc0cc22a45fc90a102d47cbd5cd3c88d279925" translate="yes" xml:space="preserve">
          <source>Trait std::string::ToString</source>
          <target state="translated">特质 std::string::ToString</target>
        </trans-unit>
        <trans-unit id="902e019f3fc71a92236203a22158a6e688676cd4" translate="yes" xml:space="preserve">
          <source>Trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee.</source>
          <target state="translated">特质,表示这是一个指针或一个包装器,可以在指针上进行大小调整。</target>
        </trans-unit>
        <trans-unit id="914213ad374b434003e30cd9d7bcaca26d295c77" translate="yes" xml:space="preserve">
          <source>Trait to represent types that can be created by multiplying elements of an iterator.</source>
          <target state="translated">表示可以通过迭代器的元素相乘来创建类型的特征。</target>
        </trans-unit>
        <trans-unit id="badf961de53295edcdb207c7619b3c8c3ea8ab3f" translate="yes" xml:space="preserve">
          <source>Trait to represent types that can be created by summing up an iterator.</source>
          <target state="translated">表示可以通过求和迭代器创建的类型的特征。</target>
        </trans-unit>
        <trans-unit id="d881d840fb21638a45b7fe784d4a5eb2d495d58e" translate="yes" xml:space="preserve">
          <source>Trait types:</source>
          <target state="translated">特质类型:</target>
        </trans-unit>
        <trans-unit id="602d794344a5274058fe843b2cdf8ec0429dd8a0" translate="yes" xml:space="preserve">
          <source>Trait types: &lt;a href=&quot;types/trait-object&quot;&gt;Trait objects&lt;/a&gt; and &lt;a href=&quot;types/impl-trait&quot;&gt;impl trait&lt;/a&gt;.</source>
          <target state="translated">特质类型：&lt;a href=&quot;types/trait-object&quot;&gt;特质对象&lt;/a&gt;和&lt;a href=&quot;types/impl-trait&quot;&gt;impl trait&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bb3c78c542b9f8ec90ade6e9ec8d9a3209bf67e" translate="yes" xml:space="preserve">
          <source>TraitObject</source>
          <target state="translated">TraitObject</target>
        </trans-unit>
        <trans-unit id="6dafbe61d09e60652f6bbad6957562daf88836c1" translate="yes" xml:space="preserve">
          <source>TraitObject::borrow</source>
          <target state="translated">TraitObject::borrow</target>
        </trans-unit>
        <trans-unit id="d4a155778d83f0c6e0941f69c58ed350bc406da6" translate="yes" xml:space="preserve">
          <source>TraitObject::borrow_mut</source>
          <target state="translated">TraitObject::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1ad27b39ed4c34288ce66526e3c4d0c6cfa27a49" translate="yes" xml:space="preserve">
          <source>TraitObject::clone</source>
          <target state="translated">TraitObject::clone</target>
        </trans-unit>
        <trans-unit id="f7e5bbc88cb023be138b61515a8a95359d090a5c" translate="yes" xml:space="preserve">
          <source>TraitObject::clone_from</source>
          <target state="translated">TraitObject::clone_from</target>
        </trans-unit>
        <trans-unit id="fdf0c70ef2387158d4df2cba6555b292ed39d46d" translate="yes" xml:space="preserve">
          <source>TraitObject::clone_into</source>
          <target state="translated">TraitObject::clone_into</target>
        </trans-unit>
        <trans-unit id="743885aa5243b74deebe5c3d51ac4806100e3c4f" translate="yes" xml:space="preserve">
          <source>TraitObject::from</source>
          <target state="translated">TraitObject::from</target>
        </trans-unit>
        <trans-unit id="83e65850a79cb15fc900dff422e0637ecd287f18" translate="yes" xml:space="preserve">
          <source>TraitObject::into</source>
          <target state="translated">TraitObject::into</target>
        </trans-unit>
        <trans-unit id="4d10ca4ab3471cdb18500652e2706f1af91011a7" translate="yes" xml:space="preserve">
          <source>TraitObject::to_owned</source>
          <target state="translated">TraitObject::to_owned</target>
        </trans-unit>
        <trans-unit id="cb08794c131e1ac1a49313ec36f386568341f2c9" translate="yes" xml:space="preserve">
          <source>TraitObject::try_from</source>
          <target state="translated">TraitObject::try_from</target>
        </trans-unit>
        <trans-unit id="368b837c4e44612f1f89ff1a01dc94c771822d93" translate="yes" xml:space="preserve">
          <source>TraitObject::try_into</source>
          <target state="translated">TraitObject::try_into</target>
        </trans-unit>
        <trans-unit id="74e84d6c289e114766c37bd05fe2729da4981e80" translate="yes" xml:space="preserve">
          <source>TraitObject::type_id</source>
          <target state="translated">TraitObject::type_id</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="9c97df5331a0dd1cf9d7e4754c7f28e534496f46" translate="yes" xml:space="preserve">
          <source>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. In dynamically typed languages, we would get an error at runtime if we called a method on a type that the type didn&amp;rsquo;t implement. But Rust moves these errors to compile time so we&amp;rsquo;re forced to fix the problems before our code is even able to run. Additionally, we don&amp;rsquo;t have to write code that checks for behavior at runtime because we&amp;rsquo;ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.</source>
          <target state="translated">特质和特征边界使我们可以编写使用通用类型参数来减少重复的代码，同时还向编译器指定我们希望通用类型具有特定行为。然后，编译器可以使用特征绑定信息来检查与我们的代码一起使用的所有具体类型是否提供正确的行为。在动态类型的语言中，如果在未实现的类型上调用方法，则会在运行时出现错误。但是Rust会将这些错误转移到编译时，因此我们不得不在代码无法运行之前解决问题。另外，我们不必编写在运行时检查行为的代码，因为我们已经在编译时进行了检查。这样做可以提高性能，而不必放弃泛型的灵活性。</target>
        </trans-unit>
        <trans-unit id="3fc76183719059f2c0c8080816f40e16e5dee060" translate="yes" xml:space="preserve">
          <source>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. In dynamically typed languages, we would get an error at runtime if we called a method on a type which didn&amp;rsquo;t define the method. But Rust moves these errors to compile time so we&amp;rsquo;re forced to fix the problems before our code is even able to run. Additionally, we don&amp;rsquo;t have to write code that checks for behavior at runtime because we&amp;rsquo;ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d92be1538d577b3a476ce5c89b01f7242bf547" translate="yes" xml:space="preserve">
          <source>Traits are also compared by their implementation:</source>
          <target state="translated">性状也是通过实施来比较的。</target>
        </trans-unit>
        <trans-unit id="e9a67b2444510e46e8948ad83a34775ca31fa40c" translate="yes" xml:space="preserve">
          <source>Traits are declared using the &lt;code&gt;trait&lt;/code&gt; keyword. Types can implement them using &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Trait&lt;/code&gt;&lt;a href=&quot;keyword.for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66685be42641df1c5c014df0db7fb2681f6517c0" translate="yes" xml:space="preserve">
          <source>Traits are implemented for specific types through separate &lt;a href=&quot;implementations&quot;&gt;implementations&lt;/a&gt;.</source>
          <target state="translated">通过单独的&lt;a href=&quot;implementations&quot;&gt;实现&lt;/a&gt;为特定类型实现特征。</target>
        </trans-unit>
        <trans-unit id="68c3dbb43f5798e7691ebd93a6d889062ce5c80e" translate="yes" xml:space="preserve">
          <source>Traits as Parameters</source>
          <target state="translated">作为参数的特征</target>
        </trans-unit>
        <trans-unit id="4bf9fb060bd902afb2cded8739189581c26cdf0d" translate="yes" xml:space="preserve">
          <source>Traits can also be declared as &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661e39b3878b924290822d7b53ab6af8bbecce44" translate="yes" xml:space="preserve">
          <source>Traits can be generic, with constraints or without:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d13ed5586289e0d3d40796b5bf51fc03fcc1f1" translate="yes" xml:space="preserve">
          <source>Traits can be made up of three varieties of associated items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f25be72831238ea3a0070cedc0b27becde04cb1" translate="yes" xml:space="preserve">
          <source>Traits can be used in functions, as parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a444e95cf19cfd56b5bd44d15b0d8f1bb04bba" translate="yes" xml:space="preserve">
          <source>Traits can build upon the requirements of other traits. In the example below &lt;code&gt;Iterator&lt;/code&gt; is a &lt;strong&gt;supertrait&lt;/strong&gt; and &lt;code&gt;ThreeIterator&lt;/code&gt; is a &lt;strong&gt;subtrait&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bf3800cd574708d91373db1be628b4ff994b51" translate="yes" xml:space="preserve">
          <source>Traits can serve as markers or carry other logical semantics that aren't expressed through their items. When a type implements that trait it is promising to uphold its contract. &lt;a href=&quot;marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; are two such marker traits present in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1779dfd4e53a302206ca9f432ac589991148919" translate="yes" xml:space="preserve">
          <source>Traits for conversions between types.</source>
          <target state="translated">类型之间转换的特征。</target>
        </trans-unit>
        <trans-unit id="5129fe11a670c9d54f51f82654cb88d2c5359dd3" translate="yes" xml:space="preserve">
          <source>Traits for working with Errors.</source>
          <target state="translated">处理错误的特点。</target>
        </trans-unit>
        <trans-unit id="e714d1e850bbb5cbfe4cbf81d9f96ff676eaae8d" translate="yes" xml:space="preserve">
          <source>Traits items that begin with the &lt;code&gt;unsafe&lt;/code&gt; keyword indicate that &lt;em&gt;implementing&lt;/em&gt; the trait may be &lt;a href=&quot;../unsafety&quot;&gt;unsafe&lt;/a&gt;. It is safe to use a correctly implemented unsafe trait. The &lt;a href=&quot;implementations#trait-implementations&quot;&gt;trait implementation&lt;/a&gt; must also begin with the &lt;code&gt;unsafe&lt;/code&gt; keyword.</source>
          <target state="translated">以 &lt;code&gt;unsafe&lt;/code&gt; 关键字开头的特征项目表明&lt;em&gt;实现&lt;/em&gt;该特征可能是&lt;a href=&quot;../unsafety&quot;&gt;不安全的&lt;/a&gt;。使用正确实施的不安全特征是安全的。该&lt;a href=&quot;implementations#trait-implementations&quot;&gt;特性的实现&lt;/a&gt;还必须与开始 &lt;code&gt;unsafe&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="c4f3eba08a0ef9ddc5179fc934760dae14913d40" translate="yes" xml:space="preserve">
          <source>Traits marked as &lt;code&gt;unsafe&lt;/code&gt; must be &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt;emented using &lt;code&gt;unsafe impl&lt;/code&gt;. This makes a guarantee to other &lt;code&gt;unsafe&lt;/code&gt; code that the implementation satisfies the trait's safety contract. The &lt;a href=&quot;marker/trait.send&quot;&gt;Send&lt;/a&gt; and &lt;a href=&quot;marker/trait.sync&quot;&gt;Sync&lt;/a&gt; traits are examples of this behaviour in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bb75d5aa409703504921566195fb3122da2052" translate="yes" xml:space="preserve">
          <source>Traits may also contain additional type parameters. Those type parameters or the trait itself can be constrained by other traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b45c49a33c4022855bfa5d2a686751214a7126a" translate="yes" xml:space="preserve">
          <source>Traits may be implemented for</source>
          <target state="translated">可实施以下特征</target>
        </trans-unit>
        <trans-unit id="986fcbb6a73e7cc26d2d8b2b6164011d8bab7460" translate="yes" xml:space="preserve">
          <source>Traits, helpers, and type definitions for core I/O functionality.</source>
          <target state="translated">核心I/O功能的特征、助手和类型定义。</target>
        </trans-unit>
        <trans-unit id="9aa77953b92e4e6c565758326d541910014cfd21" translate="yes" xml:space="preserve">
          <source>Traits: Defining Shared Behavior</source>
          <target state="translated">特质。界定共同行为</target>
        </trans-unit>
        <trans-unit id="d8a8f61d9f0fd714531d17d414abcb212572f131" translate="yes" xml:space="preserve">
          <source>Transcribing</source>
          <target state="translated">Transcribing</target>
        </trans-unit>
        <trans-unit id="2df1d93dea4e259eb26edde2c26eb9c20992b104" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection.</source>
          <target state="translated">将迭代器转换为一个集合。</target>
        </trans-unit>
        <trans-unit id="81c1484a18bb69461dc41663b8ca61aba770c66a" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将迭代器转换为集合。&lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0fe9703c09ae5aff473aa850cc9ea84e177f2a25" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将迭代器转换为集合。&lt;a href=&quot;../../iter/trait.iterator#method.collect&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d95c53779cc93ec00cbab50bc8d1d781ee0140b9" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将迭代器转换为集合。&lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f6c7d5e9d128d42f6100c26dc454bf0231e3a05" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将迭代器转换为集合。&lt;a href=&quot;iter/trait.iterator#method.collect&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f3c54bd44a2ac346c25bc4bf8dc990a7215290b" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将迭代器转换为集合。&lt;a href=&quot;trait.iterator#method.collect&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d04afdfe20a5d1e30c5697c258379dba1dfdd82" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 转换为&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;，将&lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt;映射到&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(v)&lt;/code&gt; &lt;/a&gt;，将&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;映射到&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err(err())&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a32b0b090c9474f23fede28872bd2f862d58ca7" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 转换为&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;，将&lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt;映射到&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(v)&lt;/code&gt; &lt;/a&gt;，将&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;映射到&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err(err)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="398730368239daf72c58a553f251431298c7cfb2" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6f8723802ef085327c42e8d97e13f22a876933" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb313d7fccfec96291e799fbdbae78f85b64379" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes. &lt;a href=&quot;../../../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4eb95563ead3e77457aefa3ae80b465ed16f04e" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes.</source>
          <target state="translated">将此 &lt;code&gt;Read&lt;/code&gt; 实例的字节转换为&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95b63dbe9d04ab6189a2f04a995620130158a036" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes. &lt;a href=&quot;../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a749feee7f6dbf3973b0c9eb615ab3107735d9" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes. &lt;a href=&quot;trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b59ca5339cfaac01d1e21047c3e9f00c4f7918" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes. &lt;a href=&quot;io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c96526be3584d2d000005b6f01d7d3341c8987" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;../../../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将此 &lt;code&gt;Read&lt;/code&gt; 实例的字节数转换为[ &lt;code&gt;Iterator&lt;/code&gt; ]。&lt;a href=&quot;../../../io/trait.read#method.bytes&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12fec74288b63220271ad545369927ef8290a081" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将此 &lt;code&gt;Read&lt;/code&gt; 实例的字节数转换为[ &lt;code&gt;Iterator&lt;/code&gt; ]。&lt;a href=&quot;../io/trait.read#method.bytes&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="caf9cf05351d52e3be9282ae06933a14488056d3" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将此 &lt;code&gt;Read&lt;/code&gt; 实例的字节数转换为[ &lt;code&gt;Iterator&lt;/code&gt; ]。&lt;a href=&quot;io/trait.read#method.bytes&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="971992e8ed9d30a3c4193fa3cfd51e0926ac6cae" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将此 &lt;code&gt;Read&lt;/code&gt; 实例的字节数转换为[ &lt;code&gt;Iterator&lt;/code&gt; ]。&lt;a href=&quot;trait.read#method.bytes&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a3526b9261f151b08efa12a2cb227e4ab668a50" translate="yes" xml:space="preserve">
          <source>Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.</source>
          <target state="translated">将切片转换为另一种类型的切片,确保保持类型的对齐。</target>
        </trans-unit>
        <trans-unit id="b2cf0502b0b75797a67313725bcf7174bc249f5e" translate="yes" xml:space="preserve">
          <source>Transmute with two differently sized types was attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f952303e87a91f8044520d869ced49cf3453271e" translate="yes" xml:space="preserve">
          <source>Transmute with two differently sized types was attempted. Erroneous code example:</source>
          <target state="translated">试图用两种不同大小的类型进行转码。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="b4634eab766a7c67f4a788882ed6708930ac7723" translate="yes" xml:space="preserve">
          <source>Transposes a &lt;code&gt;Result&lt;/code&gt; of an &lt;code&gt;Option&lt;/code&gt; into an &lt;code&gt;Option&lt;/code&gt; of a &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">调换一个 &lt;code&gt;Result&lt;/code&gt; 的的 &lt;code&gt;Option&lt;/code&gt; 为 &lt;code&gt;Option&lt;/code&gt; 一个的 &lt;code&gt;Result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeec9f606ca7cc27f401e6245265d892d7c06264" translate="yes" xml:space="preserve">
          <source>Transposes an &lt;code&gt;Option&lt;/code&gt; of a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; of an &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f3938f31467da551894d5bc312a73ba5dfa379" translate="yes" xml:space="preserve">
          <source>Transposes an &lt;code&gt;Option&lt;/code&gt; of a &lt;code&gt;Result&lt;/code&gt; into a &lt;code&gt;Result&lt;/code&gt; of an &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">转置 &lt;code&gt;Option&lt;/code&gt; 一的 &lt;code&gt;Result&lt;/code&gt; 为 &lt;code&gt;Result&lt;/code&gt; 的的 &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9ccf92c436ad92e69f629d1e0488d9928d7d7e6" translate="yes" xml:space="preserve">
          <source>Treating Smart Pointers Like Regular References with the &lt;code id=&quot;treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait</source>
          <target state="translated">使用 &lt;code id=&quot;treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;Deref&lt;/code&gt; 特性将智能指针视为常规参考</target>
        </trans-unit>
        <trans-unit id="453a0f8e23093d2d468470224b84f666ef425b17" translate="yes" xml:space="preserve">
          <source>Treating a Type Like a Reference by Implementing the &lt;code id=&quot;treating-a-type-like-a-reference-by-implementing-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait</source>
          <target state="translated">通过实现 &lt;code id=&quot;treating-a-type-like-a-reference-by-implementing-the-deref-trait&quot;&gt;Deref&lt;/code&gt; 特性将类型视为引用</target>
        </trans-unit>
        <trans-unit id="dc5f05aecd7821404c68147034c8c8b762c94716" translate="yes" xml:space="preserve">
          <source>Treating each integration test file as its own crate is useful to create separate scopes that are more like the way end users will be using your crate. However, this means files in the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t share the same behavior as files in &lt;em&gt;src&lt;/em&gt; do, as you learned in Chapter 7 regarding how to separate code into modules and files.</source>
          <target state="translated">将每个集成测试文件视为其自己的板条箱对于创建单独的作用域非常有用，这些范围更像最终用户将使用您的板条箱。但是，这意味着&lt;em&gt;tests&lt;/em&gt;目录中的文件与&lt;em&gt;src中的&lt;/em&gt;文件不具有相同的行为，正如您在第7章中了解到的如何将代码分为模块和文件一样。</target>
        </trans-unit>
        <trans-unit id="7569cb1679e0c3aa7540702f13a5f8dd4a1739a0" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;HashMap&amp;lt;K,V&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">尝试备用容量为至少 &lt;code&gt;additional&lt;/code&gt; 在给定的要被插入多个元件 &lt;code&gt;HashMap&amp;lt;K,V&amp;gt;&lt;/code&gt; 。该集合可以保留更多空间，以避免频繁的重新分配。</target>
        </trans-unit>
        <trans-unit id="44298809e4f1f115c9f5ba28f46ae5a8d609bfc3" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;HashSet&amp;lt;K,V&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">尝试备用容量为至少 &lt;code&gt;additional&lt;/code&gt; 在给定的要被插入多个元件 &lt;code&gt;HashSet&amp;lt;K,V&amp;gt;&lt;/code&gt; 。该集合可以保留更多空间，以避免频繁的重新分配。</target>
        </trans-unit>
        <trans-unit id="57b7ed7bcbd15d35b279a1bce9bfd658efd71b2a" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;String&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">尝试备用容量为至少 &lt;code&gt;additional&lt;/code&gt; 在给定的要被插入多个元件 &lt;code&gt;String&lt;/code&gt; 。该集合可以保留更多空间，以避免频繁的重新分配。调用 &lt;code&gt;reserve&lt;/code&gt; 之后，容量将大于或等于 &lt;code&gt;self.len() + additional&lt;/code&gt; 。如果容量已经足够，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="1cd7b987cbc0791bfb1324cfd6464263751dd7d3" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">尝试备用容量为至少 &lt;code&gt;additional&lt;/code&gt; 在给定的要被插入多个元件 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 。该集合可以保留更多空间，以避免频繁的重新分配。调用 &lt;code&gt;reserve&lt;/code&gt; 之后，容量将大于或等于 &lt;code&gt;self.len() + additional&lt;/code&gt; 。如果容量已经足够，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="3cfac0433720c8cd13adc91772d417cffa80bddb" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;try_reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddb2f7e963d7384fcd84f59781aafbcb1eefd0c" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">尝试备用容量为至少 &lt;code&gt;additional&lt;/code&gt; 在给定的要被插入多个元件 &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; 。该集合可以保留更多空间，以避免频繁的重新分配。调用 &lt;code&gt;reserve&lt;/code&gt; 之后，容量将大于或等于 &lt;code&gt;self.len() + additional&lt;/code&gt; 。如果容量已经足够，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="c6ae8edff340a9bc30d1fc3ea07c88a2d615e594" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;try_reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c1225ca478afba96e69e3738929c44dc44f818" translate="yes" xml:space="preserve">
          <source>Tries to reserve the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;try_reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt; if it returns &lt;code&gt;Ok(())&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c910716261f7e551f1259edf1ea661f9578f8fe" translate="yes" xml:space="preserve">
          <source>Tries to reserve the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;try_reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea826f973c60e61f52c1a1545b1dfe84c909b71b" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;String&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">尝试保留最小容量，以便在给定 &lt;code&gt;String&lt;/code&gt; 中插入恰好 &lt;code&gt;additional&lt;/code&gt; 其他元素。调用 &lt;code&gt;reserve_exact&lt;/code&gt; 之后，容量将大于或等于 &lt;code&gt;self.len() + additional&lt;/code&gt; 。如果容量已经足够，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="c6bd5db90f8cb9540fd3f35c2883f8b8a881d37a" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">尝试储备恰好最小容量 &lt;code&gt;additional&lt;/code&gt; 在给定的要被插入多个元件 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 。调用 &lt;code&gt;reserve_exact&lt;/code&gt; 之后，容量将大于或等于 &lt;code&gt;self.len() + additional&lt;/code&gt; 。如果容量已经足够，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="90bd1ab7f76bd67110646c064057b5e26a376cef" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">尝试储备恰好最小容量 &lt;code&gt;additional&lt;/code&gt; 在给定的要被插入多个元件 &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; 。调用 &lt;code&gt;reserve_exact&lt;/code&gt; 之后，容量将大于或等于 &lt;code&gt;self.len() + additional&lt;/code&gt; 。如果容量已经足够，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="6547ac01541509cbac431ef7568ec956f10079ba" translate="yes" xml:space="preserve">
          <source>Triggers a panic without invoking the panic hook.</source>
          <target state="translated">触发惊恐而不引动惊恐钩。</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="27c211f297ff6afd2354cf8148b012cae3b0628b" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;self&lt;/code&gt; to &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;self.parent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb95599ef56aa13caaac1499a3644565e8b6049" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;self&lt;/code&gt; to &lt;a href=&quot;struct.pathbuf#method.parent&quot;&gt;&lt;code&gt;self.parent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;self&lt;/code&gt; 截断为&lt;a href=&quot;struct.pathbuf#method.parent&quot;&gt; &lt;code&gt;self.parent&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5927f0d5ac8801b4254d8379327d991a701a80da" translate="yes" xml:space="preserve">
          <source>Truncates or extends the underlying file, updating the size of this file to become &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">截断或扩展基础文件，将该文件的大小更新为 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2702cfbf0e58f8f82fb23e8d650e499d7cc927c5" translate="yes" xml:space="preserve">
          <source>Truncates the &lt;code&gt;OsString&lt;/code&gt; to zero length.</source>
          <target state="translated">将 &lt;code&gt;OsString&lt;/code&gt; 截断为零长度。</target>
        </trans-unit>
        <trans-unit id="ed28d8bdecc758ddcef76eed8b86ffa1d4ea3181" translate="yes" xml:space="preserve">
          <source>Truncates this &lt;code&gt;String&lt;/code&gt;, removing all contents.</source>
          <target state="translated">截断此 &lt;code&gt;String&lt;/code&gt; ，删除所有内容。</target>
        </trans-unit>
        <trans-unit id="5474aa5946c713a1f6e7a033ad591db623edd6d3" translate="yes" xml:space="preserve">
          <source>Truncating a five element vector to two elements:</source>
          <target state="translated">将一个五元素向量截断为两个元素。</target>
        </trans-unit>
        <trans-unit id="743f01c9ef69fe480785553858265deba678132e" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">当 &lt;code&gt;len == 0&lt;/code&gt; 时截断等效于调用&lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7b9f4a78a76c6893e05b1ff011a47211505551b2" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63908c3dcfc457f07a333b89f52c763024b846da" translate="yes" xml:space="preserve">
          <source>TrustedLen</source>
          <target state="translated">TrustedLen</target>
        </trans-unit>
        <trans-unit id="72677028b4d0d41af475041fdbe030f7c7146d2c" translate="yes" xml:space="preserve">
          <source>Try</source>
          <target state="translated">Try</target>
        </trans-unit>
        <trans-unit id="93cacc9f6a162523f52bc4401526c741faac95a0" translate="yes" xml:space="preserve">
          <source>Try designing more experiments that vary the values and lifetimes of the references passed in to the &lt;code&gt;longest&lt;/code&gt; function and how the returned reference is used. Make hypotheses about whether or not your experiments will pass the borrow checker before you compile; then check to see if you&amp;rsquo;re right!</source>
          <target state="translated">尝试设计更多的实验，以改变传递给 &lt;code&gt;longest&lt;/code&gt; 函数的引用的值和生存期，以及如何使用返回的引用。假设您的实验在编译之前是否会通过借阅检查器；然后检查您是否正确！</target>
        </trans-unit>
        <trans-unit id="b25651affa48a09fef804a246293a9441327deef" translate="yes" xml:space="preserve">
          <source>Try making a request from a different browser or asking for a different address, such as &lt;em&gt;127.0.0.1:7878/test&lt;/em&gt;, to see how the request data changes.</source>
          <target state="translated">尝试从其他浏览器发出请求或请求其他地址，例如&lt;em&gt;127.0.0.1:7878/test&lt;/em&gt;，以查看请求数据的变化。</target>
        </trans-unit>
        <trans-unit id="3cdedf03df7f2d7ff7f62a3fe4c0233e49c2605a" translate="yes" xml:space="preserve">
          <source>Try modifying &lt;code&gt;Cacher&lt;/code&gt; to hold a hash map rather than a single value. The keys of the hash map will be the &lt;code&gt;arg&lt;/code&gt; values that are passed in, and the values of the hash map will be the result of calling the closure on that key. Instead of looking at whether &lt;code&gt;self.value&lt;/code&gt; directly has a &lt;code&gt;Some&lt;/code&gt; or a &lt;code&gt;None&lt;/code&gt; value, the &lt;code&gt;value&lt;/code&gt; function will look up the &lt;code&gt;arg&lt;/code&gt; in the hash map and return the value if it&amp;rsquo;s present. If it&amp;rsquo;s not present, the &lt;code&gt;Cacher&lt;/code&gt; will call the closure and save the resulting value in the hash map associated with its &lt;code&gt;arg&lt;/code&gt; value.</source>
          <target state="translated">尝试修改 &lt;code&gt;Cacher&lt;/code&gt; 以保存哈希图，而不是单个值。哈希图的键将是传入的 &lt;code&gt;arg&lt;/code&gt; 值，哈希图的值将是对该键调用闭包的结果。而不是查看 &lt;code&gt;self.value&lt;/code&gt; 是否直接具有 &lt;code&gt;Some&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; 值， &lt;code&gt;value&lt;/code&gt; 函数将在哈希映射中查找 &lt;code&gt;arg&lt;/code&gt; 并返回该值（如果存在）。如果不存在，则 &lt;code&gt;Cacher&lt;/code&gt; 将调用该闭包，并将结果值保存在与其 &lt;code&gt;arg&lt;/code&gt; 值关联的哈希图中。</target>
        </trans-unit>
        <trans-unit id="746db25e46725d2a25a5be38541b8fd90c0e318e" translate="yes" xml:space="preserve">
          <source>Try running the program a few times:</source>
          <target state="translated">试着运行该程序几次。</target>
        </trans-unit>
        <trans-unit id="40db21ca976b20c4f1a37614a766d7e0fedff356" translate="yes" xml:space="preserve">
          <source>Try running this code; you should see the following output:</source>
          <target state="translated">试着运行这段代码;你应该看到以下输出。</target>
        </trans-unit>
        <trans-unit id="0c704dff8c8947b24bdb19d42ed1933021fa9b51" translate="yes" xml:space="preserve">
          <source>Try running this program with the &lt;code&gt;main&lt;/code&gt; function from Listing 13-2. Change the values in the &lt;code&gt;simulated_user_specified_value&lt;/code&gt; and &lt;code&gt;simulated_random_number&lt;/code&gt; variables to verify that in all the cases in the various &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks, &lt;code&gt;calculating slowly...&lt;/code&gt; appears only once and only when needed. The &lt;code&gt;Cacher&lt;/code&gt; takes care of the logic necessary to ensure we aren&amp;rsquo;t calling the expensive calculation more than we need to so &lt;code&gt;generate_workout&lt;/code&gt; can focus on the business logic.</source>
          <target state="translated">尝试使用清单13-2中的 &lt;code&gt;main&lt;/code&gt; 函数运行该程序。更改 &lt;code&gt;simulated_user_specified_value&lt;/code&gt; 和 &lt;code&gt;simulated_random_number&lt;/code&gt; 变量中的值，以验证在各种情况下，在各种 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块中， &lt;code&gt;calculating slowly...&lt;/code&gt; 仅在需要时才出现一次。该 &lt;code&gt;Cacher&lt;/code&gt; 采取必要的逻辑的谨慎，以确保我们不是要求昂贵的计算比我们更需要这样 &lt;code&gt;generate_workout&lt;/code&gt; 可以专注于业务逻辑。</target>
        </trans-unit>
        <trans-unit id="f64954535b22680cee23c59284f0821d313912c5" translate="yes" xml:space="preserve">
          <source>Try running this program; you should get the following output:</source>
          <target state="translated">试着运行这个程序,你应该得到以下输出。</target>
        </trans-unit>
        <trans-unit id="4e2f79e768da3d333677b7768aba6698b9473abe" translate="yes" xml:space="preserve">
          <source>Try the tasks suggested for additional requirements that we mentioned at the start of this section on the &lt;code&gt;blog&lt;/code&gt; crate as it is after Listing 17-20 to see what you think about the design of this version of the code. Note that some of the tasks might be completed already in this design.</source>
          <target state="translated">在清单17-20之后，尝试在 &lt;code&gt;blog&lt;/code&gt; 板箱本节开头提到的建议的任务，以了解其他要求，以了解您对该版本代码的设计有何看法。请注意，某些任务可能已在此设计中完成。</target>
        </trans-unit>
        <trans-unit id="bea7aa5241bc934fb93d73fbe72c3c92fd9cb391" translate="yes" xml:space="preserve">
          <source>Try this instead:</source>
          <target state="translated">试试这个吧</target>
        </trans-unit>
        <trans-unit id="cf4dffd1f17e87d4131fe9dbd6ed3566366e3295" translate="yes" xml:space="preserve">
          <source>Try to avoid moving the variable.</source>
          <target state="translated">尽量避免移动变量。</target>
        </trans-unit>
        <trans-unit id="708f496ce718cad5f2bfb9c2203cb73e375d06e0" translate="yes" xml:space="preserve">
          <source>Try to create the target number type from a source number type. This returns an error if the source value is outside of the range of the target type.</source>
          <target state="translated">尝试从源数字类型创建目标数字类型。如果源值在目标类型的范围之外,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="d7bb54d91c5813615d6b6445e2ebf488e82cdc0c" translate="yes" xml:space="preserve">
          <source>Try using &lt;code&gt;{}&lt;/code&gt; instead:</source>
          <target state="translated">尝试改用 &lt;code&gt;{}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8a1eb6a4114d62537aa281f5d03abf55ba6e9e3" translate="yes" xml:space="preserve">
          <source>Try using type inference instead. Example:</source>
          <target state="translated">尝试使用类型推理来代替。例如:</target>
        </trans-unit>
        <trans-unit id="ea0079401a89dd04fe8291c0c734d4aa5a8c7177" translate="yes" xml:space="preserve">
          <source>Try::from_error</source>
          <target state="translated">Try::from_error</target>
        </trans-unit>
        <trans-unit id="bde6f44b7e04bd6491a07ffb037c4fa48b882a33" translate="yes" xml:space="preserve">
          <source>Try::from_ok</source>
          <target state="translated">Try::from_ok</target>
        </trans-unit>
        <trans-unit id="809111dd75695d75905fa1c8b4bad5d14691a30e" translate="yes" xml:space="preserve">
          <source>Try::into_result</source>
          <target state="translated">Try::into_result</target>
        </trans-unit>
        <trans-unit id="18e77d4b44ff639060d9a2fa2960f190781f7859" translate="yes" xml:space="preserve">
          <source>TryFrom</source>
          <target state="translated">TryFrom</target>
        </trans-unit>
        <trans-unit id="4acc1ac1c58ab4ae6724001d461baf2c8b8dbc3a" translate="yes" xml:space="preserve">
          <source>TryFrom::try_from</source>
          <target state="translated">TryFrom::try_from</target>
        </trans-unit>
        <trans-unit id="ad96c601815ad5f050e0b6351dd0b189e48a31a9" translate="yes" xml:space="preserve">
          <source>TryFromIntError</source>
          <target state="translated">TryFromIntError</target>
        </trans-unit>
        <trans-unit id="f81061adcf59a4b18f6432dc500e16b9a793d0e6" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow</source>
          <target state="translated">TryFromIntError::borrow</target>
        </trans-unit>
        <trans-unit id="4d5e6ded3e6e6a7b69de27e74b52df8d33085625" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow_mut</source>
          <target state="translated">TryFromIntError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8c6ac7bc7b08a0164c28c84e181d07ac7264caa1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::cause</source>
          <target state="translated">TryFromIntError::cause</target>
        </trans-unit>
        <trans-unit id="f0da83cb703ff9ab478400076f17fb3b6df58453" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone</source>
          <target state="translated">TryFromIntError::clone</target>
        </trans-unit>
        <trans-unit id="21c991dfc7c9f46d0f223e9ada6bbb1b3ddc0419" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_from</source>
          <target state="translated">TryFromIntError::clone_from</target>
        </trans-unit>
        <trans-unit id="611f56282230f313fea840ae9d1b4022b318faec" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_into</source>
          <target state="translated">TryFromIntError::clone_into</target>
        </trans-unit>
        <trans-unit id="05df18eb5e5e51ad418c603a8c9e45f939b7afa0" translate="yes" xml:space="preserve">
          <source>TryFromIntError::description</source>
          <target state="translated">TryFromIntError::description</target>
        </trans-unit>
        <trans-unit id="cffa72c79f028d8b2b67ac3b5a88fa8e893445f1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::eq</source>
          <target state="translated">TryFromIntError::eq</target>
        </trans-unit>
        <trans-unit id="7ec29ac29b26af4ad4e22c908d20f04e34123009" translate="yes" xml:space="preserve">
          <source>TryFromIntError::fmt</source>
          <target state="translated">TryFromIntError::fmt</target>
        </trans-unit>
        <trans-unit id="27af3cbe1fc043a4ba2263a1ddb04f43ed3341d8" translate="yes" xml:space="preserve">
          <source>TryFromIntError::from</source>
          <target state="translated">TryFromIntError::from</target>
        </trans-unit>
        <trans-unit id="88b0ca4bd6e97295df88042c17da3bc4ad1d1e49" translate="yes" xml:space="preserve">
          <source>TryFromIntError::into</source>
          <target state="translated">TryFromIntError::into</target>
        </trans-unit>
        <trans-unit id="b590493dab8454ef91bc8263edc4d90474ae7585" translate="yes" xml:space="preserve">
          <source>TryFromIntError::ne</source>
          <target state="translated">TryFromIntError::ne</target>
        </trans-unit>
        <trans-unit id="34bc40cbf452f309c77160c0bc046a559d512c4c" translate="yes" xml:space="preserve">
          <source>TryFromIntError::source</source>
          <target state="translated">TryFromIntError::source</target>
        </trans-unit>
        <trans-unit id="4650111711913011245aed1cfd4e401bf80b92bd" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_owned</source>
          <target state="translated">TryFromIntError::to_owned</target>
        </trans-unit>
        <trans-unit id="145d38c6294ea7b0b18a9beaf5c2ba62d71c6d31" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_string</source>
          <target state="translated">TryFromIntError::to_string</target>
        </trans-unit>
        <trans-unit id="3bd074fd7b824eb16d5c009603fefee21d967354" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_from</source>
          <target state="translated">TryFromIntError::try_from</target>
        </trans-unit>
        <trans-unit id="2a66975e8a4a9df97b01eea79b97edba1ce4fc13" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_into</source>
          <target state="translated">TryFromIntError::try_into</target>
        </trans-unit>
        <trans-unit id="853b95e029b9b10b04426ea41bce22a33cadfde3" translate="yes" xml:space="preserve">
          <source>TryFromIntError::type_id</source>
          <target state="translated">TryFromIntError::type_id</target>
        </trans-unit>
        <trans-unit id="f7ae979f3e3e5c6883cf562acec4a3d8911ff6b7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError</source>
          <target state="translated">TryFromSliceError</target>
        </trans-unit>
        <trans-unit id="08abda7dda4132c13ad2de215a8116ad1c512693" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow</source>
          <target state="translated">TryFromSliceError::borrow</target>
        </trans-unit>
        <trans-unit id="a42a16b656b3e78ad3c1fba788c25cca8562aa04" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow_mut</source>
          <target state="translated">TryFromSliceError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6b154dc43d23a695abe3c26c810c9600a10bbfc7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::cause</source>
          <target state="translated">TryFromSliceError::cause</target>
        </trans-unit>
        <trans-unit id="06c3cdee5b115341587a81b7640e380fd15333ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone</source>
          <target state="translated">TryFromSliceError::clone</target>
        </trans-unit>
        <trans-unit id="a4d48a9b9f7dd5e07e2bb398d2d1029a5b1eb76b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_from</source>
          <target state="translated">TryFromSliceError::clone_from</target>
        </trans-unit>
        <trans-unit id="faf3d5f757e37a47d1e58275eb48efaa726218ad" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_into</source>
          <target state="translated">TryFromSliceError::clone_into</target>
        </trans-unit>
        <trans-unit id="49619f8bf5df143f7d9e552904f6a84fca8093ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::description</source>
          <target state="translated">TryFromSliceError::description</target>
        </trans-unit>
        <trans-unit id="fc484006f6aa38bffa40eb517d8b4b32091a5671" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::fmt</source>
          <target state="translated">TryFromSliceError::fmt</target>
        </trans-unit>
        <trans-unit id="630dd1955f1b733df02d2f1446cd6b9ba9cd293b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::from</source>
          <target state="translated">TryFromSliceError::from</target>
        </trans-unit>
        <trans-unit id="2a5519380aabe238e175f9b6849d0a2d7f53c5a8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::into</source>
          <target state="translated">TryFromSliceError::into</target>
        </trans-unit>
        <trans-unit id="b1ef9a7f4941a7c7fc1ee4d269c0be752b4049c1" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::source</source>
          <target state="translated">TryFromSliceError::source</target>
        </trans-unit>
        <trans-unit id="46b791fdfec792bbb13fbb3115a245caecffc0d8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_owned</source>
          <target state="translated">TryFromSliceError::to_owned</target>
        </trans-unit>
        <trans-unit id="04f8529255b3a3ba17e31837ca350fb03a1837a0" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_string</source>
          <target state="translated">TryFromSliceError::to_string</target>
        </trans-unit>
        <trans-unit id="d39f8030ca01a81b1eedd289678e98a9a8c6374d" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_from</source>
          <target state="translated">TryFromSliceError::try_from</target>
        </trans-unit>
        <trans-unit id="87b56d5270282ca8cea8f2ae22fb393b6ef2e185" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_into</source>
          <target state="translated">TryFromSliceError::try_into</target>
        </trans-unit>
        <trans-unit id="273ef45502220a3e82cc6cd2ff47d1b967ced192" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::type_id</source>
          <target state="translated">TryFromSliceError::type_id</target>
        </trans-unit>
        <trans-unit id="eb91bb9edb358310d1de44ff46dcb50ed3d4dbf6" translate="yes" xml:space="preserve">
          <source>TryInto</source>
          <target state="translated">TryInto</target>
        </trans-unit>
        <trans-unit id="d4782bb6e82830853df5d390b765742f2ed433ce" translate="yes" xml:space="preserve">
          <source>TryInto::try_into</source>
          <target state="translated">TryInto::try_into</target>
        </trans-unit>
        <trans-unit id="d550a8f93a6fe62cffc66481db4e53166b4de9e5" translate="yes" xml:space="preserve">
          <source>TryIter</source>
          <target state="translated">TryIter</target>
        </trans-unit>
        <trans-unit id="b4f81b18947056193693e5cce08cae5bcc996cf1" translate="yes" xml:space="preserve">
          <source>TryLockError</source>
          <target state="translated">TryLockError</target>
        </trans-unit>
        <trans-unit id="6408d526dcb04978c761f176b4b48253f6e2b3a3" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow</source>
          <target state="translated">TryLockError::borrow</target>
        </trans-unit>
        <trans-unit id="c1162b670a7e56c24667fd355cb74c01579b66f6" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow_mut</source>
          <target state="translated">TryLockError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="645caaf83340c9e36066d5283df40d2289f0c56a" translate="yes" xml:space="preserve">
          <source>TryLockError::cause</source>
          <target state="translated">TryLockError::cause</target>
        </trans-unit>
        <trans-unit id="edc35be2771c53d502f5e8aaee878dd2e15d3b5a" translate="yes" xml:space="preserve">
          <source>TryLockError::description</source>
          <target state="translated">TryLockError::description</target>
        </trans-unit>
        <trans-unit id="c6f2c000c844249e646527b009bb44e488eef5e5" translate="yes" xml:space="preserve">
          <source>TryLockError::fmt</source>
          <target state="translated">TryLockError::fmt</target>
        </trans-unit>
        <trans-unit id="9001bf82d878e70373f04e6654b0f776179b2f53" translate="yes" xml:space="preserve">
          <source>TryLockError::from</source>
          <target state="translated">TryLockError::from</target>
        </trans-unit>
        <trans-unit id="655a2e7bdf752d14f5354358dacab8b46b5c1b0d" translate="yes" xml:space="preserve">
          <source>TryLockError::into</source>
          <target state="translated">TryLockError::into</target>
        </trans-unit>
        <trans-unit id="e4ccb09bacf6984439f523c7aecac39df9844058" translate="yes" xml:space="preserve">
          <source>TryLockError::source</source>
          <target state="translated">TryLockError::source</target>
        </trans-unit>
        <trans-unit id="c61e09fc91fbcfa81bcf718beb714ea63719b4eb" translate="yes" xml:space="preserve">
          <source>TryLockError::to_string</source>
          <target state="translated">TryLockError::to_string</target>
        </trans-unit>
        <trans-unit id="ebcde8097671e82bd0e812397421ce3e5f83aa6a" translate="yes" xml:space="preserve">
          <source>TryLockError::try_from</source>
          <target state="translated">TryLockError::try_from</target>
        </trans-unit>
        <trans-unit id="7b92cc07d0ee9b28099cb947d6053805d66baac1" translate="yes" xml:space="preserve">
          <source>TryLockError::try_into</source>
          <target state="translated">TryLockError::try_into</target>
        </trans-unit>
        <trans-unit id="904eaeeceb270dd726f594af3ac7324866060774" translate="yes" xml:space="preserve">
          <source>TryLockError::type_id</source>
          <target state="translated">TryLockError::type_id</target>
        </trans-unit>
        <trans-unit id="7d779fd6e34ddc3c9ecd145e12eaab2707fb88f2" translate="yes" xml:space="preserve">
          <source>TryLockResult</source>
          <target state="translated">TryLockResult</target>
        </trans-unit>
        <trans-unit id="b00cb1382a524b91c7b6f872f909018a2ba2fcdb" translate="yes" xml:space="preserve">
          <source>TryRecvError</source>
          <target state="translated">TryRecvError</target>
        </trans-unit>
        <trans-unit id="ffa19b2195d0c15e9339c99460878fe4f010d76d" translate="yes" xml:space="preserve">
          <source>TryReserveError</source>
          <target state="translated">TryReserveError</target>
        </trans-unit>
        <trans-unit id="7b782adc98cd68cba60f49733fd7fc4e8ce78c2c" translate="yes" xml:space="preserve">
          <source>TrySendError</source>
          <target state="translated">TrySendError</target>
        </trans-unit>
        <trans-unit id="bb111acc067364e9c3571b77d0ce5c4a9c6b3124" translate="yes" xml:space="preserve">
          <source>Trying to implement this scenario using our definition of &lt;code&gt;List&lt;/code&gt; with &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; won&amp;rsquo;t work, as shown in Listing 15-17:</source>
          <target state="translated">尝试使用我们的定义来实现这个场景 &lt;code&gt;List&lt;/code&gt; 与 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 将无法正常工作，如清单15-17：</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="5518f0873d902287241e5e83188a303861d5a9e6" translate="yes" xml:space="preserve">
          <source>Tuple Layout</source>
          <target state="translated">元组布局</target>
        </trans-unit>
        <trans-unit id="11dd41e6851bdf449646a773272c37c50a284fc9" translate="yes" xml:space="preserve">
          <source>Tuple and tuple indexing expressions</source>
          <target state="translated">元组和元组索引表达式</target>
        </trans-unit>
        <trans-unit id="6bdf2a89da03771b9bc590f650c8c5b6c77c5197" translate="yes" xml:space="preserve">
          <source>Tuple expression</source>
          <target state="translated">元组表达式</target>
        </trans-unit>
        <trans-unit id="a63a11d9cdfd9d84d9c0b5569d554b9e83dcf1cc" translate="yes" xml:space="preserve">
          <source>Tuple expression attributes</source>
          <target state="translated">元组表达式属性</target>
        </trans-unit>
        <trans-unit id="e822aa7ad790f9164d76dd24bd82039b2ac65758" translate="yes" xml:space="preserve">
          <source>Tuple expressions</source>
          <target state="translated">元组表达式</target>
        </trans-unit>
        <trans-unit id="f601e94cafc9d12d8593dd02c6d703d40de35c4d" translate="yes" xml:space="preserve">
          <source>Tuple index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6c1f43b44b32fa35dca7937a6775d19792506c" translate="yes" xml:space="preserve">
          <source>Tuple indexing</source>
          <target state="translated">元组索引</target>
        </trans-unit>
        <trans-unit id="44dc4b3b01b16ad2661df0966d7c7a1cf905b8b9" translate="yes" xml:space="preserve">
          <source>Tuple indexing expressions</source>
          <target state="translated">元组索引表达式</target>
        </trans-unit>
        <trans-unit id="b8a1d058f14f452a93d10da089ec69f4c32d794e" translate="yes" xml:space="preserve">
          <source>Tuple indices are compared with the literal token directly. Tuple indices start with &lt;code&gt;0&lt;/code&gt; and each successive index increments the value by &lt;code&gt;1&lt;/code&gt; as a decimal value. Thus, only decimal values will match, and the value must not have any extra &lt;code&gt;0&lt;/code&gt; prefix characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28c59e960977888e94a3c34b0278e6e00c6936d" translate="yes" xml:space="preserve">
          <source>Tuple patterns</source>
          <target state="translated">元组模式</target>
        </trans-unit>
        <trans-unit id="49d48b16cda97c82ccd41f82c8b675a2db8b4116" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d60a4a77a7ad9b86665dc5ec42ea14f2698ee75" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="translated">元组模式匹配的元组值与其子模式定义的所有条件均匹配。它们还用于&lt;a href=&quot;patterns#destructuring&quot;&gt;破坏&lt;/a&gt;元组。</target>
        </trans-unit>
        <trans-unit id="f4691e7b0b597791c415f166cd1397c0daec1163" translate="yes" xml:space="preserve">
          <source>Tuple struct expression</source>
          <target state="translated">元组结构表达式</target>
        </trans-unit>
        <trans-unit id="ea9f0838dcbcc88a01e222d90f53e8f39880136f" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns</source>
          <target state="translated">元组结构模式</target>
        </trans-unit>
        <trans-unit id="91a08356932d9cf1d09320f96dfca3ba26d2fc8a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce23bf97599891184ee6af65a034650dc03427a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="translated">元组结构模式匹配元组结构和枚举值，该值与由其子模式定义的所有条件匹配。它们还用于&lt;a href=&quot;patterns#destructuring&quot;&gt;解构&lt;/a&gt;元组结构或枚举值。</target>
        </trans-unit>
        <trans-unit id="dd28158a620f360ba4aa0c759eb104e4dede6329" translate="yes" xml:space="preserve">
          <source>Tuple structs are instantiated in the same way as tuples themselves, except with the struct's name as a prefix: &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt;.</source>
          <target state="translated">用元组本身的实例化元组结构，除了以结构名作为前缀： &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="985c4283e220405d4d0ac504a38671b8b680d3c5" translate="yes" xml:space="preserve">
          <source>Tuple structs are similar to regular structs, but its fields have no names. They are used like tuples, with deconstruction possible via &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; syntax. For accessing individual variables, the same syntax is used as with regular tuples, namely &lt;code&gt;foo.0&lt;/code&gt;, &lt;code&gt;foo.1&lt;/code&gt;, etc, starting at zero.</source>
          <target state="translated">元组结构与常规结构相似，但是其字段没有名称。它们就像元组一样使用，可以通过 &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; 解构。句法。为了访问各个变量，使用与常规元组相同的语法，即 &lt;code&gt;foo.0&lt;/code&gt; ， &lt;code&gt;foo.1&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="405d7b4bc4604c6657b54f4846e0560006e9fc0e" translate="yes" xml:space="preserve">
          <source>Tuple type</source>
          <target state="translated">元组类型</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">元组类型</target>
        </trans-unit>
        <trans-unit id="5e273646744d8620cb13d8fba10b333bc84bed1e" translate="yes" xml:space="preserve">
          <source>Tuple types and values are denoted by listing the types or values of their elements, respectively, in a parenthesized, comma-separated list.</source>
          <target state="translated">元组类型和值是通过将其元素的类型或值分别列在一个用括号、逗号分隔的列表中来表示的。</target>
        </trans-unit>
        <trans-unit id="3fbd57dd63bac7c82834159ddc9ea56e1515ece9" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="translated">元组类型，如果每个组件还实现 &lt;code&gt;Clone&lt;/code&gt; （例如 &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;(i32, bool)&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="bd89c408cfdec88fd6d8e898f3566b701ea35d3a" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="translated">的元组类型，如果每个部件还实现 &lt;code&gt;Copy&lt;/code&gt; （例如， &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;(i32, bool)&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="56d624bd930abb83c2a720d48bf858a7d49eb690" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;finite&lt;/em&gt;. In other words, a tuple has a length. Here's a tuple of length &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">元组是&lt;em&gt;有限的&lt;/em&gt;。换句话说，元组具有长度。这是一个长度为 &lt;code&gt;3&lt;/code&gt; 的元组：</target>
        </trans-unit>
        <trans-unit id="4da05b6b2dc1fb19e334d246d97430b523feb378" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;heterogeneous&lt;/em&gt;. This means that each element of the tuple can have a different type. In that tuple above, it has the type:</source>
          <target state="translated">元组是&lt;em&gt;异构的&lt;/em&gt;。这意味着元组的每个元素可以具有不同的类型。在上面的元组中，其类型为：</target>
        </trans-unit>
        <trans-unit id="567f8079007690271f5a29cda47d067992841b99" translate="yes" xml:space="preserve">
          <source>Tuples are a &lt;em&gt;sequence&lt;/em&gt;. This means that they can be accessed by position; this is called 'tuple indexing', and it looks like this:</source>
          <target state="translated">元组是一个&lt;em&gt;序列&lt;/em&gt;。这意味着可以按位置访问它们；这称为&amp;ldquo;元组索引&amp;rdquo;，看起来像这样：</target>
        </trans-unit>
        <trans-unit id="e91ee0fad8731c0386a059fa3bf0652dd08c64d3" translate="yes" xml:space="preserve">
          <source>Tuples are often used as a return type when you want to return more than one value:</source>
          <target state="translated">当你想返回多个值时,Tuple通常被用作返回类型。</target>
        </trans-unit>
        <trans-unit id="d7ee3ba750e08e0013c45b2b001ce78e8459fa90" translate="yes" xml:space="preserve">
          <source>Tuples are written by enclosing zero or more comma-separated expressions in parentheses. They are used to create &lt;a href=&quot;../types/tuple&quot;&gt;tuple-typed&lt;/a&gt; values.</source>
          <target state="translated">通过将零个或多个逗号分隔的表达式括在括号中来编写元组。它们用于创建&lt;a href=&quot;../types/tuple&quot;&gt;元组类型的&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="5fb8ee22cf29120bf8f87bd0e3ee7ebd9949b96b" translate="yes" xml:space="preserve">
          <source>Tuples do not have any guarantees about their layout.</source>
          <target state="translated">图元组对其布局没有任何保证。</target>
        </trans-unit>
        <trans-unit id="cf3ce6296bd35ecede807c2ca855fee144afacb9" translate="yes" xml:space="preserve">
          <source>Tuples, if they only contain types that are also &lt;code&gt;Copy&lt;/code&gt;. For example, &lt;code&gt;(i32, i32)&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, but &lt;code&gt;(i32, String)&lt;/code&gt; is not.</source>
          <target state="translated">元组（如果它们仅包含也是 &lt;code&gt;Copy&lt;/code&gt; 的类型）。例如， &lt;code&gt;(i32, i32)&lt;/code&gt; 是 &lt;code&gt;Copy&lt;/code&gt; ，但 &lt;code&gt;(i32, String)&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="f9c67af2890eabc2460069a200a1d4229437528f" translate="yes" xml:space="preserve">
          <source>Tuples, where a tuple is a coercion site to type &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt;. Each sub-expression is a coercion site to the respective type, e.g. the zeroth sub-expression is a coercion site to type &lt;code&gt;U_0&lt;/code&gt;.</source>
          <target state="translated">元组，其中元组是要键入的强制站点 &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt; 。每个子表达式是相应类型的强制站点，例如，第零子表达式是类型 &lt;code&gt;U_0&lt;/code&gt; 的强制站点。</target>
        </trans-unit>
        <trans-unit id="c9853aa9de5add5fa51a4530e193cc7279fd6159" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89ab8db9a13e916878d1aff18816e183dfae8d6" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7311ea0eb58a505bdf5f01b88b3339c4b7cd8b3" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b38a71dfcaefc79a39b01d00754205648079aa2" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe97f664cc043b9cae686cc00711fc73ef1df08" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbea64da5a5f06d75e0a8af0090b3b0e2a08380" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4669fd8f77a02ec1c266c7fe545791bb7885dad1" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09625451991a5b8e805da34776aaedc90525fbd" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54437abef1f3840afb67899d2d515749e44d9fef" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="translated">将[ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ]转换为[ &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="e6b58be63cc031a2c0fb9a41ef4a5c4c544f30d9" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="translated">将[ &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; ]转换为[ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="68fccb5986b95d1769fe3ac2f5db1e4528fbe17a" translate="yes" xml:space="preserve">
          <source>Turning Our Single-Threaded Server into a Multithreaded Server</source>
          <target state="translated">将我们的单线程服务器变成多线程服务器</target>
        </trans-unit>
        <trans-unit id="b859b7ff96007e824952102a2b6cf7f2532bb6f5" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;*mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut T&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;*mut T&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="92f32c54d91cd32dab86c92433ff5bf59fbe670a" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 变成 &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ddddd1c6a422bfc2e73b1e1e06d4513f4b671ef3" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="translated">将指针变成 &lt;code&gt;usize&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0cfcb75a89ff8f3d42e0969a81b68c58ff41ffed" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a function pointer. This is &lt;em&gt;not&lt;/em&gt; portable to machines where function pointers and data pointers have different sizes.</source>
          <target state="translated">将指针变成函数指针。这对于函数指针和数据指针具有不同大小的机器是&lt;em&gt;不可&lt;/em&gt;移植的。</target>
        </trans-unit>
        <trans-unit id="406e60e2392b6e162c75155bdd0eec0802166101" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut U&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;mut U&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b7709a825d906324651f42904d312bfc3d9cfdce" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;str&lt;/code&gt; into an &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;str&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8fe665706a3a9d23c3f80f786fb6f659e7dafb3b" translate="yes" xml:space="preserve">
          <source>Turning raw bytes(&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;) to &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;f64&lt;/code&gt;, etc.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cfabf1744551752d0d316f8226b7949182c80d" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal, even if they are stored in different allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4a5ffe0d58bc942e71a31a403ac137dbf193dd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="translated">如果两个 &lt;code&gt;Arc&lt;/code&gt; 的内部值相等，则它们相等。</target>
        </trans-unit>
        <trans-unit id="3b0340dc9882895d2ed9f18ec41d4ee9ceaf4e0c" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="translated">如果两个 &lt;code&gt;Arc&lt;/code&gt; 的内部值不相等，则它们不相等。</target>
        </trans-unit>
        <trans-unit id="77c963714f423503919254b2ffd83b6fa90a298e" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal, even if they are stored in different allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a2d18514777aaae37a7ce067b908310bbd6b4b" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="translated">如果两个 &lt;code&gt;Rc&lt;/code&gt; 的内部值相等，则它们相等。</target>
        </trans-unit>
        <trans-unit id="2fa5c112e4e91cdb91570c34d930cf27ff1cdefa" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="translated">如果两个 &lt;code&gt;Rc&lt;/code&gt; 的内部值不相等，则它们不相等。</target>
        </trans-unit>
        <trans-unit id="2b4b2f527e82e5d4b1ed0e9743d509787616d686" translate="yes" xml:space="preserve">
          <source>Two associated items (like methods, associated types, associated functions, etc.) were defined with the same identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026acb3ca4aa61acf271a2918c10ebc97e741248" translate="yes" xml:space="preserve">
          <source>Two examples of simple paths consisting of only identifier segments:</source>
          <target state="translated">两个仅由标识符段组成的简单路径的例子。</target>
        </trans-unit>
        <trans-unit id="0cd83d672a615733082e8ee7f56c39b0af561a3e" translate="yes" xml:space="preserve">
          <source>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</source>
          <target state="translated">如果不将其中一个项目重新绑定在新的本地名称下,则无法导入两个同名的项目。</target>
        </trans-unit>
        <trans-unit id="cbb02c3e2b1b62256b2dccb2ec1aec1fddd7391c" translate="yes" xml:space="preserve">
          <source>Two kind of item &lt;em&gt;declarations&lt;/em&gt; are allowed in external blocks: &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt; and &lt;a href=&quot;static-items&quot;&gt;statics&lt;/a&gt;. Calling functions or accessing statics that are declared in external blocks is only allowed in an &lt;code&gt;unsafe&lt;/code&gt; context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d0f0b6138243f294ae08264cc55ed1bd1ca167" translate="yes" xml:space="preserve">
          <source>Two lifetimes cannot have the same name. To fix this example, change the second &lt;code&gt;'a&lt;/code&gt; lifetime into something else (&lt;code&gt;'c&lt;/code&gt; for example):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c944c513e67b8c4ff5047db8e7ab8f3c379bad" translate="yes" xml:space="preserve">
          <source>Two or more pointers access the same data at the same time.</source>
          <target state="translated">两个或多个指针同时访问同一数据。</target>
        </trans-unit>
        <trans-unit id="ea818e0ad4fe2dcf3d6dd4c02bacf808745d38d6" translate="yes" xml:space="preserve">
          <source>Two possibilities are available to solve this issue:</source>
          <target state="translated">解决这个问题有两种可能。</target>
        </trans-unit>
        <trans-unit id="9e61db6f0549ccd99ae56429864c2f4cbe98bb50" translate="yes" xml:space="preserve">
          <source>Two such examples are macros and &lt;code&gt;#[cfg]&lt;/code&gt; environments.</source>
          <target state="translated">两个这样的示例是宏和 &lt;code&gt;#[cfg]&lt;/code&gt; 环境。</target>
        </trans-unit>
        <trans-unit id="9d8a406e3a91b6f18f7fee9fffccd411cd7bea0e" translate="yes" xml:space="preserve">
          <source>Two tests that pass! Now let&amp;rsquo;s see what happens to our test results when we introduce a bug in our code. Let&amp;rsquo;s change the implementation of the &lt;code&gt;can_hold&lt;/code&gt; method by replacing the greater than sign with a less than sign when it compares the widths:</source>
          <target state="translated">两项测试通过！现在，让我们看看在代码中引入错误后测试结果会如何变化。让我们在比较宽度时，通过将大于号替换为小于号来更改 &lt;code&gt;can_hold&lt;/code&gt; 方法的实现：</target>
        </trans-unit>
        <trans-unit id="6831c93d3c0041ecff78583892f51cefdc18f74a" translate="yes" xml:space="preserve">
          <source>Two things are important to note about this function:</source>
          <target state="translated">关于这个功能,有两点需要注意。</target>
        </trans-unit>
        <trans-unit id="d73651bf2df8af467f41b29a872952ef24a40245" translate="yes" xml:space="preserve">
          <source>Two trait implementations overlap when there is a non-empty intersection of the traits the implementation is for, the implementations can be instantiated with the same type.</source>
          <target state="translated">当两个特质实现重叠时,当该实现所针对的特质有非空的交集时,可以用相同的类型实例化该实现。</target>
        </trans-unit>
        <trans-unit id="45049ec7ea97abec9bd8269a665797ccca478bf9" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + UnwindSafe + Send&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6094fd54b67e7d276ce315b3b79ffc2dd18ae2" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt;.</source>
          <target state="translated">如果基本特征彼此别名，并且自动特征集相同且生命周期范围相同，则两种特征对象类型彼此互斥。例如， &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; 与 &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d078a0dedfa986439265f5fefabc817ba279445" translate="yes" xml:space="preserve">
          <source>Two traits, &lt;a href=&quot;../std/marker/trait.unsize&quot;&gt;&lt;code&gt;Unsize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt;, are used to assist in this process and expose it for library use. The following coercions are built-ins and, if &lt;code&gt;T&lt;/code&gt; can be coerced to &lt;code&gt;U&lt;/code&gt; with one of them, then an implementation of &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; will be provided:</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.unsize&quot;&gt; &lt;code&gt;Unsize&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt;两个特征用于协助此过程，并将其公开以供库使用。以下强制是内置的，如果可以使用其中之一将 &lt;code&gt;T&lt;/code&gt; 强制为 &lt;code&gt;U&lt;/code&gt; ，则将为 &lt;code&gt;T&lt;/code&gt; 提供 &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; 实现：</target>
        </trans-unit>
        <trans-unit id="0c40881391e5533daaab739e69ccda2bb7bda270" translate="yes" xml:space="preserve">
          <source>TyCtor(&lt;code&gt;T&lt;/code&gt;) to TyCtor(&lt;code&gt;U&lt;/code&gt;), where TyCtor(&lt;code&gt;T&lt;/code&gt;) is one of</source>
          <target state="translated">TyCtor（ &lt;code&gt;T&lt;/code&gt; ）到TyCtor（ &lt;code&gt;U&lt;/code&gt; ），其中TyCtor（ &lt;code&gt;T&lt;/code&gt; ）是以下之一</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="8893ac4ddfe0ea4688a44afc0ddfe4ebc76a84ef" translate="yes" xml:space="preserve">
          <source>Type &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; represents an optional value: every &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is either &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; and contains a value, or &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, and does not. &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; types are very common in Rust code, as they have a number of uses:</source>
          <target state="translated">Type &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;代表一个可选值：每个&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;要么是&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;且包含一个值，要么是&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，但没有。&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;类型在Rust代码中非常常见，因为它们具有多种用途：</target>
        </trans-unit>
        <trans-unit id="5a34cc9264aacb6462265b18d25bcf726faf398f" translate="yes" xml:space="preserve">
          <source>Type Definition std::fmt::Result</source>
          <target state="translated">类型定义 std::fmt::Result</target>
        </trans-unit>
        <trans-unit id="34dd3e846f6d75301a90ce0c190a60bbb2f75015" translate="yes" xml:space="preserve">
          <source>Type Definition std::io::Result</source>
          <target state="translated">类型定义 std::io::Result</target>
        </trans-unit>
        <trans-unit id="46f6920a49ecfbe5727cafe69a86a93c6dc323b4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blkcnt_t</source>
          <target state="translated">类型定义 std::os::linux::raw::blkcnt_t</target>
        </trans-unit>
        <trans-unit id="85fbcc37c53b78d2794e588bd5f55d25d53b121b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blksize_t</source>
          <target state="translated">类型定义 std::os::linux::raw::blksize_t</target>
        </trans-unit>
        <trans-unit id="e2606fd8324f1985d42d98f82ef97532070eae3e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::dev_t</source>
          <target state="translated">类型定义 std::os::linux::raw::dev_t</target>
        </trans-unit>
        <trans-unit id="1a0725c0d449cfcc82b033154c822ab6aa94cb70" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::ino_t</source>
          <target state="translated">类型定义 std::os::linux::raw::ini_t</target>
        </trans-unit>
        <trans-unit id="96a7fc18b0419da7fc9a515e767bed1bfbc9562c" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::mode_t</source>
          <target state="translated">类型定义 std::os::linux::raw::mode_t</target>
        </trans-unit>
        <trans-unit id="75a060e0f5140a7dabbcb1ba8000909c3c0378d8" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::nlink_t</source>
          <target state="translated">类型定义 std::os::linux::raw::nlink_t</target>
        </trans-unit>
        <trans-unit id="7ae7bb16976469a8ad4e67f2c0d76a2afe6847e7" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::off_t</source>
          <target state="translated">类型定义 std::os::linux::raw::off_t</target>
        </trans-unit>
        <trans-unit id="76556b9aa9b1d76aecac20fd90dee8158aed1fa4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::pthread_t</source>
          <target state="translated">类型定义 std::os::linux::raw::pthread_t</target>
        </trans-unit>
        <trans-unit id="c8140af217e68caacdab8d2aaef2318b6e02ba66" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::time_t</source>
          <target state="translated">类型定义 std::os::linux::raw::time_t</target>
        </trans-unit>
        <trans-unit id="d80e70a5e9f44648db2fa12eba538e96a084706b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_char</source>
          <target state="translated">类型定义 std::os::raw::c_char</target>
        </trans-unit>
        <trans-unit id="47268ec268f5e51266c8c9b25e903a966387595d" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_double</source>
          <target state="translated">类型定义 std::os::raw::c_double</target>
        </trans-unit>
        <trans-unit id="167acfa92657a06bc69cb3f91777f380110e4dc9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_float</source>
          <target state="translated">类型定义 std::os::raw::c_float</target>
        </trans-unit>
        <trans-unit id="c27fd9199e90c2472f965bdc0cca23d6c8c570f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_int</source>
          <target state="translated">类型定义 std::os::raw::c_int</target>
        </trans-unit>
        <trans-unit id="19f693eccac3c497abf741d0f8baed1d19e53f4b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_long</source>
          <target state="translated">类型定义 std::os::raw::c_long</target>
        </trans-unit>
        <trans-unit id="8600d6f2d9a4b023e7037b70faa22dc15e66388f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_longlong</source>
          <target state="translated">类型定义 std::os::raw::c_longlong</target>
        </trans-unit>
        <trans-unit id="38fbb377e146c43dbf57e7ef0b9149de46dd63ee" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_schar</source>
          <target state="translated">类型定义 std::os::raw::c_schar</target>
        </trans-unit>
        <trans-unit id="24f91247eef9f189a56e0d26eb63e94174545d18" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_short</source>
          <target state="translated">类型定义 std::os::raw::c_short</target>
        </trans-unit>
        <trans-unit id="8fd264b0559dbbedb815b835dcd8dc23c60e3e46" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uchar</source>
          <target state="translated">类型定义 std::os::raw::c_uchar</target>
        </trans-unit>
        <trans-unit id="73ae8275dba1734adb8dd3eb79d165dfd8926f8e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uint</source>
          <target state="translated">类型定义 std::os::raw::c_uint</target>
        </trans-unit>
        <trans-unit id="963d890a0fa816ac69f7b2a91122d42f47482af6" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulong</source>
          <target state="translated">类型定义 std::os::raw::c_ulong</target>
        </trans-unit>
        <trans-unit id="9529b81e31c700d29c794b44439c31236befee6e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulonglong</source>
          <target state="translated">类型定义 std::os::raw::c_ulonglong</target>
        </trans-unit>
        <trans-unit id="2add572706fcd5310850bb5c41c263a68becd701" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ushort</source>
          <target state="translated">类型定义 std::os::raw::c_ushort</target>
        </trans-unit>
        <trans-unit id="af576d5699684e5ccc6dd3bdda06f283b79646ba" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::io::RawFd</source>
          <target state="translated">类型定义 std::os::unix::io::RawFd</target>
        </trans-unit>
        <trans-unit id="54df1b972115ebdb7492ee1ec118ad059c5b96b9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blkcnt_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::blkcnt_t</target>
        </trans-unit>
        <trans-unit id="24cf96c7673dcafd447d654adb8e4cf01b30bb6f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blksize_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::blksize_t</target>
        </trans-unit>
        <trans-unit id="27da02afd4df0cefb0f36b07dc40fb05a497c94e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::dev_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::dev_t</target>
        </trans-unit>
        <trans-unit id="73d1317f78cb687f50d63c8e6d4ee01bdba096f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::gid_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::gid_t</target>
        </trans-unit>
        <trans-unit id="f1c61da35b3b5a8948934b0c33b08607e17ab49a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::ino_t</source>
          <target state="translated">类型定义 std::os::unix::raw::ino_t</target>
        </trans-unit>
        <trans-unit id="f57f89ce06fb76c13960558bcf6af72b48025b0a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::mode_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::mode_t</target>
        </trans-unit>
        <trans-unit id="6efe4bc154c56731d72a72033b5e96f1e8e776fa" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::nlink_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::nlink_t</target>
        </trans-unit>
        <trans-unit id="16d41f66ea53de25694ff8008809453896212992" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::off_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::off_t</target>
        </trans-unit>
        <trans-unit id="7fcd1c7c7d47846aeea79e3b67b951552799ecac" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pid_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::pid_t</target>
        </trans-unit>
        <trans-unit id="15394730cd6adf60683b03d0f547388ed732a617" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pthread_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::pthread_t</target>
        </trans-unit>
        <trans-unit id="f5866aac0842b4a721a91364de015f0e36fbc706" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::time_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::time_t</target>
        </trans-unit>
        <trans-unit id="c10ba42310b44320213f70095552a73e406c10bc" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::uid_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::uid_t</target>
        </trans-unit>
        <trans-unit id="ccfd242450d8d8e764c541c183e48c95060db965" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::thread::RawPthread</source>
          <target state="translated">类型 定义 std::os::unix::thread::RawPthread</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
