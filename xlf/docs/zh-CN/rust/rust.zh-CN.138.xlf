<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="0334dcbe551a168678883cc6ef5072f1b77f711d" translate="yes" xml:space="preserve">
          <source>We hinted that this example wouldn&amp;rsquo;t compile. Now let&amp;rsquo;s find out why!</source>
          <target state="translated">我们暗示此示例无法编译。现在让我们找出原因！</target>
        </trans-unit>
        <trans-unit id="1c19907344e59dccc89eee30d7cddf54b21dbd0f" translate="yes" xml:space="preserve">
          <source>We implemented the &lt;code&gt;Iterator&lt;/code&gt; trait by defining the &lt;code&gt;next&lt;/code&gt; method, so we can now use any &lt;code&gt;Iterator&lt;/code&gt; trait method&amp;rsquo;s default implementations as defined in the standard library, because they all use the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s functionality.</source>
          <target state="translated">我们通过定义 &lt;code&gt;next&lt;/code&gt; 方法来实现 &lt;code&gt;Iterator&lt;/code&gt; trait ，因此我们现在可以使用标准库中定义的 &lt;code&gt;Iterator&lt;/code&gt; trait方法的默认实现，因为它们都使用 &lt;code&gt;next&lt;/code&gt; 方法的功能。</target>
        </trans-unit>
        <trans-unit id="0d4561449955c45ad5ebb7f1cf5ff9bb22096f4e" translate="yes" xml:space="preserve">
          <source>We just built a project with &lt;code&gt;cargo build&lt;/code&gt; and ran it with &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt;, but we can also use &lt;code&gt;cargo run&lt;/code&gt; to compile the code and then run the resulting executable all in one command:</source>
          <target state="translated">我们只是使用 &lt;code&gt;cargo build&lt;/code&gt; 构建了一个项目，并使用 &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt; 运行了该项目，但是我们也可以使用 &lt;code&gt;cargo run&lt;/code&gt; 编译代码，然后在一个命令中全部运行生成的可执行文件：</target>
        </trans-unit>
        <trans-unit id="a56bd0b36b29e10cce98f9d35be1f611e5d93adf" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;add&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ae298deaf2e1fd72117ae5b5eb4b47977e9b52" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;offset&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">我们坚持认为 &lt;code&gt;mid&lt;/code&gt; 索引在切片内。然后我们转到不安全的代码： &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 函数采用原始指针和长度，然后创建一个slice。我们使用此功能创建一个从 &lt;code&gt;ptr&lt;/code&gt; 开始且长度为 &lt;code&gt;mid&lt;/code&gt; 项目的切片。然后，我们调用 &lt;code&gt;offset&lt;/code&gt; 的方法 &lt;code&gt;ptr&lt;/code&gt; 与 &lt;code&gt;mid&lt;/code&gt; 作为参数来获得原始指针开始在 &lt;code&gt;mid&lt;/code&gt; ，我们创建一个使用该指针后的剩余数量项目的切片和 &lt;code&gt;mid&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="240382aa15b940fb356b9ed46bfb7832514ebd3d" translate="yes" xml:space="preserve">
          <source>We know we want to define a method, so it will be within the &lt;code&gt;impl Rectangle&lt;/code&gt; block. The method name will be &lt;code&gt;can_hold&lt;/code&gt;, and it will take an immutable borrow of another &lt;code&gt;Rectangle&lt;/code&gt; as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; passes in &lt;code&gt;&amp;amp;rect2&lt;/code&gt;, which is an immutable borrow to &lt;code&gt;rect2&lt;/code&gt;, an instance of &lt;code&gt;Rectangle&lt;/code&gt;. This makes sense because we only need to read &lt;code&gt;rect2&lt;/code&gt; (rather than write, which would mean we&amp;rsquo;d need a mutable borrow), and we want &lt;code&gt;main&lt;/code&gt; to retain ownership of &lt;code&gt;rect2&lt;/code&gt; so we can use it again after calling the &lt;code&gt;can_hold&lt;/code&gt; method. The return value of &lt;code&gt;can_hold&lt;/code&gt; will be a Boolean, and the implementation will check whether the width and height of &lt;code&gt;self&lt;/code&gt; are both greater than the width and height of the other &lt;code&gt;Rectangle&lt;/code&gt;, respectively. Let&amp;rsquo;s add the new &lt;code&gt;can_hold&lt;/code&gt; method to the &lt;code&gt;impl&lt;/code&gt; block from Listing 5-13, shown in Listing 5-15.</source>
          <target state="translated">我们知道我们想定义一个方法，因此它将位于 &lt;code&gt;impl Rectangle&lt;/code&gt; 块内。方法名称将为 &lt;code&gt;can_hold&lt;/code&gt; ，并且它将另一个 &lt;code&gt;Rectangle&lt;/code&gt; 的不可变借位作为参数。通过查看调用该方法的代码，我们可以知道参数的类型： &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; 传入 &lt;code&gt;&amp;amp;rect2&lt;/code&gt; ，这是对 &lt;code&gt;Rectangle&lt;/code&gt; 实例 &lt;code&gt;rect2&lt;/code&gt; 的不可变借用。这是有道理的，因为我们只需要读取 &lt;code&gt;rect2&lt;/code&gt; （而不是写，这意味着我们需要可变的借用），并且我们希望 &lt;code&gt;main&lt;/code&gt; 保留 &lt;code&gt;rect2&lt;/code&gt; 的所有权。因此我们可以在调用 &lt;code&gt;can_hold&lt;/code&gt; 方法之后再次使用它。 &lt;code&gt;can_hold&lt;/code&gt; 的返回值将是一个布尔值，并且实现将检查 &lt;code&gt;self&lt;/code&gt; 的宽度和高度是否分别大于另一个 &lt;code&gt;Rectangle&lt;/code&gt; 的宽度和高度。让我们向清单5-13中的 &lt;code&gt;impl&lt;/code&gt; 块添加新的 &lt;code&gt;can_hold&lt;/code&gt; 方法，如清单5-15所示。</target>
        </trans-unit>
        <trans-unit id="09720690261d856f42ba9e119c7bca4126dc617c" translate="yes" xml:space="preserve">
          <source>We leave the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; fields private so there is no way for external code to add or remove items to the &lt;code&gt;list&lt;/code&gt; field directly; otherwise, the &lt;code&gt;average&lt;/code&gt; field might become out of sync when the &lt;code&gt;list&lt;/code&gt; changes. The &lt;code&gt;average&lt;/code&gt; method returns the value in the &lt;code&gt;average&lt;/code&gt; field, allowing external code to read the &lt;code&gt;average&lt;/code&gt; but not modify it.</source>
          <target state="translated">我们将 &lt;code&gt;list&lt;/code&gt; 字段和 &lt;code&gt;average&lt;/code&gt; 字段保留为私有，因此外部代码无法直接在 &lt;code&gt;list&lt;/code&gt; 字段中添加或删除项目。否则，当 &lt;code&gt;list&lt;/code&gt; 更改时， &lt;code&gt;average&lt;/code&gt; 字段可能会变得不同步。 &amp;ldquo; &lt;code&gt;average&lt;/code&gt; 方法返回&amp;ldquo; &lt;code&gt;average&lt;/code&gt; 字段中的值，从而允许外部代码读取 &lt;code&gt;average&lt;/code&gt; 但不能修改它。</target>
        </trans-unit>
        <trans-unit id="28901e7633295a79506b9862e703f0c9ec5149e8" translate="yes" xml:space="preserve">
          <source>We left a comment in the &lt;code&gt;for&lt;/code&gt; loop in Listing 20-14 regarding the creation of threads. Here, we&amp;rsquo;ll look at how we actually create threads. The standard library provides &lt;code&gt;thread::spawn&lt;/code&gt; as a way to create threads, and &lt;code&gt;thread::spawn&lt;/code&gt; expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them &lt;em&gt;wait&lt;/em&gt; for code that we&amp;rsquo;ll send later. The standard library&amp;rsquo;s implementation of threads doesn&amp;rsquo;t include any way to do that; we have to implement it manually.</source>
          <target state="translated">我们在清单20-14 的 &lt;code&gt;for&lt;/code&gt; 循环中留下了有关线程创建的注释。在这里，我们将了解如何实际创建线程。标准库提供了 &lt;code&gt;thread::spawn&lt;/code&gt; 作为创建线程的一种方式， &lt;code&gt;thread::spawn&lt;/code&gt; 希望获得一些代码，该线程应在创建线程后立即运行。但是，在我们的情况下，我们想要创建线程并让它们&lt;em&gt;等待&lt;/em&gt;稍后将发送的代码。标准库的线程实现不包含任何实现方法。我们必须手动实施。</target>
        </trans-unit>
        <trans-unit id="e917b5faacb8108bac1660ec1b4c362d8a292e12" translate="yes" xml:space="preserve">
          <source>We list the &lt;code&gt;x&lt;/code&gt; value and then just include the &lt;code&gt;..&lt;/code&gt; pattern. This is quicker than having to list &lt;code&gt;y: _&lt;/code&gt; and &lt;code&gt;z: _&lt;/code&gt;, particularly when we&amp;rsquo;re working with structs that have lots of fields in situations where only one or two fields are relevant.</source>
          <target state="translated">我们列出 &lt;code&gt;x&lt;/code&gt; 值，然后只包含 &lt;code&gt;..&lt;/code&gt; 模式。这比必须列出 &lt;code&gt;y: _&lt;/code&gt; 和 &lt;code&gt;z: _&lt;/code&gt; 更快，尤其是当我们在只有一个或两个字段相关的情况下使用具有很多字段的结构时。</target>
        </trans-unit>
        <trans-unit id="1649278ad2d9cbd95d5bb9721993ae2f4d897594" translate="yes" xml:space="preserve">
          <source>We make two threads and change the variable names used with the second thread to &lt;code&gt;handle2&lt;/code&gt; and &lt;code&gt;num2&lt;/code&gt;. When we run the code this time, compiling gives us the following:</source>
          <target state="translated">我们创建两个线程，并将第二个线程使用的变量名称更改为 &lt;code&gt;handle2&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 。这次运行代码时，编译会为我们提供以下内容：</target>
        </trans-unit>
        <trans-unit id="488b1d1d555af27ea61cdda89514b2dfd138dd29" translate="yes" xml:space="preserve">
          <source>We may want to write bytes to a &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; in our production code, but use an in-memory buffer in our tests. We can do this with &lt;code&gt;Cursor&lt;/code&gt;:</source>
          <target state="translated">我们可能想在生产代码中将字节写入&lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，但在测试中使用内存缓冲区。我们可以使用 &lt;code&gt;Cursor&lt;/code&gt; 做到这一点：</target>
        </trans-unit>
        <trans-unit id="42f5297aad6a8bcbbe769864f90a8b8abdf120a8" translate="yes" xml:space="preserve">
          <source>We modify &lt;code&gt;a&lt;/code&gt; so it points to &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;Nil&lt;/code&gt;, creating a cycle. We do that by using the &lt;code&gt;tail&lt;/code&gt; method to get a reference to the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;, which we put in the variable &lt;code&gt;link&lt;/code&gt;. Then we use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; to change the value inside from an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;Nil&lt;/code&gt; value to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">我们修改 &lt;code&gt;a&lt;/code&gt; 使其指向 &lt;code&gt;b&lt;/code&gt; 而不是 &lt;code&gt;Nil&lt;/code&gt; ，从而创建一个循环。我们通过使用 &lt;code&gt;tail&lt;/code&gt; 方法得到的一个参考 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; 中 &lt;code&gt;a&lt;/code&gt; ，我们把在变量 &lt;code&gt;link&lt;/code&gt; 。然后我们使用 &lt;code&gt;borrow_mut&lt;/code&gt; 上所述方法 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; 以从改变的值的内部 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 保持一个 &lt;code&gt;Nil&lt;/code&gt; 值到 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5a434a5fbccadae9667d94aa729d1d78f20bd90" translate="yes" xml:space="preserve">
          <source>We must call the &lt;code&gt;dangerous&lt;/code&gt; function within a separate &lt;code&gt;unsafe&lt;/code&gt; block. If we try to call &lt;code&gt;dangerous&lt;/code&gt; without the &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;ll get an error:</source>
          <target state="translated">我们必须在单独的 &lt;code&gt;unsafe&lt;/code&gt; 块中调用 &lt;code&gt;dangerous&lt;/code&gt; 函数。如果我们在没有 &lt;code&gt;unsafe&lt;/code&gt; 块的情况下尝试调用 &lt;code&gt;dangerous&lt;/code&gt; ，则会收到错误消息：</target>
        </trans-unit>
        <trans-unit id="4fb4c5141c4cfa6ea474c70142cc893715e15a85" translate="yes" xml:space="preserve">
          <source>We need a mock object that, instead of sending an email or text message when we call &lt;code&gt;send&lt;/code&gt;, will only keep track of the messages it&amp;rsquo;s told to send. We can create a new instance of the mock object, create a &lt;code&gt;LimitTracker&lt;/code&gt; that uses the mock object, call the &lt;code&gt;set_value&lt;/code&gt; method on &lt;code&gt;LimitTracker&lt;/code&gt;, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&amp;rsquo;t allow it:</source>
          <target state="translated">我们需要一个模拟对象，该对象不会在调用 &lt;code&gt;send&lt;/code&gt; 时发送电子邮件或短信，而只会跟踪被告知要发送的消息。我们可以创建模拟对象的新实例，创建一个 &lt;code&gt;LimitTracker&lt;/code&gt; 使用模拟对象，调用 &lt;code&gt;set_value&lt;/code&gt; 方法上 &lt;code&gt;LimitTracker&lt;/code&gt; ，然后检查模拟对象有我们预期的消息。清单15-21显示了尝试实现一个模拟对象来实现此目的的尝试，但是借位检查器不允许这样做：</target>
        </trans-unit>
        <trans-unit id="a110963ca04d0182f8c4f733a600767ec4a8c414" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the allocator when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb260a7277d45c34609007ac1f57ba6424e3b7d" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the operating system when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">完成 &lt;code&gt;String&lt;/code&gt; 后，我们需要一种将该内存返回给操作系统的方法。</target>
        </trans-unit>
        <trans-unit id="20e2cb940baac98dfff4c0ce471d1304226840b2" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;code&gt;use&lt;/code&gt; statement to bring &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into scope because it&amp;rsquo;s not in the prelude. In &lt;code&gt;main&lt;/code&gt;, we create the list holding 5 and 10 and store it in a new &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;. Then when we create &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we call the &lt;code&gt;Rc::clone&lt;/code&gt; function and pass a reference to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as an argument.</source>
          <target state="translated">我们需要添加一条 &lt;code&gt;use&lt;/code&gt; 语句将 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 纳入范围，因为它不在序幕中。在 &lt;code&gt;main&lt;/code&gt; ，我们创建列表保持5和10，并将其存储在一个新 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;a&lt;/code&gt; 。然后当我们创建 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ^，我们称之为 &lt;code&gt;Rc::clone&lt;/code&gt; 函数并传递到一个参考 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在 &lt;code&gt;a&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="20a230dc482759cbcb024d662f9a4b5ff8cb7a21" translate="yes" xml:space="preserve">
          <source>We need to add to the code in Listing 9-3 to take different actions depending on the value &lt;code&gt;File::open&lt;/code&gt; returns. Listing 9-4 shows one way to handle the &lt;code&gt;Result&lt;/code&gt; using a basic tool, the &lt;code&gt;match&lt;/code&gt; expression that we discussed in Chapter 6.</source>
          <target state="translated">我们需要添加到清单9-3中的代码中，以根据 &lt;code&gt;File::open&lt;/code&gt; 返回的值执行不同的操作。清单9-4显示了一种使用基本工具（第6章中讨论过的 &lt;code&gt;match&lt;/code&gt; 表达式）处理 &lt;code&gt;Result&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="1a52300a363f54affc64d905b97b32aef73e0083" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9771dc4bdc41f5521988ffa4bcbf0d3c0f959de9" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-24.</source>
          <target state="translated">我们需要调整通道以使用 &lt;code&gt;Message&lt;/code&gt; 类型的值而不是 &lt;code&gt;Job&lt;/code&gt; 类型的代码，如清单20-24所示。</target>
        </trans-unit>
        <trans-unit id="9fe42f06f6df7ac68de2d948fcbea1a3d7286a3b" translate="yes" xml:space="preserve">
          <source>We need to declare the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate as a procedural macro crate. We&amp;rsquo;ll also need functionality from the &lt;code&gt;syn&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; crates, as you&amp;rsquo;ll see in a moment, so we need to add them as dependencies. Add the following to the &lt;em&gt;Cargo.toml&lt;/em&gt; file for &lt;code&gt;hello_macro_derive&lt;/code&gt;:</source>
          <target state="translated">我们需要将 &lt;code&gt;hello_macro_derive&lt;/code&gt; 板条箱声明为程序宏板条箱。正如您稍后会看到的那样，我们还将需要 &lt;code&gt;syn&lt;/code&gt; 和 &lt;code&gt;quote&lt;/code&gt; 板条箱中的功能，因此我们需要将它们添加为依赖项。将以下内容添加到&lt;em&gt;Cargo.toml&lt;/em&gt;文件中，用于 &lt;code&gt;hello_macro_derive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d463764f5c2df75db583b72e63eacc4531621bf0" translate="yes" xml:space="preserve">
          <source>We need to set &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; temporarily rather than setting it directly with code like &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; to get ownership of the &lt;code&gt;state&lt;/code&gt; value. This ensures &lt;code&gt;Post&lt;/code&gt; can&amp;rsquo;t use the old &lt;code&gt;state&lt;/code&gt; value after we&amp;rsquo;ve transformed it into a new state.</source>
          <target state="translated">我们需要暂时将 &lt;code&gt;state&lt;/code&gt; 设置为 &lt;code&gt;None&lt;/code&gt; ,而不是像 &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; 这样的代码直接将其设置为 获得 &lt;code&gt;state&lt;/code&gt; 价值的所有权。这可以确保 &lt;code&gt;Post&lt;/code&gt; 在将其转换为新状态后不能使用旧 &lt;code&gt;state&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="7bc24d658a32bb0bbfec91b13ffff10ee769ddc2" translate="yes" xml:space="preserve">
          <source>We needed &lt;code&gt;clone&lt;/code&gt; here because we have a slice with &lt;code&gt;String&lt;/code&gt; elements in the parameter &lt;code&gt;args&lt;/code&gt;, but the &lt;code&gt;new&lt;/code&gt; function doesn&amp;rsquo;t own &lt;code&gt;args&lt;/code&gt;. To return ownership of a &lt;code&gt;Config&lt;/code&gt; instance, we had to clone the values from the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; fields of &lt;code&gt;Config&lt;/code&gt; so the &lt;code&gt;Config&lt;/code&gt; instance can own its values.</source>
          <target state="translated">我们这里需要 &lt;code&gt;clone&lt;/code&gt; ，因为我们在参数 &lt;code&gt;args&lt;/code&gt; 中有一个包含 &lt;code&gt;String&lt;/code&gt; 元素的切片，但是 &lt;code&gt;new&lt;/code&gt; 函数不拥有 &lt;code&gt;args&lt;/code&gt; 。要返回 &lt;code&gt;Config&lt;/code&gt; 实例的所有权，我们必须从 &lt;code&gt;Config&lt;/code&gt; 的 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 段中克隆值，以便 &lt;code&gt;Config&lt;/code&gt; 实例可以拥有其值。</target>
        </trans-unit>
        <trans-unit id="a43e27dbd35abeb15b38b9262e2f49308a9d38c7" translate="yes" xml:space="preserve">
          <source>We now have a straightforward API that&amp;rsquo;s much harder to mess up, because the compiler will ensure the references into the &lt;code&gt;String&lt;/code&gt; remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn&amp;rsquo;t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of &lt;code&gt;first_word&lt;/code&gt; will throw a compile-time error:</source>
          <target state="translated">现在，我们有了一个简单的API，它很难搞乱，因为编译器将确保对 &lt;code&gt;String&lt;/code&gt; 的引用仍然有效。还记得清单4-8中程序中的错误吗？当我们将索引放在第一个单词的末尾但又清除了字符串，因此索引无效时？该代码在逻辑上是不正确的，但没有立即显示任何错误。如果我们继续尝试将第一个单词索引与空字符串一起使用，问题将在稍后出现。切片使此错误变得不可能，并且让我们知道我们的代码早日有问题。使用 &lt;code&gt;first_word&lt;/code&gt; 的切片版本将引发编译时错误：</target>
        </trans-unit>
        <trans-unit id="c7a58a3bc34ccbe75e8ddbc8d069a47ead8d2749" translate="yes" xml:space="preserve">
          <source>We now have a way to find out the index of the end of the first word in the string, but there&amp;rsquo;s a problem. We&amp;rsquo;re returning a &lt;code&gt;usize&lt;/code&gt; on its own, but it&amp;rsquo;s only a meaningful number in the context of the &lt;code&gt;&amp;amp;String&lt;/code&gt;. In other words, because it&amp;rsquo;s a separate value from the &lt;code&gt;String&lt;/code&gt;, there&amp;rsquo;s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the &lt;code&gt;first_word&lt;/code&gt; function from Listing 4-7.</source>
          <target state="translated">现在，我们有一种方法可以找出字符串中第一个单词的末尾的索引，但这是有问题的。我们将自己返回一个 &lt;code&gt;usize&lt;/code&gt; ，但这在 &lt;code&gt;&amp;amp;String&lt;/code&gt; 的上下文中只是一个有意义的数字。换句话说，因为它是与 &lt;code&gt;String&lt;/code&gt; 分开的值，所以不能保证它在将来仍然有效。考虑清单4-8中的程序，该程序使用清单4-7中的 &lt;code&gt;first_word&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="7c5216021536b3c08541f1af93af0172517e8ef7" translate="yes" xml:space="preserve">
          <source>We now need our &lt;code&gt;Job&lt;/code&gt; type alias to be a &lt;code&gt;Box&lt;/code&gt; of anything that implements our new trait &lt;code&gt;FnBox&lt;/code&gt;. This will allow us to use &lt;code&gt;call_box&lt;/code&gt; in &lt;code&gt;Worker&lt;/code&gt; when we get a &lt;code&gt;Job&lt;/code&gt; value instead of invoking the closure directly. Implementing the &lt;code&gt;FnBox&lt;/code&gt; trait for any &lt;code&gt;FnOnce()&lt;/code&gt; closure means we don&amp;rsquo;t have to change anything about the actual values we&amp;rsquo;re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</source>
          <target state="translated">现在，我们需要 &lt;code&gt;Job&lt;/code&gt; 类型别名为实现了我们新特征 &lt;code&gt;FnBox&lt;/code&gt; 的任何东西的 &lt;code&gt;Box&lt;/code&gt; 。当我们获得 &lt;code&gt;Job&lt;/code&gt; 值时，这将允许我们在 &lt;code&gt;Worker&lt;/code&gt; 中使用 &lt;code&gt;call_box&lt;/code&gt; ，而不是直接调用闭包。为任何 &lt;code&gt;FnOnce()&lt;/code&gt; 闭包实现 &lt;code&gt;FnBox&lt;/code&gt; 特质意味着我们不必更改沿通道发送的实际值的任何内容。现在Rust能够识别出我们想要做的很好。</target>
        </trans-unit>
        <trans-unit id="8583c35b022bb0426f8e6796265e5ae06507a412" translate="yes" xml:space="preserve">
          <source>We pass the value in the &lt;code&gt;case_sensitive&lt;/code&gt; variable to the &lt;code&gt;Config&lt;/code&gt; instance so the &lt;code&gt;run&lt;/code&gt; function can read that value and decide whether to call &lt;code&gt;search&lt;/code&gt; or &lt;code&gt;search_case_insensitive&lt;/code&gt;, as we implemented in Listing 12-22.</source>
          <target state="translated">我们将 &lt;code&gt;case_sensitive&lt;/code&gt; 变量中的值传递给 &lt;code&gt;Config&lt;/code&gt; 实例，以便 &lt;code&gt;run&lt;/code&gt; 函数可以读取该值并决定是调用 &lt;code&gt;search&lt;/code&gt; 还是 &lt;code&gt;search_case_insensitive&lt;/code&gt; ，如清单12-22所示。</target>
        </trans-unit>
        <trans-unit id="278796f5b8837b7d0f28d68d910bc02fc27c0a6a" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;#[should_panic]&lt;/code&gt; attribute after the &lt;code&gt;#[test]&lt;/code&gt; attribute and before the test function it applies to. Let&amp;rsquo;s look at the result when this test passes:</source>
          <target state="translated">我们将 &lt;code&gt;#[should_panic]&lt;/code&gt; 属性放在 &lt;code&gt;#[test]&lt;/code&gt; 属性之后，并将其应用到测试函数之前。让我们看一下测试通过时的结果：</target>
        </trans-unit>
        <trans-unit id="2bba2aa85955f56b33ac81b32d1e3abad3ce51a8" translate="yes" xml:space="preserve">
          <source>We ran a benchmark by loading the entire contents of &lt;em&gt;The Adventures of Sherlock Holmes&lt;/em&gt; by Sir Arthur Conan Doyle into a &lt;code&gt;String&lt;/code&gt; and looking for the word &lt;em&gt;the&lt;/em&gt; in the contents. Here are the results of the benchmark on the version of &lt;code&gt;search&lt;/code&gt; using the &lt;code&gt;for&lt;/code&gt; loop and the version using iterators:</source>
          <target state="translated">我们通过的全部内容加载运行基准&lt;em&gt;冒险史&lt;/em&gt;柯南道尔爵士为 &lt;code&gt;String&lt;/code&gt; ，并寻找这个词&lt;em&gt;的&lt;/em&gt;的内容。以下是使用 &lt;code&gt;for&lt;/code&gt; 循环和使用迭代器的 &lt;code&gt;search&lt;/code&gt; 版本的基准测试结果：</target>
        </trans-unit>
        <trans-unit id="3cb4438c8408ae587f40f74c3ab4a85a10a319c0" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a reference to a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90131aacb69308c853c9e012b87bab3eb99486f" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">我们将这个定义读为： &lt;code&gt;largest&lt;/code&gt; 的函数在某些 &lt;code&gt;T&lt;/code&gt; 类型上是泛型的。此函数有一个名为 &lt;code&gt;list&lt;/code&gt; 的参数，它是 &lt;code&gt;T&lt;/code&gt; 类型的值的一部分。在 &lt;code&gt;largest&lt;/code&gt; 函数将返回相同类型的值 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="147f34652912dc5e1cde73ec0858d227ac63c740" translate="yes" xml:space="preserve">
          <source>We receive the following error:</source>
          <target state="translated">我们收到以下错误信息。</target>
        </trans-unit>
        <trans-unit id="7e8e5c0341d305aaf380fa95376adf0a328c5bce" translate="yes" xml:space="preserve">
          <source>We set the associated &lt;code&gt;Item&lt;/code&gt; type for our iterator to &lt;code&gt;u32&lt;/code&gt;, meaning the iterator will return &lt;code&gt;u32&lt;/code&gt; values. Again, don&amp;rsquo;t worry about associated types yet, we&amp;rsquo;ll cover them in Chapter 19.</source>
          <target state="translated">我们将迭代器的关联 &lt;code&gt;Item&lt;/code&gt; 类型设置为 &lt;code&gt;u32&lt;/code&gt; ，这意味着迭代器将返回 &lt;code&gt;u32&lt;/code&gt; 值。同样，不用担心关联类型，我们将在第19章中介绍它们。</target>
        </trans-unit>
        <trans-unit id="758bab9e4ef6994d52233f0c2648d86ae9d96c9c" translate="yes" xml:space="preserve">
          <source>We set the number of test threads to &lt;code&gt;1&lt;/code&gt;, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won&amp;rsquo;t interfere with each other if they share state.</source>
          <target state="translated">我们将测试线程的数量设置为 &lt;code&gt;1&lt;/code&gt; ，告诉程序不要使用任何并行性。使用一个线程运行测试将比并行运行更长的时间，但是如果测试共享状态，则不会相互干扰。</target>
        </trans-unit>
        <trans-unit id="2570e3bb2400d24bff6a3167e41e4cf75ad5c3a8" translate="yes" xml:space="preserve">
          <source>We should get lines that contain &amp;ldquo;to&amp;rdquo; that might have uppercase letters:</source>
          <target state="translated">我们应该得到包含&amp;ldquo; to&amp;rdquo;的行，其中可能包含大写字母：</target>
        </trans-unit>
        <trans-unit id="8d210a202bdd118dd9e0c3872fbd6277ea746c27" translate="yes" xml:space="preserve">
          <source>We still enable the creation of new posts in the draft state using &lt;code&gt;Post::new&lt;/code&gt; and the ability to add text to the post&amp;rsquo;s content. But instead of having a &lt;code&gt;content&lt;/code&gt; method on a draft post that returns an empty string, we&amp;rsquo;ll make it so draft posts don&amp;rsquo;t have the &lt;code&gt;content&lt;/code&gt; method at all. That way, if we try to get a draft post&amp;rsquo;s content, we&amp;rsquo;ll get a compiler error telling us the method doesn&amp;rsquo;t exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&amp;rsquo;t even compile. Listing 17-19 shows the definition of a &lt;code&gt;Post&lt;/code&gt; struct and a &lt;code&gt;DraftPost&lt;/code&gt; struct, as well as methods on each:</source>
          <target state="translated">我们仍然允许使用 &lt;code&gt;Post::new&lt;/code&gt; 在草稿状态下创建新帖子，并能够在帖子内容中添加文本。但是，我们将使草稿帖子根本不具有 &lt;code&gt;content&lt;/code&gt; 方法，而不是在草稿帖子中使用 &lt;code&gt;content&lt;/code&gt; 方法返回空字符串，而是将其设为空。这样，如果我们尝试获取草稿的内容，则会收到编译器错误，告诉我们该方法不存在。结果，我们不可能在生产中意外显示草稿内容，因为该代码甚至无法编译。清单17-19显示了 &lt;code&gt;Post&lt;/code&gt; 结构和 &lt;code&gt;DraftPost&lt;/code&gt; 结构的定义，以及每个结构的方法：</target>
        </trans-unit>
        <trans-unit id="95a2d58046436515ce7947004a7ac4ae33fbaf9a" translate="yes" xml:space="preserve">
          <source>We still have a &lt;code&gt;Post::new&lt;/code&gt; function, but instead of returning an instance of &lt;code&gt;Post&lt;/code&gt;, it returns an instance of &lt;code&gt;DraftPost&lt;/code&gt;. Because &lt;code&gt;content&lt;/code&gt; is private and there aren&amp;rsquo;t any functions that return &lt;code&gt;Post&lt;/code&gt;, it&amp;rsquo;s not possible to create an instance of &lt;code&gt;Post&lt;/code&gt; right now.</source>
          <target state="translated">我们仍然有一个 &lt;code&gt;Post::new&lt;/code&gt; 函数，但是它没有返回 &lt;code&gt;Post&lt;/code&gt; 的实例，而是返回了 &lt;code&gt;DraftPost&lt;/code&gt; 的实例。因为 &lt;code&gt;content&lt;/code&gt; 是私有的，并且没有任何函数返回 &lt;code&gt;Post&lt;/code&gt; ，所以现在无法创建 &lt;code&gt;Post&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="6a14d4ebb9ad3b731ec935502e9ce7735b1d1739" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and doesn&amp;rsquo;t return a value. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">我们仍然在 &lt;code&gt;FnOnce&lt;/code&gt; 之后使用 &lt;code&gt;()&lt;/code&gt; ，因为该 &lt;code&gt;FnOnce&lt;/code&gt; 表示一个不带参数且不返回值的闭包。就像函数定义一样，可以从签名中省略返回类型，但是即使我们没有参数，我们仍然需要括号。</target>
        </trans-unit>
        <trans-unit id="fb6760fff74f1d2184578db32de57a1297acba15" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and returns the unit type &lt;code&gt;()&lt;/code&gt;. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e44b48751025b1860e023a6de0b5d66e3d099ea" translate="yes" xml:space="preserve">
          <source>We still want to have our program stop running if the unimplemented methods are reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5137b030849ac96f77436fd6551753ef7e79d43f" translate="yes" xml:space="preserve">
          <source>We talked about strings in Chapter 4, but we&amp;rsquo;ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&amp;rsquo;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you&amp;rsquo;re coming from other programming languages.</source>
          <target state="translated">我们在第4章中讨论过字符串，但是现在我们将更深入地研究它们。新的Rustacean通常由于以下三个原因而卡在字符串上：Rust倾向于暴露可能的错误，字符串是比许多程序员认为的更复杂的数据结构以及UTF-8。当您来自其他编程语言时，这些因素的组合似乎很难。</target>
        </trans-unit>
        <trans-unit id="aaadc6667df848db61b7c0773e7ae3fb21446c1d" translate="yes" xml:space="preserve">
          <source>We temporarily print the values of these variables to prove that the code is working as we intend. Let&amp;rsquo;s run this program again with the arguments &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;sample.txt&lt;/code&gt;:</source>
          <target state="translated">我们临时打印这些变量的值，以证明代码按预期工作。让我们再次使用 &lt;code&gt;test&lt;/code&gt; 和 &lt;code&gt;sample.txt&lt;/code&gt; 参数运行该程序：</target>
        </trans-unit>
        <trans-unit id="e19d7657ac4c2d18fdac154ffac8e272b1fa158c" translate="yes" xml:space="preserve">
          <source>We then call the &lt;code&gt;unwrap&lt;/code&gt; method, which we know will never panic, because we know the methods on &lt;code&gt;Post&lt;/code&gt; ensure that &lt;code&gt;state&lt;/code&gt; will always contain a &lt;code&gt;Some&lt;/code&gt; value when those methods are done. This is one of the cases we talked about in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Cases In Which You Have More Information Than the Compiler&amp;rdquo;&lt;/a&gt; section of Chapter 9 when we know that a &lt;code&gt;None&lt;/code&gt; value is never possible, even though the compiler isn&amp;rsquo;t able to understand that.</source>
          <target state="translated">然后我们调用 &lt;code&gt;unwrap&lt;/code&gt; 方法，我们知道它永远不会慌乱，因为我们知道 &lt;code&gt;Post&lt;/code&gt; 方法确保完成这些方法后 &lt;code&gt;state&lt;/code&gt; 始终包含 &lt;code&gt;Some&lt;/code&gt; 值。这是我们在第9章的&lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;需要比编译器提供更多信息的情况&amp;rdquo;&lt;/a&gt;一节中讨论的情况之一，我们知道即使编译器无法理解 &lt;code&gt;None&lt;/code&gt; 值也永远不可能。</target>
        </trans-unit>
        <trans-unit id="90e0dc4d89651b511b21e761c7cecacf78deadb6" translate="yes" xml:space="preserve">
          <source>We then start the macro definition with &lt;code&gt;macro_rules!&lt;/code&gt; and the name of the macro we&amp;rsquo;re defining &lt;em&gt;without&lt;/em&gt; the exclamation mark. The name, in this case &lt;code&gt;vec&lt;/code&gt;, is followed by curly brackets denoting the body of the macro definition.</source>
          <target state="translated">然后，我们从 &lt;code&gt;macro_rules!&lt;/code&gt; 开始宏定义！以及我们定义的&lt;em&gt;不带&lt;/em&gt;感叹号的宏的名称。名称（在本例中为 &lt;code&gt;vec&lt;/code&gt; ）后跟大括号，表示宏定义的正文。</target>
        </trans-unit>
        <trans-unit id="3e635cdf83139712ccc1cd2aa803bc947c37a339" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;ThreadPool::new&lt;/code&gt; to create a new thread pool with a configurable number of threads, in this case four. Then, in the &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;pool.execute&lt;/code&gt; has a similar interface as &lt;code&gt;thread::spawn&lt;/code&gt; in that it takes a closure the pool should run for each stream. We need to implement &lt;code&gt;pool.execute&lt;/code&gt; so it takes the closure and gives it to a thread in the pool to run. This code won&amp;rsquo;t yet compile, but we&amp;rsquo;ll try so the compiler can guide us in how to fix it.</source>
          <target state="translated">我们使用 &lt;code&gt;ThreadPool::new&lt;/code&gt; 来创建一个具有可配置数量的线程的新线程池，在这种情况下为四个。然后，在 &lt;code&gt;for&lt;/code&gt; 循环中， &lt;code&gt;pool.execute&lt;/code&gt; 具有与 &lt;code&gt;thread::spawn&lt;/code&gt; 类似的接口，因为它需要关闭池才能为每个流运行。我们需要实现 &lt;code&gt;pool.execute&lt;/code&gt; ,以便它采取闭包并将其提供给池中的线程来运行。该代码尚未编译，但是我们将尝试使编译器指导我们如何修复它。</target>
        </trans-unit>
        <trans-unit id="00a8575d12353b261846fe413a9059471bbbb3a1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;expect&lt;/code&gt; in the same way as &lt;code&gt;unwrap&lt;/code&gt;: to return the file handle or call the &lt;code&gt;panic!&lt;/code&gt; macro. The error message used by &lt;code&gt;expect&lt;/code&gt; in its call to &lt;code&gt;panic!&lt;/code&gt; will be the parameter that we pass to &lt;code&gt;expect&lt;/code&gt;, rather than the default &lt;code&gt;panic!&lt;/code&gt; message that &lt;code&gt;unwrap&lt;/code&gt; uses. Here&amp;rsquo;s what it looks like:</source>
          <target state="translated">我们用 &lt;code&gt;expect&lt;/code&gt; 的同样的方式 &lt;code&gt;unwrap&lt;/code&gt; ：返回文件句柄或致电 &lt;code&gt;panic!&lt;/code&gt; 宏。 &lt;code&gt;expect&lt;/code&gt; 在 &lt;code&gt;panic!&lt;/code&gt; 使用的错误消息！将是我们传递的 &lt;code&gt;expect&lt;/code&gt; 参数，而不是默认的 &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;unwrap&lt;/code&gt; 使用的消息。看起来是这样的：</target>
        </trans-unit>
        <trans-unit id="c78d1a392741412017cb0bee15d7b3bfa39b4f96" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;if let&lt;/code&gt; rather than &lt;code&gt;unwrap_or_else&lt;/code&gt; to check whether &lt;code&gt;run&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt; value and call &lt;code&gt;process::exit(1)&lt;/code&gt; if it does. The &lt;code&gt;run&lt;/code&gt; function doesn&amp;rsquo;t return a value that we want to &lt;code&gt;unwrap&lt;/code&gt; in the same way that &lt;code&gt;Config::new&lt;/code&gt; returns the &lt;code&gt;Config&lt;/code&gt; instance. Because &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; in the success case, we only care about detecting an error, so we don&amp;rsquo;t need &lt;code&gt;unwrap_or_else&lt;/code&gt; to return the unwrapped value because it would only be &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">我们使用 &lt;code&gt;if let&lt;/code&gt; 而不是 &lt;code&gt;unwrap_or_else&lt;/code&gt; 来检查 &lt;code&gt;run&lt;/code&gt; 是否返回 &lt;code&gt;Err&lt;/code&gt; 值，如果是，则调用 &lt;code&gt;process::exit(1)&lt;/code&gt; 。在 &lt;code&gt;run&lt;/code&gt; 函数不返回一个值，我们要 &lt;code&gt;unwrap&lt;/code&gt; 以同样的方式， &lt;code&gt;Config::new&lt;/code&gt; 收益的 &lt;code&gt;Config&lt;/code&gt; 实例。由于 &lt;code&gt;run&lt;/code&gt; 的回报 &lt;code&gt;()&lt;/code&gt; 在成功的情况下，我们只关心一检测到错误，所以我们不需要 &lt;code&gt;unwrap_or_else&lt;/code&gt; 返回展开的价值，因为它只会是 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ae4452a21a2f1db6f66b2ae014602087da7436" translate="yes" xml:space="preserve">
          <source>We use structs to add meaning by labeling the data. We can transform the tuple we&amp;rsquo;re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</source>
          <target state="translated">我们使用结构通过标记数据来添加含义。我们可以将正在使用的元组转换为具有整体名称和部分名称的数据类型，如清单5-10所示。</target>
        </trans-unit>
        <trans-unit id="588a26e819f938a8daa06969800194e2035e44dd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type when we want to allocate some data on the heap for multiple parts of our program to read and we can&amp;rsquo;t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data&amp;rsquo;s owner, and the normal ownership rules enforced at compile time would take effect.</source>
          <target state="translated">当我们要在堆上分配一些数据以供程序的多个部分读取时，我们使用 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 类型，并且我们无法确定在编译时最后将使用该数据的哪一部分。如果我们知道哪一部分将最后完成，我们可以使该部分成为数据的所有者，并且在编译时强制执行的常规所有权规则将生效。</target>
        </trans-unit>
        <trans-unit id="52b921b4cc68cbe5aa2d7fc1be85a8c378a377ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first call to &lt;code&gt;enumerate&lt;/code&gt; produces the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="translated">我们使用 &lt;code&gt;enumerate&lt;/code&gt; 方法使迭代器适应生成一个值，并将该值在迭代器中的索引放置到元组中。第一次 &lt;code&gt;enumerate&lt;/code&gt; 生成元组 &lt;code&gt;(0, 'a')&lt;/code&gt; 。当此值与模式 &lt;code&gt;(index, value)&lt;/code&gt; 匹配时， &lt;code&gt;index&lt;/code&gt; 将为 &lt;code&gt;0&lt;/code&gt; 且 &lt;code&gt;value&lt;/code&gt; 将为 &lt;code&gt;'a'&lt;/code&gt; ，打印输出的第一行。</target>
        </trans-unit>
        <trans-unit id="4b7fed23abc00c81e6f42de18b1f4486c96308f2" translate="yes" xml:space="preserve">
          <source>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</source>
          <target state="translated">我们使用简写ANYTOKEN来表示所有令牌(包括简单的NT)的集合。例如,如果任何令牌在匹配器M之后都是合法的,那么FOLLOW(M)=ANYTOKEN。</target>
        </trans-unit>
        <trans-unit id="e8b8d2725e3d51d9cd1d2d122943d1410209c3b4" translate="yes" xml:space="preserve">
          <source>We used the &lt;code&gt;# Examples&lt;/code&gt; Markdown heading in Listing 14-1 to create a section in the HTML with the title &amp;ldquo;Examples.&amp;rdquo; Here are some other sections that crate authors commonly use in their documentation:</source>
          <target state="translated">我们使用 &lt;code&gt;# Examples&lt;/code&gt; 清单14-1的降价标题来创建与标题的HTML一节&amp;ldquo;的例子。&amp;rdquo; 这是板条箱作者在其文档中常用的其他部分：</target>
        </trans-unit>
        <trans-unit id="0ef9cc2887d688cae816e0aff37ad262f04c5243" translate="yes" xml:space="preserve">
          <source>We want &lt;code&gt;Cacher&lt;/code&gt; to manage the struct fields&amp;rsquo; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</source>
          <target state="translated">我们希望 &lt;code&gt;Cacher&lt;/code&gt; 管理struct字段的值，而不是让调用代码潜在地直接更改这些字段中的值，因此这些字段是私有的。</target>
        </trans-unit>
        <trans-unit id="343cff43eccaf2ff33fadb37476034c08a669197" translate="yes" xml:space="preserve">
          <source>We want a &lt;code&gt;Node&lt;/code&gt; to own its children, and we want to share that ownership with variables so we can access each &lt;code&gt;Node&lt;/code&gt; in the tree directly. To do this, we define the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; items to be values of type &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt;. We also want to modify which nodes are children of another node, so we have a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;children&lt;/code&gt; around the &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">我们希望一个 &lt;code&gt;Node&lt;/code&gt; 拥有其子节点，并希望与变量共享该所有权，以便我们可以直接访问树中的每个 &lt;code&gt;Node&lt;/code&gt; 。为此，我们将 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 项定义为 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 类型的值。我们还希望修改哪些节点是另一个节点的孩子，所以我们有一个 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;code&gt;children&lt;/code&gt; 周围的 &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efe26c37f1d8e8931b2a537169f33a14c01a5d00" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 5, &lt;code&gt;next&lt;/code&gt; will increment &lt;code&gt;count&lt;/code&gt; and return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;. Once &lt;code&gt;count&lt;/code&gt; is 5, our iterator will stop incrementing &lt;code&gt;count&lt;/code&gt; and always return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d37e81b31729b213fcdf893a4673b004b8c84e" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 6, &lt;code&gt;next&lt;/code&gt; will return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;, but if &lt;code&gt;count&lt;/code&gt; is 6 or higher, our iterator will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">我们希望迭代器将1添加到当前状态，因此我们将 &lt;code&gt;count&lt;/code&gt; 初始化为0，这样它将首先返回1。如果 &lt;code&gt;count&lt;/code&gt; 的值小于6，则 &lt;code&gt;next&lt;/code&gt; 将返回包装在 &lt;code&gt;Some&lt;/code&gt; 中的当前值，但如果 &lt;code&gt;count&lt;/code&gt; 为6或更高，则迭代器将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="159b06d9b1bc3efbb438075384303e9f9ce5bdb3" translate="yes" xml:space="preserve">
          <source>We want our procedural macro to generate an implementation of our &lt;code&gt;HelloMacro&lt;/code&gt; trait for the type the user annotated, which we can get by using &lt;code&gt;#name&lt;/code&gt;. The trait implementation has one function, &lt;code&gt;hello_macro&lt;/code&gt;, whose body contains the functionality we want to provide: printing &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; and then the name of the annotated type.</source>
          <target state="translated">我们希望过程宏为用户注释的类型生成 &lt;code&gt;HelloMacro&lt;/code&gt; 特征的实现，可以使用 &lt;code&gt;#name&lt;/code&gt; 来获取。trait实现有一个函数 &lt;code&gt;hello_macro&lt;/code&gt; ，其主体包含我们要提供的功能：打印 &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; ，然后是注释类型的名字。</target>
        </trans-unit>
        <trans-unit id="dcf36cf58e85676915b970d805c54013d2ad222e" translate="yes" xml:space="preserve">
          <source>We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&amp;rsquo;t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a &lt;code&gt;ThreadPool&lt;/code&gt; struct we want to use instead of &lt;code&gt;thread::spawn&lt;/code&gt;.</source>
          <target state="translated">我们希望线程池以类似的熟悉方式工作，因此从线程切换到线程池不需要对使用我们的API的代码进行大量更改。清单20-12显示了我们要使用的 &lt;code&gt;ThreadPool&lt;/code&gt; 结构而不是 &lt;code&gt;thread::spawn&lt;/code&gt; 的假设接口。</target>
        </trans-unit>
        <trans-unit id="fff17d8c2985947122e61a61d15c1a4da390070a" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;Worker&lt;/code&gt; structs that we just created to fetch code to run from a queue held in the &lt;code&gt;ThreadPool&lt;/code&gt; and send that code to its thread to run.</source>
          <target state="translated">我们希望我们刚创建的 &lt;code&gt;Worker&lt;/code&gt; 结构从 &lt;code&gt;ThreadPool&lt;/code&gt; 保存的队列中获取代码以运行代码，并将该代码发送到其线程中以运行。</target>
        </trans-unit>
        <trans-unit id="131c3dfcc453a4966e031008be09ae09bde292da" translate="yes" xml:space="preserve">
          <source>We want to add a new &lt;code&gt;search_case_insensitive&lt;/code&gt; function that we&amp;rsquo;ll call when the environment variable is on. We&amp;rsquo;ll continue to follow the TDD process, so the first step is again to write a failing test. We&amp;rsquo;ll add a new test for the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function and rename our old test from &lt;code&gt;one_result&lt;/code&gt; to &lt;code&gt;case_sensitive&lt;/code&gt; to clarify the differences between the two tests, as shown in Listing 12-20.</source>
          <target state="translated">我们要添加一个新的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数，当环境变量打开时将调用该函数。我们将继续遵循TDD流程，因此第一步再次是编写失败的测试。我们将为新的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数添加一个新测试，并将旧测试从 &lt;code&gt;one_result&lt;/code&gt; 重命名为 &lt;code&gt;case_sensitive&lt;/code&gt; ,以阐明这两个测试之间的差异，如清单12-20所示。</target>
        </trans-unit>
        <trans-unit id="b16d6b885dbd18ae9ca5b7b63f85be38981add63" translate="yes" xml:space="preserve">
          <source>We want to allow the user to create a new draft blog post with &lt;code&gt;Post::new&lt;/code&gt;. Then we want to allow text to be added to the blog post while it&amp;rsquo;s in the draft state. If we try to get the post&amp;rsquo;s content immediately, before approval, nothing should happen because the post is still a draft. We&amp;rsquo;ve added &lt;code&gt;assert_eq!&lt;/code&gt; in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the &lt;code&gt;content&lt;/code&gt; method, but we&amp;rsquo;re not going to write tests for this example.</source>
          <target state="translated">我们希望允许用户使用 &lt;code&gt;Post::new&lt;/code&gt; 创建新的博客文章草稿。然后，我们希望允许文本处于草稿状态时将其添加到博客中。如果我们尝试立即获得帖子的内容，那么在批准之前，什么都不会发生，因为该帖子仍然是草稿。我们添加了 &lt;code&gt;assert_eq!&lt;/code&gt; 在代码中用于演示目的。一个很好的单元测试就是断言博客文章草案从 &lt;code&gt;content&lt;/code&gt; 方法返回一个空字符串，但是我们不会为这个示例编写测试。</target>
        </trans-unit>
        <trans-unit id="7fed3691de8586ef2849a59c359e563892a4dc4c" translate="yes" xml:space="preserve">
          <source>We want to define code in one place in our program, but only &lt;em&gt;execute&lt;/em&gt; that code where we actually need the result. This is a use case for closures!</source>
          <target state="translated">我们希望在程序中的一个位置定义代码，但是仅在实际需要结果的地方&lt;em&gt;执行&lt;/em&gt;该代码。这是关闭的用例！</target>
        </trans-unit>
        <trans-unit id="d18a25187ad631c5a4e827947adecf2aa147cc32" translate="yes" xml:space="preserve">
          <source>We want to do something with the &lt;code&gt;Some(3)&lt;/code&gt; match but do nothing with any other &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; value or the &lt;code&gt;None&lt;/code&gt; value. To satisfy the &lt;code&gt;match&lt;/code&gt; expression, we have to add &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; after processing just one variant, which is a lot of boilerplate code to add.</source>
          <target state="translated">我们想对 &lt;code&gt;Some(3)&lt;/code&gt; 匹配进行操作，而对其他 &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; 值或 &lt;code&gt;None&lt;/code&gt; 值则不执行任何操作。为了满足 &lt;code&gt;match&lt;/code&gt; 表达式，我们只需要处理一个变体就添加 &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; ，这是要添加的许多样板代码。</target>
        </trans-unit>
        <trans-unit id="dc02dbe447e584d5bc7325caffcd6113884e46a0" translate="yes" xml:space="preserve">
          <source>We want to express the constraint that Foo should not outlive &lt;code&gt;'a&lt;/code&gt;, because the data pointed to by &lt;code&gt;T&lt;/code&gt; is only valid for that lifetime. The problem is that there are no actual uses of &lt;code&gt;'a&lt;/code&gt;. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">我们要表达Foo不应超过 &lt;code&gt;'a&lt;/code&gt; 的约束，因为 &lt;code&gt;T&lt;/code&gt; 指向的数据仅在该生存期内有效。问题是 &lt;code&gt;'a&lt;/code&gt; 没有实际使用。可以通过在结构中添加PhantomData类型来解决此问题，并使用它告诉编译器以该结构包含借用引用 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 的方式进行操作：</target>
        </trans-unit>
        <trans-unit id="8096aefade4c17845a6c208281a849237f1210fa" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; for 'MyStruct', but for some reason it only makes sense to implement the &lt;code&gt;bar()&lt;/code&gt; function. &lt;code&gt;baz()&lt;/code&gt; and &lt;code&gt;qux()&lt;/code&gt; will still need to be defined in our implementation of &lt;code&gt;Foo&lt;/code&gt;, but we can use &lt;code&gt;unimplemented!&lt;/code&gt; in their definitions to allow our code to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f35ebffd6903da931ba226fd712a56dd80d9" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;todo!&lt;/code&gt;:</source>
          <target state="translated">我们想对其中一种类型实现 &lt;code&gt;Foo&lt;/code&gt; ，但我们也想先对 &lt;code&gt;bar()&lt;/code&gt; 进行操作。为了编译我们的代码，我们需要实现 &lt;code&gt;baz()&lt;/code&gt; ，所以我们可以使用 &lt;code&gt;todo!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56425053366a107f9b4c0d5cead1a47581ce32c6" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;unimplemented!&lt;/code&gt;:</source>
          <target state="translated">我们想对其中一种类型实现 &lt;code&gt;Foo&lt;/code&gt; ，但我们也想先对 &lt;code&gt;bar()&lt;/code&gt; 进行操作。为了使我们的代码编译，我们需要实现 &lt;code&gt;baz()&lt;/code&gt; ，因此我们可以使用 &lt;code&gt;unimplemented!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2603349a6514abb34f4d8e302a6f486604d53289" translate="yes" xml:space="preserve">
          <source>We want to make a media aggregator library that can display summaries of data that might be stored in a &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt; instance. To do this, we need a summary from each type, and we need to request that summary by calling a &lt;code&gt;summarize&lt;/code&gt; method on an instance. Listing 10-12 shows the definition of a &lt;code&gt;Summary&lt;/code&gt; trait that expresses this behavior.</source>
          <target state="translated">我们想要制作一个媒体聚合器库，以显示可能存储在 &lt;code&gt;NewsArticle&lt;/code&gt; 或 &lt;code&gt;Tweet&lt;/code&gt; 实例中的数据摘要。要做到这一点，我们需要从各个类型的总结，我们需要通过调用来请求总结 &lt;code&gt;summarize&lt;/code&gt; 上一个实例方法。清单10-12显示了表达此行为的 &lt;code&gt;Summary&lt;/code&gt; 特性的定义。</target>
        </trans-unit>
        <trans-unit id="c43cd68edbbfd1b8e1512d94b1171eea5afef79e" translate="yes" xml:space="preserve">
          <source>We want to require that types of consts used in pattern matches have the attribute &lt;code&gt;#[derive(PartialEq, Eq)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad91bce07f001635901cf680ab9baa3e439ca352" translate="yes" xml:space="preserve">
          <source>We welcome contributions of all kinds.</source>
          <target state="translated">我们欢迎各种形式的贡献。</target>
        </trans-unit>
        <trans-unit id="23a6529743bec69716fd57e6fc32983956eb0107" translate="yes" xml:space="preserve">
          <source>We will tend to use the variable &quot;M&quot; to stand for a matcher, variables &quot;t&quot; and &quot;u&quot; for arbitrary individual tokens, and the variables &quot;tt&quot; and &quot;uu&quot; for arbitrary token trees. (The use of &quot;tt&quot; does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</source>
          <target state="translated">我们倾向于用变量 &quot;M &quot;代表匹配器,用变量 &quot;t &quot;和 &quot;u &quot;代表任意的单个标记,用变量 &quot;tt &quot;和 &quot;uu &quot;代表任意的标记树(使用 &quot;tt &quot;确实会带来潜在的歧义,因为它的额外作用是作为一个片段指定符;但从上下文中可以清楚地看出是指哪种解释)。</target>
        </trans-unit>
        <trans-unit id="83ee5c69c56907ebdffff8aeb268f380fd8205ee" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can&amp;rsquo;t know and define all the types other programmers might want to create. But we do know that &lt;code&gt;gui&lt;/code&gt; needs to keep track of many values of different types, and it needs to call a &lt;code&gt;draw&lt;/code&gt; method on each of these differently typed values. It doesn&amp;rsquo;t need to know exactly what will happen when we call the &lt;code&gt;draw&lt;/code&gt; method, just that the value will have that method available for us to call.</source>
          <target state="translated">在此示例中，我们不会实现完整的GUI库，但会显示各个部分如何组合在一起。在编写库时，我们无法知道和定义其他程序员可能想要创建的所有类型。但是我们确实知道 &lt;code&gt;gui&lt;/code&gt; 需要跟踪许多不同类型的值，并且需要对这些不同类型的值中的每一个调用 &lt;code&gt;draw&lt;/code&gt; 方法。不必确切知道调用 &lt;code&gt;draw&lt;/code&gt; 方法时会发生什么，只需知道值将具有可供我们调用的方法即可。</target>
        </trans-unit>
        <trans-unit id="d21a898dd719bc6dce095fa6d8b7f4dd1c97ae10" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t see any output to the terminal, and &lt;em&gt;output.txt&lt;/em&gt; will contain our results:</source>
          <target state="translated">我们不会在终端看到任何输出，并且&lt;em&gt;output.txt&lt;/em&gt;将包含我们的结果：</target>
        </trans-unit>
        <trans-unit id="1bcf0abfb9f5d1eb6eceeb8401331a69bbdacdc8" translate="yes" xml:space="preserve">
          <source>We would get this error:</source>
          <target state="translated">我们会得到这个错误。</target>
        </trans-unit>
        <trans-unit id="5622bdba3c15431adc562635e894da31c4a2b58c" translate="yes" xml:space="preserve">
          <source>We wrap the list &lt;code&gt;a&lt;/code&gt; in an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; so when we create lists &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, they can both refer to &lt;code&gt;a&lt;/code&gt;, which is what we did in Listing 15-18.</source>
          <target state="translated">我们将列表 &lt;code&gt;a&lt;/code&gt; 包装在 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 因此当创建列表 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 时，它们都可以引用 &lt;code&gt;a&lt;/code&gt; ，这是清单15-18中所做的。</target>
        </trans-unit>
        <trans-unit id="e8c8515d512bf806d32faac4f020e79d1b4ea0b5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also briefly introduce closures, iterators, and trait objects, which Chapters &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; and &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; will cover in detail.</source>
          <target state="translated">我们还将简要介绍倒闭，迭代器和特质的对象，这章&lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt;和&lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt;我们会详细讨论。</target>
        </trans-unit>
        <trans-unit id="bd0d703fb6da707b1fe1894466f6416db96a6796" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll change the start of the &lt;code&gt;main&lt;/code&gt; function that we had in Listing 12-24 to the code in Listing 13-25. This won&amp;rsquo;t compile until we update &lt;code&gt;Config::new&lt;/code&gt; as well.</source>
          <target state="translated">我们将清单12-24 中的 &lt;code&gt;main&lt;/code&gt; 函数的开始更改为清单13-25中的代码。在我们也更新 &lt;code&gt;Config::new&lt;/code&gt; 之前，它不会编译。</target>
        </trans-unit>
        <trans-unit id="d3116613c32b066db53048929e2f72dcbc32c305" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll check for errors and handle them using a technique similar to one we used with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-10, but with a slight difference:</source>
          <target state="translated">我们将检查错误并使用与清单12-10中的 &lt;code&gt;Config::new&lt;/code&gt; 相似的技术来处理错误，但略有不同：</target>
        </trans-unit>
        <trans-unit id="d62b197067e3536d1071880b59f256af5edc6238" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll come back to &lt;code&gt;panic!&lt;/code&gt; and when we should and should not use &lt;code&gt;panic!&lt;/code&gt; to handle error conditions in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section later in this chapter. Next, we&amp;rsquo;ll look at how to recover from an error using &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">我们会 &lt;code&gt;panic!&lt;/code&gt; 以及何时应该和不应该使用 &lt;code&gt;panic!&lt;/code&gt; 处理&lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo; &lt;code&gt;panic!&lt;/code&gt; 还是不要 &lt;code&gt;panic!&lt;/code&gt; &amp;rdquo;&lt;/a&gt;稍后部分节。接下来，我们将研究如何使用 &lt;code&gt;Result&lt;/code&gt; 从错误中恢复。</target>
        </trans-unit>
        <trans-unit id="7c361948b72916d443c2a8639e53ba761429344f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue to get warnings because we aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">我们将继续收到警告，因为我们对 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;execute&lt;/code&gt; 的参数没有做任何事情。让我们以所需的行为实现这些函数的主体。首先，让我们考虑一下 &lt;code&gt;new&lt;/code&gt; 。之前我们为 &lt;code&gt;size&lt;/code&gt; 参数选择了无符号类型，因为线程数为负的池没有意义。但是，具有零线程的池也没有意义，但是零是一个完全有效的 &lt;code&gt;usize&lt;/code&gt; 。我们将添加代码以检查 &lt;code&gt;size&lt;/code&gt; 是否大于零，然后再返回 &lt;code&gt;ThreadPool&lt;/code&gt; 实例，并通过 &lt;code&gt;assert!&lt;/code&gt; 使程序惊慌（如果它收到零）！宏，如清单20-13所示。</target>
        </trans-unit>
        <trans-unit id="51ae0f2c48f47ac8366f3fdf37d10c87f351ab8e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a new &lt;code&gt;Job&lt;/code&gt; struct that will hold the closures we want to send down the channel.</source>
          <target state="translated">我们将创建一个新的 &lt;code&gt;Job&lt;/code&gt; 结构，该结构将保存我们要沿通道发送的闭包。</target>
        </trans-unit>
        <trans-unit id="4bb83dcab86b4aa0381b060ab157833722eb2537" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create list &lt;code&gt;a&lt;/code&gt; that contains 5 and then 10. Then we&amp;rsquo;ll make two more lists: &lt;code&gt;b&lt;/code&gt; that starts with 3 and &lt;code&gt;c&lt;/code&gt; that starts with 4. Both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; lists will then continue on to the first &lt;code&gt;a&lt;/code&gt; list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</source>
          <target state="translated">我们将创建 &lt;code&gt;a&lt;/code&gt; 包含5和10的列表a，然后再创建两个列表： &lt;code&gt;b&lt;/code&gt; 以3开头， &lt;code&gt;c&lt;/code&gt; 以4开头 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 列表都将继续到第 &lt;code&gt;a&lt;/code&gt; 包含5 的列表。和10。换句话说，两个列表将共享包含5和10的第一个列表。</target>
        </trans-unit>
        <trans-unit id="fa20d8056fa921c697f37302e71e0fe1ecb7bea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll define the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; to take a closure as a parameter. Recall from the &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;Storing Closures Using Generic Parameters and the &lt;code&gt;Fn&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 13 that we can take closures as parameters with three different traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;. We need to decide which kind of closure to use here. We know we&amp;rsquo;ll end up doing something similar to the standard library &lt;code&gt;thread::spawn&lt;/code&gt; implementation, so we can look at what bounds the signature of &lt;code&gt;thread::spawn&lt;/code&gt; has on its parameter. The documentation shows us the following:</source>
          <target state="translated">我们将在 &lt;code&gt;ThreadPool&lt;/code&gt; 上定义 &lt;code&gt;execute&lt;/code&gt; 方法，以将闭包作为参数。回想一下第13章的&lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;使用通用参数和&lt;/a&gt; &lt;code&gt;Fn&lt;/code&gt; 特性存储闭包&amp;rdquo;，我们可以将闭包作为具有三个不同特征的参数： &lt;code&gt;Fn&lt;/code&gt; ， &lt;code&gt;FnMut&lt;/code&gt; 和 &lt;code&gt;FnOnce&lt;/code&gt; 。我们需要决定在这里使用哪种闭包。我们知道我们最终将执行与标准库 &lt;code&gt;thread::spawn&lt;/code&gt; 实现类似的操作，因此我们可以查看 &lt;code&gt;thread::spawn&lt;/code&gt; 的签名在其参数上的界限。该文档向我们显示了以下内容：</target>
        </trans-unit>
        <trans-unit id="a2fdbbe18f87451459f008e457c7a300c4999cac" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate the first situation in the &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;Enabling Recursive Types with Boxes&amp;rdquo;&lt;/a&gt; section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a &lt;em&gt;trait object&lt;/em&gt;, and Chapter 17 devotes an entire section, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types,&amp;rdquo;&lt;/a&gt; just to that topic. So what you learn here you&amp;rsquo;ll apply again in Chapter 17!</source>
          <target state="translated">我们将在&lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;使用框启用递归类型&amp;rdquo;&lt;/a&gt;部分中演示第一种情况。在第二种情况下，转移大量数据的所有权可能会花费很长时间，因为数据是在堆栈上四处复制的。为了在这种情况下提高性能，我们可以将大量数据存储在一个盒子中的堆中。然后，只有少量的指针数据被复制到堆栈中，而它所引用的数据则保留在堆中的某个位置。第三种情况称为&lt;em&gt;特质对象&lt;/em&gt;，第17章专门针对该主题专门讨论了&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;使用允许使用不同类型的值的特性对象&amp;rdquo;这一&lt;/a&gt;节。因此，您在这里学到的内容将在第17章中再次应用！</target>
        </trans-unit>
        <trans-unit id="deceb660af9d289cbab49d701f06e3ffa29f7fd4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.</source>
          <target state="translated">我们将讨论如何创建和更新向量，字符串和哈希图，以及使每个特征与众不同的地方。</target>
        </trans-unit>
        <trans-unit id="8ac89a220719114fba008017ccc516ce2a635466" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss iterators in more detail in Chapter 13. For now, know that &lt;code&gt;iter&lt;/code&gt; is a method that returns each element in a collection and that &lt;code&gt;enumerate&lt;/code&gt; wraps the result of &lt;code&gt;iter&lt;/code&gt; and returns each element as part of a tuple instead. The first element of the tuple returned from &lt;code&gt;enumerate&lt;/code&gt; is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.</source>
          <target state="translated">我们将在第13章中更详细地讨论迭代器。现在，知道 &lt;code&gt;iter&lt;/code&gt; 是一种返回集合中每个元素的方法，该方法 &lt;code&gt;enumerate&lt;/code&gt; 包装 &lt;code&gt;iter&lt;/code&gt; 的结果并将每个元素返回为元组的一部分。从 &lt;code&gt;enumerate&lt;/code&gt; 返回的元组的第一个元素是索引，第二个元素是对该元素的引用。这比自己计算索引要方便一些。</target>
        </trans-unit>
        <trans-unit id="624f79a35ccc7ff9109a384a1f2001d1a19900e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore some aspects of how tests work by experimenting with the template test generated for us without actually testing any code. Then we&amp;rsquo;ll write some real-world tests that call some code that we&amp;rsquo;ve written and assert that its behavior is correct.</source>
          <target state="translated">我们将通过试验为我们生成的模板测试而不实际测试任何代码来探索测试工作方式的某些方面。然后，我们将编写一些真实的测试，这些测试将调用我们编写的某些代码，并断言其行为是正确的。</target>
        </trans-unit>
        <trans-unit id="2bdd67fc360b4185f7483b213b4f01b862aebe2c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll extract the functionality for parsing arguments into a function that &lt;code&gt;main&lt;/code&gt; will call to prepare for moving the command line parsing logic to &lt;em&gt;src/lib.rs&lt;/em&gt;. Listing 12-5 shows the new start of &lt;code&gt;main&lt;/code&gt; that calls a new function &lt;code&gt;parse_config&lt;/code&gt;, which we&amp;rsquo;ll define in &lt;em&gt;src/main.rs&lt;/em&gt; for the moment.</source>
          <target state="translated">我们将解析参数成函数提取的功能 &lt;code&gt;main&lt;/code&gt; 会调用到移动命令行解析逻辑准备&lt;em&gt;的src / lib.rs&lt;/em&gt;。清单12-5显示了 &lt;code&gt;main&lt;/code&gt; 的新起点，它调用了一个新函数 &lt;code&gt;parse_config&lt;/code&gt; ，我们现在将在&lt;em&gt;src / main.rs中&lt;/em&gt;定义该函数。</target>
        </trans-unit>
        <trans-unit id="e88c3b3a979bcfce4b1760b46e6bdec4b2d5837b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first define what we mean by the term &lt;em&gt;string&lt;/em&gt;. Rust has only one string type in the core language, which is the string slice &lt;code&gt;str&lt;/code&gt; that is usually seen in its borrowed form &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Chapter 4, we talked about &lt;em&gt;string slices&lt;/em&gt;, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program&amp;rsquo;s binary and are therefore string slices.</source>
          <target state="translated">我们将首先定义术语&lt;em&gt;字符串&lt;/em&gt;的含义。Rust在核心语言中只有一种字符串类型，即字符串切片 &lt;code&gt;str&lt;/code&gt; ，通常以借用形式 &lt;code&gt;&amp;amp;str&lt;/code&gt; 看到。在第4章中，我们讨论了&lt;em&gt;字符串切片&lt;/em&gt;，它是对存储在其他位置的一些UTF-8编码的字符串数据的引用。例如，字符串文字存储在程序的二进制文件中，因此是字符串切片。</target>
        </trans-unit>
        <trans-unit id="e0a42ef337f81f469e74c07a4e57681998929bd2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll get this error because &lt;code&gt;String&lt;/code&gt; doesn&amp;rsquo;t implement the &lt;code&gt;Draw&lt;/code&gt; trait:</source>
          <target state="translated">我们将收到此错误，因为 &lt;code&gt;String&lt;/code&gt; 没有实现 &lt;code&gt;Draw&lt;/code&gt; 特性：</target>
        </trans-unit>
        <trans-unit id="d5a20f154a16497d1d3eb9e39d468647563e6985" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; by the standard library. As always, check the standard library documentation for more information.</source>
          <target state="translated">在本节中，我们将介绍散列图的基本API，但是标准库在 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 上定义的函数中隐藏了更多东西。与往常一样，请查阅标准库文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="eac18c8869068094c6cd67d1df8b09a6dcd85f58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll have more examples of &lt;code&gt;move&lt;/code&gt; closures in Chapter 16 when we talk about concurrency. For now, here&amp;rsquo;s the code from Listing 13-12 with the &lt;code&gt;move&lt;/code&gt; keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</source>
          <target state="translated">在谈到并发时，我们 &lt;code&gt;move&lt;/code&gt; 在第16章中有更多关于移动关闭的示例。现在，这是清单13-12中的代码，在闭包定义中添加了 &lt;code&gt;move&lt;/code&gt; 关键字，并使用了矢量而不是整数，因为可以复制而不是移动整数；请注意，此代码尚未编译。</target>
        </trans-unit>
        <trans-unit id="45660693e231ee73bb1364738b13ef0ef0f19408" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a blog post workflow in an incremental way. The blog&amp;rsquo;s final functionality will look like this:</source>
          <target state="translated">我们将以增量方式实施博客文章工作流程。该博客的最终功能如下所示：</target>
        </trans-unit>
        <trans-unit id="13ede53dc0201795dcdc26b0b93f397bb66c964d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a classic beginner programming problem: a guessing game. Here&amp;rsquo;s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</source>
          <target state="translated">我们将实现一个经典的初学者编程问题：一个猜谜游戏。它是这样工作的：程序将生成一个介于1到100之间的随机整数。然后它将提示玩家输入一个猜测。输入猜测之后，程序将指示猜测是太低还是太高。如果猜测正确，游戏将显示祝贺消息并退出。</target>
        </trans-unit>
        <trans-unit id="048db9a1a62206761ce5925145fa53461a07bbf2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement this behavior by introducing a new data structure between the &lt;code&gt;ThreadPool&lt;/code&gt; and the threads that will manage this new behavior. We&amp;rsquo;ll call this data structure &lt;code&gt;Worker&lt;/code&gt;, which is a common term in pooling implementations. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&amp;rsquo;re responsible for taking those orders and filling them.</source>
          <target state="translated">我们将通过在 &lt;code&gt;ThreadPool&lt;/code&gt; 和将管理此新行为的线程之间引入新的数据结构来实现此行为。我们将这种数据结构称为 &lt;code&gt;Worker&lt;/code&gt; ，这是池实现中的常用术语。想一想在餐厅里的厨房里工作的人：工人等到顾客下订单，然后他们负责接下这些订单并填写订单。</target>
        </trans-unit>
        <trans-unit id="3d83967911dd3c9768c9078b0f1f0230b11c5179" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</source>
          <target state="translated">我们将通过添加一个附加功能来改进 &lt;code&gt;minigrep&lt;/code&gt; ：用户可以通过环境变量打开的不区分大小写搜索选项。我们可以将此功能设置为命令行选项，并要求用户在每次希望应用该功能时都输入该功能，但是我们将使用环境变量。这样做使我们的用户可以一次设置环境变量，并使所有搜索在该终端会话中不区分大小写。</target>
        </trans-unit>
        <trans-unit id="d68f5d386409006cd90ddd8d3bb0c58cf3c62419" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll leave the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; as is, returning an empty string slice. We can now have a &lt;code&gt;Post&lt;/code&gt; in the &lt;code&gt;PendingReview&lt;/code&gt; state as well as in the &lt;code&gt;Draft&lt;/code&gt; state, but we want the same behavior in the &lt;code&gt;PendingReview&lt;/code&gt; state. Listing 17-11 now works up to line 10!</source>
          <target state="translated">我们将 &lt;code&gt;content&lt;/code&gt; 方法保留在 &lt;code&gt;Post&lt;/code&gt; 上，返回一个空字符串切片。现在，我们可以在 &lt;code&gt;PendingReview&lt;/code&gt; 状态和 &lt;code&gt;Draft&lt;/code&gt; 状态下都有一个 &lt;code&gt;Post&lt;/code&gt; ，但是我们希望在 &lt;code&gt;PendingReview&lt;/code&gt; 状态下具有相同的行为。清单17-11现在可以处理第10行！</target>
        </trans-unit>
        <trans-unit id="d54b9a4076624177fb35b9a3dd76036387ec23ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&amp;rsquo;s resources and grinding the processing of requests to a halt.</source>
          <target state="translated">我们将池中的线程数限制为一小部分，以保护我们免受拒绝服务（DoS）攻击；如果我们让程序为传入的每个请求创建一个新线程，那么向服务器发出1000万个请求的人可能会由于耗尽服务器的所有资源并停止处理请求而造成破坏。</target>
        </trans-unit>
        <trans-unit id="c71f00103a62f0c5845aebe33e418eb38eb04404" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to &lt;em&gt;/sleep&lt;/em&gt; with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</source>
          <target state="translated">我们将研究处理缓慢的请求如何影响对当前服务器实现的其他请求。清单20-10实现了使用模拟的慢响应来处理&lt;em&gt;/ sleep&lt;/em&gt;的请求，这将导致服务器在响应之前休眠5秒钟。</target>
        </trans-unit>
        <trans-unit id="63d0e1907454ce3a168d379fb233f059e45940b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll receive an error because the &lt;code&gt;s&lt;/code&gt; value will still be moved into &lt;code&gt;_s&lt;/code&gt;, which prevents us from using &lt;code&gt;s&lt;/code&gt; again. However, using the underscore by itself doesn&amp;rsquo;t ever bind to the value. Listing 18-22 will compile without any errors because &lt;code&gt;s&lt;/code&gt; doesn&amp;rsquo;t get moved into &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">我们将收到一个错误消息，因为 &lt;code&gt;s&lt;/code&gt; 值仍将移至 &lt;code&gt;_s&lt;/code&gt; ，这将阻止我们再次使用 &lt;code&gt;s&lt;/code&gt; 。但是，仅使用下划线不会绑定到该值。清单18-22将编译而没有任何错误，因为 &lt;code&gt;s&lt;/code&gt; 不会移入 &lt;code&gt;_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61f9110a68d84478cf97fc80e4e62fe2b389965b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll round out this chapter by talking about the &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits and how we can use them with custom types.</source>
          <target state="translated">在本章中，我们将讨论&amp;ldquo; &lt;code&gt;Send&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Sync&lt;/code&gt; 特征以及如何将其与自定义类型一起使用。</target>
        </trans-unit>
        <trans-unit id="b07b0f8b9fff1c6b7489d1f03bbaf11c53f92f25" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&amp;rsquo;ll encode the states into different types. Consequently, Rust&amp;rsquo;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</source>
          <target state="translated">我们将向您展示如何重新思考状态模式以获得一组不同的权衡。与其完全封装状态和转换，以使外部代码不了解它们，我们将状态编码为不同的类型。因此，Rust的类型检查系统将通过发出编译器错误来阻止尝试使用仅允许发布的帖子的草稿帖子。</target>
        </trans-unit>
        <trans-unit id="627b700f2567a428c4b498681919e2e69479fc97" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll simulate calling this hypothetical algorithm with the function &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; shown in Listing 13-1, which will print &lt;code&gt;calculating slowly...&lt;/code&gt;, wait for two seconds, and then return whatever number we passed in.</source>
          <target state="translated">我们将使用清单13-1中所示的函数 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 模拟调用此假设算法，该函数将 &lt;code&gt;calculating slowly...&lt;/code&gt; 打印出...，等待两秒钟，然后返回传入的任何数字。</target>
        </trans-unit>
        <trans-unit id="5973b041f6a9740c7e6d85ca07367dbed50852e0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by getting a single-threaded web server working. Before we begin, let&amp;rsquo;s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</source>
          <target state="translated">我们将从使单线程Web服务器开始工作开始。在开始之前，让我们快速了解构建Web服务器所涉及的协议。这些协议的详细信息超出了本书的范围，但是简要概述将为您提供所需的信息。</target>
        </trans-unit>
        <trans-unit id="060170101757c33938356030dc05849b3282e228" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about each of these in turn, but first, let&amp;rsquo;s look at why we even need macros when we already have functions.</source>
          <target state="translated">我们将依次讨论它们中的每一个，但首先，让我们看一下为什么我们已经有了函数时为什么甚至需要宏。</target>
        </trans-unit>
        <trans-unit id="00042b704a4af242dc3eb83d8f9f0adbd9c9c6f2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We&amp;rsquo;ll add this functionality in a function called &lt;code&gt;search&lt;/code&gt;.</source>
          <target state="translated">我们将测试驱动该功能的实现，该功能实际上将在文件内容中搜索查询字符串并生成与查询匹配的行列表。我们将在称为 &lt;code&gt;search&lt;/code&gt; 的函数中添加此功能。</target>
        </trans-unit>
        <trans-unit id="a6a5b07486e18e4aafc4b7efa3b6df52895ecfa1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">我们在这里以 &lt;code&gt;String&lt;/code&gt; 为例，并专注于与所有权有关的 &lt;code&gt;String&lt;/code&gt; 部分。这些方面也适用于标准库提供的以及您创建的其他复杂数据类型。我们将在第8章中更深入地讨论 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f26df7e74655da28655e14a9fc6315701535f09" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdb67ce55cd6e4b067c62180346b3dbc3180259" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, &lt;code&gt;main&lt;/code&gt;. The standard library provides the &lt;code&gt;eprintln!&lt;/code&gt; macro that prints to the standard error stream, so let&amp;rsquo;s change the two places we were calling &lt;code&gt;println!&lt;/code&gt; to print errors to use &lt;code&gt;eprintln!&lt;/code&gt; instead.</source>
          <target state="translated">我们将使用清单12-24中的代码来更改错误消息的打印方式。由于我们在本章前面已经进行了重构，所有打印错误消息的代码都在一个函数 &lt;code&gt;main&lt;/code&gt; 中。标准库提供了 &lt;code&gt;eprintln!&lt;/code&gt; 打印到标准错误流的宏，所以让我们更改我们调用 &lt;code&gt;println!&lt;/code&gt; 的两个位置！打印错误以使用 &lt;code&gt;eprintln!&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="7be7c248999b3ea861a86839bb6847251beded8a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re allowed to change the value that &lt;code&gt;x&lt;/code&gt; binds to from &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; when &lt;code&gt;mut&lt;/code&gt; is used. In some cases, you&amp;rsquo;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</source>
          <target state="translated">使用 &lt;code&gt;mut&lt;/code&gt; 时，我们可以将 &lt;code&gt;x&lt;/code&gt; 绑定的值从 &lt;code&gt;5&lt;/code&gt; 更改为 &lt;code&gt;6&lt;/code&gt; 。在某些情况下，您将希望使变量可变，因为与仅具有不可变变量的情况相比，它使代码的编写更加方便。</target>
        </trans-unit>
        <trans-unit id="85a800cd9f89b371e568b4c783baa80e895e6025" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re creating an &lt;code&gt;IpAddr&lt;/code&gt; instance by parsing a hardcoded string. We can see that &lt;code&gt;127.0.0.1&lt;/code&gt; is a valid IP address, so it&amp;rsquo;s acceptable to use &lt;code&gt;unwrap&lt;/code&gt; here. However, having a hardcoded, valid string doesn&amp;rsquo;t change the return type of the &lt;code&gt;parse&lt;/code&gt; method: we still get a &lt;code&gt;Result&lt;/code&gt; value, and the compiler will still make us handle the &lt;code&gt;Result&lt;/code&gt; as if the &lt;code&gt;Err&lt;/code&gt; variant is a possibility because the compiler isn&amp;rsquo;t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore &lt;em&gt;did&lt;/em&gt; have a possibility of failure, we&amp;rsquo;d definitely want to handle the &lt;code&gt;Result&lt;/code&gt; in a more robust way instead.</source>
          <target state="translated">我们通过解析硬编码字符串来创建 &lt;code&gt;IpAddr&lt;/code&gt; 实例。我们可以看到 &lt;code&gt;127.0.0.1&lt;/code&gt; 是有效的IP地址，因此在这里使用 &lt;code&gt;unwrap&lt;/code&gt; 是可以接受的。但是，使用经过硬编码的有效字符串不会更改 &lt;code&gt;parse&lt;/code&gt; 方法的返回类型：我们仍然会获得 &lt;code&gt;Result&lt;/code&gt; 值，并且编译器仍将使我们像 &lt;code&gt;Err&lt;/code&gt; 变体一样处理 &lt;code&gt;Result&lt;/code&gt; ，因为编译器不是。足够聪明，可以看到此字符串始终是有效的IP地址。如果IP地址字符串来自用户而不是硬编码到程序中，因此&lt;em&gt;确实&lt;/em&gt;有失败的可能，我们肯定希望处理&lt;em&gt;&lt;/em&gt; &lt;code&gt;Result&lt;/code&gt; 而是以更可靠的方式得到结果。</target>
        </trans-unit>
        <trans-unit id="7a98461520cf94e325231f61b61fe6b7361a4963" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re getting into more complex programs in which operations can fail, so, it&amp;rsquo;s a perfect time to discuss error handling. We&amp;rsquo;ll do that next!</source>
          <target state="translated">我们正在进入更复杂的程序，在这些程序中操作可能会失败，因此，现在是讨论错误处理的理想时机。接下来，我们会做的！</target>
        </trans-unit>
        <trans-unit id="1bec095d3bfed69e34b314dbfade082c4c12b16b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re not quite done with this line of code. Although what we&amp;rsquo;ve discussed so far is a single line of text, it&amp;rsquo;s only the first part of the single logical line of code. The second part is this method:</source>
          <target state="translated">这行代码还没有完成。尽管到目前为止我们讨论的只是一行文本，但这只是逻辑代码行的第一部分。第二部分是这种方法：</target>
        </trans-unit>
        <trans-unit id="e8fdc745ba3517693a4cefb98c523891480464ad" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re now iterating over the workers twice: once to send one &lt;code&gt;Terminate&lt;/code&gt; message for each worker and once to call &lt;code&gt;join&lt;/code&gt; on each worker&amp;rsquo;s thread. If we tried to send a message and &lt;code&gt;join&lt;/code&gt; immediately in the same loop, we couldn&amp;rsquo;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</source>
          <target state="translated">现在，我们遍历工作线程两次：一次为每个工作线程发送一个 &lt;code&gt;Terminate&lt;/code&gt; 消息，一次在每个工作线程上调用 &lt;code&gt;join&lt;/code&gt; 。如果我们尝试发送消息并立即 &lt;code&gt;join&lt;/code&gt; 同一循环中，则无法保证当前迭代中的工作程序将是从通道中获取消息的工作程序。</target>
        </trans-unit>
        <trans-unit id="3043bedf342450c930adba158d22a65820a93654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the &lt;code&gt;baby_name&lt;/code&gt; method from the &lt;code&gt;Animal&lt;/code&gt; trait as implemented on &lt;code&gt;Dog&lt;/code&gt; by saying that we want to treat the &lt;code&gt;Dog&lt;/code&gt; type as an &lt;code&gt;Animal&lt;/code&gt; for this function call. This code will now print what we want:</source>
          <target state="translated">我们在尖括号内为Rust提供类型注释，这表示我们要通过对 &lt;code&gt;Dog&lt;/code&gt; 实施的 &lt;code&gt;Animal&lt;/code&gt; 特质来调用 &lt;code&gt;baby_name&lt;/code&gt; 方法，方法是说我们希望此函数调用将 &lt;code&gt;Dog&lt;/code&gt; 类型视为 &lt;code&gt;Animal&lt;/code&gt; 。现在，此代码将打印出我们想要的内容：</target>
        </trans-unit>
        <trans-unit id="4ddf3a6c4a7ff9bc3976c2dddb0193cf3c8094f5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re receiving only warnings now, which means it compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="translated">现在我们只收到警告，这意味着它可以编译！但是请注意，如果您尝试 &lt;code&gt;cargo run&lt;/code&gt; 并在浏览器中提出请求，您将在本章开头看到的浏览器中看到错误。我们的库实际上并没有调用传递给 &lt;code&gt;execute&lt;/code&gt; 的闭包！</target>
        </trans-unit>
        <trans-unit id="39e24358659ae04dcbe82e2100b6975e897d6a38" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable &lt;code&gt;query&lt;/code&gt; and the argument value at index 2 to the variable &lt;code&gt;filename&lt;/code&gt; within the &lt;code&gt;main&lt;/code&gt; function, we pass the whole vector to the &lt;code&gt;parse_config&lt;/code&gt; function. The &lt;code&gt;parse_config&lt;/code&gt; function then holds the logic that determines which argument goes in which variable and passes the values back to &lt;code&gt;main&lt;/code&gt;. We still create the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables in &lt;code&gt;main&lt;/code&gt;, but &lt;code&gt;main&lt;/code&gt; no longer has the responsibility of determining how the command line arguments and variables correspond.</source>
          <target state="translated">我们仍将命令行参数收集到向量中，但没有将索引1的参数值分配给变量 &lt;code&gt;query&lt;/code&gt; ，而是将索引2的参数值分配给了 &lt;code&gt;main&lt;/code&gt; 函数中的变量 &lt;code&gt;filename&lt;/code&gt; ，而是将整个向量传递给了 &lt;code&gt;parse_config&lt;/code&gt; 函数。然后， &lt;code&gt;parse_config&lt;/code&gt; 函数包含确定哪个参数进入哪个变量并将值传递回 &lt;code&gt;main&lt;/code&gt; 的逻辑。我们仍然在 &lt;code&gt;main&lt;/code&gt; 中创建 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 变量，但是 &lt;code&gt;main&lt;/code&gt; 不再负责确定命令行参数和变量如何对应。</target>
        </trans-unit>
        <trans-unit id="6a2a09503d50f0f83deb42b9b3c8d235d3d20cd7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still using a &lt;code&gt;for&lt;/code&gt; loop to return each line from &lt;code&gt;search&lt;/code&gt; and print it.</source>
          <target state="translated">我们仍在使用 &lt;code&gt;for&lt;/code&gt; 循环从 &lt;code&gt;search&lt;/code&gt; 返回每一行并打印出来。</target>
        </trans-unit>
        <trans-unit id="704d6708be51c898fd0ee7c005925dabd11417ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still working on this line of code. Although we&amp;rsquo;re now discussing a third line of text, it&amp;rsquo;s still part of a single logical line of code. The next part is this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dc7c10dc508f133971e52b437dcfabc8c9d8d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using another variation of the &lt;code&gt;List&lt;/code&gt; definition from Listing 15-5. The second element in the &lt;code&gt;Cons&lt;/code&gt; variant is now &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt;, meaning that instead of having the ability to modify the &lt;code&gt;i32&lt;/code&gt; value as we did in Listing 15-24, we want to modify which &lt;code&gt;List&lt;/code&gt; value a &lt;code&gt;Cons&lt;/code&gt; variant is pointing to. We&amp;rsquo;re also adding a &lt;code&gt;tail&lt;/code&gt; method to make it convenient for us to access the second item if we have a &lt;code&gt;Cons&lt;/code&gt; variant.</source>
          <target state="translated">我们使用清单15-5中 &lt;code&gt;List&lt;/code&gt; 定义的另一个变体。 &lt;code&gt;Cons&lt;/code&gt; 变量中的第二个元素现在是 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; ，这意味着我们不能像清单15-24那样修改 &lt;code&gt;i32&lt;/code&gt; 值，而是要修改 &lt;code&gt;Cons&lt;/code&gt; 变量指向哪个 &lt;code&gt;List&lt;/code&gt; 值。至。如果有 &lt;code&gt;Cons&lt;/code&gt; 变体，我们还添加了 &lt;code&gt;tail&lt;/code&gt; 方法，以方便我们访问第二项。</target>
        </trans-unit>
        <trans-unit id="e0c173af0bd25448bf48e4ff0f52351084a37793" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using the &lt;code&gt;is_err&lt;/code&gt; method on the &lt;code&gt;Result&lt;/code&gt; to check whether it&amp;rsquo;s an error and therefore unset, which means it &lt;em&gt;should&lt;/em&gt; do a case-sensitive search. If the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable is set to anything, &lt;code&gt;is_err&lt;/code&gt; will return false and the program will perform a case-insensitive search. We don&amp;rsquo;t care about the &lt;em&gt;value&lt;/em&gt; of the environment variable, just whether it&amp;rsquo;s set or unset, so we&amp;rsquo;re checking &lt;code&gt;is_err&lt;/code&gt; rather than using &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, or any of the other methods we&amp;rsquo;ve seen on &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">我们在 &lt;code&gt;Result&lt;/code&gt; 上使用 &lt;code&gt;is_err&lt;/code&gt; 方法来检查是否为错误并因此未设置，这意味着它&lt;em&gt;应该&lt;/em&gt;进行区分大小写的搜索。如果将 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 环境变量设置为任何值，则 &lt;code&gt;is_err&lt;/code&gt; 将返回false，并且程序将执行不区分大小写的搜索。我们不关心&lt;em&gt;值&lt;/em&gt;的环境变量，只是无论是设置或取消，所以我们正在检查 &lt;code&gt;is_err&lt;/code&gt; 而不是使用 &lt;code&gt;unwrap&lt;/code&gt; ， &lt;code&gt;expect&lt;/code&gt; 或任何我们所见过的其他方法 &lt;code&gt;Result&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d56b97467af5db84c05cb413a5fabde32de08385" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve actually already used statements and expressions. &lt;em&gt;Statements&lt;/em&gt; are instructions that perform some action and do not return a value. &lt;em&gt;Expressions&lt;/em&gt; evaluate to a resulting value. Let&amp;rsquo;s look at some examples.</source>
          <target state="translated">我们实际上已经使用过语句和表达式。&lt;em&gt;语句&lt;/em&gt;是执行某些操作且不返回值的指令。&lt;em&gt;表达式的&lt;/em&gt;计算结果为结果值。让我们看一些例子。</target>
        </trans-unit>
        <trans-unit id="d8fc6748175101658632d95f9debdd96c25d44d2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each file in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22b2164f8306680aed3e27380f526ec1c6ded84" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each test in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">我们已经在代码的顶部添加了 &lt;code&gt;use adder&lt;/code&gt; ，而在单元测试中则不需要。原因是 &lt;code&gt;tests&lt;/code&gt; 目录中的每个测试都是一个单独的板条箱，因此我们需要将我们的库放入每个测试板条箱的范围内。</target>
        </trans-unit>
        <trans-unit id="584b8b954ee114612008442a8b00d97910ff6eab" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a line at the top to bring the standard library&amp;rsquo;s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.</source>
          <target state="translated">我们在顶部添加了一行，以将标准库的文件系统模块纳入范围。用于将文件内容读取为字符串的代码应该看起来很熟悉；在清单12-4中读取I / O项目文件的内容时，我们在第12章中使用了它。</target>
        </trans-unit>
        <trans-unit id="4c87cb387453e91590c14806fac036a23f89422e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new &lt;code&gt;use&lt;/code&gt; line to bring &lt;code&gt;process&lt;/code&gt; from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the &lt;code&gt;err&lt;/code&gt; value and then call &lt;code&gt;process::exit&lt;/code&gt;. The &lt;code&gt;process::exit&lt;/code&gt; function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the &lt;code&gt;panic!&lt;/code&gt;-based handling we used in Listing 12-8, but we no longer get all the extra output. Let&amp;rsquo;s try it:</source>
          <target state="translated">我们添加了一条新的 &lt;code&gt;use&lt;/code&gt; 线，以将标准库中的 &lt;code&gt;process&lt;/code&gt; 引入范围。在错误情况下将运行的闭包中的代码只有两行：我们打印 &lt;code&gt;err&lt;/code&gt; 值，然后调用 &lt;code&gt;process::exit&lt;/code&gt; 。该 &lt;code&gt;process::exit&lt;/code&gt; 功能将立即停止该程序并返回被作为退出状态代码传递的数量。这类似于 &lt;code&gt;panic!&lt;/code&gt; 清单12-8中使用了基于的处理，但不再获得所有多余的输出。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="7cffa1b480aa410c1dc47385712cedb9b3949a57" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a struct named &lt;code&gt;Config&lt;/code&gt; defined to have fields named &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;. The signature of &lt;code&gt;parse_config&lt;/code&gt; now indicates that it returns a &lt;code&gt;Config&lt;/code&gt; value. In the body of &lt;code&gt;parse_config&lt;/code&gt;, where we used to return string slices that reference &lt;code&gt;String&lt;/code&gt; values in &lt;code&gt;args&lt;/code&gt;, we now define &lt;code&gt;Config&lt;/code&gt; to contain owned &lt;code&gt;String&lt;/code&gt; values. The &lt;code&gt;args&lt;/code&gt; variable in &lt;code&gt;main&lt;/code&gt; is the owner of the argument values and is only letting the &lt;code&gt;parse_config&lt;/code&gt; function borrow them, which means we&amp;rsquo;d violate Rust&amp;rsquo;s borrowing rules if &lt;code&gt;Config&lt;/code&gt; tried to take ownership of the values in &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">我们添加了一个名为 &lt;code&gt;Config&lt;/code&gt; 的结构体，该结构体具有名为 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 的字段。现在， &lt;code&gt;parse_config&lt;/code&gt; 的签名表明它返回了 &lt;code&gt;Config&lt;/code&gt; 值。在 &lt;code&gt;parse_config&lt;/code&gt; 的主体中，我们曾经用来返回引用 &lt;code&gt;args&lt;/code&gt; 中的 &lt;code&gt;String&lt;/code&gt; 值的字符串切片，现在我们将 &lt;code&gt;Config&lt;/code&gt; 定义为包含拥有的 &lt;code&gt;String&lt;/code&gt; 值。 &lt;code&gt;main&lt;/code&gt; 中的 &lt;code&gt;args&lt;/code&gt; 变量是参数值的所有者，并且只允许 &lt;code&gt;parse_config&lt;/code&gt; 函数借用它们，这意味着如果 &lt;code&gt;Config&lt;/code&gt; 违反了Rust的借用规则试图取得 &lt;code&gt;args&lt;/code&gt; 中的值的所有权。</target>
        </trans-unit>
        <trans-unit id="1885fbfa7b60233a91c017c818f49ba0e7b6f717" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added some documentation for our &lt;code&gt;ThreadPool&lt;/code&gt; with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running &lt;code&gt;cargo doc --open&lt;/code&gt; and clicking the &lt;code&gt;ThreadPool&lt;/code&gt; struct to see what the generated docs for &lt;code&gt;new&lt;/code&gt; look like!</source>
          <target state="translated">我们为 &lt;code&gt;ThreadPool&lt;/code&gt; 添加了一些文档注释文档。请注意，我们遵循良好的文档惯例，添加了一节，指出了函数可能出现紧急情况的情况，如第14章中所述。尝试运行 &lt;code&gt;cargo doc --open&lt;/code&gt; 并单击 &lt;code&gt;ThreadPool&lt;/code&gt; 结构，以查看生成的文档具有 &lt;code&gt;new&lt;/code&gt; 外观喜欢！</target>
        </trans-unit>
        <trans-unit id="033bfc676c905568043c961c9b266296859d8c02" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added the &lt;code&gt;request_review&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait; all types that implement the trait will now need to implement the &lt;code&gt;request_review&lt;/code&gt; method. Note that rather than having &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter of the method, we have &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. This syntax means the method is only valid when called on a &lt;code&gt;Box&lt;/code&gt; holding the type. This syntax takes ownership of &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, invalidating the old state so the state value of the &lt;code&gt;Post&lt;/code&gt; can transform into a new state.</source>
          <target state="translated">我们已将 &lt;code&gt;request_review&lt;/code&gt; 方法添加到 &lt;code&gt;State&lt;/code&gt; trait；现在，实现该特征的所有类型都将需要实现 &lt;code&gt;request_review&lt;/code&gt; 方法。请注意，我们没有将 &lt;code&gt;self&lt;/code&gt; ， &lt;code&gt;&amp;amp;self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 作为方法的第一个参数，而是使用了 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 。这种语法意味着该方法仅在持有该类型的 &lt;code&gt;Box&lt;/code&gt; 上调用时才有效。此语法采用 &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; 所有权，从而使旧状态无效，因此 &lt;code&gt;Post&lt;/code&gt; 的状态值可以转换为新状态。</target>
        </trans-unit>
        <trans-unit id="c2d6bca1ece5398cc0aaa45cdd8c28d538813cdf" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already encountered a few smart pointers in this book, such as &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in Chapter 8, although we didn&amp;rsquo;t call them smart pointers at the time. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with &lt;code&gt;String&lt;/code&gt; ensuring its data will always be valid UTF-8).</source>
          <target state="translated">在本书中，我们已经遇到了一些智能指针，例如第8章中的 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，尽管我们当时没有称它们为智能指针。这两种类型都算作智能指针，因为它们拥有一些内存并允许您对其进行操作。它们还具有元数据（例如其容量）和额外的功能或保证（例如使用 &lt;code&gt;String&lt;/code&gt; 来确保其数据始终是有效的UTF-8）。</target>
        </trans-unit>
        <trans-unit id="5f665940216ffe5d50883d2554e20cbd268101e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren&amp;rsquo;t suitable for every situation in which we may want to use text. One reason is that they&amp;rsquo;re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, &lt;code&gt;String&lt;/code&gt;. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a &lt;code&gt;String&lt;/code&gt; from a string literal using the &lt;code&gt;from&lt;/code&gt; function, like so:</source>
          <target state="translated">我们已经看到了字符串文字，其中字符串值被硬编码到我们的程序中。字符串文字很方便，但是它们并不适合我们可能要使用文本的每种情况。原因之一是它们是不可变的。另一个是在编写代码时并不是每个字符串值都可以知道的：例如，如果我们想接受用户输入并存储它，该怎么办？对于这些情况，Rust具有第二个字符串类型 &lt;code&gt;String&lt;/code&gt; 。这种类型在堆上分配，因此能够存储在编译时我们不知道的大量文本。您可以创建一个 &lt;code&gt;String&lt;/code&gt; 字面使用从一个字符串 &lt;code&gt;from&lt;/code&gt; 函数，比如：</target>
        </trans-unit>
        <trans-unit id="afec387c328832d115c9aaceeb2e235c2cecfd8f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve brought &lt;code&gt;std::thread&lt;/code&gt; into scope in the library crate, because we&amp;rsquo;re using &lt;code&gt;thread::JoinHandle&lt;/code&gt; as the type of the items in the vector in &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">我们将 &lt;code&gt;std::thread&lt;/code&gt; 放入库箱的作用域中，因为我们在 &lt;code&gt;ThreadPool&lt;/code&gt; 中使用 &lt;code&gt;thread::JoinHandle&lt;/code&gt; 作为向量中项目的类型。</target>
        </trans-unit>
        <trans-unit id="d06c508a695440c6e3d61967e906e12cd55df3a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve changed the name of the field on &lt;code&gt;ThreadPool&lt;/code&gt; from &lt;code&gt;threads&lt;/code&gt; to &lt;code&gt;workers&lt;/code&gt; because it&amp;rsquo;s now holding &lt;code&gt;Worker&lt;/code&gt; instances instead of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances. We use the counter in the &lt;code&gt;for&lt;/code&gt; loop as an argument to &lt;code&gt;Worker::new&lt;/code&gt;, and we store each new &lt;code&gt;Worker&lt;/code&gt; in the vector named &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">我们已经将 &lt;code&gt;ThreadPool&lt;/code&gt; 上的字段名称从 &lt;code&gt;threads&lt;/code&gt; 更改为 &lt;code&gt;workers&lt;/code&gt; 因为它现在持有 &lt;code&gt;Worker&lt;/code&gt; 实例而不是 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 实例。我们将 &lt;code&gt;for&lt;/code&gt; 循环中的计数器用作 &lt;code&gt;Worker::new&lt;/code&gt; 的参数，并将每个新 &lt;code&gt;Worker&lt;/code&gt; 存储在名为 &lt;code&gt;workers&lt;/code&gt; 的向量中。</target>
        </trans-unit>
        <trans-unit id="b6773f3d57e1c56123d2fb2caa6f401e95f3ea12" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve chosen &lt;code&gt;&amp;amp;self&lt;/code&gt; here for the same reason we used &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; in the function version: we don&amp;rsquo;t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we&amp;rsquo;ve called the method on as part of what the method does, we&amp;rsquo;d use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter. Having a method that takes ownership of the instance by using just &lt;code&gt;self&lt;/code&gt; as the first parameter is rare; this technique is usually used when the method transforms &lt;code&gt;self&lt;/code&gt; into something else and you want to prevent the caller from using the original instance after the transformation.</source>
          <target state="translated">我们在这里选择 &lt;code&gt;&amp;amp;self&lt;/code&gt; 的原因 &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; 在函数版本中使用＆Rectangle的原因相同：我们不想获得所有权，我们只想读取结构中的数据，而不是对其进行写入。如果我们想在方法执行的过程中更改调用该方法的实例，则可以使用 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 作为第一个参数。很少有一种方法只使用 &lt;code&gt;self&lt;/code&gt; 作为第一个参数来获取实例的所有权；该方法通常在方法将 &lt;code&gt;self&lt;/code&gt; 转换为其他形式并且要防止调用者在转换后使用原始实例时使用。</target>
        </trans-unit>
        <trans-unit id="c1db49e2d4e1cde132781769873263a6ad0787ce" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve created raw pointers by using &lt;code&gt;as&lt;/code&gt; to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&amp;rsquo;t make that assumption about just any raw pointer.</source>
          <target state="translated">我们通过使用 &lt;code&gt;as&lt;/code&gt; 将不可变和可变引用转换为相应的原始指针类型来创建原始指针。因为我们直接从保证有效的引用中创建了它们，所以我们知道这些特定的原始指针是有效的，但是我们不能仅对任何原始指针进行假设。</target>
        </trans-unit>
        <trans-unit id="bffcb1376e08b8bdf566e588ca56d6643d86c91b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</source>
          <target state="translated">我们定义了一个宏，该宏可以接受任意数量的任何类型的参数，并且可以生成代码以创建包含指定元素的向量。</target>
        </trans-unit>
        <trans-unit id="51c190acab3ae3b5901bd943815d252d578b8d41" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they&amp;rsquo;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</source>
          <target state="translated">我们已经在本章中描述了大多数高级功能，这些功能很少需要。关联类型位于中间位置：它们比本书其余部分所介绍的功能使用得很少，但比本章中讨论的许多其他功能更常用。</target>
        </trans-unit>
        <trans-unit id="06deefd5074e90766703296697ebf8ccb43b0e5d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve destructured enums earlier in this book, for example, when we destructured &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; in Listing 6-5 in Chapter 6. One detail we haven&amp;rsquo;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the &lt;code&gt;Message&lt;/code&gt; enum from Listing 6-2 and write a &lt;code&gt;match&lt;/code&gt; with patterns that will destructure each inner value.</source>
          <target state="translated">例如，当我们在第6章的清单6-5中对 &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; 进行结构化时，我们已经在本书的前面对结构进行了解构。定义了枚举中存储的数据。例如，在清单18-15中，我们使用清单6-2中的 &lt;code&gt;Message&lt;/code&gt; 枚举，并编写一个具有将破坏每个内部值的模式的 &lt;code&gt;match&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6277ca606742a1b968d8228027cda7b90d3f30" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, it will not compile.</source>
          <target state="translated">我们已经给出了代码！这段代码是完全有效的，尽管它意味着我们不能在没有错误的情况下使用不可辩驳的模式。如果我们给 &lt;code&gt;if let&lt;/code&gt; 一个模式，将总是一致的，如 &lt;code&gt;x&lt;/code&gt; ，如图18-10所示，它不会编译。</target>
        </trans-unit>
        <trans-unit id="78dee02791985c19ffc271569fd60c5a8fc8dade" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, the compiler will give a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9288497ed026aec5cddf626c274f65076b889591" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve hardcoded the variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; as 10 and the variable &lt;code&gt;simulated_random_number&lt;/code&gt; as 7 for simplicity&amp;rsquo;s sake; in an actual program, we&amp;rsquo;d get the intensity number from the app frontend, and we&amp;rsquo;d use the &lt;code&gt;rand&lt;/code&gt; crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The &lt;code&gt;main&lt;/code&gt; function calls a &lt;code&gt;generate_workout&lt;/code&gt; function with the simulated input values.</source>
          <target state="translated">为了简单起见，我们已将变量 &lt;code&gt;simulated_user_specified_value&lt;/code&gt; 硬编码为10，并将变量 &lt;code&gt;simulated_random_number&lt;/code&gt; 硬编码为7。在实际的程序，我们会得到从应用程序前端强度号码，我们会使用 &lt;code&gt;rand&lt;/code&gt; 箱子生成一个随机数字，我们在划拳例如，在第2章所做的 &lt;code&gt;main&lt;/code&gt; 功能调用 &lt;code&gt;generate_workout&lt;/code&gt; 功能与模拟输入值。</target>
        </trans-unit>
        <trans-unit id="5e36cd45124891f0ced7a53981629ff72590f283" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve introduced three new crates: &lt;code&gt;proc_macro&lt;/code&gt;, &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate comes with Rust, so we didn&amp;rsquo;t need to add that to the dependencies in &lt;em&gt;Cargo.toml&lt;/em&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate is the compiler&amp;rsquo;s API that allows us to read and manipulate Rust code from our code.</source>
          <target state="translated">我们引入了三个新的板条箱： &lt;code&gt;proc_macro&lt;/code&gt; ，&lt;a href=&quot;https://crates.io/crates/syn&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://crates.io/crates/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt;。该 &lt;code&gt;proc_macro&lt;/code&gt; 箱带有铁锈，所以我们并不需要将它添加到依赖&lt;em&gt;Cargo.toml&lt;/em&gt;。该 &lt;code&gt;proc_macro&lt;/code&gt; 箱子是编译器的API，使我们能够阅读和我们的代码操作锈病代码。</target>
        </trans-unit>
        <trans-unit id="0ad45439c6472977b496b46c9e8ec344b7d03941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made liberal use of the &lt;code&gt;pub&lt;/code&gt; keyword: on &lt;code&gt;Config&lt;/code&gt;, on its fields and its &lt;code&gt;new&lt;/code&gt; method, and on the &lt;code&gt;run&lt;/code&gt; function. We now have a library crate that has a public API that we can test!</source>
          <target state="translated">我们自由使用了 &lt;code&gt;pub&lt;/code&gt; 关键字： &lt;code&gt;Config&lt;/code&gt; ，其字段及其 &lt;code&gt;new&lt;/code&gt; 方法以及 &lt;code&gt;run&lt;/code&gt; 函数。现在，我们有了一个带有公共API的库箱，我们可以对其进行测试！</target>
        </trans-unit>
        <trans-unit id="93d9e35440edfc2a27a289759d47f3243926cd99" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made some small and straightforward changes: we pass the receiving end of the channel into &lt;code&gt;Worker::new&lt;/code&gt;, and then we use it inside the closure.</source>
          <target state="translated">我们进行了一些小而直接的更改：将通道的接收端传递给 &lt;code&gt;Worker::new&lt;/code&gt; ，然后在闭包内部使用它。</target>
        </trans-unit>
        <trans-unit id="56995a6860da00dba94b79267ee87621a35cfd58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made three significant changes here. First, we changed the return type of the &lt;code&gt;run&lt;/code&gt; function to &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt;. This function previously returned the unit type, &lt;code&gt;()&lt;/code&gt;, and we keep that as the value returned in the &lt;code&gt;Ok&lt;/code&gt; case.</source>
          <target state="translated">我们在这里进行了三项重大更改。首先，我们将 &lt;code&gt;run&lt;/code&gt; 函数的返回类型更改为 &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt; 。该函数先前返回了单位类型 &lt;code&gt;()&lt;/code&gt; ，我们将其保留为 &lt;code&gt;Ok&lt;/code&gt; 情况下返回的值。</target>
        </trans-unit>
        <trans-unit id="7aef292d2641df4649db03b9163b74c003c21be2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made two changes in the body of the &lt;code&gt;new&lt;/code&gt; function: instead of calling &lt;code&gt;panic!&lt;/code&gt; when the user doesn&amp;rsquo;t pass enough arguments, we now return an &lt;code&gt;Err&lt;/code&gt; value, and we&amp;rsquo;ve wrapped the &lt;code&gt;Config&lt;/code&gt; return value in an &lt;code&gt;Ok&lt;/code&gt;. These changes make the function conform to its new type signature.</source>
          <target state="translated">我们在 &lt;code&gt;new&lt;/code&gt; 函数的主体中进行了两项更改：而不是调用 &lt;code&gt;panic!&lt;/code&gt; 当用户未传递足够的参数时，我们现在返回 &lt;code&gt;Err&lt;/code&gt; 值，并将 &lt;code&gt;Config&lt;/code&gt; 返回值包装在 &lt;code&gt;Ok&lt;/code&gt; 中。这些更改使函数符合其新类型签名。</target>
        </trans-unit>
        <trans-unit id="be1fafd103cb85a28b4ca20cff35d635b76880a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve mentioned that in Rust, we refrain from calling structs and enums &amp;ldquo;objects&amp;rdquo; to distinguish them from other languages&amp;rsquo; objects. In a struct or enum, the data in the struct fields and the behavior in &lt;code&gt;impl&lt;/code&gt; blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects &lt;em&gt;are&lt;/em&gt; more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can&amp;rsquo;t add data to a trait object. Trait objects aren&amp;rsquo;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</source>
          <target state="translated">我们已经提到过，在Rust中，我们避免调用结构和枚举&amp;ldquo;对象&amp;rdquo;来将它们与其他语言的对象区分开。在结构或枚举中，结构字段中的数据和 &lt;code&gt;impl&lt;/code&gt; 块中的行为是分开的，而在其他语言中，组合为一个概念的数据和行为通常被标记为对象。然而，特质对象&lt;em&gt;是&lt;/em&gt;更像是在这个意义上其他语言的对象，他们结合数据和行为。但是特征对象与传统对象的不同之处在于我们无法向特征对象添加数据。特性对象通常没有其他语言中的对象有用：它们的特定目的是允许对常见行为进行抽象。</target>
        </trans-unit>
        <trans-unit id="d6a7a8ffdb70b17f8f4c294d0eea3a1bf35ddd50" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve moved the creation of the new &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; to the beginning of the function; that part hasn&amp;rsquo;t changed. Instead of creating a variable &lt;code&gt;f&lt;/code&gt;, we&amp;rsquo;ve chained the call to &lt;code&gt;read_to_string&lt;/code&gt; directly onto the result of &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt;. We still have a &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call, and we still return an &lt;code&gt;Ok&lt;/code&gt; value containing the username in &lt;code&gt;s&lt;/code&gt; when both &lt;code&gt;File::open&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.</source>
          <target state="translated">我们已经搬到新创建 &lt;code&gt;String&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 给函数的开始;那部分没有改变。而不是创建变量 &lt;code&gt;f&lt;/code&gt; ，我们 &lt;code&gt;read_to_string&lt;/code&gt; 的调用直接链接到 &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt; 。我们还有一个 &lt;code&gt;?&lt;/code&gt; 在 &lt;code&gt;read_to_string&lt;/code&gt; 调用的末尾，当 &lt;code&gt;File::open&lt;/code&gt; 和 &lt;code&gt;read_to_string&lt;/code&gt; 都成功而不返回错误时，我们仍然返回一个包含 &lt;code&gt;s&lt;/code&gt; 中用户名的 &lt;code&gt;Ok&lt;/code&gt; 值。功能再次与清单9-6和清单9-7相同；这只是一种不同的，更符合人体工程学的编写方式。</target>
        </trans-unit>
        <trans-unit id="c8159737415ba1d5840c5d1dcfa32d246b649654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve named our test &lt;code&gt;larger_can_hold_smaller&lt;/code&gt;, and we&amp;rsquo;ve created the two &lt;code&gt;Rectangle&lt;/code&gt; instances that we need. Then we called the &lt;code&gt;assert!&lt;/code&gt; macro and passed it the result of calling &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt;. This expression is supposed to return &lt;code&gt;true&lt;/code&gt;, so our test should pass. Let&amp;rsquo;s find out!</source>
          <target state="translated">我们将测试命名为 &lt;code&gt;larger_can_hold_smaller&lt;/code&gt; ，并创建了我们需要的两个 &lt;code&gt;Rectangle&lt;/code&gt; 实例。然后我们叫 &lt;code&gt;assert!&lt;/code&gt; 宏并将其传递给调用 &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt; 。该表达式应该返回 &lt;code&gt;true&lt;/code&gt; ，因此我们的测试应该通过。让我们找出答案！</target>
        </trans-unit>
        <trans-unit id="eb03fca51e0258eda1b9da34ca6053fc2fa793f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We&amp;rsquo;ve shown how the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type helps you use the type system to prevent errors. When enum values have data inside them, you can use &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to extract and use those values, depending on how many cases you need to handle.</source>
          <target state="translated">现在，我们已经介绍了如何使用枚举创建自定义类型，这些自定义类型可以是一组枚举值中的一个。我们已经展示了标准库的 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 类型如何帮助您使用类型系统来防止错误。当枚举值中包含数据时，您可以使用 &lt;code&gt;match&lt;/code&gt; ,或者 &lt;code&gt;if let&lt;/code&gt; 我们提取和使用这些值，具体取决于您需要处理多少种情况。</target>
        </trans-unit>
        <trans-unit id="2ddb2aa6e11b76709deea3ac27493aedd396c368" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&amp;rsquo;s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won&amp;rsquo;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&amp;rsquo;t have.</source>
          <target state="translated">我们已经看到，即使Rust能够实现面向对象的设计模式，Rust中也可以使用其他模式，例如将状态编码到类型系统中。这些模式具有不同的权衡。尽管您可能非常熟悉面向对象的模式，但是重新考虑问题以利用Rust的功能可以带来好处，例如防止在编译时出现一些错误。由于某些功能（例如所有权）是面向对象语言所不具备的，因此面向对象模式并非总是Rust中最好的解决方案。</target>
        </trans-unit>
        <trans-unit id="4a3393f5cdb05fd0ee1656e458d53bb37965c9bd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;the standard library has a definition we can use!&lt;/a&gt; Let&amp;rsquo;s look at how the standard library defines &lt;code&gt;IpAddr&lt;/code&gt;: it has the exact enum and variants that we&amp;rsquo;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</source>
          <target state="translated">我们已经展示了几种不同的方式来定义数据结构以存储第四版和第六版IP地址。然而，事实证明，想要存储IP地址并对其进行编码非常普遍，以至于&lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;标准库有一个我们可以使用的定义！&lt;/a&gt;让我们看一下标准库如何定义 &lt;code&gt;IpAddr&lt;/code&gt; ：它具有我们定义和使用的确切枚举和变量，但它以两种不同的结构形式将地址数据嵌入变量中，每种结构的定义都不同：</target>
        </trans-unit>
        <trans-unit id="29dedc9579ea7a2e3397effb70664bac84882984" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on &lt;code&gt;Post&lt;/code&gt; know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the &lt;code&gt;State&lt;/code&gt; trait on the &lt;code&gt;Published&lt;/code&gt; struct.</source>
          <target state="translated">我们已经证明，Rust能够实现面向对象的状态模式，以封装帖子在每种状态下应该具有的各种行为。 &lt;code&gt;Post&lt;/code&gt; 上的方法对各种行为一无所知。我们组织代码的方式，我们只需要查看一个地方即可知道已发布帖子的不同行为方式：在已 &lt;code&gt;Published&lt;/code&gt; 结构上实现 &lt;code&gt;State&lt;/code&gt; 特质。</target>
        </trans-unit>
        <trans-unit id="ebc522f12982267dfc02e6dcc67a8d4e642dabf5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that you can create an iterator by calling &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;into_iter&lt;/code&gt;, or &lt;code&gt;iter_mut&lt;/code&gt; on a vector. You can create iterators from the other collection types in the standard library, such as hash map. You can also create iterators that do anything you want by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait on your own types. As previously mentioned, the only method you&amp;rsquo;re required to provide a definition for is the &lt;code&gt;next&lt;/code&gt; method. Once you&amp;rsquo;ve done that, you can use all other methods that have default implementations provided by the &lt;code&gt;Iterator&lt;/code&gt; trait!</source>
          <target state="translated">我们已经展示了可以通过在向量上调用 &lt;code&gt;iter&lt;/code&gt; ， &lt;code&gt;into_iter&lt;/code&gt; 或 &lt;code&gt;iter_mut&lt;/code&gt; 来创建迭代器。您可以从标准库中的其他集合类型（例如哈希映射）创建迭代器。您还可以通过在自己的类型上实现 &lt;code&gt;Iterator&lt;/code&gt; 特质来创建可以执行任何操作的迭代器。如前所述，唯一需要提供定义的方法是 &lt;code&gt;next&lt;/code&gt; 方法。完成此操作后，您可以使用具有 &lt;code&gt;Iterator&lt;/code&gt; 特性提供的默认实现的所有其他方法！</target>
        </trans-unit>
        <trans-unit id="b66581e28df90aa77932dec55a52d6260ebfbe34" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you&amp;rsquo;ve already defined rather than defining a new closure. Doing this with function pointers will allow you to use functions as arguments to other functions. Functions coerce to the type &lt;code&gt;fn&lt;/code&gt; (with a lowercase f), not to be confused with the &lt;code&gt;Fn&lt;/code&gt; closure trait. The &lt;code&gt;fn&lt;/code&gt; type is called a &lt;em&gt;function pointer&lt;/em&gt;. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</source>
          <target state="translated">我们已经讨论了如何将闭包传递给函数。您还可以将常规函数传递给函数！当您要传递已经定义的函数而不是定义新的闭包时，此技术很有用。使用函数指针执行此操作将使您可以将函数用作其他函数的参数。函数强制转换为 &lt;code&gt;fn&lt;/code&gt; 类型（带有小写的f），不要与 &lt;code&gt;Fn&lt;/code&gt; 闭包特征相混淆。该 &lt;code&gt;fn&lt;/code&gt; 类型称为&lt;em&gt;函数指针&lt;/em&gt;。用于指定参数为函数指针的语法类似于闭包的语法，如清单19-27所示。</target>
        </trans-unit>
        <trans-unit id="44c2c6bad4c34dbea054ba65f353232e3b4bb941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; so it places the instance of &lt;code&gt;Config&lt;/code&gt; returned by &lt;code&gt;parse_config&lt;/code&gt; into a variable named &lt;code&gt;config&lt;/code&gt;, and we updated the code that previously used the separate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables so it now uses the fields on the &lt;code&gt;Config&lt;/code&gt; struct instead.</source>
          <target state="translated">我们已经更新了 &lt;code&gt;main&lt;/code&gt; ,因此将 &lt;code&gt;parse_config&lt;/code&gt; 返回的 &lt;code&gt;Config&lt;/code&gt; 实例放置到名为 &lt;code&gt;config&lt;/code&gt; 的变量中，并且更新了以前使用单独的 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 变量的代码，因此现在改为使用 &lt;code&gt;Config&lt;/code&gt; 结构上的字段。</target>
        </trans-unit>
        <trans-unit id="d23dd8237d80151639faf67cba12c8d62a94d599" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; where we were calling &lt;code&gt;parse_config&lt;/code&gt; to instead call &lt;code&gt;Config::new&lt;/code&gt;. We&amp;rsquo;ve changed the name of &lt;code&gt;parse_config&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; and moved it within an &lt;code&gt;impl&lt;/code&gt; block, which associates the &lt;code&gt;new&lt;/code&gt; function with &lt;code&gt;Config&lt;/code&gt;. Try compiling this code again to make sure it works.</source>
          <target state="translated">我们已经更新了 &lt;code&gt;main&lt;/code&gt; ，我们分别致电 &lt;code&gt;parse_config&lt;/code&gt; 改为调用 &lt;code&gt;Config::new&lt;/code&gt; 。我们将 &lt;code&gt;parse_config&lt;/code&gt; 的名称更改为 &lt;code&gt;new&lt;/code&gt; ，并将其移动到 &lt;code&gt;impl&lt;/code&gt; 块中，该块将 &lt;code&gt;new&lt;/code&gt; 功能与 &lt;code&gt;Config&lt;/code&gt; 关联。尝试再次编译此代码，以确保它可以工作。</target>
        </trans-unit>
        <trans-unit id="682f1e494883240e497eaf886adabbd3de94d2f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used &lt;code&gt;recv&lt;/code&gt; in this example for simplicity; we don&amp;rsquo;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</source>
          <target state="translated">为了简单起见，我们在此示例中使用了 &lt;code&gt;recv&lt;/code&gt; 。除了等待消息外，我们没有其他任何工作可让主线程执行，因此阻塞主线程是适当的。</target>
        </trans-unit>
        <trans-unit id="09261808e853fe8c1b1cf1c98bcaef67bcdbf69f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used macros like &lt;code&gt;println!&lt;/code&gt; throughout this book, but we haven&amp;rsquo;t fully explored what a macro is and how it works. The term &lt;em&gt;macro&lt;/em&gt; refers to a family of features in Rust: &lt;em&gt;declarative&lt;/em&gt; macros with &lt;code&gt;macro_rules!&lt;/code&gt; and three kinds of &lt;em&gt;procedural&lt;/em&gt; macros:</source>
          <target state="translated">我们使用了诸如 &lt;code&gt;println!&lt;/code&gt; 宏！在本书中，但我们还没有完全探讨宏是什么以及宏如何工作。术语&lt;em&gt;宏&lt;/em&gt;是指Rust中的一系列功能：具有 &lt;code&gt;macro_rules!&lt;/code&gt; &lt;em&gt;声明性&lt;/em&gt;宏！和三种&lt;em&gt;程序&lt;/em&gt;宏：</target>
        </trans-unit>
        <trans-unit id="e2712446812526a53471c1e0383e7a3108a1b4ae" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used packages from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distributes the source code of your packages, so it primarily hosts code that is open source.</source>
          <target state="translated">我们已经使用了&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io中的&lt;/a&gt;程序包作为我们项目的依赖项，但是您也可以通过发布自己的程序包与其他人共享代码。位于&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;的crate注册表分发软件包的源代码，因此它主要托管开放源代码。</target>
        </trans-unit>
        <trans-unit id="ec147c9a441b7f735a89cab0dad06f6138cccde7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used the underscore (&lt;code&gt;_&lt;/code&gt;) as a wildcard pattern that will match any value but not bind to the value. Although the underscore &lt;code&gt;_&lt;/code&gt; pattern is especially useful as the last arm in a &lt;code&gt;match&lt;/code&gt; expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</source>
          <target state="translated">我们使用下划线（ &lt;code&gt;_&lt;/code&gt; ）作为通配符模式，该模式将匹配任何值但不绑定到该值。尽管下划线 &lt;code&gt;_&lt;/code&gt; 模式作为 &lt;code&gt;match&lt;/code&gt; 表达式的最后一臂特别有用，但是我们可以在任何模式中使用它，包括函数参数，如清单18-17所示。</target>
        </trans-unit>
        <trans-unit id="44adc69b5d64c0f01b24575df11e052ec21c4722" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve walked through an example of a Rust program already in Chapter 2. Now that we&amp;rsquo;re past basic syntax, we won&amp;rsquo;t include all the &lt;code&gt;fn main() {&lt;/code&gt; code in examples, so if you&amp;rsquo;re following along, you&amp;rsquo;ll have to put the following examples inside a &lt;code&gt;main&lt;/code&gt; function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</source>
          <target state="translated">我们已经在第2章中介绍了Rust程序的示例。现在，我们已经讲解了基本语法，我们不会在示例中包含所有的 &lt;code&gt;fn main() {&lt;/code&gt; 代码，因此，如果您继续学习，将必须手动将以下示例放入 &lt;code&gt;main&lt;/code&gt; 函数中。结果，我们的示例将更加简洁，让我们专注于实际的细节而不是样板代码。</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="2592fb559c34ba109b261e1e971e0271f723f218" translate="yes" xml:space="preserve">
          <source>Weak keywords</source>
          <target state="translated">弱关键词</target>
        </trans-unit>
        <trans-unit id="b141897801ad64a5c292f85e9b0acea35468d86f" translate="yes" xml:space="preserve">
          <source>Weak::as_raw</source>
          <target state="translated">Weak::as_raw</target>
        </trans-unit>
        <trans-unit id="d422a6274254bfe89623f64408426ee6a4b95d2f" translate="yes" xml:space="preserve">
          <source>Weak::borrow</source>
          <target state="translated">Weak::borrow</target>
        </trans-unit>
        <trans-unit id="e090aeaf0035d47a06522ac573102af7ef03019b" translate="yes" xml:space="preserve">
          <source>Weak::borrow_mut</source>
          <target state="translated">Weak::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31f2cf80409016cb1a54e11bd8e10df114bcff9c" translate="yes" xml:space="preserve">
          <source>Weak::clone</source>
          <target state="translated">Weak::clone</target>
        </trans-unit>
        <trans-unit id="1022360ae57147f43f753c89ffa5b787aa1673ef" translate="yes" xml:space="preserve">
          <source>Weak::clone_from</source>
          <target state="translated">Weak::clone_from</target>
        </trans-unit>
        <trans-unit id="7ffb62a38307a645dc9e4fc1d7f948ab860db2a7" translate="yes" xml:space="preserve">
          <source>Weak::clone_into</source>
          <target state="translated">Weak::clone_into</target>
        </trans-unit>
        <trans-unit id="c865a401afc186e43b4eab7ca361d7638e0b536e" translate="yes" xml:space="preserve">
          <source>Weak::default</source>
          <target state="translated">Weak::default</target>
        </trans-unit>
        <trans-unit id="e57f10f57657469def31fa2d885237f40eb69154" translate="yes" xml:space="preserve">
          <source>Weak::drop</source>
          <target state="translated">Weak::drop</target>
        </trans-unit>
        <trans-unit id="ef51946ab6d84ee6b5287e68325989e298d500bc" translate="yes" xml:space="preserve">
          <source>Weak::fmt</source>
          <target state="translated">Weak::fmt</target>
        </trans-unit>
        <trans-unit id="04990cfad4762bebd1df30cc473af5882f2479cb" translate="yes" xml:space="preserve">
          <source>Weak::from</source>
          <target state="translated">Weak::from</target>
        </trans-unit>
        <trans-unit id="df4c7443eba251c8b78b6539d8ece4de970f301b" translate="yes" xml:space="preserve">
          <source>Weak::from_raw</source>
          <target state="translated">Weak::from_raw</target>
        </trans-unit>
        <trans-unit id="a6076aa76799b24c93bec01d241d277a0659dedb" translate="yes" xml:space="preserve">
          <source>Weak::into</source>
          <target state="translated">Weak::into</target>
        </trans-unit>
        <trans-unit id="0d8046306424b99b930a8b4a94195613e63c8154" translate="yes" xml:space="preserve">
          <source>Weak::into_raw</source>
          <target state="translated">Weak::into_raw</target>
        </trans-unit>
        <trans-unit id="a47f17db375bc704f4e384a38de508a900dfe192" translate="yes" xml:space="preserve">
          <source>Weak::new</source>
          <target state="translated">Weak::new</target>
        </trans-unit>
        <trans-unit id="9bc78ec91050d31c7752a036bdbd22e4063b718e" translate="yes" xml:space="preserve">
          <source>Weak::ptr_eq</source>
          <target state="translated">Weak::ptr_eq</target>
        </trans-unit>
        <trans-unit id="772fd61fe1d60fd5b1beff3bc669c9f17593cd0f" translate="yes" xml:space="preserve">
          <source>Weak::strong_count</source>
          <target state="translated">Weak::strong_count</target>
        </trans-unit>
        <trans-unit id="78b91a1fa2b3787768d39e8c6e94b83a6d3b3355" translate="yes" xml:space="preserve">
          <source>Weak::to_owned</source>
          <target state="translated">Weak::to_owned</target>
        </trans-unit>
        <trans-unit id="a0b4587c121fa0987a33f7acf83c36d1aa760be3" translate="yes" xml:space="preserve">
          <source>Weak::try_from</source>
          <target state="translated">Weak::try_from</target>
        </trans-unit>
        <trans-unit id="dffb26aa2fde976b45f16c5f1b3ec4c3c2236a57" translate="yes" xml:space="preserve">
          <source>Weak::try_into</source>
          <target state="translated">Weak::try_into</target>
        </trans-unit>
        <trans-unit id="66cbdb0ce3c9d445fe02eebbca20dc6699c1e0b8" translate="yes" xml:space="preserve">
          <source>Weak::type_id</source>
          <target state="translated">Weak::type_id</target>
        </trans-unit>
        <trans-unit id="ffffecfd343836cf2781f4e9ad8fe4ab904bdda7" translate="yes" xml:space="preserve">
          <source>Weak::upgrade</source>
          <target state="translated">Weak::upgrade</target>
        </trans-unit>
        <trans-unit id="5eadf7e5be67bb31aac15c710ff80ec7238e0320" translate="yes" xml:space="preserve">
          <source>Weak::weak_count</source>
          <target state="translated">Weak::weak_count</target>
        </trans-unit>
        <trans-unit id="cbd86db606d844ea581cc87e07ebe1432bbeb3e7" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">欢迎&lt;em&gt;使用Rust编程语言&lt;/em&gt;书！此版本的文本假定您在所有项目的&lt;em&gt;Cargo.toml&lt;/em&gt;中使用的是Rust 1.31.0或更高版本，且其 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; ，才能使用Rust 2018 Edition惯用语。请参阅&lt;a href=&quot;book/ch01-01-installation&quot;&gt;第1章&lt;/a&gt;的&amp;ldquo;安装&amp;rdquo;部分以安装或更新Rust，并参阅新的&lt;a href=&quot;book/appendix-05-editions&quot;&gt;附录E&lt;/a&gt;以获取有关Rust版本的信息。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8d0b89eafe83e20d5f86108981d205157dbff45" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">欢迎&lt;em&gt;使用Rust编程语言&lt;/em&gt;书！此版本的文本假定您在所有项目的&lt;em&gt;Cargo.toml&lt;/em&gt;中使用的是Rust 1.31.0或更高版本，且其 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; ，才能使用Rust 2018 Edition惯用语。请参阅&lt;a href=&quot;ch01-01-installation&quot;&gt;第1章&lt;/a&gt;的&amp;ldquo;安装&amp;rdquo;部分以安装或更新Rust，并参阅新的&lt;a href=&quot;appendix-05-editions&quot;&gt;附录E&lt;/a&gt;以获取有关Rust版本的信息。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71aabd16eb59292324e9dfd1470f8e3b8318b16b" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt;, an introductory book about Rust. The Rust programming language helps you write faster, more reliable software. High-level ergonomics and low-level control are often at odds in programming language design; Rust challenges that conflict. Through balancing powerful technical capacity and a great developer experience, Rust gives you the option to control low-level details (such as memory usage) without all the hassle traditionally associated with such control.</source>
          <target state="translated">欢迎&lt;em&gt;使用Rust编程语言&lt;/em&gt;，这是一本有关Rust的入门书籍。 Rust编程语言可帮助您编写更快，更可靠的软件。高级人机工程学和低级控制在编程语言设计中常常是矛盾的。锈病挑战冲突。通过平衡强大的技术能力和出色的开发人员经验，Rust为您提供了控制底层细节（例如内存使用情况）的选项，而无需传统上与此类控制相关的所有麻烦。</target>
        </trans-unit>
        <trans-unit id="def3e0cabaddabefe272409c1a7371052fe52e2f" translate="yes" xml:space="preserve">
          <source>Well done! You&amp;rsquo;ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You&amp;rsquo;re now ready to implement your own Rust projects and help with other peoples&amp;rsquo; projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</source>
          <target state="translated">做得好！您已经完成了这本书的结尾！我们要感谢您加入我们的Rust之旅。现在，您准备实施自己的Rust项目并为其他人的项目提供帮助。请记住，这里有其他Rustaceans的欢迎社区，他们愿意帮助您解决Rust旅途中遇到的任何挑战。</target>
        </trans-unit>
        <trans-unit id="e51a9120a6d90f0f111fa29f2fe00c6bb7da9412" translate="yes" xml:space="preserve">
          <source>What &lt;em id=&quot;what-the-reference-is-not&quot;&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cecc65aff2a51e558a3cf424c55a11b8c31dce1" translate="yes" xml:space="preserve">
          <source>What &lt;em&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">什么不是&lt;em&gt;参考&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f518d8ec17050e8115e7f2ec450de2471cd3f305" translate="yes" xml:space="preserve">
          <source>What Is Ownership?</source>
          <target state="translated">什么是所有权?</target>
        </trans-unit>
        <trans-unit id="70d9b24e457447486228a37f69315f0aa6c48b62" translate="yes" xml:space="preserve">
          <source>What Is a String?</source>
          <target state="translated">什么是字符串?</target>
        </trans-unit>
        <trans-unit id="2368fe52347b12513e40ec057f72fd1310d84880" translate="yes" xml:space="preserve">
          <source>What do I do?</source>
          <target state="translated">我该怎么办?</target>
        </trans-unit>
        <trans-unit id="b31d036160b82937b3f747c02baff101759a7996" translate="yes" xml:space="preserve">
          <source>What expression to evaluate when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition evaluates to &lt;a href=&quot;keyword.false&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2332f8c7d8caf559cd55bda6779e69b9228def" translate="yes" xml:space="preserve">
          <source>What happened? Adding the &lt;code&gt;pub&lt;/code&gt; keyword in front of &lt;code&gt;mod hosting&lt;/code&gt; makes the module public. With this change, if we can access &lt;code&gt;front_of_house&lt;/code&gt;, we can access &lt;code&gt;hosting&lt;/code&gt;. But the &lt;em&gt;contents&lt;/em&gt; of &lt;code&gt;hosting&lt;/code&gt; are still private; making the module public doesn&amp;rsquo;t make its contents public. The &lt;code&gt;pub&lt;/code&gt; keyword on a module only lets code in its ancestor modules refer to it.</source>
          <target state="translated">发生了什么？在 &lt;code&gt;mod hosting&lt;/code&gt; 前面添加 &lt;code&gt;pub&lt;/code&gt; 关键字可使该模块公开。进行此更改后，如果我们可以访问 &lt;code&gt;front_of_house&lt;/code&gt; ，那么我们可以访问 &lt;code&gt;hosting&lt;/code&gt; 。但是，&lt;em&gt;内容&lt;/em&gt;的 &lt;code&gt;hosting&lt;/code&gt; 还是私有的; 公开该模块不会公开其内容。模块上的 &lt;code&gt;pub&lt;/code&gt; 关键字仅允许其祖先模块中的代码引用它。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8765b8c06cc83702c9dbf2bca66a40041316a4f" translate="yes" xml:space="preserve">
          <source>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</source>
          <target state="translated">如果你试图访问一个数组中已经过了数组末尾的元素,会发生什么?假设你把这个例子改成了下面的代码,它可以编译,但运行时却以错误退出。</target>
        </trans-unit>
        <trans-unit id="0903cd7655009ddeab2540796c6a002b16cf56ff" translate="yes" xml:space="preserve">
          <source>What implementing the trait signifies about the type</source>
          <target state="translated">实现特质意味着什么?</target>
        </trans-unit>
        <trans-unit id="a77059cf1db619a698ed5c928ae175c07abb8490" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">什么是 &lt;code&gt;UnwindSafe&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="39c550be471783e69447a16171fe28c441cfa1b6" translate="yes" xml:space="preserve">
          <source>What is in the standard library documentation?</source>
          <target state="translated">标准库文件中有哪些内容?</target>
        </trans-unit>
        <trans-unit id="6be8c40317b2fde07b27b69f6275feba9067a940" translate="yes" xml:space="preserve">
          <source>What is unwind safety?</source>
          <target state="translated">什么是解套安全?</target>
        </trans-unit>
        <trans-unit id="546be1954cedfdfe8c9b6d5ed68a1aba4520048c" translate="yes" xml:space="preserve">
          <source>What operators and methods deriving this trait will enable</source>
          <target state="translated">哪些运算符和方法可以推导出这个特征呢?</target>
        </trans-unit>
        <trans-unit id="8cbcae63b4448efc20dd52bc49133e3cdc73cd42" translate="yes" xml:space="preserve">
          <source>What should the value of &lt;code&gt;answer&lt;/code&gt; be? Should it be &lt;code&gt;З&lt;/code&gt;, the first letter? When encoded in UTF-8, the first byte of &lt;code&gt;З&lt;/code&gt; is &lt;code&gt;208&lt;/code&gt; and the second is &lt;code&gt;151&lt;/code&gt;, so &lt;code&gt;answer&lt;/code&gt; should in fact be &lt;code&gt;208&lt;/code&gt;, but &lt;code&gt;208&lt;/code&gt; is not a valid character on its own. Returning &lt;code&gt;208&lt;/code&gt; is likely not what a user would want if they asked for the first letter of this string; however, that&amp;rsquo;s the only data that Rust has at byte index 0. Users generally don&amp;rsquo;t want the byte value returned, even if the string contains only Latin letters: if &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; were valid code that returned the byte value, it would return &lt;code&gt;104&lt;/code&gt;, not &lt;code&gt;h&lt;/code&gt;. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&amp;rsquo;t compile this code at all and prevents misunderstandings early in the development process.</source>
          <target state="translated">&lt;code&gt;answer&lt;/code&gt; 的价值是什么？应该是 &lt;code&gt;З&lt;/code&gt; ，第一个字母吗？当以UTF-8编码时， &lt;code&gt;З&lt;/code&gt; 的第一个字节为 &lt;code&gt;208&lt;/code&gt; ，第二个字节为 &lt;code&gt;151&lt;/code&gt; ，因此 &lt;code&gt;answer&lt;/code&gt; 实际上应该为 &lt;code&gt;208&lt;/code&gt; ，但 &lt;code&gt;208&lt;/code&gt; 本身不是有效字符。如果用户要求输入此字符串的第一个字母，则返回 &lt;code&gt;208&lt;/code&gt; 可能不是用户想要的。但是，这是Rust拥有字节索引0的唯一数据。即使字符串仅包含拉丁字母，用户也通常不希望返回字节值：如果 &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; 是返回字节值的有效代码，它将返回 &lt;code&gt;104&lt;/code&gt; ，不是 &lt;code&gt;h&lt;/code&gt; 。为了避免返回意外的值并导致可能不会立即发现的错误，Rust完全不编译该代码，并避免了开发过程早期的误解。</target>
        </trans-unit>
        <trans-unit id="104867f147475715b8460879a1886ec236299ab6" translate="yes" xml:space="preserve">
          <source>What the implementation of the trait provided by &lt;code&gt;derive&lt;/code&gt; does</source>
          <target state="translated">什么提供的性状的实施 &lt;code&gt;derive&lt;/code&gt; 呢</target>
        </trans-unit>
        <trans-unit id="813bb1fc77d8fbc02f8d5943beea4d865f45c1f2" translate="yes" xml:space="preserve">
          <source>What this means is that any type of argument which implements the &lt;a href=&quot;trait.binary&quot;&gt;&lt;code&gt;fmt::Binary&lt;/code&gt;&lt;/a&gt; trait can then be formatted with &lt;code&gt;{:b}&lt;/code&gt;. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{:6}&lt;/code&gt;), then the format trait used is the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">这意味着实现&lt;a href=&quot;trait.binary&quot;&gt; &lt;code&gt;fmt::Binary&lt;/code&gt; &lt;/a&gt;特征的任何类型的参数都可以使用 &lt;code&gt;{:b}&lt;/code&gt; 进行格式化。标准库也为许多原始类型提供了针对这些特征的实现。如果未指定格式（如 &lt;code&gt;{}&lt;/code&gt; 或 &lt;code&gt;{:6}&lt;/code&gt; ），则使用的格式特征是&lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;特征。</target>
        </trans-unit>
        <trans-unit id="0093e0ba1575f01e625f11752607bd61339f460b" translate="yes" xml:space="preserve">
          <source>What to do when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition does not hold.</source>
          <target state="translated">&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;条件不成立怎么办。</target>
        </trans-unit>
        <trans-unit id="534b9c0fb827379bcd2c8827a70c556de12f2bc1" translate="yes" xml:space="preserve">
          <source>What we can&amp;rsquo;t see in this example is that when &lt;code&gt;b&lt;/code&gt; and then &lt;code&gt;a&lt;/code&gt; go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, the count is then 0, and the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; is cleaned up completely at that point. Using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</source>
          <target state="translated">我们不能在这个例子中看到的是，当 &lt;code&gt;b&lt;/code&gt; ，然后 &lt;code&gt;a&lt;/code&gt; 在走到底的范围之 &lt;code&gt;main&lt;/code&gt; ，计数为0，然后，和 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在这一点上完全清除。使用 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 允许单个值具有多个所有者，并且计数确保只要任何所有者仍然存在，该值就保持有效。</target>
        </trans-unit>
        <trans-unit id="b08c6969a173d0d359ebf16040e97b732df68a33" translate="yes" xml:space="preserve">
          <source>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?</source>
          <target state="translated">通过共享内存进行交流会是怎样的呢?另外,为什么消息传递爱好者不会使用,反而会反其道而行之呢?</target>
        </trans-unit>
        <trans-unit id="e11dfea032c9cc516196eaa3fe3bafda5d5ff2fa" translate="yes" xml:space="preserve">
          <source>What would happen if we used &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt;? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</source>
          <target state="translated">如果我们使用 &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt; 会发生什么？答案：Rust在运行时会出现恐慌，就像在向量中访问无效索引一样：</target>
        </trans-unit>
        <trans-unit id="3a08543da46101db0a5f909c75d05185352f5e54" translate="yes" xml:space="preserve">
          <source>What would happen to the code in Listing 16-4 where the main thread called &lt;code&gt;drop&lt;/code&gt; if we use a &lt;code&gt;move&lt;/code&gt; closure? Would &lt;code&gt;move&lt;/code&gt; fix that case? Unfortunately, no; we would get a different error because what Listing 16-4 is trying to do isn&amp;rsquo;t allowed for a different reason. If we added &lt;code&gt;move&lt;/code&gt; to the closure, we would move &lt;code&gt;v&lt;/code&gt; into the closure&amp;rsquo;s environment, and we could no longer call &lt;code&gt;drop&lt;/code&gt; on it in the main thread. We would get this compiler error instead:</source>
          <target state="translated">如果使用 &lt;code&gt;move&lt;/code&gt; 闭包，清单16-4中的主线程调用 &lt;code&gt;drop&lt;/code&gt; 的代码会发生什么？将 &lt;code&gt;move&lt;/code&gt; 修正这种情况？抱歉不行; 我们会得到一个不同的错误，因为由于不同的原因，不允许清单16-4试图做的事情。如果将 &lt;code&gt;move&lt;/code&gt; 添加到闭包中，则将 &lt;code&gt;v&lt;/code&gt; 移到闭包的环境中，我们将无法再在主线程中调用 &lt;code&gt;drop&lt;/code&gt; 。我们将得到此编译器错误：</target>
        </trans-unit>
        <trans-unit id="7e42bfeecb6b1e951f9890e0818a295e8fe9a892" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Clone&lt;/code&gt; 什么区别？</target>
        </trans-unit>
        <trans-unit id="c8dcd460b2b3eb060b9c3f227627cad77273bd6e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;extern&quot; Abi?*&lt;/code&gt; is omitted from &lt;code&gt;FunctionQualifiers&lt;/code&gt; in function items, the ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; is assigned. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cd724105e5ed735f83c23d67c2ff48add6811d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary &lt;code&gt;-&lt;/code&gt; on the smallest value of any signed integer type.</source>
          <target state="translated">当 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 时,创建一个大于最大值或小于可以存储的最小值的值。这包括一元数 &lt;code&gt;-&lt;/code&gt; 任何有符号整数类型的最小值。</target>
        </trans-unit>
        <trans-unit id="aec1ff4fb0f51938e677ce85402d7e6e56fa4124" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait2&lt;/code&gt; is a subtrait of &lt;code&gt;Trait1&lt;/code&gt; (for example, when &lt;code&gt;Trait2&lt;/code&gt; has a definition like &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt;), it is not allowed to implement &lt;code&gt;Trait1&lt;/code&gt; for &lt;code&gt;Trait2&lt;/code&gt;. This is because &lt;code&gt;Trait2&lt;/code&gt; already implements &lt;code&gt;Trait1&lt;/code&gt; by definition, so it is not useful to do this.</source>
          <target state="translated">当 &lt;code&gt;Trait2&lt;/code&gt; 是Trait1的子 &lt;code&gt;Trait1&lt;/code&gt; （例如，当 &lt;code&gt;Trait2&lt;/code&gt; 具有类似 &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt; 的定义）时，不允许为 &lt;code&gt;Trait1&lt;/code&gt; 实现 &lt;code&gt;Trait2&lt;/code&gt; 。这是因为 &lt;code&gt;Trait2&lt;/code&gt; 已经通过定义实现了 &lt;code&gt;Trait1&lt;/code&gt; ，所以这样做没有用。</target>
        </trans-unit>
        <trans-unit id="394708bf787cdb05a4155072af4201796f69da61" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait&lt;/code&gt; is treated as a type, the type does not implement the special &lt;code&gt;Sized&lt;/code&gt; trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</source>
          <target state="translated">将 &lt;code&gt;Trait&lt;/code&gt; 视为类型时，该类型不会实现特殊的 &lt;code&gt;Sized&lt;/code&gt; 特征，因为在编译时该类型的大小未知，并且只能在指针后面进行访问。因此，如果我们具有以下特征：</target>
        </trans-unit>
        <trans-unit id="f4fcd22fdc939d17d3b6f99c714199ea75ee05bf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;bar&lt;/code&gt; is the name of a function, then the expression &lt;code&gt;bar&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a function pointer. Rather, it denotes a value of an unnameable type that uniquely identifies the function &lt;code&gt;bar&lt;/code&gt;. The value is zero-sized because the type already identifies the function. This has the advantage that &quot;calling&quot; the value (it implements the &lt;code&gt;Fn*&lt;/code&gt; traits) does not require dynamic dispatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bc0dd59ab0b7fc42f69193dff99dc50f4478aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated, for example:</source>
          <target state="translated">当 &lt;code&gt;break&lt;/code&gt; 遇到，相关联的循环体的执行被立即终止，例如：</target>
        </trans-unit>
        <trans-unit id="b790b4f62a35aeedd4f3d63c2da173a7ec837ca2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c791d46f518801c28641842a73515ec8d559a2ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration is terminated, returning control to the loop head, typically continuing with the next iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595c9458cad4cb9057d8e7fc040fb8866cc8cc3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop &lt;em&gt;head&lt;/em&gt;. In the case of a &lt;code&gt;while&lt;/code&gt; loop, the head is the conditional expression controlling the loop. In the case of a &lt;code&gt;for&lt;/code&gt; loop, the head is the call-expression controlling the loop.</source>
          <target state="translated">当遇到 &lt;code&gt;continue&lt;/code&gt; 时，关联循环主体的当前迭代将立即终止，将控制返回到循环&lt;em&gt;头&lt;/em&gt;。在 &lt;code&gt;while&lt;/code&gt; 循环的情况下，head是控制循环的条件表达式。在 &lt;code&gt;for&lt;/code&gt; 循环的情况下，head是控制循环的调用表达式。</target>
        </trans-unit>
        <trans-unit id="95185630ceafb190a6bbaa449dad38f0bceaa3df" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called by another attributed function &lt;code&gt;g&lt;/code&gt; which is in turn called by &lt;code&gt;calls_g&lt;/code&gt;, code in both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; observes &lt;code&gt;g&lt;/code&gt;'s callsite within &lt;code&gt;calls_g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3d8142d10bdab6df8f2b960ed3b5f595f6be33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called directly by &lt;code&gt;calls_f&lt;/code&gt;, code in &lt;code&gt;f&lt;/code&gt; observes its callsite within &lt;code&gt;calls_f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b714a909447f7628d7a5c65a1ec2d8d650053b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;g&lt;/code&gt; is called by another attributed function &lt;code&gt;h&lt;/code&gt; which is in turn called by &lt;code&gt;calls_h&lt;/code&gt;, all code in &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; observes &lt;code&gt;h&lt;/code&gt;'s callsite within &lt;code&gt;calls_h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a4cd7cb82bb7dfe91312bff7fa4ef245f8f684" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outer&lt;/code&gt; goes out of scope, the &lt;code&gt;drop&lt;/code&gt; method will be called first for &lt;code&gt;Outer&lt;/code&gt;, then for &lt;code&gt;Inner&lt;/code&gt;. Therefore, &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping Outer!&lt;/code&gt; and then &lt;code&gt;Dropping Inner!&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;outer&lt;/code&gt; 去的范围时，该 &lt;code&gt;drop&lt;/code&gt; 方法将首先对被称为 &lt;code&gt;Outer&lt;/code&gt; ，则对于 &lt;code&gt;Inner&lt;/code&gt; 。因此， &lt;code&gt;main&lt;/code&gt; 版画 &lt;code&gt;Dropping Outer!&lt;/code&gt; 然后 &lt;code&gt;Dropping Inner!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a6386c03d530a251bd741f83dfe28d17156802f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s&lt;/code&gt; comes &lt;em&gt;into scope&lt;/em&gt;, it is valid.</source>
          <target state="translated">当 &lt;code&gt;s&lt;/code&gt; 来&lt;em&gt;为范围&lt;/em&gt;，它是有效的。</target>
        </trans-unit>
        <trans-unit id="187902d840e750b40be0f468eec4f29e171a13da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">当未设置 &lt;code&gt;security_qos_flags&lt;/code&gt; 时,恶意程序可以通过诱骗程序打开命名管道来允许其打开用户指定的路径，从而获得特权Rust进程的提升特权。因此可以说在打开任意路径时也应该设置 &lt;code&gt;security_qos_flags&lt;/code&gt; 。但是，这些位可能会与其他标志（特别是 &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; )冲突。</target>
        </trans-unit>
        <trans-unit id="f6050c0d5bfa7ba1d59f28a5f8ace3a1e46fb76d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set, a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5e8e8826bd49e5ed65af5663b42f4dcb6bef45" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;can't&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">我什么时候&lt;em&gt;不能&lt;/em&gt;输入&amp;ldquo; &lt;code&gt;Copy&lt;/code&gt; &amp;rdquo;？</target>
        </trans-unit>
        <trans-unit id="1afd27d775db688aa55a7acd7657368f0252621c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;should&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">我什么时候&lt;em&gt;应该&lt;/em&gt;输入&amp;ldquo; &lt;code&gt;Copy&lt;/code&gt; &amp;rdquo;？</target>
        </trans-unit>
        <trans-unit id="eeffd83a46d46ad1d4f4a9906f6344d685f07825" translate="yes" xml:space="preserve">
          <source>When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances and identifies two kinds of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;: one is &lt;code&gt;i32&lt;/code&gt; and the other is &lt;code&gt;f64&lt;/code&gt;. As such, it expands the generic definition of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into &lt;code&gt;Option_i32&lt;/code&gt; and &lt;code&gt;Option_f64&lt;/code&gt;, thereby replacing the generic definition with the specific ones.</source>
          <target state="translated">当Rust编译此代码时，它将执行单态化。在该过程中，编译器读取 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 实例中已使用的值，并标识两种 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ：一种是 &lt;code&gt;i32&lt;/code&gt; ，另一种是 &lt;code&gt;f64&lt;/code&gt; 。这样，它将 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 的通用定义扩展为 &lt;code&gt;Option_i32&lt;/code&gt; 和 &lt;code&gt;Option_f64&lt;/code&gt; ，从而用特定的替换通用定义。</target>
        </trans-unit>
        <trans-unit id="2db72e30aa272b55473c5bb5758326ffc2e81ae7" translate="yes" xml:space="preserve">
          <source>When Should You Use Which Collection?</source>
          <target state="translated">什么时候应该使用哪种系列?</target>
        </trans-unit>
        <trans-unit id="25db746b33ac06b90cb2c2043d4cbfe8648aece7" translate="yes" xml:space="preserve">
          <source>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don&amp;rsquo;t want to pay in more common cases where we want to execute code that doesn&amp;rsquo;t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</source>
          <target state="translated">当闭包从其环境中捕获值时，它将使用内存来存储要在闭包主体中使用的值。这种内存使用是开销，我们不想在更常见的情况下执行不捕获其环境的代码。由于永远不允许函数捕获其环境，因此定义和使用函数绝不会产生这种开销。</target>
        </trans-unit>
        <trans-unit id="497ca50f155974a1532fc87c50b119765598e81c" translate="yes" xml:space="preserve">
          <source>When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched. Consider using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt; in such cases.</source>
          <target state="translated">当一个功能需要正确对齐时，即使访问的大小为0，即即使实际上未触及内存，也需要进行正确的对齐。在这种情况下，请考虑使用&lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8dfc9c0b52337fbeec4162f45c275f5e1ab922f4" translate="yes" xml:space="preserve">
          <source>When a function returns &lt;code&gt;Pending&lt;/code&gt;, the function &lt;em&gt;must&lt;/em&gt; also ensure that the current task is scheduled to be awoken when progress can be made.</source>
          <target state="translated">当函数返回 &lt;code&gt;Pending&lt;/code&gt; 时，该函数还&lt;em&gt;必须&lt;/em&gt;确保可以安排进度使当前任务被唤醒。</target>
        </trans-unit>
        <trans-unit id="df3a37e739621c9131e28f62bb1b9067e261aa43" translate="yes" xml:space="preserve">
          <source>When a future is not ready yet, &lt;code&gt;poll&lt;/code&gt; returns &lt;code&gt;Poll::Pending&lt;/code&gt; and stores a clone of the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; copied from the current &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; is then woken once the future can make progress. For example, a future waiting for a socket to become readable would call &lt;code&gt;.clone()&lt;/code&gt; on the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; and store it. When a signal arrives elsewhere indicating that the socket is readable, &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt;&lt;code&gt;Waker::wake&lt;/code&gt;&lt;/a&gt; is called and the socket future's task is awoken. Once a task has been woken up, it should attempt to &lt;code&gt;poll&lt;/code&gt; the future again, which may or may not produce a final value.</source>
          <target state="translated">当未来还没有准备好时， &lt;code&gt;poll&lt;/code&gt; 返回 &lt;code&gt;Poll::Pending&lt;/code&gt; 并存储从当前&lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;复制的&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; 的&lt;/a&gt;副本。一旦未来可以进步，这个唤醒&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;就会被唤醒。例如，将来等待套接字变得可读的将在&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;上调用 &lt;code&gt;.clone()&lt;/code&gt; 并将其存储。当信号到达其他地方指示该套接字可读时，将调用&lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt; &lt;code&gt;Waker::wake&lt;/code&gt; &lt;/a&gt;，并唤醒套接字future的任务。任务唤醒后，它应尝试再次 &lt;code&gt;poll&lt;/code&gt; 将来，这可能会或可能不会产生最终值。</target>
        </trans-unit>
        <trans-unit id="0a389975a3b1e10203b84d73debfb669c64513a0" translate="yes" xml:space="preserve">
          <source>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the &lt;code&gt;foo&lt;/code&gt; function here:</source>
          <target state="translated">引用泛型函数时，将根据引用的上下文实例化其类型。例如，在此处调用 &lt;code&gt;foo&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="6dd55c7ab400acdd91bba18da1fe8d01823a4e07" translate="yes" xml:space="preserve">
          <source>When a macro is exported, the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute can have the &lt;code&gt;local_inner_macros&lt;/code&gt; keyword added to automatically prefix all contained macro invocations with &lt;code&gt;$crate::&lt;/code&gt;. This is intended primarily as a tool to migrate code written before &lt;code&gt;$crate&lt;/code&gt; was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.</source>
          <target state="translated">导出宏时，可以在 &lt;code&gt;#[macro_export]&lt;/code&gt; 属性中添加 &lt;code&gt;local_inner_macros&lt;/code&gt; 关键字，以自动为所有包含的宏调用加上 &lt;code&gt;$crate::&lt;/code&gt; 前缀。这主要是用作迁移在将 &lt;code&gt;$crate&lt;/code&gt; 添加到语言中之前编写的代码的工具，以与Rust 2018基于路径的宏导入一起使用。在新代码中不鼓励使用它。</target>
        </trans-unit>
        <trans-unit id="5cf6c55b5740990d2d97e584acaf0732444aabf9" translate="yes" xml:space="preserve">
          <source>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.</source>
          <target state="translated">当一个宏被一个非限定标识符(不是多部分路径的一部分)调用时,首先会在文本范围内进行查找。如果这样做没有得到任何结果,那么就用基于路径的作用域来查找。如果宏的名称用路径限定,则只在基于路径的范围内查找。</target>
        </trans-unit>
        <trans-unit id="da106a1de68be7bf6a4528e441dfbcc8cf456544" translate="yes" xml:space="preserve">
          <source>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a &lt;code&gt;)&lt;/code&gt;, even though that would allow it to parse the invocation unambiguously:</source>
          <target state="translated">调用宏时，宏扩展器按名称查找宏调用，然后依次尝试每个宏规则。它记录第一个成功的比赛；如果这导致错误，则不尝试将来的匹配。匹配时，不执行前瞻；如果编译器不能明确确定一次如何解析宏调用，那么这是一个错误。在以下示例中，编译器不会向前看标识符，以查看以下标记是否为 &lt;code&gt;)&lt;/code&gt; ，即使这将使其能够明确解析调用：</target>
        </trans-unit>
        <trans-unit id="db73e8cf8b50208d0fa9d6efe2409269d6d07431" translate="yes" xml:space="preserve">
          <source>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held &lt;em&gt;in&lt;/em&gt; that memory location. If the type of that value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, then the value will be copied. In the remaining situations if that type is &lt;a href=&quot;special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;, then it may be possible to move the value. Only the following place expressions may be moved out of:</source>
          <target state="translated">当一个地方表达的值表达上下文被评估，或者通过值在模式束缚，但是表示所保持的值&lt;em&gt;在&lt;/em&gt;该存储器位置。如果该值的类型实现&lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，那么将复制该值。在其余情况下，如果该类型为&lt;a href=&quot;special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;，则可以移动该值。只能将以下位置表达式移出：</target>
        </trans-unit>
        <trans-unit id="f1166409c8dae55a33ce311312672ddb4f4b9f7d" translate="yes" xml:space="preserve">
          <source>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an &lt;code&gt;unsafe&lt;/code&gt; block. The compiler will consider uses of such code safe, in the surrounding context.</source>
          <target state="translated">当程序员有足够的信心认为一系列潜在的不安全操作实际上是安全的时，他们可以将该序列（整体上）封装在一个 &lt;code&gt;unsafe&lt;/code&gt; 块中。编译器将在周围环境中安全使用此类代码。</target>
        </trans-unit>
        <trans-unit id="37dbbb1590700cff7b3552010c53f0420bf77ff3" translate="yes" xml:space="preserve">
          <source>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</source>
          <target state="translated">当一个堆栈框架被退出时,它的本地分配全部被释放,它对盒子的引用也被丢弃。</target>
        </trans-unit>
        <trans-unit id="9c30511e183a1aabc7ef13d867dc58fb961ffdbb" translate="yes" xml:space="preserve">
          <source>When a temporary value expression is being created that is assigned into a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt;, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt; would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a &lt;code&gt;let&lt;/code&gt; binding, and therefore deserve a longer temporary lifetime.</source>
          <target state="translated">但是，当创建分配给&lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 声明&lt;/a&gt;的临时值表达式时，将使用封闭块的生存期来创建该临时值，因为使用封闭的&lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 声明&lt;/a&gt;将确保出现错误（因为指向临时块的指针会可以存储到变量中，但可以在使用该变量之前将其释放）。编译器使用简单的语法规则来决定将哪些值分配给 &lt;code&gt;let&lt;/code&gt; 绑定，因此应获得更长的临时寿命。</target>
        </trans-unit>
        <trans-unit id="3039f11f165afd56d3c433b69cd1393d96919902" translate="yes" xml:space="preserve">
          <source>When a tool is not in use, the tool's attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</source>
          <target state="translated">当工具未使用时,工具的属性被接受,没有警告。当工具在使用时,工具负责处理和解释其属性。</target>
        </trans-unit>
        <trans-unit id="57dd9a0351b44496fecb16d4596f4a8247328e39" translate="yes" xml:space="preserve">
          <source>When a trait object is used as a type argument of a generic type, Rust will try to infer its lifetime if unspecified. However, this isn't possible when the containing type has more than one lifetime bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed6434b244126fa9e52f60dea8a8d6ab8918d34" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; does not take any argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746134148fbdc4bec37479d1ea67a6352b384088" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; takes &lt;code&gt;self&lt;/code&gt; as argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa395a4e08ef9a2a05a0ac466a281cf522ff2172" translate="yes" xml:space="preserve">
          <source>When a union is dropped, it cannot know which of its fields needs to be dropped. For this reason, all union fields must either be of a &lt;code&gt;Copy&lt;/code&gt; type or of the shape &lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&amp;lt;_&amp;gt;&lt;/code&gt;&lt;/a&gt;. This ensures that a union does not need to drop anything when it goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9879ea05cdb93dca8c0304f717ae122b1e8ba0" translate="yes" xml:space="preserve">
          <source>When a user calls &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt;, the map will search for the key and then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.</source>
          <target state="translated">当用户调用 &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt; 时，地图将搜索该键，然后生成 &lt;code&gt;Entry&lt;/code&gt; 枚举的变体。</target>
        </trans-unit>
        <trans-unit id="fdd0bd3294966057d48234d31e6f7d296a99309a" translate="yes" xml:space="preserve">
          <source>When a value goes out of scope, it will have its &lt;code&gt;drop&lt;/code&gt; method called if its type implements &lt;code&gt;Drop&lt;/code&gt;. Then, any fields the value contains will also be dropped recursively.</source>
          <target state="translated">当值超出范围时，如果其类型实现 &lt;code&gt;Drop&lt;/code&gt; ，则将调用其 &lt;code&gt;drop&lt;/code&gt; 方法。然后，该值包含的任何字段也将被递归删除。</target>
        </trans-unit>
        <trans-unit id="d7ba61b38031de6106df804542ee455b8b72fed7" translate="yes" xml:space="preserve">
          <source>When a value is no longer needed, Rust will run a &quot;destructor&quot; on that value. The most common way that a value is no longer needed is when it goes out of scope. Destructors may still run in other circumstances, but we're going to focus on scope for the examples here. To learn about some of those other cases, please see &lt;a href=&quot;../../reference/destructors&quot;&gt;the reference&lt;/a&gt; section on destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0821834765580ea9c5440213203fcb1c1cbcdd57" translate="yes" xml:space="preserve">
          <source>When a variable is immutable, once a value is bound to a name, you can&amp;rsquo;t change that value. To illustrate this, let&amp;rsquo;s generate a new project called &lt;em&gt;variables&lt;/em&gt; in your &lt;em&gt;projects&lt;/em&gt; directory by using &lt;code&gt;cargo new variables&lt;/code&gt;.</source>
          <target state="translated">如果变量是不可变的，则将值绑定到名称后，就无法再更改该值。为了说明这一点，让我们通过使用 &lt;code&gt;cargo new variables&lt;/code&gt; 在&lt;em&gt;项目&lt;/em&gt;目录中生成一个名为&lt;em&gt;变量&lt;/em&gt;的新项目。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd9a182b7a78038005ce22938a8bdbd281d7f445" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in Rust goes out of scope or a &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt; is no longer needed its &lt;em&gt;destructor&lt;/em&gt; is run. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, unless it's an uninitialized variable. If a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">当Rust中的&lt;a href=&quot;glossary#initialized&quot;&gt;初始化&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;超出范围或不再需要&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;临时&lt;/a&gt;变量时，将运行其&lt;em&gt;析构函数&lt;/em&gt;。&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;赋值&lt;/a&gt;还会运行其左操作数的析构函数，除非它是未初始化的变量。如果&lt;a href=&quot;types/struct&quot;&gt;结构&lt;/a&gt;变量已被部分初始化，则仅删除其初始化字段。</target>
        </trans-unit>
        <trans-unit id="a5a59a643bd12cd60c0f839e9c5140aa3d6d2e23" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; or &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt; goes out of &lt;a href=&quot;#drop-scopes&quot;&gt;scope&lt;/a&gt; its &lt;em&gt;destructor&lt;/em&gt; is run, or it is &lt;em&gt;dropped&lt;/em&gt;. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, if it's initialized. If a variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c277e0058026b8160091c9cd27bc3ead387a36" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStderr&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStderr&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">当一个实例 &lt;code&gt;ChildStderr&lt;/code&gt; 被&lt;a href=&quot;../ops/trait.drop&quot;&gt;丢弃&lt;/a&gt;时， &lt;code&gt;ChildStderr&lt;/code&gt; 的底层文件句柄将被关闭。</target>
        </trans-unit>
        <trans-unit id="958df1c2da20bb17df895f86bdedaa3ff7514d03" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdin&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdin&lt;/code&gt;'s underlying file handle will be closed. If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.</source>
          <target state="translated">当一个实例 &lt;code&gt;ChildStdin&lt;/code&gt; 被&lt;a href=&quot;../ops/trait.drop&quot;&gt;丢弃&lt;/a&gt;时， &lt;code&gt;ChildStdin&lt;/code&gt; 的底层文件句柄将被关闭。如果子进程在删除之前已在输入上被阻止，则子进程在删除后将变为未阻止。</target>
        </trans-unit>
        <trans-unit id="7f3df133c5feae9ef4d3689b7485515d7c0d45c0" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdout&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdout&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">当一个实例 &lt;code&gt;ChildStdout&lt;/code&gt; 被&lt;a href=&quot;../ops/trait.drop&quot;&gt;丢弃&lt;/a&gt;时， &lt;code&gt;ChildStdout&lt;/code&gt; 的底层文件句柄将被关闭。</target>
        </trans-unit>
        <trans-unit id="19c24a2b0ecc148719938d64be9c4f9999639c3f" translate="yes" xml:space="preserve">
          <source>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</source>
          <target state="translated">当在函数中注释寿命时,注释要放在函数签名中,而不是函数体中。Rust可以在没有任何帮助的情况下分析函数内的代码。然而,当一个函数有对该函数之外的代码的引用或来自该函数之外的代码时,Rust 几乎不可能自己找出参数或返回值的寿命。每次调用函数时,寿命可能都不同。这就是为什么我们需要手动注释寿命的原因。</target>
        </trans-unit>
        <trans-unit id="5eb36c8197085fe87eab8cbaf9a553875da1cc3a" translate="yes" xml:space="preserve">
          <source>When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of methods can be used to hint to the collection how much room it should make for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of these methods will be specific to the collection of interest.</source>
          <target state="translated">当预计会有大量的元素涌入时，可以使用 &lt;code&gt;reserve&lt;/code&gt; 方法来向馆藏暗示应该为即将到来的物品腾出多少空间。与 &lt;code&gt;with_capacity&lt;/code&gt; 一样，这些方法的精确行为将特定于感兴趣的集合。</target>
        </trans-unit>
        <trans-unit id="5869f8bc191d572958f5cd39be698922927ab6f9" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在适用时，首选不稳定排序，因为它通常比稳定排序快，并且不分配辅助内存。参见&lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d79690f38c03573c4c869dcdef6200c1505551cc" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by&quot;&gt;&lt;code&gt;sort_unstable_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在适用时，首选不稳定排序，因为它通常比稳定排序快，并且不分配辅助内存。参见&lt;a href=&quot;#method.sort_unstable_by&quot;&gt; &lt;code&gt;sort_unstable_by&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1e5b5f3c7b4b4a47f33b2043eea612fc9e4a52c" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt;&lt;code&gt;sort_unstable_by_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在适用时，首选不稳定排序，因为它通常比稳定排序快，并且不分配辅助内存。参见&lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt; &lt;code&gt;sort_unstable_by_key&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9457ac5b05fa1acc97622737a2e6a54db8e47e30" translate="yes" xml:space="preserve">
          <source>When applied to a function in an &lt;code&gt;extern&lt;/code&gt; block the attribute must also be applied to any linked implementations, otherwise undefined behavior results. When applied to a function which is made available to an &lt;code&gt;extern&lt;/code&gt; block, the declaration in the &lt;code&gt;extern&lt;/code&gt; block must also have the attribute, otherwise undefined behavior results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a16b324a673b29db2da7d4da32ddcedab4170b" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type, it propagates &lt;code&gt;None&lt;/code&gt;s. If the value is &lt;code&gt;None&lt;/code&gt;, then it will return &lt;code&gt;None&lt;/code&gt;. If applied to &lt;code&gt;Some(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">当应用于 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 类型的值时，它将传播 &lt;code&gt;None&lt;/code&gt; 。如果值为 &lt;code&gt;None&lt;/code&gt; ，则它将返回 &lt;code&gt;None&lt;/code&gt; 。如果应用于 &lt;code&gt;Some(x)&lt;/code&gt; ，则它将解开该值以求值为 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6010016322f07bd48e6ab713e2801cda33b2dfbc" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, it propagates errors. If the value is &lt;code&gt;Err(e)&lt;/code&gt;, then it will return &lt;code&gt;Err(From::from(e))&lt;/code&gt; from the enclosing function or closure. If applied to &lt;code&gt;Ok(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">当应用于 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 类型的值时，它将传播错误。如果值为 &lt;code&gt;Err(e)&lt;/code&gt; ，则它将从封闭函数或闭包中返回 &lt;code&gt;Err(From::from(e))&lt;/code&gt; 。如果应用于 &lt;code&gt;Ok(x)&lt;/code&gt; ，则它将解开该值以求值为 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bc7928c8c171d59b0f5be17006fd056745b554a" translate="yes" xml:space="preserve">
          <source>When applied within a crate, downstream users of the crate will need to use the &lt;code&gt;_&lt;/code&gt; pattern when matching enums and use the &lt;code&gt;..&lt;/code&gt; pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</source>
          <target state="translated">当应用在板条箱中时，板条箱的下游用户在匹配枚举时将需要使用 &lt;code&gt;_&lt;/code&gt; 模式，而在与结构体匹配时将使用 &lt;code&gt;..&lt;/code&gt; 模式。下游板条箱无法与非穷举的枚举变量匹配。</target>
        </trans-unit>
        <trans-unit id="7b7ce408de1692c1cce1be5c86062fc2d1aa15ec" translate="yes" xml:space="preserve">
          <source>When are these warnings going to turn into errors?</source>
          <target state="translated">这些警告什么时候才会变成错误?</target>
        </trans-unit>
        <trans-unit id="93dc9e73dc6c00708f0214c1f73e691c8c3e8698" translate="yes" xml:space="preserve">
          <source>When associated with &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop. This is only valid with &lt;code&gt;loop&lt;/code&gt; and not with any other type of loop. If no value is specified, &lt;code&gt;break;&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt;. Every &lt;code&gt;break&lt;/code&gt; within a loop must return the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2ee129e76133ba53a5ea99826864278fbc53d" translate="yes" xml:space="preserve">
          <source>When associated with a &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop, via one of the forms &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;, where &lt;code&gt;EXPR&lt;/code&gt; is an expression whose result is returned from the &lt;code&gt;loop&lt;/code&gt;. For example:</source>
          <target state="translated">当与相关联的 &lt;code&gt;loop&lt;/code&gt; ，一休表达可被用于从该循环返回一个值，通过的形式之一 &lt;code&gt;break EXPR&lt;/code&gt; 或 &lt;code&gt;break 'label EXPR&lt;/code&gt; ，其中 &lt;code&gt;EXPR&lt;/code&gt; 是指其结果是从返回的表达式 &lt;code&gt;loop&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="4a763dfd452f118669800efdde464c1dbe786ee4" translate="yes" xml:space="preserve">
          <source>When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So &lt;code&gt;usize&lt;/code&gt; is &lt;code&gt;32&lt;/code&gt; bits if you are compiling against a &lt;code&gt;32&lt;/code&gt; bit system, irrelevant of whether you are building on a &lt;code&gt;64&lt;/code&gt; bit or a &lt;code&gt;32&lt;/code&gt; bit system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47843d04159de5ef9116ac80f96bd39967f9187" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;product()&lt;/code&gt; and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">当调用 &lt;code&gt;product()&lt;/code&gt; 并返回原始整数类型时，如果计算溢出并启用了调试断言，则方法将出现恐慌。</target>
        </trans-unit>
        <trans-unit id="e4216881c81bce1d1b8084df44f2b67955efbb5a" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">当调用 &lt;code&gt;sum()&lt;/code&gt; 并返回原始整数类型时，如果计算溢出并且启用了调试断言，则此方法将出现恐慌。</target>
        </trans-unit>
        <trans-unit id="ad8c85712072b3d065a1d9c78cdc29d373ce9764" translate="yes" xml:space="preserve">
          <source>When calling methods with the same name, you&amp;rsquo;ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we&amp;rsquo;ve defined two traits, &lt;code&gt;Pilot&lt;/code&gt; and &lt;code&gt;Wizard&lt;/code&gt;, that both have a method called &lt;code&gt;fly&lt;/code&gt;. We then implement both traits on a type &lt;code&gt;Human&lt;/code&gt; that already has a method named &lt;code&gt;fly&lt;/code&gt; implemented on it. Each &lt;code&gt;fly&lt;/code&gt; method does something different.</source>
          <target state="translated">当调用具有相同名称的方法时，您需要告诉Rust要使用哪个方法。考虑清单19-16中的代码，其中我们定义了两个特性 &lt;code&gt;Pilot&lt;/code&gt; 和 &lt;code&gt;Wizard&lt;/code&gt; ，它们都具有一个称为 &lt;code&gt;fly&lt;/code&gt; 的方法。然后，我们在 &lt;code&gt;Human&lt;/code&gt; 类型上实现这两个特征，该类型已经在其上实现了名为 &lt;code&gt;fly&lt;/code&gt; 的方法。每种 &lt;code&gt;fly&lt;/code&gt; 方法都做不同的事情。</target>
        </trans-unit>
        <trans-unit id="09c7e5de85184f1e292948f95737d163821f3f97" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that &lt;em&gt;either&lt;/em&gt; the pointer is NULL &lt;em&gt;or&lt;/em&gt; all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5922155f29f105357a025f039108b9a7d5336187" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58559539ea94cb174e20c16d3a491d3f60daa52c" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">调用此方法时，你必须确保，如果指针非NULL，那么它是正确对齐，dereferencable（对于全尺寸 &lt;code&gt;T&lt;/code&gt; ）和指向的初始化实例 &lt;code&gt;T&lt;/code&gt; 。即使未使用此方法的结果也是如此！ （关于初始化的部分尚未完全确定，但是直到唯一安全的方法是确保它们确实被初始化。）</target>
        </trans-unit>
        <trans-unit id="154fd499f0df8e4395e27a0bd336a9bcab4964e5" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">调用此方法时，你必须确保，如果指针非NULL，那么它是正确对齐，dereferencable（对于全尺寸 &lt;code&gt;T&lt;/code&gt; ）和指向的初始化实例 &lt;code&gt;T&lt;/code&gt; 。即使未使用此方法的结果也是如此！（关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。）</target>
        </trans-unit>
        <trans-unit id="b55e6ba28b9895615b66213ef2f73826e6f58739" translate="yes" xml:space="preserve">
          <source>When can my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">我什么时候可以 &lt;code&gt;Copy&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="cee1d8053db523d0e331e35fb72c4806ed64bb77" translate="yes" xml:space="preserve">
          <source>When casting, keep in mind that only primitive types can be cast into each other. Example:</source>
          <target state="translated">当投射时,请记住,只有基元类型可以相互投射。例如</target>
        </trans-unit>
        <trans-unit id="d4a2dc7caf12d861d68e9e941b267ef0330f899f" translate="yes" xml:space="preserve">
          <source>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their addition data compared.</source>
          <target state="translated">当比较指针时，它们是通过它们的地址而不是它们指向的对象来比较的。当将指针与&lt;a href=&quot;../dynamically-sized-types&quot;&gt;动态大小的类型&lt;/a&gt;进行比较时，它们还将其附加数据进行比较。</target>
        </trans-unit>
        <trans-unit id="f2f745dfedc8e3dcf7cd93386db2954df66d81dc" translate="yes" xml:space="preserve">
          <source>When comparing raw pointers they are compared by their address, rather than by what they point to. When comparing raw pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their additional data compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a443c0cb167970fd613da945b3f247baaf5ed2" translate="yes" xml:space="preserve">
          <source>When comparison is impossible:</source>
          <target state="translated">当比较是不可能的。</target>
        </trans-unit>
        <trans-unit id="09f829ddc19ecb8dff523da8b6aa0bd5c5c69a9a" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e1556a905fd63df9a9011e6b9eaa088ecbd8b" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">与加载耦合时，如果加载的值是由具有&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;（或更高级）排序的存储操作写入的，则所有后续操作在该存储之后都将被排序。特别是，所有后续加载将看到在存储之前写入的数据。</target>
        </trans-unit>
        <trans-unit id="c91753b6ff7ee275cf69a5dce0e73e0bd2e33946" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96f1d52823f389b197a0d9cfba10684464e92e3" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">与商店耦合时，所有以前的操作都将在使用&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;（或更强）排序对该值进行任何加载之前进行排序。特别是，所有以前的写入操作对执行此值的&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;（或更强）加载的所有线程均可见。</target>
        </trans-unit>
        <trans-unit id="c5257416252adc45097a1b4beca1249797335afe" translate="yes" xml:space="preserve">
          <source>When created, cursors start at the front of the list, or the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d1a77fcc1e6a3499230bbe1efaa4ab2267c420" translate="yes" xml:space="preserve">
          <source>When creating immutable and mutable references, we use the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; syntax, respectively. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we use the &lt;code&gt;borrow&lt;/code&gt; and &lt;code&gt;borrow_mut&lt;/code&gt; methods, which are part of the safe API that belongs to &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;borrow&lt;/code&gt; method returns the smart pointer type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;borrow_mut&lt;/code&gt; returns the smart pointer type &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt;. Both types implement &lt;code&gt;Deref&lt;/code&gt;, so we can treat them like regular references.</source>
          <target state="translated">创建不可变和可变引用时，我们分别使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 语法。与 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，我们用 &lt;code&gt;borrow&lt;/code&gt; 和 &lt;code&gt;borrow_mut&lt;/code&gt; 方法，这是属于安全API的一部分 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 。的 &lt;code&gt;borrow&lt;/code&gt; 方法返回智能指针类型 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;borrow_mut&lt;/code&gt; 返回智能指针类型 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 。两种类型都实现 &lt;code&gt;Deref&lt;/code&gt; ，因此我们可以将它们视为常规引用。</target>
        </trans-unit>
        <trans-unit id="d153302e6c43d39140a619c03bdcafd574d25849" translate="yes" xml:space="preserve">
          <source>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. Using procedural macros looks like the code in Listing 19-29, where &lt;code&gt;some_attribute&lt;/code&gt; is a placeholder for using a specific macro.</source>
          <target state="translated">创建过程宏时，定义必须驻留在自己的带有特殊板条箱类型的板条箱中。这是由于复杂的技术原因，我们希望将来消除。使用过程宏看起来像清单19-29中的代码，其中 &lt;code&gt;some_attribute&lt;/code&gt; 是使用特定宏的占位符。</target>
        </trans-unit>
        <trans-unit id="ba2b321ad5c05c7fd09164d2ee9abbba93ac268f" translate="yes" xml:space="preserve">
          <source>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</source>
          <target state="translated">在定义一个使用泛型的函数时,我们将泛型放在函数的签名中,通常我们会在这里指定参数和返回值的数据类型。这样做可以使我们的代码更加灵活,为函数的调用者提供更多的功能,同时防止代码重复。</target>
        </trans-unit>
        <trans-unit id="649a6e7ed2c9379226547d6e7e75e552d9d288ba" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">定义递归结构或枚举时，从定义内部定义的类型的任何使用都必须在指针后面（例如 &lt;code&gt;Box&lt;/code&gt; 或 &lt;code&gt;&amp;amp;&lt;/code&gt; ）进行。这是因为结构和枚举必须具有定义良好的大小，并且如果没有指针，则类型的大小将需要不受限制。</target>
        </trans-unit>
        <trans-unit id="54e2930486f06054c79b2d368c2769ebefeaab63" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7f1bc79b8fb9a6a685b72bb3e271975e8e2732" translate="yes" xml:space="preserve">
          <source>When derived on structs, &lt;code&gt;PartialOrd&lt;/code&gt; compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</source>
          <target state="translated">当从结构派生时， &lt;code&gt;PartialOrd&lt;/code&gt; 通过按字段在结构定义中出现的顺序比较每个字段中的值来比较两个实例。当从枚举派生时，在枚举定义中较早声明的枚举的变体被认为小于后面列出的变体。</target>
        </trans-unit>
        <trans-unit id="f282c8c6369ef0fd139eb8e2fef3f5aed8dab06e" translate="yes" xml:space="preserve">
          <source>When enabled, this socket is allowed to send packets to a broadcast address.</source>
          <target state="translated">启用后,允许该套接字向广播地址发送数据包。</target>
        </trans-unit>
        <trans-unit id="761e5afed23cf69a708babbaebf38541084e7e71" translate="yes" xml:space="preserve">
          <source>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final expression is executed, if given.</source>
          <target state="translated">在评估块表达式时,除了项目声明语句外,每条语句都会依次执行。如果给定,则执行最后的表达式。</target>
        </trans-unit>
        <trans-unit id="ee1fcd0e31ceced99f1f3ec881706ad2610edecf" translate="yes" xml:space="preserve">
          <source>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The &lt;code&gt;ident&lt;/code&gt;, &lt;code&gt;lifetime&lt;/code&gt;, and &lt;code&gt;tt&lt;/code&gt; fragment types are an exception, and &lt;em&gt;can&lt;/em&gt; be matched by literal tokens. The following illustrates this restriction:</source>
          <target state="translated">例如，将匹配的片段转发到另一个宏时，第二个宏中的匹配器将看到片段类型的不透明AST。第二个宏不能使用文字标记来匹配匹配器中的片段，只能使用相同类型的片段说明符。的 &lt;code&gt;ident&lt;/code&gt; ， &lt;code&gt;lifetime&lt;/code&gt; ，和 &lt;code&gt;tt&lt;/code&gt; 的片段类型是一个例外，并且&lt;em&gt;可以&lt;/em&gt;由数字令牌相匹配。以下说明了此限制：</target>
        </trans-unit>
        <trans-unit id="9aca28029ce8b3b95a609b5e4ca6542143135bed" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; implementation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0607e7e68ca3e721e6db0ea6bb7b2aa2a0922c" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;code&gt;poll&lt;/code&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;code&gt;poll&lt;/code&gt; implementation).</source>
          <target state="translated">在实现&lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;组合器时，通常需要对嵌套的Future进行结构固定，因为您需要获取对其的固定引用以调用 &lt;code&gt;poll&lt;/code&gt; 。但是，如果您的组合器包含不需要固定的任何其他数据，则可以使这些字段不具有结构性，因此即使您只有 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; （例如，在您自己的 &lt;code&gt;poll&lt;/code&gt; 实现中），也可以使用可变引用自由地访问它们）。</target>
        </trans-unit>
        <trans-unit id="3023d431ee0ca325e5e6237d2618e2a98462263f" translate="yes" xml:space="preserve">
          <source>When implementing a foreign trait for a foreign type, the trait must have one or more type parameters. A type local to your crate must appear before any use of any type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83728ab8db088c5c5e2bb91d0aa5ec68f4bff8ed" translate="yes" xml:space="preserve">
          <source>When implementing a format trait for your own type, you will have to implement a method of the signature:</source>
          <target state="translated">在为自己的类型实现格式特征时,你必须实现签名的方法。</target>
        </trans-unit>
        <trans-unit id="f71a495d94aa8ee98863b069031787f4cf122fc5" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b12d14018112fa67f152d3bcca4ff8a3cd2e160" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">在实现 &lt;code&gt;ExactSizeIterator&lt;/code&gt; 时，还必须实现&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;。这样做时，&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt;的实现&lt;em&gt;必须&lt;/em&gt;返回迭代器的确切大小。</target>
        </trans-unit>
        <trans-unit id="fc5662685206bca89b1530dcc1f9af41c4eb9eca" translate="yes" xml:space="preserve">
          <source>When implementing both &lt;code&gt;Hash&lt;/code&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;, it is important that the following property holds:</source>
          <target state="translated">同时实现 &lt;code&gt;Hash&lt;/code&gt; 和&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; 时&lt;/a&gt;，重要的是要保留以下属性：</target>
        </trans-unit>
        <trans-unit id="d4e13d31485717c35b3ad17ef91b724897ba5adb" translate="yes" xml:space="preserve">
          <source>When implementing this trait for &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; we need to pick a type for &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. And since converting a string into a string will never result in an error, the appropriate type is &lt;code&gt;!&lt;/code&gt;. (Currently the type actually used is an enum with no variants, though this is only because &lt;code&gt;!&lt;/code&gt; was added to Rust at a later date and it may change in the future.) With an &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type of &lt;code&gt;!&lt;/code&gt;, if we have to call &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;String::from_str&lt;/code&gt;&lt;/a&gt; for some reason the result will be a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt;&lt;/a&gt; which we can unpack like this:</source>
          <target state="translated">在为&lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;实现此特征时，我们需要为&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;选择一个类型。并且由于将字符串转换为字符串永远不会导致错误，因此合适的类型是 &lt;code&gt;!&lt;/code&gt; 。（当前实际使用的类型是没有变体的枚举，尽管这仅是因为 &lt;code&gt;!&lt;/code&gt; 是在以后的日期中添加到Rust的，并且将来可能会更改。）&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;类型为 &lt;code&gt;!&lt;/code&gt; 的，如果由于某种原因我们必须调用&lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;String::from_str&lt;/code&gt; &lt;/a&gt;，结果将是&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt; &lt;/a&gt;，我们可以像这样解压缩：</target>
        </trans-unit>
        <trans-unit id="7aa4b7fd6580c50f7056a94460fc482fde8db6bd" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;code&gt;Slice&lt;/code&gt; you simply provide the value &lt;code&gt;PhantomData&lt;/code&gt; for the field &lt;code&gt;phantom&lt;/code&gt;:</source>
          <target state="translated">初始化 &lt;code&gt;Slice&lt;/code&gt; 时,您只需为 &lt;code&gt;phantom&lt;/code&gt; 字段提供值 &lt;code&gt;PhantomData&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="891072d4b25628183370abc4a215b4cbe1b78b5f" translate="yes" xml:space="preserve">
          <source>When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write &lt;code&gt;fieldname&lt;/code&gt; as a shorthand for &lt;code&gt;fieldname: fieldname&lt;/code&gt;. This allows a compact syntax with less duplication. For example:</source>
          <target state="translated">当使用已命名（但未编号）字段初始化数据结构（struct，enum，union）时，可以将 &lt;code&gt;fieldname&lt;/code&gt; 作为 &lt;code&gt;fieldname: fieldname&lt;/code&gt; 的简写形式。这允许使用较少重复的紧凑语法。例如：</target>
        </trans-unit>
        <trans-unit id="8ecea1e59f3ed90e0cce7be9457c55eec0b2f8dd" translate="yes" xml:space="preserve">
          <source>When invoking closures or other implementations of the function traits &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; using call notation, the number of parameters passed to the function must match its definition.</source>
          <target state="translated">使用调用表示法调用函数特征 &lt;code&gt;Fn&lt;/code&gt; ， &lt;code&gt;FnMut&lt;/code&gt; 或 &lt;code&gt;FnOnce&lt;/code&gt; 的闭包或其他实现时，传递给该函数的参数数量必须与其定义相匹配。</target>
        </trans-unit>
        <trans-unit id="ccc9f327284b4385f76159eac1f35c501745b8a3" translate="yes" xml:space="preserve">
          <source>When looking for the implementation for the trait, the compiler finds both the &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; where T is all types and the &lt;code&gt;impl MyTrait for Foo&lt;/code&gt;. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</source>
          <target state="translated">在寻找特征的实现时，编译器会找到 &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; 的impl &amp;lt;T&amp;gt; MyTrait（其中T是所有类型）和 &lt;code&gt;impl MyTrait for Foo&lt;/code&gt; 的impl MyTrait。由于特征不能多次实现，因此这是一个错误。所以，当你写：</target>
        </trans-unit>
        <trans-unit id="696c7265bd3688072f55c2cbcd990beecd847885" translate="yes" xml:space="preserve">
          <source>When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</source>
          <target state="translated">在查找方法调用时,为了调用一个方法,可能会自动去引用或借用接收器。这就需要一个比其他函数更复杂的查找过程,因为可能有很多可能的方法要调用。采用以下程序。</target>
        </trans-unit>
        <trans-unit id="9b2a422583a7efee3ed72f17d4f2851e1858e60e" translate="yes" xml:space="preserve">
          <source>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</source>
          <target state="translated">当与一个范围匹配时,编译器会验证该范围是非空的。范围模式包括两个端点,所以这相当于要求范围的开始小于或等于范围的结束。</target>
        </trans-unit>
        <trans-unit id="b9653a3e395619856456d73e03e247c655234f5c" translate="yes" xml:space="preserve">
          <source>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</source>
          <target state="translated">当与独占范围匹配时,编译器会验证该范围是非空的。排他性范围模式包括起点但不包括终点,所以这相当于要求范围的起点小于范围的终点。</target>
        </trans-unit>
        <trans-unit id="b0e0c88f0138777df9f95477c6fa805a498782e3" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8087590aa98711c0675fa786398706bd350ddbdc" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</source>
          <target state="translated">当对一个变量进行匹配时,不能在匹配守卫中进行突变,因为这会导致匹配不详尽。</target>
        </trans-unit>
        <trans-unit id="c917207922c15bc47219fc846ecafbebb3833877" translate="yes" xml:space="preserve">
          <source>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when &lt;code&gt;Cargo.toml&lt;/code&gt; doesn't specify a crate name, Cargo will transparently replace &lt;code&gt;-&lt;/code&gt; with &lt;code&gt;_&lt;/code&gt; (Refer to &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; for more details).</source>
          <target state="translated">在命名Rust板条箱时，不允许使用连字符。但是，货物包装可能会利用它们。在这种情况下，当 &lt;code&gt;Cargo.toml&lt;/code&gt; 没有指定箱子的名称，货物将透明代替 &lt;code&gt;-&lt;/code&gt; 用 &lt;code&gt;_&lt;/code&gt; （参见&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt;的更多细节）。</target>
        </trans-unit>
        <trans-unit id="4b84b0246e3a22cc957323594b187a4ee8d486c1" translate="yes" xml:space="preserve">
          <source>When only a single thread is involved, the results are as expected: the line &lt;code&gt;7 4 4&lt;/code&gt; gets printed.</source>
          <target state="translated">当仅涉及单个线程时，结果将达到预期：打印第 &lt;code&gt;7 4 4&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="631b2d61cf855b93c1989c5cb6e1c8291602cdf2" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">在控制台中操作时,该流的Windows实现不支持非UTF-8字节序列。试图读取非有效的UTF-8字节将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="dbaed3bc410762aacbeb0a4e72c167df5ec7b452" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">在控制台中操作时,该流的Windows实现不支持非UTF-8字节序列。试图写入非有效的UTF-8字节将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="6a8905858177aefd0e233b7b17c0d7132a07f2ef" translate="yes" xml:space="preserve">
          <source>When parsing the path, there is a small amount of normalization:</source>
          <target state="translated">在解析路径时,会有少量的归一化。</target>
        </trans-unit>
        <trans-unit id="de65f313906013336610f9ce397839cdfeef65dc" translate="yes" xml:space="preserve">
          <source>When pattern matching on a non-exhaustive &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt;, matching on a variant does not contribute towards the exhaustiveness of the arms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9f5f5346d0d53afbe7e6c96b99054e854e83d4" translate="yes" xml:space="preserve">
          <source>When pattern matching on a non-exhaustive variant (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; variant&lt;/a&gt;), a &lt;a href=&quot;../patterns#struct-patterns&quot;&gt;&lt;em&gt;StructPattern&lt;/em&gt;&lt;/a&gt; must be used which must include a &lt;code&gt;..&lt;/code&gt;. Tuple variant constructor visibility is lowered to &lt;code&gt;min($vis, pub(crate))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822f9e7b18bc62d671d8d3984cc7775a10aa571" translate="yes" xml:space="preserve">
          <source>When re-exporting a private item, it can be thought of as allowing the &quot;privacy chain&quot; being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</source>
          <target state="translated">当重新导出一个私有项目时,可以认为是允许 &quot;隐私链 &quot;通过重新导出被短路,而不是像通常那样通过命名空间层次结构。</target>
        </trans-unit>
        <trans-unit id="9af3e2801218bbefe9fcf6ba2cdb6292e76c830f" translate="yes" xml:space="preserve">
          <source>When referred to, a &lt;em&gt;function&lt;/em&gt; yields a first-class &lt;em&gt;value&lt;/em&gt; of the corresponding zero-sized &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;function item type&lt;/em&gt;&lt;/a&gt;, which when called evaluates to a direct call to the function.</source>
          <target state="translated">引用时，&lt;em&gt;函数会&lt;/em&gt;产生相应的零大小&lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;函数项类型&lt;/em&gt;&lt;/a&gt;的第一类&lt;em&gt;值&lt;/em&gt;，当调用该函数时，该值会求直接调用该函数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683091416dacec74442beb6b8e2ae04cddfafa2" translate="yes" xml:space="preserve">
          <source>When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its &lt;em&gt;function item type&lt;/em&gt;. That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</source>
          <target state="translated">引用功能项或类似元组的struct或enum的构造&lt;em&gt;函数时&lt;/em&gt;，其&lt;em&gt;功能项类型&lt;/em&gt;的大小为零。该类型明确标识了该函数-其名称，其类型参数和其早期绑定的生存期参数（但不是其后期绑定的生存期参数，后者仅在调用函数时才分配）-因此，该值不需要包含实际的函数指针，并且在调用函数时不需要间接调用。</target>
        </trans-unit>
        <trans-unit id="242796f19057c3b62462e9cba8dd8c2590aadff7" translate="yes" xml:space="preserve">
          <source>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</source>
          <target state="translated">当涉及重复时,规则适用于所有可能的扩展数,并考虑到分隔符。这意味着:</target>
        </trans-unit>
        <trans-unit id="c3d84541bce134cd9e4b390eb66c9f391f2b9c11" translate="yes" xml:space="preserve">
          <source>When requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via &lt;code&gt;{:x}&lt;/code&gt; (like &lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;). The current mapping of types to traits is:</source>
          <target state="translated">当要求将参数格式化为特定类型时，实际上是在要求参数归因于特定特征。这允许通过 &lt;code&gt;{:x}&lt;/code&gt; 格式化多个实际类型（例如&lt;a href=&quot;../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt;以及&lt;a href=&quot;../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt;）。当前类型到特征的映射为：</target>
        </trans-unit>
        <trans-unit id="172f2234ac85fe1a3605f2a91c946d179cec1a7e" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0).</source>
          <target state="translated">当返回值溢出时（即， &lt;code&gt;uN&lt;/code&gt; 类型的 &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; ），它将在调试模式下崩溃，在释放模式下返回值包装为0（唯一的方法可以返回0的情况） 。</target>
        </trans-unit>
        <trans-unit id="edd8cc343e5de387a9b54e7b83ae697de445cc0a" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), overflows to &lt;code&gt;2^N = 0&lt;/code&gt;.</source>
          <target state="translated">当返回值溢出时（即 &lt;code&gt;uN&lt;/code&gt; 类型的 &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; ），溢出到 &lt;code&gt;2^N = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba5cb533c56f4e80ee649a64f4f48b9916ee9878" translate="yes" xml:space="preserve">
          <source>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does &lt;em&gt;not&lt;/em&gt; refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the &lt;code&gt;longest&lt;/code&gt; function that won&amp;rsquo;t compile:</source>
          <target state="translated">从函数返回引用时，返回类型的有效期参数需要与其中一个参数的有效期参数匹配。如果返回的引用&lt;em&gt;未&lt;/em&gt;引用参数之一，则它必须引用在此函数内创建的值，该值将是悬空引用，因为该值将在函数末尾超出范围。考虑一下 &lt;code&gt;longest&lt;/code&gt; 函数无法编译的这种尝试实现：</target>
        </trans-unit>
        <trans-unit id="9ba5a0cad76ddab0bb154107936aabf9c3bbc80c" translate="yes" xml:space="preserve">
          <source>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</source>
          <target state="translated">当运行清单16-10中的代码时,你应该看到以下输出,每行之间有1秒的停顿。</target>
        </trans-unit>
        <trans-unit id="6b236fc247e64f3c8aa065d156b22dcb57f154a9" translate="yes" xml:space="preserve">
          <source>When searching for a value in the map, however, having to provide a reference to a &lt;code&gt;K&lt;/code&gt; as the key to search for would require to always create such an owned value. For string keys, this would mean a &lt;code&gt;String&lt;/code&gt; value needs to be created just for the search for cases where only a &lt;code&gt;str&lt;/code&gt; is available.</source>
          <target state="translated">但是，当在地图中搜索值时，必须提供对 &lt;code&gt;K&lt;/code&gt; 的引用作为搜索关键字，这将需要始终创建此类拥有的值。对于字符串键，这意味着仅在搜索只有 &lt;code&gt;str&lt;/code&gt; 可用的情况下才需要创建 &lt;code&gt;String&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="b091e7c5109a4bd476e6a41500e0c7dae79d2e20" translate="yes" xml:space="preserve">
          <source>When should &lt;code&gt;UnwindSafe&lt;/code&gt; be used?</source>
          <target state="translated">何时应使用 &lt;code&gt;UnwindSafe&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="e948e1fccd691ef6c810406fc6cc8816126b310a" translate="yes" xml:space="preserve">
          <source>When starting from a slice rather than an array, fallible conversion APIs can be used:</source>
          <target state="translated">当从分片而不是数组开始时,可以使用易错的转换API。</target>
        </trans-unit>
        <trans-unit id="9972ed917e94de2af5e7cf0dfc874ef3575cd482" translate="yes" xml:space="preserve">
          <source>When such a string in &lt;code&gt;monospace&lt;/code&gt; font occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; for more information.</source>
          <target state="translated">当这种 &lt;code&gt;monospace&lt;/code&gt; 字体的字符串出现在语法内部时，它是对这种字符串表产生的单个成员的隐式引用。有关更多信息，请参见&lt;a href=&quot;tokens&quot;&gt;令牌&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a52c1f9d28a81019545579685f71cebe8cd39993" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; on the same stream can cause data loss. Reading from the underlying reader after unwrapping the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.bufreader#method.into_inner&quot;&gt;&lt;code&gt;BufReader::into_inner&lt;/code&gt;&lt;/a&gt; can also cause data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954b4d58192a34fc7c83e90ef17c03453e2596e2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&lt;/code&gt; on the same stream can cause data loss.</source>
          <target state="translated">当 &lt;code&gt;BufReader&lt;/code&gt; 被丢弃，其缓冲区的内容将被丢弃。在同 &lt;code&gt;BufReader&lt;/code&gt; 上创建BufReader的多个实例可能会导致数据丢失。</target>
        </trans-unit>
        <trans-unit id="f6535869e34b4050ebcca71930a99c22bd0cf5ef" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufWriter&lt;/code&gt; is dropped, the contents of its buffer will be written out. However, any errors that happen in the process of flushing the buffer when the writer is dropped will be ignored. Code that wishes to handle such errors must manually call &lt;a href=&quot;#method.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before the writer is dropped.</source>
          <target state="translated">当 &lt;code&gt;BufWriter&lt;/code&gt; 被删除，它的缓冲区的内容将被写入了。但是，删除写入器时在刷新缓冲区的过程中发生的任何错误都将被忽略。希望处理此类错误的代码必须在删除&lt;a href=&quot;#method.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;之前手动调用flush。</target>
        </trans-unit>
        <trans-unit id="04aee49349dde3129af240e6a8534c1c64ddefad" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Deref&lt;/code&gt; trait is defined for the types involved, Rust will analyze the types and use &lt;code&gt;Deref::deref&lt;/code&gt; as many times as necessary to get a reference to match the parameter&amp;rsquo;s type. The number of times that &lt;code&gt;Deref::deref&lt;/code&gt; needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</source>
          <target state="translated">当 &lt;code&gt;Deref&lt;/code&gt; 性状所涉及的类型定义，锈病将分析类型和使用 &lt;code&gt;Deref::deref&lt;/code&gt; 多次需要得到一个参考，以匹配参数的类型。需要插入 &lt;code&gt;Deref::deref&lt;/code&gt; 的次数在编译时已解决，因此，利用deref强制不会造成运行时损失！</target>
        </trans-unit>
        <trans-unit id="31fb02d0ce651e092ef0bf35613e23e7b377e4aa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;get&lt;/code&gt; method is passed an index that is outside the vector, it returns &lt;code&gt;None&lt;/code&gt; without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that&amp;rsquo;s too large and the program gets a &lt;code&gt;None&lt;/code&gt; value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!</source>
          <target state="translated">当将 &lt;code&gt;get&lt;/code&gt; 方法传递给向量之外的索引时，它将返回 &lt;code&gt;None&lt;/code&gt; 且不会惊慌。如果在正常情况下偶尔访问超出向量范围的元素，则可以使用此方法。然后，您的代码将具有处理 &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; 的逻辑，如第6章所述。例如，索引可能来自输入数字的人。如果他们不小心输入了一个太大的数字，并且程序获得了 &lt;code&gt;None&lt;/code&gt; 值，则可以告诉用户当前向量中有多少个项目，并给他们另一个输入有效值的机会。这将比由于输入错误而使程序崩溃更人性化！</target>
        </trans-unit>
        <trans-unit id="f59c09946d769635e38aad7d10ee44a827a7f14d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn&amp;rsquo;t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our &lt;code&gt;match&lt;/code&gt; has four arms.</source>
          <target state="translated">当 &lt;code&gt;match&lt;/code&gt; 表达式执行时，它会按顺序将结果值与每个手臂的模式进行比较。如果某个模式与该值匹配，那么将执行与该模式关联的代码。如果该模式与值不匹配，则执行继续到下一个分支，就像在硬币分类机中一样。我们可以根据需要提供任意数量的武器：在清单6-3中，我们的 &lt;code&gt;match&lt;/code&gt; 有4个武器。</target>
        </trans-unit>
        <trans-unit id="35dd3cadb8620e015a10c1b7eff5115846f46fce" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression is done, its scope ends, and so does the scope of the inner &lt;code&gt;y&lt;/code&gt;. The last &lt;code&gt;println!&lt;/code&gt; produces &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;match&lt;/code&gt; 表达式完成时，它的范围的端部，所以确实内的范围 &lt;code&gt;y&lt;/code&gt; 。最后的 &lt;code&gt;println!&lt;/code&gt; 最后产生 &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68d6c3c2b2d97df1f5ec2a0c2cfb150473278b62" translate="yes" xml:space="preserve">
          <source>When the associated function is declared on a trait, the function can also be called with a &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; that is a path to the trait appended by the name of the trait. When this happens, it is substituted for &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt;.</source>
          <target state="translated">在特征上声明关联的函数时，也可以使用&lt;a href=&quot;../paths&quot;&gt;路径&lt;/a&gt;来调用该函数，该路径是到特征的路径后附加特征名称。发生这种情况时，它将用 &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="bd35bbcd5c352ce9d75d44366396e7a4adb6ff6a" translate="yes" xml:space="preserve">
          <source>When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the &lt;code&gt;value&lt;/code&gt; method. This method checks whether we already have a resulting value in &lt;code&gt;self.value&lt;/code&gt; in a &lt;code&gt;Some&lt;/code&gt;; if we do, it returns the value within the &lt;code&gt;Some&lt;/code&gt; without executing the closure again.</source>
          <target state="translated">当调用代码需要评估闭包的结果时，它将直接调用 &lt;code&gt;value&lt;/code&gt; 方法，而不是直接调用闭包。这个方法检查我们是否已经有了一个结果值 &lt;code&gt;self.value&lt;/code&gt; 的 &lt;code&gt;Some&lt;/code&gt; ; 如果这样做，它将返回 &lt;code&gt;Some&lt;/code&gt; 中的值，而无需再次执行关闭操作。</target>
        </trans-unit>
        <trans-unit id="b1a7e675e1dcb1e2ab13e918ca4b37b70a8d5bf1" translate="yes" xml:space="preserve">
          <source>When the command line parsing logic starts getting complicated, extract it from &lt;em&gt;main.rs&lt;/em&gt; and move it to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="translated">当命令行解析逻辑开始越来越复杂，从提取它&lt;em&gt;main.rs&lt;/em&gt;并将其移动到&lt;em&gt;lib.rs&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f005b1e8a05e081cd9cbf74c1d92789005c2778" translate="yes" xml:space="preserve">
          <source>When the configuration predicate is true, this attribute expands out to the attributes listed after the predicate. For example, the following module will either be found at &lt;code&gt;linux.rs&lt;/code&gt; or &lt;code&gt;windows.rs&lt;/code&gt; based on the target.</source>
          <target state="translated">当配置谓词为true时，此属性扩展为该谓词之后列出的属性。例如，将根据目标在 &lt;code&gt;linux.rs&lt;/code&gt; 或 &lt;code&gt;windows.rs&lt;/code&gt; 中找到以下模块。</target>
        </trans-unit>
        <trans-unit id="b2cac43891907079676afac07f98ef2691d9a0f5" translate="yes" xml:space="preserve">
          <source>When the draft is done, a review of the post is requested.</source>
          <target state="translated">稿子写好后,要求审帖。</target>
        </trans-unit>
        <trans-unit id="81c2e18caa886f869f8ca82f7d008cc861e8f29d" translate="yes" xml:space="preserve">
          <source>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</source>
          <target state="translated">当使用空字符串作为分隔符时,它会将字符串中的每个字符以及字符串的开头和结尾分开。</target>
        </trans-unit>
        <trans-unit id="8391463b3513744ada63d41c0e15df2b575fc578" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;../fs/struct.file#method.open&quot;&gt;&lt;code&gt;fs::File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../fs/struct.openoptions#method.open&quot;&gt;&lt;code&gt;fs::OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b88e35933dd499afe9dc518b98a0ae7b4608c2" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993a1dfbbbb04483419f87e35c0750d6b041320f" translate="yes" xml:space="preserve">
          <source>When the inner scope ends, &lt;code&gt;branch&lt;/code&gt; goes out of scope and the strong count of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; decreases to 0, so its &lt;code&gt;Node&lt;/code&gt; is dropped. The weak count of 1 from &lt;code&gt;leaf.parent&lt;/code&gt; has no bearing on whether or not &lt;code&gt;Node&lt;/code&gt; is dropped, so we don&amp;rsquo;t get any memory leaks!</source>
          <target state="translated">当内部作用域结束时， &lt;code&gt;branch&lt;/code&gt; 超出作用域，并且 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 的强计数减少为0，因此其 &lt;code&gt;Node&lt;/code&gt; 被丢弃。 &lt;code&gt;leaf.parent&lt;/code&gt; 的弱计数1与 &lt;code&gt;Node&lt;/code&gt; 是否被删除没有关系，因此我们不会发生任何内存泄漏！</target>
        </trans-unit>
        <trans-unit id="92e09a21380ea98a48f9618974476f27f710a28e" translate="yes" xml:space="preserve">
          <source>When the iterator &lt;strong&gt;is&lt;/strong&gt; dropped, all elements in the range are removed from the vector, even if the iterator was not fully consumed. If the iterator &lt;strong&gt;is not&lt;/strong&gt; dropped (with &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; for example), it is unspecified how many elements are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42ec8800c3cc9133daaff5ef361d3ea73ec622b" translate="yes" xml:space="preserve">
          <source>When the logic to be performed on the value is more complex, we may simply use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the logic afterwards.</source>
          <target state="translated">当要对值执行的逻辑比较复杂时，我们可以简单地使用 &lt;code&gt;entry&lt;/code&gt; API来确保值已初始化并随后执行逻辑。</target>
        </trans-unit>
        <trans-unit id="43d2b59799e2c6b4bb4b98d12d6f70c1cf49277f" translate="yes" xml:space="preserve">
          <source>When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).</source>
          <target state="translated">当Rust程序的主线程终止时,即使其他线程还在运行,整个程序也会关闭。但是,这个模块提供了方便的设施,可以自动等待子线程的终止(即加入)。</target>
        </trans-unit>
        <trans-unit id="c0dc6f3a5195559f8d12308da2db6f2414d40676" translate="yes" xml:space="preserve">
          <source>When the owner goes out of scope, the value will be dropped.</source>
          <target state="translated">当所有者超出范围时,该值将被放弃。</target>
        </trans-unit>
        <trans-unit id="59190310a1258679f5eb021233a840994f9a99c1" translate="yes" xml:space="preserve">
          <source>When the pattern doesn't match:</source>
          <target state="translated">当图案不匹配时。</target>
        </trans-unit>
        <trans-unit id="ecb20a6a7a7f25d225823e98ccb5c961dba326d7" translate="yes" xml:space="preserve">
          <source>When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. Otherwise, the next pattern, including other matches with the &lt;code&gt;|&lt;/code&gt; operator in the same arm, is tested.</source>
          <target state="translated">模式成功匹配后，将执行模式保护表达式。如果表达式的计算结果为true，则表示模式已成功匹配。否则，下一个模式，包括与 &lt;code&gt;|&lt;/code&gt; 匹配的其他匹配项 同一手臂的操作员，经过测试。</target>
        </trans-unit>
        <trans-unit id="b7f41ee353730e0c1a0a6d3264ef3197cc06c52f" translate="yes" xml:space="preserve">
          <source>When the post is approved, it gets published.</source>
          <target state="translated">当帖子被批准后,它就会被发布。</target>
        </trans-unit>
        <trans-unit id="41bc650167a3c0cb28cbdf2fe35163fe7bda095c" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work if we also try to refer to that element later in the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ce9475a843aa2869fe7fade2558fcd95ae51c8" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work.</source>
          <target state="translated">当程序具有有效的引用时，借用检查器将执行所有权和借用规则（在第4章中介绍），以确保该引用和对向量内容的任何其他引用保持有效。回想一下规则，该规则规定在同一范围内不能有可变引用和不可变引用。该规则适用于清单8-7，其中我们对向量中的第一个元素持有不变的引用，并尝试将元素添加到末尾，这是行不通的。</target>
        </trans-unit>
        <trans-unit id="f773a5aea5eb96eca971d71eeb66cfae58b30a5a" translate="yes" xml:space="preserve">
          <source>When the programmer has enabled &lt;code&gt;debug_assert!&lt;/code&gt; assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that &lt;code&gt;panic&lt;/code&gt; on overflow. Other kinds of builds may result in &lt;code&gt;panics&lt;/code&gt; or silently wrapped values on overflow, at the implementation's discretion.</source>
          <target state="translated">当程序员启用 &lt;code&gt;debug_assert!&lt;/code&gt; 断言（例如，通过启用未优化的构建），实现必须插入在溢出时会出现 &lt;code&gt;panic&lt;/code&gt; 动态检查。根据实现的判断，其他类型的构建可能会导致溢出时出现 &lt;code&gt;panics&lt;/code&gt; 或默默包装的值。</target>
        </trans-unit>
        <trans-unit id="ce3f6166f132f399bf38664a6cccbedbde5ef26e" translate="yes" xml:space="preserve">
          <source>When the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</source>
          <target state="translated">当scrutinee表达式是&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place表达式时&lt;/a&gt;，匹配项不会分配临时位置；但是，按值绑定可以从内存位置复制或移动。在可能的情况下，最好在位置表达式上进行匹配，因为这些匹配项的生存期会继承位置表达式的生存期，而不是局限于匹配项内部。</target>
        </trans-unit>
        <trans-unit id="2c72e3065d1cd65994fce834d0430d9416ecec2e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.</source>
          <target state="translated">当分片len没有被分块大小平均分配时,迭代的最后一个分片将是剩余部分。</target>
        </trans-unit>
        <trans-unit id="28062354592a563db8e797c18e0e70b8ef604bb5" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.arraychunks#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0fda08da1d4cf85762ce95953612e1248e0072" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.arraychunksmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff85a9a955873b521d1857eca1f1e9a549be54e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">如果切片len不均匀地除以块大小，则最后一个不超过 &lt;code&gt;chunk_size-1&lt;/code&gt; 个元素将被省略，但可以从迭代器的&lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt;函数中检索。</target>
        </trans-unit>
        <trans-unit id="380f0182bf0446b4645382de4340b8f27ea208b9" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">如果切片len不均匀地除以块大小，则最后一个不超过 &lt;code&gt;chunk_size-1&lt;/code&gt; 个元素将被省略，但可以从迭代器的&lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt; &lt;code&gt;into_remainder&lt;/code&gt; &lt;/a&gt;函数中检索。</target>
        </trans-unit>
        <trans-unit id="c18714384f2b643a8c87f83e941ef77f216c1e30" translate="yes" xml:space="preserve">
          <source>When the source is an owning iterator struct (commonly called &lt;code&gt;IntoIter&lt;/code&gt;) then this can be useful for specializing &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; implementations or recovering the remaining elements after an iterator has been partially exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb68be86a1a45d1f6b54a16fdad69c0443b3e68" translate="yes" xml:space="preserve">
          <source>When the trailing semicolon is omitted, the result must be type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">如果省略尾部分号，则结果必须为type &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c349a820ac0a64039fea25d4cbecfdfad33b558" translate="yes" xml:space="preserve">
          <source>When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let&amp;rsquo;s tackle that next!</source>
          <target state="translated">删除向量时，其所有内容也将被删除，这意味着将清除其拥有的那些整数。这似乎很简单，但是当您开始引入对向量元素的引用时，可能会变得更加复杂。让我们接下来解决这个问题！</target>
        </trans-unit>
        <trans-unit id="d759cfed67550956f3c467a9677f59d40c90a085" translate="yes" xml:space="preserve">
          <source>When there isn't a &lt;code&gt;Self: Sized&lt;/code&gt; bound on a method, the type of a method receiver must be one of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045b65f5d67968ff8801369e1d99fcba44a4e94a" translate="yes" xml:space="preserve">
          <source>When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations may not appear where intended.</source>
          <target state="translated">当这个闭合运行时,诸如stdio文件描述符和工作目录等方面已经被成功地改变了,所以输出到这些位置的结果可能不会出现在预定的地方。</target>
        </trans-unit>
        <trans-unit id="ad7769a3800701a3a043ec20084e499702706111" translate="yes" xml:space="preserve">
          <source>When this function is used during const evaluation, it may return &lt;code&gt;false&lt;/code&gt; for pointers that turn out to be null at runtime. Specifically, when a pointer to some memory is offset beyond its bounds in such a way that the resulting pointer is null, the function will still return &lt;code&gt;false&lt;/code&gt;. There is no way for CTFE to know the absolute position of that memory, so we cannot tell if the pointer is null or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6792fc653fbacaf2b989ced239eb6fa2deec46" translate="yes" xml:space="preserve">
          <source>When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).</source>
          <target state="translated">当这个函数返回时,保证某个初始化已经运行并完成(可能不是指定的闭包)。它还保证被执行的闭包所执行的任何内存写入都可以在此时被其他线程可靠地观察到(在闭包和返回后执行的代码之间有一个发生-之前的关系)。</target>
        </trans-unit>
        <trans-unit id="6272391ae8d142b8a69f4da76b9108341afacf1f" translate="yes" xml:space="preserve">
          <source>When this method has been called, &lt;code&gt;self&lt;/code&gt; has not yet been deallocated. That only happens after the method is over. If this wasn't the case, &lt;code&gt;self&lt;/code&gt; would be a dangling reference.</source>
          <target state="translated">调用此方法后，尚未释放 &lt;code&gt;self&lt;/code&gt; 。这仅在方法结束后才发生。如果不是这种情况， &lt;code&gt;self&lt;/code&gt; 将是一个悬而未决的参考。</target>
        </trans-unit>
        <trans-unit id="9b04566ec85e491e3fa2ae5cb87abb0c8372d784" translate="yes" xml:space="preserve">
          <source>When this program executes, it checks each &lt;code&gt;if&lt;/code&gt; expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don&amp;rsquo;t see the output &lt;code&gt;number is divisible by 2&lt;/code&gt;, nor do we see the &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; text from the &lt;code&gt;else&lt;/code&gt; block. That&amp;rsquo;s because Rust only executes the block for the first true condition, and once it finds one, it doesn&amp;rsquo;t even check the rest.</source>
          <target state="translated">执行此程序时，它将依次检查每个 &lt;code&gt;if&lt;/code&gt; 表达式并执行条件成立的第一个正文。请注意，即使6被2整除，我们也看不到输出 &lt;code&gt;number is divisible by 2&lt;/code&gt; ，也看不到 &lt;code&gt;else&lt;/code&gt; 块中的 &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; 文本整除。这是因为Rust仅在第一个真实条件下执行该块，并且一旦找到一个条件，它甚至不检查其余部分。</target>
        </trans-unit>
        <trans-unit id="f943a1cfdbb4b42ef0aab62b7f7aa8f670763652" translate="yes" xml:space="preserve">
          <source>When to Use Unsafe Code</source>
          <target state="translated">何时使用不安全代码</target>
        </trans-unit>
        <trans-unit id="e49f07ac591b9df3217836c08c55df9a224df807" translate="yes" xml:space="preserve">
          <source>When to choose interior mutability</source>
          <target state="translated">何时选择内部可变性</target>
        </trans-unit>
        <trans-unit id="34bd2ffda436616fa2dd5a24ddce1b15ffc8ed97" translate="yes" xml:space="preserve">
          <source>When trying to make some type implement a trait &lt;code&gt;Foo&lt;/code&gt;, you must, at minimum, provide implementations for all of &lt;code&gt;Foo&lt;/code&gt;'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</source>
          <target state="translated">当试图使某个类型实现特征 &lt;code&gt;Foo&lt;/code&gt; 时，至少必须为 &lt;code&gt;Foo&lt;/code&gt; 的所有必需方法（意味着没有默认实现的方法）以及任何必需的特征项（如关联类型或类型）提供实现。常数。例：</target>
        </trans-unit>
        <trans-unit id="727739e9ec606ff0128888672a6babe668ea6ab8" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeTo&lt;/code&gt; produces a slice of all array elements before the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">当用作&lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;切片索引时&lt;/a&gt;， &lt;code&gt;RangeTo&lt;/code&gt; 生成由 &lt;code&gt;end&lt;/code&gt; 指示的索引之前的所有数组元素的切片。</target>
        </trans-unit>
        <trans-unit id="e81866ba280f233e50444316cfe195129a341859" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeToInclusive&lt;/code&gt; produces a slice of all array elements up to and including the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">当用作&lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;切片索引时&lt;/a&gt;， &lt;code&gt;RangeToInclusive&lt;/code&gt; 会生成一个所有数组元素的切片，直到并包括 &lt;code&gt;end&lt;/code&gt; 指示的索引。</target>
        </trans-unit>
        <trans-unit id="2b45521f0b2908c3126bcf39f34e601db7fa5296" translate="yes" xml:space="preserve">
          <source>When used as an item or a statement, the &lt;em&gt;MacroInvocationSemi&lt;/em&gt; form is used where a semicolon is required at the end when not using curly braces. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Visibility qualifiers&lt;/a&gt; are never allowed before a macro invocation or &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt;&lt;/a&gt; definition.</source>
          <target state="translated">当用作项目或语句时，使用&lt;em&gt;MacroInvocationSemi&lt;/em&gt;表单，其中不使用花括号时最后需要使用分号。在宏调用或&lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;macro_rules&lt;/code&gt; &lt;/a&gt;定义之前，永远不允许&lt;a href=&quot;visibility-and-privacy&quot;&gt;可见性限定符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="142d83eb0488a8e5aa5cd0f7af5b426b99a98c2b" translate="yes" xml:space="preserve">
          <source>When used on a &lt;a href=&quot;../items/traits&quot;&gt;trait declaration&lt;/a&gt;, a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; to a function that returns an &lt;a href=&quot;../types/impl-trait&quot;&gt;impl trait&lt;/a&gt; of that trait violates the &lt;code&gt;unused_must_use&lt;/code&gt; lint.</source>
          <target state="translated">在&lt;a href=&quot;../items/traits&quot;&gt;特征声明&lt;/a&gt;上使用时，对返回该&lt;a href=&quot;../types/impl-trait&quot;&gt;特征&lt;/a&gt;的impl特征的函数的&lt;a href=&quot;../statements#expression-statements&quot;&gt;表达式语句&lt;/a&gt;的&lt;a href=&quot;../expressions/call-expr&quot;&gt;调用表达式&lt;/a&gt;违反了 &lt;code&gt;unused_must_use&lt;/code&gt; lint。</target>
        </trans-unit>
        <trans-unit id="a852fccfd2a27297b4365a331af8dc1c15ac5f5a" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</source>
          <target state="translated">当使用在trait声明中的函数上时,当调用表达式是来自trait实现的函数时,该行为也适用。</target>
        </trans-unit>
        <trans-unit id="88cab39f222cd92692e6d511980bef189805ee7b" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait implementation, the attribute does nothing.</source>
          <target state="translated">当使用在特质实现中的函数上时,这个属性什么都不做。</target>
        </trans-unit>
        <trans-unit id="a38aec53cd57e4a640fb72d4c596595beee7f334" translate="yes" xml:space="preserve">
          <source>When used on a function, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; is a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; to that function, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">当在函数中使用，如果&lt;a href=&quot;../expressions&quot;&gt;表达&lt;/a&gt;的的&lt;a href=&quot;../statements#expression-statements&quot;&gt;表达式语句&lt;/a&gt;是一个&lt;a href=&quot;../expressions/call-expr&quot;&gt;调用表达式&lt;/a&gt;该功能，那么 &lt;code&gt;unused_must_use&lt;/code&gt; 棉绒被违反。</target>
        </trans-unit>
        <trans-unit id="e4d571aee68c6431041b80e34711ac5e77b8cfc0" translate="yes" xml:space="preserve">
          <source>When used on user-defined composite types, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; has that type, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">当用户定义的复合类型使用，如果&lt;a href=&quot;../expressions&quot;&gt;表达&lt;/a&gt;一个的&lt;a href=&quot;../statements#expression-statements&quot;&gt;表达式语句&lt;/a&gt;具有类型，则 &lt;code&gt;unused_must_use&lt;/code&gt; 棉绒被违反。</target>
        </trans-unit>
        <trans-unit id="370602de292c5acf9300ec1049f6d7b0d030d468" translate="yes" xml:space="preserve">
          <source>When used with the alternate format specifier &lt;code&gt;#?&lt;/code&gt;, the output is pretty-printed.</source>
          <target state="translated">与替代格式说明符 &lt;code&gt;#?&lt;/code&gt; ，输出结果漂亮。</target>
        </trans-unit>
        <trans-unit id="e3c7fb67d8df75a586e35884637385ed0d8f23ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; it may be the case that some of the closed over variables are not unwind safe. For example if &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.</source>
          <target state="translated">当使用&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; 时&lt;/a&gt;，可能会发生某些closed over变量不安全的情况。例如，如果捕获了 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ,则编译器将生成一条警告，指出它不是展开安全的。但是，如果专门考虑了&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt;安全性，则由于catch_unwind的特定用法，实际上可能不是问题。该包装器结构可用于快速且轻量级的注释，该注释的确确实是安全的。</target>
        </trans-unit>
        <trans-unit id="b4aaf8ff7f846237ace4f0a059c82e12475ebd13" translate="yes" xml:space="preserve">
          <source>When using a future, you generally won't call &lt;code&gt;poll&lt;/code&gt; directly, but instead &lt;code&gt;.await&lt;/code&gt; the value.</source>
          <target state="translated">使用 &lt;code&gt;.await&lt;/code&gt; ，通常不会直接调用 &lt;code&gt;poll&lt;/code&gt; ，而是.await值。</target>
        </trans-unit>
        <trans-unit id="206af53865bdd4c9d82650ccc0b648e77c1d1339" translate="yes" xml:space="preserve">
          <source>When using a lifetime like &lt;code&gt;'a&lt;/code&gt; in a type, it must be declared before being used.</source>
          <target state="translated">在类型中使用诸如 &lt;code&gt;'a&lt;/code&gt; 之类的生存期时，必须在使用前声明它。</target>
        </trans-unit>
        <trans-unit id="68d4836a866e67a5b4af384a8eb471ccacc77a13" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt; to a &lt;code&gt;static&lt;/code&gt;. The &lt;a href=&quot;destructors#drop-scopes&quot;&gt;drop scope&lt;/a&gt; of the temporary is usually the end of the enclosing statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783900079b0706a4642035130b0d4e5b4c18d3f8" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if promoted to &lt;code&gt;'static&lt;/code&gt;. Promotion of a value expression to a &lt;code&gt;'static&lt;/code&gt; slot occurs when the expression could be written in a constant, borrowed, and dereferencing that borrow where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain &lt;a href=&quot;interior-mutability&quot;&gt;interior mutability&lt;/a&gt; or &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; (these properties are determined based on the value where possible, e.g. &lt;code&gt;&amp;amp;None&lt;/code&gt; always has the type &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt;, as it contains nothing disallowed). Otherwise, the lifetime of temporary values is typically</source>
          <target state="translated">在大多数场所表达式上下文中使用值表达式时，会创建一个临时的未命名存储位置，并将其初始化为该值，并且表达式会求值到该位置，除非提升为 &lt;code&gt;'static&lt;/code&gt; 。当可以在不更改运行时行为的情况下将表达式以常量写入，借用并取消引用最初写入表达式的位置时，将值表达式提升为 &lt;code&gt;'static&lt;/code&gt; 插槽&amp;rdquo;。也就是说，可以在编译时评估提升后的表达式，并且结果值不包含&lt;a href=&quot;interior-mutability&quot;&gt;内部可变性&lt;/a&gt;或&lt;a href=&quot;destructors&quot;&gt;析构函数&lt;/a&gt;（这些属性是根据可能的值确定的，例如 &lt;code&gt;&amp;amp;None&lt;/code&gt; 始终具有该类型 &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt; ，因为其中不包含任何不允许的内容）。否则，临时值的生存期通常为</target>
        </trans-unit>
        <trans-unit id="7387e6f07d50e4b94b03c5027eaa0a1074379c4f" translate="yes" xml:space="preserve">
          <source>When using an alias over a function type, you cannot e.g. denote a parameter as being mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e391fe57ab900573f61faa4d08b9fd057fe4752" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">当使用包含范围的迭代时，在迭代结束后未指定&lt;a href=&quot;#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;end()&lt;/code&gt; 的值。要确定包含范围是否为空，请使用&lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt;方法，而不是比较 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a518969d6cf8add6a83ea03a0b5649d4f43920f2" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;struct.rangeinclusive#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41ad7fcc2b6f72dd75060937158a4566bb3d48c" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">当使用包含范围的迭代时，在迭代结束后未指定 &lt;code&gt;start()&lt;/code&gt; 和&lt;a href=&quot;#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt;的值。要确定包含范围是否为空，请使用&lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt;方法，而不是比较 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbb0c63c5182e2af20d41eccf36aeeeb95780341" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;struct.rangeinclusive#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88230c170cac7c9979daeb85327371e8fc8933d" translate="yes" xml:space="preserve">
          <source>When using generators (or async) all type variables must be bound so a generator can be constructed.</source>
          <target state="translated">当使用生成器(或异步)时,所有的类型变量必须被绑定,这样才能构造生成器。</target>
        </trans-unit>
        <trans-unit id="eb4afcd059cb498d340016957478dc07a5b0b9cd" translate="yes" xml:space="preserve">
          <source>When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to &lt;code&gt;inspect()&lt;/code&gt;.</source>
          <target state="translated">使用迭代器时，通常会将其中的几个链接在一起。在处理此类代码时，您可能想检查一下管道中各个部分的情况。为此，请插入对 &lt;code&gt;inspect()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="c5b59408fe1f6f4de1643cf5f48d4f5771ac3565" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</source>
          <target state="translated">在元组结构上使用 &lt;code&gt;#[simd]&lt;/code&gt; 属性时，元组结构的组件必须全部为具体的非泛型类型，以便编译器可以推断出如何将SIMD与它们一起使用。如果类型是通用的，则会发生此错误。</target>
        </trans-unit>
        <trans-unit id="39b563bb5da92b14b1bd3b2de6d3ed8ec3f0fd65" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</source>
          <target state="translated">在元组结构上使用 &lt;code&gt;#[simd]&lt;/code&gt; 属性时，元组中的元素必须是机器类型，以便SIMD操作可以应用于它们。</target>
        </trans-unit>
        <trans-unit id="f68c56eaa365c1195d011c5971774cffabbee19c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</source>
          <target state="translated">当使用 &lt;code&gt;#[simd]&lt;/code&gt; 属性在元组结构中自动使用SIMD操作时，该结构中的类型必须全部为同一类型，否则编译器将触发此错误。</target>
        </trans-unit>
        <trans-unit id="8dd63b3b5f84a11f65877d582b3cb17771f94809" translate="yes" xml:space="preserve">
          <source>When using/declaring an item with generic arguments, you must provide the exact same number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875f23e80d105f6373be722e024a688059c93026" translate="yes" xml:space="preserve">
          <source>When we assign &lt;code&gt;s1&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;, the &lt;code&gt;String&lt;/code&gt; data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.</source>
          <target state="translated">当将 &lt;code&gt;s1&lt;/code&gt; 分配给 &lt;code&gt;s2&lt;/code&gt; 时，将复制 &lt;code&gt;String&lt;/code&gt; 数据，这意味着我们将复制堆栈上的指针，长度和容量。我们不将数据复制到指针引用的堆上。换句话说，存储器中的数据表示如图4-2所示。</target>
        </trans-unit>
        <trans-unit id="20dccc7faf7358ddd1e5e9048cb569181ba72e52" translate="yes" xml:space="preserve">
          <source>When we bring a name into scope with the &lt;code&gt;use&lt;/code&gt; keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code&amp;rsquo;s scope, we can combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;. This technique is called &lt;em&gt;re-exporting&lt;/em&gt; because we&amp;rsquo;re bringing an item into scope but also making that item available for others to bring into their scope.</source>
          <target state="translated">当我们 &lt;code&gt;use&lt;/code&gt; 关键字将名称带入范围时，新范围中可用的名称是私有的。为了使调用我们代码的代码能够像在该代码的作用域中定义的那样引用该名称，我们可以结合 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;pub&lt;/code&gt; 和use。这项技术称为&lt;em&gt;重新导出，&lt;/em&gt;因为我们将某个项目放入范围内，同时也使该项目可供其他人进入其范围。</target>
        </trans-unit>
        <trans-unit id="42f15b600972fbcabaccb1f899d3d65cff52600b" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;fly&lt;/code&gt; on an instance of &lt;code&gt;Human&lt;/code&gt;, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</source>
          <target state="translated">当我们在 &lt;code&gt;Human&lt;/code&gt; 的实例上调用 &lt;code&gt;fly&lt;/code&gt; 时，编译器默认调用直接在该类型上实现的方法，如清单19-17所示。</target>
        </trans-unit>
        <trans-unit id="350ebfd5b3bd82b33fcb60d5557f6b4f388aac65" translate="yes" xml:space="preserve">
          <source>When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the &lt;code&gt;$x&lt;/code&gt; pattern matches three times with the three expressions &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">当我们用 &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; 调用此宏时；中， &lt;code&gt;$x&lt;/code&gt; 图案三次与三个表达式匹配 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，和 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e7bba3d9da7852f6359cc6e672864f837a98a14" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get an error with this core message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6bd2715022e06e450780014c7b5af3817cebde" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get the following error message:</source>
          <target state="translated">当我们编译这段代码时,得到以下错误信息。</target>
        </trans-unit>
        <trans-unit id="d7383a66b159cf7464f68ba405d35045b37c0b59" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get this error:</source>
          <target state="translated">当我们编译这段代码时,我们得到了这个错误。</target>
        </trans-unit>
        <trans-unit id="5e8ce4b2651c1cb04164eadfa1df10bcf9bfb1ce" translate="yes" xml:space="preserve">
          <source>When we compile this example, we get this error:</source>
          <target state="translated">当我们编译这个例子时,我们得到这个错误。</target>
        </trans-unit>
        <trans-unit id="54132a8652e951367540a246425bd7e243e44e7e" translate="yes" xml:space="preserve">
          <source>When we create a new &lt;code&gt;Post&lt;/code&gt;, we set its &lt;code&gt;state&lt;/code&gt; field to a &lt;code&gt;Some&lt;/code&gt; value that holds a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; points to a new instance of the &lt;code&gt;Draft&lt;/code&gt; struct. This ensures whenever we create a new instance of &lt;code&gt;Post&lt;/code&gt;, it will start out as a draft. Because the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; is private, there is no way to create a &lt;code&gt;Post&lt;/code&gt; in any other state! In the &lt;code&gt;Post::new&lt;/code&gt; function, we set the &lt;code&gt;content&lt;/code&gt; field to a new, empty &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">当我们创建一个新的 &lt;code&gt;Post&lt;/code&gt; 时，我们将它的 &lt;code&gt;state&lt;/code&gt; 字段设置为保存 &lt;code&gt;Box&lt;/code&gt; 的 &lt;code&gt;Some&lt;/code&gt; 值。该 &lt;code&gt;Box&lt;/code&gt; 指向 &lt;code&gt;Draft&lt;/code&gt; 结构的新实例。这样可以确保每当我们创建 &lt;code&gt;Post&lt;/code&gt; 的新实例时，它都将作为草稿开始。由于 &lt;code&gt;Post&lt;/code&gt; 的 &lt;code&gt;state&lt;/code&gt; 字段是私有的，因此无法在其他任何状态下创建 &lt;code&gt;Post&lt;/code&gt; ！在 &lt;code&gt;Post::new&lt;/code&gt; 函数中，我们将 &lt;code&gt;content&lt;/code&gt; 字段设置为一个新的空 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bdaf316b9ae5f73e74db4dd3cf073c814edc28e" translate="yes" xml:space="preserve">
          <source>When we create the &lt;code&gt;branch&lt;/code&gt; node, it will also have a new &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference in the &lt;code&gt;parent&lt;/code&gt; field, because &lt;code&gt;branch&lt;/code&gt; doesn&amp;rsquo;t have a parent node. We still have &lt;code&gt;leaf&lt;/code&gt; as one of the children of &lt;code&gt;branch&lt;/code&gt;. Once we have the &lt;code&gt;Node&lt;/code&gt; instance in &lt;code&gt;branch&lt;/code&gt;, we can modify &lt;code&gt;leaf&lt;/code&gt; to give it a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to its parent. We use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; in the &lt;code&gt;parent&lt;/code&gt; field of &lt;code&gt;leaf&lt;/code&gt;, and then we use the &lt;code&gt;Rc::downgrade&lt;/code&gt; function to create a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to &lt;code&gt;branch&lt;/code&gt; from the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</source>
          <target state="translated">当我们创建 &lt;code&gt;branch&lt;/code&gt; 节点时，它在 &lt;code&gt;parent&lt;/code&gt; 字段中还将有一个新的 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 引用，因为 &lt;code&gt;branch&lt;/code&gt; 没有父节点。我们仍然把 &lt;code&gt;leaf&lt;/code&gt; 作为 &lt;code&gt;branch&lt;/code&gt; 的子代之一。将 &lt;code&gt;Node&lt;/code&gt; 实例放置在 &lt;code&gt;branch&lt;/code&gt; 中后，我们可以修改 &lt;code&gt;leaf&lt;/code&gt; 以为其对其父级提供 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 引用。我们使用 &lt;code&gt;borrow_mut&lt;/code&gt; 的方法 &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; 在 &lt;code&gt;parent&lt;/code&gt; 的领域 &lt;code&gt;leaf&lt;/code&gt; ，然后我们使用 &lt;code&gt;Rc::downgrade&lt;/code&gt; 函数来创建 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 从 &lt;code&gt;branch&lt;/code&gt; 中的 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 对 &lt;code&gt;branch.&lt;/code&gt; 弱&amp;lt;Node&amp;gt;引用。</target>
        </trans-unit>
        <trans-unit id="b6d475e631798bcfdbe8b5d49b3651bb13f536b5" translate="yes" xml:space="preserve">
          <source>When we entered &lt;code&gt;*y&lt;/code&gt; in Listing 15-9, behind the scenes Rust actually ran this code:</source>
          <target state="translated">当我们在清单15-9中输入 &lt;code&gt;*y&lt;/code&gt; 时，Rust实际上在后台运行了以下代码：</target>
        </trans-unit>
        <trans-unit id="022643a7b2e9e273dbb19c62148637669a0b154f" translate="yes" xml:space="preserve">
          <source>When we entered the command, Cargo created a &lt;em&gt;Cargo.toml&lt;/em&gt; file, giving us a package. Looking at the contents of &lt;em&gt;Cargo.toml&lt;/em&gt;, there&amp;rsquo;s no mention of &lt;em&gt;src/main.rs&lt;/em&gt; because Cargo follows a convention that &lt;em&gt;src/main.rs&lt;/em&gt; is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains &lt;em&gt;src/lib.rs&lt;/em&gt;, the package contains a library crate with the same name as the package, and &lt;em&gt;src/lib.rs&lt;/em&gt; is its crate root. Cargo passes the crate root files to &lt;code&gt;rustc&lt;/code&gt; to build the library or binary.</source>
          <target state="translated">当我们输入命令时，Cargo创建了一个&lt;em&gt;Cargo.toml&lt;/em&gt;文件，为我们提供了一个包。在&lt;em&gt;查看Cargo.toml&lt;/em&gt;的内容时，没有提到&lt;em&gt;src / main.rs，&lt;/em&gt;因为Cargo遵循一个约定，即&lt;em&gt;src / main.rs&lt;/em&gt;是与包同名的二进制包的包根。同样，Cargo知道，如果程序包目录包含&lt;em&gt;src / lib.rs&lt;/em&gt;，则程序包包含与程序包同名的库条板箱，并且&lt;em&gt;src / lib.rs&lt;/em&gt;是其板条箱根。 Cargo将板条箱根文件传递给 &lt;code&gt;rustc&lt;/code&gt; 以构建库或二进制文件。</target>
        </trans-unit>
        <trans-unit id="457abff93dbe5ac6fded48fa1428f69ee83409b3" translate="yes" xml:space="preserve">
          <source>When we have a &lt;code&gt;Some&lt;/code&gt; value, we know that a value is present and the value is held within the &lt;code&gt;Some&lt;/code&gt;. When we have a &lt;code&gt;None&lt;/code&gt; value, in some sense, it means the same thing as null: we don&amp;rsquo;t have a valid value. So why is having &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; any better than having null?</source>
          <target state="translated">当我们具有 &lt;code&gt;Some&lt;/code&gt; 值时，我们知道存在一个值并将该值保存在 &lt;code&gt;Some&lt;/code&gt; 中。从某种意义上讲，当我们拥有 &lt;code&gt;None&lt;/code&gt; 值时，它意味着与null相同：我们没有有效值。那么，为什么拥有 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 比拥有null更好呢？</target>
        </trans-unit>
        <trans-unit id="f020ca74b67fee23ca0497cca95821474c7cc12b" translate="yes" xml:space="preserve">
          <source>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they&amp;rsquo;re related to the struct fields or the method parameters and return values.</source>
          <target state="translated">在具有生命周期的结构上实现方法时，我们使用与清单10-11中所示的泛型类型参数相同的语法。我们声明和使用生命周期参数的位置取决于它们是否与struct字段或方法参数以及返回值相关。</target>
        </trans-unit>
        <trans-unit id="a57e5870f2a33156805f7bdbcc9a94b3975d0971" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;RHS&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;RHS&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">当我们实现 &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; 时，我们将默认值用于 &lt;code&gt;RHS&lt;/code&gt; ,因为我们想添加两个 &lt;code&gt;Point&lt;/code&gt; 实例。让我们看一个实现 &lt;code&gt;Add&lt;/code&gt; trait 的示例，在该示例中我们想要自定义 &lt;code&gt;RHS&lt;/code&gt; 类型而不是使用默认类型。</target>
        </trans-unit>
        <trans-unit id="bbeae0b47ec877c608d0d21b1b80a717b1578283" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;Rhs&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;Rhs&lt;/code&gt; type rather than using the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b1449687c25748d2619d5b3c608f432cee9ffd" translate="yes" xml:space="preserve">
          <source>When we look at &lt;em&gt;src/main.rs&lt;/em&gt; again, we&amp;rsquo;ll see that &lt;code&gt;cargo fix&lt;/code&gt; has changed the code:</source>
          <target state="translated">再次查看&lt;em&gt;src / main.rs&lt;/em&gt;时，我们将看到 &lt;code&gt;cargo fix&lt;/code&gt; 已更改代码：</target>
        </trans-unit>
        <trans-unit id="7a54ab2951cd6fff0884c0511bb61b6ab512dff0" translate="yes" xml:space="preserve">
          <source>When we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module helps you start writing your tests so you don&amp;rsquo;t have to look up the exact structure and syntax of test functions every time you start a new project. You can add as many additional test functions and as many test modules as you want!</source>
          <target state="translated">当我们使用Cargo制作一个新的图书馆项目时，会自动为我们生成一个带有测试功能的测试模块。该模块可帮助您开始编写测试，因此您不必在每次启动新项目时都查找测试函数的确切结构和语法。您可以根据需要添加任意数量的其他测试功能和测试模块！</target>
        </trans-unit>
        <trans-unit id="c17714721f7f441933c167091091578db54d0995" translate="yes" xml:space="preserve">
          <source>When we pass concrete references to &lt;code&gt;longest&lt;/code&gt;, the concrete lifetime that is substituted for &lt;code&gt;'a&lt;/code&gt; is the part of the scope of &lt;code&gt;x&lt;/code&gt; that overlaps with the scope of &lt;code&gt;y&lt;/code&gt;. In other words, the generic lifetime &lt;code&gt;'a&lt;/code&gt; will get the concrete lifetime that is equal to the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Because we&amp;rsquo;ve annotated the returned reference with the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;, the returned reference will also be valid for the length of the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">当我们传递 &lt;code&gt;longest&lt;/code&gt; 具体引用时，代替 &lt;code&gt;'a&lt;/code&gt; 的具体寿命是 &lt;code&gt;x&lt;/code&gt; 范围的一部分，与 &lt;code&gt;y&lt;/code&gt; 范围重叠。换句话说，一般寿命 &lt;code&gt;'a&lt;/code&gt; 将获得等于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 中较小者的具体寿命。因为我们已经使用相同的生命周期参数 &lt;code&gt;'a&lt;/code&gt; 注释了返回的引用，所以返回的引用对于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 生命周期中较小者的长度也将有效。</target>
        </trans-unit>
        <trans-unit id="a267d1c9dce3d09c3ccaaec536f47b38cd5559e0" translate="yes" xml:space="preserve">
          <source>When we print &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we can see that they all have the modified value of 15 rather than 5:</source>
          <target state="translated">当我们打印 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 时，我们可以看到它们的修改值为15而不是5：</target>
        </trans-unit>
        <trans-unit id="e6d697346a86084beb1a95157687a62dfdd661aa" translate="yes" xml:space="preserve">
          <source>When we print the parent of &lt;code&gt;leaf&lt;/code&gt; again, this time we&amp;rsquo;ll get a &lt;code&gt;Some&lt;/code&gt; variant holding &lt;code&gt;branch&lt;/code&gt;: now &lt;code&gt;leaf&lt;/code&gt; can access its parent! When we print &lt;code&gt;leaf&lt;/code&gt;, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; references are printed as &lt;code&gt;(Weak)&lt;/code&gt;:</source>
          <target state="translated">当我们再次打印 &lt;code&gt;leaf&lt;/code&gt; 的父级时，这一次，我们将获得 &lt;code&gt;Some&lt;/code&gt; 变异保持 &lt;code&gt;branch&lt;/code&gt; ：现在 &lt;code&gt;leaf&lt;/code&gt; 可以访问其父级了！当我们打印 &lt;code&gt;leaf&lt;/code&gt; 时，我们还避免了像清单15-26那样最终导致堆栈溢出的循环。所述 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 引用被打印为 &lt;code&gt;(Weak)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d6ae0ddb23c20f16f914c98f6cadf070ae827274" translate="yes" xml:space="preserve">
          <source>When we run &lt;code&gt;cargo doc --open&lt;/code&gt;, these comments will display on the front page of the documentation for &lt;code&gt;my_crate&lt;/code&gt; above the list of public items in the crate, as shown in Figure 14-2:</source>
          <target state="translated">当我们运行 &lt;code&gt;cargo doc --open&lt;/code&gt; 时，这些注释将显示在 &lt;code&gt;my_crate&lt;/code&gt; 的文档的首页上，位于板条箱中公共项目列表的上方，如图14-2所示：</target>
        </trans-unit>
        <trans-unit id="e0a9b14cc5672cde13757ff7b922b97b778df10c" translate="yes" xml:space="preserve">
          <source>When we run the code in Listing 16-8, we&amp;rsquo;ll see the value printed from the main thread:</source>
          <target state="translated">运行清单16-8中的代码时，我们将看到从主线程打印的值：</target>
        </trans-unit>
        <trans-unit id="b9d752c4fc202642188fd8ee33a406138a554856" translate="yes" xml:space="preserve">
          <source>When we run the program now, we get this:</source>
          <target state="translated">当我们现在运行程序时,我们得到的是这样的结果。</target>
        </trans-unit>
        <trans-unit id="8c0106d7279651b49f13e37d40b4d1b5d7049633" translate="yes" xml:space="preserve">
          <source>When we run the test in Listing 11-8, it will fail:</source>
          <target state="translated">当我们运行清单11-8中的测试时,会失败。</target>
        </trans-unit>
        <trans-unit id="44d32483b028a29165bad05ab4f3b2f5da955011" translate="yes" xml:space="preserve">
          <source>When we run the tests again, we&amp;rsquo;ll see a new section in the test output for the &lt;em&gt;common.rs&lt;/em&gt; file, even though this file doesn&amp;rsquo;t contain any test functions nor did we call the &lt;code&gt;setup&lt;/code&gt; function from anywhere:</source>
          <target state="translated">当我们再次运行测试时，我们将在&lt;em&gt;common.rs&lt;/em&gt;文件的测试输出中看到一个新部分，即使该文件不包含任何测试函数，也没有在任何地方调用 &lt;code&gt;setup&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="cb3ddc159979bee1d75a46f9ea2d0183358cc97b" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--nocapture&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">当使用 &lt;code&gt;--nocapture&lt;/code&gt; 标志再次运行清单11-10中的测试时，我们看到以下输出：</target>
        </trans-unit>
        <trans-unit id="35bd5db3d4e7561ab5f23e824a5b461601f0023a" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--show-output&lt;/code&gt; flag, we see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d8419c932e242d1adf6db2334731a0ed2c1d0" translate="yes" xml:space="preserve">
          <source>When we run these tests with &lt;code&gt;cargo test&lt;/code&gt;, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">将这些测试与 &lt;code&gt;cargo test&lt;/code&gt; 一起运行时，将看到以下输出：</target>
        </trans-unit>
        <trans-unit id="44da441e6c2b41d33ecf09cf035dd429fd808ba5" translate="yes" xml:space="preserve">
          <source>When we run this code with the &lt;code&gt;main&lt;/code&gt; function in Listing 5-14, we&amp;rsquo;ll get our desired output. Methods can take multiple parameters that we add to the signature after the &lt;code&gt;self&lt;/code&gt; parameter, and those parameters work just like parameters in functions.</source>
          <target state="translated">当使用清单5-14中的 &lt;code&gt;main&lt;/code&gt; 函数运行此代码时，将获得所需的输出。方法可以采用多个参数，这些参数要在 &lt;code&gt;self&lt;/code&gt; 参数之后添加到签名中，并且这些参数的作用就像函数中的参数一样。</target>
        </trans-unit>
        <trans-unit id="53901aa87c2188aaba7aa42fd2554bc7576ce3ee" translate="yes" xml:space="preserve">
          <source>When we run this code, keeping the last &lt;code&gt;println!&lt;/code&gt; commented out for the moment, we&amp;rsquo;ll get this output:</source>
          <target state="translated">当我们运行此代码时，保留最后一个 &lt;code&gt;println!&lt;/code&gt; 暂时将其注释掉，我们将获得以下输出：</target>
        </trans-unit>
        <trans-unit id="5a3726ae54b6ccfb63fe87a5f6a303a012e956de" translate="yes" xml:space="preserve">
          <source>When we run this code, the first &lt;code&gt;[]&lt;/code&gt; method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there&amp;rsquo;s an attempt to access an element past the end of the vector.</source>
          <target state="translated">当我们运行这段代码时，第一个 &lt;code&gt;[]&lt;/code&gt; 方法将导致程序出现恐慌，因为它引用了一个不存在的元素。如果试图访问向量结尾之后的元素，则当您希望程序崩溃时，最好使用此方法。</target>
        </trans-unit>
        <trans-unit id="d8d2da45983d7df0624bea6b1c973bb74ce76aac" translate="yes" xml:space="preserve">
          <source>When we run this code, we get an error with this core message:</source>
          <target state="translated">当我们运行这段代码时,我们得到了一个错误的核心信息。</target>
        </trans-unit>
        <trans-unit id="da6003750d05384524bf31be1adada0eff839f64" translate="yes" xml:space="preserve">
          <source>When we run this code, we&amp;rsquo;ll see the same output as in Listing 3-4. More importantly, we&amp;rsquo;ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</source>
          <target state="translated">运行此代码时，我们将看到与清单3-4相同的输出。更重要的是，我们现在已经提高了代码的安全性，并消除了由于超出数组末尾或距离不够远而丢失某些项目而导致错误的可能性。</target>
        </trans-unit>
        <trans-unit id="0377ef8d6715ac2dafa89aafe2017357ba5bea77" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see &lt;code&gt;again!&lt;/code&gt; printed over and over continuously until we stop the program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is stuck in a continual loop. Give it a try:</source>
          <target state="translated">当我们运行该程序时，我们会 &lt;code&gt;again!&lt;/code&gt; 看到！反复打印，直到我们手动停止程序为止。大多数终端都支持键盘快捷键ctrl-c来中断陷入连续循环的程序。试试看：</target>
        </trans-unit>
        <trans-unit id="17d349051e8f46b1c202c3a4fbf98139c89d6d7a" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">运行该程序时，将看到以下输出：</target>
        </trans-unit>
        <trans-unit id="2f39695d914a0c9b88c38a4702c072cc550001b0" translate="yes" xml:space="preserve">
          <source>When we try to check this code, we get this error:</source>
          <target state="translated">当我们试图检查这段代码时,我们得到了这个错误。</target>
        </trans-unit>
        <trans-unit id="b3d78770e0df06fb7d4eaea2e697443df3c1aa40" translate="yes" xml:space="preserve">
          <source>When we try to compile the code in Listing 19-5, we&amp;rsquo;ll get an error.</source>
          <target state="translated">当我们尝试编译清单19-5中的代码时，会出现错误。</target>
        </trans-unit>
        <trans-unit id="48d690d7f7c7a29675b105185a25b0eb605ff7f0" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get an error. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; arms have value types that are incompatible, and Rust indicates exactly where to find the problem in the program:</source>
          <target state="translated">当我们尝试编译此代码时，我们将得到一个错误。的 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 武器有不兼容的值类型，以及锈准确地指出来查找程序中的问题：</target>
        </trans-unit>
        <trans-unit id="20d9e738eb0bfb3c94a0df139314a2d502044dfc" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">当我们尝试编译此代码时，我们将收到此错误：</target>
        </trans-unit>
        <trans-unit id="382fab0dfc540b6d59e6b19a27e6a865624379ec" translate="yes" xml:space="preserve">
          <source>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic &lt;code&gt;largest&lt;/code&gt; function, place type name declarations inside angle brackets, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, between the name of the function and the parameter list, like this:</source>
          <target state="translated">当在函数主体中使用参数时，必须在签名中声明参数名称，以便编译器知道该名称的含义。同样，当在函数签名中使用类型参数名称时，必须在使用它之前声明类型参数名称。要定义通用的 &lt;code&gt;largest&lt;/code&gt; 函数，请将类型名称声明放在函数名称和参数列表之间的尖括号 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 中，如下所示：</target>
        </trans-unit>
        <trans-unit id="8036c669dac454067b908559831bbcc6af369344" translate="yes" xml:space="preserve">
          <source>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; when declaring the generic type.</source>
          <target state="translated">使用通用类型参数时，可以为通用类型指定默认的具体类型。如果默认类型有效，则无需特征的实现者指定具体类型。声明通用类型时，用于为通用类型指定默认类型的语法为 &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2fd3063d82737c85a4bd4560675bf8f567d4cb1" translate="yes" xml:space="preserve">
          <source>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn&amp;rsquo;t know all the types that might be used with the code that is using trait objects, so it doesn&amp;rsquo;t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn&amp;rsquo;t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method&amp;rsquo;s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&amp;rsquo;s a trade-off to consider.</source>
          <target state="translated">当我们使用特征对象时，Rust必须使用动态分配。编译器不知道使用trait对象的代码可能使用的所有类型，因此它不知道要在哪种类型上实现哪种方法来调用。相反，在运行时，Rust使用trait对象中的指针来知道要调用的方法。当这种查找发生时，这是静态分配所不会发生的运行时成本。动态分派还阻止编译器选择内联方法的代码，从而阻止进行某些优化。但是，我们确实在清单17-5中编写的代码中获得了额外的灵活性，并且能够在清单17-9中提供支持，因此需要权衡取舍。</target>
        </trans-unit>
        <trans-unit id="5fae46f3aefc24b09d40cb2c031a63a93c19cc1f" translate="yes" xml:space="preserve">
          <source>When we wrote the library, we didn&amp;rsquo;t know that someone might add the &lt;code&gt;SelectBox&lt;/code&gt; type, but our &lt;code&gt;Screen&lt;/code&gt; implementation was able to operate on the new type and draw it because &lt;code&gt;SelectBox&lt;/code&gt; implements the &lt;code&gt;Draw&lt;/code&gt; trait, which means it implements the &lt;code&gt;draw&lt;/code&gt; method.</source>
          <target state="translated">在编写库时，我们并不知道有人可以添加 &lt;code&gt;SelectBox&lt;/code&gt; 类型，但是我们的 &lt;code&gt;Screen&lt;/code&gt; 实现能够对新类型进行操作并绘制它，因为 &lt;code&gt;SelectBox&lt;/code&gt; 实现了 &lt;code&gt;Draw&lt;/code&gt; trait，这意味着它实现了 &lt;code&gt;draw&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1835312d71cbb49146dabf1e8972dadabbddcca1" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re defining this function, we don&amp;rsquo;t know the concrete values that will be passed into this function, so we don&amp;rsquo;t know whether the &lt;code&gt;if&lt;/code&gt; case or the &lt;code&gt;else&lt;/code&gt; case will execute. We also don&amp;rsquo;t know the concrete lifetimes of the references that will be passed in, so we can&amp;rsquo;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. The borrow checker can&amp;rsquo;t determine this either, because it doesn&amp;rsquo;t know how the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; relate to the lifetime of the return value. To fix this error, we&amp;rsquo;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</source>
          <target state="translated">定义此函数时，我们不知道将传递给该函数的具体值，因此我们不知道是否执行 &lt;code&gt;if&lt;/code&gt; 情况或 &lt;code&gt;else&lt;/code&gt; 情况。我们还不知道将传递的引用的具体生命周期，因此我们无法像清单10-18和清单10-19那样查看范围，以确定返回的引用是否始终有效。借用检查器也无法确定这一点，因为它不知道 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的生存期与返回值的生存期有何关系。要解决此错误，我们将添加通用的生存期参数，这些参数定义了引用之间的关系，以便借阅检查器可以执行其分析。</target>
        </trans-unit>
        <trans-unit id="2b0ee241a22dde4f8299858560fbc384d292c571" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54afd1d4de630fedf720b910edfe13f2d8fe3dc8" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">当使用固定结构时，会出现一个问题，即如何以仅使用 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 的方法访问该结构的字段。通常的方法是编写将 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 转换为对该字段的引用的辅助方法（所谓的&lt;em&gt;projections&lt;/em&gt;），但是该引用应具有哪种类型？是 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 还是 &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ？对于 &lt;code&gt;enum&lt;/code&gt; 的字段，以及在考虑容器/包装类型（例如&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;时，也会出现相同的问题。（此问题适用于可变引用和共享引用，我们仅在此处使用可变引用的更常见情况进行说明。）</target>
        </trans-unit>
        <trans-unit id="0c51f9b3e20caf1c1713245e1eb2bd51a6ddf835" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.</source>
          <target state="translated">当写入文件结束后,文件适当扩展,中间字节初始化值为0。</target>
        </trans-unit>
        <trans-unit id="debf85ed8f2982fd1ef982135cd5a37e3b932f44" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.</source>
          <target state="translated">当写入文件结束后,文件适当扩展,中间字节不初始化。</target>
        </trans-unit>
        <trans-unit id="4354c2cf3db4bc019d136bbb52f5ec5d3d5bdd0b" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">在编写调用许多返回&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;类型的函数的代码时，错误处理可能很乏味。问号运算符，&lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;，在调用堆栈中隐藏了一些传播错误的样板。</target>
        </trans-unit>
        <trans-unit id="fd3f2291c33fd3018ecb6b461f1a771659ef7d7e" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../ops/trait.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66253992d5df0f86fdc814938e97de3a70b258a2" translate="yes" xml:space="preserve">
          <source>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named &lt;code&gt;mod test&lt;/code&gt;. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</source>
          <target state="translated">在为模块编写单元测试时，将要测试的模块的直接子代命名为 &lt;code&gt;mod test&lt;/code&gt; 是常见的习惯用法。通过第二种情况，该模块可以访问父模块的任何项，这意味着内部实现细节也可以从子模块中进行无缝测试。</target>
        </trans-unit>
        <trans-unit id="6849dad47894c159da1bb308e92d26a3e924214c" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. As it turns out, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">在编写自己的特征时， &lt;code&gt;!&lt;/code&gt; 只要有明显的 &lt;code&gt;impl&lt;/code&gt; 而不必 &lt;code&gt;panic!&lt;/code&gt; ，就应该有一个 &lt;code&gt;impl&lt;/code&gt; ！。事实证明，多数性状可以有一个 &lt;code&gt;impl&lt;/code&gt; 的 &lt;code&gt;!&lt;/code&gt; 。以&lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;为例：</target>
        </trans-unit>
        <trans-unit id="b06c46c776108f6df59bce40c78afdd8aa807784" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. The reason is that functions returning an &lt;code&gt;impl Trait&lt;/code&gt; where &lt;code&gt;!&lt;/code&gt; does not have an &lt;code&gt;impl&lt;/code&gt; of &lt;code&gt;Trait&lt;/code&gt; cannot diverge as their only possible code path. In other words, they can't return &lt;code&gt;!&lt;/code&gt; from every code path. As an example, this code doesn't compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376eed46fc5732c188b64191ceb100503469e764" translate="yes" xml:space="preserve">
          <source>When you &lt;em&gt;do&lt;/em&gt; want to update a crate, Cargo provides another command, &lt;code&gt;update&lt;/code&gt;, which will ignore the &lt;em&gt;Cargo.lock&lt;/em&gt; file and figure out all the latest versions that fit your specifications in &lt;em&gt;Cargo.toml&lt;/em&gt;. If that works, Cargo will write those versions to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">当您&lt;em&gt;确实&lt;/em&gt;要更新包装箱时，Cargo提供了另一个命令 &lt;code&gt;update&lt;/code&gt; ，它将忽略&lt;em&gt;Cargo.lock&lt;/em&gt;文件，并找出符合&lt;em&gt;Cargo.toml&lt;/em&gt;规范的所有最新版本。如果&lt;em&gt;可行&lt;/em&gt;，Cargo会将这些版本写入&lt;em&gt;Cargo.lock&lt;/em&gt;文件。</target>
        </trans-unit>
        <trans-unit id="1ba68f5d231df3408014c574fc5fb4dc7c5f7587" translate="yes" xml:space="preserve">
          <source>When you call a method with the &lt;code&gt;.foo()&lt;/code&gt; syntax, it&amp;rsquo;s often wise to introduce a newline and other whitespace to help break up long lines. We could have written this code as:</source>
          <target state="translated">当使用 &lt;code&gt;.foo()&lt;/code&gt; 语法调用方法时，通常明智的做法是引入换行符和其他空格以帮助分隔长行。我们可以将这段代码编写为：</target>
        </trans-unit>
        <trans-unit id="05246324bae5d78696c081ca3bb969c9b5f76aa9" translate="yes" xml:space="preserve">
          <source>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement &lt;code&gt;FnOnce&lt;/code&gt; because they can all be called at least once. Closures that don&amp;rsquo;t move the captured variables also implement &lt;code&gt;FnMut&lt;/code&gt;, and closures that don&amp;rsquo;t need mutable access to the captured variables also implement &lt;code&gt;Fn&lt;/code&gt;. In Listing 13-12, the &lt;code&gt;equal_to_x&lt;/code&gt; closure borrows &lt;code&gt;x&lt;/code&gt; immutably (so &lt;code&gt;equal_to_x&lt;/code&gt; has the &lt;code&gt;Fn&lt;/code&gt; trait) because the body of the closure only needs to read the value in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">创建闭包时，Rust根据闭包如何使用环境中的值来推断要使用的特征。所有的闭包都实现 &lt;code&gt;FnOnce&lt;/code&gt; ,因为它们至少可以被调用一次。不移动捕获变量的闭包也实现 &lt;code&gt;FnMut&lt;/code&gt; ，不需要对捕获变量进行可变访问的闭包也实现 &lt;code&gt;Fn&lt;/code&gt; 。在清单13-12中， &lt;code&gt;equal_to_x&lt;/code&gt; 闭包不可变地借用 &lt;code&gt;x&lt;/code&gt; （因此 &lt;code&gt;equal_to_x&lt;/code&gt; 具有 &lt;code&gt;Fn&lt;/code&gt; 特性），因为闭包的主体仅需要读取 &lt;code&gt;x&lt;/code&gt; 中的值。</target>
        </trans-unit>
        <trans-unit id="4b225d4c2d0c02a52b23cd1b31dafb9bb8378985" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data and you want to transfer ownership but ensure the data won&amp;rsquo;t be copied when you do so</source>
          <target state="translated">当您拥有大量数据并且想要转移所有权但要确保在执行此操作时不会复制数据</target>
        </trans-unit>
        <trans-unit id="1616d0bcec37e1d1974f0cec040ed2afa3965cea" translate="yes" xml:space="preserve">
          <source>When you have a type whose size can&amp;rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size</source>
          <target state="translated">如果您有一个在编译时无法得知其大小的类型，并且想要在需要精确大小的上下文中使用该类型的值</target>
        </trans-unit>
        <trans-unit id="faaa349bf2d53d10371fecd29ecbff47ff56b1b0" translate="yes" xml:space="preserve">
          <source>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</source>
          <target state="translated">当你在代码中发现有多个结构体或枚举定义的情况,而这些结构体或枚举定义仅在它们所持有的值的类型上有所不同时,你可以通过使用通用类型来避免重复。</target>
        </trans-unit>
        <trans-unit id="679e3b066cfac92df42c0662cfeca1f3e83d745f" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;cargo check&lt;/code&gt; again, you&amp;rsquo;ll get a few more warnings, but it should succeed.</source>
          <target state="translated">再次运行 &lt;code&gt;cargo check&lt;/code&gt; 时，还会收到一些警告，但应该会成功。</target>
        </trans-unit>
        <trans-unit id="6448bbefd235d50e1c725bdf06e891f730d7d66b" translate="yes" xml:space="preserve">
          <source>When you run it, you won&amp;rsquo;t get the path of the original executable, you&amp;rsquo;ll get the path of the hard link:</source>
          <target state="translated">运行它时，您将不会获得原始可执行文件的路径，而会获得硬链接的路径：</target>
        </trans-unit>
        <trans-unit id="30a9b27f023546ce78e3fa8bcc73ea93a891ddb0" translate="yes" xml:space="preserve">
          <source>When you run multiple tests, by default they run in parallel using threads. This means the tests will finish running faster so you can get feedback quicker on whether or not your code is working. Because the tests are running at the same time, make sure your tests don&amp;rsquo;t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</source>
          <target state="translated">当您运行多个测试时，默认情况下它们使用线程并行运行。这意味着测试将更快地完成运行，因此您可以更快地获得有关代码是否正常工作的反馈。由于测试是同时运行的，因此请确保您的测试不相互依赖，也不依赖任何共享状态，包括共享环境，例如当前的工作目录或环境变量。</target>
        </trans-unit>
        <trans-unit id="bdd64a76c4764e34bb256afe510d04a4140ab743" translate="yes" xml:space="preserve">
          <source>When you run the code, your output should look something like this:</source>
          <target state="translated">当你运行这段代码时,你的输出应该是这样的。</target>
        </trans-unit>
        <trans-unit id="56a080f28d7b938e415697722d1eaa5194296964" translate="yes" xml:space="preserve">
          <source>When you run the program, you&amp;rsquo;ll see something like this:</source>
          <target state="translated">当您运行该程序时，您将看到类似以下内容：</target>
        </trans-unit>
        <trans-unit id="9d0f951f7def4bb9ddc934064d83b22842550653" translate="yes" xml:space="preserve">
          <source>When you run this code, it will compile but will display a warning:</source>
          <target state="translated">当你运行这段代码时,它会编译,但会显示一个警告。</target>
        </trans-unit>
        <trans-unit id="cd11ee578beeab8bff18cf7df74988e81ef63b8d" translate="yes" xml:space="preserve">
          <source>When you run this program, the error you&amp;rsquo;ll get looks like this:</source>
          <target state="translated">当您运行该程序时，您将收到如下错误：</target>
        </trans-unit>
        <trans-unit id="88bf968fcfba3ccae7b190e45758bbe17d47d594" translate="yes" xml:space="preserve">
          <source>When you see a call to &lt;code&gt;clone&lt;/code&gt;, you know that some arbitrary code is being executed and that code may be expensive. It&amp;rsquo;s a visual indicator that something different is going on.</source>
          <target state="translated">当您看到对 &lt;code&gt;clone&lt;/code&gt; 的调用时，您知道正在执行一些任意代码，并且这些代码可能会很昂贵。这是一个视觉指示器，表明发生了一些不同的情况。</target>
        </trans-unit>
        <trans-unit id="dba00a225c49d7aad6a4c3e2fefc5b6ad717617e" translate="yes" xml:space="preserve">
          <source>When you understand ownership, you&amp;rsquo;ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you&amp;rsquo;ll learn ownership by working through some examples that focus on a very common data structure: strings.</source>
          <target state="translated">了解所有权后，您将拥有坚实的基础，可以理解使Rust独树一帜的功能。在本章中，您将通过研究一些关注非常常见的数据结构的示例（字符串）来学习所有权。</target>
        </trans-unit>
        <trans-unit id="fb9b6ed06b18947df730bd329065f971ebc43888" translate="yes" xml:space="preserve">
          <source>When you want a function to have multiple parameters, separate the parameter declarations with commas, like this:</source>
          <target state="translated">当你想让一个函数有多个参数时,可以用逗号分隔参数声明,就像这样。</target>
        </trans-unit>
        <trans-unit id="7140942a9e83dd3630a3c0916a44b851e25bd0ab" translate="yes" xml:space="preserve">
          <source>When you want to own a value and you care only that it&amp;rsquo;s a type that implements a particular trait rather than being of a specific type</source>
          <target state="translated">当您想拥有一个值并且只关心它是实现特定特征的类型而不是特定类型时</target>
        </trans-unit>
        <trans-unit id="a38101ccd42a1c4f79b06b155e4e46b8f79f9a7b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error. If you want to wrap explicitly, you can use the standard library type &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt;&lt;code&gt;Wrapping&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当你在释放模式下编译 &lt;code&gt;--release&lt;/code&gt; 标志，锈也&lt;em&gt;未&lt;/em&gt;包括整数溢出是造成恐慌的检查。相反，如果发生溢出，Rust将执行&lt;em&gt;二进制补码&lt;/em&gt;。简而言之，大于类型可以保持的最大值的值&amp;ldquo;环绕&amp;rdquo;到类型可以保持的最小值。在 &lt;code&gt;u8&lt;/code&gt; 的情况下，256变为0，257变为1，依此类推。该程序不会出现紧急情况，但是该变量的值可能不是您期望的值。依赖整数溢出的包装行为被视为错误。如果要显式包装，则可以使用标准库类型&lt;a href=&quot;../std/num/struct.wrapping&quot;&gt; &lt;code&gt;Wrapping&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf6294d1d4938dc2164807d070a9e5a24c528b0b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</source>
          <target state="translated">互斥锁保护的数据处理完毕后，必须解锁数据，以便其他线程可以获取锁定。</target>
        </trans-unit>
        <trans-unit id="87ed8d0c79155dbc381301582c028a0bc87a94b1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to move on, we&amp;rsquo;ll talk about a concept in Rust that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; commonly exist in other programming languages: ownership.</source>
          <target state="translated">当您准备好继续前进时，我们将讨论Rust 中其他编程语言&lt;em&gt;中不&lt;/em&gt;常见的概念：所有权。</target>
        </trans-unit>
        <trans-unit id="338c49418a81c4fe8cdbaa3398a7f70c772eed82" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a function whose implementation calls something that might fail, instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as &lt;em&gt;propagating&lt;/em&gt; the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</source>
          <target state="translated">当您编写一个函数的实现调用可能失败的函数时，可以将错误返回给调用代码，以便它可以决定要做什么，而不是处理该函数中的错误。这被称为&lt;em&gt;传播&lt;/em&gt;错误，并赋予调用代码更多的控制权，那里可能有更多的信息或逻辑来规定应如何处理错误，而不是代码上下文中可用的信息或逻辑。</target>
        </trans-unit>
        <trans-unit id="52116b6d188a2650ef7d8367c1d460637ef198b9" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a program, if you don&amp;rsquo;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&amp;rsquo;t work. Instead, you can use a trait object, which we&amp;rsquo;ll cover in Chapter 17.</source>
          <target state="translated">在编写程序时，如果您不知道程序将在运行时获取的完整类型集以存储在向量中，则枚举技术将不起作用。相反，您可以使用trait对象，我们将在第17章中介绍。</target>
        </trans-unit>
        <trans-unit id="a6c702a723f263e7d6b8ef006b195ad04de8148a" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear. In examples, it&amp;rsquo;s understood that a call to a method like &lt;code&gt;unwrap&lt;/code&gt; that could panic is meant as a placeholder for the way you&amp;rsquo;d want your application to handle errors, which can differ based on what the rest of your code is doing.</source>
          <target state="translated">当您编写示例以说明一些概念时，在示例中也使用健壮的错误处理代码可能会使示例不清楚。在示例中，可以理解的是，对可能引起恐慌的诸如 &lt;code&gt;unwrap&lt;/code&gt; 之类的方法的调用，是作为您希望应用程序处理错误的方式的占位符，该错误可能根据其余代码的执行情况而有所不同。</target>
        </trans-unit>
        <trans-unit id="c42c6bb649d897cae512ccb086d5d0b9efa0b2d4" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;ve made changes to your crate and are ready to release a new version, you change the &lt;code&gt;version&lt;/code&gt; value specified in your &lt;em&gt;Cargo.toml&lt;/em&gt; file and republish. Use the &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning rules&lt;/a&gt; to decide what an appropriate next version number is based on the kinds of changes you&amp;rsquo;ve made. Then run &lt;code&gt;cargo publish&lt;/code&gt; to upload the new version.</source>
          <target state="translated">更改完包装箱并准备发布新版本后，可以更改在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中指定的 &lt;code&gt;version&lt;/code&gt; 值，然后重新发布。使用&amp;ldquo; &lt;a href=&quot;http://semver.org/&quot;&gt;语义版本控制&amp;rdquo;规则&lt;/a&gt;，根据您所做的更改来决定合适的下一版本号。然后运行 &lt;code&gt;cargo publish&lt;/code&gt; 上传新版本。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a63fa0940baafe694284e32babae3f74d6ff198c" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a2affd429f9e55f7202252260760e859abffb5" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839440b70c5a7ad1d7e470fedb75657493aedb6e" translate="yes" xml:space="preserve">
          <source>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function&amp;rsquo;s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</source>
          <target state="translated">当您的代码调用函数时，传递给函数的值（可能包括指向堆上数据的指针）和函数的局部变量将被压入堆栈。函数结束后，这些值将从堆栈中弹出。</target>
        </trans-unit>
        <trans-unit id="7fc4ed82b7b946f127718773ea3ac4f397f59537" translate="yes" xml:space="preserve">
          <source>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&amp;rsquo;t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call &lt;code&gt;panic!&lt;/code&gt; if you attempt an out-of-bounds memory access: trying to access memory that doesn&amp;rsquo;t belong to the current data structure is a common security problem. Functions often have &lt;em&gt;contracts&lt;/em&gt;: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&amp;rsquo;s not a kind of error you want the calling code to have to explicitly handle. In fact, there&amp;rsquo;s no reasonable way for calling code to recover; the calling &lt;em&gt;programmers&lt;/em&gt; need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</source>
          <target state="translated">当您的代码对值执行操作时，您的代码应首先验证值有效，如果值无效，则应恐慌。这主要是出于安全原因：尝试对无效数据进行操作会使您的代码容易受到攻击。这是标准库将 &lt;code&gt;panic!&lt;/code&gt; 主要原因！如果您尝试越界访问内存：尝试访问不属于当前数据结构的内存是一个常见的安全问题。功能通常有&lt;em&gt;合同&lt;/em&gt;：仅当输入满足特定要求时，才能保证其行为。违反合同时恐慌是有道理的，因为违反合同总是表示调用方错误，这不是您希望调用代码必须明确处理的错误。实际上，没有合理的方法来调用代码进行恢复。调用&lt;em&gt;程序员&lt;/em&gt;需要修复代码。有关功能的合同，特别是在违规会引起恐慌的情况下，应在该功能的API文档中进行说明。</target>
        </trans-unit>
        <trans-unit id="89c680949e7cd958d9cc4977874667c68a138ea6" translate="yes" xml:space="preserve">
          <source>When your project is finally ready for release, you can use &lt;code&gt;cargo build --release&lt;/code&gt; to compile it with optimizations. This command will create an executable in &lt;em&gt;target/release&lt;/em&gt; instead of &lt;em&gt;target/debug&lt;/em&gt;. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you&amp;rsquo;ll give to a user that won&amp;rsquo;t be rebuilt repeatedly and that will run as fast as possible. If you&amp;rsquo;re benchmarking your code&amp;rsquo;s running time, be sure to run &lt;code&gt;cargo build --release&lt;/code&gt; and benchmark with the executable in &lt;em&gt;target/release&lt;/em&gt;.</source>
          <target state="translated">当项目最终准备好发布时，您可以使用 &lt;code&gt;cargo build --release&lt;/code&gt; 进行优化编译。此命令将在&lt;em&gt;target / release中&lt;/em&gt;创建一个可执行文件，而不是&lt;em&gt;target / debug&lt;/em&gt;。这些优化使您的Rust代码运行得更快，但是打开它们会延长程序编译的时间。这就是为什么要使用两种不同的配置文件的原因：一种用于开发，当您想要快速且经常地进行重建时，另一种用于构建最终程序，您将提供给不会重复重建且运行速度与用户相同的用户可能。如果您要对代码的运行时间进行基准测试，请确保使用&lt;em&gt;目标/ release中&lt;/em&gt;的可执行文件运行 &lt;code&gt;cargo build --release&lt;/code&gt; 和基准测试。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3d1e3a329799ed0876a4d1ad716f19e4a9cec94" translate="yes" xml:space="preserve">
          <source>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the &lt;code&gt;let&lt;/code&gt;. This is illustrated in the example above by showing that &lt;code&gt;tmp&lt;/code&gt; would be freed as we exit the block.</source>
          <target state="translated">每当创建临时文件时，都会根据固定规则自动将其删除（释放）。通常，在包含语句的末尾（在这种情况下，在 &lt;code&gt;let&lt;/code&gt; 之后）删除临时项。在上面的示例中通过显示 &lt;code&gt;tmp&lt;/code&gt; 在退出该块时将被释放来说明了这一点。</target>
        </trans-unit>
        <trans-unit id="0d66101f5b82c22f64225217f832b8e7af03aba9" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3c7f91ce843a180fc6f430d195fed72f860109" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4432a187ec3056ddd9bd907b999948f00874c" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferrable to use &lt;a href=&quot;#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在任何可能的情况下，最好都使用而非&lt;a href=&quot;#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt;方式，它可以防止重复 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4de23a7f6719a7ba57b078ca4ff7e8250001b36" translate="yes" xml:space="preserve">
          <source>Where clauses</source>
          <target state="translated">凡条款</target>
        </trans-unit>
        <trans-unit id="9b0b082cc3c369bcfe0d32cc803440f9644c559a" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s the &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operator?</source>
          <target state="translated">&lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; 运算符在哪里？</target>
        </trans-unit>
        <trans-unit id="d4ea105a6df2620f7975d097e826dec6963287a4" translate="yes" xml:space="preserve">
          <source>Whether or not to evaluate the sub-expressions when evaluating the expression</source>
          <target state="translated">在评价表达式时,是否对子表达式进行评价?</target>
        </trans-unit>
        <trans-unit id="7441400ac9aa4ede2210143836e6a213067deff4" translate="yes" xml:space="preserve">
          <source>Whew! Now you have some Rust features in your toolbox that you won&amp;rsquo;t use often, but you&amp;rsquo;ll know they&amp;rsquo;re available in very particular circumstances. We&amp;rsquo;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&amp;rsquo; code, you&amp;rsquo;ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</source>
          <target state="translated">ew！现在，您的工具箱中有一些不经常使用的Rust功能，但是您会知道它们在非常特殊的情况下可用。我们介绍了几个复杂的主题，因此当您在错误消息建议或其他人的代码中遇到这些主题时，您将能够识别这些概念和语法。使用本章作为参考，以指导您找到解决方案。</target>
        </trans-unit>
        <trans-unit id="ecbdd73494930b04d58d59a497ec54128fcf95a8" translate="yes" xml:space="preserve">
          <source>Whew! That was a lot of work, but we&amp;rsquo;ve set ourselves up for success in the future. Now it&amp;rsquo;s much easier to handle errors, and we&amp;rsquo;ve made the code more modular. Almost all of our work will be done in &lt;em&gt;src/lib.rs&lt;/em&gt; from here on out.</source>
          <target state="translated">ew！那是很多工作，但是我们为将来的成功做好了准备。现在，更容易处理错误，并且我们使代码更加模块化。从现在开始，几乎所有工作都将在&lt;em&gt;src / lib.rs中&lt;/em&gt;完成。</target>
        </trans-unit>
        <trans-unit id="357b219e220334335cb6c179ad0fbd5be62e5879" translate="yes" xml:space="preserve">
          <source>Whew! We &lt;em&gt;also&lt;/em&gt; cannot have a mutable reference while we have an immutable one. Users of an immutable reference don&amp;rsquo;t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&amp;rsquo;s reading of the data.</source>
          <target state="translated">ew！当我们拥有不变的参考时，我们&lt;em&gt;也&lt;/em&gt;不能拥有可变的参考。不变引用的用户不要期望值会突然从它们下面改变！但是，可以使用多个不可变的引用，因为没有人会影响其他任何人对数据的读取。</target>
        </trans-unit>
        <trans-unit id="c4abab176ad04758c7995b5bf1a8ebbc48d27dab" translate="yes" xml:space="preserve">
          <source>Which configuration options are set is determined statically during the compilation of the crate. Certain options are &lt;em&gt;compiler-set&lt;/em&gt; based on data about the compilation. Other options are &lt;em&gt;arbitrarily-set&lt;/em&gt;, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.</source>
          <target state="translated">设置哪些配置选项是在板条箱的编译过程中静态确定的。某些选项是基于有关编译数据的编译&lt;em&gt;器设置&lt;/em&gt;的。其他选项是&lt;em&gt;任意设置&lt;/em&gt;，基于代码外传递给编译器的输入进行设置。无法从正在编译的板条箱的源代码中设置配置选项。</target>
        </trans-unit>
        <trans-unit id="aec19e71f7245e5468afe6ba28062c55126000f9" translate="yes" xml:space="preserve">
          <source>Which kind of future are we turning this into?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e64a82a5b16af1f23a177677675bfbfea39f34c" translate="yes" xml:space="preserve">
          <source>Which kind of iterator are we turning this into?</source>
          <target state="translated">我们要把这个变成哪种迭代器?</target>
        </trans-unit>
        <trans-unit id="0807125208cee959762c24f1a5a66bea0dc3bb1c" translate="yes" xml:space="preserve">
          <source>Which method works best depends on what kind of situation you're in.</source>
          <target state="translated">哪种方法最有效,要看你是在什么样的情况下。</target>
        </trans-unit>
        <trans-unit id="f77bbb1b800fe27a58f9b1a9edd741074b14ca16" translate="yes" xml:space="preserve">
          <source>Which of our two &lt;code&gt;HasDrop&lt;/code&gt; drops first, though? For structs, it's the same order that they're declared: first &lt;code&gt;one&lt;/code&gt;, then &lt;code&gt;two&lt;/code&gt;. If you'd like to try this yourself, you can modify &lt;code&gt;HasDrop&lt;/code&gt; above to contain some data, like an integer, and then use it in the &lt;code&gt;println!&lt;/code&gt; inside of &lt;code&gt;Drop&lt;/code&gt;. This behavior is guaranteed by the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381bdae639e5c41f0066a4ced8cdfc3fa580e603" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; is very useful for removing errors, &lt;code&gt;!&lt;/code&gt; can also be used to remove successes as well. If we think of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; as &quot;if this function returns, it has not errored,&quot; we get a very intuitive idea of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; as well: if the function returns, it &lt;em&gt;has&lt;/em&gt; errored.</source>
          <target state="translated">虽然&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt;是去除错误是非常有用的， &lt;code&gt;!&lt;/code&gt; 也可以用来消除成功。如果我们将&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt;认为是&amp;ldquo;如果此函数返回，则不会出错&amp;rdquo;，我们也可以很直观地看到&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt;：如果函数返回，则说明&lt;em&gt;已&lt;/em&gt;出错。</target>
        </trans-unit>
        <trans-unit id="040144073c8f0dfdb2720a3a96450c0f97978b7d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;MaybeUninit&lt;/code&gt; is &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (indicating it guarantees the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;), this does &lt;em&gt;not&lt;/em&gt; change any of the previous caveats. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; may still have different sizes, and types containing a field of type &lt;code&gt;T&lt;/code&gt; may be laid out (and sized) differently than if that field were &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;MaybeUninit&lt;/code&gt; is a union type, and &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions is unstable (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;the tracking issue&lt;/a&gt;). Over time, the exact guarantees of &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions may evolve, and &lt;code&gt;MaybeUninit&lt;/code&gt; may or may not remain &lt;code&gt;#[repr(transparent)]&lt;/code&gt;. That said, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; guarantee that it has the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;; it's just that the way &lt;code&gt;MaybeUninit&lt;/code&gt; implements that guarantee may evolve.</source>
          <target state="translated">虽然 &lt;code&gt;MaybeUninit&lt;/code&gt; 是 &lt;code&gt;#[repr(transparent)]&lt;/code&gt; （指示它保证相同的尺寸，取向，和ABI为 &lt;code&gt;T&lt;/code&gt; ），这并&lt;em&gt;不会&lt;/em&gt;改变任何先前的警告的。 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 仍可能具有不同的大小，并且包含该类型 &lt;code&gt;T&lt;/code&gt; 的字段的类型（和大小）的布局（和大小）可能与该字段为 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 。 &lt;code&gt;MaybeUninit&lt;/code&gt; 是联合类型，联合上的 &lt;code&gt;#[repr(transparent)]&lt;/code&gt; 不稳定（请参阅&lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;跟踪问题&lt;/a&gt;）。随着时间的推移， &lt;code&gt;#[repr(transparent)]&lt;/code&gt; 对联合的确切保证可能会演变，并且 &lt;code&gt;MaybeUninit&lt;/code&gt; 可能保留也可能不保留 &lt;code&gt;#[repr(transparent)]&lt;/code&gt; 。这就是说， &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 将&lt;em&gt;始终&lt;/em&gt;保证它具有相同的大小，对齐，和ABI为 &lt;code&gt;T&lt;/code&gt; ; 只是 &lt;code&gt;MaybeUninit&lt;/code&gt; 实现保证的方式可能会演变。</target>
        </trans-unit>
        <trans-unit id="b5f05e101ccc42742a41d22d19ff794b2f1ec6bc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TypeId&lt;/code&gt; implements &lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;, it is worth noting that the hashes and ordering will vary between Rust releases. Beware of relying on them inside of your code!</source>
          <target state="translated">尽管 &lt;code&gt;TypeId&lt;/code&gt; 实现了 &lt;code&gt;Hash&lt;/code&gt; ， &lt;code&gt;PartialOrd&lt;/code&gt; 和 &lt;code&gt;Ord&lt;/code&gt; ，但值得注意的是，Rust版本之间的哈希值和顺序将有所不同。当心在代码中依赖它们！</target>
        </trans-unit>
        <trans-unit id="6d4c0b858b921a1aa9b09d6f6ffff138728f277d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;mem::forget&lt;/code&gt; can also be used to transfer &lt;em&gt;memory&lt;/em&gt; ownership, doing so is error-prone. &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; should be used instead. Consider, for example, this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef43e2f499fb4e7ebf44c6c96560fe3863b368a0" translate="yes" xml:space="preserve">
          <source>While Rust strings may contain nul bytes in the middle, C strings can't, as that byte would effectively truncate the string.</source>
          <target state="translated">Rust 字符串可以在中间包含 nul 字节,而 C 字符串则不能,因为那个字节会有效地截断字符串。</target>
        </trans-unit>
        <trans-unit id="9b96c7bdcb6a7fde4fa090bcc724c51dcf154ff7" translate="yes" xml:space="preserve">
          <source>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be &quot;bridging&quot; some Windows APIs together, just passing &lt;code&gt;WCHAR&lt;/code&gt; strings among those APIs without ever really looking into the strings.</source>
          <target state="translated">虽然并非总是可以无损地将这样的字符串转换为有效的UTF-16字符串（甚至是UTF-8），但是通常希望能够无损地将这样的字符串往返于Windows API。例如，某些Rust代码可能将某些Windows API&amp;ldquo;桥接&amp;rdquo;在一起，仅在这些API之间传递 &lt;code&gt;WCHAR&lt;/code&gt; 字符串，而无需真正研究这些字符串。</target>
        </trans-unit>
        <trans-unit id="94ebb9d6a417c21d0e98155c75c39327ba03733c" translate="yes" xml:space="preserve">
          <source>While it might seem strange to have a function that just returns back the input, there are some interesting uses.</source>
          <target state="translated">虽然有一个只返回输入的函数似乎很奇怪,但也有一些有趣的用途。</target>
        </trans-unit>
        <trans-unit id="97e4502df2c17c97ddd6625eabaef88cae532a3d" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2427b468d47a7420d460c3c9434666519bb67a" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">进行迭代时，如果环境中的任何键或值都不是有效的unicode，则返回的迭代器将发生混乱。如果不希望这样做，请考虑使用&lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;env::vars_os&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="88abee318504f329611b88069221a80488cf9999" translate="yes" xml:space="preserve">
          <source>While performing error handling it is often useful to implement &lt;code&gt;From&lt;/code&gt; for your own error type. By converting underlying error types to our own custom error type that encapsulates the underlying error type, we can return a single error type without losing information on the underlying cause. The '?' operator automatically converts the underlying error type to our custom error type by calling &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; which is automatically provided when implementing &lt;code&gt;From&lt;/code&gt;. The compiler then infers which implementation of &lt;code&gt;Into&lt;/code&gt; should be used.</source>
          <target state="translated">在执行错误处理时，通常对于您自己的错误类型实施 &lt;code&gt;From&lt;/code&gt; 很有用。通过将基础错误类型转换为封装了基础错误类型的我们自己的自定义错误类型，我们可以返回单个错误类型，而不会丢失有关基础原因的信息。 '？'操作员通过调用 &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; 来自动将基础错误类型转换为我们的自定义错误类型，该类型在实现 &lt;code&gt;From&lt;/code&gt; 时自动提供。然后，编译器会推断应使用 &lt;code&gt;Into&lt;/code&gt; 的哪种实现。</target>
        </trans-unit>
        <trans-unit id="21a3472b42943360038c378154c72aeef876d83b" translate="yes" xml:space="preserve">
          <source>While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are &lt;a href=&quot;#primitives&quot;&gt;documented in the section on primitives&lt;/a&gt;.</source>
          <target state="translated">由编译器实现原语时，标准库直接在原语类型上实现方法（这是唯一这样做的库），这&lt;a href=&quot;#primitives&quot;&gt;在原语部分中进行了介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2a8167e66f949c278500fe8a0d882045622dfbf" translate="yes" xml:space="preserve">
          <source>While the following example is sound, there is a memory leak since the inner vectors were not freed prior to the &lt;code&gt;set_len&lt;/code&gt; call:</source>
          <target state="translated">尽管下面的示例很合理，但是由于在调用 &lt;code&gt;set_len&lt;/code&gt; 之前没有释放内部向量，因此存在内存泄漏：</target>
        </trans-unit>
        <trans-unit id="c01f6f794efd0c185cdbd0acdeb3770eddfc8772" translate="yes" xml:space="preserve">
          <source>While there could be a more fine-grained scheme in the future that allows mutable references if they are not &quot;leaked&quot; to the final value, a more conservative approach was chosen for now. &lt;code&gt;const fn&lt;/code&gt; do not have this problem, as the borrow checker will prevent the &lt;code&gt;const fn&lt;/code&gt; from returning new mutable references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce58c9d13deabade9d0031e57b5c561b8bbc9a7" translate="yes" xml:space="preserve">
          <source>While these:</source>
          <target state="translated">虽然这些:</target>
        </trans-unit>
        <trans-unit id="5d891980461c7894b78072e4c40fd8f0ee9d4fc4" translate="yes" xml:space="preserve">
          <source>While this means the &lt;code&gt;String&lt;/code&gt; will have a length of zero, it does not touch its capacity.</source>
          <target state="translated">虽然这意味着 &lt;code&gt;String&lt;/code&gt; 的长度为零，但不会影响其容量。</target>
        </trans-unit>
        <trans-unit id="1461d256887a81f77bef33d763313b5547fde61d" translate="yes" xml:space="preserve">
          <source>While this method and its mutable counterpart are useful for null-safety, it is important to note that this is still an unsafe operation because the returned value could be pointing to invalid memory.</source>
          <target state="translated">虽然这个方法和它的可突变对应方法对空安全很有用,但需要注意的是,这仍然是一个不安全的操作,因为返回的值可能指向无效的内存。</target>
        </trans-unit>
        <trans-unit id="ee1ba6c8d8e736d86285c52e19961693ec306982" translate="yes" xml:space="preserve">
          <source>While this trait is unstable, the methods are stable. &lt;code&gt;SliceConcatExt&lt;/code&gt; is included in the &lt;a href=&quot;../prelude/index&quot;&gt;standard library prelude&lt;/a&gt;, so you can use &lt;a href=&quot;#tymethod.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; as if they existed on &lt;code&gt;[T]&lt;/code&gt; itself.</source>
          <target state="translated">尽管此特征不稳定，但方法是稳定的。 &lt;code&gt;SliceConcatExt&lt;/code&gt; 包含在&lt;a href=&quot;../prelude/index&quot;&gt;标准库的prelude中&lt;/a&gt;，因此您可以使用&lt;a href=&quot;#tymethod.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#tymethod.concat&quot;&gt; &lt;code&gt;concat()&lt;/code&gt; &lt;/a&gt;，就好像它们存在于 &lt;code&gt;[T]&lt;/code&gt; 本身上一样。</target>
        </trans-unit>
        <trans-unit id="3b5f26a246fb02c7cc6b4b29c460a0d1e8dc7640" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the &lt;a href=&quot;../prelude/index&quot;&gt;prelude&lt;/a&gt;'s import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3f0c0f2ca43b389646c40f7923cc632b8f8da" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the prelude's import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常的Rust风格是直接导入类型，而&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; 的&lt;/a&gt;别名通常不是，以便于区分它们。通常假定&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt;，因此使用此别名的用户通常将使用 &lt;code&gt;io::Result&lt;/code&gt; 而不是掩盖前奏曲中&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt;的导入。</target>
        </trans-unit>
        <trans-unit id="8ba71bc00b481e82beeb9921c07aacd0590f6bd1" translate="yes" xml:space="preserve">
          <source>While you are looking at that &lt;code&gt;[-]&lt;/code&gt; button also notice the &lt;code&gt;[src]&lt;/code&gt; button. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.</source>
          <target state="translated">当您查看该 &lt;code&gt;[-]&lt;/code&gt; 按钮时，还请注意 &lt;code&gt;[src]&lt;/code&gt; 按钮。Rust的API文档附带了源代码，建议您阅读。标准库的资源通常是高质量的，通常可以启发人们对幕后的了解。</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5bd6985bffedbe45212e5ed4b8d7b10e4e8bfe85" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;a href=&quot;https://www.unicode.org/reports/tr31/&quot;&gt;&lt;code&gt;Pattern_White_Space&lt;/code&gt;&lt;/a&gt; Unicode property, namely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff785990fe44822be8ffd4354e290cef0c34c873" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode property, namely:</source>
          <target state="translated">空格是任何非空字符串，仅包含具有 &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode属性的字符，即：</target>
        </trans-unit>
        <trans-unit id="9831741f3701cd2501051eea04df81e500fcac28" translate="yes" xml:space="preserve">
          <source>Who Rust Is For</source>
          <target state="translated">生锈是为了谁</target>
        </trans-unit>
        <trans-unit id="73012c2e29394e650b32f0b4934e8028ea0802a0" translate="yes" xml:space="preserve">
          <source>Who This Book Is For</source>
          <target state="translated">本书适合谁</target>
        </trans-unit>
        <trans-unit id="43d9a912852b85357d25bd06b5c4e243076f38d3" translate="yes" xml:space="preserve">
          <source>Who implements &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">谁实施 &lt;code&gt;UnwindSafe&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="e36799f202c4d0ce55f224011110c6d687f10837" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;filter_map&lt;/code&gt; and not just &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;? The key is in this part:</source>
          <target state="translated">为什么选择 &lt;code&gt;filter_map&lt;/code&gt; 而不仅仅是&lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;？关键在这一部分：</target>
        </trans-unit>
        <trans-unit id="f5b054d5badd7795d72a342651abfb7fc1f4dad9" translate="yes" xml:space="preserve">
          <source>Why do I get this message with code that doesn't involve borrowing?</source>
          <target state="translated">为什么我在使用不涉及借用的代码时,会得到这个消息?</target>
        </trans-unit>
        <trans-unit id="996dd8b0e5f1405cbf0cea853468ae25180b7c3c" translate="yes" xml:space="preserve">
          <source>Why would you not want an executable? Often, &lt;code&gt;cargo check&lt;/code&gt; is much faster than &lt;code&gt;cargo build&lt;/code&gt;, because it skips the step of producing an executable. If you&amp;rsquo;re continually checking your work while writing the code, using &lt;code&gt;cargo check&lt;/code&gt; will speed up the process! As such, many Rustaceans run &lt;code&gt;cargo check&lt;/code&gt; periodically as they write their program to make sure it compiles. Then they run &lt;code&gt;cargo build&lt;/code&gt; when they&amp;rsquo;re ready to use the executable.</source>
          <target state="translated">为什么不想要可执行文件？通常， &lt;code&gt;cargo check&lt;/code&gt; 比 &lt;code&gt;cargo build&lt;/code&gt; 要快得多，因为它跳过了生成可执行文件的步骤。如果您在编写代码时不断检查工作，使用 &lt;code&gt;cargo check&lt;/code&gt; 将加快流程！因此，许多Rustaceans在编写程序以确保编译时会定期进行 &lt;code&gt;cargo check&lt;/code&gt; 。然后，当他们准备使用可执行文件时，他们将进行 &lt;code&gt;cargo build&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="a81276e6dfb0c035da01e2595ee9fa04fdc86e1e" translate="yes" xml:space="preserve">
          <source>Wildcard pattern</source>
          <target state="translated">通配符模式</target>
        </trans-unit>
        <trans-unit id="f4138f22664d37f96c263052adeb723fdfd7248c" translate="yes" xml:space="preserve">
          <source>Wildcards</source>
          <target state="translated">Wildcards</target>
        </trans-unit>
        <trans-unit id="dd04e2ae06e0c22d6b8a5c4141451a441cf23045" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0843bf815a9dab90b0636f270db8d304e5915a96" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">始终会返回相同的 &lt;code&gt;&amp;amp;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74ce1cb06587f571c24b39c88c3261da8e964077" translate="yes" xml:space="preserve">
          <source>Will handle the pattern &lt;code&gt;&quot;&quot;&lt;/code&gt; as returning empty matches at each character boundary.</source>
          <target state="translated">将在每个字符边界返回空匹配项时处理模式 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2a58ab6d8aaaf56805d5dcc5d08104ca8722e51" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;../str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cfca1876affe8c210a04c4805938a5cb452282" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="translated">如果无法将此字符串切片解析为所需的类型，则将返回&lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="17aebcc3873693512f66ff2029c56928afebc898" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf1c1efc2e097b96e98657a8262127bc226f8f4" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">Windows路径前缀，例如 &lt;code&gt;C:&lt;/code&gt; 或 &lt;code&gt;\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b25b9078d1c6b5cf7d0c03d87923967058f5d7a" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f64162f505580122671f38419aea6835f8c68d" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="translated">Windows使用各种路径前缀样式，包括对驱动器卷（如 &lt;code&gt;C:&lt;/code&gt; ：），网络共享文件夹（如 &lt;code&gt;\server\share&lt;/code&gt; ）和其他文件的引用。此外，一些路径前缀是&amp;ldquo;逐字&amp;rdquo;（即，前缀 &lt;code&gt;\?\&lt;/code&gt; ），在这种情况下 &lt;code&gt;/&lt;/code&gt; 是&lt;em&gt;没有&lt;/em&gt;处理过的作为隔板，并且基本上不进行归一化。</target>
        </trans-unit>
        <trans-unit id="7b773809bbe5f3adf18d472bfb1e18eaa3a7d486" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions for the primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::fs&lt;/code&gt; 模块中原语的Windows特定扩展。</target>
        </trans-unit>
        <trans-unit id="965b862fd7707ea01407f5bde9d76c4b33887700" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows特定的&lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="315ae7857105e3f47dabe009d9742ce6b255f1de" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows的&lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="e64c5541c43eacfdb85ccf07942595f788d2cb90" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows特定于&lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 的&lt;/a&gt;扩展名。</target>
        </trans-unit>
        <trans-unit id="8a739bab05e923c90296481bb09cc25239dd40e0" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;fs::File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00024f75ddf677c52ec0b6d2810b742570a31c11" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows特定于&lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; 的&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="c379abe31315129f29960307cac5c5a9ebe73ce4" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;fs::FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ae56a0a615ce91192a5ee5e6f95bfb7ba258a6" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows特定的&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="45de75b6c03804d7df1abb9816158b688e268757" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows特定的&lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt; &lt;code&gt;fs::OpenOptions&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="94d3d733eec0453c12d54d6f46b9364d74ffa234" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows特定的扩展程序，用于&lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt; &lt;code&gt;process::ExitStatus&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6631cb576a83d66476aa6a96c888a47fea46888b" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to general I/O primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd50699b2495e189ba2c74247886850721ca3204" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="translated">Windows对&lt;a href=&quot;../../../process/struct.command&quot;&gt; &lt;code&gt;process::Command&lt;/code&gt; &lt;/a&gt;构建器的扩展。</target>
        </trans-unit>
        <trans-unit id="72c2a1cf40aca0e7999edbbce4beb69846664076" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="translated">Windows对 &lt;code&gt;std::ffi&lt;/code&gt; 模块中的原语的扩展。</target>
        </trans-unit>
        <trans-unit id="6a36d28de36794d012a45ca83704dfdf241f6fac" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives</source>
          <target state="translated">窗口专用基元</target>
        </trans-unit>
        <trans-unit id="a29244317dd706a76b2545e981c947b9fe3e3b2c" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faf80579510e395a13fd315a37c59f2f038321b" translate="yes" xml:space="preserve">
          <source>Windows::all</source>
          <target state="translated">Windows::all</target>
        </trans-unit>
        <trans-unit id="6716af8ef731d4cbf5689fbdfb93409bf05643fa" translate="yes" xml:space="preserve">
          <source>Windows::any</source>
          <target state="translated">Windows::any</target>
        </trans-unit>
        <trans-unit id="700457e5baeb9db95e547cef9c74633bc4d41f0d" translate="yes" xml:space="preserve">
          <source>Windows::borrow</source>
          <target state="translated">Windows::borrow</target>
        </trans-unit>
        <trans-unit id="17164b9bb020d976e93adc4baa902877434e8dcf" translate="yes" xml:space="preserve">
          <source>Windows::borrow_mut</source>
          <target state="translated">Windows::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31908ffdddda768740e732a89602628774aabf19" translate="yes" xml:space="preserve">
          <source>Windows::by_ref</source>
          <target state="translated">Windows::by_ref</target>
        </trans-unit>
        <trans-unit id="f3d0e279ef4b7617f62329eac02e5ee30b537a4a" translate="yes" xml:space="preserve">
          <source>Windows::chain</source>
          <target state="translated">Windows::chain</target>
        </trans-unit>
        <trans-unit id="dc2580c31dfca64d3e4362d3193516de3088323f" translate="yes" xml:space="preserve">
          <source>Windows::clone</source>
          <target state="translated">Windows::clone</target>
        </trans-unit>
        <trans-unit id="a98bb41ccc08f765218084e917668531933467aa" translate="yes" xml:space="preserve">
          <source>Windows::clone_from</source>
          <target state="translated">Windows::clone_from</target>
        </trans-unit>
        <trans-unit id="561b1708f321b704fa9eba574176baec35025d94" translate="yes" xml:space="preserve">
          <source>Windows::clone_into</source>
          <target state="translated">Windows::clone_into</target>
        </trans-unit>
        <trans-unit id="9c9f0c0979265913d55cdfc2ebb0045f5a724bb0" translate="yes" xml:space="preserve">
          <source>Windows::cloned</source>
          <target state="translated">Windows::cloned</target>
        </trans-unit>
        <trans-unit id="a5b46f7f7dbd448b7a57c4223d0c87d1f200d2c6" translate="yes" xml:space="preserve">
          <source>Windows::cmp</source>
          <target state="translated">Windows::cmp</target>
        </trans-unit>
        <trans-unit id="fbb6b9c622af98d5a66bbf1cfbc26795253b7489" translate="yes" xml:space="preserve">
          <source>Windows::collect</source>
          <target state="translated">Windows::collect</target>
        </trans-unit>
        <trans-unit id="b4ad49bdadeff7d300af28e5eb3fa8051a92ccee" translate="yes" xml:space="preserve">
          <source>Windows::copied</source>
          <target state="translated">Windows::copied</target>
        </trans-unit>
        <trans-unit id="bd6d8af2e6984890043a2ffcecf64303ee4d2b67" translate="yes" xml:space="preserve">
          <source>Windows::count</source>
          <target state="translated">Windows::count</target>
        </trans-unit>
        <trans-unit id="a46aabac6f5fb33e90e0fa67da1b1c957391a4ba" translate="yes" xml:space="preserve">
          <source>Windows::cycle</source>
          <target state="translated">Windows::cycle</target>
        </trans-unit>
        <trans-unit id="54d929ec5d55c2868b2694194d22d67c995476cd" translate="yes" xml:space="preserve">
          <source>Windows::enumerate</source>
          <target state="translated">Windows::enumerate</target>
        </trans-unit>
        <trans-unit id="974003d8cd6730c68f798fb5852a1b8f66b8fc07" translate="yes" xml:space="preserve">
          <source>Windows::eq</source>
          <target state="translated">Windows::eq</target>
        </trans-unit>
        <trans-unit id="fcdcd8564c22f0d208d5887dca20b15981ed7eda" translate="yes" xml:space="preserve">
          <source>Windows::filter</source>
          <target state="translated">Windows::filter</target>
        </trans-unit>
        <trans-unit id="072316ad208e9676ec686940b97aee272075037a" translate="yes" xml:space="preserve">
          <source>Windows::filter_map</source>
          <target state="translated">Windows::filter_map</target>
        </trans-unit>
        <trans-unit id="c74c15ca962f2f3a44811fa2285bb43e26958f3d" translate="yes" xml:space="preserve">
          <source>Windows::find</source>
          <target state="translated">Windows::find</target>
        </trans-unit>
        <trans-unit id="786d8bedc7c35f14926b40554c0038bfc1b31ca1" translate="yes" xml:space="preserve">
          <source>Windows::find_map</source>
          <target state="translated">Windows::find_map</target>
        </trans-unit>
        <trans-unit id="643130ad01d792200f3136ea8c6e080f0365707e" translate="yes" xml:space="preserve">
          <source>Windows::flat_map</source>
          <target state="translated">Windows::flat_map</target>
        </trans-unit>
        <trans-unit id="f4d8fa17f7d4e22990b8c1303515ad7b41c0e51e" translate="yes" xml:space="preserve">
          <source>Windows::flatten</source>
          <target state="translated">Windows::flatten</target>
        </trans-unit>
        <trans-unit id="d2eb04619a69bf18cec3a67a06b479df0576a42c" translate="yes" xml:space="preserve">
          <source>Windows::fmt</source>
          <target state="translated">Windows::fmt</target>
        </trans-unit>
        <trans-unit id="d8a195c51acf16c6aadba984188c415f5441b6c3" translate="yes" xml:space="preserve">
          <source>Windows::fold</source>
          <target state="translated">Windows::fold</target>
        </trans-unit>
        <trans-unit id="01cdc502497ab9b03d2f83fa2d0871f8abb0994a" translate="yes" xml:space="preserve">
          <source>Windows::for_each</source>
          <target state="translated">Windows::for_each</target>
        </trans-unit>
        <trans-unit id="6108a137a74f4bd608fc702807fd0e17b7abd278" translate="yes" xml:space="preserve">
          <source>Windows::from</source>
          <target state="translated">Windows::from</target>
        </trans-unit>
        <trans-unit id="8f30f87a1c9a02e1fb27ac6fe719069f8e122330" translate="yes" xml:space="preserve">
          <source>Windows::fuse</source>
          <target state="translated">Windows::fuse</target>
        </trans-unit>
        <trans-unit id="67db02e23e968fbc8c51336185b95b9b96aec0fb" translate="yes" xml:space="preserve">
          <source>Windows::ge</source>
          <target state="translated">Windows::ge</target>
        </trans-unit>
        <trans-unit id="1b08a3c2211d2e64ecaa8d094412c20af26d6951" translate="yes" xml:space="preserve">
          <source>Windows::gt</source>
          <target state="translated">Windows::gt</target>
        </trans-unit>
        <trans-unit id="6a49da6e96f3901cd2e3f2a458b5df67e32fc1ac" translate="yes" xml:space="preserve">
          <source>Windows::inspect</source>
          <target state="translated">Windows::inspect</target>
        </trans-unit>
        <trans-unit id="dc89660cc21103f886ff9b7d6b842aa6ebb6eea2" translate="yes" xml:space="preserve">
          <source>Windows::into</source>
          <target state="translated">Windows::into</target>
        </trans-unit>
        <trans-unit id="7dc827a9516a85386bc0443ac7acf8dbdc207267" translate="yes" xml:space="preserve">
          <source>Windows::into_iter</source>
          <target state="translated">Windows::into_iter</target>
        </trans-unit>
        <trans-unit id="3bf9a277de1f84adeaec35fb62966d1d7c35ff91" translate="yes" xml:space="preserve">
          <source>Windows::is_empty</source>
          <target state="translated">Windows::is_empty</target>
        </trans-unit>
        <trans-unit id="0f4e75134f8d11b4a570702cb97bdd5515869f82" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted</source>
          <target state="translated">Windows::is_sorted</target>
        </trans-unit>
        <trans-unit id="e74da52cc5b534ed59329d25635be3609f0336ec" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by</source>
          <target state="translated">Windows::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="396da8bc74081a0a8716a03e2ec0b64081b2263f" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by_key</source>
          <target state="translated">Windows::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="8bbf67cd900972eb007b6f354b425cc5682d90e0" translate="yes" xml:space="preserve">
          <source>Windows::last</source>
          <target state="translated">Windows::last</target>
        </trans-unit>
        <trans-unit id="edfebb32722bfb5c8d9922b27c21e2ad57bf0c3b" translate="yes" xml:space="preserve">
          <source>Windows::le</source>
          <target state="translated">Windows::le</target>
        </trans-unit>
        <trans-unit id="5b0f7e7a7b44222bd3e3f54b200e29b7293b2aa2" translate="yes" xml:space="preserve">
          <source>Windows::len</source>
          <target state="translated">Windows::len</target>
        </trans-unit>
        <trans-unit id="f84b680a03923cb8668b70cb3d48a10366b725cb" translate="yes" xml:space="preserve">
          <source>Windows::lt</source>
          <target state="translated">Windows::lt</target>
        </trans-unit>
        <trans-unit id="211653c7638da6256828c029f6bdbbd39290d614" translate="yes" xml:space="preserve">
          <source>Windows::map</source>
          <target state="translated">Windows::map</target>
        </trans-unit>
        <trans-unit id="da3645101a0d749919ba6caacb64cbf6bb5ab932" translate="yes" xml:space="preserve">
          <source>Windows::max</source>
          <target state="translated">Windows::max</target>
        </trans-unit>
        <trans-unit id="6faf7c5f10fa19e5856c7c741e0f6e00ec43ac89" translate="yes" xml:space="preserve">
          <source>Windows::max_by</source>
          <target state="translated">Windows::max_by</target>
        </trans-unit>
        <trans-unit id="a97eb7a3a210c7918ea8d0750c43c0be36a4f490" translate="yes" xml:space="preserve">
          <source>Windows::max_by_key</source>
          <target state="translated">Windows::max_by_key</target>
        </trans-unit>
        <trans-unit id="85afd294e1c8b3ac152c12583d70b807752d21c5" translate="yes" xml:space="preserve">
          <source>Windows::min</source>
          <target state="translated">Windows::min</target>
        </trans-unit>
        <trans-unit id="9851ad95c0803c7379f60e880e611d24b73dd771" translate="yes" xml:space="preserve">
          <source>Windows::min_by</source>
          <target state="translated">Windows::min_by</target>
        </trans-unit>
        <trans-unit id="d2ffacc1b47b99ed28eab58435af4f27856f1432" translate="yes" xml:space="preserve">
          <source>Windows::min_by_key</source>
          <target state="translated">Windows::min_by_key</target>
        </trans-unit>
        <trans-unit id="bd27f7b2dd977463e705864279f5215a8693dcf1" translate="yes" xml:space="preserve">
          <source>Windows::ne</source>
          <target state="translated">Windows::ne</target>
        </trans-unit>
        <trans-unit id="07ea4a2a4bc2affb3d5f44891b5f320bb57788cf" translate="yes" xml:space="preserve">
          <source>Windows::next</source>
          <target state="translated">Windows::next</target>
        </trans-unit>
        <trans-unit id="5df573867c1237a7c0cadeeaaef6362ce41599cb" translate="yes" xml:space="preserve">
          <source>Windows::next_back</source>
          <target state="translated">Windows::next_back</target>
        </trans-unit>
        <trans-unit id="884d14d5f8a19f0db064d5b33b9b17b75a3d8a57" translate="yes" xml:space="preserve">
          <source>Windows::nth</source>
          <target state="translated">Windows::nth</target>
        </trans-unit>
        <trans-unit id="d9ece61aa05f950e8c21d253603cec8c4927666f" translate="yes" xml:space="preserve">
          <source>Windows::nth_back</source>
          <target state="translated">Windows::nth_back</target>
        </trans-unit>
        <trans-unit id="e2337e7096b09ea74ce36d188b9ca860a5770051" translate="yes" xml:space="preserve">
          <source>Windows::partial_cmp</source>
          <target state="translated">Windows::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b234418f227a17c704174f2bef5739ac92992b03" translate="yes" xml:space="preserve">
          <source>Windows::partition</source>
          <target state="translated">Windows::partition</target>
        </trans-unit>
        <trans-unit id="9be20298e80cbaffa477f416ccc86f737f3f8d78" translate="yes" xml:space="preserve">
          <source>Windows::peekable</source>
          <target state="translated">Windows::peekable</target>
        </trans-unit>
        <trans-unit id="45529696a341be706214708f3fbab21c7d0b23fd" translate="yes" xml:space="preserve">
          <source>Windows::position</source>
          <target state="translated">Windows::position</target>
        </trans-unit>
        <trans-unit id="59fc20664973429ad195ba2d8aed0ddf546bb2a2" translate="yes" xml:space="preserve">
          <source>Windows::product</source>
          <target state="translated">Windows::product</target>
        </trans-unit>
        <trans-unit id="50734bb415bc20fe6568bfd1dd1f63f6b93fe949" translate="yes" xml:space="preserve">
          <source>Windows::rev</source>
          <target state="translated">Windows::rev</target>
        </trans-unit>
        <trans-unit id="530fe46767d842dcb4f66462626de45b73ad15f2" translate="yes" xml:space="preserve">
          <source>Windows::rfind</source>
          <target state="translated">Windows::rfind</target>
        </trans-unit>
        <trans-unit id="a36a85b42116649c6a0ad782c4af43ce9da0a6d2" translate="yes" xml:space="preserve">
          <source>Windows::rfold</source>
          <target state="translated">Windows::rfold</target>
        </trans-unit>
        <trans-unit id="6b46a39965804836e499e246c032f1e49efe2b08" translate="yes" xml:space="preserve">
          <source>Windows::rposition</source>
          <target state="translated">Windows::rposition</target>
        </trans-unit>
        <trans-unit id="3085a5deaa7e492e694960ff9a8bb11a44fea77b" translate="yes" xml:space="preserve">
          <source>Windows::scan</source>
          <target state="translated">Windows::scan</target>
        </trans-unit>
        <trans-unit id="600168ee422d0b4058643289d6f5f44a0cc41069" translate="yes" xml:space="preserve">
          <source>Windows::size_hint</source>
          <target state="translated">Windows::size_hint</target>
        </trans-unit>
        <trans-unit id="60a31deba53a9144f8f111c1a535404922718781" translate="yes" xml:space="preserve">
          <source>Windows::skip</source>
          <target state="translated">Windows::skip</target>
        </trans-unit>
        <trans-unit id="f0c88d1e74fd2619b821ca5f9314adc478f85906" translate="yes" xml:space="preserve">
          <source>Windows::skip_while</source>
          <target state="translated">Windows::skip_while</target>
        </trans-unit>
        <trans-unit id="43319d488bcd123c09eddf08cef6849d9980eba7" translate="yes" xml:space="preserve">
          <source>Windows::step_by</source>
          <target state="translated">Windows::step_by</target>
        </trans-unit>
        <trans-unit id="9672bcfc100f3ac44dec88d4d85716df442fe940" translate="yes" xml:space="preserve">
          <source>Windows::sum</source>
          <target state="translated">Windows::sum</target>
        </trans-unit>
        <trans-unit id="7df17ff1135505a96dab1d9f8ef57748282788e2" translate="yes" xml:space="preserve">
          <source>Windows::take</source>
          <target state="translated">Windows::take</target>
        </trans-unit>
        <trans-unit id="1e57647d418ad6082e9d4ee5291c1745f789d2e8" translate="yes" xml:space="preserve">
          <source>Windows::take_while</source>
          <target state="translated">Windows::take_while</target>
        </trans-unit>
        <trans-unit id="8f55f6ef559f032eb73be76c2b09a5737e416d5c" translate="yes" xml:space="preserve">
          <source>Windows::to_owned</source>
          <target state="translated">Windows::to_owned</target>
        </trans-unit>
        <trans-unit id="81cbe418ab3685420d683bda86fea704938b8a31" translate="yes" xml:space="preserve">
          <source>Windows::try_fold</source>
          <target state="translated">Windows::try_fold</target>
        </trans-unit>
        <trans-unit id="b4c27872e29ca09f92a33f4478a1eff0aea539bb" translate="yes" xml:space="preserve">
          <source>Windows::try_for_each</source>
          <target state="translated">Windows::try_for_each</target>
        </trans-unit>
        <trans-unit id="171fea351be781be4e02e711fd24294e453b5b91" translate="yes" xml:space="preserve">
          <source>Windows::try_from</source>
          <target state="translated">Windows::try_from</target>
        </trans-unit>
        <trans-unit id="9220c38d1fb3ec5be1fd9df5b83c243f1caa3ba1" translate="yes" xml:space="preserve">
          <source>Windows::try_into</source>
          <target state="translated">Windows::try_into</target>
        </trans-unit>
        <trans-unit id="92ba387998e4a086247665261fda5122f9f9029e" translate="yes" xml:space="preserve">
          <source>Windows::try_rfold</source>
          <target state="translated">Windows::try_rfold</target>
        </trans-unit>
        <trans-unit id="ff8171358582a1c7e6fe713b6c5031c85fcf7da9" translate="yes" xml:space="preserve">
          <source>Windows::type_id</source>
          <target state="translated">Windows::type_id</target>
        </trans-unit>
        <trans-unit id="ef934a80a8453f69945f5830a3ed61e3b0c17061" translate="yes" xml:space="preserve">
          <source>Windows::unzip</source>
          <target state="translated">Windows::unzip</target>
        </trans-unit>
        <trans-unit id="fc3d2052b8855f4dd5b69c5898112a4724165849" translate="yes" xml:space="preserve">
          <source>Windows::zip</source>
          <target state="translated">Windows::zip</target>
        </trans-unit>
        <trans-unit id="38dc69622ed00aee21cdcf0fd074e253d0cf7005" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">带&lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;，这些宏为开发人员提供了有关源中位置的调试信息。</target>
        </trans-unit>
        <trans-unit id="0ec53663cefb4388138a07773bc9d9c40923307a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">带&lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;，这些宏为开发人员提供了有关源中位置的调试信息。</target>
        </trans-unit>
        <trans-unit id="815b1bf6287da2f53b57957c1e78d170fa30a354" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">带&lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;，这些宏为开发人员提供了有关源中位置的调试信息。</target>
        </trans-unit>
        <trans-unit id="04eb7504cabe503a97d0c1acdec5be3b9053e741" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Infallible&lt;/code&gt; being an enum, this code is valid. However when &lt;code&gt;Infallible&lt;/code&gt; becomes an alias for the never type, the two &lt;code&gt;impl&lt;/code&gt;s will start to overlap and therefore will be disallowed by the language&amp;rsquo;s trait coherence rules.</source>
          <target state="translated">由于 &lt;code&gt;Infallible&lt;/code&gt; 是枚举，因此此代码有效。但是，当 &lt;code&gt;Infallible&lt;/code&gt; 成为never类型的别名时，这两个 &lt;code&gt;impl&lt;/code&gt; 将开始重叠，因此将被语言的特质一致性规则所禁止。</target>
        </trans-unit>
        <trans-unit id="0eafffeebea0c3842266dddbb6f397a2037dca13" translate="yes" xml:space="preserve">
          <source>With CMD on Windows, you would enter the following:</source>
          <target state="translated">在Windows上使用CMD,你可以输入以下内容。</target>
        </trans-unit>
        <trans-unit id="c67b427f4a43407481fdbe0434a6fd74d6c08115" translate="yes" xml:space="preserve">
          <source>With Rust&amp;rsquo;s &lt;code&gt;..&lt;/code&gt; range syntax, if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:</source>
          <target state="translated">使用Rust的 &lt;code&gt;..&lt;/code&gt; 范围语法，如果要从第一个索引（零）开始，则可以在两个句点之前删除该值。换句话说，这些是相等的：</target>
        </trans-unit>
        <trans-unit id="e6848246eb0a467aba8b63d5b96e2ddd94bde183" translate="yes" xml:space="preserve">
          <source>With a basic understanding of threads and the thread API, let&amp;rsquo;s look at what we can &lt;em&gt;do&lt;/em&gt; with threads.</source>
          <target state="translated">在基本了解线程和线程API之后，让我们看一下我们可以&lt;em&gt;对&lt;/em&gt;线程执行的操作。</target>
        </trans-unit>
        <trans-unit id="b24837e9bbb4a3f319a132114baf06eda4b2e88c" translate="yes" xml:space="preserve">
          <source>With a method call:</source>
          <target state="translated">用方法调用。</target>
        </trans-unit>
        <trans-unit id="5ec0502a02d896b78bc96b2798e0767135b5c8c9" translate="yes" xml:space="preserve">
          <source>With a pathname:</source>
          <target state="translated">有一个路径名。</target>
        </trans-unit>
        <trans-unit id="f37d3365310acb52cb4a4d469a50deacc72ef16e" translate="yes" xml:space="preserve">
          <source>With a unique name, the version, the author details that &lt;code&gt;cargo new&lt;/code&gt; added when you created the crate, your description, and a license added, the &lt;em&gt;Cargo.toml&lt;/em&gt; file for a project that is ready to publish might look like this:</source>
          <target state="translated">凭借独特的名称，版本，作者细节 &lt;code&gt;cargo new&lt;/code&gt; 时创建的箱子，你的描述，并增加了一个许可补充说，&lt;em&gt;Cargo.toml&lt;/em&gt;的一个项目，是准备发布可能是这样的文件：</target>
        </trans-unit>
        <trans-unit id="33d3ef8879647cae82afb7b344de4fdc8e49a8b3" translate="yes" xml:space="preserve">
          <source>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you&amp;rsquo;ll see in the next section, &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;Calling an Unsafe Function or Method.&amp;rdquo;&lt;/a&gt; Another case is when building up safe abstractions that the borrow checker doesn&amp;rsquo;t understand. We&amp;rsquo;ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</source>
          <target state="translated">面对所有这些危险，为什么还要使用原始指针？一个主要的用例是与C代码进行接口时，正如您将在下一节&lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;调用不安全的函数或方法&amp;rdquo;中&lt;/a&gt;看到的那样。另一种情况是建立借用检查器不理解的安全抽象时。我们将介绍不安全的函数，然后看一个使用不安全代码的安全抽象示例。</target>
        </trans-unit>
        <trans-unit id="a402171e60da25e2d20aa541a5e736d082a2894a" translate="yes" xml:space="preserve">
          <source>With all the changes we&amp;rsquo;ve made, our code compiles without any warnings. But the bad news is this code doesn&amp;rsquo;t function the way we want it to yet. The key is the logic in the closures run by the threads of the &lt;code&gt;Worker&lt;/code&gt; instances: at the moment, we call &lt;code&gt;join&lt;/code&gt;, but that won&amp;rsquo;t shut down the threads because they &lt;code&gt;loop&lt;/code&gt; forever looking for jobs. If we try to drop our &lt;code&gt;ThreadPool&lt;/code&gt; with our current implementation of &lt;code&gt;drop&lt;/code&gt;, the main thread will block forever waiting for the first thread to finish.</source>
          <target state="translated">经过我们所做的所有更改，我们的代码得以编译而没有任何警告。但坏消息是此代码尚未按我们希望的方式运行。关键是由 &lt;code&gt;Worker&lt;/code&gt; 实例的线程运行的闭包中的逻辑：目前，我们称为 &lt;code&gt;join&lt;/code&gt; ，但这不会关闭线程，因为它们会永远 &lt;code&gt;loop&lt;/code&gt; 寻找工作。如果我们尝试使用当前的 &lt;code&gt;drop&lt;/code&gt; 实现删除 &lt;code&gt;ThreadPool&lt;/code&gt; ，则主线程将永远阻塞，等待第一个线程完成。</target>
        </trans-unit>
        <trans-unit id="3e478a9c9aaa53e1f24932c1bf11ee27b2b756f9" translate="yes" xml:space="preserve">
          <source>With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the &lt;code&gt;rlib&lt;/code&gt; format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</source>
          <target state="translated">对于所有这些不同类型的输出，如果板条箱A依赖于板条箱B，则编译器可以在整个系统中找到各种不同形式的B。但是，编译器只寻找 &lt;code&gt;rlib&lt;/code&gt; 格式和动态库格式。使用依赖库的这两个选项时，编译器必须在某些时候在这两种格式之间做出选择。考虑到这一点，在确定将使用哪种格式的依赖项时，编译器将遵循以下规则：</target>
        </trans-unit>
        <trans-unit id="1b779befcd3540151b782d4543ae930ae53755ec" translate="yes" xml:space="preserve">
          <source>With all this information in mind, let&amp;rsquo;s rewrite &lt;code&gt;first_word&lt;/code&gt; to return a slice. The type that signifies &amp;ldquo;string slice&amp;rdquo; is written as &lt;code&gt;&amp;amp;str&lt;/code&gt;:</source>
          <target state="translated">考虑到所有这些信息后，让我们重写 &lt;code&gt;first_word&lt;/code&gt; 以返回切片。表示&amp;ldquo;字符串切片&amp;rdquo;的类型写为 &lt;code&gt;&amp;amp;str&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb10c6677d4a9c4ac3a69e9072ac5b7bbbfc8ab3" translate="yes" xml:space="preserve">
          <source>With an associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e91fb00c7adb5b470a7e84f143a4420eb3479d" translate="yes" xml:space="preserve">
          <source>With associated types, we don&amp;rsquo;t need to annotate types because we can&amp;rsquo;t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of &lt;code&gt;Item&lt;/code&gt; will be once, because there can only be one &lt;code&gt;impl Iterator for Counter&lt;/code&gt;. We don&amp;rsquo;t have to specify that we want an iterator of &lt;code&gt;u32&lt;/code&gt; values everywhere that we call &lt;code&gt;next&lt;/code&gt; on &lt;code&gt;Counter&lt;/code&gt;.</source>
          <target state="translated">对于关联的类型，我们不需要注释类型，因为我们不能多次对类型实现特征。在清单19-12中，使用了关联类型的定义，我们只能选择 &lt;code&gt;Item&lt;/code&gt; 的类型一次，因为 &lt;code&gt;impl Iterator for Counter&lt;/code&gt; 只能有一个impl Iterator。我们不必指定要在 &lt;code&gt;Counter&lt;/code&gt; 上 &lt;code&gt;next&lt;/code&gt; 调用的所有地方都需要 &lt;code&gt;u32&lt;/code&gt; 值的迭代器。</target>
        </trans-unit>
        <trans-unit id="7a53dfae04bc081765c66dac442860f331c44aeb" translate="yes" xml:space="preserve">
          <source>With mutable data that is globally accessible, it&amp;rsquo;s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it&amp;rsquo;s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</source>
          <target state="translated">对于可全局访问的可变数据，很难确保不存在数据争用，这就是Rust认为可变静态变量不安全的原因。在可能的情况下，最好使用我们在第16章中讨论的并发技术和线程安全智能指针，以便编译器检查从不同线程访问的数据是否安全完成。</target>
        </trans-unit>
        <trans-unit id="ef733904e440fafdfd6f6cff1f3753a02bb10342" translate="yes" xml:space="preserve">
          <source>With our new knowledge about iterators, we can change the &lt;code&gt;new&lt;/code&gt; function to take ownership of an iterator as its argument instead of borrowing a slice. We&amp;rsquo;ll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the &lt;code&gt;Config::new&lt;/code&gt; function is doing because the iterator will access the values.</source>
          <target state="translated">利用我们对迭代器的新知识，我们可以更改 &lt;code&gt;new&lt;/code&gt; 函数，以将迭代器的所有权作为其参数，而不是借用切片。我们将使用迭代器功能，而不是用于检查切片长度并将其索引到特定位置的代码。这将阐明 &lt;code&gt;Config::new&lt;/code&gt; 函数的作用，因为迭代器将访问这些值。</target>
        </trans-unit>
        <trans-unit id="813d416dedfb40190d58c273de8f8eb75ea3340b" translate="yes" xml:space="preserve">
          <source>With real world traits these numbers can grow drastically.</source>
          <target state="translated">随着现实世界的特征,这些数字会急剧增长。</target>
        </trans-unit>
        <trans-unit id="b72f5cb005021c9be16f1dc058fb74107683aac5" translate="yes" xml:space="preserve">
          <source>With references and &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, the borrowing rules&amp;rsquo; invariants are enforced at compile time. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, these invariants are enforced &lt;em&gt;at runtime&lt;/em&gt;. With references, if you break these rules, you&amp;rsquo;ll get a compiler error. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, if you break these rules, your program will panic and exit.</source>
          <target state="translated">使用reference和 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ，可以在编译时强制执行借入规则的不变式。使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，这些不变量&lt;em&gt;在运行时&lt;/em&gt;强制执行。使用引用，如果您违反这些规则，则会出现编译器错误。使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，如果违反这些规则，则程序将崩溃并退出。</target>
        </trans-unit>
        <trans-unit id="9baf0229e3e9e6c893294479bb6fe3668b3a0c0e" translate="yes" xml:space="preserve">
          <source>With simple projects, Cargo doesn&amp;rsquo;t provide a lot of value over just using &lt;code&gt;rustc&lt;/code&gt;, but it will prove its worth as your programs become more intricate. With complex projects composed of multiple crates, it&amp;rsquo;s much easier to let Cargo coordinate the build.</source>
          <target state="translated">对于简单的项目，Cargo并不能提供仅使用 &lt;code&gt;rustc&lt;/code&gt; 的大量价值，但是随着您的程序变得更加复杂，它将证明其价值。对于由多个板条箱组成的复杂项目，让Cargo协调构建要容易得多。</target>
        </trans-unit>
        <trans-unit id="498cc75c7709fdab78e1cc82cb0379d4fbbfc2cc" translate="yes" xml:space="preserve">
          <source>With stdin:</source>
          <target state="translated">与stdin。</target>
        </trans-unit>
        <trans-unit id="06224dc60392a0fce212359437fb5cee57ac9f42" translate="yes" xml:space="preserve">
          <source>With stdout:</source>
          <target state="translated">与stdout。</target>
        </trans-unit>
        <trans-unit id="93ea5ac4258ad8d0735b4be8347a757702850e37" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;String&lt;/code&gt; type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</source>
          <target state="translated">对于 &lt;code&gt;String&lt;/code&gt; 类型，为了支持可变的，可增长的文本，我们需要在堆上分配一个在编译时未知的内存量来容纳内容。这表示：</target>
        </trans-unit>
        <trans-unit id="e41ed52cf940fa02215dfc776f98dffa8f13fd94" translate="yes" xml:space="preserve">
          <source>With the above specification in hand, we can present arguments for why particular matchers are legal and others are not.</source>
          <target state="translated">有了上述规范,我们就可以提出论据,说明为什么特定的匹配器是合法的,而其他匹配器是不合法的。</target>
        </trans-unit>
        <trans-unit id="9c5fab965ba18f74e15ee6e594f51c165aae934a" translate="yes" xml:space="preserve">
          <source>With the closure defined, we can change the code in the &lt;code&gt;if&lt;/code&gt; blocks to call the closure to execute the code and get the resulting value. We call a closure like we do a function: we specify the variable name that holds the closure definition and follow it with parentheses containing the argument values we want to use, as shown in Listing 13-6.</source>
          <target state="translated">定义闭包后，我们可以在 &lt;code&gt;if&lt;/code&gt; 块中更改代码以调用闭包以执行代码并获取结果值。我们像执行函数一样调用闭包：我们指定保存闭包定义的变量名称，并在其后加上包含要使用的参数值的括号，如清单13-6所示。</target>
        </trans-unit>
        <trans-unit id="01c46a1d067cb86c80a793fada3c4bf6ccb8375e" translate="yes" xml:space="preserve">
          <source>With the implementation of this trick, our thread pool is in a working state! Give it a &lt;code&gt;cargo run&lt;/code&gt; and make some requests:</source>
          <target state="translated">通过实施此技巧，我们的线程池处于工作状态！给它放个 &lt;code&gt;cargo run&lt;/code&gt; 并提出一些要求：</target>
        </trans-unit>
        <trans-unit id="24a7fa0675f3c1ff0574c22a8d3081db443c0de4" translate="yes" xml:space="preserve">
          <source>With the notion of an item being either public or private, Rust allows item accesses in two cases:</source>
          <target state="translated">有了物品是公共的或私有的概念,Rust允许在两种情况下进行物品访问。</target>
        </trans-unit>
        <trans-unit id="bc6738ca71c4d0da46b8887fed6bda41f9aa0556" translate="yes" xml:space="preserve">
          <source>With the remaining program logic separated into the &lt;code&gt;run&lt;/code&gt; function, we can improve the error handling, as we did with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-9. Instead of allowing the program to panic by calling &lt;code&gt;expect&lt;/code&gt;, the &lt;code&gt;run&lt;/code&gt; function will return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; when something goes wrong. This will let us further consolidate into &lt;code&gt;main&lt;/code&gt; the logic around handling errors in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">将其余的程序逻辑分离为 &lt;code&gt;run&lt;/code&gt; 函数，我们可以像清单12-9中的 &lt;code&gt;Config::new&lt;/code&gt; 一样改进错误处理。当出现问题时， &lt;code&gt;run&lt;/code&gt; 函数不会通过调用 &lt;code&gt;expect&lt;/code&gt; 来使程序惊慌，而是会返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 。这将使我们进一步以用户友好的方式将处理错误的逻辑进一步整合为 &lt;code&gt;main&lt;/code&gt; 。清单12-12显示了我们需要对 &lt;code&gt;run&lt;/code&gt; 的签名和主体进行的更改。</target>
        </trans-unit>
        <trans-unit id="34d45efbbc694df1116b7475884bd1d2fd47f1c6" translate="yes" xml:space="preserve">
          <source>With the state pattern, the &lt;code&gt;Post&lt;/code&gt; methods and the places we use &lt;code&gt;Post&lt;/code&gt; don&amp;rsquo;t need &lt;code&gt;match&lt;/code&gt; expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</source>
          <target state="translated">使用状态模式， &lt;code&gt;Post&lt;/code&gt; 方法和我们使用 &lt;code&gt;Post&lt;/code&gt; 的位置不需要 &lt;code&gt;match&lt;/code&gt; 表达式，并且要添加新状态，我们只需要添加新结构并在该结构上实现trait方法即可。</target>
        </trans-unit>
        <trans-unit id="83ff23e8afd931a2cd544c6885efa1601bab61bb" translate="yes" xml:space="preserve">
          <source>With the text in place, edit &lt;em&gt;src/main.rs&lt;/em&gt; and add code to read the file, as shown in Listing 12-4.</source>
          <target state="translated">放置好文本后，编辑&lt;em&gt;src / main.rs&lt;/em&gt;并添加代码以读取文件，如清单12-4所示。</target>
        </trans-unit>
        <trans-unit id="e0b0d0d55bb8949af2866594443ea68c01592e9d" translate="yes" xml:space="preserve">
          <source>With the two trait bounds specified, the body of &lt;code&gt;notify&lt;/code&gt; can call &lt;code&gt;summarize&lt;/code&gt; and use &lt;code&gt;{}&lt;/code&gt; to format &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">在指定了两个特征范围后， &lt;code&gt;notify&lt;/code&gt; 主体可以调用 &lt;code&gt;summarize&lt;/code&gt; 并使用 &lt;code&gt;{}&lt;/code&gt; 格式化 &lt;code&gt;item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7deae3df9bc9dd91ed2ed3e73a23c867198988dd" translate="yes" xml:space="preserve">
          <source>With these changes, let&amp;rsquo;s run our code and make a request. We&amp;rsquo;re no longer printing any data to the terminal, so we won&amp;rsquo;t see any output other than the output from Cargo. When you load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser, you should get a blank page instead of an error. You&amp;rsquo;ve just hand-coded an HTTP request and response!</source>
          <target state="translated">通过这些更改，让我们运行代码并发出请求。我们不再将任何数据打印到终端，因此除了Cargo的输出之外，我们将看不到其他任何输出。在Web浏览器中加载&lt;em&gt;127.0.0.1:7878&lt;/em&gt;时，应该得到空白页而不是错误。您刚刚手动编码了HTTP请求和响应！</target>
        </trans-unit>
        <trans-unit id="2b8a9662a9a062dbd858ec248c6bcfe6e17a1e8d" translate="yes" xml:space="preserve">
          <source>With these changes, run your server again. Requesting &lt;em&gt;127.0.0.1:7878&lt;/em&gt; should return the contents of &lt;em&gt;hello.html&lt;/em&gt;, and any other request, like &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;, should return the error HTML from &lt;em&gt;404.html&lt;/em&gt;.</source>
          <target state="translated">进行这些更改后，请再次运行服务器。请求&lt;em&gt;127.0.0.1:7878&lt;/em&gt;应该返回&lt;em&gt;hello.html&lt;/em&gt;的内容，其他任何请求（例如&lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;）都应该返回&lt;em&gt;404.html中&lt;/em&gt;的错误HTML 。</target>
        </trans-unit>
        <trans-unit id="a7ea5830e4d89ce20b87325d5feaac7885edd633" translate="yes" xml:space="preserve">
          <source>With these changes, the code compiles! We&amp;rsquo;re getting there!</source>
          <target state="translated">经过这些更改，代码即可编译！我们到了！</target>
        </trans-unit>
        <trans-unit id="64e9859cf60a37b6fd6185bea427eb35dd3442b4" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-20. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa98175f3edbe33adc271e61ac4777981eaf67" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-21. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-25.</source>
          <target state="translated">进行了这些更改之后，代码将按照清单20-21之后的方式进行编译并继续运行。但是我们会收到警告，因为我们没有创建任何 &lt;code&gt;Terminate&lt;/code&gt; 消息。让我们通过将 &lt;code&gt;Drop&lt;/code&gt; 实现更改为清单20-25来解决此警告。</target>
        </trans-unit>
        <trans-unit id="86aa3b5dba5f873b63c48b4c86a229ed1fbfd4e1" translate="yes" xml:space="preserve">
          <source>With these extra few lines of code in &lt;code&gt;new&lt;/code&gt;, let&amp;rsquo;s run the program without any arguments again to see what the error looks like now:</source>
          <target state="translated">通过在 &lt;code&gt;new&lt;/code&gt; 中添加以下几行代码，让我们再次运行不带任何参数的程序，以查看现在的错误情况：</target>
        </trans-unit>
        <trans-unit id="96fe782e8597a2f8b432d3a608914c807144f829" translate="yes" xml:space="preserve">
          <source>With this added &lt;code&gt;content&lt;/code&gt; method, everything in Listing 17-11 up to line 7 works as intended.</source>
          <target state="translated">使用此添加的 &lt;code&gt;content&lt;/code&gt; 方法，清单17-11到第7行的所有内容均按预期工作。</target>
        </trans-unit>
        <trans-unit id="6a69a998d97d76e52647bdd19719b61356e441e9" translate="yes" xml:space="preserve">
          <source>With this approach, x and y share ownership of the data via the &lt;code&gt;Rc&lt;/code&gt; (reference count type). &lt;code&gt;RefCell&lt;/code&gt; essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</source>
          <target state="translated">通过这种方法，x和y通过 &lt;code&gt;Rc&lt;/code&gt; （引用计数类型）共享数据的所有权。 &lt;code&gt;RefCell&lt;/code&gt; 本质上执行运行时借阅检查：确保最多一位或多位读者可以在任何时间访问数据。</target>
        </trans-unit>
        <trans-unit id="e0294acc426b53e8eefb85526ce41c8bfef32085" translate="yes" xml:space="preserve">
          <source>With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let&amp;rsquo;s look at how iterators can improve our implementation of the &lt;code&gt;Config::new&lt;/code&gt; function and the &lt;code&gt;search&lt;/code&gt; function.</source>
          <target state="translated">有了有关迭代器的新知识，我们可以通过使用迭代器使代码中的位置更加清晰和简洁来改进第12章中的I / O项目。让我们看一下迭代器如何改善 &lt;code&gt;Config::new&lt;/code&gt; 函数和 &lt;code&gt;search&lt;/code&gt; 函数的实现。</target>
        </trans-unit>
        <trans-unit id="e2fb8bb90dda22d23945c9584750688009a769c8" translate="yes" xml:space="preserve">
          <source>With this:</source>
          <target state="translated">有了这个。</target>
        </trans-unit>
        <trans-unit id="f92b2fe5b7dcaebe110b80babf1c63cd9fdd43ef" translate="yes" xml:space="preserve">
          <source>With type annotations added, the syntax of closures looks more similar to the syntax of functions. The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior. We&amp;rsquo;ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</source>
          <target state="translated">添加类型注释后，闭包的语法看起来与函数的语法更相似。以下是对该函数定义的语法的垂直比较，该函数的参数加1，并且闭包具有相同的行为。我们添加了一些空格来对齐相关部分。这说明了闭包语法与函数语法的相似之处，除了使用管道和可选的语法数量之外：</target>
        </trans-unit>
        <trans-unit id="e12bdc1ee24b9c9117113f7fd06a681041f0f8ca" translate="yes" xml:space="preserve">
          <source>With values that have many parts, we can use the &lt;code&gt;..&lt;/code&gt; syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value. The &lt;code&gt;..&lt;/code&gt; pattern ignores any parts of a value that we haven&amp;rsquo;t explicitly matched in the rest of the pattern. In Listing 18-23, we have a &lt;code&gt;Point&lt;/code&gt; struct that holds a coordinate in three-dimensional space. In the &lt;code&gt;match&lt;/code&gt; expression, we want to operate only on the &lt;code&gt;x&lt;/code&gt; coordinate and ignore the values in the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; fields.</source>
          <target state="translated">对于包含很多部分的值，我们可以使用 &lt;code&gt;..&lt;/code&gt; 语法仅使用一些部分，而忽略其余部分，从而避免了为每个被忽略的值列出下划线。该 &lt;code&gt;..&lt;/code&gt; 模式忽略了我们还没有明确的模式其余相匹配的价值的任何部分。在清单18-23中，我们有一个 &lt;code&gt;Point&lt;/code&gt; 结构，该结构在三维空间中保存坐标。在 &lt;code&gt;match&lt;/code&gt; 表达式中，我们只想对 &lt;code&gt;x&lt;/code&gt; 坐标进行运算，而忽略 &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 字段中的值。</target>
        </trans-unit>
        <trans-unit id="3392b1d08169948bc18f560cc78f42601ac7de77" translate="yes" xml:space="preserve">
          <source>Within a type definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bf9a3332dbb1aae191337d7acb72ccf285dc36" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, we list the names and signatures of external functions from another language we want to call. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; part defines which &lt;em&gt;application binary interface (ABI)&lt;/em&gt; the external function uses: the ABI defines how to call the function at the assembly level. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI is the most common and follows the C programming language&amp;rsquo;s ABI.</source>
          <target state="translated">在 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 块中，我们列出了要调用的另一种语言的外部函数的名称和签名。的 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 部分定义哪些&lt;em&gt;应用程序二进制接口（ABI）&lt;/em&gt;的外部函数的用途：在ABI定义如何调用在组件级别的功能。在 &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI是最常见的，并遵循C编程语言的ABI。</target>
        </trans-unit>
        <trans-unit id="a3840b923c5773a4355bfcefff4121f0878713eb" translate="yes" xml:space="preserve">
          <source>Within the body of an item that has type parameter declarations, the names of its type parameters are types:</source>
          <target state="translated">在有类型参数声明的项目正文中,其类型参数的名称为类型。</target>
        </trans-unit>
        <trans-unit id="3507a3f4edcb8828e19d61809f6ad4863c52a9ce" translate="yes" xml:space="preserve">
          <source>Within the defining crate, &lt;code&gt;non_exhaustive&lt;/code&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cad0f75b24acc004189d1ad1ae2454225184aa" translate="yes" xml:space="preserve">
          <source>Within this documentation's grammar, &quot;simple&quot; tokens are given in &lt;a href=&quot;notation#string-table-productions&quot;&gt;string table production&lt;/a&gt; form, and appear in &lt;code&gt;monospace&lt;/code&gt; font.</source>
          <target state="translated">在本文档的语法内，&amp;ldquo;简单&amp;rdquo;标记以&lt;a href=&quot;notation#string-table-productions&quot;&gt;字符串表生产&lt;/a&gt;形式给出，并以 &lt;code&gt;monospace&lt;/code&gt; 字体显示。</target>
        </trans-unit>
        <trans-unit id="e7f884881293efc9c1f179ad8b3973e698991d41" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;compiler_fence&lt;/code&gt;, the &lt;code&gt;assert_eq!&lt;/code&gt; in following code is &lt;em&gt;not&lt;/em&gt; guaranteed to succeed, despite everything happening in a single thread. To see why, remember that the compiler is free to swap the stores to &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; and &lt;code&gt;IS_READ&lt;/code&gt; since they are both &lt;code&gt;Ordering::Relaxed&lt;/code&gt;. If it does, and the signal handler is invoked right after &lt;code&gt;IS_READY&lt;/code&gt; is updated, then the signal handler will see &lt;code&gt;IS_READY=1&lt;/code&gt;, but &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt;. Using a &lt;code&gt;compiler_fence&lt;/code&gt; remedies this situation.</source>
          <target state="translated">如果没有 &lt;code&gt;compiler_fence&lt;/code&gt; 的 &lt;code&gt;assert_eq!&lt;/code&gt; 尽管所有事情都在单个线程中发生，但&lt;em&gt;不能&lt;/em&gt;保证后面的代码中的成功。要了解原因，请记住编译器可以自由地将存储交换为 &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; 和 &lt;code&gt;IS_READ&lt;/code&gt; ,因为它们都是 &lt;code&gt;Ordering::Relaxed&lt;/code&gt; 。如果是这样，并且在更新 &lt;code&gt;IS_READY&lt;/code&gt; 之后立即调用信号处理程序，则信号处理程序将看到 &lt;code&gt;IS_READY=1&lt;/code&gt; ，但 &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt; 。使用 &lt;code&gt;compiler_fence&lt;/code&gt; 可以纠正这种情况。</target>
        </trans-unit>
        <trans-unit id="6823be3ffd83b17bd9d63c393e81d5a41ffc52cc" translate="yes" xml:space="preserve">
          <source>Without a loop to break out of or continue in, no sensible action can be taken. Please verify that you are using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; only in loops. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2efdc6add8e970dc1865be96d1f867d6e1b60c" translate="yes" xml:space="preserve">
          <source>Without a pathname:</source>
          <target state="translated">没有路径名。</target>
        </trans-unit>
        <trans-unit id="90c928ad5c0a871061baee534c7a9a3eec8a4645" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;Deref&lt;/code&gt; trait, the compiler can only dereference &lt;code&gt;&amp;amp;&lt;/code&gt; references. The &lt;code&gt;deref&lt;/code&gt; method gives the compiler the ability to take a value of any type that implements &lt;code&gt;Deref&lt;/code&gt; and call the &lt;code&gt;deref&lt;/code&gt; method to get a &lt;code&gt;&amp;amp;&lt;/code&gt; reference that it knows how to dereference.</source>
          <target state="translated">没有 &lt;code&gt;Deref&lt;/code&gt; 特性，编译器只能取消引用 &lt;code&gt;&amp;amp;&lt;/code&gt; 引用。通过使用 &lt;code&gt;deref&lt;/code&gt; 方法，编译器可以采用实现 &lt;code&gt;Deref&lt;/code&gt; 的任何类型的值，并调用 &lt;code&gt;deref&lt;/code&gt; 方法以获取其知道如何取消引用的 &lt;code&gt;&amp;amp;&lt;/code&gt; 引用。</target>
        </trans-unit>
        <trans-unit id="87160e17882870214c0775aca97bd35e735c34ab" translate="yes" xml:space="preserve">
          <source>Working with Environment Variables</source>
          <target state="translated">使用环境变量</target>
        </trans-unit>
        <trans-unit id="90e474d6c66232279cbf06723c1f38f471687b09" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</source>
          <target state="translated">在Rust中使用原始指针工作是不常见的,通常只限于一些模式。</target>
        </trans-unit>
        <trans-unit id="9a40e384f7f263637185bd19da70cd3d69e259e7" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns. Raw pointers can be unaligned or &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;. However, when a raw pointer is dereferenced (using the &lt;code&gt;*&lt;/code&gt; operator), it must be non-null and aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727515b132b28daa88eb87eebc62a62072364288" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here are some important parts to focus on: the first inline error says &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The reason for this is in the next important part to focus on, the error message. The distilled error message says &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="translated">哇，该错误消息非常罗word！这里有一些重要的方面需要注意：第一个内联错误说 &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt; 。原因是在下一个要重点关注的部分，错误消息。提炼的错误消息说 &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt; 。我们将在下一节中讨论 &lt;code&gt;Send&lt;/code&gt; ：这是确保我们与线程一起使用的类型旨在用于并发情况的特征之一。</target>
        </trans-unit>
        <trans-unit id="71aebd97d81f1f2a97e5f18bfd8c471204fa376d" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here&amp;rsquo;s the important part to focus on: &lt;code&gt;`Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The compiler is also telling us the reason why: &lt;code&gt;the trait `Send` is not implemented for `Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` &lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130acb06cdbaff87c403e521823abb94f422c9e0" translate="yes" xml:space="preserve">
          <source>Wrap a value to be manually dropped.</source>
          <target state="translated">包裹一个要手动投放的数值。</target>
        </trans-unit>
        <trans-unit id="744e431b88ea1a0035f05b8fb26571f5315f1927" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">包装一个OK值以构造复合结果。例如， &lt;code&gt;Result::Ok(x)&lt;/code&gt; 和 &lt;code&gt;Result::from_ok(x)&lt;/code&gt; 是等效的。</target>
        </trans-unit>
        <trans-unit id="a120e7e89eaa3b758fd2407bf284e593ba7d4ab0" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">包装一个OK值以构造复合结果。例如， &lt;code&gt;Result::Ok(x)&lt;/code&gt; 和 &lt;code&gt;Result::from_ok(x)&lt;/code&gt; 是等效的。&lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ba39a168910f0f4c9c0f953e5989879aa499399" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8c3f0758b57991ee8d44e4f6a9dc360915c844" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">包装错误值以构造合成结果。例如， &lt;code&gt;Result::Err(x)&lt;/code&gt; 和 &lt;code&gt;Result::from_error(x)&lt;/code&gt; 是等效的。</target>
        </trans-unit>
        <trans-unit id="b038d6e7a645f366cbf4e437083304bafb6bb808" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">包装错误值以构造合成结果。例如， &lt;code&gt;Result::Err(x)&lt;/code&gt; 和 &lt;code&gt;Result::from_error(x)&lt;/code&gt; 是等效的。&lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="350a348893132c0e8f86200072eaac4fe18f553d" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef840afcddbb0c72a9932bf338567231c320f6c4" translate="yes" xml:space="preserve">
          <source>Wrapping</source>
          <target state="translated">Wrapping</target>
        </trans-unit>
        <trans-unit id="743cdade02c9bf9e30517f2de055980f9f8a86fb" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) absolute value. Computes &lt;code&gt;self.abs()&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装（模块化）绝对值。计算 &lt;code&gt;self.abs()&lt;/code&gt; ，在类型的边界处环绕。</target>
        </trans-unit>
        <trans-unit id="f4efecec7c636af1ead7e0409272bc8b700c5382" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装（模块化）添加。计算 &lt;code&gt;self + rhs&lt;/code&gt; ，环绕该类型的边界。</target>
        </trans-unit>
        <trans-unit id="8112829180296558677473f537db1e33a076f93c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装（模数）除法。计算 &lt;code&gt;self / rhs&lt;/code&gt; ，环绕该类型的边界。</target>
        </trans-unit>
        <trans-unit id="3f6391833e153cf10bdb32314ca04ce9ce43dbdd" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">包装（模数）除法。计算 &lt;code&gt;self / rhs&lt;/code&gt; 。无符号类型的包装除法只是普通除法。包装是不可能发生的。存在此功能，以便所有操作都在包装操作中考虑。</target>
        </trans-unit>
        <trans-unit id="d6bb89dd7e6026b10f235fa3863c6339f2fb774c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) exponentiation. Computes &lt;code&gt;self.pow(exp)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装（模）幂。计算 &lt;code&gt;self.pow(exp)&lt;/code&gt; ，在类型的边界处回绕。</target>
        </trans-unit>
        <trans-unit id="e6b77bd3d8c54b47f23891885173c42858312a14" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装（模）乘。计算 &lt;code&gt;self * rhs&lt;/code&gt; ，环绕该类型的边界。</target>
        </trans-unit>
        <trans-unit id="2ad719d382b4d16912e1a91a3a59d2c050db5a30" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) negation. Computes &lt;code&gt;-self&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装（取反）。计算 &lt;code&gt;-self&lt;/code&gt; ，环绕类型的边界。</target>
        </trans-unit>
        <trans-unit id="88feadfab016809fcd2984cfd9226aba00462cae" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装（模块化）余数。计算 &lt;code&gt;self % rhs&lt;/code&gt; ，环绕该类型的边界。</target>
        </trans-unit>
        <trans-unit id="bab7a7fcc721ce6448649830e7166d7008062fd3" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;. Wrapped remainder calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">包装（模块化）余数。计算 &lt;code&gt;self % rhs&lt;/code&gt; 。无符号类型的包装余数计算只是常规余数计算。包装是不可能发生的。存在此功能，以便所有操作都在包装操作中考虑。</target>
        </trans-unit>
        <trans-unit id="0547792119ca778e4ded115060f8e8198122f4ee" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装（模减）。计算 &lt;code&gt;self - rhs&lt;/code&gt; ，在类型的边界处回绕。</target>
        </trans-unit>
        <trans-unit id="9c70c48db93cbf30305f6f367392a85a748eb0d9" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装欧几里得分部。计算 &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; ，在类型的边界处回绕。</target>
        </trans-unit>
        <trans-unit id="0c397d89ed28af23471d1300df82f2628a5cc9eb" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt;.</source>
          <target state="translated">包装欧几里得分部。计算 &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; 。无符号类型的包装除法只是普通除法。包装是不可能发生的。存在此功能，以便所有操作都在包装操作中考虑。由于对于正整数，除法的所有常见定义都是相等的，因此它完全等于 &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1a6d61ea92522854260430b74b8667bece5c095" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean modulo. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;. Wrapped modulo calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt;.</source>
          <target state="translated">包装欧几里德模。计算 &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; 。无符号类型的包装模运算只是常规的余数计算。包装是不可能发生的。存在此功能，以便所有操作都在包装操作中考虑。由于对于正整数，除法的所有常见定义都是相等的，因此它完全等于 &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72c3f54557cafd34a10c40361aa84b7aedc96050" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean remainder. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">包装欧几里得的余数。计算 &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; ，在类型的边界处回绕。</target>
        </trans-unit>
        <trans-unit id="c113027998f084fc650feeb5a7a7db8e8206e9c9" translate="yes" xml:space="preserve">
          <source>Wrapping arithmetic can be achieved either through methods like &lt;code&gt;wrapping_add&lt;/code&gt;, or through the &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</source>
          <target state="translated">包裹算术可以通过类似的方法来实现 &lt;code&gt;wrapping_add&lt;/code&gt; ，或者通过 &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; 类型，这表示，在底层值的所有标准的算术运算旨在具有包裹语义。</target>
        </trans-unit>
        <trans-unit id="67accd5f5a259bdba5036a1931f5ae6a264b08ff" translate="yes" xml:space="preserve">
          <source>Wrapping the entire closure amounts to a blanket assertion that all captured variables are unwind safe. This has the downside that if new captures are added in the future, they will also be considered unwind safe. Therefore, you may prefer to just wrap individual captures, as shown below. This is more annotation, but it ensures that if a new capture is added which is not unwind safe, you will get a compilation error at that time, which will allow you to consider whether that new capture in fact represent a bug or not.</source>
          <target state="translated">包裹整个闭包相当于一概断言所有捕获的变量都是安全的。这样做的缺点是,如果将来有新的捕获,它们也会被认为是安全的。因此,你可能更喜欢只对单个捕获进行封装,如下图所示。这样做的注释比较多,但它可以确保如果增加了一个新的捕获,而这个捕获不是解卷安全的,这时你会得到一个编译错误,这样你就可以考虑这个新的捕获事实上是否代表了一个bug。</target>
        </trans-unit>
        <trans-unit id="3012f027dfde83895278c2a37775ef7453b5a48e" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN % -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). In this case, this method returns 0.</source>
          <target state="translated">包装只会在有符号类型的 &lt;code&gt;MIN % -1&lt;/code&gt; 发生（其中 &lt;code&gt;MIN&lt;/code&gt; 是该类型的负最小值）。在这种情况下，此方法返回0。</target>
        </trans-unit>
        <trans-unit id="5d2a82c1ae568c2138fb6d4aab53c9ab79d15385" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). This is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In this case, this method returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">包装只会在有符号类型的 &lt;code&gt;MIN / -1&lt;/code&gt; 发生（其中 &lt;code&gt;MIN&lt;/code&gt; 是该类型的负最小值）。这等效于 &lt;code&gt;-MIN&lt;/code&gt; ，它是一个太大的正值，无法在类型中表示。在这种情况下，此方法本身将返回 &lt;code&gt;MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44bf3ad335738a5732c68d1f5196155da8fafc7b" translate="yes" xml:space="preserve">
          <source>Wrapping::abs</source>
          <target state="translated">Wrapping::abs</target>
        </trans-unit>
        <trans-unit id="fc3cfb30e84b8ebe6925ae0fbbf5f0d863e96948" translate="yes" xml:space="preserve">
          <source>Wrapping::add</source>
          <target state="translated">Wrapping::add</target>
        </trans-unit>
        <trans-unit id="e4708fa03c855319c8e70d77b4d353eb63d863a1" translate="yes" xml:space="preserve">
          <source>Wrapping::add_assign</source>
          <target state="translated">Wrapping::add_assign</target>
        </trans-unit>
        <trans-unit id="6227b7b51ca5d41b66a8bd3e6ec7e706422dcd02" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand</source>
          <target state="translated">Wrapping::bitand</target>
        </trans-unit>
        <trans-unit id="50986c3cc68dd80bb41b112f5357a4b5cb0ac2fc" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand_assign</source>
          <target state="translated">Wrapping::bitand_assign</target>
        </trans-unit>
        <trans-unit id="b7da20cfd17d521397a2d0c4d7318400486ff1e3" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor</source>
          <target state="translated">Wrapping::bitor</target>
        </trans-unit>
        <trans-unit id="b1f50a490018b194e6eb7c8804a9e9492ca0ae9b" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor_assign</source>
          <target state="translated">Wrapping::bitor_assign</target>
        </trans-unit>
        <trans-unit id="fd32619eaf11a02453eca2921b2682dcb9909981" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor</source>
          <target state="translated">Wrapping::bitxor</target>
        </trans-unit>
        <trans-unit id="4ee45c7807828640fae4c2e2cbbd932b27eab127" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor_assign</source>
          <target state="translated">Wrapping::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="453a622aaaf4b4b2bd85589c0f8774be95ac4938" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow</source>
          <target state="translated">Wrapping::borrow</target>
        </trans-unit>
        <trans-unit id="7842f835a5fa6d18893907fa71602942c78be04d" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow_mut</source>
          <target state="translated">Wrapping::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4251a19204a74bbc8ead142e79f328751693afa6" translate="yes" xml:space="preserve">
          <source>Wrapping::clamp</source>
          <target state="translated">Wrapping::clamp</target>
        </trans-unit>
        <trans-unit id="cf1afade198e332fd9d6aa7668a3bb32f2401d0b" translate="yes" xml:space="preserve">
          <source>Wrapping::clone</source>
          <target state="translated">Wrapping::clone</target>
        </trans-unit>
        <trans-unit id="54ff9aff38c7f4f514610503b3e487387eb07e58" translate="yes" xml:space="preserve">
          <source>Wrapping::clone_from</source>
          <target state="translated">Wrapping::clone_from</target>
        </trans-unit>
        <trans-unit id="f68c352e73999ff6e48da1e988a3a084b81becdc" translate="yes" xml:space="preserve">
          <source>Wrapping::clone_into</source>
          <target state="translated">Wrapping::clone_into</target>
        </trans-unit>
        <trans-unit id="32813d8440ead76b1def56d4e5d7fd137f1714b5" translate="yes" xml:space="preserve">
          <source>Wrapping::cmp</source>
          <target state="translated">Wrapping::cmp</target>
        </trans-unit>
        <trans-unit id="4fecc3db0f0b1e9deb5da5a1f039d7c88813a6bc" translate="yes" xml:space="preserve">
          <source>Wrapping::count_ones</source>
          <target state="translated">Wrapping::count_ones</target>
        </trans-unit>
        <trans-unit id="0707d6a5c3931efbf437f387bfdbb1a8025b4865" translate="yes" xml:space="preserve">
          <source>Wrapping::count_zeros</source>
          <target state="translated">Wrapping::count_zeros</target>
        </trans-unit>
        <trans-unit id="a236a50222c3eb097eb11ec3a8bd688ac72247f5" translate="yes" xml:space="preserve">
          <source>Wrapping::default</source>
          <target state="translated">Wrapping::default</target>
        </trans-unit>
        <trans-unit id="7606cc1196464916bcf7fa22b931dbc498ed2d35" translate="yes" xml:space="preserve">
          <source>Wrapping::div</source>
          <target state="translated">Wrapping::div</target>
        </trans-unit>
        <trans-unit id="b2ae04a0a7ac3514cff2c427720f641e1e13a105" translate="yes" xml:space="preserve">
          <source>Wrapping::div_assign</source>
          <target state="translated">Wrapping::div_assign</target>
        </trans-unit>
        <trans-unit id="818aac7baf3ade93847ccd4565c9412270bfd765" translate="yes" xml:space="preserve">
          <source>Wrapping::eq</source>
          <target state="translated">Wrapping::eq</target>
        </trans-unit>
        <trans-unit id="edf1a00ab01443e1c22b37d5320b28146f8fae8f" translate="yes" xml:space="preserve">
          <source>Wrapping::fmt</source>
          <target state="translated">Wrapping::fmt</target>
        </trans-unit>
        <trans-unit id="da29af44683c629d1953591b5af876af1284f165" translate="yes" xml:space="preserve">
          <source>Wrapping::from</source>
          <target state="translated">Wrapping::from</target>
        </trans-unit>
        <trans-unit id="bb4414a5497b8f006614444c61fdfbf7e351c1e1" translate="yes" xml:space="preserve">
          <source>Wrapping::from_be</source>
          <target state="translated">Wrapping::from_be</target>
        </trans-unit>
        <trans-unit id="8327aab74dc84b766db6b768bb5f0b4fbae51d60" translate="yes" xml:space="preserve">
          <source>Wrapping::from_le</source>
          <target state="translated">Wrapping::from_le</target>
        </trans-unit>
        <trans-unit id="2e5b33409882b1e267e6cfbfc31a1f3c8c97affd" translate="yes" xml:space="preserve">
          <source>Wrapping::ge</source>
          <target state="translated">Wrapping::ge</target>
        </trans-unit>
        <trans-unit id="763baba99ef1af7752d4c399fd9e4f56ca95cae4" translate="yes" xml:space="preserve">
          <source>Wrapping::gt</source>
          <target state="translated">Wrapping::gt</target>
        </trans-unit>
        <trans-unit id="7f52b5e60bdf5a8b75a6f1bee019e4223125b7ea" translate="yes" xml:space="preserve">
          <source>Wrapping::hash</source>
          <target state="translated">Wrapping::hash</target>
        </trans-unit>
        <trans-unit id="439b5d8bd3660d315ca5a58573799ca1f8b650bd" translate="yes" xml:space="preserve">
          <source>Wrapping::hash_slice</source>
          <target state="translated">Wrapping::hash_slice</target>
        </trans-unit>
        <trans-unit id="e6b9c5af34e5d2c6b6aa7479d3ac5762be077d3b" translate="yes" xml:space="preserve">
          <source>Wrapping::into</source>
          <target state="translated">Wrapping::into</target>
        </trans-unit>
        <trans-unit id="8f7f5f2dd4156c437b4278d979eb99568352829c" translate="yes" xml:space="preserve">
          <source>Wrapping::is_negative</source>
          <target state="translated">Wrapping::is_negative</target>
        </trans-unit>
        <trans-unit id="981b618861d8b57a9acf7fd2996a6466724aea1b" translate="yes" xml:space="preserve">
          <source>Wrapping::is_positive</source>
          <target state="translated">Wrapping::is_positive</target>
        </trans-unit>
        <trans-unit id="3e0d9c814180240ed5988fdbca65c34038e05ba2" translate="yes" xml:space="preserve">
          <source>Wrapping::is_power_of_two</source>
          <target state="translated">Wrapping::is_power_of_two</target>
        </trans-unit>
        <trans-unit id="7eee9ab399dbfec97ad14d12d84dd02ef4c06ce3" translate="yes" xml:space="preserve">
          <source>Wrapping::le</source>
          <target state="translated">Wrapping::le</target>
        </trans-unit>
        <trans-unit id="e5ed947e23bd18f2e1dec6dc53205a1c2b9565b1" translate="yes" xml:space="preserve">
          <source>Wrapping::leading_zeros</source>
          <target state="translated">Wrapping::leading_zeros</target>
        </trans-unit>
        <trans-unit id="863ef48643c8bc709efcb07670e6f74b1ce8d7db" translate="yes" xml:space="preserve">
          <source>Wrapping::lt</source>
          <target state="translated">Wrapping::lt</target>
        </trans-unit>
        <trans-unit id="f8c4ed77b17c6dd866e77c6844acb16e3570ccb0" translate="yes" xml:space="preserve">
          <source>Wrapping::max</source>
          <target state="translated">Wrapping::max</target>
        </trans-unit>
        <trans-unit id="b8977c5e6f634623ea3525b2d454af899f6eb091" translate="yes" xml:space="preserve">
          <source>Wrapping::max_value</source>
          <target state="translated">Wrapping::max_value</target>
        </trans-unit>
        <trans-unit id="0450be54fef79761132d1aef7686c837c2fb7d59" translate="yes" xml:space="preserve">
          <source>Wrapping::min</source>
          <target state="translated">Wrapping::min</target>
        </trans-unit>
        <trans-unit id="8e1254c79d384f9bb2963a56f9a7834418921b24" translate="yes" xml:space="preserve">
          <source>Wrapping::min_value</source>
          <target state="translated">Wrapping::min_value</target>
        </trans-unit>
        <trans-unit id="3dbf2ab4711da3ee943c8515466f305c3d067dd6" translate="yes" xml:space="preserve">
          <source>Wrapping::mul</source>
          <target state="translated">Wrapping::mul</target>
        </trans-unit>
        <trans-unit id="193429091dcbc7d316a04f0dc154b88272a65f08" translate="yes" xml:space="preserve">
          <source>Wrapping::mul_assign</source>
          <target state="translated">Wrapping::mul_assign</target>
        </trans-unit>
        <trans-unit id="0210502668266ded14b09843d193035a2b624a28" translate="yes" xml:space="preserve">
          <source>Wrapping::ne</source>
          <target state="translated">Wrapping::ne</target>
        </trans-unit>
        <trans-unit id="d08218c355fb4c595823228061d8f6285a384c7e" translate="yes" xml:space="preserve">
          <source>Wrapping::neg</source>
          <target state="translated">Wrapping::neg</target>
        </trans-unit>
        <trans-unit id="b68d44f8dc9b7bccaa5f89c2580778d3f5c481ca" translate="yes" xml:space="preserve">
          <source>Wrapping::next_power_of_two</source>
          <target state="translated">Wrapping::next_power_of_two</target>
        </trans-unit>
        <trans-unit id="dc08d2689104cf14575e073facb8aec83dc9a31a" translate="yes" xml:space="preserve">
          <source>Wrapping::not</source>
          <target state="translated">Wrapping::not</target>
        </trans-unit>
        <trans-unit id="e5d2695179201fbe97915617ae577e6a74b5df38" translate="yes" xml:space="preserve">
          <source>Wrapping::partial_cmp</source>
          <target state="translated">Wrapping::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fdaf45498033a636d7d91789f724fabd68edb8d" translate="yes" xml:space="preserve">
          <source>Wrapping::pow</source>
          <target state="translated">Wrapping::pow</target>
        </trans-unit>
        <trans-unit id="df24d6f31eef97d8356983a2855db9da91e53388" translate="yes" xml:space="preserve">
          <source>Wrapping::product</source>
          <target state="translated">Wrapping::product</target>
        </trans-unit>
        <trans-unit id="a8d7bbb8b06894e60316bfa8896f3a9ac47a6d64" translate="yes" xml:space="preserve">
          <source>Wrapping::rem</source>
          <target state="translated">Wrapping::rem</target>
        </trans-unit>
        <trans-unit id="da3a26e48c553a9ebd7ad42e38d4c13f4cbb4bde" translate="yes" xml:space="preserve">
          <source>Wrapping::rem_assign</source>
          <target state="translated">Wrapping::rem_assign</target>
        </trans-unit>
        <trans-unit id="307c0e40471bf0ca34f880f97766b03909622b22" translate="yes" xml:space="preserve">
          <source>Wrapping::reverse_bits</source>
          <target state="translated">Wrapping::reverse_bits</target>
        </trans-unit>
        <trans-unit id="133f98b61cd2fc743ea3ab9ab7d24b004d38769b" translate="yes" xml:space="preserve">
          <source>Wrapping::rotate_left</source>
          <target state="translated">Wrapping::rotate_left</target>
        </trans-unit>
        <trans-unit id="3ce34aaff81a8cb1b00504a6d7ba0307a0954a44" translate="yes" xml:space="preserve">
          <source>Wrapping::rotate_right</source>
          <target state="translated">Wrapping::rotate_right</target>
        </trans-unit>
        <trans-unit id="6fea873396e78fa80dc5b81a4b24f5731984d1b4" translate="yes" xml:space="preserve">
          <source>Wrapping::shl</source>
          <target state="translated">Wrapping::shl</target>
        </trans-unit>
        <trans-unit id="9edfd053f58c6dc953850af5f23fe9791136e673" translate="yes" xml:space="preserve">
          <source>Wrapping::shl_assign</source>
          <target state="translated">Wrapping::shl_assign</target>
        </trans-unit>
        <trans-unit id="727c36c7aba1df8a46aafc2245377be316466083" translate="yes" xml:space="preserve">
          <source>Wrapping::shr</source>
          <target state="translated">Wrapping::shr</target>
        </trans-unit>
        <trans-unit id="a459ea5ad750d76affd0bb2928733c2196d44926" translate="yes" xml:space="preserve">
          <source>Wrapping::shr_assign</source>
          <target state="translated">Wrapping::shr_assign</target>
        </trans-unit>
        <trans-unit id="f5b4f5594c248eaa052551544a5613e890f44805" translate="yes" xml:space="preserve">
          <source>Wrapping::signum</source>
          <target state="translated">Wrapping::signum</target>
        </trans-unit>
        <trans-unit id="5421f7a3c097f4803cab58bff1cb7ebfbe6a61cd" translate="yes" xml:space="preserve">
          <source>Wrapping::sub</source>
          <target state="translated">Wrapping::sub</target>
        </trans-unit>
        <trans-unit id="fe50fe98bf767916368abf1c925e7ac3e037c08c" translate="yes" xml:space="preserve">
          <source>Wrapping::sub_assign</source>
          <target state="translated">Wrapping::sub_assign</target>
        </trans-unit>
        <trans-unit id="f72d77e1d30187c514a849ed36c97ad216978037" translate="yes" xml:space="preserve">
          <source>Wrapping::sum</source>
          <target state="translated">Wrapping::sum</target>
        </trans-unit>
        <trans-unit id="3886fc89ccb5cf7ab1ce69c7013954aa90ca533e" translate="yes" xml:space="preserve">
          <source>Wrapping::swap_bytes</source>
          <target state="translated">Wrapping::swap_bytes</target>
        </trans-unit>
        <trans-unit id="bd4ae9e508fe128f587726b34b639594de73a5f6" translate="yes" xml:space="preserve">
          <source>Wrapping::to_be</source>
          <target state="translated">Wrapping::to_be</target>
        </trans-unit>
        <trans-unit id="7885b2e75fcb436776b4e307af4f9e623074994c" translate="yes" xml:space="preserve">
          <source>Wrapping::to_le</source>
          <target state="translated">Wrapping::to_le</target>
        </trans-unit>
        <trans-unit id="28db626412c7da571e95eec9a8ad5fa799e67614" translate="yes" xml:space="preserve">
          <source>Wrapping::to_owned</source>
          <target state="translated">Wrapping::to_owned</target>
        </trans-unit>
        <trans-unit id="73aa20bad1867d0ff4c2d24f0721a5a8eef6a4d8" translate="yes" xml:space="preserve">
          <source>Wrapping::to_string</source>
          <target state="translated">Wrapping::to_string</target>
        </trans-unit>
        <trans-unit id="04d5020a03ae412567480d9d468c0ac47bbeb27e" translate="yes" xml:space="preserve">
          <source>Wrapping::trailing_zeros</source>
          <target state="translated">Wrapping::trailing_zeros</target>
        </trans-unit>
        <trans-unit id="346c87924a2dddfb76d03753bd7557d01a46d89f" translate="yes" xml:space="preserve">
          <source>Wrapping::try_from</source>
          <target state="translated">Wrapping::try_from</target>
        </trans-unit>
        <trans-unit id="d6a7a2b803d2c4bf9add1e2055e52b0b8af45d11" translate="yes" xml:space="preserve">
          <source>Wrapping::try_into</source>
          <target state="translated">Wrapping::try_into</target>
        </trans-unit>
        <trans-unit id="527e0a06e98efe05731d34b8495de7a9c0796355" translate="yes" xml:space="preserve">
          <source>Wrapping::type_id</source>
          <target state="translated">Wrapping::type_id</target>
        </trans-unit>
        <trans-unit id="d8fe6dbee08984aea95f13fc56e0174b6cc4af39" translate="yes" xml:space="preserve">
          <source>Wraps a borrowed reference to a value in a &lt;code&gt;RefCell&lt;/code&gt; box. A wrapper type for an immutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">将借用的引用包装到 &lt;code&gt;RefCell&lt;/code&gt; 框中的值。从 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 不变借来的值的包装器类型。</target>
        </trans-unit>
        <trans-unit id="14edef43e7df9f66193cba2f15582361d72b01a1" translate="yes" xml:space="preserve">
          <source>Wraps a raw C string with a safe C string wrapper.</source>
          <target state="translated">用一个安全的C字符串包装器来包装一个原始的C字符串。</target>
        </trans-unit>
        <trans-unit id="cc416cf90ebff133d69706f1e45c9ea10f251fd4" translate="yes" xml:space="preserve">
          <source>Wraps a writer and buffers its output.</source>
          <target state="translated">封装一个写入器并缓冲其输出。</target>
        </trans-unit>
        <trans-unit id="8835b45a5ce8372fc5b7a9379d43ba01d8c84d89" translate="yes" xml:space="preserve">
          <source>Wraps a writer and buffers output to it, flushing whenever a newline (&lt;code&gt;0x0a&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;) is detected.</source>
          <target state="translated">包装编写器并将其输出缓冲，每当检测到换行符（ &lt;code&gt;0x0a&lt;/code&gt; ， &lt;code&gt;'\n'&lt;/code&gt; ）时刷新。</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="422b221e3621326874b9013f07f6893cefb36793" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written.</source>
          <target state="translated">向这个写入器写入一个缓冲区,返回写入的字节数。</target>
        </trans-unit>
        <trans-unit id="ae542cbc15e88f2bf807f8d29fc312d51c4f9344" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">向该写入器中写入一个缓冲区，返回写入的字节数。&lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e588991feee7d28024ae797d8cc74c94c42f1fc" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">向该写入器中写入一个缓冲区，返回写入的字节数。&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad7b7826de9694bab5fc487da2a9381a00705795" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">向该写入器中写入一个缓冲区，返回写入的字节数。&lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42d55a3c5a475b3858d14de608fc86cc1e27fad6" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">向该写入器中写入一个缓冲区，返回写入的字节数。&lt;a href=&quot;trait.write#tymethod.write&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f289e0fc842fa4a0a0c757a23aec01849b63cc" translate="yes" xml:space="preserve">
          <source>Write a slice as the entire contents of a file.</source>
          <target state="translated">将一个分片写成文件的全部内容。</target>
        </trans-unit>
        <trans-unit id="fd14b03d8c7f6b0eec5d8071e36c0b064da74395" translate="yes" xml:space="preserve">
          <source>Write a test that fails and run it to make sure it fails for the reason you expect.</source>
          <target state="translated">写一个失败的测试,并运行它以确保它失败的原因是你所期望的。</target>
        </trans-unit>
        <trans-unit id="4792f2eef0440e6afee1219df6ba659746474535" translate="yes" xml:space="preserve">
          <source>Write an Ipv6Addr, conforming to the canonical style described by &lt;a href=&quot;https://tools.ietf.org/html/rfc5952&quot;&gt;RFC 5952&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbf60c6c756d06c22970e5f8f55fad03ee1e678" translate="yes" xml:space="preserve">
          <source>Write an usize value to a byte buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a183b868e8fdfdd4779773f0a41b1402c75eb8" translate="yes" xml:space="preserve">
          <source>Write and run a &amp;ldquo;Hello, world!&amp;rdquo; program using &lt;code&gt;rustc&lt;/code&gt; directly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bcd0015d2edce502b72162bafb8ff8f006ae23" translate="yes" xml:space="preserve">
          <source>Write and run a Hello, world! program using &lt;code&gt;rustc&lt;/code&gt; directly</source>
          <target state="translated">编写并运行一个Hello，世界！程序直接使用 &lt;code&gt;rustc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffab6af2de782f874c56ecf608ce2d84de7c2b88" translate="yes" xml:space="preserve">
          <source>Write formatted data into a buffer, with a newline appended.</source>
          <target state="translated">将格式化的数据写入缓冲区,并添加一个新行。</target>
        </trans-unit>
        <trans-unit id="fcbfbac0d9c49bc3cad2d435296a9ffe56032aaa" translate="yes" xml:space="preserve">
          <source>Write is implemented for &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; by copying into the slice, overwriting its data.</source>
          <target state="translated">写入用于实现 &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; 通过复制到片，覆盖其数据。</target>
        </trans-unit>
        <trans-unit id="565edb809a298ba756dfab19911a1af435d39eef" translate="yes" xml:space="preserve">
          <source>Write is implemented for &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; by appending to the vector. The vector will grow as needed.</source>
          <target state="translated">通过将 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 附加到向量来实现写操作。载体将根据需要增长。</target>
        </trans-unit>
        <trans-unit id="ba9c763eec2480149fd9cd47639418928770f449" translate="yes" xml:space="preserve">
          <source>Write or modify just enough code to make the new test pass.</source>
          <target state="translated">编写或修改足够的代码来使新的测试通过。</target>
        </trans-unit>
        <trans-unit id="25725f1f38f240f2a77af039a57e73d792f138b4" translate="yes" xml:space="preserve">
          <source>Write::by_ref</source>
          <target state="translated">Write::by_ref</target>
        </trans-unit>
        <trans-unit id="b18d29c2778fcf294a1af5583a58fde2428d05bc" translate="yes" xml:space="preserve">
          <source>Write::flush</source>
          <target state="translated">Write::flush</target>
        </trans-unit>
        <trans-unit id="2ad8047081c1571209c8de21b5d8ef496c875bcb" translate="yes" xml:space="preserve">
          <source>Write::write</source>
          <target state="translated">Write::write</target>
        </trans-unit>
        <trans-unit id="7f21bb462deedb47e98867332781d5a55ac1f33c" translate="yes" xml:space="preserve">
          <source>Write::write_all</source>
          <target state="translated">Write::write_all</target>
        </trans-unit>
        <trans-unit id="59885a3e77b05a624ab69e3e736291d1ac54574b" translate="yes" xml:space="preserve">
          <source>Write::write_char</source>
          <target state="translated">Write::write_char</target>
        </trans-unit>
        <trans-unit id="869124fb10adcbc1f8e39c2d520b04d4a2bb69e1" translate="yes" xml:space="preserve">
          <source>Write::write_fmt</source>
          <target state="translated">Write::write_fmt</target>
        </trans-unit>
        <trans-unit id="3bed1d79d195792e3683c2bc152331ab7dd62609" translate="yes" xml:space="preserve">
          <source>Write::write_str</source>
          <target state="translated">Write::write_str</target>
        </trans-unit>
        <trans-unit id="141b04d7eaaf0c8ba6b520a1addb5de1176dd5e6" translate="yes" xml:space="preserve">
          <source>Write::write_vectored</source>
          <target state="translated">Write::write_vectored</target>
        </trans-unit>
        <trans-unit id="791cf1c7de23e0f236576b53f40de7030db55060" translate="yes" xml:space="preserve">
          <source>Writers are defined by two required methods, &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;由两种必需的方法write和&lt;a href=&quot;#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; 定义&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="066642e038ad8d099b61091156c44bbd264c7655" translate="yes" xml:space="preserve">
          <source>Writers are defined by two required methods, &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d019e37d31448a1c36b68f61dbbcb935ed4575" translate="yes" xml:space="preserve">
          <source>Writers are intended to be composable with one another. Many implementors throughout &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; take and provide types which implement the &lt;code&gt;Write&lt;/code&gt; trait.</source>
          <target state="translated">作家可以彼此融为一体。&lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::io&lt;/code&gt; &lt;/a&gt;许多实现者都采用并提供实现 &lt;code&gt;Write&lt;/code&gt; 特性的类型。</target>
        </trans-unit>
        <trans-unit id="a718c79c131f76156d3a6b0d5a5556c990d2570b" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded.</source>
          <target state="translated">将&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;写入此writer，并返回写入是否成功。</target>
        </trans-unit>
        <trans-unit id="dcbe05c646a15714bf69547e05d3cd91b7425533" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645bfe779599abf2ba4f8f6c08447416d5474b43" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4305f6b237e9832ff95454c9f34aa579f1dc813" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9272508b2e41aaf20afc1194eb5b0b6d2dfdc6c9" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将[ &lt;code&gt;char&lt;/code&gt; ]写入此写入器，返回写入是否成功。&lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="344bd2db5bc9ba178016d1881285c5afaddc4598" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将[ &lt;code&gt;char&lt;/code&gt; ]写入此写入器，返回写入是否成功。&lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d63a032a19b4234e192d3e267b268acd649fd1b" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将[ &lt;code&gt;char&lt;/code&gt; ]写入此写入器，返回写入是否成功。&lt;a href=&quot;trait.write#method.write_char&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95220c41379acdd46bdc780a7a0f1e80e449feff" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered.</source>
          <target state="translated">将一个格式化的字符串写入该写入器,并返回任何遇到的错误。</target>
        </trans-unit>
        <trans-unit id="ecd98e7e5a4ec62ace4f960c01001be172e4925a" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;../../../io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将格式化的字符串写入此编写器，返回遇到的任何错误。&lt;a href=&quot;../../../io/trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5543389626d86c8e31553df92af2bde941d2a65" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将格式化的字符串写入此编写器，返回遇到的任何错误。&lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de5e6f1aafa20fef122dbeed5a71a42b9aa2cae7" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将格式化的字符串写入此编写器，返回遇到的任何错误。&lt;a href=&quot;io/trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c76861292606f0bb18321f85e96258836dd2770e" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将格式化的字符串写入此编写器，返回遇到的任何错误。&lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ba303c199b9fe4bf1985b876faca69be2aaf9cf" translate="yes" xml:space="preserve">
          <source>Writes a number of bytes starting from a given offset.</source>
          <target state="translated">从给定的偏移量开始写入一定数量的字节。</target>
        </trans-unit>
        <trans-unit id="934343889f7324a6e5af2ff1400d9536dbb167e4" translate="yes" xml:space="preserve">
          <source>Writes a number of bytes starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#tymethod.write_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从给定的偏移量开始写入多个字节。&lt;a href=&quot;../os/unix/fs/trait.fileext#tymethod.write_at&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45af1e55309b26785973c6185f7a9e763b1c820c" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i128&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;i128&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="6bdae3ffbfb54cc26470f2ec7abd8a54cb058931" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i16&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;i16&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="1e459398c36e231b3d36e4260518d1366491f1f6" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i32&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;i32&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="e6d8da557fcf2c2f0d524d8144d83e2c8862ca13" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i64&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;i64&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="53db12ba27efb40f7499916f3539839440705b87" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i8&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;i8&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="330e06c59d6bdbee17d36d76f63e12553c4d97da" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;isize&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;isize&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="45e49a31d6e7c2d2a651050c305491ca7804f21e" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u128&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;u128&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="aa85ed84476923b1cc5d6b7dfba41874a5d706a0" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u16&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;u16&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="d68ef120a557f4627660db1da5fdfbcac01eb533" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u32&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;u32&lt;/code&gt; 到这个散列器。</target>
        </trans-unit>
        <trans-unit id="a14997eaf51c4e7602b5505b9d66837490a2a9fe" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u64&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;u64&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="40743e36f9b775608cfba8e00eb78b804913d33f" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u8&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;u8&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="d83f8161e61d59972914ffd1989afe5538474dbc" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;usize&lt;/code&gt; into this hasher.</source>
          <target state="translated">将单个 &lt;code&gt;usize&lt;/code&gt; 写入此哈希器。</target>
        </trans-unit>
        <trans-unit id="75c98aad5800d7465070b778412dd48f81ecbabf" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded.</source>
          <target state="translated">向该写入器写入一个字节片,返回写入是否成功。</target>
        </trans-unit>
        <trans-unit id="589037d6e27cf4636e5142d1239dc9ad31b05dda" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将字节的一部分写入此写入器，返回写入是否成功。&lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fddaf179154fa846c54d2edd52d74504db1eece" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将字节的一部分写入此写入器，返回写入是否成功。&lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8235073da555c5bd3bf719f2ab4a2cc258a3445a" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将字节的一部分写入此写入器，返回写入是否成功。&lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="660e25a3eb306b3311d28442f6e6208ae58a5791" translate="yes" xml:space="preserve">
          <source>Writes a string slice into this writer, returning whether the write succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b1b14666b506662fd683fe6bca2d5d9e8bcd1f" translate="yes" xml:space="preserve">
          <source>Writes a string slice into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a15db8ef2c352ca0cb66f490148cb6670e5f327" translate="yes" xml:space="preserve">
          <source>Writes a string slice into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe30ae81a283cdbac3d9b2f4e474cbc6a9a2dcd" translate="yes" xml:space="preserve">
          <source>Writes a string slice into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e50e6072cf8d9643cbbf27cb278e15b00644e8" translate="yes" xml:space="preserve">
          <source>Writes formatted data into a buffer.</source>
          <target state="translated">将格式化的数据写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="b133e539f22c56a49e3bc9bfe584753136fdfcd5" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;.</source>
          <target state="translated">将一些数据写入此 &lt;code&gt;Hasher&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d56d2da40c1790d440e6f30eedb76e01abcaec37" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;../../hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将一些数据写入此 &lt;code&gt;Hasher&lt;/code&gt; 中。&lt;a href=&quot;../../hash/trait.hasher#tymethod.write&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="664b4eecc8d27414cb11c8ab606f3786a94fd297" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;../hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将一些数据写入此 &lt;code&gt;Hasher&lt;/code&gt; 中。&lt;a href=&quot;../hash/trait.hasher#tymethod.write&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ca27f9b6840a29f38a33b35b6a75dbc6f57703f" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将一些数据写入此 &lt;code&gt;Hasher&lt;/code&gt; 中。&lt;a href=&quot;hash/trait.hasher#tymethod.write&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b8a4f8c89b109d74c610b85abf9468d80196ad2" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将一些数据写入此 &lt;code&gt;Hasher&lt;/code&gt; 中。&lt;a href=&quot;trait.hasher#tymethod.write&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a2b61198cabc344eec293cea3eb21151c358cad" translate="yes" xml:space="preserve">
          <source>Writes some data to the underlying buffer contained within this formatter.</source>
          <target state="translated">将一些数据写入该格式器中包含的底层缓冲区。</target>
        </trans-unit>
        <trans-unit id="b05105a6d198b6efd15010fe5b3a83555f844ec8" translate="yes" xml:space="preserve">
          <source>Writes some formatted information into this instance.</source>
          <target state="translated">将一些格式化的信息写入这个实例中。</target>
        </trans-unit>
        <trans-unit id="73e796ac178d17656628057ad4de2c3715ecb31f" translate="yes" xml:space="preserve">
          <source>Writes to &lt;code&gt;Copy&lt;/code&gt; union fields do not require reads for running destructors, so these writes don't have to be placed in &lt;code&gt;unsafe&lt;/code&gt; blocks</source>
          <target state="translated">&amp;ldquo;写入 &lt;code&gt;Copy&lt;/code&gt; 联合字段不需要读取正在运行的析构函数，因此这些写入不必放在 &lt;code&gt;unsafe&lt;/code&gt; 块中</target>
        </trans-unit>
        <trans-unit id="7a04ade11270a59b7a8d9a38b3f59d450099f209" translate="yes" xml:space="preserve">
          <source>Writing Automated Tests</source>
          <target state="translated">编写自动测试</target>
        </trans-unit>
        <trans-unit id="8d9de7655ad92afdb381750f5cb6b0b9d4630db5" translate="yes" xml:space="preserve">
          <source>Writing Code to Pass the Test</source>
          <target state="translated">编写代码,通过测试</target>
        </trans-unit>
        <trans-unit id="c7ec99d9ff26178393f163143686d9bc7fb6a3d1" translate="yes" xml:space="preserve">
          <source>Writing Error Messages to Standard Error Instead of Standard Output</source>
          <target state="translated">将错误信息写入标准错误而不是标准输出。</target>
        </trans-unit>
        <trans-unit id="b4a721e4aa8c7261bfa68a1535b4fe4e84e2f28e" translate="yes" xml:space="preserve">
          <source>Writing a Failing Test</source>
          <target state="translated">写一个失败的测试</target>
        </trans-unit>
        <trans-unit id="83ca9b1b9c2e5fb239421cfb23f5c54c22d603eb" translate="yes" xml:space="preserve">
          <source>Writing a Failing Test for the Case-Insensitive &lt;code id=&quot;writing-a-failing-test-for-the-case-insensitive-search-function&quot;&gt;search&lt;/code&gt; Function</source>
          <target state="translated">为不区分大小写的 &lt;code id=&quot;writing-a-failing-test-for-the-case-insensitive-search-function&quot;&gt;search&lt;/code&gt; 功能编写失败测试</target>
        </trans-unit>
        <trans-unit id="993bd3ebaf1e78a4791f69f6f8988c0b5b0d3ae3" translate="yes" xml:space="preserve">
          <source>Writing a Response</source>
          <target state="translated">撰写回应</target>
        </trans-unit>
        <trans-unit id="97d3ede6e5b435ad6b9a77ec03a83113afdfb3a5" translate="yes" xml:space="preserve">
          <source>Writing a program that prints &lt;code&gt;Hello, world!&lt;/code&gt;</source>
          <target state="translated">编写一个打印 &lt;code&gt;Hello, world!&lt;/code&gt; 的程序！</target>
        </trans-unit>
        <trans-unit id="785a0c70580d26564b61ec7b2da0b61477b68b43" translate="yes" xml:space="preserve">
          <source>Writing an array&amp;rsquo;s type this way looks similar to an alternative syntax for initializing an array: if you want to create an array that contains the same value for each element, you can specify the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:</source>
          <target state="translated">以这种方式编写数组的类型看起来类似于初始化数组的另一种语法：如果要创建一个数组，该数组的每个元素都包含相同的值，则可以指定初始值，后跟一个分号，然后指定长度数组放在方括号中，如下所示：</target>
        </trans-unit>
        <trans-unit id="f560bd46db71699beed1dbcf4f543ef55a25efce" translate="yes" xml:space="preserve">
          <source>Writing and Running a Rust Program</source>
          <target state="translated">编写和运行Rust程序</target>
        </trans-unit>
        <trans-unit id="6c156da0c5e2570a035c5e8bd4f021c50ffb20da" translate="yes" xml:space="preserve">
          <source>Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.</source>
          <target state="translated">编写这两种测试是很重要的,以确保你的库的各个部分分别和一起做你所期望的事情。</target>
        </trans-unit>
        <trans-unit id="796c30002159ff15a3a7e4eeec8cf17afe766c5f" translate="yes" xml:space="preserve">
          <source>Writing tests (&lt;a href=&quot;ch11-00-testing&quot;&gt;Chapter 11&lt;/a&gt;)</source>
          <target state="translated">编写测试（&lt;a href=&quot;ch11-00-testing&quot;&gt;第11章&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="450f15de86c3b61b38fb7579e1f10bd319432ea8" translate="yes" xml:space="preserve">
          <source>Writing tests so they return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an &lt;code&gt;Err&lt;/code&gt; variant.</source>
          <target state="translated">编写测试以使它们返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 使您能够在测试正文中使用问号运算符，这是编写测试的便捷方法，如果其中的任何操作返回 &lt;code&gt;Err&lt;/code&gt; 变体，测试都会失败。</target>
        </trans-unit>
        <trans-unit id="07bc23942d416a7fef04bbcf5fc194f37c766951" translate="yes" xml:space="preserve">
          <source>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. Imagine having a project full of code like that in Listing 19-24.</source>
          <target state="translated">将这种冗长的类型写在函数签名中,并作为类型注解写满整个代码,会让人感到厌烦,而且容易出错。想象一下,有一个项目充满了像清单19-24中那样的代码。</target>
        </trans-unit>
        <trans-unit id="07e47a0416a28679b7085ffdf5344062b5fcdd36" translate="yes" xml:space="preserve">
          <source>Yanking a version prevents new projects from starting to depend on that version while allowing all existing projects that depend on it to continue to download and depend on that version. Essentially, a yank means that all projects with a &lt;em&gt;Cargo.lock&lt;/em&gt; will not break, and any future &lt;em&gt;Cargo.lock&lt;/em&gt; files generated will not use the yanked version.</source>
          <target state="translated">取消版本阻止新项目开始依赖该版本，同时允许所有依赖该版本的现有项目继续下载并依赖该版本。本质上，&lt;em&gt;拉动&lt;/em&gt;意味着所有带有&lt;em&gt;Cargo.lock的&lt;/em&gt;项目都不会中断，并且以后生成的任何&lt;em&gt;Cargo.lock&lt;/em&gt;文件都不会使用&lt;em&gt;拉动&lt;/em&gt;版本。</target>
        </trans-unit>
        <trans-unit id="f8e5799899abe435ee29b5e571cca4a4951b4912" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;CStr&lt;/code&gt; contains valid UTF-8.</source>
          <target state="translated">如果 &lt;code&gt;CStr&lt;/code&gt; 包含有效的UTF-8，则产生&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;切片。</target>
        </trans-unit>
        <trans-unit id="3c7c3595b258ab56decf488e64eb0d24960bf485" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;OsStr&lt;/code&gt; is valid Unicode.</source>
          <target state="translated">如果 &lt;code&gt;OsStr&lt;/code&gt; 是有效的Unicode，则生成&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;切片。</target>
        </trans-unit>
        <trans-unit id="195279f44b198c67c27101e6d1db95ba38fd584e" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;Path&lt;/code&gt; is valid unicode.</source>
          <target state="translated">如果 &lt;code&gt;Path&lt;/code&gt; 是有效的unicode，则产生&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; slice 。</target>
        </trans-unit>
        <trans-unit id="758c4d0f690a6c543ad0cd5b04420b3087ad8f1b" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;CStr&lt;/code&gt; contains valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86217a19209be5bc5617ae5f4db30f4c9578c5e5" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;OsStr&lt;/code&gt; is valid Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c0b7dbdf4f40a5f0fc3157e3dd92701d432da4" translate="yes" xml:space="preserve">
          <source>Yields a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice if the &lt;code&gt;Path&lt;/code&gt; is valid unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413679a903a004b3c5c40da67ab627b0db5926d2" translate="yes" xml:space="preserve">
          <source>Yields a &lt;code&gt;Result&amp;lt;bool, ParseBoolError&amp;gt;&lt;/code&gt;, because &lt;code&gt;s&lt;/code&gt; may or may not actually be parseable.</source>
          <target state="translated">产生 &lt;code&gt;Result&amp;lt;bool, ParseBoolError&amp;gt;&lt;/code&gt; ，因为 &lt;code&gt;s&lt;/code&gt; 可能实际上可能不可解析。</target>
        </trans-unit>
        <trans-unit id="e9230c9fc9c21a74b44c14778be86dfe99887de8" translate="yes" xml:space="preserve">
          <source>Yields the underlying &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice.</source>
          <target state="translated">产生基础的&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;切片。</target>
        </trans-unit>
        <trans-unit id="0c744c88f234909706712417b746da8f001876e3" translate="yes" xml:space="preserve">
          <source>Yields the underlying byte vector of this &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">产生此&lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;的基础字节向量。</target>
        </trans-unit>
        <trans-unit id="45e614c97fadbe28622649b26e90d5c12092a4a5" translate="yes" xml:space="preserve">
          <source>Yields the underlying byte vector of this &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827f632b1eb13c813d90204287d7a305ab25fbc3" translate="yes" xml:space="preserve">
          <source>Yields the underlying byte vector of this [&lt;code&gt;OsString&lt;/code&gt;]. &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">产生此[ &lt;code&gt;OsString&lt;/code&gt; ] 的基础字节向量。&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65ae03a65393d6ce8a756fcd3bce6d5e0e587d92" translate="yes" xml:space="preserve">
          <source>You also don&amp;rsquo;t have to worry about problems resulting from accidentally cleaning up values still in use: the ownership system that makes sure references are always valid also ensures that &lt;code&gt;drop&lt;/code&gt; gets called only once when the value is no longer being used.</source>
          <target state="translated">您也不必担心由于意外清理仍在使用的值而导致的问题：确保引用始终有效的所有权系统还确保在不再使用该值时仅调用一次 &lt;code&gt;drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec9b139e5d307ab87a8084c13822b6acd8da7805" translate="yes" xml:space="preserve">
          <source>You are &lt;em&gt;absolutely&lt;/em&gt; certain you &lt;em&gt;really&lt;/em&gt;, &lt;em&gt;truly&lt;/em&gt;, want a doubly linked list.</source>
          <target state="translated">你是&lt;em&gt;绝对&lt;/em&gt;肯定你&lt;em&gt;真的&lt;/em&gt;，&lt;em&gt;真的&lt;/em&gt;，希望有一个双向链表。</target>
        </trans-unit>
        <trans-unit id="7df51c21931f3ba8153011ff31ac3df483e2b6f2" translate="yes" xml:space="preserve">
          <source>You are trying to use an identifier that is either undefined or not a struct. Erroneous code example:</source>
          <target state="translated">你试图使用一个未定义或不是结构的标识符。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="72a4cd7a33eb16fdb9f37ef196e2dcb7606d5372" translate="yes" xml:space="preserve">
          <source>You attempted to use multiple types as bounds for a closure or trait object. Rust does not currently support this. A simple example that causes this error:</source>
          <target state="translated">您试图使用多个类型作为闭包或trait对象的边界。Rust 目前不支持这个功能。一个简单的例子会导致这个错误。</target>
        </trans-unit>
        <trans-unit id="1f01714756be32bd3190176ff6c1f442b832a1d6" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;struct.vec#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; values onto the end of a vector (which will grow the vector as needed):</source>
          <target state="translated">您可以&lt;a href=&quot;struct.vec#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;值推送到向量的末尾（它将根据需要增加向量）：</target>
        </trans-unit>
        <trans-unit id="0d2a0e1493249f355c1cfdfc3bac39d75c54ff72" translate="yes" xml:space="preserve">
          <source>You can also add a custom message to be printed with the failure message as optional arguments to the &lt;code&gt;assert!&lt;/code&gt;, &lt;code&gt;assert_eq!&lt;/code&gt;, and &lt;code&gt;assert_ne!&lt;/code&gt; macros. Any arguments specified after the one required argument to &lt;code&gt;assert!&lt;/code&gt; or the two required arguments to &lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; are passed along to the &lt;code&gt;format!&lt;/code&gt; macro (discussed in Chapter 8 in the &lt;a href=&quot;ch08-02-strings#concatenation-with-the--operator-or-the-format-macro&quot;&gt;&amp;ldquo;Concatenation with the &lt;code&gt;+&lt;/code&gt; Operator or the &lt;code&gt;format!&lt;/code&gt; Macro&amp;rdquo;&lt;/a&gt; section), so you can pass a format string that contains &lt;code&gt;{}&lt;/code&gt; placeholders and values to go in those placeholders. Custom messages are useful to document what an assertion means; when a test fails, you&amp;rsquo;ll have a better idea of what the problem is with the code.</source>
          <target state="translated">您还可以添加要与失败消息一起打印的自定义消息，作为 &lt;code&gt;assert!&lt;/code&gt; 可选参数！， &lt;code&gt;assert_eq!&lt;/code&gt; 和 &lt;code&gt;assert_ne!&lt;/code&gt; 宏。在必须 &lt;code&gt;assert!&lt;/code&gt; 的一个必填参数之后指定的任何参数！或 &lt;code&gt;assert_eq!&lt;/code&gt; 的两个必需参数！和 &lt;code&gt;assert_ne!&lt;/code&gt; 传递给 &lt;code&gt;format!&lt;/code&gt; 宏（在第8章的&lt;a href=&quot;ch08-02-strings#concatenation-with-the--operator-or-the-format-macro&quot;&gt;&amp;ldquo;与 &lt;code&gt;+&lt;/code&gt; 运算符或 &lt;code&gt;format!&lt;/code&gt; 宏&amp;rdquo;串联中&lt;/a&gt;讨论），因此您可以传递包含 &lt;code&gt;{}&lt;/code&gt; 的格式字符串占位符和要放在这些占位符中的值。自定义消息对于记录断言的含义很有用。当测试失败时，您将更好地了解代码的问题所在。</target>
        </trans-unit>
        <trans-unit id="59d30fe12340d329f73be7515fd4175c752f146f" translate="yes" xml:space="preserve">
          <source>You can also bring an item into scope with &lt;code&gt;use&lt;/code&gt; and a relative path. Listing 7-12 shows how to specify a relative path to get the same behavior as in Listing 7-11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6933a535082bef416b84d186746e29a92d0ca26" translate="yes" xml:space="preserve">
          <source>You can also combine these implementations to let the &lt;code&gt;==&lt;/code&gt; operator work with two different types:</source>
          <target state="translated">您还可以结合使用这些实现，以使 &lt;code&gt;==&lt;/code&gt; 运算符可以使用两种不同的类型：</target>
        </trans-unit>
        <trans-unit id="99c9da3c8943fcee498c0ed8b484f227e63545a2" translate="yes" xml:space="preserve">
          <source>You can also define structs that don&amp;rsquo;t have any fields! These are called &lt;em&gt;unit-like structs&lt;/em&gt; because they behave similarly to &lt;code&gt;()&lt;/code&gt;, the unit type. Unit-like structs can be useful in situations in which you need to implement a trait on some type but don&amp;rsquo;t have any data that you want to store in the type itself. We&amp;rsquo;ll discuss traits in Chapter 10.</source>
          <target state="translated">您还可以定义没有任何字段的结构！它们之所以称为类&lt;em&gt;单元结构，&lt;/em&gt;是因为它们的行为类似于 &lt;code&gt;()&lt;/code&gt; 单元类型。在需要在某种类型上实现特征但又不想在类型本身中存储任何数据的情况下，类似单元的结构很有用。我们将在第10章中讨论特征。</target>
        </trans-unit>
        <trans-unit id="85102a822bf46f84c9e28f5552de9b8522a4dbde" translate="yes" xml:space="preserve">
          <source>You can also define structs that look similar to tuples, called &lt;em&gt;tuple structs&lt;/em&gt;. Tuple structs have the added meaning the struct name provides but don&amp;rsquo;t have names associated with their fields; rather, they just have the types of the fields. Tuple structs are useful when you want to give the whole tuple a name and make the tuple be a different type from other tuples, and naming each field as in a regular struct would be verbose or redundant.</source>
          <target state="translated">您还可以定义看起来类似于元&lt;em&gt;组的结构&lt;/em&gt;，称为&lt;em&gt;元组结构&lt;/em&gt;。元组结构具有附加的含义，即结构名称提供的含义，但没有与其字段关联的名称；相反，它们只是字段的类型。当您想给整个元组起一个名字并使元组成为与其他元组不同的类型时，元组结构很有用，并且像常规结构中那样命名每个字段都是冗长或多余的。</target>
        </trans-unit>
        <trans-unit id="478834b4ebadfb970a4e8408c36d21f8f75d5297" translate="yes" xml:space="preserve">
          <source>You can also define your own wrapper around &lt;code&gt;System&lt;/code&gt; if you'd like, such as keeping track of the number of all bytes allocated:</source>
          <target state="translated">您还可以根据需要在 &lt;code&gt;System&lt;/code&gt; 周围定义自己的包装器，例如跟踪分配的所有字节数：</target>
        </trans-unit>
        <trans-unit id="f2ec90a0a184fc0a34f0ffbecbdb3577a9642216" translate="yes" xml:space="preserve">
          <source>You can also drop both values to take a slice of the entire string. So these are equal:</source>
          <target state="translated">你也可以把这两个值都丢掉,取整个字符串的一个片断。所以这些都是平等的。</target>
        </trans-unit>
        <trans-unit id="07fd7e0ceaeb6effa3bef1f17d2c79141e988f86" translate="yes" xml:space="preserve">
          <source>You can also have this error while using a cell type:</source>
          <target state="translated">在使用单元格类型时也会出现这种错误。</target>
        </trans-unit>
        <trans-unit id="2abcc436137e02d2d460f9bb29cc2de726a9488d" translate="yes" xml:space="preserve">
          <source>You can also implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; manually:</source>
          <target state="translated">您还可以手动实现 &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Clone&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77d0a855671805dfc5fdffb0de5601ad968fb03d" translate="yes" xml:space="preserve">
          <source>You can also omit the parameter name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0eb8e7e0853f72a4740501ba25eded7eda4cc9" translate="yes" xml:space="preserve">
          <source>You can also rewrite this in terms of &lt;a href=&quot;#method.flat_map&quot;&gt;&lt;code&gt;flat_map()&lt;/code&gt;&lt;/a&gt;, which is preferable in this case since it conveys intent more clearly:</source>
          <target state="translated">您还可以根据&lt;a href=&quot;#method.flat_map&quot;&gt; &lt;code&gt;flat_map()&lt;/code&gt; &lt;/a&gt;重写此代码，在这种情况下，这是首选方法，因为它可以更清晰地传达意图：</target>
        </trans-unit>
        <trans-unit id="31c83cc061e340443a0779b3d7127df9d6c7ce68" translate="yes" xml:space="preserve">
          <source>You can also rewrite this in terms of &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;flat_map()&lt;/code&gt;&lt;/a&gt;, which is preferable in this case since it conveys intent more clearly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15da995ef7945b8770639a97784385a172b200d0" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;dbg!()&lt;/code&gt; without a value to just print the file and line whenever it's reached.</source>
          <target state="translated">您也可以使用不带值的 &lt;code&gt;dbg!()&lt;/code&gt; 来仅在到达文件和行时打印它。</target>
        </trans-unit>
        <trans-unit id="9efcd998a1aef5d563a086721600c461fc2c254c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;cargo fix&lt;/code&gt; command to transition your code between different Rust editions. Editions are covered in Appendix E.</source>
          <target state="translated">您还可以使用 &lt;code&gt;cargo fix&lt;/code&gt; 命令在不同的Rust版本之间转换代码。版本包含在附录E中。</target>
        </trans-unit>
        <trans-unit id="9e76ec17ba63844ca8928afd80bf3131846fedf2" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;em&gt;or&lt;/em&gt; operator &lt;code&gt;|&lt;/code&gt; in a match guard to specify multiple patterns; the match guard condition will apply to all the patterns. Listing 18-28 shows the precedence of combining a match guard with a pattern that uses &lt;code&gt;|&lt;/code&gt;. The important part of this example is that the &lt;code&gt;if y&lt;/code&gt; match guard applies to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;em&gt;and&lt;/em&gt;&lt;code&gt;6&lt;/code&gt;, even though it might look like &lt;code&gt;if y&lt;/code&gt; only applies to &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">您也可以使用&lt;em&gt;or&lt;/em&gt;运算符 &lt;code&gt;|&lt;/code&gt; 在比赛后卫中指定多个模式；比赛守卫条件将适用于所有模式。清单18-28显示了将匹配防护与使用 &lt;code&gt;|&lt;/code&gt; 。这个例子中的重要组成部分是， &lt;code&gt;if y&lt;/code&gt; 比赛后卫适用于 &lt;code&gt;4&lt;/code&gt; ， &lt;code&gt;5&lt;/code&gt; ，&lt;em&gt;和&lt;/em&gt; &lt;code&gt;6&lt;/code&gt; ，尽管它可能看起来像 &lt;code&gt;if y&lt;/code&gt; 只适用于 &lt;code&gt;6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="109e7f6c3d07299c54983d31980eeb18d57c214f" translate="yes" xml:space="preserve">
          <source>You can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ecf9c07343c46c1d60f065ded4b4f2eb0ea645" translate="yes" xml:space="preserve">
          <source>You can also work with partially initialized arrays, which could be found in low-level datastructures.</source>
          <target state="translated">你也可以使用部分初始化的数组,这可以在低级数据结构中找到。</target>
        </trans-unit>
        <trans-unit id="b6c603fa73cf57e512f35e947ee6f15111e430a7" translate="yes" xml:space="preserve">
          <source>You can append a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and append a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">您可以使用&lt;a href=&quot;#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;方法将&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;附加到 &lt;code&gt;String&lt;/code&gt; ，并使用&lt;a href=&quot;#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt;方法将&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;附加：</target>
        </trans-unit>
        <trans-unit id="59ee6d5b203d9d5c9909fd86ebe91daa1ede20d7" translate="yes" xml:space="preserve">
          <source>You can append a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;struct.string#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and append a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d11f2c97c83c2645f12b9ebc6ac85c5458f4e32" translate="yes" xml:space="preserve">
          <source>You can build a free-standing crate by adding &lt;code&gt;#![no_std]&lt;/code&gt; to the crate attributes:</source>
          <target state="translated">您可以通过在包装箱属性中添加 &lt;code&gt;#![no_std]&lt;/code&gt; 来构建独立的包装箱：</target>
        </trans-unit>
        <trans-unit id="b809a385993bf02c8d1206070cc3301b18c3b78c" translate="yes" xml:space="preserve">
          <source>You can contribute to this book by opening an issue or sending a pull request to &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/&quot;&gt;the Rust Reference repository&lt;/a&gt;. If this book does not answer your question, and you think its answer is in scope of it, please do not hesitate to file an issue or ask about it in the &lt;code&gt;#docs&lt;/code&gt; channels on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;Discord&lt;/a&gt;. Knowing what people use this book for the most helps direct our attention to making those sections the best that they can be.</source>
          <target state="translated">您可以通过打开问题或向&lt;a href=&quot;https://github.com/rust-lang-nursery/reference/&quot;&gt;Rust参考资料库&lt;/a&gt;发送拉取请求来为本书做出贡献。如果这本书没有回答您的问题，并且您认为它的回答在范围之内，请不要犹豫，在&lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;Discord&lt;/a&gt;的 &lt;code&gt;#docs&lt;/code&gt; 渠道中提出问题或询问。知道人们最常使用本书的内容有助于我们将注意力集中在使这些部分尽可能地发挥最大作用上。</target>
        </trans-unit>
        <trans-unit id="b47151976fa0c19d6bbd8b86018adedad5599a36" translate="yes" xml:space="preserve">
          <source>You can contribute to this book by opening an issue or sending a pull request to &lt;a href=&quot;https://github.com/rust-lang/reference/&quot;&gt;the Rust Reference repository&lt;/a&gt;. If this book does not answer your question, and you think its answer is in scope of it, please do not hesitate to file an issue or ask about it in the &lt;code&gt;#docs&lt;/code&gt; channels on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;Discord&lt;/a&gt;. Knowing what people use this book for the most helps direct our attention to making those sections the best that they can be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45652675628aa0520caadf107ccf92529cef48c4" translate="yes" xml:space="preserve">
          <source>You can create &lt;code&gt;Path&lt;/code&gt;s from &lt;code&gt;String&lt;/code&gt;s, or even other &lt;code&gt;Path&lt;/code&gt;s:</source>
          <target state="translated">您可以从 &lt;code&gt;String&lt;/code&gt; 甚至其他 &lt;code&gt;Path&lt;/code&gt; 创建 &lt;code&gt;Path&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d7926aaf53927823e4081b71fa3d55e1e7d5547f" translate="yes" xml:space="preserve">
          <source>You can create a &lt;code&gt;String&lt;/code&gt; from &lt;a href=&quot;../primitive.str&quot;&gt;a literal string&lt;/a&gt; with &lt;a href=&quot;../convert/trait.from#tymethod.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab7261ff093b68aeb80217fb17838c264ba793f" translate="yes" xml:space="preserve">
          <source>You can create a &lt;code&gt;String&lt;/code&gt; from a literal string with &lt;a href=&quot;#method.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;#method.from&quot;&gt; &lt;code&gt;String::from&lt;/code&gt; &lt;/a&gt;文字字符串创建 &lt;code&gt;String&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9e907952e713a332ea657810a208121675e84c04" translate="yes" xml:space="preserve">
          <source>You can create a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; from an existing one by concatenating with &lt;code&gt;+&lt;/code&gt;:</source>
          <target state="translated">您可以通过与 &lt;code&gt;+&lt;/code&gt; 串联从现有&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;创建一个新字符串：</target>
        </trans-unit>
        <trans-unit id="2cc5912ade8e0031b95579911c3cbaa63e5424d5" translate="yes" xml:space="preserve">
          <source>You can create an empty hash map with &lt;code&gt;new&lt;/code&gt; and add elements with &lt;code&gt;insert&lt;/code&gt;. In Listing 8-20, we&amp;rsquo;re keeping track of the scores of two teams whose names are Blue and Yellow. The Blue team starts with 10 points, and the Yellow team starts with 50.</source>
          <target state="translated">您可以使用 &lt;code&gt;new&lt;/code&gt; 创建一个空的哈希映射，并使用 &lt;code&gt;insert&lt;/code&gt; 创建一个add元素。在清单8-20中，我们跟踪两个名字分别为Blue和Yellow的球队的得分。蓝队以10分开始，黄队以50分开始。</target>
        </trans-unit>
        <trans-unit id="0d3270ed21cd27a14044769666f4247cb1a76136" translate="yes" xml:space="preserve">
          <source>You can customize the error message by passing a string as the second parameter:</source>
          <target state="translated">你可以通过传递一个字符串作为第二个参数来定制错误信息。</target>
        </trans-unit>
        <trans-unit id="f50b50da715d70f8535907a48cb0e96ef9c58565" translate="yes" xml:space="preserve">
          <source>You can derive &lt;code&gt;Copy&lt;/code&gt; on any type whose parts all implement &lt;code&gt;Copy&lt;/code&gt;. You can only apply the &lt;code&gt;Copy&lt;/code&gt; trait to types that also implement &lt;code&gt;Clone&lt;/code&gt;, because a type that implements &lt;code&gt;Copy&lt;/code&gt; has a trivial implementation of &lt;code&gt;Clone&lt;/code&gt; that performs the same task as &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">你可以得到你 &lt;code&gt;Copy&lt;/code&gt; 任何类型，其部件都实现 &lt;code&gt;Copy&lt;/code&gt; 。您只能将 &lt;code&gt;Copy&lt;/code&gt; trait应用于也实现 &lt;code&gt;Clone&lt;/code&gt; 的类型，因为实现 &lt;code&gt;Copy&lt;/code&gt; 的类型具有琐碎的 &lt;code&gt;Clone&lt;/code&gt; 实现，该实现执行与 &lt;code&gt;Copy&lt;/code&gt; 相同的任务。</target>
        </trans-unit>
        <trans-unit id="83e158e3d2e5e26c76384dd26a124614ad844a55" translate="yes" xml:space="preserve">
          <source>You can derive &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(Hash)]&lt;/code&gt; if all fields implement &lt;code&gt;Hash&lt;/code&gt;. The resulting hash will be the combination of the values from calling &lt;a href=&quot;#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="translated">你可以得到 &lt;code&gt;Hash&lt;/code&gt; 与 &lt;code&gt;#[derive(Hash)]&lt;/code&gt; 如果所有领域实现 &lt;code&gt;Hash&lt;/code&gt; 。产生的哈希将是每个字段上调用&lt;a href=&quot;#tymethod.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt;的值的组合。</target>
        </trans-unit>
        <trans-unit id="35be33ced6f0cfe471c698377e1d225ec13de67d" translate="yes" xml:space="preserve">
          <source>You can derive &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(Hash)]&lt;/code&gt; if all fields implement &lt;code&gt;Hash&lt;/code&gt;. The resulting hash will be the combination of the values from calling &lt;a href=&quot;trait.hash#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f5ee2dba48ae74f01f68800a38cc65446beed5" translate="yes" xml:space="preserve">
          <source>You can disambiguate a single-element tuple from a value in parentheses with a comma:</source>
          <target state="translated">你可以用逗号从括号中的值中分离出一个单元素元组。</target>
        </trans-unit>
        <trans-unit id="858139efb135decf30543ab94bffe38f904b8030" translate="yes" xml:space="preserve">
          <source>You can even implement the &lt;code&gt;trait&lt;/code&gt; on the returned &lt;code&gt;enum&lt;/code&gt; so the callers &lt;em&gt;don't&lt;/em&gt; have to match on the returned value to invoke the associated items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835ac5995b1f731428fb2c278267c23aa6ba7d51" translate="yes" xml:space="preserve">
          <source>You can explicitly create a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;显式创建&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="460f3695c8c0bbab00464940a8f28d49f754cce3" translate="yes" xml:space="preserve">
          <source>You can explicitly create a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513e665187e52659901e2d139a691e98738bef9a" translate="yes" xml:space="preserve">
          <source>You can find more information about &lt;code&gt;derive&lt;/code&gt; in the &lt;a href=&quot;book/appendix-03-derivable-traits&quot;&gt;Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6b12bc4089e8eb8b5751f247a7b9589c2fe1f2" translate="yes" xml:space="preserve">
          <source>You can find more information about borrowing in the rust-book: http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</source>
          <target state="translated">你可以在生锈手册中找到更多关于借阅的信息:http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html。</target>
        </trans-unit>
        <trans-unit id="beb47d198b944a0ce4280dc360af7ef8ab346311" translate="yes" xml:space="preserve">
          <source>You can find more information about it in the &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/ffi-pure.html&quot;&gt;unstable Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2e5c62e0b55ad5028e27c25a79c338ab8a55a6" translate="yes" xml:space="preserve">
          <source>You can fix this error by finishing using the borrow before the next use of the value:</source>
          <target state="translated">你可以通过在下一次使用该值之前完成使用借款来解决这个错误。</target>
        </trans-unit>
        <trans-unit id="d8dd34acfc3bee0c9d744f723edecbf71221b97f" translate="yes" xml:space="preserve">
          <source>You can get more information about it in the &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-const.html&quot;&gt;unstable Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aedd4a29ecef931e15839bd3008e9ac572d334a" translate="yes" xml:space="preserve">
          <source>You can have multiple conditions by combining &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; in an &lt;code&gt;else if&lt;/code&gt; expression. For example:</source>
          <target state="translated">通过在 &lt;code&gt;else if&lt;/code&gt; 表达式中组合 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; ，可以具有多个条件。例如：</target>
        </trans-unit>
        <trans-unit id="b3c9603849c73d33443ee6a87ea7d3f7ea9f8eb7" translate="yes" xml:space="preserve">
          <source>You can implement &lt;code&gt;derive&lt;/code&gt; for your own traits through &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;procedural macros&lt;/a&gt;.</source>
          <target state="translated">您可以通过&lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;过程宏&lt;/a&gt;为自己的特征实现 &lt;code&gt;derive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87090e61475fabac741ebc244ff59fd41b674b51" translate="yes" xml:space="preserve">
          <source>You can instead use a single name for the argument:</source>
          <target state="translated">你可以用一个单一的名字来代替参数。</target>
        </trans-unit>
        <trans-unit id="b4e59a25eef48510bd25baeb9f2b6823ad86530a" translate="yes" xml:space="preserve">
          <source>You can look at these with the &lt;a href=&quot;#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">你可以看一下这些与&lt;a href=&quot;#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; 个&lt;/a&gt;和&lt;a href=&quot;#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;的方法：</target>
        </trans-unit>
        <trans-unit id="93493631ee602e503ac1e5a81f1088e2a4d7a4c8" translate="yes" xml:space="preserve">
          <source>You can look at these with the &lt;a href=&quot;../primitive.str#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.string#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.string#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae6e1835d66f2c10d701af8aff316c93ab9ceb1" translate="yes" xml:space="preserve">
          <source>You can move elements out of an array with a &lt;a href=&quot;../reference/patterns#slice-patterns&quot;&gt;slice pattern&lt;/a&gt;. If you want one element, see &lt;a href=&quot;mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f474815df87597604ccec4f0ca97d0a759dc6f35" translate="yes" xml:space="preserve">
          <source>You can move elements out of an array with a slice pattern. If you want one element, see &lt;a href=&quot;mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以使用切片模式将元素移出数组。如果需要一个元素，请参见&lt;a href=&quot;mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5486362126d64ce78e34e75e353c7473a5182e9a" translate="yes" xml:space="preserve">
          <source>You can only define an inherent implementation for a type in the same crate where the type was defined. For example, an &lt;code&gt;impl&lt;/code&gt; block as above is not allowed since &lt;code&gt;Vec&lt;/code&gt; is defined in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c186f63e5510473d9dc9b0dc2a5406c5f9eb96" translate="yes" xml:space="preserve">
          <source>You can only define an inherent implementation for a type in the same crate where the type was defined. For example, an &lt;code&gt;impl&lt;/code&gt; block as below is not allowed since &lt;code&gt;Vec&lt;/code&gt; is defined in the standard library:</source>
          <target state="translated">您只能在定义该类型的同一板条箱中为该类型定义一个固有实现。例如，由于 &lt;code&gt;Vec&lt;/code&gt; 是在标准库中定义的，因此不允许以下 &lt;code&gt;impl&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="b467f8c108bab6da931f53e1d1208fd735b37f94" translate="yes" xml:space="preserve">
          <source>You can only implement &lt;code&gt;Copy&lt;/code&gt; for a struct or an enum. Both of the previous examples will fail, because neither &lt;code&gt;[u8; 256]&lt;/code&gt; nor &lt;code&gt;&amp;amp;'static mut Bar&lt;/code&gt; (mutable reference to &lt;code&gt;Bar&lt;/code&gt;) is a struct or enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c813be92d22e2d7b242da8356e7fcb13fc363191" translate="yes" xml:space="preserve">
          <source>You can only implement &lt;code&gt;Copy&lt;/code&gt; for a struct or enum. Both of the following examples will fail, because neither &lt;code&gt;[u8; 256]&lt;/code&gt; nor &lt;code&gt;&amp;amp;'static mut Bar&lt;/code&gt; (mutable reference to &lt;code&gt;Bar&lt;/code&gt;) is a struct or enum:</source>
          <target state="translated">您只能为结构或枚举实现 &lt;code&gt;Copy&lt;/code&gt; 。以下两个示例都将失败，因为 &lt;code&gt;[u8; 256]&lt;/code&gt; nor &lt;code&gt;&amp;amp;'static mut Bar&lt;/code&gt; （对 &lt;code&gt;Bar&lt;/code&gt; 的可变引用）是一个结构或枚举：</target>
        </trans-unit>
        <trans-unit id="21f8b607f72c57127cd998f4d58d658ea39f8468" translate="yes" xml:space="preserve">
          <source>You can only make &lt;em&gt;object-safe&lt;/em&gt; traits into trait objects. Some complex rules govern all the properties that make a trait object safe, but in practice, only two rules are relevant. A trait is object safe if all the methods defined in the trait have the following properties:</source>
          <target state="translated">您只能将&lt;em&gt;对象安全的&lt;/em&gt;特征变成特征对象。一些复杂的规则控制使特质对象安全的所有属性，但实际上，只有两个规则是相关的。如果特征中定义的所有方法都具有以下属性，则特征是对象安全的：</target>
        </trans-unit>
        <trans-unit id="d710b72f224f5678a735cd21bec78fffa991073c" translate="yes" xml:space="preserve">
          <source>You can override any default setting by adding a different value for it in &lt;em&gt;Cargo.toml&lt;/em&gt;. For example, if we want to use optimization level 1 in the development profile, we can add these two lines to our project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file:</source>
          <target state="translated">您可以通过在&lt;em&gt;Cargo.toml&lt;/em&gt;中&lt;em&gt;为其&lt;/em&gt;添加不同的值来覆盖任何默认设置。例如，如果要在开发配置文件中使用优化级别1，可以将以下两行添加到项目的&lt;em&gt;Cargo.toml&lt;/em&gt;文件中：</target>
        </trans-unit>
        <trans-unit id="1a0d0b5c07f4a3701b975bfae52379a7cc4a0a95" translate="yes" xml:space="preserve">
          <source>You can read more about cell types in the API documentation:</source>
          <target state="translated">你可以在API文档中阅读更多关于单元格类型的信息。</target>
        </trans-unit>
        <trans-unit id="49f14d85beebdc2ce97fddebb0687041307b1cc2" translate="yes" xml:space="preserve">
          <source>You can read more about trait objects in the &lt;a href=&quot;reference/types#trait-objects&quot;&gt;Trait Objects&lt;/a&gt; section of the Reference.</source>
          <target state="translated">您可以在参考的&amp;ldquo; &lt;a href=&quot;reference/types#trait-objects&quot;&gt;特质对象&amp;rdquo;&lt;/a&gt;部分中了解有关特征对象的更多信息。</target>
        </trans-unit>
        <trans-unit id="9712625e55ae109f55059c67a65fb7d3fbaccdbb" translate="yes" xml:space="preserve">
          <source>You can read more in the API documentation for &lt;a href=&quot;std/cell/index&quot;&gt;Cell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d319729d74877014e187c2ba127457ae956cdc" translate="yes" xml:space="preserve">
          <source>You can run the example one of two ways:</source>
          <target state="translated">你可以用两种方式运行这个例子。</target>
        </trans-unit>
        <trans-unit id="63366b6e44f5163c78736c2914a78fd15427bd3a" translate="yes" xml:space="preserve">
          <source>You can see all of the &lt;em&gt;toolchains&lt;/em&gt; (releases of Rust and associated components) you have installed with &lt;code&gt;rustup&lt;/code&gt; as well. Here&amp;rsquo;s an example on one of your authors&amp;rsquo; Windows computer:</source>
          <target state="translated">您还可以查看通过 &lt;code&gt;rustup&lt;/code&gt; 安装的所有&lt;em&gt;工具链&lt;/em&gt;（Rust和相关组件的发行版）。这是您的作者的一台Windows计算机上的示例：</target>
        </trans-unit>
        <trans-unit id="9ad8bdb0d1d5a61388700f692f73fc4d634ea4d8" translate="yes" xml:space="preserve">
          <source>You can see how primitive our server is: real libraries would handle the recognition of multiple requests in a much less verbose way!</source>
          <target state="translated">你可以看到我们的服务器是多么的原始:真正的库会以一种不那么啰嗦的方式处理多个请求的识别。</target>
        </trans-unit>
        <trans-unit id="ef181677ddc6f3265ea6a87f49632fa9f1210138" translate="yes" xml:space="preserve">
          <source>You can see that &lt;code&gt;if let&lt;/code&gt; can also introduce shadowed variables in the same way that &lt;code&gt;match&lt;/code&gt; arms can: the line &lt;code&gt;if let Ok(age) = age&lt;/code&gt; introduces a new shadowed &lt;code&gt;age&lt;/code&gt; variable that contains the value inside the &lt;code&gt;Ok&lt;/code&gt; variant. This means we need to place the &lt;code&gt;if age &amp;gt; 30&lt;/code&gt; condition within that block: we can&amp;rsquo;t combine these two conditions into &lt;code&gt;if let Ok(age) = age &amp;amp;&amp;amp; age &amp;gt; 30&lt;/code&gt;. The shadowed &lt;code&gt;age&lt;/code&gt; we want to compare to 30 isn&amp;rsquo;t valid until the new scope starts with the curly bracket.</source>
          <target state="translated">您可以看到 &lt;code&gt;if let&lt;/code&gt; 也可以像 &lt;code&gt;match&lt;/code&gt; 武器一样引入影子变量： &lt;code&gt;if let Ok(age) = age&lt;/code&gt; 引入了一个新的影子 &lt;code&gt;age&lt;/code&gt; 变量，该变量包含 &lt;code&gt;Ok&lt;/code&gt; 变量内的值。这意味着我们需要将 &lt;code&gt;if age &amp;gt; 30&lt;/code&gt; 条件放置在该块中： &lt;code&gt;if let Ok(age) = age &amp;amp;&amp;amp; age &amp;gt; 30&lt;/code&gt; 则不能将这两个条件组合在一起。在新作用域以大括号开头之前，我们要比较的30 &lt;code&gt;age&lt;/code&gt; 阴影年龄无效。</target>
        </trans-unit>
        <trans-unit id="6dac8a60a46917dc69183323e9ca6b9442311d9e" translate="yes" xml:space="preserve">
          <source>You can see that the second rule doesn&amp;rsquo;t apply because there is more than one input lifetime. The third rule doesn&amp;rsquo;t apply either, because &lt;code&gt;longest&lt;/code&gt; is a function rather than a method, so none of the parameters are &lt;code&gt;self&lt;/code&gt;. After working through all three rules, we still haven&amp;rsquo;t figured out what the return type&amp;rsquo;s lifetime is. This is why we got an error trying to compile the code in Listing 10-21: the compiler worked through the lifetime elision rules but still couldn&amp;rsquo;t figure out all the lifetimes of the references in the signature.</source>
          <target state="translated">您会看到第二条规则不适用，因为存在多个输入生命周期。第三条规则也不适用，因为 &lt;code&gt;longest&lt;/code&gt; 是函数而不是方法，因此所有参数都不是 &lt;code&gt;self&lt;/code&gt; 。在完成所有三个规则后，我们仍然没有弄清楚返回类型的生存期是多少。这就是为什么我们在尝试编译清单10-21中的代码时会出错：编译器通过了生存期省略规则，但仍然无法找出签名中引用的所有生存期。</target>
        </trans-unit>
        <trans-unit id="0e4d508ac715cc3acbfdf122afbf7b9a03cd0107" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; as being a bit like &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; but without any of the run-time tracking and without any of the safety checks.</source>
          <target state="translated">您可以认为 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 有点像 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 但没有任何运行时跟踪，也没有任何安全检查。</target>
        </trans-unit>
        <trans-unit id="1f606e05dadc0999f11ab48116c48743386a6126" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;flat_map(f)&lt;/code&gt; as the semantic equivalent of &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;ping, and then &lt;a href=&quot;#method.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt;ing as in &lt;code&gt;map(f).flatten()&lt;/code&gt;.</source>
          <target state="translated">您可以将 &lt;code&gt;flat_map(f)&lt;/code&gt; 视为&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; ping 的语义等效项，然后像 &lt;code&gt;map(f).flatten()&lt;/code&gt; 一样进行&lt;a href=&quot;#method.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a9642a3aa6b0d4f644c74448c6eb12a20876d4a" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;flat_map(f)&lt;/code&gt; as the semantic equivalent of &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;ping, and then &lt;a href=&quot;trait.iterator#method.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt;ing as in &lt;code&gt;map(f).flatten()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b8c98aafd60cb333f24479704313af8e17f2d7" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; to build up a &lt;code&gt;PathBuf&lt;/code&gt; from components:</source>
          <target state="translated">您可以使用&lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;从组件构建 &lt;code&gt;PathBuf&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="79c504057bc14c1c72ecffa07908c9acfa0c3808" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; to implement &quot;out-pointers&quot;: instead of returning data from a function, pass it a pointer to some (uninitialized) memory to put the result into. This can be useful when it is important for the caller to control how the memory the result is stored in gets allocated, and you want to avoid unnecessary moves.</source>
          <target state="translated">您可以使用 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 来实现&amp;ldquo;指针外&amp;rdquo;：与其从函数返回数据，还不如将一个指针传递给某个（未初始化的）内存以将结果放入其中。当对调用方来说，控制结果存储在内存中的分配方式很重要并且您希望避免不必要的移动时，这很有用。</target>
        </trans-unit>
        <trans-unit id="f06b12f9f33805451b03aa1619046a91b1f0fea9" translate="yes" xml:space="preserve">
          <source>You can use a &lt;a href=&quot;../reference/patterns#slice-patterns&quot;&gt;slice pattern&lt;/a&gt; to move elements out of an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ef701adf9c3ff21ed219e1e0f0ea149a4acfce" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;repr&lt;/code&gt; attribute to tell the compiler how you want a struct or enum to be laid out in memory.</source>
          <target state="translated">您可以使用 &lt;code&gt;repr&lt;/code&gt; 属性来告诉编译器如何将结构或枚举布局在内存中。</target>
        </trans-unit>
        <trans-unit id="1b34b5e340a342b7c6e66a1c66e9ad2f86e01083" translate="yes" xml:space="preserve">
          <source>You can use a slice pattern to move elements out of an array:</source>
          <target state="translated">你可以使用分片模式从数组中移出元素。</target>
        </trans-unit>
        <trans-unit id="8525d6891c1f3e5f989dbf3ba87c59b3e77658c4" translate="yes" xml:space="preserve">
          <source>You can use aliases in order to fix this error. Example:</source>
          <target state="translated">你可以使用别名来解决这个错误。例子:</target>
        </trans-unit>
        <trans-unit id="fc67eb4f6c079f25d4b841983f28617d8c247116" translate="yes" xml:space="preserve">
          <source>You can use code specified in a &lt;code&gt;Drop&lt;/code&gt; trait implementation in many ways to make cleanup convenient and safe: for instance, you could use it to create your own memory allocator! With the &lt;code&gt;Drop&lt;/code&gt; trait and Rust&amp;rsquo;s ownership system, you don&amp;rsquo;t have to remember to clean up because Rust does it automatically.</source>
          <target state="translated">您可以通过多种方式使用 &lt;code&gt;Drop&lt;/code&gt; trait实现中指定的代码，以使清理变得既方便又安全：例如，您可以使用它来创建自己的内存分配器！使用 &lt;code&gt;Drop&lt;/code&gt; 特性和Rust的所有权系统，您不必记住要清理，因为Rust会自动进行清理。</target>
        </trans-unit>
        <trans-unit id="4f312fe97d3268cd00fae0b76a4dae32c526dd97" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt; method to get an &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; from an &lt;code&gt;OsString&lt;/code&gt;; this is effectively a borrowed reference to the whole string.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; &lt;/a&gt;方法获取 &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;从 &lt;code&gt;OsString&lt;/code&gt; ; 这实际上是对整个字符串的借用引用。</target>
        </trans-unit>
        <trans-unit id="1323a49e0cb97eec61d0dde3434ccf676cf86d24" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt; value that &lt;code&gt;format_args!&lt;/code&gt; returns in &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; contexts as seen below. The example also shows that &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; format to the same thing: the interpolated format string in &lt;code&gt;format_args!&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;format_args!&lt;/code&gt; 的&lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;值！返回 &lt;code&gt;Debug&lt;/code&gt; 和 &lt;code&gt;Display&lt;/code&gt; 上下文，如下所示。该示例还显示了 &lt;code&gt;Debug&lt;/code&gt; 和 &lt;code&gt;Display&lt;/code&gt; 格式的 &lt;code&gt;format_args!&lt;/code&gt; 的插补格式字符串！。</target>
        </trans-unit>
        <trans-unit id="fa54acb48af4602e2f37053a7c14e129065a9bd7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;struct.osstring#method.as_os_str&quot;&gt;&lt;code&gt;OsString::as_os_str&lt;/code&gt;&lt;/a&gt; method to get an &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; from an &lt;code&gt;OsString&lt;/code&gt;; this is effectively a borrowed reference to the whole string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f9328d191cf1a4e8041c2b20ff6e3d44a4dd7e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Arguments&amp;lt;'a&amp;gt;&lt;/code&gt; that &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; returns in &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; contexts as seen below. The example also shows that &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; format to the same thing: the interpolated format string in &lt;code&gt;format_args!&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;Arguments&amp;lt;'a&amp;gt;&lt;/code&gt; 是&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;Debug&lt;/code&gt; 和 &lt;code&gt;Display&lt;/code&gt; 上下文，如下所示。该示例还显示了 &lt;code&gt;Debug&lt;/code&gt; 和 &lt;code&gt;Display&lt;/code&gt; 格式的 &lt;code&gt;format_args!&lt;/code&gt; 的插补格式字符串！。</target>
        </trans-unit>
        <trans-unit id="a0d2c3ab842592962de40df3105ee889292b2624" translate="yes" xml:space="preserve">
          <source>You can write integer literals in any of the forms shown in Table 3-2. Note that all number literals except the byte literal allow a type suffix, such as &lt;code&gt;57u8&lt;/code&gt;, and &lt;code&gt;_&lt;/code&gt; as a visual separator, such as &lt;code&gt;1_000&lt;/code&gt;.</source>
          <target state="translated">您可以用表3-2中所示的任何形式编写整数文字。请注意，除了字节文字外，所有数字文字都允许使用类型后缀（例如 &lt;code&gt;57u8&lt;/code&gt; ）和 &lt;code&gt;_&lt;/code&gt; 作为可视分隔符（例如 &lt;code&gt;1_000&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="7e3a6a5d5ad9495618c32d7df9601c8b0c36186e" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use the &lt;code&gt;#[should_panic]&lt;/code&gt; annotation on tests that use &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. Instead, you should return an &lt;code&gt;Err&lt;/code&gt; value directly when the test should fail.</source>
          <target state="translated">在使用 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 测试中，不能使用 &lt;code&gt;#[should_panic]&lt;/code&gt; 批注。相反，您应该在测试失败时直接返回 &lt;code&gt;Err&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="68b6d283a51fc88197c307fe06aa87e325990277" translate="yes" xml:space="preserve">
          <source>You can't import a type or module when the name of the item being imported is the same as another type or submodule defined in the module.</source>
          <target state="translated">当导入的项目名称与模块中定义的另一个类型或子模块名称相同时,您不能导入一个类型或模块。</target>
        </trans-unit>
        <trans-unit id="f50f1788e3104b1887e0fe5929d8e14061698fab" translate="yes" xml:space="preserve">
          <source>You can't import a value whose name is the same as another value defined in the module.</source>
          <target state="translated">您不能导入一个与模块中定义的其他值名称相同的值。</target>
        </trans-unit>
        <trans-unit id="9a643c6311bbc95c59da6d6b04e51680a574a830" translate="yes" xml:space="preserve">
          <source>You can't use type or const parameters on foreign items. Example of erroneous code:</source>
          <target state="translated">你不能在外来项目上使用类型或const参数。错误代码的例子。</target>
        </trans-unit>
        <trans-unit id="eeb5e1b278da97fda2cc8bf3325f0cdbbec2f73d" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;Drop::drop&lt;/code&gt; yourself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe58ca7fd87be4f97f1122198ed215b1d16ba8fe" translate="yes" xml:space="preserve">
          <source>You cannot define a struct (or enum) &lt;code&gt;Foo&lt;/code&gt; that requires an instance of &lt;code&gt;Foo&lt;/code&gt; in order to make a new &lt;code&gt;Foo&lt;/code&gt; value. This is because there would be no way a first instance of &lt;code&gt;Foo&lt;/code&gt; could be made to initialize another instance!</source>
          <target state="translated">您不能定义需要 &lt;code&gt;Foo&lt;/code&gt; 实例才能产生新 &lt;code&gt;Foo&lt;/code&gt; 值的结构（或枚举） &lt;code&gt;Foo&lt;/code&gt; 。这是因为不可能将 &lt;code&gt;Foo&lt;/code&gt; 的第一个实例初始化为另一个实例！</target>
        </trans-unit>
        <trans-unit id="1777ac4e29f5cc4458b21aa65a1d164c32783aad" translate="yes" xml:space="preserve">
          <source>You cannot implement both &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Drop&lt;/code&gt; on the same type. Types that are &lt;code&gt;Copy&lt;/code&gt; get implicitly duplicated by the compiler, making it very hard to predict when, and how often destructors will be executed. As such, these types cannot have destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d56e44b75bd82612a5c898ab88640b149ae542f" translate="yes" xml:space="preserve">
          <source>You cannot import the current module into itself, please remove this import or verify you didn't misspell it.</source>
          <target state="translated">您无法将当前模块导入自身,请删除此导入或确认您没有拼错。</target>
        </trans-unit>
        <trans-unit id="9637aa7070b2e9b906188f375ead424b0ed1d4bf" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;.assume_init_mut()&lt;/code&gt; to initialize a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4886cf84f3f70749a96d8b14082b6bb665ea1eb" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; hints on a same type. If you want to pack a type to a given size, you should provide a size to packed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e29ffbaea7cbfa903117ea4f8c302e21bcc69bf" translate="yes" xml:space="preserve">
          <source>You cannot use conflicting &lt;code&gt;packed&lt;/code&gt; hints on a same type. If you want to pack a type to a given size, you should provide a size to packed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e46b0f9b1886a75845894deaafd475e2954540" translate="yes" xml:space="preserve">
          <source>You cannot use type or const parameters on foreign items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8026aeec168d950d49b1d853d7fb5eccbde596" translate="yes" xml:space="preserve">
          <source>You choose inheritance for two main reasons. One is for reuse of code: you can implement particular behavior for one type, and inheritance enables you to reuse that implementation for a different type. You can share Rust code using default trait method implementations instead, which you saw in Listing 10-14 when we added a default implementation of the &lt;code&gt;summarize&lt;/code&gt; method on the &lt;code&gt;Summary&lt;/code&gt; trait. Any type implementing the &lt;code&gt;Summary&lt;/code&gt; trait would have the &lt;code&gt;summarize&lt;/code&gt; method available on it without any further code. This is similar to a parent class having an implementation of a method and an inheriting child class also having the implementation of the method. We can also override the default implementation of the &lt;code&gt;summarize&lt;/code&gt; method when we implement the &lt;code&gt;Summary&lt;/code&gt; trait, which is similar to a child class overriding the implementation of a method inherited from a parent class.</source>
          <target state="translated">选择继承有两个主要原因。一种是代码的重用：您可以为一种类型实现特定的行为，而继承使您可以为另一种类型重用该实现。你可以使用默认的特征的方法实现，而不是分享锈代码，您清单10-14中所看到的，当我们添加的默认实现 &lt;code&gt;summarize&lt;/code&gt; 的方法 &lt;code&gt;Summary&lt;/code&gt; 特点。任何实现 &lt;code&gt;Summary&lt;/code&gt; 特征的类型都可以使用 &lt;code&gt;summarize&lt;/code&gt; 方法，而无需任何其他代码。这类似于具有方法实现的父类和具有方法实现的继承子类。我们还可以覆盖 &lt;code&gt;summarize&lt;/code&gt; 的默认实现当我们实现 &lt;code&gt;Summary&lt;/code&gt; 特性时，此方法类似于子类，该子类重写了从父类继承的方法的实现。</target>
        </trans-unit>
        <trans-unit id="6eab2426d653eb63791cf922c9fd68c2cf3cc300" translate="yes" xml:space="preserve">
          <source>You could use the &lt;code&gt;while&lt;/code&gt; construct to loop over the elements of a collection, such as an array. For example, let&amp;rsquo;s look at Listing 3-4.</source>
          <target state="translated">您可以使用 &lt;code&gt;while&lt;/code&gt; 构造来遍历集合的元素，例如数组。例如，让我们看一下清单3-4。</target>
        </trans-unit>
        <trans-unit id="86305ea7dfbd655b97c9fe7b48a6cfa736ccdc12" translate="yes" xml:space="preserve">
          <source>You declare constants using the &lt;code&gt;const&lt;/code&gt; keyword instead of the &lt;code&gt;let&lt;/code&gt; keyword, and the type of the value &lt;em&gt;must&lt;/em&gt; be annotated. We&amp;rsquo;re about to cover types and type annotations in the next section, &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types,&amp;rdquo;&lt;/a&gt; so don&amp;rsquo;t worry about the details right now. Just know that you must always annotate the type.</source>
          <target state="translated">您可以使用 &lt;code&gt;const&lt;/code&gt; 关键字而不是 &lt;code&gt;let&lt;/code&gt; 关键字声明常量，并且值的类型&lt;em&gt;必须&lt;/em&gt;带有注释。我们将在下一节&lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;数据类型&amp;rdquo;中&lt;/a&gt;介绍类型和类型注释，所以现在不必担心细节。只知道您必须始终对类型进行注释。</target>
        </trans-unit>
        <trans-unit id="d26c982256875ef965abb7ff2a9ae7d6d8262fa1" translate="yes" xml:space="preserve">
          <source>You declared a pattern as an argument in a foreign function declaration. Erroneous code example:</source>
          <target state="translated">你在一个外来函数声明中声明了一个模式作为参数。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="3042e33d1a35dfe59f3b5a52b534fe5ccd3ab130" translate="yes" xml:space="preserve">
          <source>You declared an unknown intrinsic function. Erroneous code example:</source>
          <target state="translated">你声明了一个未知的固有函数。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="209c4b82ebb79e610fb7da013287d442d9de7ccc" translate="yes" xml:space="preserve">
          <source>You declared two fields of a struct with the same name. Erroneous code example:</source>
          <target state="translated">你在一个结构中声明了两个同名的字段。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="5681291083d07044a63476be05813904d873a94e" translate="yes" xml:space="preserve">
          <source>You gave an invalid number of type parameters to an intrinsic function. Erroneous code example:</source>
          <target state="translated">你给固有函数的类型参数数量无效。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="73e529ed83de9dd32d08048f27abd6e18e54d03b" translate="yes" xml:space="preserve">
          <source>You gave an unnecessary type or const parameter in a type alias. Erroneous code example:</source>
          <target state="translated">你在类型别名中给出了一个不必要的类型或const参数。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="ef290be095bc0ac42be01bd488ced06e1f432faa" translate="yes" xml:space="preserve">
          <source>You gave too few lifetime arguments. Example:</source>
          <target state="translated">你给的终身论证太少了。例如:</target>
        </trans-unit>
        <trans-unit id="3a992fb3e33f43f550919aa8e7cbe12bdd71799a" translate="yes" xml:space="preserve">
          <source>You gave too many lifetime arguments. Erroneous code example:</source>
          <target state="translated">你给了太多的终身参数。错误的代码例子。</target>
        </trans-unit>
        <trans-unit id="803a897636a53ddcd87076d162300ffab0d90307" translate="yes" xml:space="preserve">
          <source>You have to provide the same number of arguments as expected by the &lt;code&gt;Fn&lt;/code&gt;-based type. So to fix the previous example, we need to remove the &lt;code&gt;y&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8cdc3f699d29b35f63008d1337b75507d28ea4" translate="yes" xml:space="preserve">
          <source>You have two solutions:</source>
          <target state="translated">你有两个解决方案。</target>
        </trans-unit>
        <trans-unit id="9dce30760c2f61bac673b91333250ea52ecff835" translate="yes" xml:space="preserve">
          <source>You implemented a trait, overriding one or more of its associated types but did not reimplement its default methods.</source>
          <target state="translated">你实现了一个特质,覆盖了它的一个或多个关联类型,但没有重新实现它的默认方法。</target>
        </trans-unit>
        <trans-unit id="ca3b4cf5422aeae2f92f99806820d8c1b575cccd" translate="yes" xml:space="preserve">
          <source>You just want a set.</source>
          <target state="translated">你只是想要一套。</target>
        </trans-unit>
        <trans-unit id="693a8bb9813bf36c49860217c46ff78a91bebee4" translate="yes" xml:space="preserve">
          <source>You just want to remember which keys you've seen.</source>
          <target state="translated">你只是想记住你见过哪些钥匙。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
