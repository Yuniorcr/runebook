<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，则可以使用&lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，则可以使用&lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="translated">如果 &lt;code&gt;let&lt;/code&gt; 语句中的模式是扩展模式，则扩展初始化程序表达式的临时范围。</target>
        </trans-unit>
        <trans-unit id="973c0cc5d4929bc5f421c4d51b3af832d7dcc650" translate="yes" xml:space="preserve">
          <source>If the pattern is a slice of chars, split on each occurrence of any of the characters:</source>
          <target state="translated">如果模式是一个字符片,则在任何一个字符的每次出现时进行分割。</target>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">如果谓词为true，则将事物重写为不具有 &lt;code&gt;cfg&lt;/code&gt; 属性。如果谓词为假，则事物将从源代码中删除。</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">如果进程被一个信号终止,则返回该信号。</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">如果程序上下文过度限制类型,则认为是静态类型错误。</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">如果程序上下文对类型的约束不足，则默认为 &lt;code&gt;f64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">如果程序上下文对类型的约束不足，则默认为带符号的32位整数 &lt;code&gt;i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">如果程序路径是相对的（例如 &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ），则是相对于父级的工作目录还是相对于 &lt;code&gt;current_dir&lt;/code&gt; 来解释路径。这种情况下的行为是特定于平台且不稳定的，因此建议使用&lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt;来获取绝对程序路径。</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../../../macro.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">如果接收器的类型为 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; ，则将对 &lt;code&gt;Self&lt;/code&gt; 的引用的生存期分配给所有省略的输出生存期参数。</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">如果重复次数可以匹配零次（ &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; ），则后面的内容必须能够跟随之前的内容。</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">如果重复可以重复多次（ &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; ），则内容必须能够跟随自己。</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">如果重复包括一个分隔符,该分隔符必须能够跟随重复的内容。</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">如果这个方法的结果只是由产生它们的同一个架构来操作,那么就不存在可移植性问题。</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">如果返回值为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; ,&lt;/a&gt;则必须保证 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 。返回值 &lt;code&gt;0&lt;/code&gt; 通常表示基础对象不再能够接受字节，将来也可能无法接受字节，或者提供的缓冲区为空。</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">如果返回值为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; ,&lt;/a&gt;则必须保证 &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt; 。返回值 &lt;code&gt;0&lt;/code&gt; 通常表示基础对象不再能够接受字节，将来也可能无法接受字节，或者提供的缓冲区为空。</target>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">如果此方法的返回值为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt;，则必须保证 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 。 &lt;code&gt;n&lt;/code&gt; 值非零表示缓冲区 &lt;code&gt;buf&lt;/code&gt; 已被来自该源的 &lt;code&gt;n&lt;/code&gt; 个字节的数据填充。如果 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则可以指示以下两种情况之一：</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果查找操作成功完成，则此方法从流的开头返回新位置。该位置可以稍后与&lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">如果集合确实存在此值，则返回 &lt;code&gt;false&lt;/code&gt; ，并且不会更新该条目。有关更多信息，请参见&lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果集合确实存在此值，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果集合中不存在该值，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f392e4742f25190cbf5e3351752daf379a0be61" translate="yes" xml:space="preserve">
          <source>If the slice does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果切片的结尾不是 &lt;code&gt;suffix&lt;/code&gt; ，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d43a87008e53f4a6466f036fda4975d20f3ad011" translate="yes" xml:space="preserve">
          <source>If the slice does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果切片不是以 &lt;code&gt;prefix&lt;/code&gt; 开头，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ad3d774a6e0ccaa727d17e721cc10badd0ba8e6" translate="yes" xml:space="preserve">
          <source>If the slice ends with &lt;code&gt;suffix&lt;/code&gt;, returns the subslice before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;suffix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="translated">如果切片以 &lt;code&gt;suffix&lt;/code&gt; 结尾，则返回包裹在 &lt;code&gt;Some&lt;/code&gt; 中的后缀。如果 &lt;code&gt;suffix&lt;/code&gt; 为空，则仅返回原始切片。</target>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">如果切片比 &lt;code&gt;size&lt;/code&gt; 短：</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">如果分片是排序的,则第一个返回的分片不包含重复的内容。</target>
        </trans-unit>
        <trans-unit id="c27d8278e5200cca20b3d013d5698cf10c18fe2f" translate="yes" xml:space="preserve">
          <source>If the slice starts with &lt;code&gt;prefix&lt;/code&gt;, returns the subslice after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;prefix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="translated">如果切片以 &lt;code&gt;prefix&lt;/code&gt; 开头，则返回前缀在Sub之后的子切片，包装在 &lt;code&gt;Some&lt;/code&gt; 中。如果 &lt;code&gt;prefix&lt;/code&gt; 为空，则仅返回原始切片。</target>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">如果未连接套接字，则将返回&lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果源和目标&lt;em&gt;永远不会&lt;/em&gt;重叠，&lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt;可以使用copy_nonoverlapping代替。</target>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果源和目标&lt;em&gt;永远不会&lt;/em&gt;重叠，&lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt;可以使用copy_nonoverlapping。</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">如果字符串不以 &lt;code&gt;suffix&lt;/code&gt; 结尾，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00699a6c688425007189014e64bb10c087e7cc42" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果字符串不以 &lt;code&gt;suffix&lt;/code&gt; 结尾，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">如果字符串不是以 &lt;code&gt;prefix&lt;/code&gt; 开头，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4c5d3aa960799aefa6afdc31361ee8f07d50151" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果字符串不是以 &lt;code&gt;prefix&lt;/code&gt; 开头，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="translated">如果字符串以模式 &lt;code&gt;suffix&lt;/code&gt; 结尾，则将返回 &lt;code&gt;Some&lt;/code&gt; ，其中子后缀将被删除。与 &lt;code&gt;trim_end_matches&lt;/code&gt; 不同，此方法仅将后缀删除一次。</target>
        </trans-unit>
        <trans-unit id="73e6ef23293e24078530c7881fe300a2cd50dbd2" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, returns the substring before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="translated">如果字符串以模式 &lt;code&gt;suffix&lt;/code&gt; 结尾，则返回在后缀之前的子字符串，该子字符串包装在 &lt;code&gt;Some&lt;/code&gt; 中。与 &lt;code&gt;trim_end_matches&lt;/code&gt; 不同，此方法仅将后缀删除一次。</target>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="translated">如果字符串与模式开始 &lt;code&gt;prefix&lt;/code&gt; ， &lt;code&gt;Some&lt;/code&gt; 还附有前缀被删除的子字符串。与 &lt;code&gt;trim_start_matches&lt;/code&gt; 不同，此方法只删除一次前缀。</target>
        </trans-unit>
        <trans-unit id="b2971983ae4e5fda25d513b0c8f02476f9d89865" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, returns substring after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="translated">如果字符串以模式 &lt;code&gt;prefix&lt;/code&gt; 开头，则在前缀之后返回子字符串，并包装在 &lt;code&gt;Some&lt;/code&gt; 中。与 &lt;code&gt;trim_start_matches&lt;/code&gt; 不同，此方法只删除一次前缀。</target>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">如果超时为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">如果超时为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">如果特征 &lt;code&gt;Foo&lt;/code&gt; 源自 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; （其中 &lt;code&gt;Foo&lt;/code&gt; 本身是 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; ），那么这是可以的，因为给定类型 &lt;code&gt;get_a()&lt;/code&gt; 肯定会返回该类型的对象。</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">如果特征 &lt;code&gt;Trait&lt;/code&gt; 是从诸如 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; （其中 &lt;code&gt;Foo&lt;/code&gt; 本身是 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; ）之类的 &lt;code&gt;get_a()&lt;/code&gt; ，这是可以的，因为给定类型get_a（）肯定会返回该类型的对象。</target>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">如果特征没有生存期边界，则生存期可以在表达式中推断出来，并且在表达式之外是 &lt;code&gt;'static&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">如果特征是用单个生存期&lt;em&gt;绑定&lt;/em&gt;定义的，则使用该绑定。</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">如果特质对象被用作通用类型的类型参数,那么首先使用包含的类型来尝试推断一个约束。</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">如果指定了 &lt;code&gt;self&lt;/code&gt; 参数的类型，则限于以下类型之一：</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="translated">如果指定了 &lt;code&gt;self&lt;/code&gt; 参数的类型，则将其限制为解析为以下语法生成的类型的类型（其中 &lt;code&gt;'lt&lt;/code&gt; 表示任意生存期）：</target>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">如果错误地包含了类型参数,可以通过简单地删除类型参数来解决这个错误,如下图所示。</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">如果基础数据是&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt;应改为使用。</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">如果基础数据是&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.pin#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt;应改为使用。</target>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">如果基础数据是 &lt;code&gt;Unpin&lt;/code&gt; ， &lt;code&gt;Pin::get_mut&lt;/code&gt; 应改为使用。</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">如果底层文件系统不支持创建时间,返回值为0。</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">如果底层文件系统不支持最后访问时间,则返回值为0。</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">如果底层文件系统不支持最后一次写入时间,返回值为0。</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 的大小未定的尾部为：</target>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">如果用户指定了一个喜欢的颜色,这个颜色就是背景色。如果今天是星期二,背景色就是绿色。如果用户将自己的年龄指定为一个字符串,并且我们可以成功地将其解析为一个数字,那么根据数字的值,颜色是紫色或橙色。如果这些条件都不适用,则背景色为蓝色。</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">如果用户想要进行高强度的锻炼，则还有一些其他逻辑：如果应用程序生成的随机数的值恰好为3，则该应用程序将建议您休息和补水。否则，用户将基于复杂算法获得几分钟的运行时间。</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">如果必须先借入价值,然后再移动,可以尝试使用scoped block来限制借入的寿命。</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">如果该值必须被借用,可以尝试使用scoped block限制借用的寿命。</target>
        </trans-unit>
        <trans-unit id="f9c557d25b585efde62c6ddbcee6fee7ec33bf65" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">如果找到该值，则返回&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，其中包含匹配元素的索引。如果有多个匹配项，则可以返回任何一个匹配项。如果找不到该值，则返回&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;，其中包含在保留排序顺序的同时可以在其中插入匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">如果找到该值，则返回&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，其中包含匹配元素的索引。如果有多个匹配项，则可以返回任何一个匹配项。如果未找到该值，则返回&lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;，其中包含在保留排序顺序的同时可以在其中插入匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">如果找到该值，则返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，其中包含匹配元素的索引。如果有多个匹配项，则可以返回任何一个匹配项。如果找不到该值，则返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;，其中包含在保留排序顺序的同时可以在其中插入匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">如果找到该值，则返回&lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，其中包含匹配元素的索引。如果有多个匹配项，则可以返回任何一个匹配项。如果未找到该值，则返回&lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;，其中包含在保留排序顺序的同时可以在其中插入匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">如果找到该值，则返回&lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，其中包含匹配元素的索引。如果有多个匹配项，则可以返回任何一个匹配项。如果找不到该值，则返回&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;，其中包含在保留排序顺序的同时可以在其中插入匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果指定的值为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果指定的值为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">如果该值将在模式卫士中消耗,使用它的克隆不会移动它的所有权,所以代码有效。</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">如果向量是排序的,则会删除所有重复的内容。</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="translated">如果涉及多种类型，则您唯一希望与它们进行交互的方法是通过特征的接口，并且可以依靠动态分派是可以接受的，那么可以将&lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;特征对象&lt;/a&gt;与 &lt;code&gt;Box&lt;/code&gt; 或其他容器类型（如 &lt;code&gt;Rc&lt;/code&gt; 或 &lt;code&gt;Arc&lt;/code&gt; )一起使用：</target>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="translated">如果没有其他指向该分配的 &lt;code&gt;Rc&lt;/code&gt; 指针，则指向该分配的&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针将被取消关联。</target>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">如果没有其他指向该值的 &lt;code&gt;Rc&lt;/code&gt; 指针，则该值的&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针将被取消关联。</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">如果还有其他指向同一分配的 &lt;code&gt;Arc&lt;/code&gt; 或&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针，那么 &lt;code&gt;make_mut&lt;/code&gt; 将创建一个新分配并在内部值上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;以确保唯一的所有权。这也称为写时克隆。</target>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">如果还有其他指向同一值的 &lt;code&gt;Arc&lt;/code&gt; 或&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针，那么 &lt;code&gt;make_mut&lt;/code&gt; 将在内部值上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;以确保唯一的所有权。这也称为写时克隆。</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">如果还有其他指向同一分配的 &lt;code&gt;Rc&lt;/code&gt; 指针，那么 &lt;code&gt;make_mut&lt;/code&gt; 会将内部值&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;到一个新的分配中，以确保唯一的所有权。这也称为写时克隆。</target>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">如果还有其他 &lt;code&gt;Rc&lt;/code&gt; 指针指向相同的值，那么 &lt;code&gt;make_mut&lt;/code&gt; 将&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;内部值以确保唯一的所有权。这也称为写时克隆。</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">如果此条件变量上有阻塞的线程，则它将从其调用&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt;唤醒。不会以任何方式缓冲对 &lt;code&gt;notify_one&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">如果此条件变量上有阻塞的线程，则它将从其调用&lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt;唤醒。不会以任何方式缓冲对 &lt;code&gt;notify_one&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="b165be9cc0b432064e92ddc4e5e166f180e45c19" translate="yes" xml:space="preserve">
          <source>If there is a panic, the already cloned elements will be dropped.</source>
          <target state="translated">如果出现恐慌,已经克隆的元素将被丢弃。</target>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果涉及单个类型，则可以使用&lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt; &lt;code&gt;impl Trait&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">如果有一个来自包含类型的唯一绑定,那么这就是默认的</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">如果参数中恰好使用了一个寿命（是否消除），则将该寿命分配给&lt;em&gt;所有&lt;/em&gt;消除的输出寿命。</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">如果有多个来自包含类型的绑定,那么必须指定一个显式绑定。</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">如果没有数据附加到枚举的&lt;em&gt;任何&lt;/em&gt;变体，则可以直接选择和访问判别式。</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">如果在 &lt;code&gt;LineWriter&lt;/code&gt; 时缓冲区中仍然有部分行，它将刷新这些内容。</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;是通过&lt;a href=&quot;struct.error#method.last_os_error&quot;&gt; &lt;code&gt;last_os_error&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt; &lt;code&gt;from_raw_os_error&lt;/code&gt; 构造的&lt;/a&gt;，则此函数将返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;，否则将返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;是通过&lt;a href=&quot;struct.error#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;构造的，则此函数将返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;，否则将返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Error&lt;/code&gt; 是通过 &lt;code&gt;last_os_error&lt;/code&gt; 或 &lt;code&gt;from_raw_os_error&lt;/code&gt; 构造的，则此函数将返回 &lt;code&gt;Some&lt;/code&gt; ，否则将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Error&lt;/code&gt; 是通过 &lt;code&gt;new&lt;/code&gt; 构造的，则此函数将返回 &lt;code&gt;Some&lt;/code&gt; ，否则将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;char&lt;/code&gt; 没有小写字母映射，则迭代器将产生相同的 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;char&lt;/code&gt; 没有大写映射，则迭代器将产生相同的 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;char&lt;/code&gt; 具有&lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode字符数据库&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; &lt;/a&gt;给出的一对一小写映射，则迭代器将产生该 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;char&lt;/code&gt; 具有&lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode字符数据库&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; &lt;/a&gt;给出的一对一的大写映射，则迭代器将产生该 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;char&lt;/code&gt; 需要特殊考虑（例如，多个 &lt;code&gt;char&lt;/code&gt; ），则迭代器将产生&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt;给出的 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">如果本章引起了您的兴趣，并且您想实现自己的智能指针，请查看&lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo; The Rustonomicon&amp;rdquo;&lt;/a&gt;以获取更多有用的信息。</target>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">如果本章引起了您的兴趣，并且您想实现自己的智能指针，请查看&lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo; The Rustonomicon&amp;rdquo;&lt;/a&gt;以获取更多有用的信息。</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">如果此函数在完全填充缓冲区之前遇到&amp;ldquo;文件末尾&amp;rdquo;，它将返回&lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;类型的错误。在这种情况下，未指定 &lt;code&gt;buf&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">如果此函数在完全填充缓冲区之前遇到&amp;ldquo;文件末尾&amp;rdquo;，它将返回&lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;类型的错误。在这种情况下，未指定 &lt;code&gt;buf&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">如果此函数在完全填充缓冲区之前遇到&amp;ldquo;文件末尾&amp;rdquo;，它将返回&lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;类型的错误。在这种情况下，未指定 &lt;code&gt;buf&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">如果此函数遇到类型为&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;的错误，则将忽略该错误，并且该操作将继续。</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">如果此函数遇到类型为&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;的错误，则将忽略该错误，并且该操作将继续。</target>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">如果此函数遇到类型为&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;的错误，则将忽略该错误，并且该操作将继续。</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">如果这个函数遇到任何形式的I/O或其他错误,将返回一个错误变量。如果返回一个错误,那么必须保证没有读取任何字节。</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="translated">如果此函数返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;，则流已达到EOF。</target>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">如果此函数返回 &lt;code&gt;Ok(0)&lt;/code&gt; ，则流已达到EOF。</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">如果该函数返回错误,则未说明它读取了多少字节,但它读取的字节数绝不会超过完全填满缓冲区所需的数量。</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">如果这是一个缓冲通道，则此时缓冲区已满。如果这不是缓冲通道，则没有&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;可用于获取数据。</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">如果这不是一个选择，请考虑将type参数替换为另一个特征对象（例如，如果 &lt;code&gt;T: OtherTrait&lt;/code&gt; ，请使用 &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; ）。如果打算提供给该方法的类型数量有限，请考虑手动列出不同类型的方法。</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">如果你是第一次来,标准库的文档是写给你随意浏览的。点击有趣的东西,一般来说应该会把你带到有趣的地方。不过,有些重要的部分你还是不要错过,所以请继续阅读标准库和它的文档之旅吧!</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">如果此方法返回 &lt;code&gt;Err&lt;/code&gt; ，则该存储块的所有权尚未转移到此分配器，并且该存储块的内容不会更改。</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">如果此方法返回 &lt;code&gt;Ok(addr)&lt;/code&gt; ，则返回的 &lt;code&gt;addr&lt;/code&gt; 将是非空地址，该地址指向适合于保存 &lt;code&gt;layout&lt;/code&gt; 实例的存储块。</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">如果这个方法返回null,那么内存块的所有权还没有转移到这个分配器上,内存块的内容没有被改变。</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">如果这导致多个可能的候选者，那么这是一个错误，并且必须将接收方&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;转换&lt;/a&gt;为适当的接收方类型以进行方法调用。</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">如果返回 &lt;code&gt;Err&lt;/code&gt; ，则认为该存储块仍表示原始（较大） &lt;code&gt;layout&lt;/code&gt; 。没有一个块被分割出来供其他地方重用，该存储块的所有权尚未转移，并且该存储块的内容未更改。</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">如果返回 &lt;code&gt;Ok&lt;/code&gt; ，则 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块的所有权已转移到此分配器。内存可能已释放，也可能尚未释放，应被视为不可用（除非通过此方法的返回值再次将其转移回调用方）。</target>
        </trans-unit>
        <trans-unit id="d418fdb16ac3dec6f2998c32246199d93bd8ccd1" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</source>
          <target state="translated">如果返回 &lt;code&gt;Ok&lt;/code&gt; ，则 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块的所有权已转移到此分配器。内存可能已释放，也可能尚未释放，除非已通过此方法的返回值再次将其转移回调用方，否则应将其视为不可用。</target>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">如果返回 &lt;code&gt;Ok&lt;/code&gt; ，则分配器断言 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块现在适合 &lt;code&gt;new_size&lt;/code&gt; ，因此可用于承载具有该大小且与 &lt;code&gt;layout&lt;/code&gt; 对齐的布局数据。（允许分配器花费更多的精力来完成此任务，例如将内存块扩展为包括后继块或虚拟内存技巧。）</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">如果返回 &lt;code&gt;Ok&lt;/code&gt; ，则分配器断言 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块现在适合 &lt;code&gt;new_size&lt;/code&gt; ，因此只能用于承载较小布局的数据。（允许分配器利用这一点，将块的一部分切掉，以便在其他地方重用。）较小布局中的块的截断内容未更改，并且块的所有权尚未转移。</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">如果返回非空指针，则 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块的所有权已转移到此分配器。内存可能已释放，也可能尚未释放，应将其视为不可用的（除非当然已通过此方法的返回值再次将其转移回调用方）。</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">如果返回非空指针，则 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块的所有权已转移到此分配器。内存可能已释放，也可能尚未释放，应将其视为不可用的（当然，除非通过此方法的返回值再次将其转移回调用方）。新的内存块分配有 &lt;code&gt;layout&lt;/code&gt; ，但 &lt;code&gt;size&lt;/code&gt; 已更新为 &lt;code&gt;new_size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="translated">如果这个分片没有分区,返回的结果是不指定的,没有意义,因为这个方法执行的是一种二进制搜索。</target>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果使用此语法，&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;打印的字符数要在要格式化的实际对象之前，并且字符数必须具有类型usize。</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果这会使 &lt;code&gt;Self&lt;/code&gt; 所支持的值范围溢出，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="translated">如果这会使 &lt;code&gt;Self&lt;/code&gt; 所支持的值范围溢出，则允许该函数惊慌，自动换行或饱和。建议的行为是在启用调试断言时会惊慌，否则会自动换行或饱和。</target>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">如果两个匹配的元素直接相邻,则它们之间会出现一个空片。</target>
        </trans-unit>
        <trans-unit id="aba72b6261d8cf54f8817ecf4602e9f657125528" translate="yes" xml:space="preserve">
          <source>If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.</source>
          <target state="translated">如果两个序列的元素相等,且长度相同,那么序列在词法上是相等的。</target>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">如果我们&lt;em&gt;确实&lt;/em&gt;想深入复制 &lt;code&gt;String&lt;/code&gt; 的堆数据，而不仅仅是堆栈数据，则可以使用一种称为 &lt;code&gt;clone&lt;/code&gt; 的通用方法。我们将在第5章中讨论方法语法，但是由于方法是许多编程语言中的常见功能，因此您以前可能已经看过它们。</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">如果我们现在编译此代码，则会收到此错误：</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">如果我们继续阅读错误，则会发现以下有用的注释：</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">如果我们控制类型的定义，则可以使用 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 在其上实现 &lt;code&gt;Clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">如果我们不在此处添加类型注释，Rust将显示以下错误，这意味着编译器需要我们提供更多信息来了解我们要使用的类型：</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">如果我们不想将 &lt;code&gt;largest&lt;/code&gt; 函数限制为实现 &lt;code&gt;Copy&lt;/code&gt; 特征的类型，则可以指定 &lt;code&gt;T&lt;/code&gt; 具有绑定 &lt;code&gt;Clone&lt;/code&gt; 的特征，而不是 &lt;code&gt;Copy&lt;/code&gt; 。然后，当我们希望 &lt;code&gt;largest&lt;/code&gt; 函数拥有所有权时，我们可以克隆切片中的每个值。使用 &lt;code&gt;clone&lt;/code&gt; 函数意味着，在拥有堆数据（如 &lt;code&gt;String&lt;/code&gt; )的类型的情况下，我们可能会进行更多的堆分配，如果处理大量数据，堆分配可能会很慢。</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">如果我们忘记了生命周期批注并尝试编译此函数，则会收到此错误：</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">如果我们获得了互斥锁，则调用 &lt;code&gt;recv&lt;/code&gt; 以从通道接收 &lt;code&gt;Job&lt;/code&gt; 。最终的 &lt;code&gt;unwrap&lt;/code&gt; 将移过所有错误，如果保留通道发送方的线程已关闭，则可能会发生错误，类似于在接收方关闭时 &lt;code&gt;send&lt;/code&gt; 方法返回 &lt;code&gt;Err&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">如果我们没有在程序开始时列出 &lt;code&gt;use std::io&lt;/code&gt; 行，则可以将此函数调用编写为 &lt;code&gt;std::io::stdin&lt;/code&gt; 。的 &lt;code&gt;stdin&lt;/code&gt; 函数返回的一个实例&lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt;，这是表示一个把手为您的终端标准输入一个类型。</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">如果我们没有在程序开始处 &lt;code&gt;use std::io&lt;/code&gt; 行，则可以将此函数调用编写为 &lt;code&gt;std::io::stdin&lt;/code&gt; 。的 &lt;code&gt;stdin&lt;/code&gt; 函数返回的一个实例&lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt;，这是表示一个把手为您的终端标准输入一个类型。</target>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">如果我们有更复杂的键，则调用 &lt;code&gt;insert&lt;/code&gt; 不会更新键的值。例如：</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个 &lt;code&gt;String&lt;/code&gt; ，我们可以传递整个 &lt;code&gt;String&lt;/code&gt; 的一部分。定义一个函数以采用字符串切片而不是对 &lt;code&gt;String&lt;/code&gt; 的引用使我们的API更通用和有用，而不会丢失任何功能：</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">如果我们将一个键和一个值插入到哈希图中，然后将相同的键插入一个不同的值，则与该键关联的值将被替换。即使清单8-24中的代码两次 &lt;code&gt;insert&lt;/code&gt; ，哈希表也将只包含一个键/值对，因为我们两次都插入了Blue团队键的值。</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">如果我们将对值的引用插入到哈希图中，则这些值将不会移入哈希图中。引用所指向的值必须至少在哈希映射有效期间才有效。我们将在第10章的&lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;使用生命周期验证参考&amp;rdquo;&lt;/a&gt;部分中详细讨论这些问题。</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">如果我们看一下Devanagari脚本中写的北印度语单词&amp;ldquo;नमस्غे&amp;rdquo;，它会存储为 &lt;code&gt;u8&lt;/code&gt; 值的向量，如下所示：</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">如果需要连接多个字符串，则 &lt;code&gt;+&lt;/code&gt; 运算符的行为会变得笨拙：</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">如果我们在不传递任何参数的情况下运行测试,就像我们前面看到的那样,所有的测试都会并行运行。</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">如果我们在没有&lt;em&gt;hello.txt&lt;/em&gt;文件的情况下运行此代码，则会从 &lt;code&gt;panic!&lt;/code&gt; 看到错误消息！调用 &lt;code&gt;unwrap&lt;/code&gt; 方法使：</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">如果我们运行这段代码,我们会得到这样的错误信息。</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">如果我们在调用 &lt;code&gt;takes_ownership&lt;/code&gt; 之后尝试使用 &lt;code&gt;s&lt;/code&gt; ，Rust会抛出编译时错误。这些静态检查可以防止我们犯错误。尝试将代码添加到使用 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;main&lt;/code&gt; 中，以查看可以在何处使用它们以及所有权规则阻止您这样做。</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">如果我们试图写 &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; 相反，我们会收到以下编译错误：</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">如果尝试在作用域结束后访问 &lt;code&gt;leaf&lt;/code&gt; 的父级，则将再次获得 &lt;code&gt;None&lt;/code&gt; 。在程序结束时， &lt;code&gt;leaf&lt;/code&gt; 的 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 的强计数为1，而弱计数为0，因为变量 &lt;code&gt;leaf&lt;/code&gt; 现在再次是对 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 的唯一引用。</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">如果尝试通过修改清单15-14中的 &lt;code&gt;main&lt;/code&gt; 函数来手动调用 &lt;code&gt;Drop&lt;/code&gt; trait的 &lt;code&gt;drop&lt;/code&gt; 方法，如清单15-15所示，则会出现编译器错误：</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">如果我们尝试编译清单15-3中的代码,得到清单15-4所示的错误。</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">如果我们尝试实现清单10-21所示的 &lt;code&gt;longest&lt;/code&gt; 函数，它将无法编译。</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">如果我们试图违反这些规则，而不是像使用引用那样遇到编译器错误，则 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 的实现将在运行时出现恐慌。清单15-23显示了清单15-22 中 &lt;code&gt;send&lt;/code&gt; 的实现的修改。我们故意尝试为同一作用域创建两个活动的活动借位，以说明 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 阻止我们在运行时执行此操作。</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">如果我们使用 &lt;code&gt;None&lt;/code&gt; 而不是 &lt;code&gt;Some&lt;/code&gt; ，则需要告诉Rust 我们拥有哪种 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 类型，因为编译器无法通过仅查看 &lt;code&gt;None&lt;/code&gt; 值来推断 &lt;code&gt;Some&lt;/code&gt; 变量将持有的类型。</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">如果我们要依次访问向量中的每个元素，则可以遍历所有元素，而不必一次使用索引来访问一个。清单8-8显示了如何使用 &lt;code&gt;for&lt;/code&gt; 循环获取对 &lt;code&gt;i32&lt;/code&gt; 值向量中每个元素的不可变引用并进行打印。</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">如果要将路径中定义的&lt;em&gt;所有&lt;/em&gt;公共项目&lt;em&gt;都&lt;/em&gt;纳入范围，可以指定该路径，后跟 &lt;code&gt;*&lt;/code&gt; ，即glob运算符：</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">如果我们也想查看通过测试的打印值，则可以使用 &lt;code&gt;--nocapture&lt;/code&gt; 标志来禁用输出捕获行为：</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="translated">如果我们也想查看通过测试的打印值，我们可以告诉Rust在最后用 &lt;code&gt;--show-output&lt;/code&gt; 显示成功测试的输出。</target>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">如果我们希望此函数允许 &lt;code&gt;item1&lt;/code&gt; 和 &lt;code&gt;item2&lt;/code&gt; 具有不同的类型，则使用 &lt;code&gt;impl Trait&lt;/code&gt; 是合适的（只要这两种类型都实现 &lt;code&gt;Summary&lt;/code&gt; ）。如果我们想强制两个参数具有相同的类型，则只能使用特征绑定来表示，如下所示：</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">如果我们想忽略元组中的一个或多个值，可以使用 &lt;code&gt;_&lt;/code&gt; 或 &lt;code&gt;..&lt;/code&gt; ，您将在&lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;忽略模式中的值&amp;rdquo;&lt;/a&gt;部分中看到。如果问题在于模式中的变量太多，则解决方案是通过删除变量来使类型匹配，以便变量的数量等于元组中的元素数量。</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">如果允许我们运行此代码，则有可能将生成的线程立即放在后台而根本不运行。生成的线程内部引用了 &lt;code&gt;v&lt;/code&gt; ，但是主线程使用我们在第15章中讨论的 &lt;code&gt;drop&lt;/code&gt; 函数立即删除了 &lt;code&gt;v&lt;/code&gt; 。然后，当生成的线程开始执行时， &lt;code&gt;v&lt;/code&gt; 不再有效，因此对其的引用为也无效。不好了！</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">如果我们调用 &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; ， &lt;code&gt;coin&lt;/code&gt; 将是 &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; 。当我们将该值与每个匹配臂进行比较时，直到我们到达 &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; 之前，它们都不匹配。那时， &lt;code&gt;state&lt;/code&gt; 的绑定将是值 &lt;code&gt;UsState::Alaska&lt;/code&gt; 。然后，我们可以在 &lt;code&gt;println!&lt;/code&gt; 使用该绑定！表达式，从而从 &lt;code&gt;Quarter&lt;/code&gt; 的 &lt;code&gt;Coin&lt;/code&gt; 枚举变量中获取内部状态值。</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">如果要创建一个不使用状态模式的替代实现，则可以在 &lt;code&gt;Post&lt;/code&gt; 的方法中甚至在检查Post的状态并更改这些位置的行为的 &lt;code&gt;main&lt;/code&gt; 代码中使用 &lt;code&gt;match&lt;/code&gt; 表达式。这意味着我们将不得不在多个地方查看以了解帖子处于已发布状态的所有含义！这只会增加我们添加的更多状态：每个 &lt;code&gt;match&lt;/code&gt; 表达式都需要另一个分支。</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">如果我们使用在同一个板条箱或同一个模块中定义的多个项目，则在每行中列出每个项目会占用文件中的大量垂直空间。例如，清单2-4中的Guessing游戏中 &lt;code&gt;use&lt;/code&gt; 这两个use语句将 &lt;code&gt;std&lt;/code&gt; 中的项目带入范围：</target>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">如果我们使用在同一个程序包或同一个模块中定义的多个项目，则将每个项目单独列出会在我们的文件中占用很多垂直空间。例如，我们在Guessing Game清单2-4中具有的这两个 &lt;code&gt;use&lt;/code&gt; 语句将 &lt;code&gt;std&lt;/code&gt; 中的项目带入范围：</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">如果您&lt;em&gt;确实&lt;/em&gt;在Rust中编写了该代码，则编译器会向您发出警告（默认情况下，此值由未使用的 &lt;code&gt;unused_must_use&lt;/code&gt; lint 控制）。</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">如果你已经知道你要找的东西的名字,最快的方法是使用页面顶部的搜索栏来查找。</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要定义自己的智能指针类型，并希望使用&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST强制系统&lt;/a&gt;从大小转换为未大小转换，请改用&lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">如果您善于考虑类型，则可以这样考虑 &lt;code&gt;map()&lt;/code&gt; ：如果您有一个迭代器为您提供了一些类型 &lt;code&gt;A&lt;/code&gt; 的元素，并且您想要一个其他类型为 &lt;code&gt;B&lt;/code&gt; 的迭代器，则可以使用 &lt;code&gt;map()&lt;/code&gt; ，传递一个采用 &lt;code&gt;A&lt;/code&gt; 并返回 &lt;code&gt;B&lt;/code&gt; 的闭包。</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">如果您确定字节片是有效的UTF-8，并且不想增加转换的开销，则此函数有一个不安全的版本&lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;，它具有相同的行为，但是会跳过检查。</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">如果您确定字节片是有效的UTF-8，并且不想引起有效性检查的开销，则此函数有一个不安全的版本&lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;，它具有相同的行为，但是会跳过该检查。</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">如果您确定字节片是有效的UTF-8，并且不想引起有效性检查的开销，则此函数有一个不安全的版本&lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;，它具有相同的行为，但是会跳过该检查。</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">如果您确定指针永远不会为空，并且正在寻找某种类型的 &lt;code&gt;as_mut_unchecked&lt;/code&gt; 来返回 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 而不是 &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; ，请知道您可以直接取消引用该指针。</target>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">如果您确定指针永远不会为空，并且正在寻找某种类型的 &lt;code&gt;as_ref_unchecked&lt;/code&gt; 来返回 &lt;code&gt;&amp;amp;T&lt;/code&gt; 而不是 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ，请知道您可以直接取消引用该指针。</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="translated">如果你试图将一个数字类型投向一个bool,你可以用零来代替它。</target>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">如果你正在使用速记字段模式,但想用不同的名称来引用结构字段,你应该明确地重命名它。</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">如果您正在使用速记字段模式，但想通过其他名称引用struct字段，则应该对其进行显式重命名。结构字段由冒号前面使用的名称标识 &lt;code&gt;:&lt;/code&gt; 因此结构模式应类似于匹配的结构类型的声明。</target>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">如果你正在编写一个将处理现有文件格式的程序,在使用这个函数之前,请检查该格式对whitespace的定义是什么。</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果由于权限错误而无法访问包含文件的目录，则将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">如果您不能使用 &lt;code&gt;derive&lt;/code&gt; 策略，请指定您的类型实现 &lt;code&gt;Eq&lt;/code&gt; ，该方法没有方法：</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">如果您创建一个生命周期为 &lt;code&gt;'a&lt;/code&gt; 的安全引用（ &lt;code&gt;&amp;amp;T&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 引用），并且可以通过安全代码访问（例如，因为返回了它），那么您不得以任何与该引用冲突的方式访问数据 &lt;code&gt;'a&lt;/code&gt; 的其余部分。例如，这意味着，如果你把 &lt;code&gt;*mut T&lt;/code&gt; 从 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 并将其投射到一个 &lt;code&gt;&amp;amp;T&lt;/code&gt; ，则在数据 &lt;code&gt;T&lt;/code&gt; 必须保持不变（模任何 &lt;code&gt;UnsafeCell&lt;/code&gt; 内的数据发现 &lt;code&gt;T&lt;/code&gt; ，当然），直到该参考的寿命到期。同样，如果您创建 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 释放给安全代码的引用，那么在该引用过期之前，您不得访问 &lt;code&gt;UnsafeCell&lt;/code&gt; 中的数据。</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">如果创建变量但不在任何地方使用，Rust通常会发出警告，因为这可能是一个错误。但是有时创建一个尚未使用的变量很有用，例如在进行原型设计或刚开始一个项目时。在这种情况下，可以通过用下划线开头变量的名称来告诉Rust不要警告您未使用的变量。在清单18-20中，我们创建了两个未使用的变量，但是在运行此代码时，我们应该只收到关于其中一个的警告。</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="translated">如果决定使用特征对象，请注意它们依赖于&lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;动态调度&lt;/a&gt;，这会对性能产生影响，因为编译器需要发出代码，该代码将找出&lt;em&gt;在运行时而&lt;/em&gt;不是编译期间要调用的方法。使用特质对象，我们可以在性能上进行灵活交易。</target>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="translated">如果你没有一个 &lt;code&gt;&amp;amp;T&lt;/code&gt; ，但只是一个 &lt;code&gt;&amp;amp;U&lt;/code&gt; ，使得 &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; （如 &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt; ），你可以使用 &lt;code&gt;iter().any&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果您不希望这种&amp;ldquo;至少&amp;rdquo;行为，请参见&lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">如果您不调用 &lt;code&gt;expect&lt;/code&gt; ，该程序将编译，但是您会收到警告：</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">如果您不想并行运行测试，或者想要对使用的线程数进行更细粒度的控制，则可以将 &lt;code&gt;--test-threads&lt;/code&gt; 标志和要使用的线程数发送给测试二进制 看下面的例子：</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="translated">如果你不关心信号性(很有可能),那么就不存在便携性的问题。</target>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">如果你不在乎信号性(很有可能),那么就不存在便携性的问题。</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">如果你不知道Rust的基础知识,可以去找Rust书来入门:https://doc.rust-lang.org/book/。</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="translated">如果您不了解Rust的基础知识，可以阅读&lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt;入门。</target>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">如果您没有限定名称，那么代码将绑定名为&amp;ldquo; GET&amp;rdquo;和&amp;ldquo; POST&amp;rdquo;的新变量。这种行为可能不是您想要的，因此 &lt;code&gt;rustc&lt;/code&gt; 在发生这种情况时会发出警告。</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">如果遇到此错误，则必须更改模式，以便匹配输入类型的每个可能值。对于具有少量变体的类型（例如枚举），您可能应该明确涵盖所有情况。或者，可以在所有其他模式之后添加下划线 &lt;code&gt;_&lt;/code&gt; 通配符模式以匹配&amp;ldquo;其他&amp;rdquo;。例：</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">如果遇到此错误，则可能需要使用 &lt;code&gt;match&lt;/code&gt; 或者 &lt;code&gt;if let&lt;/code&gt; 处理失败的可能性。例：</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">如果您具有C或C ++背景，则会注意到这与 &lt;code&gt;gcc&lt;/code&gt; 或 &lt;code&gt;clang&lt;/code&gt; 相似。成功编译后，Rust输出二进制可执行文件。</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">如果您有一个&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;的列表，则可以使用 &lt;code&gt;collect()&lt;/code&gt; 来查看它们是否失败：</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果您具有引用 &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; ，则通常在Rust中， &lt;code&gt;SomeStruct&lt;/code&gt; 的所有字段都是不可变的。编译器基于以下知识进行优化： &lt;code&gt;&amp;amp;T&lt;/code&gt; 没有可变别名或突变，并且 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 是唯一的。 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 是唯一可以解决 &lt;code&gt;&amp;amp;T&lt;/code&gt; 可能不会突变的限制的核心语言功能。所有其他允许内部可变的类型，例如 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，都使用 &lt;code&gt;UnsafeCell&lt;/code&gt; 来包装其内部数据。有&lt;em&gt;没有&lt;/em&gt;以获得混叠合法的方式 &lt;code&gt;&amp;amp;mut&lt;/code&gt; ，即使不与 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">如果您具有引用 &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; ，则通常在Rust中 &lt;code&gt;SomeStruct&lt;/code&gt; 的所有字段都是不可变的。编译器基于以下知识进行优化： &lt;code&gt;&amp;amp;T&lt;/code&gt; 没有可变别名或突变，并且 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 是唯一的。 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 是唯一可以解决此限制的核心语言功能。所有其他允许内部可变的类型，例如 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，都使用 &lt;code&gt;UnsafeCell&lt;/code&gt; 来包装其内部数据。</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">如果您的程序中的逻辑过于冗长而无法使用 &lt;code&gt;match&lt;/code&gt; 来表达，请记住，Rust工具箱中也包含 &lt;code&gt;if let&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">如果您有一个UTF-8字节的向量，则可以使用&lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;方法从中创建一个 &lt;code&gt;String&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">如果您有一个UTF-8字节的向量，则可以使用&lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;方法从中创建一个 &lt;code&gt;String&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">如果您有一个有效UTF-8字节的向量，则可以使用它制作一个&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。您也可以相反。</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您拥有 &lt;code&gt;MaybeUninit&lt;/code&gt; 的所有权，则可以改用&lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您拥有该容器的所有权，则可以改用&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您拥有该值的所有权，则可以改用&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您拥有该值的所有权，则可以改用&lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">如果您具有实现&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; 的功能&lt;/a&gt;，则可以使用&lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; 类型&lt;/a&gt;将其转换为 &lt;code&gt;BufRead&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">如果您立即重新运行 &lt;code&gt;cargo build&lt;/code&gt; 而没有进行任何更改，则除了&amp;ldquo; &lt;code&gt;Finished&lt;/code&gt; 行以外，您将不会获得任何输出。Cargo知道它已经下载并编译了依赖项，并且您在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中没有更改任何&lt;em&gt;相关性&lt;/em&gt;。Cargo还知道您没有对代码进行任何更改，因此也不会重新编译。无事可做，它只是退出。</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;而不是 &lt;code&gt;String&lt;/code&gt; ，请考虑&lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您需要&lt;em&gt;带有&lt;/em&gt; nul终止符的 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;，&lt;/em&gt;则可以使用&lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您需要&lt;em&gt;带有&lt;/em&gt;nul终止符的 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 切片&lt;em&gt;，&lt;/em&gt;则可以改用&lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要 &lt;code&gt;String&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，请考虑&lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的引用，该引用可能比 &lt;code&gt;Entry&lt;/code&gt; 值的销毁更&lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;，请参阅into_mut。</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的引用，该引用可能比 &lt;code&gt;Entry&lt;/code&gt; 值的销毁更&lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;，请参阅into_mut。</target>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的引用，该引用可能会比 &lt;code&gt;Entry&lt;/code&gt; 值的破坏更&lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;，请参阅into_mut。</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的引用，该引用可能比 &lt;code&gt;Entry&lt;/code&gt; 值的销毁更&lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;，请参见into_mut。</target>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">如果您需要对值的散列方式进行更多控制，则当然可以自己实现 &lt;code&gt;Hash&lt;/code&gt; 特征：</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">如果需要更多控制值散列的方式，则需要实现&lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性：</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的多个引用，请参见&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的多个引用，请参见&lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">如果你需要该功能,请确保使用夜间发布的编译器(但要注意该功能可能在未来被删除或更改)。</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">如果你需要这个,你很有可能做错了什么。请记住,Rust并不能保证不同结构的布局(即使是两个具有相同声明的结构也可能有不同的布局)。如果有一种解决方案可以完全避免transmute,可以试试。</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">如果你需要跨越对象边界,可以将指针投向一个整数,并在那里进行运算。</target>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">如果您需要获取&lt;em&gt;许多&lt;/em&gt;流的长度，并且以后不再关心查找位置，则可以通过简单地调用 &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; 并使用其返回值（它来减少查找操作的数量）也是流的长度）。</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">如果需要对单个Unicode标量值执行操作，最好的方法是使用 &lt;code&gt;chars&lt;/code&gt; 方法。在&amp;ldquo;नमस्غे&amp;rdquo;上调用 &lt;code&gt;chars&lt;/code&gt; 分离出并返回 &lt;code&gt;char&lt;/code&gt; 类型的六个值，您可以遍历结果以访问每个元素：</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">如果你只想导入命名空间,就直接导入。</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">如果打开&lt;em&gt;src / main.rs&lt;/em&gt;文件，进行小改动，然后保存并再次构建，则只会看到两行输出：</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">如果你愿意,可以随时下载该脚本,并在运行前检查它。</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">如果将工作箱中的板条箱发布到&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;，则工作区中的每个板条箱都需要单独发布。该 &lt;code&gt;cargo publish&lt;/code&gt; 命令没有一个 &lt;code&gt;--all&lt;/code&gt; 标志或 &lt;code&gt;-p&lt;/code&gt; 标志，所以你必须改变每个箱子的目录并运行 &lt;code&gt;cargo publish&lt;/code&gt; 工作区中的每个箱子发布的板条箱。</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">如果您确实想要全局可变状态，请尝试使用 &lt;code&gt;static mut&lt;/code&gt; 或全局 &lt;code&gt;UnsafeCell&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">如果运行此代码并且仅看到主线程的输出，或者看不到任何重叠，请尝试增加范围内的数字，以为操作系统创造更多机会在线程之间进行切换。</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">如果看到版本号，就知道了！如果看到错误（例如 &lt;code&gt;command not found&lt;/code&gt; ，请查看您的安装方法文档，以确定如何分别安装Cargo。</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">如果您看到此信息，则说明您已成功安装Rust！如果您没有看到此信息，并且在Windows上，请检查Rust是否在 &lt;code&gt;%PATH%&lt;/code&gt; 系统变量中。如果一切正确，但Rust仍然无法正常工作，您可以在许多地方获得帮助。最简单的是&lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;官方Rust Discord&lt;/a&gt;上的#beginners频道。在这里，您可以与其他可以帮助您的Rustaceans（我们称为自己的傻昵称）聊天。其他很棒的资源包括&lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;Users论坛&lt;/a&gt;和&lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">如果您看到此信息，则说明您已成功安装Rust！如果您没有看到此信息，并且您使用的是Windows，请检查Rust是否在 &lt;code&gt;%PATH%&lt;/code&gt; 系统变量中。如果一切正确，并且Rust仍然无法正常工作，那么您可以在很多地方获得帮助。最简单的是&lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;官方Rust Discord&lt;/a&gt;上的#beginners频道。在这里，您可以与其他可以帮助您的Rustaceans（我们称自己为愚蠢的昵称）聊天。其他重要资源包括&lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;&amp;ldquo;用户&amp;rdquo;论坛&lt;/a&gt;和&amp;ldquo;&lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;堆栈溢出&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">如果您启动了一个不使用Cargo的项目，就像我们对&amp;ldquo; Hello，world！&amp;rdquo;所做的那样。项目，您可以将其转换为使用Cargo的项目。将项目代码移到&lt;em&gt;src&lt;/em&gt;目录中，并创建一个适当的&lt;em&gt;Cargo.toml&lt;/em&gt;文件。</target>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">如果您像我们使用Hello World那样开始了一个不使用Cargo的项目！项目，您可以将其转换为使用Cargo的项目。将项目代码移到&lt;em&gt;src&lt;/em&gt;目录中，并创建一个适当的&lt;em&gt;Cargo.toml&lt;/em&gt;文件。</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="translated">如果仍然想在枚举上实现 &lt;code&gt;Default&lt;/code&gt; ，则必须&amp;ldquo;手动&amp;rdquo;完成：</target>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">如果您尝试编译此代码，则会出现以下错误：</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="translated">如果您尝试使用外部包装箱中的模块并使用Rust 2015，则可能错过了 &lt;code&gt;extern crate&lt;/code&gt; 声明（通常放在包装箱根目录中）：</target>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">如果尝试在包含非 &lt;code&gt;Copy&lt;/code&gt; 数据的结构或枚举上实现 &lt;code&gt;Copy&lt;/code&gt; ，则会收到错误&lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">如果您取消注释最后的 &lt;code&gt;println!&lt;/code&gt; 并运行程序，生锈尝试打印这个周期， &lt;code&gt;a&lt;/code&gt; 指向 &lt;code&gt;b&lt;/code&gt; 指向 &lt;code&gt;a&lt;/code&gt; 依此类推，直到它溢出堆栈。</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">如果您想要的行为与 &lt;code&gt;derive&lt;/code&gt; 属性提供的行为不同，请查阅每个特征的&lt;a href=&quot;../std/index&quot;&gt;标准库文档，&lt;/a&gt;以获取有关如何手动实现它们的详细信息。</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">如果您希望其他人能够直接从您的模块导入变体，请使用 &lt;code&gt;pub use&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">如果你想访问这个字段,你有两个选择。</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要正确处理某个值，请运行其析构函数，请参阅&lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">如果要强制闭包对其在环境中使用的值拥有所有权，则可以在参数列表之前使用 &lt;code&gt;move&lt;/code&gt; 关键字。将闭包传递到新线程以移动数据，使其归新线程所有时，此技术最有用。</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">如果要获取命令行参数，请使用 &lt;code&gt;std::env::args&lt;/code&gt; 。要使用指定的退出代码退出，请使用 &lt;code&gt;std::process::exit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c9a2ec635fa6b00d5880ff9292416d8dca9a7fc" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted &lt;code&gt;VecDeque&lt;/code&gt;, while maintaining sort order:</source>
          <target state="translated">如果要将项目插入已排序的 &lt;code&gt;VecDeque&lt;/code&gt; ，同时保持排序顺序：</target>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="translated">如果你想在一个排序向量中插入一个项目,同时保持排序顺序。</target>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">如果要继续使用第一个 &lt;code&gt;String&lt;/code&gt; ，可以对其进行克隆，然后追加到克隆中：</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要泄漏内存，请参阅&lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">如果要与 &lt;code&gt;static&lt;/code&gt; 匹配，请考虑改用防护罩：</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="translated">如果你想与一个方法返回的值进行匹配,你需要先绑定该值。</target>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要获取指向内存的原始指针，请参见&lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">如果你想一步到位获得最大值,可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">如果你想一步到位地获得最小值,可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="translated">如果要忽略当前错误并仅使用其错误源，请使用 &lt;code&gt;skip(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="926fba741a818eca51e737d7fa3523921dbd4a71" translate="yes" xml:space="preserve">
          <source>If you want to omit the initial error and only process its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="translated">如果要忽略初始错误并仅处理其错误源，请使用 &lt;code&gt;skip(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">如果你想覆盖一个特定的选项,但仍然保留其他默认值。</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要替换两个变量的值，请参见&lt;a href=&quot;fn.swap&quot;&gt; &lt;code&gt;swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要替换为默认值，请参见&lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要替换为传递的值而不是默认值，请参见&lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55dde3b0a389df6438eee8ef5e4606e7a78527fd" translate="yes" xml:space="preserve">
          <source>If you want to stick to a standard style across Rust projects, you can use an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; to format your code in a particular style. The Rust team has included this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;, so it should already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">如果要在Rust项目中坚持标准样式，可以使用称为 &lt;code&gt;rustfmt&lt;/code&gt; 的自动格式化程序工具以特定样式格式化代码。Rust团队已将此工具包含在标准Rust发行版中，例如 &lt;code&gt;rustc&lt;/code&gt; ，因此它应该已经安装在您的计算机上！有关更多详细信息，请查看在线文档。</target>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要交换默认值或虚拟值，请参见&lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要与传递的值交换，返回旧值，请参见&lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">如果要使用SPDX中未显示的许可证，则需要将该许可证的文本放置在文件中，在项目中包含该文件，然后使用 &lt;code&gt;license-file&lt;/code&gt; 指定该文件的名称。使用 &lt;code&gt;license&lt;/code&gt; 密钥。</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">如果要使用方法，请在其后添加 &lt;code&gt;()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">如果要使用 &lt;code&gt;rand&lt;/code&gt; 版本 &lt;code&gt;0.4.0&lt;/code&gt; 或 &lt;code&gt;0.4.x&lt;/code&gt; 系列中的任何版本，则必须更新&lt;em&gt;Cargo.toml&lt;/em&gt;文件，使其看起来像这样：</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">如果要使用 &lt;code&gt;rand&lt;/code&gt; 版本 &lt;code&gt;0.6.0&lt;/code&gt; 或 &lt;code&gt;0.6.x&lt;/code&gt; 系列中的任何版本，则必须更新&lt;em&gt;Cargo.toml&lt;/em&gt;文件，使其看起来像这样：</target>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">如果您希望将此属性应用于impl中的所有方法，请手动注释每个方法。无法使用 &lt;code&gt;#[inline]&lt;/code&gt; 属性注释整个impl 。</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="translated">如果您想了解有关Rust中所有权的更多信息，请从本书的&lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;了解所有权&lt;/a&gt;一章开始。</target>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">如果你想了解更多关于Rust的所有权,请从本书的章节开始。</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">如果使用Windows API，则可能希望将&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;转换为 &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">如果要导入所有导出的宏，请编写 &lt;code&gt;macro_use&lt;/code&gt; 带参数的macro_use。</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">如果您对诸如Ruby，Python或JavaScript之类的动态语言更加熟悉，则可能不习惯将它们作为单独的步骤来编译和运行程序。Rust是一种&lt;em&gt;提前编译的&lt;/em&gt;语言，这意味着您可以编译程序并将可执行文件提供给其他人，即使他们没有安装Rust也可以运行它。如果为某人提供&lt;em&gt;.rb&lt;/em&gt;，&lt;em&gt;.py&lt;/em&gt;或&lt;em&gt;.js&lt;/em&gt;文件，则他们需要分别安装Ruby，Python或JavaScript实现。但是在这些语言中，您只需要一个命令即可编译和运行程序。一切都需要在语言设计中进行权衡。</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">如果您面临挑战，请尝试自己执行这些更改，然后再查看清单20-15中的代码。</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">如果您使用的是Linux或macOS，请打开一个终端并输入以下命令：</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">如果使用PowerShell，则需要设置环境变量并以两个命令而不是一个命令运行程序：</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">如果您使用Beta或稳定版的Rust，则不能使用任何功能标志。这是使我们在永久宣布新功能稳定之前就可以对其进行实际使用的关键。那些希望选择最前沿技术的人可以这样做，而那些希望获得坚如磐石经验的人可以坚持不懈，并知道他们的代码不会被破坏。稳定而无停滞。</target>
        </trans-unit>
        <trans-unit id="c4d2404277922b45ce332d5f67f5f097fe76da77" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果要将一个文件的内容复制到另一个文件并且正在使用&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，请参见&lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果要将一个文件的内容复制到另一个文件，并且正在使用&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，请参见&lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果您想将一个文件的内容复制到另一个文件，并且正在使用文件系统路径，请参见&lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">如果您在使用其他语言时听到过&lt;em&gt;浅复制&lt;/em&gt;和&lt;em&gt;深复制&lt;/em&gt;这两个术语，那么复制指针，长度和容量而不复制数据的概念可能听起来像是进行浅复制。但是由于Rust也使第一个变量无效，而不是被称为浅表副本，因此被称为&lt;em&gt;move&lt;/em&gt;。在这个例子中，我们可以说， &lt;code&gt;s1&lt;/code&gt; 被&lt;em&gt;移动&lt;/em&gt;到 &lt;code&gt;s2&lt;/code&gt; 。因此实际发生的情况如图4-4所示。</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果您想显式调用值的析构函数，则可以使用&lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">如果要创建一个集合，&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;为其实现IntoIterator将使您的集合可以与 &lt;code&gt;for&lt;/code&gt; 循环一起使用。</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">如果你正在做某种副作用，喜欢&lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;来 &lt;code&gt;map()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50fae5c17f1680200b10a72b86983fc6d83252f1" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">如果只需要获取 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的前缀就可以了，则可以先调用&lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="657123c4239a0672bb847d20cff32727a933d93f" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">如果只需要获取 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的前缀就可以了，则可以先调用&lt;a href=&quot;struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2c18403b0527c315799b70edeca9e66be8c0011" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">如果只需要获取 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的前缀就可以了，则可以先调用&lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt; &lt;code&gt;.truncate(N)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">如果仅从 &lt;code&gt;main&lt;/code&gt; 返回this和 &lt;code&gt;SUCCESS&lt;/code&gt; ，则考虑分别返回 &lt;code&gt;Err(_)&lt;/code&gt; 和 &lt;code&gt;Ok(())&lt;/code&gt; ，这将返回相同的代码（但也将 &lt;code&gt;eprintln!&lt;/code&gt; 错误）。</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">如果确定要覆盖棉绒检查，则可以将 &lt;code&gt;forbid&lt;/code&gt; 更改为 &lt;code&gt;deny&lt;/code&gt; （如果将 &lt;code&gt;forbid&lt;/code&gt; 设置作为命令行选项给出，则使用 &lt;code&gt;-D&lt;/code&gt; 而不是 &lt;code&gt;-F&lt;/code&gt; ）以允许内部棉绒检查属性：</target>
        </trans-unit>
        <trans-unit id="9708dfd947b0f617c80eaf862c93f6be07e715ad" translate="yes" xml:space="preserve">
          <source>If you're using PowerShell, you will need to set the environment variable and run the program as separate commands:</source>
          <target state="translated">如果你使用PowerShell,你将需要设置环境变量,并作为单独的命令运行程序。</target>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">如果你使用的是rustc的年夜版本,只需添加相应的功能就能够使用。</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">如果您使用的是稳定版或测试版的rustc,您将无法使用任何不稳定的功能。為此,請切換到夜間版的 rustc (使用 rustup)。</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">如果您正在编写&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;，则可以将其与 &lt;code&gt;for&lt;/code&gt; 循环一起使用。</target>
        </trans-unit>
        <trans-unit id="39b96bd78ad2447973090132f0c782a06fee701a" translate="yes" xml:space="preserve">
          <source>If you've expected to use a crate name:</source>
          <target state="translated">如果你已经预料到要用一个箱子的名字。</target>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">如果你发现自己有一个集合,并且需要对该集合的元素进行操作,你会很快遇到 &quot;迭代器&quot;。迭代器在习惯性的Rust代码中被大量使用,所以值得熟悉它们。</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">如果您的结构实际上不&lt;em&gt;拥有&lt;/em&gt;类型 &lt;code&gt;T&lt;/code&gt; 的数据，则最好使用引用类型，例如 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; （理想情况下）或 &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; （如果没有生命周期适用），这样不表示所有权。</target>
        </trans-unit>
        <trans-unit id="1f6b5f80968da1047a776f5803bbfc765104a318" translate="yes" xml:space="preserve">
          <source>If your type is &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;, you can implement &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;&lt;code&gt;partial_cmp&lt;/code&gt;&lt;/a&gt; by using &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果您的类型是&lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt;，则可以使用&lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;/a&gt;来实现&lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt; &lt;code&gt;partial_cmp&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">如果您的类型是 &lt;code&gt;Ord&lt;/code&gt; ，则可以使用 &lt;code&gt;cmp()&lt;/code&gt; 来实现 &lt;code&gt;partial_cmp()&lt;/code&gt; （）：</target>
        </trans-unit>
        <trans-unit id="7bfd0ea25f9360aa8168faba44b4ab62b5c11325" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt;&lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您的类型使用钉扎（例如上面的两个示例），则在实现&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;时必须小心。该&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;的功能需要 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，但是这就是所谓的&lt;em&gt;，即使你以前类型被寄予厚望&lt;/em&gt;！就像编译器自动调用了&lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt; &lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">如果您的类型使用钉扎（例如上面的两个示例），则在实现 &lt;code&gt;Drop&lt;/code&gt; 时必须小心。该 &lt;code&gt;drop&lt;/code&gt; 的功能需要 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，但是这就是所谓的&lt;em&gt;，即使你以前类型被寄予厚望&lt;/em&gt;！就像编译器自动调用了 &lt;code&gt;get_unchecked_mut&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">相反，如果闭包直接使用 &lt;code&gt;self.vec&lt;/code&gt; ，则它将尝试通过可变引用来捕获 &lt;code&gt;self&lt;/code&gt; 。但是由于 &lt;code&gt;self.set&lt;/code&gt; 已被借来进行迭代，因此代码无法编译。</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">忽略的领域的其他 &lt;code&gt;person&lt;/code&gt; 。其余字段可以具有任何值，并且不与任何变量绑定。</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">忽略带有嵌套 &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; 的部分值</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">用 &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt; 忽略值的其余部分</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">除非有特别要求,否则忽略某些测试</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">忽略模式中的值</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">用 &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt; 忽略整个值</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">通过以 &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt; 开头的名称来忽略未使用的变量</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">想象一下 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 在家庭活动室中作为电视。当一个人进入看电视时，他们会打开电视。其他人可以进入房间看电视。当最后一个人离开房间时，由于不再使用电视，他们关闭了电视。如果有人关闭电视，而其他人仍在观看电视，那么其余的电视观看者将会感到不安！</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">不变的原始条目的使用非常有限；您可能需要 &lt;code&gt;raw_entry_mut&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">不可变的分片迭代器</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">不变的从自有价值中借来。</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">不变地借用封装的值,如果该值当前是可变地借用的,则返回错误。</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">不变的借用包装值。</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">Impl块单独声明寿命参数。如果你要实现一个有自己的寿命参数的类型,你需要把寿命参数添加到一个 impl 块中。例如</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">Impl特征</target>
        </trans-unit>
        <trans-unit id="21127244da70324da76b7c0c9aa099a69f9c571a" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;unsafe&lt;/code&gt;&lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">实施 &lt;code&gt;unsafe&lt;/code&gt; &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt;小号</target>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">实施不安全特性</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">为一个类型实现一些功能。</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">实现&lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt;特性以实现廉价的可变突变</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">实现&lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt;特征以实现廉价的参考到参考的转换</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">实施&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; trait以使用价值转换为价值</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">实现&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;特性，以将值到值的转换消耗到当前包装箱之外的类型</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">在类型上实现 &lt;code&gt;Copy&lt;/code&gt; 特征。</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">逻辑上不可变的方法的实施细节</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">逻辑上不可变的方法的实施细节。</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">实施说明</target>
        </trans-unit>
        <trans-unit id="cbd0574adde4a73750817df1b9bf6659b05baae3" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">的执行&lt;a href=&quot;../primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f209c5111fdc43ea4ba2b99ff5e91a185c5ba5f" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">实施&lt;a href=&quot;../primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d07ae3ae0632c811bda0590dcd36a31748f12009" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">的执行&lt;a href=&quot;primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6523b8f0fa5de5a2e923accee11e86f6d33eb03c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">实施&lt;a href=&quot;primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">鼓励实现在内存耗尽时返回 &lt;code&gt;Err&lt;/code&gt; 而不是惊慌或中止，但这不是严格的要求。（特别是：在底层的本机分配库上实现此特征是&lt;em&gt;合法的&lt;/em&gt;，该本机分配库因内存耗尽而中止。）</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">鼓励实现在内存耗尽时返回null而不是中止，但这不是严格的要求。（特别是：在底层的本机分配库上实现此特征是&lt;em&gt;合法的&lt;/em&gt;，该本机分配库因内存耗尽而中止。）</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">鼓励实现在内存耗尽时返回null，而不是惊慌或中止，但这不是严格的要求。（特别是：在底层的本机分配库上实现此特征是&lt;em&gt;合法的&lt;/em&gt;，该本机分配库因内存耗尽而中止。）</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">实现可能在 &lt;code&gt;impl&lt;/code&gt; 关键字之前包含外部&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;，而在包含相关项目的方括号内则包含内部&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;。内部属性必须位于任何关联的项目之前。在这里有意义的属性是&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5c6183888e78c3e46f39fb71a3e11db5b02b618" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">的实现&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;互相同意。也就是说， &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; 当且仅当 &lt;code&gt;a == b&lt;/code&gt; 并且 &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; 为 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。通过推导某些特征并手动实施其他特征，很容易使它们意外地产生分歧。</target>
        </trans-unit>
        <trans-unit id="906e45c0ce13a452d5ad583acf7c948d36606488" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">的实现&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;PartialOrd&lt;/code&gt; 和&lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;互相同意。通过推导某些特征并手动实施其他特征，很容易使它们意外地产生分歧。</target>
        </trans-unit>
        <trans-unit id="7c77f28f9797beb5e60c442300cafb1661e149f7" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">的实现 &lt;code&gt;PartialEq&lt;/code&gt; ，&lt;a href=&quot;trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;互相同意。通过推导某些特征并手动实施其他特征，很容易使它们意外地产生分歧。</target>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">的实现 &lt;code&gt;PartialEq&lt;/code&gt; ， &lt;code&gt;PartialOrd&lt;/code&gt; 和 &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;互相同意。通过推导某些特征并手动实施其他特征，很容易使它们意外地产生分歧。</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">的实现 &lt;code&gt;PartialEq&lt;/code&gt; ， &lt;code&gt;PartialOrd&lt;/code&gt; 和 &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;互相同意。也就是说， &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; 当且仅当 &lt;code&gt;a == b&lt;/code&gt; 和 &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; 为所有 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。通过推导某些特征并手动实施其他特征，很容易使它们意外地产生分歧。</target>
        </trans-unit>
        <trans-unit id="f03739953743b6047f7ae8d466b9ff10b313f420" translate="yes" xml:space="preserve">
          <source>Implementations of must return the same mutable reference for their lifetime, unless replaced by a caller. Callers may only replace the reference when they stopped iteration and drop the iterator pipeline after extracting the source.</source>
          <target state="translated">的实现必须在其一生中返回相同的可变引用,除非被调用者替换。调用者只能在停止迭代时替换引用,并在提取源后放弃迭代器管道。</target>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">考虑到操作符特性的通常含义和&lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;操作符优先级&lt;/a&gt;，在他们各自的上下文中实现操作符特性应该不足为奇。例如，在实现&lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; 时&lt;/a&gt;，该操作应与乘法有些相似（并共享期望的属性，如关联性）。</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">对于固定长度的数组，直到一定长度的东西，如 &lt;code&gt;Eq&lt;/code&gt; 的实现。最终，我们应该能够全面推广。</target>
        </trans-unit>
        <trans-unit id="2f5aa5cbed1b025d1b2126e25480e69829ce743f" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually, we should be able to generalize to all lengths.</source>
          <target state="translated">对于固定长度的数组，直到一定长度的东西，如 &lt;code&gt;Eq&lt;/code&gt; 的实现。最终，我们应该能够全面推广。</target>
        </trans-unit>
        <trans-unit id="118b3aed38f3812ad05266c0985ae4538e945007" translate="yes" xml:space="preserve">
          <source>Implementations of this trait have to promise that if the argument to &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; is a safe reference, then so is the result.</source>
          <target state="translated">此特性的实现必须保证，如果 &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; 的参数是安全的引用，那么结果也是如此。</target>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">外来类型的实施</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">手动实现 &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; 和 &lt;code&gt;Sync&lt;/code&gt; 是不安全的</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">用泛型实现 &lt;code&gt;Add&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;Binary&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">为智能指针实现 &lt;code&gt;Deref&lt;/code&gt; 使得访问它们后面的数据变得方便，这就是为什么它们实现 &lt;code&gt;Deref&lt;/code&gt; 的原因。另一方面，有关 &lt;code&gt;Deref&lt;/code&gt; 和&lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;的规则是专门为容纳智能指针而设计的。因此，&lt;strong&gt;仅应为智能指针实现&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/strong&gt;以避免混淆。</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">为智能指针实现 &lt;code&gt;DerefMut&lt;/code&gt; 使得对它们后面的数据进行更改变得很方便，这就是它们实现 &lt;code&gt;DerefMut&lt;/code&gt; 的原因。另一方面，有关&lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;DerefMut&lt;/code&gt; 的规则是专门为容纳智能指针而设计的。因此，&lt;strong&gt;仅应为智能指针实现&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/strong&gt;以避免混淆。</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;Display&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">实现 &lt;code&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">实施 &lt;code&gt;Extend&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">为您的类型实现 &lt;code&gt;FromIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;Hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">实施 &lt;code&gt;Into&lt;/code&gt; 以转换为外部类型</target>
        </trans-unit>
        <trans-unit id="47b64f6f87d5b0f43159c63203037214de4fae2c" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types in old versions of Rust</source>
          <target state="translated">在旧版本的Rust中实现 &lt;code&gt;Into&lt;/code&gt; 以转换为外部类型</target>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">为您的类型实现 &lt;code&gt;IntoIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;LowerExp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;LowerHex&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;Octal&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;Pointer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">用泛型实现 &lt;code&gt;Sub&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;TryInto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;UpperExp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">在一种类型上实现 &lt;code&gt;UpperHex&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">实现 &lt;code&gt;split_at_mut&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">迭代器的实现</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">将转换实现为不同类型的变换。</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">在类型上实现一个特征</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">在类型上实现特征类似于实现常规方法。区别在于，在 &lt;code&gt;impl&lt;/code&gt; 之后，我们放入要实现的特征名称，然后使用 &lt;code&gt;for&lt;/code&gt; 关键字，然后指定要为其实现特征的类型的名称。在 &lt;code&gt;impl&lt;/code&gt; 块中，我们放入特征定义已定义的方法签名。我们没有在每个签名后添加分号，而是使用大括号并在方法主体中填充了我们希望特征对于特定类型具有的特定行为。</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">实施&lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;不安全特质&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">实现面向对象的设计模式</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">实施不安全特征</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;ThreadPool&lt;/code&gt; 上实现 &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">实现 &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">实现 &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">实施 &lt;code&gt;Deref&lt;/code&gt; 特质让你自定义的行为&lt;em&gt;引用操作&lt;/em&gt;， &lt;code&gt;*&lt;/code&gt; （而不是乘法或水珠运营商）。通过以一种可以将智能指针视为常规引用的方式实施 &lt;code&gt;Deref&lt;/code&gt; ，您可以编写对引用进行操作的代码，并将该代码也与智能指针一起使用。</target>
        </trans-unit>
        <trans-unit id="0f9c556a4371185e579cbc710c1fc95eeb3c1d8f" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Unpin&lt;/code&gt; trait for &lt;code&gt;T&lt;/code&gt; lifts the restrictions of pinning off the type, which then allows moving &lt;code&gt;T&lt;/code&gt; out of &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Unpin&lt;/code&gt; 特质消除了固定该类型的限制，然后允许使用诸如&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;功能将 &lt;code&gt;T&lt;/code&gt; 从&lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;移出。</target>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">实施特质</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">实现这些特性可以让你过载某些操作符。</target>
        </trans-unit>
        <trans-unit id="eda774fd99643b19395b54fc514042bb2ec818cd" translate="yes" xml:space="preserve">
          <source>Implementing this method means adapters relinquish private-only access to their source and can only rely on guarantees made based on method receiver types. The lack of restricted access also requires that adapters must uphold the source's public API even when they have access to its internals.</source>
          <target state="translated">实现这个方法意味着适配程序放弃了对其源的私有访问,只能依靠基于方法接收器类型的保证。缺乏限制性访问也要求适配程序必须维护源的公共API,即使他们可以访问其内部。</target>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现此特征可以解除固定类型的限制，然后允许使用诸如&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;功能将其移出。</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 特征的实现者称为&amp;ldquo;阅读器&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">具有 &lt;code&gt;Write&lt;/code&gt; 特性的实现者有时称为&amp;ldquo;作家&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a29b7cdf7ecad32a88da5f080db151e6782b6cbd" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;字典的角度&lt;/a&gt;实现数组的比较。</target>
        </trans-unit>
        <trans-unit id="1b3e920e06f6ab852e47c92d5907d33f79db03f9" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;字典的角度&lt;/a&gt;实现数组的比较。</target>
        </trans-unit>
        <trans-unit id="d9b100c6b8306d80c3deac3c66eb144722bfbf34" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays lexicographically.</source>
          <target state="translated">用词典实现数组的比较。</target>
        </trans-unit>
        <trans-unit id="9a9bfc1f72bab87b52d6e0bc8ae9d29b981a8471" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;字典上&lt;/a&gt;实现向量的比较。</target>
        </trans-unit>
        <trans-unit id="d1d4e2f4157c9478fac1167b8d36a099c3612234" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;字典上&lt;/a&gt;实现向量的比较。</target>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">在词典上实现向量的比较。</target>
        </trans-unit>
        <trans-unit id="8c72616b99bde1fdb32f3ac1428fa28fcbc9bbe4" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;字典上&lt;/a&gt;实现向量的比较。</target>
        </trans-unit>
        <trans-unit id="121392f51a7cb90c886bedc6219cb1e615ac17eb" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;字典上&lt;/a&gt;实现向量的比较。</target>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">实现向量的比较,词汇学。</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">实现对字符串的比较操作。</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">实现字符串的排序。</target>
        </trans-unit>
        <trans-unit id="35489c538a41efaebde69fb1cc4bd86b19d3be17" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">按&lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;字典顺序&lt;/a&gt;实现向量的排序。</target>
        </trans-unit>
        <trans-unit id="b0d293e0c8158270fc97cffd60669c60a1be015e" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="translated">按&lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;字典顺序&lt;/a&gt;实现向量的排序。</target>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">实现向量的排序,词法。</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; 语法实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">使用语法 &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; 实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">使用语法 &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; 实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; 语法实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; 语法实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; 语法实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">实现 &lt;code&gt;+&lt;/code&gt; 运算符以连接两个字符串。</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">实现 &lt;code&gt;+=&lt;/code&gt; 运算符以附加到 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">隐性借款</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">用函数和方法进行隐性脱力胁迫。</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">隐性借贷可采取以下表达方式。</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">隐性启用</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">从其他箱子或模块导入或重命名物品。</target>
        </trans-unit>
        <trans-unit id="a3bc444ee7d2e0f0563ef80376cca1e4bb0a9a91" translate="yes" xml:space="preserve">
          <source>Importing with &lt;code&gt;_&lt;/code&gt; to only import the methods of a trait without binding it to a name (to avoid conflict for example): &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;_&lt;/code&gt; 导入仅导入特征的方法而不将其绑定到名称（例如，避免冲突）： &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">不允许在非项目语句（例如变量声明和表达式语句）之后导入（ &lt;code&gt;use&lt;/code&gt; 语句）。</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">通过线程池提高我们服务器的吞吐量。</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">改进我们的I/O项目</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">利用线程池提高吞吐量</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">改进错误信息</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">在 &lt;code&gt;ThreadPool::new&lt;/code&gt; ，使用 &lt;code&gt;for&lt;/code&gt; 循环计数器生成 &lt;code&gt;id&lt;/code&gt; ，创建一个新的 &lt;code&gt;Worker&lt;/code&gt; 与 &lt;code&gt;id&lt;/code&gt; ，与劳动者存储载体。</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">在 &lt;code&gt;ThreadPool::new&lt;/code&gt; ，我们创建我们的新通道，并让该池容纳发送端。这将成功编译，但仍带有警告。</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">在 &lt;code&gt;ThreadPool::new&lt;/code&gt; ，我们将通道的接收端放在 &lt;code&gt;Arc&lt;/code&gt; 和 &lt;code&gt;Mutex&lt;/code&gt; 中。对于每个新工作人员，我们克隆 &lt;code&gt;Arc&lt;/code&gt; 来增加参考计数，以便工作人员可以共享接收端的所有权。</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 中，我们调用 &lt;code&gt;Dog::baby_name&lt;/code&gt; 函数，该函数直接调用在 &lt;code&gt;Dog&lt;/code&gt; 上定义的关联函数。此代码显示以下内容：</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 中，我们创建了两个 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 实例，然后打印 &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; 。在 &lt;code&gt;main&lt;/code&gt; 的最后，我们的 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 实例将超出范围，Rust将调用放置在 &lt;code&gt;drop&lt;/code&gt; 方法中的代码，并打印最终消息。注意，我们不需要显式调用 &lt;code&gt;drop&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="80fb329de5f9b05c42fffbe0f4f0674e4bf17666" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; ，我们创建的两个实例 &lt;code&gt;CustomSmartPointer&lt;/code&gt; ，然后打印 &lt;code&gt;CustomSmartPointers created&lt;/code&gt; 。在 &lt;code&gt;main&lt;/code&gt; 的最后，我们的 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 实例将超出范围，Rust将调用放置在 &lt;code&gt;drop&lt;/code&gt; 方法中的代码，并打印最终消息。注意，我们不需要显式调用 &lt;code&gt;drop&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 中，我们添加了一条新语句： &lt;code&gt;fs::read_to_string&lt;/code&gt; 获取 &lt;code&gt;filename&lt;/code&gt; ，打开该文件，并返回文件内容的 &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; ，我们已经定义了一个 &lt;code&gt;Point&lt;/code&gt; ，其具有 &lt;code&gt;i32&lt;/code&gt; 为 &lt;code&gt;x&lt;/code&gt; （具有值 &lt;code&gt;5&lt;/code&gt; ）和 &lt;code&gt;f64&lt;/code&gt; 为 &lt;code&gt;y&lt;/code&gt; （具有值 &lt;code&gt;10.4&lt;/code&gt; ）。所述 &lt;code&gt;p2&lt;/code&gt; 变量是一个 &lt;code&gt;Point&lt;/code&gt; 结构，其具有用于一个字符串切片 &lt;code&gt;x&lt;/code&gt; （具有值 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ）和 &lt;code&gt;char&lt;/code&gt; 用于 &lt;code&gt;y&lt;/code&gt; （具有值 &lt;code&gt;c&lt;/code&gt; ）。调用 &lt;code&gt;mixup&lt;/code&gt; 上 &lt;code&gt;p1&lt;/code&gt; 与参数 &lt;code&gt;p2&lt;/code&gt; 为我们提供了 &lt;code&gt;p3&lt;/code&gt; ，这将有 &lt;code&gt;i32&lt;/code&gt; 的 &lt;code&gt;x&lt;/code&gt; ，因为 &lt;code&gt;x&lt;/code&gt; 来自 &lt;code&gt;p1&lt;/code&gt; 。在 &lt;code&gt;p3&lt;/code&gt; 变量将有一个 &lt;code&gt;char&lt;/code&gt; 为 &lt;code&gt;y&lt;/code&gt; ，因为 &lt;code&gt;y&lt;/code&gt; 从哪里来 &lt;code&gt;p2&lt;/code&gt; 。该 &lt;code&gt;println!&lt;/code&gt; 宏调用将输出 &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">在 &lt;code&gt;match&lt;/code&gt; 表达式中，可以使用 &lt;code&gt;|&lt;/code&gt; 匹配多个模式。语法，表示&lt;em&gt;或&lt;/em&gt;。例如，以下代码将 &lt;code&gt;x&lt;/code&gt; 的值与匹配臂进行匹配，匹配臂中的第一个具有&lt;em&gt;or&lt;/em&gt;选项，这意味着如果 &lt;code&gt;x&lt;/code&gt; 的值与该臂中的任一值匹配，则该臂的代码将运行：</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">在C和C ++中，两个不同的运算符用于调用方法：use &lt;code&gt;.&lt;/code&gt; 如果要直接在对象上调用方法，则 &lt;code&gt;-&amp;gt;&lt;/code&gt; 如果要在指向对象的指针上调用方法，并且需要先取消引用该指针。换句话说，如果 &lt;code&gt;object&lt;/code&gt; 是指针，则 &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; 与 &lt;code&gt;(*object).something()&lt;/code&gt; 相似。</target>
        </trans-unit>
        <trans-unit id="13a07dbff3d7bb71ba41c886c11573397f976542" translate="yes" xml:space="preserve">
          <source>In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn&amp;rsquo;t belong to that structure. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the data structure.</source>
          <target state="translated">在C语言中，尝试读取超出数据结构末尾的内容是未定义的行为。即使内存不属于该结构，也可能会在内存中获得与该数据结构中的元素相对应的任何内容。这被称为&lt;em&gt;缓冲区溢出&lt;/em&gt;，如果攻击者能够以某种方式操纵索引以读取数据，则不应导致将其存储在数据结构之后，从而导致安全漏洞。</target>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">在第1章中，您看到了 &lt;code&gt;cargo new&lt;/code&gt; 在版本的&lt;em&gt;Cargo.toml&lt;/em&gt;文件中添加了一些元数据。本附录讨论了这意味着什么！</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">在第10章&lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;在类型上实现特征&amp;rdquo;中&lt;/a&gt;，我们提到了孤立规则，该规则规定，只要特征或类型在板条箱中是本地的，就允许我们对类型实现特征。可以使用&lt;em&gt;newtype模式&lt;/em&gt;解决此限制，该&lt;em&gt;模式&lt;/em&gt;涉及在元组结构中创建新类型。 （我们在第5章的&lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;使用没有命名字段的元组结构创建不同类型&amp;rdquo;中&lt;/a&gt;介绍了元组结构。）元组结构将只有一个字段，并且是我们要为其实现特征的类型的瘦包装。然后包装器类型对于我们的板条箱是本地的，我们可以在包装器上实现特征。&lt;em&gt;新类型&lt;/em&gt;是一个源自Haskell编程语言的术语。使用此模式不会影响运行时性能，并且包装类型在编译时会被忽略。</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">在第10章中，我们将讨论如何解决这些错误，以便您可以将引用存储在结构中，但是现在，我们将使用诸如 &lt;code&gt;String&lt;/code&gt; 之类的拥有类型而不是像 &lt;code&gt;&amp;amp;str&lt;/code&gt; 这样的引用来修复此类错误。</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">在第12章中，我们构建了一个包含二进制板条箱和库板条箱的软件包。随着项目的发展，您可能会发现库箱继续变大，并且您想将包进一步拆分成多个库箱。在这种情况下，Cargo提供了一个称为&lt;em&gt;工作空间&lt;/em&gt;的功能，该功能可以帮助管理串联开发的多个相关程序包。</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">在第13章中，我们提到了可以在闭包的参数列表之前使用 &lt;code&gt;move&lt;/code&gt; 关键字，以强制闭包对其在环境中使用的值进行所有权。当创建新线程以将值的所有权从一个线程转移到另一个线程时，此技术特别有用。</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">在第15章中，我们使用智能指针 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 创建了一个参考计数值，从而为多个所有者赋予了一个值。让我们在这里做同样的事情，看看会发生什么。在清单16-14中，我们将 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 包装在 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 中，并在将所有权移至线程之前克隆 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 。现在我们已经看到了错误，我们还将切换回使用 &lt;code&gt;for&lt;/code&gt; 循环，并且将 &lt;code&gt;move&lt;/code&gt; 关键字保留在闭包中。</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">在第16章中，我们将介绍并发编程的不同模型，并讨论Rust如何帮助您轻松地在多个线程中进行编程。第17章介绍了Rust习惯用法与您可能熟悉的面向对象编程原理的比较。</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">在第16章中，您了解了&lt;em&gt;通道（&lt;/em&gt;在两个线程之间进行通信的一种简单方法），这对于此用例而言是完美的。我们将使用一个通道作为作业队列， &lt;code&gt;execute&lt;/code&gt; 将把作业从 &lt;code&gt;ThreadPool&lt;/code&gt; 发送到 &lt;code&gt;Worker&lt;/code&gt; 实例，再将作业发送到其线程。这是计划：</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">在第2章中，我们编写了一个猜测游戏项目，该项目使用一个称为 &lt;code&gt;rand&lt;/code&gt; 的外部程序包来获取随机数。要在我们的项目中使用 &lt;code&gt;rand&lt;/code&gt; ，我们将此行添加到&lt;em&gt;Cargo.toml中&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">在第20章中，我们将完成一个项目，在该项目中我们将实现一个低级多线程Web服务器！</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">在第3章中，我们提到了 &lt;code&gt;for&lt;/code&gt; 循环是Rust代码中最常见的循环构造，但我们尚未讨论 &lt;code&gt;for&lt;/code&gt; 取用的模式。在 &lt;code&gt;for&lt;/code&gt; 循环中，模式是紧随关键字 &lt;code&gt;for&lt;/code&gt; 的值，因此 &lt;code&gt;for x in y&lt;/code&gt; 中的x中， &lt;code&gt;x&lt;/code&gt; 是模式。</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">在第4章的&lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;悬挂引用&amp;rdquo;&lt;/a&gt;部分中，我们提到了编译器确保引用始终有效。不安全的Rust有两种称为&lt;em&gt;原始指针的&lt;/em&gt;新类型，它们类似于引用。与引用一样，原始指针可以是不可变的或可变的，并且分别写为 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 。星号不是取消引用运算符；它是类型名称的一部分。在原始指针的上下文中，&lt;em&gt;不可变&lt;/em&gt;意味着指针在被取消引用后不能直接分配给它。</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">在清单5-15的第5章中，我们使用了 &lt;code&gt;Rectangle&lt;/code&gt; 结构和 &lt;code&gt;can_hold&lt;/code&gt; 方法，在清单11-5中对此进行了重复。让我们将这段代码放在&lt;em&gt;src / lib.rs&lt;/em&gt;文件中，并使用 &lt;code&gt;assert!&lt;/code&gt; 为其编写一些测试！宏。</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">在第六章中，我们讨论了如何使用 &lt;code&gt;if let&lt;/code&gt; 表达主要表现为较短的方式写了一个等效的 &lt;code&gt;match&lt;/code&gt; ，只有匹配一个情况。或者， &lt;code&gt;if let&lt;/code&gt; 可以有一个相应的 &lt;code&gt;else&lt;/code&gt; 包含代码来运行，如果在模式 &lt;code&gt;if let&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">在第7章中，我们介绍了如何使用 &lt;code&gt;mod&lt;/code&gt; 关键字将代码组织到模块中，如何使用 &lt;code&gt;pub&lt;/code&gt; 关键字将项目公开，以及如何 &lt;code&gt;use&lt;/code&gt; 关键字将项目带入范围。但是，在开发板条箱时对您有意义的结构可能对您的用户而言不是很方便。您可能想要在包含多个级别的层次结构中组织结构，但是想要使用您在层次结构深处定义的类型的人可能很难发现该类型存在。他们也可能因为不得不输入 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; 而感到恼火。而不是 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">在第7章中，您将了解Rust的模块系统以及用于组织代码及其公共应用程序编程接口（API）的隐私规则。第8章讨论了标准库提供的一些常见的集合数据结构，例如向量，字符串和哈希图。第9章探讨了Rust的错误处理哲学和技术。</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">在第8章中，我们提到了向量的一个局限性是它们只能存储一种类型的元素。我们在清单8-10中创建了一种变通方法，其中定义了一个 &lt;code&gt;SpreadsheetCell&lt;/code&gt; 枚举，该枚举具有用于容纳整数，浮点数和文本的变体。这意味着我们可以在每个单元格中存储不同类型的数据，并且仍然具有代表一行单元格的向量。当我们的可互换项是我们在编译代码时就知道的一组固定类型时，这是一个非常好的解决方案。</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">在Enum定义中</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">在功能定义中</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">在清单10-3中，我们将找到最大数字的代码提取到名为 &lt;code&gt;largest&lt;/code&gt; 的函数中。与清单10-1中的代码只能在一个特定列表中找到最大的数字不同，此程序可以在两个不同的列表中找到最大的数字。</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">在清单11-7中，我们编写了一个名为 &lt;code&gt;add_two&lt;/code&gt; 的函数，该函数将其参数加 &lt;code&gt;2&lt;/code&gt; 并返回结果。然后，我们使用 &lt;code&gt;assert_eq!&lt;/code&gt; 测试此功能！宏。</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">在清单12-6中，我们添加了获取一部分 &lt;code&gt;String&lt;/code&gt; 值的代码，并通过索引该切片并克隆值来创建 &lt;code&gt;Config&lt;/code&gt; 结构的实例，从而使 &lt;code&gt;Config&lt;/code&gt; 结构拥有这些值。在清单13-24中，我们复制了清单12-23 中的 &lt;code&gt;Config::new&lt;/code&gt; 函数的实现：</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">在清单12-8中，我们在 &lt;code&gt;new&lt;/code&gt; 函数中添加了一个检查，该检查将在访问索引1和2之前验证切片是否足够长。如果切片不够长，则程序会产生恐慌并显示出比错误消息更好的错误消息。 &lt;code&gt;index out of bounds&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">在清单13-18中，我们收集了从调用 &lt;code&gt;map&lt;/code&gt; 返回到向量的迭代器上迭代的迭代结果。此向量最终将包含原始向量中每一项递增1的各项。</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">在清单13-19中，我们使用带有闭包的 &lt;code&gt;filter&lt;/code&gt; ，该闭包从其环境中捕获 &lt;code&gt;shoe_size&lt;/code&gt; 变量以遍历 &lt;code&gt;Shoe&lt;/code&gt; 结构实例的集合。它只会返回指定尺寸的鞋子。</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">在清单15-19中，我们将更改 &lt;code&gt;main&lt;/code&gt; ，使其在列表 &lt;code&gt;c&lt;/code&gt; 的内部具有范围；然后我们可以看到 &lt;code&gt;c&lt;/code&gt; 超出范围时引用计数如何变化。</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">在清单15-26中，我们添加了一个使用清单15-25中的定义的 &lt;code&gt;main&lt;/code&gt; 函数。此代码创建列表中的 &lt;code&gt;a&lt;/code&gt; ，并在列表 &lt;code&gt;b&lt;/code&gt; ，它指向列表中的 &lt;code&gt;a&lt;/code&gt; 。然后，它将 &lt;code&gt;a&lt;/code&gt; 中的列表修改为指向 &lt;code&gt;b&lt;/code&gt; ，从而创建一个参考循环。有 &lt;code&gt;println!&lt;/code&gt; 语句，以显示在此过程中各个点的引用计数。</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">在清单16-8中，我们将从主线程中通道的接收端获取值。这就像从河底的水中取回橡皮鸭一样，或者得到聊天消息。</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">在清单18-11中，我们提到可以使用匹配防护来解决我们的模式隐藏问题。回想一下，在 &lt;code&gt;match&lt;/code&gt; 表达式中的模式内部创建了一个新变量，而不是在 &lt;code&gt;match&lt;/code&gt; 之外使用该变量。这个新变量意味着我们无法针对外部变量的值进行测试。清单18-27显示了如何使用匹配保护器解决此问题。</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">在清单7-11中，我们把 &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; 模块插入的范围 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 功能，所以我们只需要指定 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 功能 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">在清单7-11中，您可能想知道为什么我们指定 &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; 然后在 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中调用 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; ，而不是一直指定到 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数的 &lt;code&gt;use&lt;/code&gt; 路径来获得相同的结果，如清单7-13所示。</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">在方法定义中</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">在Rust 1.3中，如&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156中&lt;/a&gt;所述，默认对象生存期界限应该发生变化。之所以会发出警告，是因为编译器认为此更改可能会导致代码中的编译错误。尽管不太可能，但这是一个错误的警报。</target>
        </trans-unit>
        <trans-unit id="024c5bd925d0560baf0e3312c1764bcb998284df" translate="yes" xml:space="preserve">
          <source>In Rust 2015, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the crate root. To import items relative to the current and parent modules, use the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes, respectively.</source>
          <target state="translated">在Rust 2015中， &lt;code&gt;use&lt;/code&gt; 路径声明是相对于板条箱根的。要导入相对于当前模块和父模块的项目，请分别使用 &lt;code&gt;self::&lt;/code&gt; 和 &lt;code&gt;super::&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="e1dd28b00244d1766f66dc28a5630ffdd59cfac9" translate="yes" xml:space="preserve">
          <source>In Rust 2018 the &lt;code&gt;extern crate&lt;/code&gt; declaration is not required and you can instead just &lt;code&gt;use&lt;/code&gt; it:</source>
          <target state="translated">在Rust 2018中，不需要 &lt;code&gt;extern crate&lt;/code&gt; 声明，您可以改为 &lt;code&gt;use&lt;/code&gt; 它：</target>
        </trans-unit>
        <trans-unit id="b256b3c7dd03072851511683d3f9db1e7f94539a" translate="yes" xml:space="preserve">
          <source>In Rust 2018, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the current module unless they begin with the name of a crate or a literal &lt;code&gt;crate::&lt;/code&gt;, in which case they start from the crate root. As in Rust 2015 code, the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes refer to the current and parent modules respectively.</source>
          <target state="translated">在Rust 2018中， &lt;code&gt;use&lt;/code&gt; 语句是相对于当前模块的，除非它们以板条箱名或文字 &lt;code&gt;crate::&lt;/code&gt; 名:::开头，在这种情况下，它们从板条箱根开始。与Rust 2015代码一样， &lt;code&gt;self::&lt;/code&gt; 和 &lt;code&gt;super::&lt;/code&gt; 前缀分别引用当前模块和父模块。</target>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">在Rust中,如果一个函数惊慌失措,或者调用了一个中途惊慌失措的函数,它就会提前 &quot;返回&quot;。这种控制流并不总是被预料到的,并且有可能通过两个关键组件的组合造成微妙的错误。</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">在Rust中，&lt;em&gt;发布配置文件&lt;/em&gt;是具有不同配置的预定义和可自定义的配置文件，使程序员可以更好地控制各种用于编译代码的选项。每个配置文件均独立配置。</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">在Rust中，注释必须以两个斜杠开头，并一直持续到该行的末尾。对于超出一行的注释，您需要在每行上加上 &lt;code&gt;//&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">在Rust中，全局变量称为&lt;em&gt;静态&lt;/em&gt;变量。清单19-9显示了一个示例声明和一个静态变量的使用，该静态变量将字符串切片作为值。</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">在Rust中，集成测试完全在您的库外部。他们以与其他任何代码相同的方式使用您的库，这意味着它们只能调用属于您库的公共API的函数。它们的目的是测试库的许多部分是否可以正常协同工作。单独正确运行的代码单元在集成时可能会出现问题，因此测试集成代码的覆盖范围也很重要。要创建集成测试，首先需要一个&lt;em&gt;tests&lt;/em&gt;目录。</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">在Rust中，通常为不同的用例提供类型的不同表示形式。例如，可以通过诸如&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;类的指针类型，为特定用途适当地选择值的存储位置和管理。除了这些可以用于任何类型的通用包装器之外，某些类型还提供了可选的构面，从而提供了可能昂贵的功能。这种类型的一个例子是&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;，它增加了将字符串扩展到基本&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 的功能&lt;/a&gt;。这要求保持简单的，不变的字符串不需要的附加信息。</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Rust中，当您只想提供读取访问权限时，通常将切片作为参数而不是向量传递。这同样适用于&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa445d9bc6ce3579a8b9343d188f81a07982bc87" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Rust中，当您只想提供读取访问权限时，通常将切片作为参数而不是向量传递。这同样适用于&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">在Rust中，迭代器是&lt;em&gt;lazy&lt;/em&gt;，这意味着它们直到您调用消耗该迭代器的方法以将其耗尽为止才有效。例如，清单13-13中的代码通过调用 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 上定义的 &lt;code&gt;iter&lt;/code&gt; 方法，在向量 &lt;code&gt;v1&lt;/code&gt; 中的项目上创建了一个迭代器。这段代码本身没有任何用处。</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">在Rust中，某些简单类型是&amp;ldquo;隐式可复制的&amp;rdquo;，当您将它们分配或作为参数传递时，接收方将获得一个副本，而将原始值保留在原位。这些类型不需要分配就可以复制并且没有终结器（即，它们不包含拥有的盒子或实现&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;），因此编译器认为它们便宜且安全地复制。对于其他类型，必须按照惯例实现&lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; trait并调用&lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;方法来显式地进行复制。</target>
        </trans-unit>
        <trans-unit id="2fcd990460e8b6d0fc26ae7880ea98a98c91ad7c" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">在Rust中，一些简单类型是&amp;ldquo;隐式可复制的&amp;rdquo;，当您将它们分配或将其作为参数传递时，接收方将获得一个副本，而将原始值保留在原位。这些类型不需要分配就可以复制并且没有终结器（即，它们不包含拥有的盒子或实现&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;），因此编译器认为它们便宜且安全地进行复制。对于其他类型，必须通过实现&lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; trait并调用&lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;方法的约定显式地进行复制。</target>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">在Rust中，某些类型在编译时没有已知大小。例如，在像 &lt;code&gt;[u32]&lt;/code&gt; 这样的切片类型中，元素数量在编译时未知，因此无法计算总体大小。结果，只能通过引用（例如 &lt;code&gt;&amp;amp;T&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）或其他指针类型（例如 &lt;code&gt;Box&lt;/code&gt; 或 &lt;code&gt;Rc&lt;/code&gt; ）来操纵此类类型。尝试强制转换为参考：</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">在Rust中,字符串总是有效的UTF-8,其中可能包含0。</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">在Rust中，编译器保证当您声明一个值不会更改时，它实际上不会更改。这意味着在阅读和编写代码时，不必跟踪值的更改方式和位置。因此，您的代码更易于推理。</target>
        </trans-unit>
        <trans-unit id="187bd10d150e89528422d52ad5b94f3768fbf136" translate="yes" xml:space="preserve">
          <source>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">在Rust中，惯用注释样式以两个斜杠开始注释，并且注释一直持续到行尾。对于超出一行的注释，您需要在每行上加上 &lt;code&gt;//&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">在 Rust 中,进入数组的值被写成一个方括号内的逗号分隔的列表。</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">在使用所有权和借用概念的Rust中，引用和智能指针之间的另一个区别是，引用是仅借用数据的指针。相反，在许多情况下，智能指针&lt;em&gt;拥有&lt;/em&gt;它们指向的数据。</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">在 Rust 中,你只能在编译时知道一个值的大小时才能移动它。</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">在结构定义中</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">在土耳其语中,相当于拉丁语中的 &quot;i &quot;有五种形式,而不是两种。</target>
        </trans-unit>
        <trans-unit id="95435691c2a2f4eefe5ecbf90205f41c0b8b41fb" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; definition and related &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">在&lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt;定义和相关的&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt;块中：</target>
        </trans-unit>
        <trans-unit id="3b57043cd55b10d931a7fc7d67ec1a60b6e68743" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type and not in the arguments types.</source>
          <target state="translated">在 &lt;code&gt;fn&lt;/code&gt; 类型中，生存期仅出现在返回类型中，而不出现在参数类型中。</target>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">在 &lt;code&gt;fn&lt;/code&gt; 类型中，生存期仅出现在返回类型中，而不出现在参数类型中。</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在给定的程序中，标准库具有一个&amp;ldquo;全局&amp;rdquo;内存分配器，例如， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 使用该分配器。</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">在匹配表达式中,只能将数字和字符与一个范围进行匹配,这是因为编译器在编译时检查范围是非空的,无法评估任意比较函数。这是因为编译器在编译时检查范围是非空的,并且无法评估任意的比较函数。如果你想在两个端点之间捕获一个可排序类型的值,你可以使用守卫。</target>
        </trans-unit>
        <trans-unit id="33cf96775891f63612a2b18790b9f75c00ddb97e" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both (1.) the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; (2.) the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">在更理想的世界中，我们可以通过仅检查给定类型既实现（1.） &lt;code&gt;StructuralPartialEq&lt;/code&gt; 特征&lt;em&gt;又实现&lt;/em&gt;（2.） &lt;code&gt;Eq&lt;/code&gt; 特征来检查该需求。但是，您可以使用&lt;em&gt;确实&lt;/em&gt; &lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt; ADT，&lt;em&gt;这&lt;/em&gt;是我们希望编译器接受的情况，但是常量的类型无法实现 &lt;code&gt;Eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebeafd71108fc97e3607fbd0638300cd9c65eab5" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">在更理想的世界中，我们可以通过仅检查给定类型既实现了 &lt;code&gt;StructuralPartialEq&lt;/code&gt; 特性&lt;em&gt;又&lt;/em&gt;实现 &lt;code&gt;Eq&lt;/code&gt; 特性来检查该要求。但是，您可以使用&lt;em&gt;确实&lt;/em&gt; &lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt; ADT，&lt;em&gt;这&lt;/em&gt;是我们希望编译器接受的情况，但是常量的类型无法实现 &lt;code&gt;Eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">在模式中，所有未实现 &lt;code&gt;Copy&lt;/code&gt; trait的值都必须以相同的方式绑定。此处的目标是避免同时通过by-ref和by-ref进行绑定。</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">在一个模式中:包含范围模式</target>
        </trans-unit>
        <trans-unit id="83c0ddf34fdbd1317fa94180ff2437b5be9c9767" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from a &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt;, calling it again may or may not ever return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; again. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; are interchangeable for this purpose.</source>
          <target state="translated">以与&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;协议类似的方式，一旦 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 从&lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt; &lt;code&gt;next_back()&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则再次调用它可能会或可能不会再次返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt; &lt;code&gt;next_back()&lt;/code&gt; &lt;/a&gt;可以互换使用。</target>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">以类似于&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;协议的方式，一旦 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 从 &lt;code&gt;next_back()&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; ，则再次调用它可能会或可能不会再次返回 &lt;code&gt;Some&lt;/code&gt; 。 &lt;code&gt;next()&lt;/code&gt; 和 &lt;code&gt;next_back()&lt;/code&gt; 可以互换使用。</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">从某种意义上说，任何编程语言中的通道都类似于单一所有权，因为一旦在通道下传递了值，就不应再使用该值。共享内存并发就像是多个所有权：多个线程可以同时访问同一内存位置。正如您在第15章中看到的那样，智能指针使多重所有权成为可能，多重所有权会增加复杂性，因为这些不同的所有者需要管理。 Rust的类型系统和所有权规则在很大程度上有助于正确地进行管理。例如，让我们看一下互斥锁，互斥锁是共享内存中最常见的并发原语之一。</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">除在不可变上下文中与（一元） &lt;code&gt;*&lt;/code&gt; 运算符一起用于显式解引用操作外，在许多情况下，编译器都将隐式使用 &lt;code&gt;Deref&lt;/code&gt; 。这种机制称为&lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&amp;ldquo; &lt;code&gt;Deref&lt;/code&gt; 强制&amp;rdquo;&lt;/a&gt;。在可变上下文中，使用&lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">除在可变上下文中与（一元） &lt;code&gt;*&lt;/code&gt; 运算符一起用于显式解引用操作外，在许多情况下，编译器都将隐式使用 &lt;code&gt;DerefMut&lt;/code&gt; 。这种机制称为&lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&amp;ldquo; &lt;code&gt;Deref&lt;/code&gt; 强制&amp;rdquo;&lt;/a&gt;。在不可变的上下文中，使用&lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">除了检查我们的代码是否返回了我们期望的正确值外，检查我们的代码是否按预期处理错误条件也很重要。例如，考虑我们在清单9-10的第9章中创建的 &lt;code&gt;Guess&lt;/code&gt; 类型。其他使用 &lt;code&gt;Guess&lt;/code&gt; 的代码取决于保证 &lt;code&gt;Guess&lt;/code&gt; 实例将只包含1到100之间的值。我们可以编写测试来确保尝试创建一个值超出该范围的 &lt;code&gt;Guess&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">除了通过模式匹配进行结构分解外，我们还可以通过使用句点（ &lt;code&gt;.&lt;/code&gt; ）和要访问的值的索引直接访问元组元素。例如：</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">除了装配所述存储器块 &lt;code&gt;layout&lt;/code&gt; ，所述的对准 &lt;code&gt;layout&lt;/code&gt; 必须与用于分配的存储器块中的对准相匹配。</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">除了分组功能之外，封装实现细节还使您可以在更高级别上重用代码：实现操作后，其他代码可以通过代码的公共接口调用该代码，而无需了解实现的工作方式。编写代码的方式定义了哪些部分是公共的，供其他代码使用，哪些部分是私有的实现细节，您保留更改权。这是限制必须保留在脑海中的细节量的另一种方法。</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">除了以 &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; 的形式显示固定类型之外，函数还可以声明类型参数列表以及它们所处的特征范围。</target>
        </trans-unit>
        <trans-unit id="d6b811c43ad4130bc5a6536fe58f23b2b67258a1" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">除了公共和私有之外，Rust允许用户将某项声明为仅在给定范围内可见。对于规则 &lt;code&gt;pub&lt;/code&gt; 是限制如下：</target>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">除了公共和私有之外，Rust允许用户将某项声明为在给定范围内可见。对于规则 &lt;code&gt;pub&lt;/code&gt; 是限制如下：</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">除了&lt;a href=&quot;#implementors&quot;&gt;下面列出&lt;/a&gt;的实现者之外，以下类型还可以实现 &lt;code&gt;Clone&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">除了&lt;a href=&quot;#implementors&quot;&gt;下面列出&lt;/a&gt;的实现者之外，以下类型还实现了 &lt;code&gt;Copy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">除了 &lt;code&gt;#[cfg]&lt;/code&gt; 属性之外，还提供了此宏以允许对配置标志进行布尔表达式评估。这经常导致重复代码更少。</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了按&lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt;返回的已解析&lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt;信息之外， &lt;code&gt;PrefixComponent&lt;/code&gt; 还保存由&lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; &lt;/a&gt;返回的原始和未解析的&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;切片。</target>
        </trans-unit>
        <trans-unit id="5eb0888677903038da8d3a6a5332c2add97dc4d4" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了按&lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt;返回的已解析&lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt;信息之外， &lt;code&gt;PrefixComponent&lt;/code&gt; 还保存由&lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; &lt;/a&gt;返回的原始和未解析的&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;切片。</target>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">除了根据其签名而有所不同之外，函数指针还具有两种形式：安全和不安全。普通的 &lt;code&gt;fn()&lt;/code&gt; 函数指针只能指向安全函数，而不 &lt;code&gt;unsafe fn()&lt;/code&gt; 函数指针可以指向安全或不安全函数。</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">此外， &lt;code&gt;unsafe&lt;/code&gt; 并不意味着该块内的代码必然是危险的，或者肯定会存在内存安全问题：目的是，作为程序员，您将确保 &lt;code&gt;unsafe&lt;/code&gt; 块内的代码将以有效方式访问内存。 。</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">此外，&lt;em&gt;任何&lt;/em&gt;签名，ABI或安全性的函数指针都是&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，并且所有&lt;em&gt;安全&lt;/em&gt;函数指针都实现&lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;。之所以可行，是因为这些特性是编译器特有的。</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">另外，这暗示了一种设计选择：Rust永远不会自动创建数据的&amp;ldquo;深层&amp;rdquo;副本。因此，就运行时性能而言，任何&lt;em&gt;自动&lt;/em&gt;复制都可以被认为是廉价的。</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">此外，我们还将介绍&lt;em&gt;内部可变性&lt;/em&gt;模式，其中不可变类型公开了用于改变内部值的API。我们还将讨论&lt;em&gt;参考周期&lt;/em&gt;：它们如何泄漏内存以及如何防止内存泄漏。</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">在第二支臂中 &lt;code&gt;_&lt;/code&gt; 模式表示的所有其他情况下（如果 &lt;code&gt;setting_value&lt;/code&gt; 或 &lt;code&gt;new_setting_value&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ），我们希望允许 &lt;code&gt;new_setting_value&lt;/code&gt; 成为 &lt;code&gt;setting_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">在所有其他情况下,属性会被忽略。</target>
        </trans-unit>
        <trans-unit id="7d8a9a3640946afedd6187bd88567e66ef40d8ba" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, if we want to return the &lt;code&gt;Born&lt;/code&gt; variant from the &lt;code&gt;Dragon&lt;/code&gt; enum, we must set the function to return the enum and not its variant:</source>
          <target state="translated">在所有这些错误中，应该使用一种类型。例如，在第一个错误中，如果要从 &lt;code&gt;Dragon&lt;/code&gt; 枚举返回 &lt;code&gt;Born&lt;/code&gt; 变体，则必须将函数设置为返回枚举而不是其变体：</target>
        </trans-unit>
        <trans-unit id="a19757cafa1e47c029cbe2ba1f57c4bdca558327" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the &lt;code&gt;Mordor&lt;/code&gt; module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</source>
          <target state="translated">在所有这些错误中，应该使用一种类型。例如，在第一个错误中，我们尝试实例化 &lt;code&gt;Mordor&lt;/code&gt; 模块，这是不可能的。如果要实例化模块内的类型，可以按以下步骤进行操作：</target>
        </trans-unit>
        <trans-unit id="c47f29567923fe326970ee49948a1a1d55a18345" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">在&lt;a href=&quot;keyword.extern&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt;块中：</target>
        </trans-unit>
        <trans-unit id="1f98ac0f1fa0dec56de41fe3ea37987b03944662" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="translated">在&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt;块中：</target>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">在一个侵入式双链路列表中,集合实际上并不为元素本身分配内存。分配是由客户端控制的,元素可以活在一个比集合活得更短的堆栈框架上。</target>
        </trans-unit>
        <trans-unit id="d614cd101c88d0fcc72d7ca1ff622264cb285eeb" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">在较大的程序中，使用嵌套路径将多个项目从同一板条箱或模块引入范围可以减少很多所需的单独 &lt;code&gt;use&lt;/code&gt; 语句的数量！</target>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">在更大的程序中，使用嵌套路径将同一包或模块中的许多项目纳入范围可以减少很多单独的 &lt;code&gt;use&lt;/code&gt; 语句！</target>
        </trans-unit>
        <trans-unit id="411e743273ff9b097675015034e11f98bb60f0a1" translate="yes" xml:space="preserve">
          <source>In both cases, we're declaring a variable (called &lt;code&gt;_&lt;/code&gt;) and we're giving it a type. However, &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; and &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; aren't types, therefore the compiler throws an error.</source>
          <target state="translated">在这两种情况下，我们都声明一个变量（称为 &lt;code&gt;_&lt;/code&gt; ），并为其指定类型。但是， &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; 和 &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; 不是类型，因此编译器会引发错误。</target>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">在这两个示例中，&amp;ldquo;&amp;szlig;&amp;rdquo;需要两个字节进行编码。</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">在这两个示例中，&amp;ldquo;𝕊&amp;rdquo;需要两个 &lt;code&gt;u16&lt;/code&gt; 进行编码。</target>
        </trans-unit>
        <trans-unit id="3bd0c40bcc38a21de271423b14aaff21406fde9d" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">在匹配器和转录器中， &lt;code&gt;$&lt;/code&gt; 令牌用于从宏引擎调用特殊行为（下面在&lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt;和&lt;a href=&quot;#repetitions&quot;&gt;Repetitions中进行了&lt;/a&gt;描述）。不属于此类调用的令牌将按字面进行匹配和转录，但有一个例外。唯一的例外是匹配器的外部定界符将匹配任何一对定界符。因此，例如，匹配器 &lt;code&gt;(())&lt;/code&gt; 将匹配 &lt;code&gt;{()}&lt;/code&gt; 而不是 &lt;code&gt;{{}}&lt;/code&gt; 。字符 &lt;code&gt;$&lt;/code&gt; 不能字面匹配或转录。</target>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">在匹配器和转录器中， &lt;code&gt;$&lt;/code&gt; 令牌均用于从宏引擎调用特殊行为（以下在&lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt;和&lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions中进行了&lt;/a&gt;描述）。不属于此类调用的令牌将按字面进行匹配和转录，只有一个例外。唯一的例外是匹配器的外部定界符将匹配任何一对定界符。因此，例如，匹配器 &lt;code&gt;(())&lt;/code&gt; 将匹配 &lt;code&gt;{()}&lt;/code&gt; 而不是 &lt;code&gt;{{}}&lt;/code&gt; 。字符 &lt;code&gt;$&lt;/code&gt; 不能字面匹配或转录。</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">在匹配器和转录器中，通过将要重复的令牌放置在 &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; 内，然后是重复运算符（可选地在两者之间使用分隔符）来表示重复。分隔符令牌可以是除定界符或重复运算符之一以外的任何令牌，但 &lt;code&gt;;&lt;/code&gt; 和 &lt;code&gt;,&lt;/code&gt; 是最常见的。例如， &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 表示任意数量的标识符，用逗号分隔。嵌套重复是允许的。</target>
        </trans-unit>
        <trans-unit id="bda412bf4ac443ace6b933eedb9b5ef6ed17c2eb" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;self&lt;/code&gt; is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是指向未确定大小类型的（胖）指针，则此操作仅会影响指针部分，而对于指向已确定大小的类型的（瘦）指针，这与简单赋值具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">如果是 &lt;code&gt;Err&lt;/code&gt; 变体，它将检索内部错误。 &lt;code&gt;try!&lt;/code&gt; 然后使用 &lt;code&gt;From&lt;/code&gt; 进行转换。这样可以在特殊错误和更常见错误之间进行自动转换。然后立即返回产生​​的错误。</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">如果该项是 &lt;code&gt;impl&lt;/code&gt; 内的函数，则定义私有帮助器函数可能会更容易：</target>
        </trans-unit>
        <trans-unit id="e819f47e8194440086ecc95f22e7c6f58bfe9e72" translate="yes" xml:space="preserve">
          <source>In case you want to document the item following the doc comment, you might want to use outer doc comment:</source>
          <target state="translated">如果你想在 doc 注释后面记录项目,你可能需要使用外层 doc 注释。</target>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">如果存在许多嵌套模块，则在使用 &lt;code&gt;pub use&lt;/code&gt; 下在顶层重新导出类型会极大地影响使用板条箱的人员的体验。</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">在某些情况下，Rust没有足够的信息来进行这种转换，称为&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;强制转换。在以下示例中，字符串slice &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt;实现了特征 &lt;code&gt;TraitExample&lt;/code&gt; ，而函数 &lt;code&gt;example_func&lt;/code&gt; 则采用了实现该特征的任何东西。在这种情况下，Rust需要进行两次隐式转换，Rust没有办法进行转换。因此，以下示例将无法编译。</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">在某些情况下,子绑定有可能违反内存安全。在未来版本的Rust中,借贷检查器的更新可能会取消这一限制,但目前必须在没有子绑定的情况下重写模式。</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">相比之下，&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;不会区分获取锁的读取器或写入器，因此会阻塞等待锁可用的所有线程。一个 &lt;code&gt;RwLock&lt;/code&gt; 允许，只要任意数量的读者获取锁作为一个作家不持有锁。</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">总结:在做之前一定要检查你想得到的索引是否真的存在。</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">相反，如果我们将某个枚举公开，则其所有变体都将公开。我们只需要 &lt;code&gt;pub&lt;/code&gt; 在 &lt;code&gt;enum&lt;/code&gt; 关键字之前，如清单7-10所示。</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">相反，Rust中的语句&lt;em&gt;主要&lt;/em&gt;用于包含和显式排序表达式评估。</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">相比之下，清单19-7 中 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 的使用可能在使用slice时崩溃。此代码占用任意内存位置，并创建一个10,000个项目的切片。</target>
        </trans-unit>
        <trans-unit id="b352fcdc1230066708e3119b26e7a9dddf361692" translate="yes" xml:space="preserve">
          <source>In each such case, there are a set of types &lt;code&gt;T0..Tn&lt;/code&gt; to be mutually coerced to some target type &lt;code&gt;T_t&lt;/code&gt;, which is unknown to start. Computing the LUB coercion is done iteratively. The target type &lt;code&gt;T_t&lt;/code&gt; begins as the type &lt;code&gt;T0&lt;/code&gt;. For each new type &lt;code&gt;Ti&lt;/code&gt;, we consider whether</source>
          <target state="translated">在每种这样的情况下，都有一组类型 &lt;code&gt;T0..Tn&lt;/code&gt; 被相互强制为某个目标类型 &lt;code&gt;T_t&lt;/code&gt; ，而目标类型T_t开始时是未知的。LUB强制的计算是迭代完成的。目标类型 &lt;code&gt;T_t&lt;/code&gt; 从类型 &lt;code&gt;T0&lt;/code&gt; 开始。对于每个新类型 &lt;code&gt;Ti&lt;/code&gt; ，我们考虑是否</target>
        </trans-unit>
        <trans-unit id="759bae86a2327a6965c49083e94e3f6d305cc988" translate="yes" xml:space="preserve">
          <source>In either of the two scenarios above, we reject usage of such a constant in a pattern match.</source>
          <target state="translated">在上述两种情况下,我们拒绝在模式匹配中使用这种常量。</target>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">本质上， &lt;code&gt;*const c_void&lt;/code&gt; 等效于C的 &lt;code&gt;const void*&lt;/code&gt; 而 &lt;code&gt;*mut c_void&lt;/code&gt; 等效于C的 &lt;code&gt;void*&lt;/code&gt; 。这就是说，这是&lt;em&gt;不是&lt;/em&gt;同C的 &lt;code&gt;void&lt;/code&gt; 返回类型，这是除锈的 &lt;code&gt;()&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">在函数签名中，&lt;em&gt;必须&lt;/em&gt;声明每个参数的类型。这是Rust设计中的一个故意决定：在函数定义中需要类型注释，这意味着编译器几乎不需要您在代码的其他地方使用它们来弄清楚您的意思。</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">通常，-- &lt;code&gt;--crate-type=bin&lt;/code&gt; 或 &lt;code&gt;--crate-type=lib&lt;/code&gt; 应该足以满足所有编译需求，而如果需要对包装箱的输出格式进行更细粒度的控制，则其他选项才可用。</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">通常，C ++实现遵循零开销原则：您不用的东西，不用花钱。更进一步：您使用的是什么，您再也无法编写更好的代码了。</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">通常，任何可以通过指定类型执行的强制转换也可以使用 &lt;code&gt;as&lt;/code&gt; 来完成，因此，与其编写 &lt;code&gt;let x: u32 = 123&lt;/code&gt; ，还可以将 &lt;code&gt;let x = 123 as u32&lt;/code&gt; 编写为u32（注意： &lt;code&gt;let x: u32 = 123&lt;/code&gt; 可以在这种情况下最好）。在另一个方向上却不是这样，但是，显式地使用 &lt;code&gt;as&lt;/code&gt; 可以允许更多隐式不允许的强制，例如更改原始指针的类型或将闭包转换为原始指针。</target>
        </trans-unit>
        <trans-unit id="3ee5af53911e508508beef41bbd5529b831af173" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however; explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">在一般情况下，可通过归咎于类型进行任何投也可以用做 &lt;code&gt;as&lt;/code&gt; ，所以不是写 &lt;code&gt;let x: u32 = 123&lt;/code&gt; ，你可以写 &lt;code&gt;let x = 123 as u32&lt;/code&gt; （注： &lt;code&gt;let x: u32 = 123&lt;/code&gt; 将在这种情况下最好）。但是，在另一个方向上并非如此。显式使用 &lt;code&gt;as&lt;/code&gt; 允许更多隐式不允许的强制，例如更改原始指针的类型或将闭包转换为原始指针。</target>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">通常，由于此功能可能会引起恐慌，因此不建议使用该功能。相反，更喜欢使用模式匹配并显式处理&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;情况。</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">一般来说,完全限定语法的定义如下。</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">通常，为了使用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 值，您需要具有可处理每个变体的代码。你想一些代码，当你有一个，将只能运行 &lt;code&gt;Some(T)&lt;/code&gt; 的值，该代码被允许使用内部 &lt;code&gt;T&lt;/code&gt; 。如果您具有 &lt;code&gt;None&lt;/code&gt; 值，并且该代码没有可用的 &lt;code&gt;T&lt;/code&gt; 值，则希望运行其他代码。该 &lt;code&gt;match&lt;/code&gt; 表达式是一个控制流构建体与枚举使用时，不只是这样的：它会因它具有枚举的所述变体运行不同的代码，该代码可以使用匹配值内的数据。</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">一般来说,类型的大小在不同的编译中是不稳定的,但特定的类型,如基元,是稳定的。</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">通常，这本书假定您从前到后依次阅读。后面的章节以前面的章节中的概念为基础，而前面的章节可能不会深入研究某个主题。我们通常会在下一章中重新讨论该主题。</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">总的来说，您不必担心可重用和不可重用模式之间的区别。但是，您确实需要熟悉可引用性的概念，以便在错误消息中看到它时可以做出响应。在这些情况下，您需要根据代码的预期行为来更改模式或使用该模式的构造。</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">在这里， &lt;code&gt;jon_snow&lt;/code&gt; 引用已经借用了 &lt;code&gt;nights_watch&lt;/code&gt; ，因此 &lt;code&gt;starks&lt;/code&gt; 闭包不能同时借用它。要解决此问题，可以在借用结束后创建闭包：</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">在这里， &lt;code&gt;x&lt;/code&gt; 是不可变的，因此当我们尝试以可变方式借入 &lt;code&gt;y&lt;/code&gt; 时，它将失败。要解决此错误，您需要使 &lt;code&gt;x&lt;/code&gt; 可变：</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">在这里， &lt;code&gt;y&lt;/code&gt; 在内部作用域的末尾删除，但是 &lt;code&gt;x&lt;/code&gt; 借用了它，直到 &lt;code&gt;println&lt;/code&gt; 为止。要修复前面的示例，只需删除范围，以便在println之后才删除 &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">Edsger W. Dijkstra在1972年的文章&amp;ldquo;谦虚的程序员&amp;rdquo;中说：&amp;ldquo;程序测试可以是显示错误存在的一种非常有效的方法，但是毫无希望地不足以表明错误的存在。&amp;rdquo; 这并不意味着我们不应该尝试尽可能多地测试！</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">null的发明者Tony Hoare在2009年的演讲&amp;ldquo; Null References：十亿美元的错误&amp;rdquo;中说：</target>
        </trans-unit>
        <trans-unit id="c66d30f8ac627ea5119575fc56779340f4bd49e0" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">在不可变上下文中， &lt;code&gt;*x&lt;/code&gt; （其中 &lt;code&gt;T&lt;/code&gt; 既不是引用也不是原始指针）等效于 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">在不可变的上下文中，非指针类型上的 &lt;code&gt;*x&lt;/code&gt; 等效于 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">在其线程中， &lt;code&gt;Worker&lt;/code&gt; 将在其通道的接收方上循环并执行其接收到的所有作业的关闭。</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">在没有标准库提供迭代器的语言中，您可能会编写相同的功能，方法是在索引0处启动变量，使用该变量索引向量以获得值，然后在循环中递增变量值直到达到向量中的项目总数。</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">在带有指针的语言中，很容易错误地创建一个&lt;em&gt;悬空指针&lt;/em&gt;，即通过在保留指向该内存的指针的同时释放一些内存来引用可能已分配给他人的内存中某个位置的指针。相比之下，在Rust中，编译器保证引用永远不会成为悬挂引用：如果您对某些数据有引用，则编译器将确保数据不会超出对数据的引用范围。</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">在许多其他编程语言中，通过按索引引用来访问字符串中的单个字符是有效且常见的操作。但是，如果尝试在Rust中使用索引语法访问 &lt;code&gt;String&lt;/code&gt; 的某些部分，则会收到错误消息。考虑清单8-19中的无效代码。</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">在许多编程语言中，您不必经常考虑堆栈和堆。但是在像Rust这样的系统编程语言中，值是在堆栈上还是在堆上对语言的行为以及为什么必须做出某些决定具有更大的影响。所有权的各个部分将在本章后面的堆栈和堆中进行介绍，因此这里是准备工作的简要说明。</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">在 &lt;code&gt;impl&lt;/code&gt; 块内的方法签名中，引用可能与结构字段中引用的生存期相关，或者它们可能是独立的。此外，生存期省略规则通常使之成为必需，因此在方法签名中不需要生存期批注。让我们看一下使用清单10-25中定义的名为 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 的结构的一些示例。</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">在方法签名中,还有一条规则</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">在更实际的代码中，Rust通常可以在插入值后就推断出要存储的值的类型，因此您几乎不需要执行此类型注释。创建具有初始值的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 更为常见，而Rust提供了 &lt;code&gt;vec!&lt;/code&gt; 为方便起见。宏将创建一个新向量，其中包含您提供的值。清单8-2创建一个新的 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 保持的值 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，和 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa2c751f0fffe581147bea700ab4a27b2b536a1b" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;. The integer type is &lt;code&gt;i32&lt;/code&gt; because that&amp;rsquo;s the default integer type, as we discussed in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">在更实际的代码中，Rust通常可以在插入值后就推断出要存储的值的类型，因此您几乎不需要执行此类型注释。创建具有初始值的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 更为常见，而Rust提供了 &lt;code&gt;vec!&lt;/code&gt; 宏为方便起见。宏将创建一个新向量，其中包含您提供的值。清单8-2创建一个新的 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 保持的值 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，和 &lt;code&gt;3&lt;/code&gt; 。整数类型为 &lt;code&gt;i32&lt;/code&gt; ,因为这是默认的整数类型，正如我们在第3章的&lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;数据类型&amp;rdquo;&lt;/a&gt;一节中所讨论的那样。</target>
        </trans-unit>
        <trans-unit id="f61ae2da01f7f174aa9072fda333fb0da9180ccf" translate="yes" xml:space="preserve">
          <source>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use &lt;code&gt;cfg_attr&lt;/code&gt;. Example:</source>
          <target state="translated">在大多数情况下（如果不是全部），仅使用一个表示提示就绰绰有余了。如果要根据当前体系结构使用表示形式提示，请使用 &lt;code&gt;cfg_attr&lt;/code&gt; 。例子：</target>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">在大多数情况下，当您不再需要特定的功能参数时，可以更改签名，使其不包括未使用的参数。忽略函数参数在某些情况下尤其有用，例如，当需要特定类型签名但实现中的函数主体不需要参数之一时实现特征时。然后，编译器将不会警告未使用的函数参数，就像使用名称代替一样。</target>
        </trans-unit>
        <trans-unit id="85959f6561074f86f5f458df7e8bde59a19923db" translate="yes" xml:space="preserve">
          <source>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</source>
          <target state="translated">在大多数情况下,要么是忘记了导入,要么是打错了。然而,让我们看看如何才能拥有这样的类型。</target>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">在大多数情况下,引用的使用可以和原始值一样。字段访问、方法调用和索引的工作方式都是一样的(当然,可变性规则除外)。此外,比较运算符透明地服从于引用的实现,允许引用与拥有的值一样进行比较。</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">在大多数当前的操作系统中，已执行程序的代码在一个&lt;em&gt;进程中&lt;/em&gt;运行，并且操作系统一次管理多个进程。在您的程序中，您还可以具有可以同时运行的独立部分。运行这些独立部分的功能称为&lt;em&gt;线程&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">在大多数情况下，我们会将您引向任何未编译代码的正确版本。</target>
        </trans-unit>
        <trans-unit id="c68d3ee8b930a30d24c024ab8aa0750ac37303d5" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">在可变上下文中， &lt;code&gt;*x&lt;/code&gt; （其中 &lt;code&gt;T&lt;/code&gt; 既不是引用也不是原始指针）等效于 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">在可变上下文中，非指针类型上的 &lt;code&gt;*x&lt;/code&gt; 等效于 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">在一个编译会话中，编译器可以通过使用命令行标志或 &lt;code&gt;crate_type&lt;/code&gt; 属性来生成多个工件。如果指定了一个或多个命令行标志，则将忽略所有 &lt;code&gt;crate_type&lt;/code&gt; 属性，而仅构建命令行指定的构件。</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">在某种程度上，该程序更好。元组让我们增加了一些结构，现在我们只传递一个参数。但是以另一种方式，此版本不太明确：元组未命名其元素，因此我们的计算变得更加混乱，因为我们必须索引元组的各个部分。</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">为了让类型实现这个特点，它不仅要为每个方法提供实现，但必须指定类型 &lt;code&gt;E&lt;/code&gt; 。这是标准库类型 &lt;code&gt;Vec&lt;/code&gt; 的 &lt;code&gt;Container&lt;/code&gt; 的实现：</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">为了创建文件，必须使用&lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="b17e4fe4c4cad25a01268fcf2e26864d2a26e310" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;struct.openoptions#method.write&quot;&gt;&lt;code&gt;OpenOptions::write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.append&quot;&gt;&lt;code&gt;OpenOptions::append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">为了创建文件，必须使用&lt;a href=&quot;struct.openoptions#method.write&quot;&gt; &lt;code&gt;OpenOptions::write&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.openoptions#method.append&quot;&gt; &lt;code&gt;OpenOptions::append&lt;/code&gt; &lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">为了与 Rust 缺乏全局类型推理保持一致,在项目签名中设计不允许使用类型和 const 占位符。</target>
        </trans-unit>
        <trans-unit id="8a65853b278eb7154e9a97a3b9168563f7fe07ac" translate="yes" xml:space="preserve">
          <source>In order to change the requirement from &lt;code&gt;'static&lt;/code&gt; to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime &lt;code&gt;'_&lt;/code&gt; or some appropriate named lifetime.</source>
          <target state="translated">为了将要求从 &lt;code&gt;'static&lt;/code&gt; 更改为从其参数派生的生存期，可以为匿名生存期 &lt;code&gt;'_&lt;/code&gt; 或某些适当的命名生存期添加显式绑定。</target>
        </trans-unit>
        <trans-unit id="12fa624eb80e06baae2665fd37db20bf0778d0e3" translate="yes" xml:space="preserve">
          <source>In order to encode this kind of constraint, a &lt;code&gt;where&lt;/code&gt; clause and a new type parameter are needed:</source>
          <target state="translated">为了对这种约束进行编码，需要 &lt;code&gt;where&lt;/code&gt; 子句和一个新的type参数：</target>
        </trans-unit>
        <trans-unit id="9667d5a282ae24dfeac4aaa28cc09c9d5311dfe4" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">为了表示我们希望泛型函数采用所有可以转换为指定类型 &lt;code&gt;T&lt;/code&gt; 的参数，我们可以使用&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 的特征范围。例如：函数 &lt;code&gt;is_hello&lt;/code&gt; 接受所有可以转换为&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">为了表示我们希望泛型函数采用所有可以转换为指定类型 &lt;code&gt;T&lt;/code&gt; 的参数，我们可以使用&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 的特征范围。例如：函数 &lt;code&gt;is_hello&lt;/code&gt; 接受所有可以转换为 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">为了解决这个错误,请确认你使用的类型确实实现了这个特性。例子:</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">为了解决此错误，您需要使用 &lt;code&gt;pub&lt;/code&gt; 关键字将项目公开。例：</target>
        </trans-unit>
        <trans-unit id="0f266e5d780b399f0089fa40c8b0e4ea12c652ab" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from &lt;a href=&quot;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&quot;&gt;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&lt;/a&gt; to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="translated">为了使内在函数在编译时可用，需要将实现从&lt;a href=&quot;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&quot;&gt;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&lt;/a&gt;复制到 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; 并在内部函数中添加 &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7221777f5fa03d42ac87ea82e0b30794fd67a12c" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="translated">为了使内在函数在编译时可用，需要将实现从https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs复制到 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; 并在内部函数中添加 &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">为了使通用模式更符合人体工程学，可以在&lt;a href=&quot;types/function-item&quot;&gt;函数项&lt;/a&gt;，&lt;a href=&quot;types/function-pointer&quot;&gt;函数指针&lt;/a&gt;和&lt;a href=&quot;types/closure&quot;&gt;闭包特征&lt;/a&gt;签名中&lt;em&gt;省略&lt;/em&gt;生命周期参数。以下规则用于推断寿命消除的寿命参数。取消无法推断的寿命参数是一个错误。占位符生存期 &lt;code&gt;'_&lt;/code&gt; ，也可以用来以相同的方式推断出生存期。对于路径中的生命周期，首选使用 &lt;code&gt;'_&lt;/code&gt; 。特性对象的生存时间遵循&lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;下面&lt;/a&gt;讨论的不同规则。</target>
        </trans-unit>
        <trans-unit id="8c05c9e0569d955006204f9ccd8d44e873f7454e" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt;, and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">为了使通用模式更符合人体工程学，可以在&lt;a href=&quot;types/function-item&quot;&gt;函数item&lt;/a&gt;，&lt;a href=&quot;types/function-pointer&quot;&gt;函数指针&lt;/a&gt;和&lt;a href=&quot;types/closure&quot;&gt;闭包特征&lt;/a&gt;签名中&lt;em&gt;省略&lt;/em&gt;生命周期参数。以下规则用于推断寿命消除的寿命参数。取消无法推断的生存期参数是错误的。占位符生存期 &lt;code&gt;'_&lt;/code&gt; ，也可以用来以相同的方式推断出生存期。对于路径中的生命周期，首选使用 &lt;code&gt;'_&lt;/code&gt; 。特性对象的生存时间遵循&lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;下面&lt;/a&gt;讨论的不同规则。</target>
        </trans-unit>
        <trans-unit id="6d27121a6ebe29fbef52ed61a820dd624d21ff0c" translate="yes" xml:space="preserve">
          <source>In order to match C representation layout &lt;code&gt;repr(C)&lt;/code&gt;, you should call &lt;code&gt;pad_to_align&lt;/code&gt; after extending the layout with all fields. (There is no way to match the default Rust representation layout &lt;code&gt;repr(Rust)&lt;/code&gt;, as it is unspecified.)</source>
          <target state="translated">为了匹配C表示形式的布局 &lt;code&gt;repr(C)&lt;/code&gt; ，您应该在扩展具有所有字段的布局后调用 &lt;code&gt;pad_to_align&lt;/code&gt; 。（由于未指定，因此无法匹配默认的Rust表示形式布局 &lt;code&gt;repr(Rust)&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">为了向您的用户提供组织合理的API，该API易于使用，并且仅显示您的用户所需要的，现在让我们转向Rust的模块。</target>
        </trans-unit>
        <trans-unit id="62f97a59b8d70df8d4c8aedef19af999118a740d" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">换句话说， &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;一样 &lt;code&gt;y&lt;/code&gt; ，和解除引用它是除非未定义的行为 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 点进相同的分配对象。</target>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">换句话说，所有&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;都通过返回自身来实现&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;。这意味着两件事：</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">换句话说，每个&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;行为有点像自旋锁，可以使用 &lt;code&gt;park&lt;/code&gt; 和 &lt;code&gt;unpark&lt;/code&gt; 进行锁定和解锁。</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">换句话说,如果一个零大小的指针可以从一个分配器中流出,那么这个分配器同样必须接受该指针流回它的deallocation和reallocation方法中。</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">换句话说，如果两个键相等，则它们的哈希也必须相等。&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;都依赖此行为。</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">换句话说,如果两个键相等,它们的哈希值一定相等。</target>
        </trans-unit>
        <trans-unit id="651e99e3b0937bfaed54c38e268ae7294b8d7b90" translate="yes" xml:space="preserve">
          <source>In other words, if you tried to explicitly call &lt;code&gt;Drop::drop&lt;/code&gt; in the above example, you'd get a compiler error.</source>
          <target state="translated">换句话说，如果您在上面的示例中尝试显式调用 &lt;code&gt;Drop::drop&lt;/code&gt; ，则会出现编译器错误。</target>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">换句话说,它将两个迭代器连接在一起,形成一个链。🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">换句话说，它会自动删除&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;层。如果您的映射已经返回了&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;并且您想跳过&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，那么 &lt;code&gt;filter_map&lt;/code&gt; 会好用得多。</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">换句话说,它将两个迭代器压缩在一起,变成一个。</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">换句话说，删除所有字符 &lt;code&gt;c&lt;/code&gt; ，使 &lt;code&gt;f(c)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。此方法在原位运行，以原始顺序恰好一次访问每个字符，并保留保留字符的顺序。</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">换句话说，删除所有元素 &lt;code&gt;e&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="326bae5baf07932f414f02dbcc5ff71283bf4bd0" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The elements are visited in unsorted (and unspecified) order.</source>
          <target state="translated">换句话说，删除所有元素 &lt;code&gt;e&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。元素以未排序（和未指定）的顺序访问。</target>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">换句话说，删除所有元素 &lt;code&gt;e&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。此方法在原位运行，以原始顺序恰好一次访问每个元素，并保留保留元素的顺序。</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">换句话说，删除所有元素 &lt;code&gt;e&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 返回false。此方法在原位运行，以原始顺序恰好一次访问每个元素，并保留保留元素的顺序。</target>
        </trans-unit>
        <trans-unit id="f592c733f4a495d9c0b5f64b20924cb17921a1b4" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k, &amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">换句话说，删除所有对 &lt;code&gt;(k, v)&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;k, &amp;amp;mut v)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">换句话说，删除所有对 &lt;code&gt;(k, v)&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">换句话说，结果是将 &lt;code&gt;self / rhs&lt;/code&gt; 舍入为整数 &lt;code&gt;n&lt;/code&gt; ,从而使 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; 。如果 &lt;code&gt;self &amp;gt; 0&lt;/code&gt; ，则等于舍入为零（Rust中的默认值）；否则为0。如果 &lt;code&gt;self &amp;lt; 0&lt;/code&gt; ，则等于朝+/-无限取整。</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">换句话说,这里有两个重要的时间点。</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">换句话说，我们告诉Rust，只要在 &lt;code&gt;contents&lt;/code&gt; 参数中传递给 &lt;code&gt;search&lt;/code&gt; 功能的数据有效，则 &lt;code&gt;search&lt;/code&gt; 功能返回的数据将一直存在。这个很重要！引用的数据&lt;em&gt;由&lt;/em&gt;一个切片需要是有效的基准是有效的;如果编译器假设我们要 &lt;code&gt;query&lt;/code&gt; 是字符串而不是 &lt;code&gt;contents&lt;/code&gt; ，则它将不正确地进行安全检查。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">换句话说，您可以将 &lt;code&gt;if let&lt;/code&gt; 视为 &lt;code&gt;match&lt;/code&gt; 语法糖，该匹配在值匹配一个模式然后忽略所有其他值时运行代码。</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">换句话说，必须先将 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 转换为 &lt;code&gt;T&lt;/code&gt; ,然后才能对其执行 &lt;code&gt;T&lt;/code&gt; 操作。通常，这有助于捕获null最常见的问题之一：假设某事物实际上并非为null。</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">换句话说：t&amp;isin;FOLLOW（M）当且仅当存在（可能为空）令牌序列&amp;alpha;，&amp;beta;，&amp;gamma;，&amp;delta;时，其中：</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">但是，在错误的示例中，我们引用的是单个具体类型。因为我们肯定知道 &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; 实现了 &lt;code&gt;Clone&lt;/code&gt; ，所以没有理由在 &lt;code&gt;where&lt;/code&gt; 子句中也指定它。</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">特别是 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; 和 &lt;code&gt;Hash&lt;/code&gt; 必须与借入和拥有的值等效： &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; 的结果应与 &lt;code&gt;x == y&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="75333f3519a07df1c42a5d8eddbdb687099bae84" translate="yes" xml:space="preserve">
          <source>In particular, coercing a function with &lt;code&gt;#[track_caller]&lt;/code&gt; to a function pointer creates a shim which appears to observers to have been called at the attributed function's definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</source>
          <target state="translated">特别是，将带有 &lt;code&gt;#[track_caller]&lt;/code&gt; 的函数强制为函数指针会创建一个垫片，该垫片对于观察者而言似乎已在属性函数的定义站点处被调用，从而在虚拟调用中丢失了实际的调用者信息。这种强制的一个常见示例是创建属性对象，该对象的方法具有属性。</target>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">特别是，如果有人通过给定的分配器 &lt;code&gt;a&lt;/code&gt; 和布局 &lt;code&gt;k&lt;/code&gt; 分配了一个内存块，其中 &lt;code&gt;a.usable_size(k)&lt;/code&gt; 返回 &lt;code&gt;(l, u)&lt;/code&gt; ，则可以将该块传递给大小为 &lt;code&gt;a.dealloc()&lt;/code&gt; 的布局范围[l，u]。</target>
        </trans-unit>
        <trans-unit id="d30439b36bf2c88bac9a70141d7e2e3a34d9cecb" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</source>
          <target state="translated">特别是,如果你忘记了寄存器约束的结束括号,就会发生这种情况(见问题#51430),就像前面的代码例子一样。</target>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">特别是,如果你忘记了一个寄存器约束的关闭括号,就会发生这种情况(见问题#51430)。</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">特别是,用于初始化原始条目的哈希仍然必须与最终存储在条目中的键的哈希一致。这是因为HashMap的实现在调整大小时可能需要重新计算哈希值,这时只有键可以使用。</target>
        </trans-unit>
        <trans-unit id="1f0c47f31f9dc083f9c5c01ccece4c74f77d799d" translate="yes" xml:space="preserve">
          <source>In particular, the resulting pointer remains attached to the same allocated object that &lt;code&gt;self&lt;/code&gt; points to. It may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="translated">特别是，生成的指针仍附加到 &lt;code&gt;self&lt;/code&gt; 指向的同一分配对象上。它可能&lt;em&gt;不能&lt;/em&gt;用于访问其他分配的对象。请注意，在Rust中，每个（堆栈分配的）变量都被视为一个单独的分配对象。</target>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">特别地，在大多数情况下，返回值 &lt;code&gt;r&lt;/code&gt; 满足 &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; 。但是，由于 &lt;code&gt;self&lt;/code&gt; 的幅度远小于 &lt;code&gt;rhs.abs()&lt;/code&gt; ，并且 &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; ，因此由于浮点舍入误差，可能导致 &lt;code&gt;r == rhs.abs()&lt;/code&gt; ，违反了数学定义。此结果不是函数共域的元素，但它是实数中最接近的浮点数，因此 &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; 实现了属性self == self.div_euclid（rhs）* rhs + self.rem_euclid（rhs）。</target>
        </trans-unit>
        <trans-unit id="5ace8c101adbcb8f417784f9525d6b6b04d2023a" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;fold()&lt;/code&gt; on the internal parts from which this iterator is composed.</source>
          <target state="translated">特别是，尝试在构成此迭代器的内部部件上调用 &lt;code&gt;fold()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">特别是，尝试在组成此迭代器的内部部件上调用 &lt;code&gt;try_fold()&lt;/code&gt; 。如果需要多个呼叫，则 &lt;code&gt;?&lt;/code&gt; 运算符可能会很方便地将累加器值链接起来，但是要提防在这些早期返回之前需要维护的所有不变式。这是 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 方法，因此在此处遇到错误后，需要重新开始迭代。</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">在极少数情况下，编写紧急代码而不是返回 &lt;code&gt;Result&lt;/code&gt; 更为合适。让我们探讨为什么在示例，原型代码和测试中惊慌失措是适当的。然后，我们将讨论编译器无法告知失败是不可能的，但您却可以做到的情况。本章将以关于如何确定是否在库代码中引起恐慌的一些通用准则作为结尾。</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">简而言之，由于 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; （其中 &lt;code&gt;T&lt;/code&gt; 可以是任何类型）是不同的类型，因此编译器不会让我们使用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 值，就好像它绝对是有效值一样。例如，此代码将无法编译，因为它试图将 &lt;code&gt;i8&lt;/code&gt; 添加到 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">在单线程方案中，这可能在编写信号处理程序或某些类型的低级代码时引起问题。使用&lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;编译器篱笆&lt;/a&gt;来防止这种重新排序。</target>
        </trans-unit>
        <trans-unit id="6eccde4f87031328924ef4f1acaf135f499b7802" translate="yes" xml:space="preserve">
          <source>In some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a &quot;Least Upper Bound&quot; coercion. LUB coercion is used and only used in the following situations:</source>
          <target state="translated">在某些情况下,编译器必须将多个类型胁迫在一起,试图找到最通用的类型。这被称为 &quot;最小上界 &quot;胁迫。LUB胁迫被使用,并且只在以下情况下使用。</target>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">在某些语言中，程序员每次使用智能指针实例完成操作时，都必须调用代码以释放内存或资源。如果他们忘记了，系统可能会变得超载并崩溃。在Rust中，您可以指定每当值超出范围时就运行特定的代码位，编译器将自动插入此代码。结果，您无需在将特定类型的实例完成的程序中的任何地方放置清理代码的时候就很小心-您仍然不会泄漏资源！</target>
        </trans-unit>
        <trans-unit id="37072e6e82bbf9d96cc9281defd328d5ab53bf93" translate="yes" xml:space="preserve">
          <source>In some programming languages, the behavior of string formatting functions depends on the operating system's locale setting. The format functions provided by Rust's standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.</source>
          <target state="translated">在一些编程语言中,字符串格式化函数的行为取决于操作系统的locale设置。Rust标准库提供的格式函数没有任何locale的概念,无论用户如何配置,在所有系统上都会产生相同的结果。</target>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">在某些情况下，类型的组合可能不明确。在类型周围使用括号可避免歧义。例如，&lt;a href=&quot;types/pointer#shared-references-&quot;&gt;引用类型&lt;/a&gt;内&lt;a href=&quot;trait-bounds&quot;&gt;类型边界&lt;/a&gt;的 &lt;code&gt;+&lt;/code&gt; 运算符不清楚该边界适用于何处，因此需要使用括号。需要消除歧义的语法规则使用&lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt;规则而不是&lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78a25e5b990fcd1740e4efa791bdb025c393c864" translate="yes" xml:space="preserve">
          <source>In some situations, some strings that should create a valid float instead return an error. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;issue #31407&lt;/a&gt; for details.</source>
          <target state="translated">在某些情况下，某些应创建有效浮点数的字符串将返回错误。有关详细信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;问题＃31407&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e28b9cfae095cd08e8afd62032026a0b23bc39f7" translate="yes" xml:space="preserve">
          <source>In statements like &lt;code&gt;let x = 5;&lt;/code&gt; with a variable name in the &lt;code&gt;PATTERN&lt;/code&gt; slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the &lt;code&gt;let x = 5;&lt;/code&gt; example, &lt;code&gt;x&lt;/code&gt; is a pattern that means &amp;ldquo;bind what matches here to the variable &lt;code&gt;x&lt;/code&gt;.&amp;rdquo; Because the name &lt;code&gt;x&lt;/code&gt; is the whole pattern, this pattern effectively means &amp;ldquo;bind everything to the variable &lt;code&gt;x&lt;/code&gt;, whatever the value is.&amp;rdquo;</source>
          <target state="translated">在语句中， &lt;code&gt;let x = 5;&lt;/code&gt; 在 &lt;code&gt;PATTERN&lt;/code&gt; 插槽中有一个变量名，变量名只是模式的一种特别简单的形式。Rust将表达式与模式进行比较，并分配它找到的任何名称。因此， &lt;code&gt;let x = 5;&lt;/code&gt; 例如， &lt;code&gt;x&lt;/code&gt; 是一种模式，表示&amp;ldquo;将此处匹配的内容绑定到变量 &lt;code&gt;x&lt;/code&gt; &amp;rdquo;。因为名称 &lt;code&gt;x&lt;/code&gt; 是整个模式，所以该模式实际上意味着&amp;ldquo;将所有值绑定到变量 &lt;code&gt;x&lt;/code&gt; ，无论值是多少&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ab76c75fb8be2531be195781f70554fa526d2349" translate="yes" xml:space="preserve">
          <source>In such a case, the compiler cannot predict the return type of &lt;code&gt;foo()&lt;/code&gt; in a situation like the following:</source>
          <target state="translated">在这种情况下，编译器无法在以下情况下预测 &lt;code&gt;foo()&lt;/code&gt; 的返回类型：</target>
        </trans-unit>
        <trans-unit id="a84c028b3015af78e467c76bddbf22405a6992e9" translate="yes" xml:space="preserve">
          <source>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</source>
          <target state="translated">总而言之,以下是我们将清单10-2的代码改为清单10-3的步骤。</target>
        </trans-unit>
        <trans-unit id="b66a6766ec59e5aa720a0c750a221736c0a524da" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic memory orderings&lt;/a&gt;, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after &lt;code&gt;join&lt;/code&gt; returns.</source>
          <target state="translated">在&lt;a href=&quot;../sync/atomic/index&quot;&gt;原子内存排序方面&lt;/a&gt;，关联线程的完成与此函数返回同步。换句话说，该线程执行的所有操作在 &lt;code&gt;join&lt;/code&gt; 返回之后发生的所有操作之前被排序。</target>
        </trans-unit>
        <trans-unit id="49ebdf4d886162df5d53e77b9ab0d51282c8c87c" translate="yes" xml:space="preserve">
          <source>In the 2015 edition parameters pattern where not needed for traits:</source>
          <target state="translated">在2015版参数模式中,哪里不需要性状。</target>
        </trans-unit>
        <trans-unit id="95c17fb8e8e9e84f4aa64abfe2139c371569ca73" translate="yes" xml:space="preserve">
          <source>In the 2015 edition the parameters pattern was not needed for traits:</source>
          <target state="translated">在2015版中,性状不需要参数模式。</target>
        </trans-unit>
        <trans-unit id="4fb4dfd79140995a00d7f2f4a091910c0bb3584f" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, &lt;a href=&quot;types/trait-object&quot;&gt;&lt;code&gt;dyn&lt;/code&gt;&lt;/a&gt; is a keyword when used in a type position followed by a path that does not start with &lt;code&gt;::&lt;/code&gt;.</source>
          <target state="translated">在2015版中，&lt;a href=&quot;types/trait-object&quot;&gt; &lt;code&gt;dyn&lt;/code&gt; &lt;/a&gt;在类型位置后跟不是以 &lt;code&gt;::&lt;/code&gt; 开头的路径时是关键字。</target>
        </trans-unit>
        <trans-unit id="e5c533200fa356e0f6f01942ecd077fd12144d48" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, the pattern for a trait function or method parameter is optional:</source>
          <target state="translated">在2015版中,性状函数或方法参数的模式是可选的。</target>
        </trans-unit>
        <trans-unit id="ead217a846b182b1c7c3895bb636fcdc53cf3da8" translate="yes" xml:space="preserve">
          <source>In the 2018 edition, if an in-scope item has the same name as an external crate, then &lt;code&gt;use&lt;/code&gt; of that crate name requires a leading &lt;code&gt;::&lt;/code&gt; to unambiguously select the crate name. This is to retain compatibility with potential future changes.</source>
          <target state="translated">在2018年版中，如果范围内的商品与外部包装箱具有相同的名称，则 &lt;code&gt;use&lt;/code&gt; 该包装箱名称需要使用前导 &lt;code&gt;::&lt;/code&gt; 来明确选择包装箱名称。这是为了保持与将来可能发生的更改的兼容性。</target>
        </trans-unit>
        <trans-unit id="a3999cf3a0362f5c3017eea167e996c61b1004cc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;Unicode Standard&lt;/a&gt;, Chapter 4 (Character Properties) discusses case mapping in general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.</source>
          <target state="translated">在&lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;Unicode标准中&lt;/a&gt;，第4章（字符属性）通常讨论大小写映射，而第3章（一致性）则讨论大小写转换的默认算法。</target>
        </trans-unit>
        <trans-unit id="ac8c3e671a7bc9e2a3ca26713c444ad82025ac40" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">在&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;中，我们实施了一个&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;Counter&lt;/code&gt; 。让我们也为其实现 &lt;code&gt;ExactSizeIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="29a70e5936b8ef90f87c3d79c860b1701d924dbc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module-level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">在&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;中，我们实施了一个&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;Counter&lt;/code&gt; 。让我们也为其实现 &lt;code&gt;ExactSizeIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="542be6c89aa5ea78dd9931c09f1fa338c6d41b0e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;User&lt;/code&gt; struct definition in Listing 5-1, we used the owned &lt;code&gt;String&lt;/code&gt; type rather than the &lt;code&gt;&amp;amp;str&lt;/code&gt; string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</source>
          <target state="translated">在清单5-1中的 &lt;code&gt;User&lt;/code&gt; struct定义中，我们使用了拥有的 &lt;code&gt;String&lt;/code&gt; 类型而不是 &lt;code&gt;&amp;amp;str&lt;/code&gt; 字符串切片类型。这是一个有意的选择，因为我们希望该结构的实例拥有其所有数据，并且只要整个结构有效，该数据就一直有效。</target>
        </trans-unit>
        <trans-unit id="86f5e9e4af3e5d42db41973d9449d9469f700ef8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ve made the &lt;code&gt;stream&lt;/code&gt; parameter mutable. The reason is that the &lt;code&gt;TcpStream&lt;/code&gt; instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. It therefore needs to be &lt;code&gt;mut&lt;/code&gt; because its internal state might change; usually, we think of &amp;ldquo;reading&amp;rdquo; as not needing mutation, but in this case we need the &lt;code&gt;mut&lt;/code&gt; keyword.</source>
          <target state="translated">在 &lt;code&gt;handle_connection&lt;/code&gt; 函数中，我们使 &lt;code&gt;stream&lt;/code&gt; 参数可变。原因是 &lt;code&gt;TcpStream&lt;/code&gt; 实例跟踪它在内部返回给我们的数据。它读取的数据可能会超过我们的要求，并在下次我们要求数据时保存该数据。因此，它需要 &lt;code&gt;mut&lt;/code&gt; 因为其内部状态可能会改变;通常，我们认为&amp;ldquo;阅读&amp;rdquo;不需要突变，但是在这种情况下，我们需要 &lt;code&gt;mut&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="41e5d381e8adcfa53c11fefa07fcde5916d77703" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.3.14&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.3.14&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.3.14&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.3.14.&amp;rdquo;</source>
          <target state="translated">在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中，标头后的所有内容都是该节的一部分，该节一直持续到另一个节开始。在 &lt;code&gt;[dependencies]&lt;/code&gt; 部分中，您可以告诉Cargo项目所依赖的外部包装箱以及所需的这些包装箱的版本。在这种情况下，我们将使用语义版本说明符 &lt;code&gt;0.3.14&lt;/code&gt; 指定 &lt;code&gt;rand&lt;/code&gt; crate 。 Cargo理解&lt;a href=&quot;http://semver.org&quot;&gt;语义版本控制&lt;/a&gt;（有时称为&lt;em&gt;SemVer&lt;/em&gt;），这是编写版本号的标准。数字 &lt;code&gt;0.3.14&lt;/code&gt; 实际上是 &lt;code&gt;^0.3.14&lt;/code&gt; 简写，表示&amp;ldquo;具有与0.3.14版本兼容的公共API的任何版本。&amp;rdquo;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba414d8766c29269cba8897672efd77d70e901b9" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.5.5.&amp;rdquo;</source>
          <target state="translated">在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中，标头后的所有内容都是该节的一部分，该节一直持续到另一个节开始。在 &lt;code&gt;[dependencies]&lt;/code&gt; 部分中，您可以告诉Cargo项目所依赖的外部包装箱以及所需的这些包装箱的版本。在这种情况下，我们将使用语义版本说明符 &lt;code&gt;0.5.5&lt;/code&gt; 指定 &lt;code&gt;rand&lt;/code&gt; crate 。 Cargo理解&lt;a href=&quot;http://semver.org&quot;&gt;语义版本控制&lt;/a&gt;（有时称为&lt;em&gt;SemVer&lt;/em&gt;），这是编写版本号的标准。数字 &lt;code&gt;0.5.5&lt;/code&gt; 实际上是 &lt;code&gt;^0.5.5&lt;/code&gt; 简写，表示&amp;ldquo;具有与0.5.5版兼容的公共API的任何版本。&amp;rdquo;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3eddcd6a499d2c2be1d503ec8a0e525837574e9f" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means any version that is at least &lt;code&gt;0.5.5&lt;/code&gt; but below &lt;code&gt;0.6.0&lt;/code&gt;. Cargo considers these versions to have public APIs compatible with version &lt;code&gt;0.5.5&lt;/code&gt;.</source>
          <target state="translated">在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中，标头后的所有内容都是该节的一部分，该节一直持续到另一个节开始。在 &lt;code&gt;[dependencies]&lt;/code&gt; 部分中，您可以告诉Cargo项目所依赖的外部包装箱以及所需的这些包装箱的版本。在这种情况下，我们将使用语义版本说明符 &lt;code&gt;0.5.5&lt;/code&gt; 指定 &lt;code&gt;rand&lt;/code&gt; crate 。 Cargo理解&lt;a href=&quot;http://semver.org&quot;&gt;语义版本控制&lt;/a&gt;（有时称为&lt;em&gt;SemVer&lt;/em&gt;），这是编写版本号的标准。数字 &lt;code&gt;0.5.5&lt;/code&gt; 实际上是 &lt;code&gt;^0.5.5&lt;/code&gt; 简写，表示任何版本至少为 &lt;code&gt;0.5.5&lt;/code&gt; 但低于 &lt;code&gt;0.6.0&lt;/code&gt; 的版本&lt;em&gt;&lt;/em&gt;。 Cargo认为这些版本具有与 &lt;code&gt;0.5.5&lt;/code&gt; 版兼容的公共API 。</target>
        </trans-unit>
        <trans-unit id="b7177f5dba94e8e93990faf2d2454fb646d49847" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s add an &lt;code&gt;add_one&lt;/code&gt; function:</source>
          <target state="translated">在&lt;em&gt;add-one / src / lib.rs&lt;/em&gt;文件中，我们添加一个 &lt;code&gt;add_one&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="3da0b39e8b4dc5e8ab87b83cc0f936c2b1215ca7" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;T&lt;/code&gt; is unknowable by the compiler. To fix this you must bind &lt;code&gt;T&lt;/code&gt; to a concrete type such as &lt;code&gt;String&lt;/code&gt; so that a generator can then be constructed:</source>
          <target state="translated">在上面的示例中，编译器无法知道 &lt;code&gt;T&lt;/code&gt; 。要解决此问题，您必须将 &lt;code&gt;T&lt;/code&gt; 绑定到具体类型（例如 &lt;code&gt;String&lt;/code&gt; ),以便可以构造生成器：</target>
        </trans-unit>
        <trans-unit id="dac108bef6e0aa0c5a3c87c1e1dd002eec20cb12" translate="yes" xml:space="preserve">
          <source>In the absolute path, we start with &lt;code&gt;crate&lt;/code&gt;, the root of our crate&amp;rsquo;s module tree. Then the &lt;code&gt;front_of_house&lt;/code&gt; module is defined in the crate root. The &lt;code&gt;front_of_house&lt;/code&gt; module isn&amp;rsquo;t public, but because the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is defined in the same module as &lt;code&gt;front_of_house&lt;/code&gt; (that is, &lt;code&gt;eat_at_restaurant&lt;/code&gt; and &lt;code&gt;front_of_house&lt;/code&gt; are siblings), we can refer to &lt;code&gt;front_of_house&lt;/code&gt; from &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Next is the &lt;code&gt;hosting&lt;/code&gt; module marked with &lt;code&gt;pub&lt;/code&gt;. We can access the parent module of &lt;code&gt;hosting&lt;/code&gt;, so we can access &lt;code&gt;hosting&lt;/code&gt;. Finally, the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is marked with &lt;code&gt;pub&lt;/code&gt; and we can access its parent module, so this function call works!</source>
          <target state="translated">在绝对路径中，我们从 &lt;code&gt;crate&lt;/code&gt; 开始，这是crate的模块树的根。然后在 &lt;code&gt;front_of_house&lt;/code&gt; 中定义front_of_house模块。该 &lt;code&gt;front_of_house&lt;/code&gt; 模块是不公开的，但由于 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 功能是一样的模块定义 &lt;code&gt;front_of_house&lt;/code&gt; （即 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 和 &lt;code&gt;front_of_house&lt;/code&gt; 是兄弟），大家可以参考 &lt;code&gt;front_of_house&lt;/code&gt; 从 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。接下来是标有 &lt;code&gt;pub&lt;/code&gt; 的 &lt;code&gt;hosting&lt;/code&gt; 模块。我们可以访问 &lt;code&gt;hosting&lt;/code&gt; 的父模块，因此我们可以访问 &lt;code&gt;hosting&lt;/code&gt; 。最后，将 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数标记为 &lt;code&gt;pub&lt;/code&gt; ，我们可以访问其父模块，因此此函数调用有效！</target>
        </trans-unit>
        <trans-unit id="e8a74d26ff6bb6812e6769b94696470ac83d32c8" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;largest&lt;/code&gt; we wanted to compare two values of type &lt;code&gt;T&lt;/code&gt; using the greater than (&lt;code&gt;&amp;gt;&lt;/code&gt;) operator. Because that operator is defined as a default method on the standard library trait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, we need to specify &lt;code&gt;PartialOrd&lt;/code&gt; in the trait bounds for &lt;code&gt;T&lt;/code&gt; so the &lt;code&gt;largest&lt;/code&gt; function can work on slices of any type that we can compare. We don&amp;rsquo;t need to bring &lt;code&gt;PartialOrd&lt;/code&gt; into scope because it&amp;rsquo;s in the prelude. Change the signature of &lt;code&gt;largest&lt;/code&gt; to look like this:</source>
          <target state="translated">在 &lt;code&gt;largest&lt;/code&gt; 的正文中，我们想使用大于（ &lt;code&gt;&amp;gt;&lt;/code&gt; ）运算符比较两个类型 &lt;code&gt;T&lt;/code&gt; 的值。因为该运算符被定义为标准库特征 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; 的默认方法，所以我们需要在 &lt;code&gt;T&lt;/code&gt; 的特征范围中指定 &lt;code&gt;PartialOrd&lt;/code&gt; ，以便 &lt;code&gt;largest&lt;/code&gt; 函数可以作用于我们可以比较的任何类型的切片。我们不需要把 &lt;code&gt;PartialOrd&lt;/code&gt; 纳入范围，因为它处于序幕中。更改 &lt;code&gt;largest&lt;/code&gt; 的签名，如下所示：</target>
        </trans-unit>
        <trans-unit id="9eeb876353faccbcba2ce19feeb7d0dafe4faead" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we call &lt;code&gt;into_iter&lt;/code&gt; to create an iterator that takes ownership of the vector. Then we call &lt;code&gt;filter&lt;/code&gt; to adapt that iterator into a new iterator that only contains elements for which the closure returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;shoes_in_my_size&lt;/code&gt; 的主体中，我们调用 &lt;code&gt;into_iter&lt;/code&gt; 创建一个迭代器，该迭代器获取向量的所有权。然后，我们调用 &lt;code&gt;filter&lt;/code&gt; 使该迭代器适应新的迭代器，该迭代器仅包含闭包为其返回 &lt;code&gt;true&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="ccc28c109f469220d7a0f86ba3d92af7a489d690" translate="yes" xml:space="preserve">
          <source>In the body of a generic function, methods from &lt;code&gt;Trait&lt;/code&gt; can be called on &lt;code&gt;Ty&lt;/code&gt; values. Likewise associated constants on the &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">在泛型函数的主体中，可以对 &lt;code&gt;Ty&lt;/code&gt; 值调用 &lt;code&gt;Trait&lt;/code&gt; 中的方法。同样，可以使用 &lt;code&gt;Trait&lt;/code&gt; 上的关联常量。</target>
        </trans-unit>
        <trans-unit id="ed9b56a6d3a5e9ebb3e76d9359071c31eee0aecc" translate="yes" xml:space="preserve">
          <source>In the case a &lt;code&gt;loop&lt;/code&gt; has an associated &lt;code&gt;break&lt;/code&gt;, it is not considered diverging, and the &lt;code&gt;loop&lt;/code&gt; must have a type compatible with each &lt;code&gt;break&lt;/code&gt; expression. &lt;code&gt;break&lt;/code&gt; without an expression is considered identical to &lt;code&gt;break&lt;/code&gt; with expression &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;loop&lt;/code&gt; 具有关联的 &lt;code&gt;break&lt;/code&gt; ，则不认为它是发散的，并且 &lt;code&gt;loop&lt;/code&gt; 必须具有与每个 &lt;code&gt;break&lt;/code&gt; 表达式兼容的类型。没有表达式的 &lt;code&gt;break&lt;/code&gt; 被认为与带有表达式 &lt;code&gt;()&lt;/code&gt; 的 &lt;code&gt;break&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="5e9ac885fce76186450b96a37f179bf757255fd6" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;, the scope for the block and the expression are the same scope.</source>
          <target state="translated">对于&lt;a href=&quot;expressions/block-expr&quot;&gt;块表达式&lt;/a&gt;，该块的作用域和该表达式的作用域是相同的作用域。</target>
        </trans-unit>
        <trans-unit id="57fe262eb9d9754ab04dac149861a78ef7f9cbdf" translate="yes" xml:space="preserve">
          <source>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&amp;rsquo;s immutability. Unfortunately, we can&amp;rsquo;t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.</source>
          <target state="translated">对于字符串文字，我们在编译时就知道内容，因此文本直接硬编码到最终的可执行文件中。这就是为什么字符串文字快速高效的原因。但是这些属性仅来自字符串文字的不变性。不幸的是，对于在编译时大小未知并且运行程序时大小可能会改变的每段文本，我们无法在二进制文件中放入一滴内存。</target>
        </trans-unit>
        <trans-unit id="174ee51902d80b0fa89335cd9be3f224ff39dd4c" translate="yes" xml:space="preserve">
          <source>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</source>
          <target state="translated">在隐式包装溢出的情况下,实现必须通过使用两个的补码溢出惯例来提供定义明确的(即使仍然被认为是错误的)结果。</target>
        </trans-unit>
        <trans-unit id="ad072c8ebb70bdab55dbb950bf9d58e7b04bb9e3" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;File::open&lt;/code&gt; succeeds, the value in the variable &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Ok&lt;/code&gt; that contains a file handle. In the case where it fails, the value in &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Err&lt;/code&gt; that contains more information about the kind of error that happened.</source>
          <target state="translated">如果 &lt;code&gt;File::open&lt;/code&gt; 成功，则变量 &lt;code&gt;f&lt;/code&gt; 中的值将是 &lt;code&gt;Ok&lt;/code&gt; 的实例，其中包含文件句柄。在失败的情况下， &lt;code&gt;f&lt;/code&gt; 中的值将是 &lt;code&gt;Err&lt;/code&gt; 的实例，其中包含有关发生的错误类型的更多信息。</target>
        </trans-unit>
        <trans-unit id="98ff22c3c9a8db90c4e7212603caadebf4d948d5" translate="yes" xml:space="preserve">
          <source>In the code above, the function is returning data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, but the &lt;code&gt;'a&lt;/code&gt; annotation indicates that it is returning data only from &lt;code&gt;x&lt;/code&gt;. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&amp;amp;'a i32&lt;/code&gt;, like so:</source>
          <target state="translated">在上面的代码中，该函数正在返回从 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 借来的数据，但是 &lt;code&gt;'a&lt;/code&gt; 批注表明它仅从 &lt;code&gt;x&lt;/code&gt; 返回数据。要纠正错误，必须使签名和正文匹配。通常，这是通过更新功能签名来完成的。因此，在这种情况下，我们将 &lt;code&gt;y&lt;/code&gt; 的类型更改为 &lt;code&gt;&amp;amp;'a i32&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="47d276ce9763d36114b6391e5e3702972a6d1fd2" translate="yes" xml:space="preserve">
          <source>In the context of Listing 9-7, the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;File::open&lt;/code&gt; call will return the value inside an &lt;code&gt;Ok&lt;/code&gt; to the variable &lt;code&gt;f&lt;/code&gt;. If an error occurs, the &lt;code&gt;?&lt;/code&gt; operator will return early out of the whole function and give any &lt;code&gt;Err&lt;/code&gt; value to the calling code. The same thing applies to the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call.</source>
          <target state="translated">在清单9-7的上下文中， &lt;code&gt;?&lt;/code&gt; 在 &lt;code&gt;File::open&lt;/code&gt; 调用的末尾，会将 &lt;code&gt;Ok&lt;/code&gt; 内的值返回给变量 &lt;code&gt;f&lt;/code&gt; 。如果发生错误，则 &lt;code&gt;?&lt;/code&gt; 运算符将在整个函数中尽早返回并为调用代码提供任何 &lt;code&gt;Err&lt;/code&gt; 值。同样的事情适用于 &lt;code&gt;?&lt;/code&gt; 在 &lt;code&gt;read_to_string&lt;/code&gt; 调用的末尾。</target>
        </trans-unit>
        <trans-unit id="c49979de4803e07d7682a6dac88ad65cf9bdcef3" translate="yes" xml:space="preserve">
          <source>In the end, this means that you may need to pair &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; with some sort of &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::sync&lt;/code&gt;&lt;/a&gt; type, usually &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最后，这意味着您可能需要将 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 与某种&lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::sync&lt;/code&gt; &lt;/a&gt;类型配对，通常是&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a1b716ed41677dd2be556cd6b10193bd9fd8fb5" translate="yes" xml:space="preserve">
          <source>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</source>
          <target state="translated">在上面的错误代码例子中,提供了错误的名称,所以改成正确的名称就可以解决这个错误。例子。</target>
        </trans-unit>
        <trans-unit id="a13ba9220a713242d839758de54b6d6a213f5d7c" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;closure&lt;/code&gt; is an &lt;code&gt;FnOnce&lt;/code&gt; closure whereas the &lt;code&gt;bar&lt;/code&gt; function expected an &lt;code&gt;Fn&lt;/code&gt; closure. In this case, it's simple to fix the issue, you just have to implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; traits on &lt;code&gt;struct X&lt;/code&gt; and it'll be ok:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;closure&lt;/code&gt; 为 &lt;code&gt;FnOnce&lt;/code&gt; 闭包，而 &lt;code&gt;bar&lt;/code&gt; 函数期望为 &lt;code&gt;Fn&lt;/code&gt; 闭包。在这种情况下，解决问题很简单，您只需要在 &lt;code&gt;struct X&lt;/code&gt; 上实现 &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Clone&lt;/code&gt; 特征即可，这可以：</target>
        </trans-unit>
        <trans-unit id="0a2556b76fed59d4f25e18f6058b48758d96fe76" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;name&lt;/code&gt; is moved out of &lt;code&gt;person&lt;/code&gt;, trying to use &lt;code&gt;person&lt;/code&gt; as a whole or &lt;code&gt;person.name&lt;/code&gt; would result in an error because of &lt;em&gt;partial move&lt;/em&gt;.</source>
          <target state="translated">在下面的示例中， &lt;code&gt;name&lt;/code&gt; 被移出 &lt;code&gt;person&lt;/code&gt; ，尝试整体使用 &lt;code&gt;person&lt;/code&gt; 或 &lt;code&gt;person.name&lt;/code&gt; 会由于&lt;em&gt;部分move&lt;/em&gt;而导致错误。</target>
        </trans-unit>
        <trans-unit id="c4e63cece27f012d6cb0c3b410a4800e38cdde84" translate="yes" xml:space="preserve">
          <source>In the example below, we implement a &lt;code&gt;Point&lt;/code&gt; type. Because it only stores two integers, we opt-out of ownership semantics with &lt;code&gt;Copy&lt;/code&gt;. Then we can &lt;code&gt;let p2 = p1&lt;/code&gt; without &lt;code&gt;p1&lt;/code&gt; being moved.</source>
          <target state="translated">在下面的示例中，我们实现了 &lt;code&gt;Point&lt;/code&gt; 类型。因为它只存储两个整数，所以我们选择使用 &lt;code&gt;Copy&lt;/code&gt; 退出所有权语义。然后我们可以 &lt;code&gt;let p2 = p1&lt;/code&gt; 而不移动 &lt;code&gt;p1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1f21adbe43e342921b2cfef575b2b17bbbed822" translate="yes" xml:space="preserve">
          <source>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">在该示例中，类型不能具有明确定义的大小，因为它的大小必须任意大（因为我们可以将 &lt;code&gt;ListNode&lt;/code&gt; 嵌套到任何深度）。具体来说，</target>
        </trans-unit>
        <trans-unit id="dce7e71b1b63c6637f941a4911789744e653ecbd" translate="yes" xml:space="preserve">
          <source>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">在第一种情况下，推断出输出寿命与唯一输入寿命相同。在第二种情况下，生存期被推断为 &lt;code&gt;&amp;amp;self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 上的生存期相同。</target>
        </trans-unit>
        <trans-unit id="3fd5720ef4de3e0fbc4e279820c08cbec7f12fa8" translate="yes" xml:space="preserve">
          <source>In the first code example, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">在第一个代码示例中，编译器无法推断 &lt;code&gt;x&lt;/code&gt; 的类型： &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 都是合适的候选者。要指定使用哪种类型，可以在 &lt;code&gt;x&lt;/code&gt; 上使用类型注释：</target>
        </trans-unit>
        <trans-unit id="874b3aefadd7a8d78fd78ecf2f3f7b20564e4f86" translate="yes" xml:space="preserve">
          <source>In the first example, the lowercased string is represented &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (the last character is an acute accent &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining character&lt;/a&gt;). Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt;. In the second example, the lowercased string is represented &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (the last character is a single Unicode character representing an 'e' with an acute accent). Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt;.</source>
          <target state="translated">在第一个示例中，小写的字符串表示为 &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; （最后一个字符是尖音&lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;组合字符&lt;/a&gt;）。与字符串中的其他字符不同，合并字符不会映射到大写变体，从而导致 &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt; 。在第二个示例中，小写的字符串表示为 &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; （最后一个字符是单个Unicode字符，表示带有重音符的&amp;ldquo; e&amp;rdquo;）。由于最后一个字符是在ASCII范围之外定义的，因此不会将其映射为大写变体，从而导致 &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e492b1a4744d12effe76c9a0dc29e53bf345ccf" translate="yes" xml:space="preserve">
          <source>In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the &lt;code&gt;&amp;amp;&lt;/code&gt; operator can't be applied to the value's fields. For example, the following is not valid:</source>
          <target state="translated">在第一个匹配表达式中，将值复制（或移动）。在第二个匹配中，对相同存储位置的引用绑定到变量值。之所以需要这种语法，是因为在分解子模式时， &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符不能应用于值的字段。例如，以下无效：</target>
        </trans-unit>
        <trans-unit id="963b4be1c96ed23abf1f14a5ca37f0831c8c64ef" translate="yes" xml:space="preserve">
          <source>In the following example, we make the &lt;code&gt;call_from_c&lt;/code&gt; function accessible from C code, after it&amp;rsquo;s compiled to a shared library and linked from C:</source>
          <target state="translated">在以下示例中，在将 &lt;code&gt;call_from_c&lt;/code&gt; 函数编译到共享库并从C链接之后，我们使C语言可以访问call_from_c函数：</target>
        </trans-unit>
        <trans-unit id="ab9b978885ac92b130a921c64c6e0cb297ec938c" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="translated">在一般情况下，通过首先收集到 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 来完成对 &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; 收集。也就是说，编写以下内容时：</target>
        </trans-unit>
        <trans-unit id="068c8963b2ca078d181d2b0a51e8af10dd52ecbb" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="translated">在一般情况下，通过首先收集到 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 来完成收集到 &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; &amp;gt;中。也就是说，编写以下内容时：</target>
        </trans-unit>
        <trans-unit id="acbd16055f21eb6fdaf455bf26541bd9198ef8ac" translate="yes" xml:space="preserve">
          <source>In the implementation of &lt;code&gt;outline_print&lt;/code&gt;, we want to use the &lt;code&gt;Display&lt;/code&gt; trait&amp;rsquo;s functionality. Therefore, we need to specify that the &lt;code&gt;OutlinePrint&lt;/code&gt; trait will work only for types that also implement &lt;code&gt;Display&lt;/code&gt; and provide the functionality that &lt;code&gt;OutlinePrint&lt;/code&gt; needs. We can do that in the trait definition by specifying &lt;code&gt;OutlinePrint: Display&lt;/code&gt;. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the &lt;code&gt;OutlinePrint&lt;/code&gt; trait.</source>
          <target state="translated">在执行 &lt;code&gt;outline_print&lt;/code&gt; 的过程中，我们要使用 &lt;code&gt;Display&lt;/code&gt; trait的功能。因此，我们需要指定 &lt;code&gt;OutlinePrint&lt;/code&gt; 特征仅适用于还实现 &lt;code&gt;Display&lt;/code&gt; 并提供 &lt;code&gt;OutlinePrint&lt;/code&gt; 所需功能的类型。我们可以通过指定 &lt;code&gt;OutlinePrint: Display&lt;/code&gt; 在特征定义中做到这一点。此技术类似于添加绑定到该特性的特性。清单19-22显示了 &lt;code&gt;OutlinePrint&lt;/code&gt; 特征的实现。</target>
        </trans-unit>
        <trans-unit id="81a422714f2fa87b38ce332890d1f64c8678f1a7" translate="yes" xml:space="preserve">
          <source>In the last arm, where we&amp;rsquo;ve specified a variable without a range, we do have the value available to use in the arm&amp;rsquo;s code in a variable named &lt;code&gt;id&lt;/code&gt;. The reason is that we&amp;rsquo;ve used the struct field shorthand syntax. But we haven&amp;rsquo;t applied any test to the value in the &lt;code&gt;id&lt;/code&gt; field in this arm, as we did with the first two arms: any value would match this pattern.</source>
          <target state="translated">在最后一个分支中，我们指定了一个不带范围的变量，我们确实在一个名为 &lt;code&gt;id&lt;/code&gt; 的变量中具有可用于分支代码中的值。原因是我们使用了struct字段的简写语法。但是，我们没有像前两个手臂那样对此分支的 &lt;code&gt;id&lt;/code&gt; 字段中的值进行任何测试：任何值都将与此模式匹配。</target>
        </trans-unit>
        <trans-unit id="8a42fbeac9d5cd28add8db6a4c34d47e67684d80" translate="yes" xml:space="preserve">
          <source>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call &lt;code&gt;join&lt;/code&gt; on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</source>
          <target state="translated">在主线程中，我们收集所有联接句柄。然后，如清单16-2所示，我们在每个句柄上调用 &lt;code&gt;join&lt;/code&gt; 以确保所有线程完成。此时，主线程将获取该锁并打印该程序的结果。</target>
        </trans-unit>
        <trans-unit id="04da7f268aa71a2c6ae0063d0f79d0cc060f8123" translate="yes" xml:space="preserve">
          <source>In the main thread, we&amp;rsquo;re not calling the &lt;code&gt;recv&lt;/code&gt; function explicitly anymore: instead, we&amp;rsquo;re treating &lt;code&gt;rx&lt;/code&gt; as an iterator. For each value received, we&amp;rsquo;re printing it. When the channel is closed, iteration will end.</source>
          <target state="translated">在主线程中，我们不再显式调用 &lt;code&gt;recv&lt;/code&gt; 函数：相反，我们将 &lt;code&gt;rx&lt;/code&gt; 视为迭代器。对于收到的每个值，我们都在打印它。当通道关闭时，迭代将结束。</target>
        </trans-unit>
        <trans-unit id="6a6bd022f18026c156e26cea87623c8cec496bfa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn&amp;rsquo;t be cleaned up unless it doesn&amp;rsquo;t have any edges pointing to it.</source>
          <target state="translated">在大多数情况下，所有权很明确：您确切知道哪个变量拥有给定值。但是，在某些情况下，单个值可能具有多个所有者。例如，在图形数据结构中，多个边可能指向同一个节点，并且从概念上讲，该节点归指向该节点的所有边所有。除非没有任何指向它的边缘，否则不应该清除该节点。</target>
        </trans-unit>
        <trans-unit id="b4fe9ca25f444c9952c260922e7715e70a50aab9" translate="yes" xml:space="preserve">
          <source>In the match expression for this code, we add a variable called &lt;code&gt;state&lt;/code&gt; to the pattern that matches values of the variant &lt;code&gt;Coin::Quarter&lt;/code&gt;. When a &lt;code&gt;Coin::Quarter&lt;/code&gt; matches, the &lt;code&gt;state&lt;/code&gt; variable will bind to the value of that quarter&amp;rsquo;s state. Then we can use &lt;code&gt;state&lt;/code&gt; in the code for that arm, like so:</source>
          <target state="translated">在此代码的match表达式中，我们向模式添加一个名为 &lt;code&gt;state&lt;/code&gt; 的变量，以匹配变体 &lt;code&gt;Coin::Quarter&lt;/code&gt; 。当 &lt;code&gt;Coin::Quarter&lt;/code&gt; 匹配时， &lt;code&gt;state&lt;/code&gt; 变量将绑定到该季度状态的值。然后，我们可以在代码中为该支路使用 &lt;code&gt;state&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="37676c5799bfd02feed7afe648d55c20c391e411" translate="yes" xml:space="preserve">
          <source>In the matcher, &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;&lt;code&gt;:&lt;/code&gt;&lt;em&gt;fragment-specifier&lt;/em&gt; matches a Rust syntax fragment of the kind specified and binds it to the metavariable &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;. Valid fragment specifiers are:</source>
          <target state="translated">在匹配器中， &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name &lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;fragment-specifier&lt;/em&gt;匹配&lt;em&gt;指定类型&lt;/em&gt;的Rust语法片段，并将其绑定到元变量 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt;。有效的片段说明符是：</target>
        </trans-unit>
        <trans-unit id="963b3e8473b4ab06c6410ca4e20e74e946590848" translate="yes" xml:space="preserve">
          <source>In the next chapter, we&amp;rsquo;ll look at some collection data structures in the standard library that you can use in your neatly organized code.</source>
          <target state="translated">在下一章中，我们将研究标准库中的一些集合数据结构，您可以在整洁的代码中使用它们。</target>
        </trans-unit>
        <trans-unit id="62f755e3daa908e0af290719bd4bb3bcad378eef" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 12 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">在清单9-2的输出中，回溯的第12行指向导致问题的项目中的行：&lt;em&gt;src / main.rs的&lt;/em&gt;第4行。如果我们不希望我们的程序崩溃，那么第一行提到我们编写的文件所指向的位置就是我们应该开始调查的地方。在清单9-1中，我们故意编写了会恐慌的代码以演示如何使用回溯，解决恐慌的方法是不从仅包含3个项的向量中请求索引99的元素。将来当您的代码出现紧急情况时，您需要弄清楚该代码正在采取什么措施以及导致该紧急情况的值以及应该执行的操作。</target>
        </trans-unit>
        <trans-unit id="c97b14b94a5006f9b4ef147bf12f463db5d6141e" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 17 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">在清单9-2的输出中，回溯的第17行指向导致问题的项目中的行：&lt;em&gt;src / main.rs的&lt;/em&gt;第4行。如果我们不希望我们的程序崩溃，那么第一行提到我们编写的文件所指向的位置就是我们应该开始调查的地方。在清单9-1中，我们故意编写了恐慌的代码以演示如何使用回溯，解决恐慌的方法是不从仅包含3个项目的向量中请求索引为99的元素。将来当您的代码出现紧急情况时，您将需要弄清楚该代码正在采取什么行动以及导致该紧急情况的值以及应该执行的操作。</target>
        </trans-unit>
        <trans-unit id="2a7555618db6cec5efbdcd91e0e2567f5d19799c" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 6 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">在清单9-2的输出中，回溯的第6行指向导致问题的项目中的行：&lt;em&gt;src / main.rs的&lt;/em&gt;第4行。如果我们不希望我们的程序崩溃，那么第一行提到我们编写的文件所指向的位置就是我们应该开始调查的地方。在清单9-1中，我们故意编写了恐慌的代码以演示如何使用回溯，解决恐慌的方法是不从仅包含3个项目的向量中请求索引为99的元素。将来当您的代码出现紧急情况时，您将需要弄清楚该代码正在采取什么行动以及导致该紧急情况的值以及应该执行的操作。</target>
        </trans-unit>
        <trans-unit id="ff1955a5e30929ce37102fab2f4935897b292825" translate="yes" xml:space="preserve">
          <source>In the previous section, we looked at how the &lt;code&gt;IpAddr&lt;/code&gt; enum let us use Rust&amp;rsquo;s type system to encode more information than just the data into our program. This section explores a case study of &lt;code&gt;Option&lt;/code&gt;, which is another enum defined by the standard library. The &lt;code&gt;Option&lt;/code&gt; type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing. Expressing this concept in terms of the type system means the compiler can check whether you&amp;rsquo;ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</source>
          <target state="translated">在上一节中，我们研究了 &lt;code&gt;IpAddr&lt;/code&gt; 枚举如何使我们使用Rust的类型系统来编码更多信息，而不仅仅是将数据编码到程序中。本节探讨 &lt;code&gt;Option&lt;/code&gt; 的案例研究，Option是标准库定义的另一个枚举。该 &lt;code&gt;Option&lt;/code&gt; 类型在很多地方使用，因为它编码中的值可能会是很常见的情况，也可能什么都不是。用类型系统来表达这个概念意味着编译器可以检查您是否已经处理了所有您应该处理的情况。此功能可以防止其他编程语言中极为常见的错误。</target>
        </trans-unit>
        <trans-unit id="7166e371e82ca092dfca006916f5e7d27ed3dcc0" translate="yes" xml:space="preserve">
          <source>In the previous section, we wanted to get the inner &lt;code&gt;T&lt;/code&gt; value out of the &lt;code&gt;Some&lt;/code&gt; case when using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;; we can also handle &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;match&lt;/code&gt; as we did with the &lt;code&gt;Coin&lt;/code&gt; enum! Instead of comparing coins, we&amp;rsquo;ll compare the variants of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, but the way that the &lt;code&gt;match&lt;/code&gt; expression works remains the same.</source>
          <target state="translated">在上一节中，我们希望使用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 时从 &lt;code&gt;Some&lt;/code&gt; case中获得内部 &lt;code&gt;T&lt;/code&gt; 值；我们也可以像使用 &lt;code&gt;Coin&lt;/code&gt; 枚举一样使用 &lt;code&gt;match&lt;/code&gt; 处理 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ！除了比较硬币以外，我们将比较 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 的变体，但是 &lt;code&gt;match&lt;/code&gt; 表达式的工作方式保持不变。</target>
        </trans-unit>
        <trans-unit id="021531d5da5d15cfe5b7187998d391941c64c620" translate="yes" xml:space="preserve">
          <source>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from &lt;code&gt;front_of_house&lt;/code&gt;. The &lt;code&gt;front_of_house&lt;/code&gt; module is defined within the same module as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, so the relative path starting from the module in which &lt;code&gt;eat_at_restaurant&lt;/code&gt; is defined works. Then, because &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;add_to_waitlist&lt;/code&gt; are marked with &lt;code&gt;pub&lt;/code&gt;, the rest of the path works, and this function call is valid!</source>
          <target state="translated">在相对路径中，除了第一步外，逻辑与绝对路径相同：路径不是从板条箱根开始， &lt;code&gt;front_of_house&lt;/code&gt; 从front_of_house开始。所述 &lt;code&gt;front_of_house&lt;/code&gt; 模块相同的模块中定义的 &lt;code&gt;eat_at_restaurant&lt;/code&gt; ，所以相对的路径从该模块开始 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 定义作品。然后，因为 &lt;code&gt;hosting&lt;/code&gt; 和 &lt;code&gt;add_to_waitlist&lt;/code&gt; 都标有 &lt;code&gt;pub&lt;/code&gt; ，路径工程的其余部分，而这个函数调用是有效的！</target>
        </trans-unit>
        <trans-unit id="34eddaeb0b0b8fe0265b13cd54b792a68e5d0a8d" translate="yes" xml:space="preserve">
          <source>In the restaurant industry, some parts of a restaurant are referred to as &lt;em&gt;front of house&lt;/em&gt; and others as &lt;em&gt;back of house&lt;/em&gt;. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.</source>
          <target state="translated">在餐饮业中，餐厅的某些部分称为&lt;em&gt;房屋前部，&lt;/em&gt;而其他部分称为&lt;em&gt;房屋后部&lt;/em&gt;。屋前就是顾客的所在。主机在这里招待客户，服务器在接受订单和付款，调酒师在这里喝酒。屋后是厨师在厨房工作，洗碗碟机，经理进行行政工作的地方。</target>
        </trans-unit>
        <trans-unit id="d2fbd57442ab7172a121e226a86228020af2eb14" translate="yes" xml:space="preserve">
          <source>In the second &lt;code&gt;use&lt;/code&gt; statement, we chose the new name &lt;code&gt;IoResult&lt;/code&gt; for the &lt;code&gt;std::io::Result&lt;/code&gt; type, which won&amp;rsquo;t conflict with the &lt;code&gt;Result&lt;/code&gt; from &lt;code&gt;std::fmt&lt;/code&gt; that we&amp;rsquo;ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!</source>
          <target state="translated">在第二个 &lt;code&gt;use&lt;/code&gt; 的语句，我们选择了新名称 &lt;code&gt;IoResult&lt;/code&gt; 为 &lt;code&gt;std::io::Result&lt;/code&gt; 类型，将与不冲突 &lt;code&gt;Result&lt;/code&gt; 从 &lt;code&gt;std::fmt&lt;/code&gt; ，我们也已经纳入范围。清单7-15和清单7-16被认为是惯用的，因此选择取决于您！</target>
        </trans-unit>
        <trans-unit id="adc1d9d12c1d2bddf332118061c6c7cd3ce7bb85" translate="yes" xml:space="preserve">
          <source>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&amp;rsquo;t have a variable that contains the actual value of the &lt;code&gt;id&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; field&amp;rsquo;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&amp;rsquo;t know which it is. The pattern code isn&amp;rsquo;t able to use the value from the &lt;code&gt;id&lt;/code&gt; field, because we haven&amp;rsquo;t saved the &lt;code&gt;id&lt;/code&gt; value in a variable.</source>
          <target state="translated">在第二个分支中，我们只有模式中指定的范围，与该分支关联的代码没有包含 &lt;code&gt;id&lt;/code&gt; 字段实际值的变量。该 &lt;code&gt;id&lt;/code&gt; 字段的值可能是10，11或12，但与该模式而来的代码不知道它是。模式代码无法使用 &lt;code&gt;id&lt;/code&gt; 字段中的值，因为我们尚未将 &lt;code&gt;id&lt;/code&gt; 值保存在变量中。</target>
        </trans-unit>
        <trans-unit id="555ee2d5bf80e581edd3155ac1632a3804b80f34" translate="yes" xml:space="preserve">
          <source>In the second case, it mentions that a private item &quot;can be accessed&quot; by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</source>
          <target state="translated">在第二种情况下,它提到一个私有项目 &quot;可以被当前的模块及其后代访问&quot;,但访问一个项目的确切含义取决于该项目是什么。例如,访问一个模块,就意味着在它的内部寻找(导入更多的项目)。另一方面,访问一个函数将意味着它被调用。此外,路径表达式和导入语句被认为是访问一个项目,因为导入/表达式只有在目标在当前可见范围内才有效。</target>
        </trans-unit>
        <trans-unit id="16e34afb2acb9f1c8b1247e4ecd62d975388d5ff" translate="yes" xml:space="preserve">
          <source>In the second error, we tried to bind the &lt;code&gt;Jak&lt;/code&gt; enum directly, which is not possible: you can only bind one of its variants. To do so:</source>
          <target state="translated">在第二个错误中，我们尝试直接绑定 &lt;code&gt;Jak&lt;/code&gt; 枚举，这是不可能的：您只能绑定其变体之一。为此：</target>
        </trans-unit>
        <trans-unit id="75974ca9e444bb30cc1d72502f982a23696566b5" translate="yes" xml:space="preserve">
          <source>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</source>
          <target state="translated">在第二个错误中,你不能在一个项目上实现一些东西,只能在类型上实现。如果我们想做类似的事情,我们需要创建一个新的类型。</target>
        </trans-unit>
        <trans-unit id="b3e1b0f0f7f1d23b0a9789a638c11ce7f83e6698" translate="yes" xml:space="preserve">
          <source>In the second you can do it by simply removing &lt;code&gt;'b&lt;/code&gt; so they both use &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="translated">在第二个步骤中，您可以通过简单地删除 &lt;code&gt;'b&lt;/code&gt; 使其都使用 &lt;code&gt;'a&lt;/code&gt; 来做到这一点：</target>
        </trans-unit>
        <trans-unit id="cde08af4b5bbaaf0718281f4cc2fdcf3ef098583" translate="yes" xml:space="preserve">
          <source>In the signature for &lt;code&gt;area&lt;/code&gt;, we use &lt;code&gt;&amp;amp;self&lt;/code&gt; instead of &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; because Rust knows the type of &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Rectangle&lt;/code&gt; due to this method&amp;rsquo;s being inside the &lt;code&gt;impl Rectangle&lt;/code&gt; context. Note that we still need to use the &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt;, just as we did in &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt;. Methods can take ownership of &lt;code&gt;self&lt;/code&gt;, borrow &lt;code&gt;self&lt;/code&gt; immutably as we&amp;rsquo;ve done here, or borrow &lt;code&gt;self&lt;/code&gt; mutably, just as they can any other parameter.</source>
          <target state="translated">在 &lt;code&gt;area&lt;/code&gt; 的签名中，我们使用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 而不是 &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; 因为Rust知道 &lt;code&gt;self&lt;/code&gt; 的类型是 &lt;code&gt;Rectangle&lt;/code&gt; ,因为该方法位于 &lt;code&gt;impl Rectangle&lt;/code&gt; 上下文中。需要注意的是，我们仍然需要使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 之前 &lt;code&gt;self&lt;/code&gt; ，就像我们在做 &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; 。方法可以取得 &lt;code&gt;self&lt;/code&gt; 所有权，像我们在这里所做的那样，不可变地借用 &lt;code&gt;self&lt;/code&gt; ，或者可变地借用 &lt;code&gt;self&lt;/code&gt; ，就像它们可以使用任何其他参数一样。</target>
        </trans-unit>
        <trans-unit id="15bf74e663ebaabe244e5b40c6c296178b0d40e8" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">在标准库中，指针类型通常不具有结构固定，因此它们不提供固定投影。这就是 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 固定所有 &lt;code&gt;T&lt;/code&gt; 的原因。这是有道理的为指针类型做到这一点，因为移动 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 实际上并不移动 &lt;code&gt;T&lt;/code&gt; ：该&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;可以自由移动（又名 &lt;code&gt;Unpin&lt;/code&gt; ），即使 &lt;code&gt;T&lt;/code&gt; 不是。实际上，即使&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 和&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 总是总是自己&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;，原因相同：它们的内容（ &lt;code&gt;T&lt;/code&gt; ）是固定的，但指针本身可以移动而无需移动固定的数据。对于&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ，内容是否固定与指针是否固定完全无关，这意味着固定&lt;em&gt;不是&lt;/em&gt;结构化的。</target>
        </trans-unit>
        <trans-unit id="b01eb539066ab2d6a68111a77de7d3391be1abdf" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;code&gt;Unpin&lt;/code&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">在标准库中，指针类型通常不具有结构固定，因此它们不提供固定投影。这就是 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 固定所有 &lt;code&gt;T&lt;/code&gt; 的原因。这是有道理的为指针类型做到这一点，因为移动 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 实际上并不移动 &lt;code&gt;T&lt;/code&gt; ：该 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 可以自由移动（又名 &lt;code&gt;Unpin&lt;/code&gt; ），即使 &lt;code&gt;T&lt;/code&gt; 不是。实际上，即使 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 总是总是自己 &lt;code&gt;Unpin&lt;/code&gt; 钉扎，原因相同：它们的内容（ &lt;code&gt;T&lt;/code&gt; ）被钉扎，但是指针本身可以移动而无需移动钉扎的数据。对彼此而言 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ，是否固定内容与指针是否固定完全无关，这意味着固定&lt;em&gt;不是&lt;/em&gt;结构化的。</target>
        </trans-unit>
        <trans-unit id="69a1bd27469eb2f59075cae2a36951b2f4c30b0e" translate="yes" xml:space="preserve">
          <source>In the test, we&amp;rsquo;re testing what happens when the &lt;code&gt;LimitTracker&lt;/code&gt; is told to set &lt;code&gt;value&lt;/code&gt; to something that is more than 75 percent of the &lt;code&gt;max&lt;/code&gt; value. First, we create a new &lt;code&gt;MockMessenger&lt;/code&gt;, which will start with an empty list of messages. Then we create a new &lt;code&gt;LimitTracker&lt;/code&gt; and give it a reference to the new &lt;code&gt;MockMessenger&lt;/code&gt; and a &lt;code&gt;max&lt;/code&gt; value of 100. We call the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt; with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the &lt;code&gt;MockMessenger&lt;/code&gt; is keeping track of should now have one message in it.</source>
          <target state="translated">在测试中，我们正在测试 &lt;code&gt;LimitTracker&lt;/code&gt; 被告知将 &lt;code&gt;value&lt;/code&gt; 设置为 &lt;code&gt;max&lt;/code&gt; 75％以上时发生的情况。首先，我们创建一个新的 &lt;code&gt;MockMessenger&lt;/code&gt; ，它将以一个空消息列表开始。然后，我们创建一个新的 &lt;code&gt;LimitTracker&lt;/code&gt; 并为其提供对新 &lt;code&gt;MockMessenger&lt;/code&gt; 的引用，且 &lt;code&gt;max&lt;/code&gt; 为100。我们在 &lt;code&gt;LimitTracker&lt;/code&gt; 上调用 &lt;code&gt;set_value&lt;/code&gt; 方法，该方法的值为80，该值大于100的75％。 &lt;code&gt;MockMessenger&lt;/code&gt; 跟踪的消息列表现在应该包含一条消息。</target>
        </trans-unit>
        <trans-unit id="adba8ce512afb3223e0e44bbc4efd34311d66e90" translate="yes" xml:space="preserve">
          <source>In the third case, we tried to only expect one variant of the &lt;code&gt;Wizard&lt;/code&gt; enum, which is not possible. To make this work, we need to using pattern matching over the &lt;code&gt;Wizard&lt;/code&gt; enum:</source>
          <target state="translated">在第三种情况下，我们试图只期望 &lt;code&gt;Wizard&lt;/code&gt; 枚举的一种变体，这是不可能的。为了使这项工作有效，我们需要在 &lt;code&gt;Wizard&lt;/code&gt; 枚举上使用模式匹配：</target>
        </trans-unit>
        <trans-unit id="7fe4d3d8b095874ffa846390a6fba933c59176e6" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">在转录器中，由于片段&lt;em&gt;名称&lt;/em&gt;是在匹配器中指定的，因此 &lt;code&gt;$&lt;/code&gt; 变量仅用$ &lt;em&gt;name&lt;/em&gt;来引用。将元变量替换为与之匹配的语法元素。关键字metavariable &lt;code&gt;$crate&lt;/code&gt; 可以用于引用当前的板条箱；参见下面的&lt;a href=&quot;#hygiene&quot;&gt;卫生&lt;/a&gt;。元变量可以被转录一次以上，也可以根本不被转录。</target>
        </trans-unit>
        <trans-unit id="474cfc53c29ed4a7f5438f6a16ce96a820777966" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">在转录器中，由于片段&lt;em&gt;名称&lt;/em&gt;是在匹配器中指定的，因此 &lt;code&gt;$&lt;/code&gt; 变量仅用$ &lt;em&gt;name&lt;/em&gt;来引用。将元变量替换为与它们匹配的语法元素。关键字metavariable &lt;code&gt;$crate&lt;/code&gt; 可用于引用当前的板条箱；参见下面的&lt;a href=&quot;macros-by-example#hygiene&quot;&gt;卫生&lt;/a&gt;。元变量可以被转录多次或完全不被转录。</target>
        </trans-unit>
        <trans-unit id="fc28b1beae2c194779de6e426a53754bfb37f82e" translate="yes" xml:space="preserve">
          <source>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don&amp;rsquo;t have: they can capture their environment and access variables from the scope in which they&amp;rsquo;re defined.</source>
          <target state="translated">在锻炼生成器示例中，我们仅将闭包用作嵌入式匿名函数。但是，闭包具有函数所没有的其他功能：它们可以捕获其环境并从定义它们的作用域访问变量。</target>
        </trans-unit>
        <trans-unit id="402986500120f551bc8e41d90bdabaccacec9185" translate="yes" xml:space="preserve">
          <source>In the worst case, the algorithm allocates temporary storage in a &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; the length of the slice.</source>
          <target state="translated">在最坏的情况下，该算法以切片长度 &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; 分配临时存储。</target>
        </trans-unit>
        <trans-unit id="2792c27ad83efd64abffe24df3a1fb1485fd08bf" translate="yes" xml:space="preserve">
          <source>In these examples, types of the &lt;code&gt;ba*&lt;/code&gt; are found by LUB coercion. And the compiler checks whether LUB coercion result of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;i32&lt;/code&gt; in the processing of the function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在这些示例中，通过LUB强制发现 &lt;code&gt;ba*&lt;/code&gt; 类型。然后，编译器会在函数 &lt;code&gt;foo&lt;/code&gt; 的处理中检查 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 的LUB强制结果是否为 &lt;code&gt;i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bc14d5532165c49508408bd484b7e97e6ac2646" translate="yes" xml:space="preserve">
          <source>In this appendix, we provide a reference of all the traits in the standard library that you can use with &lt;code&gt;derive&lt;/code&gt;. Each section covers:</source>
          <target state="translated">在本附录中，我们提供了标准库中可与 &lt;code&gt;derive&lt;/code&gt; 一起使用的所有特征的参考。每个部分包括：</target>
        </trans-unit>
        <trans-unit id="0046a6cf07943993e17ce12f3c78298391a2264f" translate="yes" xml:space="preserve">
          <source>In this appendix, we talk about some useful development tools that the Rust project provides. We&amp;rsquo;ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</source>
          <target state="translated">在本附录中，我们讨论了Rust项目提供的一些有用的开发工具。我们将研究自动格式化，应用警告修复的快速方法，lint和与IDE集成。</target>
        </trans-unit>
        <trans-unit id="ac9b1080783742689a97db16c3344339516e90c0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo&lt;/code&gt; is undefined, so it inherently isn't anything, and definitely not a struct.</source>
          <target state="translated">在这种情况下， &lt;code&gt;Foo&lt;/code&gt; 是未定义的，因此它本质上不是任何东西，并且绝对不是结构。</target>
        </trans-unit>
        <trans-unit id="afe608724d7fcb6b165ca3da57f4af8c6e2f8834" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Question&lt;/code&gt; would need to implement the &lt;code&gt;std::ops::Not&lt;/code&gt; trait in order to be able to use &lt;code&gt;!&lt;/code&gt; on it. Let's implement it:</source>
          <target state="translated">在这种情况下， &lt;code&gt;Question&lt;/code&gt; 将需要实现 &lt;code&gt;std::ops::Not&lt;/code&gt; trait才能使用 &lt;code&gt;!&lt;/code&gt; 在上面。让我们实现它：</target>
        </trans-unit>
        <trans-unit id="4b7473dc279144e44448cca5746abb04e0fa8694" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;c_double&lt;/code&gt; has the same size as &lt;code&gt;f64&lt;/code&gt; so we can use it directly:</source>
          <target state="translated">在这种情况下， &lt;code&gt;c_double&lt;/code&gt; 的大小与 &lt;code&gt;f64&lt;/code&gt; 相同，因此我们可以直接使用它：</target>
        </trans-unit>
        <trans-unit id="f3b4ba6190447ccb2a7d84efd7c0391f36cf1b3c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;foo&lt;/code&gt; is defined, but is not a struct, so Rust can't use it as one.</source>
          <target state="translated">在这种情况下，定义了 &lt;code&gt;foo&lt;/code&gt; ，但它不是一个结构，因此Rust不能将其用作一个。</target>
        </trans-unit>
        <trans-unit id="e3897adfb1b49645b05c0b83e391e1fc19ac894e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;len&lt;/code&gt; will be 4, which means the vector storing the string &amp;ldquo;Hola&amp;rdquo; is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</source>
          <target state="translated">在这种情况下， &lt;code&gt;len&lt;/code&gt; 将为4，这意味着存储字符串&amp;ldquo; Hola&amp;rdquo;的向量为4个字节长。以UTF-8编码时，这些字母中的每个字母都占用1个字节。但是下一行呢？ （请注意，此字符串以大写的西里尔字母Ze开头，而不是阿拉伯数字3。）</target>
        </trans-unit>
        <trans-unit id="8561b972a9830d06a3e257ff13fef28acb8d1808" translate="yes" xml:space="preserve">
          <source>In this case, borrowing &lt;code&gt;x&lt;/code&gt; mutably is not possible, because &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;mut&lt;/code&gt;. But at the same time, borrowing &lt;code&gt;x&lt;/code&gt; immutably would make the assignment illegal, because a &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; reference may not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows &lt;code&gt;x&lt;/code&gt; immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of &lt;code&gt;y&lt;/code&gt; will produce an error because it would violate the uniqueness of the closure's borrow of &lt;code&gt;x&lt;/code&gt;; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.</source>
          <target state="translated">在这种情况下，因为 &lt;code&gt;x&lt;/code&gt; 不是 &lt;code&gt;mut&lt;/code&gt; ，所以无法可变地借用 &lt;code&gt;x&lt;/code&gt; 。但是同时，一成不变地借用 &lt;code&gt;x&lt;/code&gt; 会使赋值非法，因为 &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; 引用可能不是唯一的，因此不能安全地用于修改值。因此，使用了唯一的不可变借位：它不可变地借入 &lt;code&gt;x&lt;/code&gt; ，但像可变借位一样，它必须是唯一的。在上面的示例中，取消对 &lt;code&gt;y&lt;/code&gt; 声明的注释将产生错误，因为它将违反闭包的 &lt;code&gt;x&lt;/code&gt; 借位的唯一性； z的声明是有效的，因为闭包的生存期已在该块的末尾到期，从而释放了借位。</target>
        </trans-unit>
        <trans-unit id="bf5da830ba52c31b3f48f71542b74085fca253da" translate="yes" xml:space="preserve">
          <source>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren&amp;rsquo;t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</source>
          <target state="translated">在这种情况下，在创建参考循环之后，程序立即结束。这个周期的后果不是很可怕。但是，如果一个更复杂的程序在一个周期内分配了很多内存并保留了很长时间，则该程序将使用比所需数量更多的内存，并且可能使系统不堪重负，从而导致可用内存不足。</target>
        </trans-unit>
        <trans-unit id="94ade146c6864efc0d837c6a05c5b82eb67849f1" translate="yes" xml:space="preserve">
          <source>In this case, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">在这种情况下，编译器无法推断 &lt;code&gt;x&lt;/code&gt; 的类型： &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 都是合适的候选者。要指定使用哪种类型，可以在 &lt;code&gt;x&lt;/code&gt; 上使用类型注释：</target>
        </trans-unit>
        <trans-unit id="f275640cc613a55c1aac0d980097965aad345a42" translate="yes" xml:space="preserve">
          <source>In this case, the line indicated is part of our code, and if we go to that line, we see the &lt;code&gt;panic!&lt;/code&gt; macro call. In other cases, the &lt;code&gt;panic!&lt;/code&gt; call might be in code that our code calls, and the filename and line number reported by the error message will be someone else&amp;rsquo;s code where the &lt;code&gt;panic!&lt;/code&gt; macro is called, not the line of our code that eventually led to the &lt;code&gt;panic!&lt;/code&gt; call. We can use the backtrace of the functions the &lt;code&gt;panic!&lt;/code&gt; call came from to figure out the part of our code that is causing the problem. We&amp;rsquo;ll discuss what a backtrace is in more detail next.</source>
          <target state="translated">在这种情况下，指示的行是代码的一部分，如果转到该行，我们会感到 &lt;code&gt;panic!&lt;/code&gt; 宏调用。在其他情况下， &lt;code&gt;panic!&lt;/code&gt; 调用可能是在我们的代码调用的代码中，而错误消息报告的文件名和行号将是其他人的代码，因此 &lt;code&gt;panic!&lt;/code&gt; 宏被调用，而不是最终导致 &lt;code&gt;panic!&lt;/code&gt; 代码行！呼叫。我们可以使用函数的回溯来 &lt;code&gt;panic!&lt;/code&gt; 调用来自于找出导致问题的代码部分。接下来，我们将详细讨论回溯。</target>
        </trans-unit>
        <trans-unit id="a03c0650d25cf706ca4c711a0b4fa0c7cdd46367" translate="yes" xml:space="preserve">
          <source>In this case, you need to implement the &lt;code&gt;chocolate&lt;/code&gt; method to fix the error:</source>
          <target state="translated">在这种情况下，您需要实现 &lt;code&gt;chocolate&lt;/code&gt; 方法来修复错误：</target>
        </trans-unit>
        <trans-unit id="8dfdeb564b13d0de24ae4a70c8a6c9f64176934b" translate="yes" xml:space="preserve">
          <source>In this chapter and throughout the book, we&amp;rsquo;ll show some commands used in the terminal. Lines that you should enter in a terminal all start with &lt;code&gt;$&lt;/code&gt;. You don&amp;rsquo;t need to type in the &lt;code&gt;$&lt;/code&gt; character; it indicates the start of each command. Lines that don&amp;rsquo;t start with &lt;code&gt;$&lt;/code&gt; typically show the output of the previous command. Additionally, PowerShell-specific examples will use &lt;code&gt;&amp;gt;&lt;/code&gt; rather than &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">在本章以及整本书中，我们将展示一些在终端中使用的命令。您应在终端中输入的行均以 &lt;code&gt;$&lt;/code&gt; 开头。您无需输入 &lt;code&gt;$&lt;/code&gt; 字符；它指示每个命令的开始。不以 &lt;code&gt;$&lt;/code&gt; 开头的行通常显示前一个命令的输出。此外，特定于PowerShell的示例将使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f1d6f9bd53aa4df418aa201b887fdd6df55aeab" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible &lt;em&gt;variants&lt;/em&gt;. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">在这一章中，我们将介绍&lt;em&gt;枚举&lt;/em&gt;，也称为&lt;em&gt;枚举&lt;/em&gt;。枚举允许您通过枚举可能的&lt;em&gt;变体&lt;/em&gt;来定义类型。首先，我们将定义并使用一个枚举来显示枚举如何将含义与数据一起编码。接下来，我们将探讨一个称为 &lt;code&gt;Option&lt;/code&gt; 的特别有用的枚举，该枚举表示一个值可以是某些东西或什么都可以。然后，我们来看一下 &lt;code&gt;match&lt;/code&gt; 表达式中的模式匹配如何使为枚举的不同值轻松运行不同的代码。最后，我们将介绍 &lt;code&gt;if let&lt;/code&gt; 构造如何为您提供另一个方便且简洁的习惯用法，以处理代码中的枚举。</target>
        </trans-unit>
        <trans-unit id="511940d9b79e52eebc6c566f728bbaeb0dd1dd34" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible values. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">在这一章中，我们将研究&lt;em&gt;枚举&lt;/em&gt;，也称为&lt;em&gt;枚举&lt;/em&gt;。枚举允许您通过枚举可能的值来定义类型。首先，我们将定义并使用一个枚举来显示枚举如何将含义与数据一起编码。接下来，我们将探讨一个名为 &lt;code&gt;Option&lt;/code&gt; 的特别有用的枚举，该枚举表示一个值可以是某些东西或什么都可以。然后，我们将研究 &lt;code&gt;match&lt;/code&gt; 表达式中的模式匹配如何使为枚举的不同值运行不同的代码变得容易。最后，我们将介绍 &lt;code&gt;if let&lt;/code&gt; 构造如何为您提供另一个方便且简洁的惯用法来处理代码中的枚举。</target>
        </trans-unit>
        <trans-unit id="54bfe40f65e4baf089b3fdf58b27393a8784f4c8" translate="yes" xml:space="preserve">
          <source>In this chapter, we won&amp;rsquo;t debate the issue of what functional programming is or isn&amp;rsquo;t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</source>
          <target state="translated">在本章中，我们将不讨论什么是函数编程或什么不是函数编程的问题，而将讨论Rust的某些功能，这些功能与许多语言（通常称为函数）的功能相似。</target>
        </trans-unit>
        <trans-unit id="1a7486659e0b2248f370c5b62acbfa92d0246aa8" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!</source>
          <target state="translated">在本章中，我们将介绍所有这些功能，讨论它们如何交互，并解释如何使用它们来管理范围。最后，您应该对模块系统有深入的了解，并且能够像专业人士一样使用示波器！</target>
        </trans-unit>
        <trans-unit id="323ae7b14fd96e68551f003142bf4b84170544d5" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover:</source>
          <target state="translated">在本章中，我们将介绍：</target>
        </trans-unit>
        <trans-unit id="a4639a7fb71c7cc2724cbe31da70376d99c56baa" translate="yes" xml:space="preserve">
          <source>In this code, the first and last value are matched with &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;. The &lt;code&gt;..&lt;/code&gt; will match and ignore everything in the middle.</source>
          <target state="translated">在此代码中，第一个和最后一个值与 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 匹配。该 &lt;code&gt;..&lt;/code&gt; 将匹配而忽略中间的一切。</target>
        </trans-unit>
        <trans-unit id="145a83e849a55e3baebf66ad497473ddcd7f5f55" translate="yes" xml:space="preserve">
          <source>In this code, the same thing happens as in the &lt;code&gt;match&lt;/code&gt; in Listing 19-26: Rust sees that &lt;code&gt;val&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;panic!&lt;/code&gt; has the type &lt;code&gt;!&lt;/code&gt;, so the result of the overall &lt;code&gt;match&lt;/code&gt; expression is &lt;code&gt;T&lt;/code&gt;. This code works because &lt;code&gt;panic!&lt;/code&gt; doesn&amp;rsquo;t produce a value; it ends the program. In the &lt;code&gt;None&lt;/code&gt; case, we won&amp;rsquo;t be returning a value from &lt;code&gt;unwrap&lt;/code&gt;, so this code is valid.</source>
          <target state="translated">在这段代码中，发生了 &lt;code&gt;match&lt;/code&gt; 清单19-26 中的匹配相同的事情：Rust看到 &lt;code&gt;val&lt;/code&gt; 具有类型 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;panic!&lt;/code&gt; 有类型 &lt;code&gt;!&lt;/code&gt; ，所以整体的结果 &lt;code&gt;match&lt;/code&gt; 表达式是 &lt;code&gt;T&lt;/code&gt; 。该代码有效，因为出现了 &lt;code&gt;panic!&lt;/code&gt; 没有产生价值；它结束程序。在 &lt;code&gt;None&lt;/code&gt; 的情况下，我们不会从 &lt;code&gt;unwrap&lt;/code&gt; 返回值，因此此代码有效。</target>
        </trans-unit>
        <trans-unit id="844247dc89592da735fc5622f72eb35876e2a2a2" translate="yes" xml:space="preserve">
          <source>In this code, you have two ways to solve this issue:</source>
          <target state="translated">在这段代码中,你有两种方法来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="4f5f63902ac52a2fdb77ae9b0aaf168362307239" translate="yes" xml:space="preserve">
          <source>In this context, by &lt;em&gt;runtime&lt;/em&gt; we mean code that is included by the language in every binary. This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code. For that reason, colloquially when people say a language has &amp;ldquo;no runtime,&amp;rdquo; they often mean &amp;ldquo;small runtime.&amp;rdquo; Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts. Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</source>
          <target state="translated">在这种情况下，在&lt;em&gt;运行时中，&lt;/em&gt;我们指的是语言包含在每个二进制文件中的代码。取决于语言，此代码可以大可小，但是每种非汇编语言都将具有一定数量的运行时代码。因此，通常人们在说一种语言&amp;ldquo;没有运行时&amp;rdquo;时，通常是指&amp;ldquo;小型运行时&amp;rdquo;。较小的运行时具有较少的功能，但具有产生较小二进制文件的优势，这使得在更多上下文中更轻松地将语言与其他语言结合在一起。尽管许多语言可以通过增加运行时大小来换取更多功能，但是Rust几乎不需要运行时，并且不能折衷使用C来保持性能。</target>
        </trans-unit>
        <trans-unit id="3f10f5106c28699182d72488c5b199580b51f515" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;2&lt;/code&gt; is destroyed right after the assignment, which means that &lt;code&gt;ptr&lt;/code&gt; now points to an unavailable location.</source>
          <target state="translated">在此示例中，分配后立即销毁了 &lt;code&gt;2&lt;/code&gt; ，这意味着 &lt;code&gt;ptr&lt;/code&gt; 现在指向不可用的位置。</target>
        </trans-unit>
        <trans-unit id="16ee00cd14e3198e4bb4ed77351c13a68c4d2964" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;BoxCar&lt;/code&gt; has two super-traits: &lt;code&gt;Vehicle&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt;. Both of these traits define an associated type &lt;code&gt;Color&lt;/code&gt;. &lt;code&gt;BoxCar&lt;/code&gt; inherits two types with that name from both super-traits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate &lt;code&gt;Color&lt;/code&gt; associated type, either &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; or &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt;, but this syntax is not allowed to be used in a function signature.</source>
          <target state="translated">在此示例中， &lt;code&gt;BoxCar&lt;/code&gt; 具有两个超级特征： &lt;code&gt;Vehicle&lt;/code&gt; 和 &lt;code&gt;Box&lt;/code&gt; 。这两个特征都定义了一个关联的类型 &lt;code&gt;Color&lt;/code&gt; 。 &lt;code&gt;BoxCar&lt;/code&gt; 会从两个超级特征继承具有该名称的两种类型。因此，我们需要使用完全限定的路径语法来引用相应的 &lt;code&gt;Color&lt;/code&gt; 关联类型，即 &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; 或 &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt; ，但是不允许使用此语法在功能签名中。</target>
        </trans-unit>
        <trans-unit id="8e0ee0316ee57e8497270b5ce77464ecb56adca2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Cat&lt;/code&gt; is a &lt;em&gt;struct-like enum variant&lt;/em&gt;, whereas &lt;code&gt;Dog&lt;/code&gt; is simply called an enum variant. Each enum instance has a &lt;em&gt;discriminant&lt;/em&gt; which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt;&lt;code&gt;mem::discriminant&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">在此示例中， &lt;code&gt;Cat&lt;/code&gt; 是类似&lt;em&gt;struct的枚举变量&lt;/em&gt;，而 &lt;code&gt;Dog&lt;/code&gt; 简称为枚举变量。每个枚举实例都有一个&lt;em&gt;判别式&lt;/em&gt;，该&lt;em&gt;判别式&lt;/em&gt;是与之关联的整数，用于确定其拥有哪个变体。可以使用&lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt; &lt;code&gt;mem::discriminant&lt;/code&gt; &lt;/a&gt;函数获得对该判别式的不透明引用。</target>
        </trans-unit>
        <trans-unit id="7bb9799e70052b9e454a954f47a55d73983d300f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Foo&lt;/code&gt; defines an associated type &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;Bar&lt;/code&gt; inherits that type from &lt;code&gt;Foo&lt;/code&gt;, and defines another associated type of the same name. As a result, when we attempt to use &lt;code&gt;Self::A&lt;/code&gt;, it's ambiguous whether we mean the &lt;code&gt;A&lt;/code&gt; defined by &lt;code&gt;Foo&lt;/code&gt; or the one defined by &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">在此实例中， &lt;code&gt;Foo&lt;/code&gt; 定义的关联类型 &lt;code&gt;A&lt;/code&gt; 。 &lt;code&gt;Bar&lt;/code&gt; 从 &lt;code&gt;Foo&lt;/code&gt; 继承该类型，并定义了另一个具有相同名称的关联类型。结果，当我们尝试使用 &lt;code&gt;Self::A&lt;/code&gt; ，是指由 &lt;code&gt;Foo&lt;/code&gt; 定义的 &lt;code&gt;A&lt;/code&gt; 还是由 &lt;code&gt;Bar&lt;/code&gt; 定义的A都是不明确的。</target>
        </trans-unit>
        <trans-unit id="8cedc14f701bbdf96ac8102b9f064b1dca2f26cb" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Y&lt;/code&gt; cannot refer to &lt;code&gt;X&lt;/code&gt; here. To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">在此示例中， &lt;code&gt;Y&lt;/code&gt; 在这里不能引用 &lt;code&gt;X&lt;/code&gt; 。要解决此问题，可以将值提取为const，然后使用：</target>
        </trans-unit>
        <trans-unit id="ea4ed47b5eac4878ae970fa360382b182707dcb9" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;string1&lt;/code&gt; is valid until the end of the outer scope, &lt;code&gt;string2&lt;/code&gt; is valid until the end of the inner scope, and &lt;code&gt;result&lt;/code&gt; references something that is valid until the end of the inner scope. Run this code, and you&amp;rsquo;ll see that the borrow checker approves of this code; it will compile and print &lt;code&gt;The longest string is long string is long&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;string1&lt;/code&gt; 在外部作用域结束之前一直有效， &lt;code&gt;string2&lt;/code&gt; 在内部作用域结束之前一直有效，并且 &lt;code&gt;result&lt;/code&gt; 引用的有效范围直到内部作用域结束为止。运行此代码，您将看到借用检查器批准了该代码；它将编译并打印 &lt;code&gt;The longest string is long string is long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a21a4f7cf44738665bcf722c117e87d97dd2b44" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;value&lt;/code&gt; is mutably borrowed by &lt;code&gt;borrow&lt;/code&gt; and cannot be used to calculate &lt;code&gt;sum&lt;/code&gt;. This is not possible because this would violate Rust's mutability rules.</source>
          <target state="translated">在这个例子中， &lt;code&gt;value&lt;/code&gt; 是由性情不定地借用 &lt;code&gt;borrow&lt;/code&gt; 并且不能被用于计算 &lt;code&gt;sum&lt;/code&gt; 。这是不可能的，因为这会违反Rust的可变性规则。</target>
        </trans-unit>
        <trans-unit id="ee5fd415a36736dbb42604438d3e115f3ef63293" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;x&lt;/code&gt; matches the pattern &lt;code&gt;(0, _)&lt;/code&gt;, the second field is set to &lt;code&gt;y&lt;/code&gt;. If it matches &lt;code&gt;(_, 0)&lt;/code&gt;, the first field is set to &lt;code&gt;y&lt;/code&gt;; so in all cases &lt;code&gt;y&lt;/code&gt; is set to some value.</source>
          <target state="translated">在此示例中，如果 &lt;code&gt;x&lt;/code&gt; 与模式 &lt;code&gt;(0, _)&lt;/code&gt; 匹配，则第二个字段设置为 &lt;code&gt;y&lt;/code&gt; 。如果匹配 &lt;code&gt;(_, 0)&lt;/code&gt; ，则第一个字段设置为 &lt;code&gt;y&lt;/code&gt; ；因此在所有情况下 &lt;code&gt;y&lt;/code&gt; 都设置为某个值。</target>
        </trans-unit>
        <trans-unit id="7fe9cc71a505a06c66b5d9f57153a2d3327a9165" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;'SnowWhite&lt;/code&gt; lifetime is supposed to outlive the &lt;code&gt;'kiss&lt;/code&gt; lifetime but the declaration of the &lt;code&gt;Prince&lt;/code&gt; struct doesn't enforce it. To fix this issue, you need to specify it:</source>
          <target state="translated">在此示例中， &lt;code&gt;'SnowWhite&lt;/code&gt; 生存期应该超过 &lt;code&gt;'kiss&lt;/code&gt; 生存期，但是 &lt;code&gt;Prince&lt;/code&gt; 结构的声明并未强制执行。要解决此问题，您需要指定它：</target>
        </trans-unit>
        <trans-unit id="5793bd2e6d3c5293d83c901c5867d17a61fb1b7b" translate="yes" xml:space="preserve">
          <source>In this example, the closure does not satisfy the &lt;code&gt;'static&lt;/code&gt; lifetime constraint. To fix this error, you need to double check the lifetime of the type. Here, we can fix this problem by giving &lt;code&gt;s&lt;/code&gt; a static lifetime:</source>
          <target state="translated">在该示例中，闭包不满足 &lt;code&gt;'static&lt;/code&gt; 寿命约束&amp;rdquo;。要解决此错误，您需要仔细检查该类型的生存期。在这里，我们可以通过赋予 &lt;code&gt;s&lt;/code&gt; 静态寿命来解决此问题：</target>
        </trans-unit>
        <trans-unit id="c61f98e2cee2baaabf8be1956ffb960bd279fb24" translate="yes" xml:space="preserve">
          <source>In this example, the module &lt;code&gt;quux&lt;/code&gt; re-exports two public names defined in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在此示例中，模块 &lt;code&gt;quux&lt;/code&gt; 重新导出 &lt;code&gt;foo&lt;/code&gt; 中定义的两个公用名。</target>
        </trans-unit>
        <trans-unit id="4350bf464e116b6d57c761b20a820cb5925c37d3" translate="yes" xml:space="preserve">
          <source>In this example, the spawned thread is &quot;detached&quot; from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.</source>
          <target state="translated">在这个例子中,被产卵的线程是 &quot;脱离 &quot;于当前线程的,这意味着它的寿命可以超过它的父线程(产卵的线程),除非这个父线程是主线程。这意味着它的寿命可以超过它的父线程(产生它的线程),除非这个父线程是主线程。</target>
        </trans-unit>
        <trans-unit id="adb1f627c4f5f533a368664ad1bfd6b52635fef6" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Foo&lt;/code&gt; and the trait method &lt;code&gt;do_something_else&lt;/code&gt; both define a type parameter &lt;code&gt;T&lt;/code&gt;. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</source>
          <target state="translated">在这个例子中，所述性状 &lt;code&gt;Foo&lt;/code&gt; 和性状方法 &lt;code&gt;do_something_else&lt;/code&gt; 的都定义了类型参数 &lt;code&gt;T&lt;/code&gt; 。这是不允许的：如果该方法希望定义类型参数，则必须为其使用不同的名称。</target>
        </trans-unit>
        <trans-unit id="5106de7dace445aa59aa82effd4989b6c9358ae0" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Printable&lt;/code&gt; occurs as a trait object in both the type signature of &lt;code&gt;print&lt;/code&gt;, and the cast expression in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">在此示例中，特征 &lt;code&gt;Printable&lt;/code&gt; 在 &lt;code&gt;print&lt;/code&gt; 的类型签名和 &lt;code&gt;main&lt;/code&gt; 中的强制类型转换表达式中均作为特征对象出现。</target>
        </trans-unit>
        <trans-unit id="2c7b2451157bfe66dfc5ae3bcc7df818cb052f87" translate="yes" xml:space="preserve">
          <source>In this example, the value &lt;code&gt;p&lt;/code&gt; matches the second arm by virtue of &lt;code&gt;x&lt;/code&gt; containing a 0, so this code will print &lt;code&gt;On the y axis at 7&lt;/code&gt;.</source>
          <target state="translated">在此示例中，值 &lt;code&gt;p&lt;/code&gt; 由于 &lt;code&gt;x&lt;/code&gt; 包含0 而与第二条臂匹配，因此此代码将 &lt;code&gt;On the y axis at 7&lt;/code&gt; 打印。</target>
        </trans-unit>
        <trans-unit id="76e376bb135f5c25de32c031f91a381023081f30" translate="yes" xml:space="preserve">
          <source>In this example, the variable named &lt;code&gt;first&lt;/code&gt; will get the value &lt;code&gt;1&lt;/code&gt;, because that is the value at index &lt;code&gt;[0]&lt;/code&gt; in the array. The variable named &lt;code&gt;second&lt;/code&gt; will get the value &lt;code&gt;2&lt;/code&gt; from index &lt;code&gt;[1]&lt;/code&gt; in the array.</source>
          <target state="translated">在此示例中，名为 &lt;code&gt;first&lt;/code&gt; 的变量将获得值 &lt;code&gt;1&lt;/code&gt; ，因为它是数组中索引 &lt;code&gt;[0]&lt;/code&gt; 处的值。名为 &lt;code&gt;second&lt;/code&gt; 的变量将从数组中的索引 &lt;code&gt;[1]&lt;/code&gt; 获取值 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db1c89f552fe6cd5046ff6bd0d230e80deb004f6" translate="yes" xml:space="preserve">
          <source>In this example, we are asserting that the destructor for &lt;code&gt;Foo&lt;/code&gt; will not access any data of type &lt;code&gt;X&lt;/code&gt;, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this &lt;code&gt;impl&lt;/code&gt; as unsafe.</source>
          <target state="translated">在此示例中，我们断言 &lt;code&gt;Foo&lt;/code&gt; 的析构函数将不会访问 &lt;code&gt;X&lt;/code&gt; 类型的任何数据，并且要求此断言对我们程序的整体安全性为true。编译器当前不尝试验证此断言。因此，我们必须将此 &lt;code&gt;impl&lt;/code&gt; 标签标记为不安全。</target>
        </trans-unit>
        <trans-unit id="5b639017ef60ffaf0981282e4da6c27fcdd578e1" translate="yes" xml:space="preserve">
          <source>In this example, we define a function &lt;code&gt;ten_times&lt;/code&gt; that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.</source>
          <target state="translated">在此示例中，我们定义一个函数 &lt;code&gt;ten_times&lt;/code&gt; ，该函数接受一个高阶函数参数，然后以闭包表达式作为参数来调用它，然后是一个从环境中移出值的闭包表达式。</target>
        </trans-unit>
        <trans-unit id="65cd159213dbe5caf10e5067fe9f06a95f76f236" translate="yes" xml:space="preserve">
          <source>In this example, we have to instantiate &lt;code&gt;'x&lt;/code&gt;, and we don't know what lifetime to instantiate it with. To fix this, spell out the precise lifetimes involved. Example:</source>
          <target state="translated">在此示例中，我们必须实例化 &lt;code&gt;'x&lt;/code&gt; ，并且我们不知道该实例化的寿命。要解决此问题，请阐明所涉及的确切寿命。例子：</target>
        </trans-unit>
        <trans-unit id="9be8015724a60f5a7de7fc8be3cf3fbc9130aa82" translate="yes" xml:space="preserve">
          <source>In this example, we tried to set a value with an incompatible lifetime to another one (&lt;code&gt;'long&lt;/code&gt; is unrelated to &lt;code&gt;'short&lt;/code&gt;). We can solve this issue in two different ways:</source>
          <target state="translated">在此示例中，我们尝试设置一个寿命与另一个寿命不兼容的值（ &lt;code&gt;'long&lt;/code&gt; 与 &lt;code&gt;'short&lt;/code&gt; 无关）。我们可以通过两种不同的方式解决此问题：</target>
        </trans-unit>
        <trans-unit id="8385385b7c5acae88f390fa2486165f8a8931f92" translate="yes" xml:space="preserve">
          <source>In this example, we tried to use the non-existent associated type &lt;code&gt;You&lt;/code&gt; of the &lt;code&gt;Hello&lt;/code&gt; trait. To fix this error, use an existing associated type:</source>
          <target state="translated">在这个例子中，我们试图使用不存在相关类型 &lt;code&gt;You&lt;/code&gt; 的的 &lt;code&gt;Hello&lt;/code&gt; 特质。要解决此错误，请使用现有的关联类型：</target>
        </trans-unit>
        <trans-unit id="0bbce52117883bf5718cfbbb01cfe64f9309a2ae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the parameter &lt;code&gt;x&lt;/code&gt; and the return type, but not for the parameter &lt;code&gt;y&lt;/code&gt;, because the lifetime of &lt;code&gt;y&lt;/code&gt; does not have any relationship with the lifetime of &lt;code&gt;x&lt;/code&gt; or the return value.</source>
          <target state="translated">在此示例中，我们为参数 &lt;code&gt;x&lt;/code&gt; 和返回类型指定了寿命参数 &lt;code&gt;'a&lt;/code&gt; ，但没有为参数 &lt;code&gt;y&lt;/code&gt; 指定寿命参数，因为 &lt;code&gt;y&lt;/code&gt; 的寿命与 &lt;code&gt;x&lt;/code&gt; 的寿命或返回值没有任何关系。</target>
        </trans-unit>
        <trans-unit id="2185efdb59ae63a632adf24d45f191ffee2411df" translate="yes" xml:space="preserve">
          <source>In this example, when we assign the integer value 5 to &lt;code&gt;x&lt;/code&gt;, we let the compiler know that the generic type &lt;code&gt;T&lt;/code&gt; will be an integer for this instance of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. Then when we specify 4.0 for &lt;code&gt;y&lt;/code&gt;, which we&amp;rsquo;ve defined to have the same type as &lt;code&gt;x&lt;/code&gt;, we&amp;rsquo;ll get a type mismatch error like this:</source>
          <target state="translated">在此示例中，当我们将整数值5分配给 &lt;code&gt;x&lt;/code&gt; 时，我们让编译器知道，对于 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 此实例，泛型 &lt;code&gt;T&lt;/code&gt; 将为整数。然后，当我们为 &lt;code&gt;y&lt;/code&gt; 指定4.0时，我们将其定义为与 &lt;code&gt;x&lt;/code&gt; 具有相同的类型，我们将得到如下类型不匹配错误：</target>
        </trans-unit>
        <trans-unit id="af5f4c7efbea71694085e036fb3fca287f7c1342" translate="yes" xml:space="preserve">
          <source>In this example, you can see that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; enables mutation inside an immutable struct. In other words, it enables &quot;interior mutability&quot;.</source>
          <target state="translated">在此示例中，您可以看到 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 启用了不可变结构内的突变。换句话说，它实现了&amp;ldquo;内部可变性&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="28ad91d98b4c69b8725ca2927cbfaca53b3c5e8d" translate="yes" xml:space="preserve">
          <source>In this implementation, the &lt;code&gt;to_string&lt;/code&gt; method panics if the &lt;code&gt;Display&lt;/code&gt; implementation returns an error. This indicates an incorrect &lt;code&gt;Display&lt;/code&gt; implementation since &lt;code&gt;fmt::Write for String&lt;/code&gt; never returns an error itself.</source>
          <target state="translated">在此实现中，如果 &lt;code&gt;Display&lt;/code&gt; 实现返回错误，则 &lt;code&gt;to_string&lt;/code&gt; 方法会感到恐慌。这表明 &lt;code&gt;Display&lt;/code&gt; 实现不正确，因为 &lt;code&gt;fmt::Write for String&lt;/code&gt; 永远不会返回错误。</target>
        </trans-unit>
        <trans-unit id="f07445d5d52a84f1a2b08af97ac8fb5214288938" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;&quot;not enough arguments&quot;&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">在此清单中，我们使用了之前未介绍的方法： &lt;code&gt;unwrap_or_else&lt;/code&gt; ，它是由标准库在 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 上定义的。使用 &lt;code&gt;unwrap_or_else&lt;/code&gt; 可以让我们定义一些自定义的，非 &lt;code&gt;panic!&lt;/code&gt; 错误处理。如果 &lt;code&gt;Result&lt;/code&gt; 是 &lt;code&gt;Ok&lt;/code&gt; 值，则此方法的行为类似于 &lt;code&gt;unwrap&lt;/code&gt; ：它返回 &lt;code&gt;Ok&lt;/code&gt; 正在包装的内部值。但是，如果值是 &lt;code&gt;Err&lt;/code&gt; 值，则此方法将调用&lt;em&gt;闭包中&lt;/em&gt;的代码，这是我们定义的匿名函数，并将其作为参数传递给 &lt;code&gt;unwrap_or_else&lt;/code&gt; 。我们将在下面更详细地介绍闭包&lt;a href=&quot;ch13-00-functional-features&quot;&gt;第13章&lt;/a&gt;。现在，您只需要知道 &lt;code&gt;unwrap_or_else&lt;/code&gt; 将传递 &lt;code&gt;Err&lt;/code&gt; 的内部值（在本例中是我们在清单12-9中添加的静态字符串 &lt;code&gt;&quot;not enough arguments&quot;&lt;/code&gt; 到出现的参数 &lt;code&gt;err&lt;/code&gt; 的闭包中即可。在垂直管道之间。然后，闭包中的代码在运行时可以使用 &lt;code&gt;err&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="7cf45f5e676953372bb64ede268b0f879c84bec0" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;not enough arguments&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">在此清单中，我们使用了之前未涉及的方法： &lt;code&gt;unwrap_or_else&lt;/code&gt; ，它是由标准库在 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 上定义的。使用 &lt;code&gt;unwrap_or_else&lt;/code&gt; 可让我们定义一些自定义的，非 &lt;code&gt;panic!&lt;/code&gt; 错误处理。如果 &lt;code&gt;Result&lt;/code&gt; 是 &lt;code&gt;Ok&lt;/code&gt; 值，则此方法的行为类似于 &lt;code&gt;unwrap&lt;/code&gt; ：它返回 &lt;code&gt;Ok&lt;/code&gt; 正在包装的内部值。但是，如果值是 &lt;code&gt;Err&lt;/code&gt; 值，则此方法将调用&lt;em&gt;闭包中&lt;/em&gt;的代码，这是我们定义的匿名函数，并将其作为参数传递给 &lt;code&gt;unwrap_or_else&lt;/code&gt; 。我们将在下面详细介绍闭包&lt;a href=&quot;ch13-00-functional-features&quot;&gt;第13章&lt;/a&gt;。现在，您只需要知道 &lt;code&gt;unwrap_or_else&lt;/code&gt; 将传递 &lt;code&gt;Err&lt;/code&gt; 的内部值（在本例中是静态字符串， &lt;code&gt;not enough arguments&lt;/code&gt; 清单12-9中没有添加足够的参数）将其传递给在 &lt;code&gt;err&lt;/code&gt; 之间出现的参数err中的闭包。垂直管道。然后，闭包中的代码在运行时可以使用 &lt;code&gt;err&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="bd1efd0f88f5695bb09cde72e8a0904d7ad1c207" translate="yes" xml:space="preserve">
          <source>In this more complex example, we use &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;.debug_set()&lt;/code&gt; to build a list of match arms:</source>
          <target state="translated">在这个更复杂的示例中，我们使用&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;.debug_set()&lt;/code&gt; 构建匹配臂列表：</target>
        </trans-unit>
        <trans-unit id="b03c6712fd2fec1eec14a91751691024a72c4d16" translate="yes" xml:space="preserve">
          <source>In this next example, &lt;code&gt;init_after_if&lt;/code&gt; is initialized after the &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt; expression&lt;/a&gt; while &lt;code&gt;uninit_after_if&lt;/code&gt; is not because it is not initialized in the &lt;code&gt;else&lt;/code&gt; case.</source>
          <target state="translated">在下一个示例中， &lt;code&gt;init_after_if&lt;/code&gt; 在&lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; 表达式&lt;/a&gt;之后初始化，而 &lt;code&gt;uninit_after_if&lt;/code&gt; 则不是，因为在 &lt;code&gt;else&lt;/code&gt; 情况下未初始化。</target>
        </trans-unit>
        <trans-unit id="8c69b4c18cf4fe1c7e28ef21ab7b9243778f0c95" translate="yes" xml:space="preserve">
          <source>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</source>
          <target state="translated">在这个过程中,编译器所做的与我们在清单10-5中用来创建泛型函数的步骤相反:编译器查看所有调用泛型代码的地方,并为泛型代码被调用的具体类型生成代码。</target>
        </trans-unit>
        <trans-unit id="9b2eecf1196adab0e0b7bc0dd52bfa9ea4118939" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll add the searching logic to the &lt;code&gt;minigrep&lt;/code&gt; program by using the Test-driven development (TDD) process. This software development technique follows these steps:</source>
          <target state="translated">在本节中，我们将使用测试驱动的开发（TDD）流程将搜索逻辑添加到 &lt;code&gt;minigrep&lt;/code&gt; 程序中。此软件开发技术遵循以下步骤：</target>
        </trans-unit>
        <trans-unit id="35594ca80fb0c4ca7018f39776903a474d1cfb0f" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll talk about modules and other parts of the module system, namely &lt;em&gt;paths&lt;/em&gt; that allow you to name items; the &lt;code&gt;use&lt;/code&gt; keyword that brings a path into scope; and the &lt;code&gt;pub&lt;/code&gt; keyword to make items public. We&amp;rsquo;ll also discuss the &lt;code&gt;as&lt;/code&gt; keyword, external packages, and the glob operator. For now, let&amp;rsquo;s focus on modules!</source>
          <target state="translated">在本节中，我们将讨论模块和模块系统的其他部分，即允许您命名项目的&lt;em&gt;路径&lt;/em&gt;。在 &lt;code&gt;use&lt;/code&gt; 关键字带来的路径进入范围; 和 &lt;code&gt;pub&lt;/code&gt; 关键字来公开商品。我们还将讨论 &lt;code&gt;as&lt;/code&gt; 关键字，外部包和glob运算符。现在，让我们专注于模块！</target>
        </trans-unit>
        <trans-unit id="b9ddbf2b08f89e10bfeee4884b118c18fb0ff1c3" translate="yes" xml:space="preserve">
          <source>In this situation, even the &lt;code&gt;ref&lt;/code&gt; keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</source>
          <target state="translated">在这种情况下，即使 &lt;code&gt;ref&lt;/code&gt; 关键字也无法解决它，因为借用的内容无法移动。这个问题一般无法解决。如果可以克隆该值，则这是一个不太明确的解决方案：</target>
        </trans-unit>
        <trans-unit id="66f6d7f6d5b6dce217f5225ca67e0e2ff88fca0a" translate="yes" xml:space="preserve">
          <source>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for &lt;em&gt;all&lt;/em&gt; possible types, so &lt;code&gt;transmute()&lt;/code&gt; simply only accepts types without any unsubstituted type parameters.</source>
          <target state="translated">在这种情况下，转换很有可能是无害的（但是Rust不能保证）。但是，当对齐和枚举优化出现在图中时，大小很可能与不同的类型参数替换匹配或不匹配。不可能检查&lt;em&gt;所有&lt;/em&gt;可能的类型，因此 &lt;code&gt;transmute()&lt;/code&gt; 仅接受没有任何未替换类型参数的类型。</target>
        </trans-unit>
        <trans-unit id="fe9b2052803d3d7b3dd78aa5085c8137d21478b8" translate="yes" xml:space="preserve">
          <source>In this suggestion, &amp;ldquo;indirection&amp;rdquo; means that instead of storing a value directly, we&amp;rsquo;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</source>
          <target state="translated">在此建议中，&amp;ldquo;间接&amp;rdquo;表示不直接存储值，而是通过存储指向值的指针来更改数据结构以间接存储值。</target>
        </trans-unit>
        <trans-unit id="ace1483441c50f77553551974f43198070533a0e" translate="yes" xml:space="preserve">
          <source>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</source>
          <target state="translated">这样一来,表达式的结构就决定了执行的结构。块只是另一种表达式,所以块、语句、表达式、块又可以相互递归嵌套在内部,达到任意深度。</target>
        </trans-unit>
        <trans-unit id="3c64ce605c02c94d28e3d47caa98671818a3b2ae" translate="yes" xml:space="preserve">
          <source>In those cases, you need to provide the type explicitly:</source>
          <target state="translated">在这些情况下,你需要明确地提供类型。</target>
        </trans-unit>
        <trans-unit id="2f60575dd030bfd74d0c69219e41591057c41df3" translate="yes" xml:space="preserve">
          <source>In trait declarations as &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt;: &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; is equivalent to &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt;.</source>
          <target state="translated">在特质声明中作为&lt;a href=&quot;items/traits#supertraits&quot;&gt;超&lt;/a&gt; &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; ：特质Circle：Shape {}等同于 &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4f93075a116db72d1570a79e9e24585b192c4ef" translate="yes" xml:space="preserve">
          <source>In trait declarations as bounds on &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;associated types&lt;/a&gt;: &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; is equivalent to &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt;.</source>
          <target state="translated">在特质声明中，以&lt;a href=&quot;items/associated-items#associated-types&quot;&gt;关联类型&lt;/a&gt;为界： &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; 等同于 &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d593169be70ffe063ab15f461603b04fb19d3943" translate="yes" xml:space="preserve">
          <source>In traits, &lt;code&gt;type&lt;/code&gt; is used to declare an &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;associated type&lt;/a&gt;:</source>
          <target state="translated">在特征中， &lt;code&gt;type&lt;/code&gt; 用于声明&lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;关联的类型&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="31d52c1f8837d60baebd5fe1bd8acd4770d12408" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses.</source>
          <target state="translated">在类型中， &lt;code&gt;+&lt;/code&gt; 类型运算符的优先级较低，因此通常需要使用括号。</target>
        </trans-unit>
        <trans-unit id="f9490ac1bbc7d37c9f2c0e3e394c8775ef19ff65" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses:</source>
          <target state="translated">在类型中， &lt;code&gt;+&lt;/code&gt; 类型运算符的优先级较低，因此通常需要使用括号：</target>
        </trans-unit>
        <trans-unit id="cd1daf40491a926084464e0388144e6ba829d637" translate="yes" xml:space="preserve">
          <source>In various places in the book, we&amp;rsquo;ve discussed the &lt;code&gt;derive&lt;/code&gt; attribute, which you can apply to a struct or enum definition. The &lt;code&gt;derive&lt;/code&gt; attribute generates code that will implement a trait with its own default implementation on the type you&amp;rsquo;ve annotated with the &lt;code&gt;derive&lt;/code&gt; syntax.</source>
          <target state="translated">在本书的不同地方，我们讨论了 &lt;code&gt;derive&lt;/code&gt; 属性，您可以将其应用于结构或枚举定义。该 &lt;code&gt;derive&lt;/code&gt; 属性生成的代码将实现与您所使用的注解类型自身的默认实现一个特点 &lt;code&gt;derive&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="0cebe38e502b4e0d3a49a067f9739636c8c7567e" translate="yes" xml:space="preserve">
          <source>In very rare edge cases, this may happen when loading &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;std&lt;/code&gt; twice, once with &lt;code&gt;check&lt;/code&gt; metadata and once with &lt;code&gt;build&lt;/code&gt; metadata. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;#75176&lt;/a&gt;.</source>
          <target state="translated">在极少数情况下，这可能在两次加载 &lt;code&gt;core&lt;/code&gt; 或 &lt;code&gt;std&lt;/code&gt; 时发生，一次是使用 &lt;code&gt;check&lt;/code&gt; 元数据，一次是使用 &lt;code&gt;build&lt;/code&gt; 元数据。有关更多信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;＃75176&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fcacf884bdd57e38c179c26c2a445daf0a3b88d" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be mixed with explicit lifetime binders. For example:</source>
          <target state="translated">带内寿命不能与显性寿命绑定混合。例如:</target>
        </trans-unit>
        <trans-unit id="2c1253e722ca01693911433634c27b9199fbe1b5" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be used in &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;Fn&lt;/code&gt; syntax.</source>
          <target state="translated">带内生存期不能用于 &lt;code&gt;fn&lt;/code&gt; / &lt;code&gt;Fn&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="a0307fb1316fe032b75c2eab1c02683137e89f74" translate="yes" xml:space="preserve">
          <source>In-band lifetimes were mixed with explicit lifetime binders.</source>
          <target state="translated">带内寿命与显性寿命粘合剂混合。</target>
        </trans-unit>
        <trans-unit id="71195f6d729d094826e987475aa2b83d4c3354c6" translate="yes" xml:space="preserve">
          <source>InPlaceIterable</source>
          <target state="translated">InPlaceIterable</target>
        </trans-unit>
        <trans-unit id="0d84c9de7449d934ab38cca665ee24ab8d418e04" translate="yes" xml:space="preserve">
          <source>Includes a UTF-8 encoded file as a string.</source>
          <target state="translated">包括一个UTF-8编码的文件作为一个字符串。</target>
        </trans-unit>
        <trans-unit id="42e257e75b3e4fa6d9e9989f973afa801a9a03f0" translate="yes" xml:space="preserve">
          <source>Includes a file as a reference to a byte array.</source>
          <target state="translated">包含一个文件作为对字节数组的引用。</target>
        </trans-unit>
        <trans-unit id="9c140715e3185328a980b4bc60a18b0febc51520" translate="yes" xml:space="preserve">
          <source>Includes a utf8-encoded file as a string.</source>
          <target state="translated">包含一个utf8编码的文件作为一个字符串。</target>
        </trans-unit>
        <trans-unit id="0c11e0c644b5890be96bab7620a548663254f1f7" translate="yes" xml:space="preserve">
          <source>Includes all extension traits, and some important type definitions.</source>
          <target state="translated">包括所有扩展特征,以及一些重要的类型定义。</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="805a014cffe854e2c811b260ab089d2eda0bbeb7" translate="yes" xml:space="preserve">
          <source>Incoming::all</source>
          <target state="translated">Incoming::all</target>
        </trans-unit>
        <trans-unit id="83bd443d175b9e89de0c8b8872961ea2816dcfb6" translate="yes" xml:space="preserve">
          <source>Incoming::any</source>
          <target state="translated">Incoming::any</target>
        </trans-unit>
        <trans-unit id="f9822b9a823019e577bdfe3ac98493f3aa60473c" translate="yes" xml:space="preserve">
          <source>Incoming::borrow</source>
          <target state="translated">Incoming::borrow</target>
        </trans-unit>
        <trans-unit id="db57c16634c0af16618401e02b9b1b14cfb90675" translate="yes" xml:space="preserve">
          <source>Incoming::borrow_mut</source>
          <target state="translated">Incoming::borrow_mut</target>
        </trans-unit>
        <trans-unit id="909a090d9b0ea3ec427658ae73388b50d4bfbc1f" translate="yes" xml:space="preserve">
          <source>Incoming::by_ref</source>
          <target state="translated">Incoming::by_ref</target>
        </trans-unit>
        <trans-unit id="6d7e9108e413d8a837bb790d96b999eaae29b3f2" translate="yes" xml:space="preserve">
          <source>Incoming::chain</source>
          <target state="translated">Incoming::chain</target>
        </trans-unit>
        <trans-unit id="30254dbd6651bc8d2ce9a6489cb59513c462d366" translate="yes" xml:space="preserve">
          <source>Incoming::cloned</source>
          <target state="translated">Incoming::cloned</target>
        </trans-unit>
        <trans-unit id="8a2bf20be5038460f2e5f09718d4cb6a21fb4c03" translate="yes" xml:space="preserve">
          <source>Incoming::cmp</source>
          <target state="translated">Incoming::cmp</target>
        </trans-unit>
        <trans-unit id="5ed0bcc65453a7978586b3e2016dacfbc14352fe" translate="yes" xml:space="preserve">
          <source>Incoming::collect</source>
          <target state="translated">Incoming::collect</target>
        </trans-unit>
        <trans-unit id="e70d0d30256802ac0658826bed8a56d75ffa6c45" translate="yes" xml:space="preserve">
          <source>Incoming::copied</source>
          <target state="translated">Incoming::copied</target>
        </trans-unit>
        <trans-unit id="a1ce4c03ba198d6862609c9bca7b4fdfd0e790c1" translate="yes" xml:space="preserve">
          <source>Incoming::count</source>
          <target state="translated">Incoming::count</target>
        </trans-unit>
        <trans-unit id="445c24f8aeffb804abbe66eac8d728adfa6384c3" translate="yes" xml:space="preserve">
          <source>Incoming::cycle</source>
          <target state="translated">Incoming::cycle</target>
        </trans-unit>
        <trans-unit id="c7373d860bdcd6bd00f58afd7287948921f2cf3d" translate="yes" xml:space="preserve">
          <source>Incoming::enumerate</source>
          <target state="translated">Incoming::enumerate</target>
        </trans-unit>
        <trans-unit id="422e90f2e0427cea81726aa22dde243c959e3442" translate="yes" xml:space="preserve">
          <source>Incoming::eq</source>
          <target state="translated">Incoming::eq</target>
        </trans-unit>
        <trans-unit id="d82ad0962be1b645dba4415057b56c8c71d2db6c" translate="yes" xml:space="preserve">
          <source>Incoming::filter</source>
          <target state="translated">Incoming::filter</target>
        </trans-unit>
        <trans-unit id="f2d060b73d6c431a592011fdcaf80f72c4327ea7" translate="yes" xml:space="preserve">
          <source>Incoming::filter_map</source>
          <target state="translated">Incoming::filter_map</target>
        </trans-unit>
        <trans-unit id="ec24aef48051e0d66dfbf513fbece0b535e8173a" translate="yes" xml:space="preserve">
          <source>Incoming::find</source>
          <target state="translated">Incoming::find</target>
        </trans-unit>
        <trans-unit id="9f1745b317ce967f0969bdd91f79615c9788ba14" translate="yes" xml:space="preserve">
          <source>Incoming::find_map</source>
          <target state="translated">Incoming::find_map</target>
        </trans-unit>
        <trans-unit id="57ed09c2ac8fbae367da14cf88b9a1cf3a0b0f16" translate="yes" xml:space="preserve">
          <source>Incoming::flat_map</source>
          <target state="translated">Incoming::flat_map</target>
        </trans-unit>
        <trans-unit id="aa8cfa9877df81bdf6f3e26ae8c327e4f18e7ca7" translate="yes" xml:space="preserve">
          <source>Incoming::flatten</source>
          <target state="translated">Incoming::flatten</target>
        </trans-unit>
        <trans-unit id="f534c99639d2a7b60622d67e3da268c1b2dbd8a2" translate="yes" xml:space="preserve">
          <source>Incoming::fmt</source>
          <target state="translated">Incoming::fmt</target>
        </trans-unit>
        <trans-unit id="7bf954d9f452b8f0bff229d58d17ebe667b8bdaa" translate="yes" xml:space="preserve">
          <source>Incoming::fold</source>
          <target state="translated">Incoming::fold</target>
        </trans-unit>
        <trans-unit id="f45d04534657562b3b8e1ac8b93f0995c4f52ffc" translate="yes" xml:space="preserve">
          <source>Incoming::for_each</source>
          <target state="translated">Incoming::for_each</target>
        </trans-unit>
        <trans-unit id="146d704978de3d221c4a8b538e653f767ff7d0cc" translate="yes" xml:space="preserve">
          <source>Incoming::from</source>
          <target state="translated">Incoming::from</target>
        </trans-unit>
        <trans-unit id="8d00e730beb7664120c689b2165fe55c7e43696b" translate="yes" xml:space="preserve">
          <source>Incoming::fuse</source>
          <target state="translated">Incoming::fuse</target>
        </trans-unit>
        <trans-unit id="d6f3fa46377ae997728223371f8e2928bbcd46ee" translate="yes" xml:space="preserve">
          <source>Incoming::ge</source>
          <target state="translated">Incoming::ge</target>
        </trans-unit>
        <trans-unit id="ed38c0b5ef84ea5163b2da693e4b72183ddee0ec" translate="yes" xml:space="preserve">
          <source>Incoming::gt</source>
          <target state="translated">Incoming::gt</target>
        </trans-unit>
        <trans-unit id="b1345261a277f185321d6adb9b350bcb58cd599e" translate="yes" xml:space="preserve">
          <source>Incoming::inspect</source>
          <target state="translated">Incoming::inspect</target>
        </trans-unit>
        <trans-unit id="59abb681c116c064869e4b015c6b1cd16fb45598" translate="yes" xml:space="preserve">
          <source>Incoming::into</source>
          <target state="translated">Incoming::into</target>
        </trans-unit>
        <trans-unit id="95a20422d3926772d9c359f121355edbd8f745f9" translate="yes" xml:space="preserve">
          <source>Incoming::into_iter</source>
          <target state="translated">Incoming::into_iter</target>
        </trans-unit>
        <trans-unit id="77b7ce153ce8067d29a7d019ff3fcc043c2fdd8e" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted</source>
          <target state="translated">Incoming::is_sorted</target>
        </trans-unit>
        <trans-unit id="4dfdf545d2798411e8ee50244269b54395d86c9a" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by</source>
          <target state="translated">Incoming::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d90a5dfb897aff5c068a0a4a12a54de5b9bdf1da" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by_key</source>
          <target state="translated">Incoming::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f1c770fca353b885ee610fe1f519139cdebcc0ee" translate="yes" xml:space="preserve">
          <source>Incoming::last</source>
          <target state="translated">Incoming::last</target>
        </trans-unit>
        <trans-unit id="f5c79843bca5e97321f55d85100e1ac93d537dd7" translate="yes" xml:space="preserve">
          <source>Incoming::le</source>
          <target state="translated">Incoming::le</target>
        </trans-unit>
        <trans-unit id="41753aa4086d7645034ac6f543870deca487abbb" translate="yes" xml:space="preserve">
          <source>Incoming::lt</source>
          <target state="translated">Incoming::lt</target>
        </trans-unit>
        <trans-unit id="42262cd6a3c45e0c4ccd2f403ab3dde4f31c999d" translate="yes" xml:space="preserve">
          <source>Incoming::map</source>
          <target state="translated">Incoming::map</target>
        </trans-unit>
        <trans-unit id="b14fbc258acb1391be68964dacf06c868d0223ee" translate="yes" xml:space="preserve">
          <source>Incoming::max</source>
          <target state="translated">Incoming::max</target>
        </trans-unit>
        <trans-unit id="e598cfd5a561805bab3a055536a7ce8d4cbc0d87" translate="yes" xml:space="preserve">
          <source>Incoming::max_by</source>
          <target state="translated">Incoming::max_by</target>
        </trans-unit>
        <trans-unit id="02e8830cd577c40509d7ca817740c861b52c07c0" translate="yes" xml:space="preserve">
          <source>Incoming::max_by_key</source>
          <target state="translated">Incoming::max_by_key</target>
        </trans-unit>
        <trans-unit id="e522553048356a9c7e3aafb53205e73c814823fd" translate="yes" xml:space="preserve">
          <source>Incoming::min</source>
          <target state="translated">Incoming::min</target>
        </trans-unit>
        <trans-unit id="8b1b84ed0cee495bc315c75dc85c4916ce7f680f" translate="yes" xml:space="preserve">
          <source>Incoming::min_by</source>
          <target state="translated">Incoming::min_by</target>
        </trans-unit>
        <trans-unit id="94a6455843a6def08f4247ddbcf5a373aff6a12c" translate="yes" xml:space="preserve">
          <source>Incoming::min_by_key</source>
          <target state="translated">Incoming::min_by_key</target>
        </trans-unit>
        <trans-unit id="af6f0e0d448b8971f8088a94ecfe2c2c28074b20" translate="yes" xml:space="preserve">
          <source>Incoming::ne</source>
          <target state="translated">Incoming::ne</target>
        </trans-unit>
        <trans-unit id="ad9f2df7e05588db669a49fe0bfa35787281e257" translate="yes" xml:space="preserve">
          <source>Incoming::next</source>
          <target state="translated">Incoming::next</target>
        </trans-unit>
        <trans-unit id="15fdadbdf731ff5f14bd01d14581b0031b5aa856" translate="yes" xml:space="preserve">
          <source>Incoming::nth</source>
          <target state="translated">Incoming::nth</target>
        </trans-unit>
        <trans-unit id="f584fdb6a022a6b9c2041ae0049adb844c00af0a" translate="yes" xml:space="preserve">
          <source>Incoming::partial_cmp</source>
          <target state="translated">Incoming::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d6e7347d2f13179a0246ad8c2f8f8c42d5ea1e8b" translate="yes" xml:space="preserve">
          <source>Incoming::partition</source>
          <target state="translated">Incoming::partition</target>
        </trans-unit>
        <trans-unit id="d15dc3a739c395fba4cdef1bb3db41863ef399f5" translate="yes" xml:space="preserve">
          <source>Incoming::peekable</source>
          <target state="translated">Incoming::peekable</target>
        </trans-unit>
        <trans-unit id="cab06ddc3af8abd52b92e45544310b0faa110219" translate="yes" xml:space="preserve">
          <source>Incoming::position</source>
          <target state="translated">Incoming::position</target>
        </trans-unit>
        <trans-unit id="bb23c8eb76a6d68dfc63c6d32849abe960c1b856" translate="yes" xml:space="preserve">
          <source>Incoming::product</source>
          <target state="translated">Incoming::product</target>
        </trans-unit>
        <trans-unit id="b3d90889f7b30454426b3ed4e11228f5d9d8ee9f" translate="yes" xml:space="preserve">
          <source>Incoming::rev</source>
          <target state="translated">Incoming::rev</target>
        </trans-unit>
        <trans-unit id="d662587d11104ca4324befe21e5aaa1cf3ed3fa3" translate="yes" xml:space="preserve">
          <source>Incoming::rposition</source>
          <target state="translated">Incoming::rposition</target>
        </trans-unit>
        <trans-unit id="6b42372525b119239ec4bd20dc7bf69a1a105a08" translate="yes" xml:space="preserve">
          <source>Incoming::scan</source>
          <target state="translated">Incoming::scan</target>
        </trans-unit>
        <trans-unit id="c1399e28a107bc4249663ed0d2b97e798127c9c6" translate="yes" xml:space="preserve">
          <source>Incoming::size_hint</source>
          <target state="translated">Incoming::size_hint</target>
        </trans-unit>
        <trans-unit id="85ee70ca43a998ef206f4a945f59006b6f40ddfa" translate="yes" xml:space="preserve">
          <source>Incoming::skip</source>
          <target state="translated">Incoming::skip</target>
        </trans-unit>
        <trans-unit id="fdd32c3e0206952202e83705e9d627eb48f607e6" translate="yes" xml:space="preserve">
          <source>Incoming::skip_while</source>
          <target state="translated">Incoming::skip_while</target>
        </trans-unit>
        <trans-unit id="5a589e1b9602c4ff48aa22e65968275507ea9485" translate="yes" xml:space="preserve">
          <source>Incoming::step_by</source>
          <target state="translated">Incoming::step_by</target>
        </trans-unit>
        <trans-unit id="d9ed48df44b20a36de8b0990f9b0c9b964475772" translate="yes" xml:space="preserve">
          <source>Incoming::sum</source>
          <target state="translated">Incoming::sum</target>
        </trans-unit>
        <trans-unit id="bcf6381c826c50e1aaea7423243d1529dca214b8" translate="yes" xml:space="preserve">
          <source>Incoming::take</source>
          <target state="translated">Incoming::take</target>
        </trans-unit>
        <trans-unit id="981c1e08f556e3870dd2af3a144f3176473200b7" translate="yes" xml:space="preserve">
          <source>Incoming::take_while</source>
          <target state="translated">Incoming::take_while</target>
        </trans-unit>
        <trans-unit id="2f0356552ebde5f1c3f3f3ad37fa03b3d1bf90bd" translate="yes" xml:space="preserve">
          <source>Incoming::try_fold</source>
          <target state="translated">Incoming::try_fold</target>
        </trans-unit>
        <trans-unit id="5c1f1df01cacdbf861258e63eb2cb8581f88d043" translate="yes" xml:space="preserve">
          <source>Incoming::try_for_each</source>
          <target state="translated">Incoming::try_for_each</target>
        </trans-unit>
        <trans-unit id="9a58299e31b9803379553db37123ab15774b671d" translate="yes" xml:space="preserve">
          <source>Incoming::try_from</source>
          <target state="translated">Incoming::try_from</target>
        </trans-unit>
        <trans-unit id="fff541a38a97a609e5012c516e4164326cfb79eb" translate="yes" xml:space="preserve">
          <source>Incoming::try_into</source>
          <target state="translated">Incoming::try_into</target>
        </trans-unit>
        <trans-unit id="946f55dc3e1af640cd291f2aaa8528234e768102" translate="yes" xml:space="preserve">
          <source>Incoming::type_id</source>
          <target state="translated">Incoming::type_id</target>
        </trans-unit>
        <trans-unit id="bf46b8f3bb432660f79899dee66baf3e9f087f95" translate="yes" xml:space="preserve">
          <source>Incoming::unzip</source>
          <target state="translated">Incoming::unzip</target>
        </trans-unit>
        <trans-unit id="96a8cde7e0e4c52965055072fd39e0d341071072" translate="yes" xml:space="preserve">
          <source>Incoming::zip</source>
          <target state="translated">Incoming::zip</target>
        </trans-unit>
        <trans-unit id="bcbf83cd2f0ed89c4d2689129dde9ed148866efc" translate="yes" xml:space="preserve">
          <source>Incorrect bytes:</source>
          <target state="translated">错误的字节。</target>
        </trans-unit>
        <trans-unit id="2a70492a6aefdfa404f3b9ac0c6d0448b88be337" translate="yes" xml:space="preserve">
          <source>Incorrect usage</source>
          <target state="translated">不正确的用法</target>
        </trans-unit>
        <trans-unit id="6d7c0e61e47d8d76b1fdbcd2b9644ebc448b482b" translate="yes" xml:space="preserve">
          <source>Increments the strong reference count on the &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; associated with the provided pointer by one.</source>
          <target state="translated">将与提供的指针关联的 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 上的强引用计数增加1。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="52cb15ca8d9c1e4b950b26ef1f32246271f50339" translate="yes" xml:space="preserve">
          <source>Index expressions on arrays and slices</source>
          <target state="translated">数组和切片的索引表达式</target>
        </trans-unit>
        <trans-unit id="361d6f89c121ce39bb2ed14f7085cd248645d21b" translate="yes" xml:space="preserve">
          <source>Index expressions, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; or &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; with a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">索引表达式，&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;数组索引&lt;/a&gt;或带有 &lt;code&gt;usize&lt;/code&gt; 的&lt;a href=&quot;types/slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="528b0ff12e28b750b5aeda40648664d5f6804c7c" translate="yes" xml:space="preserve">
          <source>Index::index</source>
          <target state="translated">Index::index</target>
        </trans-unit>
        <trans-unit id="21d657443793a7fc6c319cfc186e761fac77191e" translate="yes" xml:space="preserve">
          <source>IndexMut</source>
          <target state="translated">IndexMut</target>
        </trans-unit>
        <trans-unit id="24f9ef47b9bb8985e28653af23b1accbf6cd2d9b" translate="yes" xml:space="preserve">
          <source>IndexMut::index_mut</source>
          <target state="translated">IndexMut::index_mut</target>
        </trans-unit>
        <trans-unit id="bda8e2dcef8324d4ce1ba450c4e2e0cae96a9a4a" translate="yes" xml:space="preserve">
          <source>Indexes must be within bounds of the original slice;</source>
          <target state="translated">索引必须在原始切片的范围内。</target>
        </trans-unit>
        <trans-unit id="fa74cb6623de227628f45b4ae93159daddea90b3" translate="yes" xml:space="preserve">
          <source>Indexes must lie on UTF-8 sequence boundaries.</source>
          <target state="translated">索引必须位于UTF-8序列边界上。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="8e33bba2a2fe8c945dee904cfed37743c8dd2807" translate="yes" xml:space="preserve">
          <source>Indexing into Strings</source>
          <target state="translated">索引到字符串中</target>
        </trans-unit>
        <trans-unit id="bc1a7f445eecf9a21ddaa6928da85497c3f808d7" translate="yes" xml:space="preserve">
          <source>Indexing into a string is often a bad idea because it&amp;rsquo;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using &lt;code&gt;[]&lt;/code&gt; with a single number, you can use &lt;code&gt;[]&lt;/code&gt; with a range to create a string slice containing particular bytes:</source>
          <target state="translated">索引到字符串通常不是一个好主意，因为尚不清楚字符串索引操作的返回类型应该是什么：字节值，字符，字形簇或字符串切片。因此，Rust要求您更具体地说明是否真的需要使用索引来创建字符串切片。为了更具体地指示索引并指示您要使用字符串切片，而不是使用带有单个数字的 &lt;code&gt;[]&lt;/code&gt; 进行索引，可以将 &lt;code&gt;[]&lt;/code&gt; 与范围结合使用以创建包含特定字节的字符串切片：</target>
        </trans-unit>
        <trans-unit id="6b92d7c5b5fd6e80ddd2c2e71ae6f53dabf14469" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">索引旨在进行恒定时间操作，但是UTF-8编码不允许我们执行此操作。此外，尚不清楚索引应返回哪种类型：字节，代码点或字素簇。该&lt;a href=&quot;#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt;的方法分别返回迭代器比前两个。</target>
        </trans-unit>
        <trans-unit id="ceeb8ddb5f53fcb5614444876f148bbebee79484" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">索引旨在进行恒定时间操作，但是UTF-8编码不允许我们执行此操作。此外，尚不清楚索引应返回哪种类型：字节，代码点或字素簇。该&lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt;的方法分别返回迭代器比前两个。</target>
        </trans-unit>
        <trans-unit id="0aba4d1ffc3e50a35d8e6bb2627a9921d36e96c9" translate="yes" xml:space="preserve">
          <source>Indexing outside of the bounds of an object with &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; with the exception of one byte past the end of the object.</source>
          <target state="translated">用&lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;在对象边界之外进行索引，但要超出对象末尾一个字节。</target>
        </trans-unit>
        <trans-unit id="27caa1fa7c65a4437e649a4888fe129281a79568" translate="yes" xml:space="preserve">
          <source>Indicates if a buffer should be initialized.</source>
          <target state="translated">表示是否需要初始化缓冲区。</target>
        </trans-unit>
        <trans-unit id="c4c4786e638c55c48e8eb353954207ab6043189e" translate="yes" xml:space="preserve">
          <source>Indicates that directories should be created recursively, creating all parent directories. Parents that do not exist are created with the same security and permissions settings.</source>
          <target state="translated">表示应递归创建目录,创建所有父目录。不存在的父目录将以相同的安全和权限设置创建。</target>
        </trans-unit>
        <trans-unit id="4856479107baf14ea55cfdf8d4985b8807716a64" translate="yes" xml:space="preserve">
          <source>Indicates the manner in which a thread exited.</source>
          <target state="translated">表示线程退出的方式。</target>
        </trans-unit>
        <trans-unit id="075cfaf01d924967ba4b76beb1cc86c1b8ffbe22" translate="yes" xml:space="preserve">
          <source>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</source>
          <target state="translated">表示该套接字的外发组播数据包的存活时间值,默认值为1,表示除非明确要求,否则组播数据包不会离开本地网络。默认值是1,表示除非有明确的要求,否则多播数据包不会离开本地网络。</target>
        </trans-unit>
        <trans-unit id="888a497d6d0feb54c4bc51c8bbfa14e4db0f048b" translate="yes" xml:space="preserve">
          <source>Indicates unfinished code.</source>
          <target state="translated">表示未完成的代码。</target>
        </trans-unit>
        <trans-unit id="35472c24a202b583e18e139d3d561c6674911e84" translate="yes" xml:space="preserve">
          <source>Indicates unimplemented code by panicking with a message of &quot;not implemented&quot;.</source>
          <target state="translated">用 &quot;未实现 &quot;的信息慌乱地表示未实现的代码。</target>
        </trans-unit>
        <trans-unit id="4862445239fb7cd37f48e6ace7775dcd354d2d14" translate="yes" xml:space="preserve">
          <source>Indicates unreachable code.</source>
          <target state="translated">表示无法到达的代码。</target>
        </trans-unit>
        <trans-unit id="cd5cea6e94489fba68a0399bcc4d11feffb0cbe4" translate="yes" xml:space="preserve">
          <source>Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.</source>
          <target state="translated">表示是否有值可用,或者当前任务是否已被安排接收唤醒。</target>
        </trans-unit>
        <trans-unit id="a5d9b716629f981c5e75c2880c16718258347eb9" translate="yes" xml:space="preserve">
          <source>Indication that contents should be center-aligned.</source>
          <target state="translated">表示内容应居中对齐。</target>
        </trans-unit>
        <trans-unit id="582259f836deeb40225aa78333ee7027acddbdbe" translate="yes" xml:space="preserve">
          <source>Indication that contents should be left-aligned.</source>
          <target state="translated">表示内容应左对齐。</target>
        </trans-unit>
        <trans-unit id="30524864694504eb9866802047ab21c114fa2091" translate="yes" xml:space="preserve">
          <source>Indication that contents should be right-aligned.</source>
          <target state="translated">表示内容应右对齐。</target>
        </trans-unit>
        <trans-unit id="f2cd68a3153c21de89ed40993772ed6007b02a6f" translate="yes" xml:space="preserve">
          <source>Indices are zero-based for arrays and slices. Array access is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a &lt;em&gt;panicked state&lt;/em&gt; if it fails.</source>
          <target state="translated">数组和切片的索引从零开始。数组访问是一个&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;常量表达式&lt;/a&gt;，因此可以在编译时使用常量索引值检查范围。否则，将在运行时执行检查，如果检查失败，该检查会将线程置于&lt;em&gt;紧急状态&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e7d8ee4a5140f0e6e32c94f9ff32453c7e40a4a3" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">两个 &lt;code&gt;Arc&lt;/code&gt; 的不等式。</target>
        </trans-unit>
        <trans-unit id="8aa90054db987f32eec9e62690e9b9862d6f642a" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">两个 &lt;code&gt;Rc&lt;/code&gt; 不等式。</target>
        </trans-unit>
        <trans-unit id="5d55264281a8b8357477a0b1f6f6a4a72582a08d" translate="yes" xml:space="preserve">
          <source>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final &lt;code&gt;TokenStream&lt;/code&gt;.</source>
          <target state="translated">也允许由应用于项目的过程宏属性使用的惰性帮助程序属性，但要小心，不要在最终的 &lt;code&gt;TokenStream&lt;/code&gt; 中包括这些惰性属性。</target>
        </trans-unit>
        <trans-unit id="32565cc43897d204c904c25aeddc29a5a2fe5f4d" translate="yes" xml:space="preserve">
          <source>Infallible</source>
          <target state="translated">Infallible</target>
        </trans-unit>
        <trans-unit id="327440953e8036a6b78b97c190dedc5d1ddc1d6f" translate="yes" xml:space="preserve">
          <source>Infallible errors</source>
          <target state="translated">无懈可击的错误</target>
        </trans-unit>
        <trans-unit id="379d563f62e4c026be425a08a60de86e8b28b34e" translate="yes" xml:space="preserve">
          <source>Infallible::borrow</source>
          <target state="translated">Infallible::borrow</target>
        </trans-unit>
        <trans-unit id="ffd9adf91cadc5963cf564501d6440dfcb9953d6" translate="yes" xml:space="preserve">
          <source>Infallible::borrow_mut</source>
          <target state="translated">Infallible::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d5161b5d2a0dd973c7749267f912225db6f86b3c" translate="yes" xml:space="preserve">
          <source>Infallible::clamp</source>
          <target state="translated">Infallible::clamp</target>
        </trans-unit>
        <trans-unit id="f9dfe17efa7693fd64ca4bce650f4693dec46e6a" translate="yes" xml:space="preserve">
          <source>Infallible::clone</source>
          <target state="translated">Infallible::clone</target>
        </trans-unit>
        <trans-unit id="7c7c7505a3bdd3e6bbbfabe3c0aa36eea42c2f97" translate="yes" xml:space="preserve">
          <source>Infallible::clone_from</source>
          <target state="translated">Infallible::clone_from</target>
        </trans-unit>
        <trans-unit id="6af6b86ef345c274a60c49262dbedb50a8323471" translate="yes" xml:space="preserve">
          <source>Infallible::clone_into</source>
          <target state="translated">Infallible::clone_into</target>
        </trans-unit>
        <trans-unit id="3f4e892d27a40b0bfaf9fee7ba4a2719e5f0e03b" translate="yes" xml:space="preserve">
          <source>Infallible::cmp</source>
          <target state="translated">Infallible::cmp</target>
        </trans-unit>
        <trans-unit id="465ca79819acd2f64e9c25bd2a18d141db20f7e4" translate="yes" xml:space="preserve">
          <source>Infallible::eq</source>
          <target state="translated">Infallible::eq</target>
        </trans-unit>
        <trans-unit id="7b0120f9faa0f0e51d2f41f2228ccb58415bb901" translate="yes" xml:space="preserve">
          <source>Infallible::fmt</source>
          <target state="translated">Infallible::fmt</target>
        </trans-unit>
        <trans-unit id="7699715e87167505521e297f0cc5acf9571073ba" translate="yes" xml:space="preserve">
          <source>Infallible::from</source>
          <target state="translated">Infallible::from</target>
        </trans-unit>
        <trans-unit id="9ed64ca1536a61aeb71e791f8b0cd35996768800" translate="yes" xml:space="preserve">
          <source>Infallible::ge</source>
          <target state="translated">Infallible::ge</target>
        </trans-unit>
        <trans-unit id="6bc6944b5c980e7843d508d02dcd2bfaf58a503d" translate="yes" xml:space="preserve">
          <source>Infallible::gt</source>
          <target state="translated">Infallible::gt</target>
        </trans-unit>
        <trans-unit id="be25a1605cddc636f6f076ea8d21d97812f2aa85" translate="yes" xml:space="preserve">
          <source>Infallible::into</source>
          <target state="translated">Infallible::into</target>
        </trans-unit>
        <trans-unit id="acae0cd14002a94fe132d6ca88f1fdd5ca563403" translate="yes" xml:space="preserve">
          <source>Infallible::le</source>
          <target state="translated">Infallible::le</target>
        </trans-unit>
        <trans-unit id="2b7d09de5fbcd932797ca9cc160818ef628164b0" translate="yes" xml:space="preserve">
          <source>Infallible::lt</source>
          <target state="translated">Infallible::lt</target>
        </trans-unit>
        <trans-unit id="d981e531de4db6af3fa624928233a62cc48506b0" translate="yes" xml:space="preserve">
          <source>Infallible::max</source>
          <target state="translated">Infallible::max</target>
        </trans-unit>
        <trans-unit id="4e77b6f968c067dfd00c877ce693a33816232a84" translate="yes" xml:space="preserve">
          <source>Infallible::min</source>
          <target state="translated">Infallible::min</target>
        </trans-unit>
        <trans-unit id="1b9bdf4c04b01562bf66a579b3902b4d24df2814" translate="yes" xml:space="preserve">
          <source>Infallible::ne</source>
          <target state="translated">Infallible::ne</target>
        </trans-unit>
        <trans-unit id="593cf3934010f07d135bbd81984d0e7b07060f05" translate="yes" xml:space="preserve">
          <source>Infallible::partial_cmp</source>
          <target state="translated">Infallible::partial_cmp</target>
        </trans-unit>
        <trans-unit id="171d7fff4d94e2b47d18a78e5a1c94a683078c15" translate="yes" xml:space="preserve">
          <source>Infallible::to_owned</source>
          <target state="translated">Infallible::to_owned</target>
        </trans-unit>
        <trans-unit id="256be91884f5591734d76be10903ead44c9f209f" translate="yes" xml:space="preserve">
          <source>Infallible::to_string</source>
          <target state="translated">Infallible::to_string</target>
        </trans-unit>
        <trans-unit id="c3635403870a783a099eedcae587acfb8a52bc1f" translate="yes" xml:space="preserve">
          <source>Infallible::try_from</source>
          <target state="translated">Infallible::try_from</target>
        </trans-unit>
        <trans-unit id="3c8ee4706115d8499f3abf4d51e35db72e1ffd2e" translate="yes" xml:space="preserve">
          <source>Infallible::try_into</source>
          <target state="translated">Infallible::try_into</target>
        </trans-unit>
        <trans-unit id="9701bd213ca2d8e7962b353284539a737fba44f7" translate="yes" xml:space="preserve">
          <source>Infallible::type_id</source>
          <target state="translated">Infallible::type_id</target>
        </trans-unit>
        <trans-unit id="c548ca9534f0b8a6c18d5933d5460cae1f620bec" translate="yes" xml:space="preserve">
          <source>Inferred type</source>
          <target state="translated">推断类型</target>
        </trans-unit>
        <trans-unit id="85dc47997d86458573535c2b6419f71eaedb8bec" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">像 &lt;code&gt;repeat()&lt;/code&gt; 这样的无限迭代器通常与&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt;这样的适配器一起使用，以使它们变得有限。</target>
        </trans-unit>
        <trans-unit id="5b827f3090a9999d7251035ec3accdcd8d4fbe7d" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">像 &lt;code&gt;repeat()&lt;/code&gt; 这样的无限迭代器通常与&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 等&lt;/a&gt;适配器一起使用，以使它们变得有限。</target>
        </trans-unit>
        <trans-unit id="2872d343e29a3d0faf1e93a846c0ad3b8146eceb" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">无限迭代器（如 &lt;code&gt;repeat_with()&lt;/code&gt; )经常与适配器（如&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt;，以使它们变得有限。</target>
        </trans-unit>
        <trans-unit id="e414b3978173634ff311532d9eb1dc73109f5119" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">无限重复器（如 &lt;code&gt;repeat_with()&lt;/code&gt; )经常与适配器（如&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;）一起使用，以使它们变得有限。</target>
        </trans-unit>
        <trans-unit id="a2550f47e7bda60f30b73b2126315e72f6a1181f" translate="yes" xml:space="preserve">
          <source>Infinite loops</source>
          <target state="translated">无限循环</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="2caa9882f0053ecda17ba6be06a5251c1ec2645f" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;).</source>
          <target state="translated">无穷大（&amp;infin;）。</target>
        </trans-unit>
        <trans-unit id="87a3bea62fc4aac2370741613d6bad23fc5e7898" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f32::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">无穷大（&amp;infin;）。请改用&lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt; &lt;code&gt;f32::INFINITY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5889ff563c59beba5ff715c644770f8c520445a" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f64::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">无穷大（&amp;infin;）。请改用&lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt; &lt;code&gt;f64::INFINITY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="d42473cc429103c815ee41c99ce227e6800bc064" translate="yes" xml:space="preserve">
          <source>Informally:</source>
          <target state="translated">Informally:</target>
        </trans-unit>
        <trans-unit id="50473fcaee3f0826f522b7d9bde1dee298665a6b" translate="yes" xml:space="preserve">
          <source>Informs the compiler that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">告知编译器,代码中的这一点是无法达到的,以便进一步优化。</target>
        </trans-unit>
        <trans-unit id="da26edc8a2a6b051f930b8dc35ea3b2d2eb04a3f" translate="yes" xml:space="preserve">
          <source>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</source>
          <target state="translated">告知优化器一个条件始终为真。如果条件为假,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="7ae97ac101c4619f2cdd3e3df7584b679394eca7" translate="yes" xml:space="preserve">
          <source>Inhabited</source>
          <target state="translated">Inhabited</target>
        </trans-unit>
        <trans-unit id="b07b5b517980bf88c19321ee29f23f8a21e0b4de" translate="yes" xml:space="preserve">
          <source>Inherent Implementations</source>
          <target state="translated">固有实施</target>
        </trans-unit>
        <trans-unit id="bf73ea65fd18a78a9021507f0c11c78ed2ec5124" translate="yes" xml:space="preserve">
          <source>Inherent associated types were part of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; but are not yet implemented. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;the tracking issue&lt;/a&gt; for the status of this implementation.</source>
          <target state="translated">固有的关联类型是&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195的&lt;/a&gt;一部分，但尚未实现。有关此实现的状态，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;跟踪问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f47cc0e78be269b94ff1fbb506eefabb2d14cd1d" translate="yes" xml:space="preserve">
          <source>Inherent implementation</source>
          <target state="translated">固有的执行</target>
        </trans-unit>
        <trans-unit id="89d8c2e2efc6fafd98f5603953f0cb702613d6d3" translate="yes" xml:space="preserve">
          <source>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the &lt;code&gt;unsafe&lt;/code&gt; keyword from the inherent implementation will resolve this error.</source>
          <target state="translated">固有的实现（不实现特征但提供与类型关联的方法的实现）始终是安全的，因为它们没有实现不安全的特征。从固有实现中删除 &lt;code&gt;unsafe&lt;/code&gt; 关键字将解决此错误。</target>
        </trans-unit>
        <trans-unit id="02407dbce9ca24cc02710598fc24ae8f49c07a7e" translate="yes" xml:space="preserve">
          <source>Inherent implementations associate the contained items to the implementing type. Inherent implementations can contain &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;associated functions&lt;/a&gt; (including methods) and &lt;a href=&quot;associated-items#associated-constants&quot;&gt;associated constants&lt;/a&gt;. They cannot contain associated type aliases.</source>
          <target state="translated">固有的实现将所包含的项目与实现类型相关联。固有的实现可以包含&lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;关联的函数&lt;/a&gt;（包括方法）和&lt;a href=&quot;associated-items#associated-constants&quot;&gt;关联的常量&lt;/a&gt;。它们不能包含关联的类型别名。</target>
        </trans-unit>
        <trans-unit id="4ccb704ced0ac70357d35287cb1c67388f967d06" translate="yes" xml:space="preserve">
          <source>Inherent method</source>
          <target state="translated">固有方法</target>
        </trans-unit>
        <trans-unit id="c7a774bf3dce2aac99ad48347458653bbd55d325" translate="yes" xml:space="preserve">
          <source>Inherit stdin/stdout/stderr for &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt;, but create pipes for &lt;code&gt;output&lt;/code&gt;</source>
          <target state="translated">继承stdin / stdout / stderr &lt;code&gt;spawn&lt;/code&gt; 或 &lt;code&gt;status&lt;/code&gt; ，但创建管道 &lt;code&gt;output&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f4e94fb7b802199fb91e731b50847b79d9607c1" translate="yes" xml:space="preserve">
          <source>Inherit the current process's environment</source>
          <target state="translated">继承当前进程的环境</target>
        </trans-unit>
        <trans-unit id="44c348c84d3785ac5adb30ee3d2d10f68e971317" translate="yes" xml:space="preserve">
          <source>Inherit the current process's working directory</source>
          <target state="translated">继承当前进程的工作目录。</target>
        </trans-unit>
        <trans-unit id="6325b69277e854d2ebda5c6558b946870708063a" translate="yes" xml:space="preserve">
          <source>Inheritance as a Type System and as Code Sharing</source>
          <target state="translated">作为类型系统和代码共享的继承性</target>
        </trans-unit>
        <trans-unit id="c561edc4e8c488ada0373bbdca70237bf7b2c36a" translate="yes" xml:space="preserve">
          <source>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it&amp;rsquo;s often at risk of sharing more code than necessary. Subclasses shouldn&amp;rsquo;t always share all characteristics of their parent class but will do so with inheritance. This can make a program&amp;rsquo;s design less flexible. It also introduces the possibility of calling methods on subclasses that don&amp;rsquo;t make sense or that cause errors because the methods don&amp;rsquo;t apply to the subclass. In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program&amp;rsquo;s design.</source>
          <target state="translated">继承最近在许多编程语言中不再是编程设计解决方案的首选，因为继承经常有共享不必要代码的风险。子类不应该总是共享其父类的所有特征，而应该通过继承来共享。这会使程序的设计不灵活。它还引入了在子类上调用没有意义或会导致错误的子类的可能性，因为这些方法不适用于子类。另外，某些语言仅允许子类从一个类继承，从而进一步限制了程序设计的灵活性。</target>
        </trans-unit>
        <trans-unit id="2e8b04bb573d36dddf2182bf5af08f053f087e52" translate="yes" xml:space="preserve">
          <source>Initial values</source>
          <target state="translated">初始值</target>
        </trans-unit>
        <trans-unit id="c904b3e1f2d0c5d733b728b7a681f23a1ee75fda" translate="yes" xml:space="preserve">
          <source>Initialization and Destruction</source>
          <target state="translated">初始化和销毁</target>
        </trans-unit>
        <trans-unit id="13d802cdbafe0031cbe0ff944c50f80b718c2135" translate="yes" xml:space="preserve">
          <source>Initialization invariant</source>
          <target state="translated">初始化不变性</target>
        </trans-unit>
        <trans-unit id="e4de29eb027f99abd844645c1796c2a7a7d72482" translate="yes" xml:space="preserve">
          <source>Initialization is dynamically performed on the first call to &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; within a thread, and values that implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; get destructed when a thread exits. Some caveats apply, which are explained below.</source>
          <target state="translated">初始化是在线程中对&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;的第一次调用中动态执行的，并且在线程退出时，实现&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 的&lt;/a&gt;值将被破坏。一些注意事项适用，下面将进行说明。</target>
        </trans-unit>
        <trans-unit id="b12d9d28ca06ab166730d1a0be67505b54f2b263" translate="yes" xml:space="preserve">
          <source>Initialization of a union</source>
          <target state="translated">联合体的初始化</target>
        </trans-unit>
        <trans-unit id="db21316277d9b77e6330bd9b3d2303f36118171f" translate="yes" xml:space="preserve">
          <source>Initialization value for static &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">静态&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;值的初始化值。</target>
        </trans-unit>
        <trans-unit id="777041461872120636aa50d7bf36c832a7f4df98" translate="yes" xml:space="preserve">
          <source>Initialize a result to &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; before a loop:</source>
          <target state="translated">在循环之前将结果初始化为&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cb5407ce66e9cc74c7b9cdad45d317b358a42346" translate="yes" xml:space="preserve">
          <source>Initializer::borrow</source>
          <target state="translated">Initializer::borrow</target>
        </trans-unit>
        <trans-unit id="9329992da7e67d3d87b950443458d66c568d4935" translate="yes" xml:space="preserve">
          <source>Initializer::borrow_mut</source>
          <target state="translated">Initializer::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8b338b461eda8eab3ac52c21c7ba950b55ddab77" translate="yes" xml:space="preserve">
          <source>Initializer::fmt</source>
          <target state="translated">Initializer::fmt</target>
        </trans-unit>
        <trans-unit id="370ad1ce33d717e00bfed251c3d4bf09120c4049" translate="yes" xml:space="preserve">
          <source>Initializer::from</source>
          <target state="translated">Initializer::from</target>
        </trans-unit>
        <trans-unit id="26ef6fd69d6de0da79344847b51c3c8c83e2b8cc" translate="yes" xml:space="preserve">
          <source>Initializer::initialize</source>
          <target state="translated">Initializer::initialize</target>
        </trans-unit>
        <trans-unit id="bdae64fb5268754bb9cc8ae6c8db2ab2a08fdbc3" translate="yes" xml:space="preserve">
          <source>Initializer::into</source>
          <target state="translated">Initializer::into</target>
        </trans-unit>
        <trans-unit id="a79949e93a459b7f8ca5406e877e55f5660e5c75" translate="yes" xml:space="preserve">
          <source>Initializer::nop</source>
          <target state="translated">Initializer::nop</target>
        </trans-unit>
        <trans-unit id="dcb257db32b009bda392da62101575610abd1f91" translate="yes" xml:space="preserve">
          <source>Initializer::should_initialize</source>
          <target state="translated">Initializer::should_initialize</target>
        </trans-unit>
        <trans-unit id="bcab8cf375f63f790f0ce8e05777079bda310ea7" translate="yes" xml:space="preserve">
          <source>Initializer::try_from</source>
          <target state="translated">Initializer::try_from</target>
        </trans-unit>
        <trans-unit id="1ce33c3dc308ea20a9c3e23385d3fd4e6cdbc2f0" translate="yes" xml:space="preserve">
          <source>Initializer::try_into</source>
          <target state="translated">Initializer::try_into</target>
        </trans-unit>
        <trans-unit id="7015bd93154feb364c2957b0fc2cdb3fe5bb0863" translate="yes" xml:space="preserve">
          <source>Initializer::type_id</source>
          <target state="translated">Initializer::type_id</target>
        </trans-unit>
        <trans-unit id="38d15bea38cc632ed42db7368869a2581cd9ac0d" translate="yes" xml:space="preserve">
          <source>Initializer::zeroing</source>
          <target state="translated">Initializer::zeroing</target>
        </trans-unit>
        <trans-unit id="b02eff8ddabee28d5ce99312e8bd3930e76e09a5" translate="yes" xml:space="preserve">
          <source>Initializes a buffer if necessary.</source>
          <target state="translated">必要时初始化一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="c1014a628ca9687c4db754c43f3628d84e3050c5" translate="yes" xml:space="preserve">
          <source>Initializing a struct field-by-field</source>
          <target state="translated">逐字段初始化一个结构</target>
        </trans-unit>
        <trans-unit id="6d9d88d804a2b918f6a240e649b5e1a2aa5a1b6e" translate="yes" xml:space="preserve">
          <source>Initializing an array element-by-element</source>
          <target state="translated">逐元素初始化一个数组</target>
        </trans-unit>
        <trans-unit id="e30e79f506a4a7b48aa6bd2ea1d1c98586736d96" translate="yes" xml:space="preserve">
          <source>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety &lt;em&gt;and&lt;/em&gt; concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you&amp;rsquo;re working on it rather than potentially after it has been shipped to production. We&amp;rsquo;ve nicknamed this aspect of Rust &lt;em&gt;fearless&lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt;. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</source>
          <target state="translated">最初，Rust团队认为确保内存安全和防止并发问题是要用不同方法解决的两个独立挑战。随着时间的推移，该团队发现所有权和类型系统是一组功能强大的工具，可帮助管理内存安全&lt;em&gt;和&lt;/em&gt;并发问题！通过所有权和类型检查，许多并发错误是Rust中的编译时错误，而不是运行时错误。因此，错误的代码将拒绝编译并呈现一个解释问题的错误，而不是使您花费大量时间尝试重现运行时并发错误发生的确切情况。因此，您可以在处理代码时对其进行修复，而不是在将代码交付生产后进行修复。我们已经将Rust &lt;em&gt;无畏&lt;/em&gt;&lt;em&gt;并发的&lt;/em&gt;这一方面称为&amp;ldquo; &lt;em&gt;无畏&amp;rdquo;&lt;/em&gt;。无所畏惧的并发性使您可以编写无细微错误且易于重构的代码，而不会引入新的错误。</target>
        </trans-unit>
        <trans-unit id="377c3360b199ab4bedae33ce6d834fe07f041fe6" translate="yes" xml:space="preserve">
          <source>Inline assembly.</source>
          <target state="translated">内联装配。</target>
        </trans-unit>
        <trans-unit id="b7a13c17feda3ff04e933d53202cd41c94dace05" translate="yes" xml:space="preserve">
          <source>Inner attribute</source>
          <target state="translated">内在属性</target>
        </trans-unit>
        <trans-unit id="565c802152b12c7dd9aea0fe59ebaacf3d1a82a3" translate="yes" xml:space="preserve">
          <source>Inner block doc comment</source>
          <target state="translated">内块文档注释</target>
        </trans-unit>
        <trans-unit id="af507067e5f2cec421f889124df4ee46c1a92bbf" translate="yes" xml:space="preserve">
          <source>Inner document can only be used before items. For example:</source>
          <target state="translated">内文只能用在项目之前。例如:</target>
        </trans-unit>
        <trans-unit id="5ca5fb7f033a9d40e84c1a1a0c29b149dc2c2561" translate="yes" xml:space="preserve">
          <source>Inner functions do not have access to their containing environment. To fix this error, you can replace the function with a closure:</source>
          <target state="translated">内部函数不能访问其包含的环境。为了解决这个错误,你可以用一个闭包来代替函数。</target>
        </trans-unit>
        <trans-unit id="10264f133a74f365cfab7999c77a7091803d2786" translate="yes" xml:space="preserve">
          <source>Inner items do not inherit type or const parameters from the functions they are embedded in.</source>
          <target state="translated">内项不继承它们所嵌入的函数的类型或常量参数。</target>
        </trans-unit>
        <trans-unit id="6909dc9a044dcde9a4fe7603daf0a9a52557aba3" translate="yes" xml:space="preserve">
          <source>Inner line doc comment</source>
          <target state="translated">内行文档注释</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">输入格式</target>
        </trans-unit>
        <trans-unit id="daf107c7f6d6d3a06676862d762621e314a3de24" translate="yes" xml:space="preserve">
          <source>Insert and complex keys</source>
          <target state="translated">插入键和复合键</target>
        </trans-unit>
        <trans-unit id="3d9eeb934e6164d2c24b6394e6758d068509ccb2" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;code&gt;O(log n)&lt;/code&gt; time complexity. Checking the largest element is &lt;code&gt;O(1)&lt;/code&gt;. Converting a vector to a binary heap can be done in-place, and has &lt;code&gt;O(n)&lt;/code&gt; complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;code&gt;O(n log n)&lt;/code&gt; in-place heapsort.</source>
          <target state="translated">插入和弹出最大元素的时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 。检查最大的元素是 &lt;code&gt;O(1)&lt;/code&gt; 。将向量转换为二进制堆可以就地完成，并且复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 。二进制堆也可以就地转换为排序向量，从而可以将其用于 &lt;code&gt;O(n log n)&lt;/code&gt; 就地堆排序。</target>
        </trans-unit>
        <trans-unit id="e3054fc5d210400311e9f74c38361908c7518246" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) time complexity. Checking the largest element is &lt;em&gt;O&lt;/em&gt;(1). Converting a vector to a binary heap can be done in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) in-place heapsort.</source>
          <target state="translated">插入和弹出最大元素的时间复杂度为&lt;em&gt;O&lt;/em&gt;（log（&lt;em&gt;n&lt;/em&gt;））。检查最大的元素是&lt;em&gt;O&lt;/em&gt;（1）。将向量转换为二进制堆可以就地完成，并且复杂度为&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）。二进制堆也可以就地转换为排序向量，从而可以将其用于&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt; * log（&lt;em&gt;n&lt;/em&gt;））就地堆排序。</target>
        </trans-unit>
        <trans-unit id="e0b51cb1a3f7392b32f519dbb88d97e332d11c69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">插入 &lt;code&gt;v&lt;/code&gt; 入选项，如果它是&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，然后返回一个可变参考包含的值。</target>
        </trans-unit>
        <trans-unit id="ea064b5e532406cd5efbee55897b1c3c1824866f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">插入 &lt;code&gt;v&lt;/code&gt; 入选项，如果它是&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，然后返回一个可变参考包含的值。</target>
        </trans-unit>
        <trans-unit id="94836515b3818e2e9860b9063cc6b9696a633f85" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">插入 &lt;code&gt;value&lt;/code&gt; 到如果它是选项&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，然后返回一个可变参考包含的值。</target>
        </trans-unit>
        <trans-unit id="ec673856ac415b2c56f7363563f20a74b9ab6742" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option then returns a mutable reference to it.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 插入选项，然后返回对其的可变引用。</target>
        </trans-unit>
        <trans-unit id="633ef776ac14fc1a5ba3722ac27ba6e3e9e74927" translate="yes" xml:space="preserve">
          <source>Inserts a character into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">在此 &lt;code&gt;String&lt;/code&gt; 中的字节位置插入一个字符。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
