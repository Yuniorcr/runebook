<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="fe9cf4a133a88b8bc470c4394f4eb8cf3b306e68" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_dir&quot;&gt;&lt;code&gt;fs::read_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.read_dir&quot;&gt; &lt;code&gt;fs::read_dir&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="f461dafd60906d9babd38850b381951321bafa0a" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_link&quot;&gt;&lt;code&gt;fs::read_link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.read_link&quot;&gt; &lt;code&gt;fs::read_link&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="8a772f821d093dc45f53501fe5deb3218dd74356" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="d34ac7564172d2ff8117857aff9df3320c42fae5" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::clone(...)&lt;/code&gt;. A &lt;code&gt;Clone&lt;/code&gt; implementation or a method would interfere with the widespread use of &lt;code&gt;r.borrow().clone()&lt;/code&gt; to clone the contents of a &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="translated">这是一个相关函数，需要用作 &lt;code&gt;Ref::clone(...)&lt;/code&gt; 。一个 &lt;code&gt;Clone&lt;/code&gt; 的实现或方法将与广泛使用的干扰 &lt;code&gt;r.borrow().clone()&lt;/code&gt; 克隆的内容 &lt;code&gt;RefCell&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de597cdfc25d4b695eb376a8a0838157803d015" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83e3e547dadb3f845f93bfeaf6231ee030e91c8" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个关联函数，需要用作 &lt;code&gt;Ref::map(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f18aedd0b02030c35b1012078adf973833d874e" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个关联函数，需要用作 &lt;code&gt;Ref::map_split(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9124c09eb61044a9051beed91e77bd6ffcbf176" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ab5139ea01a60d2224bebc358fd7f5a09aee7b" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个相关函数，需要用作 &lt;code&gt;RefMut::map(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="202f23e551bc61ba34f51a486b60ddfce30150ab" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个相关函数，需要用作 &lt;code&gt;RefMut::map_split(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb3bd037be08bb82591900e7ddf468637a2b8c80" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; from.</source>
          <target state="translated">这适用于初始化未初始化的内存，或覆盖先前已&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;内存。</target>
        </trans-unit>
        <trans-unit id="856709efbf0ee049257184bc9760c0b3d18a43eb" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read with &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这适用于初始化未初始化的内存，或覆盖以前使用&lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt;读取的内存。</target>
        </trans-unit>
        <trans-unit id="9049d14f9f0cb6f47694e4f8dd6256baa32e595c" translate="yes" xml:space="preserve">
          <source>This is based on &lt;code&gt;malloc&lt;/code&gt; on Unix platforms and &lt;code&gt;HeapAlloc&lt;/code&gt; on Windows, plus related functions.</source>
          <target state="translated">它基于Unix平台上的 &lt;code&gt;malloc&lt;/code&gt; 和Windows 上的 &lt;code&gt;HeapAlloc&lt;/code&gt; ，以及相关功能。</target>
        </trans-unit>
        <trans-unit id="d9e17b1971fcc8ebac923ca9bdcdbe86fd7ccc27" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;AddAssign&lt;/code&gt; is not automatically implemented, so you need to manually implement it for your type.</source>
          <target state="translated">这是因为 &lt;code&gt;AddAssign&lt;/code&gt; 不会自动实现，因此您需要为您的类型手动实现它。</target>
        </trans-unit>
        <trans-unit id="5c0cfc8e697e9e04f2ac8988522860bd36ed371a" translate="yes" xml:space="preserve">
          <source>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</source>
          <target state="translated">这是因为单元格类型做的操作不是线程安全的。由于这个原因,它们没有实现同步,因此不能放在静态中。</target>
        </trans-unit>
        <trans-unit id="43247ccf0e7189f6826d62c195b63176c827f652" translate="yes" xml:space="preserve">
          <source>This is because of a type mismatch between the associated type of some trait (e.g., &lt;code&gt;T::Bar&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt;) and another type &lt;code&gt;U&lt;/code&gt; that is required to be equal to &lt;code&gt;T::Bar&lt;/code&gt;, but is not. Examples follow.</source>
          <target state="translated">这是因为相关联的一些类型的性状（例如，之间的类型不匹配的 &lt;code&gt;T::Bar&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 器具 &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt; ）和另一种类型的 &lt;code&gt;U&lt;/code&gt; 所需等于 &lt;code&gt;T::Bar&lt;/code&gt; ，但不是。示例如下。</target>
        </trans-unit>
        <trans-unit id="0e543293d9c4cb900df2afb34a1c801950192149" translate="yes" xml:space="preserve">
          <source>This is because there could exist &lt;code&gt;V&lt;/code&gt; types with multiple &lt;code&gt;Borrow&amp;lt;[_]&amp;gt;&lt;/code&gt; impls, such that multiple &lt;code&gt;T&lt;/code&gt; types would apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a641717e833808f9f0bc4f5f362a54b6a1faff5b" translate="yes" xml:space="preserve">
          <source>This is borrow-generalized version of &lt;code&gt;Clone::clone_from&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;Clone::clone_from&lt;/code&gt; 借用概括版本。</target>
        </trans-unit>
        <trans-unit id="834216017331c86ca1e125eb990783c9079a99f6" translate="yes" xml:space="preserve">
          <source>This is called the &amp;ldquo;train model&amp;rdquo; because every six weeks, a release &amp;ldquo;leaves the station&amp;rdquo;, but still has to take a journey through the beta channel before it arrives as a stable release.</source>
          <target state="translated">之所以称其为&amp;ldquo;培训模型&amp;rdquo;，是因为每六周，一个发行版会&amp;ldquo;离开站点&amp;rdquo;，但是在它作为稳定发行版发布之前，仍然必须经过Beta通道。</target>
        </trans-unit>
        <trans-unit id="d83e7e82097d376958eb95d5e51d98e6719f2542" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e339d64ba30c9973394f6282049233c7be4f71" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">这是灾难性的，这意味着我们可以先固定 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 的内容（使用 &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ），然后使用稍后获得的可变引用移动该内容。</target>
        </trans-unit>
        <trans-unit id="9ed19556018375489742916bfb6ea73b08918fbf" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67913f9219472099fcca84773f5f227006ffbcce" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">这通常用于使单个值生成器适应其他类型的迭代&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt;。也许您有一个涵盖几乎所有内容的迭代器，但是您需要一个额外的特殊情况。也许您有一个适用于迭代器的函数，但只需要处理一个值即可。</target>
        </trans-unit>
        <trans-unit id="507d399d0caa748ec0f687d63827f62d38ea93b1" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764e0240ad7ec9a9585ed8305ceb8e8099f2723d" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">这通常用于使单个值适应其他类型的迭代&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt;。也许您有一个涵盖几乎所有内容的迭代器，但是您需要一个额外的特殊情况。也许您有一个适用于迭代器的函数，但只需要处理一个值即可。</target>
        </trans-unit>
        <trans-unit id="f239b530d28c30ec1070f1658b16620a287e3251" translate="yes" xml:space="preserve">
          <source>This is correct (explicit):</source>
          <target state="translated">这是正确的(明确)。</target>
        </trans-unit>
        <trans-unit id="7d6342cfa6f9200a801992dcf925b5cee5be4a5b" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">当前，这在所有平台上都与 &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a48f92d085d1c5423be432a065e6504acd5a4a36" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">当前 &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; 在所有平台上都与transmute :: &amp;lt;f64，u64&amp;gt;（self）相同。</target>
        </trans-unit>
        <trans-unit id="918c5990ef12f35794f26c0b83e42a5d2ef0c694" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">当前，这在所有平台上均与 &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; 。事实证明，它具有极好的可移植性，原因有两个：</target>
        </trans-unit>
        <trans-unit id="00309d71e504692e129d008c7a1eff96961c44fc" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">当前 &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; 在所有平台上都与transmute :: &amp;lt;u64，f64&amp;gt;（v）相同。事实证明，它具有极好的可移植性，原因有两个：</target>
        </trans-unit>
        <trans-unit id="de7179edea4813efbd79fdfefd23f0fcc07d0700" translate="yes" xml:space="preserve">
          <source>This is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt;:</source>
          <target state="translated">这在&lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737中&lt;/a&gt;定义：</target>
        </trans-unit>
        <trans-unit id="59a6ad6e6ae513088e0c1bb8ed9888b474a9dbba" translate="yes" xml:space="preserve">
          <source>This is designed to be used in conjunction with &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; to, for example, carry a panic across a layer of C code.</source>
          <target state="translated">它被设计为与&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt;结合使用，例如，在C代码层上引起恐慌。</target>
        </trans-unit>
        <trans-unit id="5fdeff8202418046160b5ede029f4ae17e4cb706" translate="yes" xml:space="preserve">
          <source>This is different than the &lt;code&gt;C&lt;/code&gt; representation because a struct with the &lt;code&gt;C&lt;/code&gt; representation will always have the ABI of a &lt;code&gt;C&lt;/code&gt;&lt;code&gt;struct&lt;/code&gt; while, for example, a struct with the &lt;code&gt;transparent&lt;/code&gt; representation with a primitive field will have the ABI of the primitive field.</source>
          <target state="translated">这比不同 &lt;code&gt;C&lt;/code&gt; 表示，因为与一个结构 &lt;code&gt;C&lt;/code&gt; 表示将始终具有一个的ABI &lt;code&gt;C&lt;/code&gt; &lt;code&gt;struct&lt;/code&gt; 而，例如，与一个结构 &lt;code&gt;transparent&lt;/code&gt; 与原始场表示将具有原始字段的ABI。</target>
        </trans-unit>
        <trans-unit id="f40a48629593c80076df828df6524a31bbb5832c" translate="yes" xml:space="preserve">
          <source>This is done as if by the Euclidean division algorithm -- given &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt;, &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt;.</source>
          <target state="translated">就像通过欧几里德除法算法一样-给定 &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt; ， &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt; ，并且 &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="261341fb7dbde0853cc1e229f30dada63a712ac0" translate="yes" xml:space="preserve">
          <source>This is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.</source>
          <target state="translated">这是由Rust编译器执行的。但是,在有些情况下,这个规则不够灵活。有时需要对一个对象有多个引用,但又要对它进行突变。</target>
        </trans-unit>
        <trans-unit id="1a48a3285621637ef35ee331d4de4979ad866379" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea3c08c47d3f2c239e1b0612d35fd093489ce76f" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a97a7d1bcb8cd7cc77582edff43cedf5b5f9e7ec" translate="yes" xml:space="preserve">
          <source>This is equivalent to adding the result of &lt;code&gt;padding_needed_for&lt;/code&gt; to the layout's current size.</source>
          <target state="translated">这等效于将 &lt;code&gt;padding_needed_for&lt;/code&gt; 的结果添加到布局的当前大小。</target>
        </trans-unit>
        <trans-unit id="cd40c4706f12ddab3deeab19ddffb1056c56c24a" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*const T&lt;/code&gt;, but more type-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1cc6c65ebdd0a382483c4dc8c7f13d29cc10dc3" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*mut T&lt;/code&gt;, but more type-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cc1d085b275d07a515f10b6c1293ccce68e246" translate="yes" xml:space="preserve">
          <source>This is equivalent to sending a SIGKILL on Unix platforms.</source>
          <target state="translated">这相当于在Unix平台上发送一个SIGKILL。</target>
        </trans-unit>
        <trans-unit id="f985a290d8b35439e1509532b1f307ab14186afb" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;Deref&lt;/code&gt; impl, but is explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb80b753a6a285f62ca3be46d0ca7ebb71f7211" translate="yes" xml:space="preserve">
          <source>This is equivalent to using a &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop on the iterator, although &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are not possible from a closure. It's generally more idiomatic to use a &lt;code&gt;for&lt;/code&gt; loop, but &lt;code&gt;for_each&lt;/code&gt; may be more legible when processing items at the end of longer iterator chains. In some cases &lt;code&gt;for_each&lt;/code&gt; may also be faster than a loop, because it will use internal iteration on adaptors like &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">这等效于在迭代器上使用&lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;循环，尽管无法通过闭包进行 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 。通常，使用 &lt;code&gt;for&lt;/code&gt; 循环更为习惯，但是在较长的迭代器链的末尾处理项目时， &lt;code&gt;for_each&lt;/code&gt; 可能更容易理解。在某些情况下， &lt;code&gt;for_each&lt;/code&gt; 也可能比循环快，因为它会在 &lt;code&gt;Chain&lt;/code&gt; 之类的适配器上使用内部迭代。</target>
        </trans-unit>
        <trans-unit id="85aa708c3c4c286a53847d7118e6789eccd018b1" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;Iterator::nth()&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value from the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5fc7a87669eb5a575d2a14569feb14339d998c" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;nth&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value fro the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">这本质上是&lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;nth&lt;/code&gt; &lt;/a&gt;的反向版​​本。尽管像大多数索引操作一样，计数从零开始，所以 &lt;code&gt;nth_back(0)&lt;/code&gt; 返回最后一个值， &lt;code&gt;nth_back(1)&lt;/code&gt; 返回第二个值，依此类推。</target>
        </trans-unit>
        <trans-unit id="da357ed847b3be924604524d54de90650dc840c5" translate="yes" xml:space="preserve">
          <source>This is exactly the kind of guarantee that the intrusive linked list from the previous section needs to function correctly.</source>
          <target state="translated">这正是上一节的侵入式链接列表正常运行所需要的保证。</target>
        </trans-unit>
        <trans-unit id="bb45c58beba541079b29f983c2bd8c56db26b71e" translate="yes" xml:space="preserve">
          <source>This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing &lt;code&gt;enum&lt;/code&gt; layout.</source>
          <target state="translated">编译器将其用于各种优化，例如取消运行时检查和优化 &lt;code&gt;enum&lt;/code&gt; 布局。</target>
        </trans-unit>
        <trans-unit id="2800cba431c3f0317ff7290328c22feda7e8a245" translate="yes" xml:space="preserve">
          <source>This is fixed by declaring the impl block like this:</source>
          <target state="translated">通过像这样声明 impl 块来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="7800b5b60ece10a2bb3977b34790a457f9ba1d9b" translate="yes" xml:space="preserve">
          <source>This is generally created by methods like &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;RwLock::read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常由&lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;Mutex::lock&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;RwLock::read&lt;/code&gt; &lt;/a&gt;类的方法创建。</target>
        </trans-unit>
        <trans-unit id="d04e3acde7f8ef92dfb6b7b52b3e3c3811cad1e0" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常不建议这样做，请谨慎使用！有关安全的替代方法，请参阅&lt;a href=&quot;#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bd5c92d6bc3bc69b3d544b464184377050cce05" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常不建议这样做，请谨慎使用！有关安全的选择，请参见&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1be3a48c43f2cbe9f66bb8b317aa83c1345f1b36" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f2e569769a80d9853e1327c13dd3289346f0be" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常不建议这样做，请谨慎使用！有关安全的选择，请参见&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5835397a3648f1790072b1697b1686de073dd8a5" translate="yes" xml:space="preserve">
          <source>This is highly unsafe, due to the number of invariants that aren't checked:</source>
          <target state="translated">这是很不安全的,由于没有检查的不变量太多。</target>
        </trans-unit>
        <trans-unit id="75907ab0f8297b43f4704528d57293015e32b770" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.</source>
          <target state="translated">这是作为一个固有的功能来实现的,以避免向整数转换和从整数转换,因为转换会抑制某些优化。</target>
        </trans-unit>
        <trans-unit id="11f5a22e0c8092b2e830a298d3f000dd528e1ac9" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.</source>
          <target state="translated">这是作为一个固有的功能来实现的,以避免向整数转换和从整数转换,因为转换会丢掉别名信息。</target>
        </trans-unit>
        <trans-unit id="0d148f9608c961194f7d8d82b9462e528bb48245" translate="yes" xml:space="preserve">
          <source>This is in contrast to the default behaviour of &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; which unwinds the current thread's stack and calls all destructors. When &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; is set, either as an argument to &lt;code&gt;rustc&lt;/code&gt; or in a crate's Cargo.toml, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;abort&lt;/code&gt; are similar. However, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will still call the &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;panic hook&lt;/a&gt; while &lt;code&gt;abort&lt;/code&gt; will not.</source>
          <target state="translated">这与&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;的默认行为相反！它展开当前线程的堆栈并调用所有析构函数。当 &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; 设置，无论是作为参数传递给 &lt;code&gt;rustc&lt;/code&gt; 或一箱的Cargo.toml，&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;abort&lt;/code&gt; 相似。但是，&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;仍然会调用&lt;a href=&quot;../panic/fn.set_hook&quot;&gt;紧急钩子，&lt;/a&gt;而 &lt;code&gt;abort&lt;/code&gt; 则不会。</target>
        </trans-unit>
        <trans-unit id="4ae8371c0715e2fc1f945296e51fa6a1f4eac55c" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string are not specified, other than being a best-effort description of the type. For example, &lt;code&gt;type_name_of_val::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;(None)&lt;/code&gt; could return &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. In addition, the output may change between versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ec787ed30362b911645f3b84c9e12d95cf9472" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string returned are not specified, other than being a best-effort description of the type. For example, amongst the strings that &lt;code&gt;type_name::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;()&lt;/code&gt; might return are &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc319fa8d54bb7f30ec3fbd3c75a33f269dda0d" translate="yes" xml:space="preserve">
          <source>This is intended for use cases that must synchronize content, but don't need the metadata on disk. The goal of this method is to reduce disk operations.</source>
          <target state="translated">这是为必须同步内容,但不需要磁盘上的元数据的用例准备的。这种方法的目标是减少磁盘操作。</target>
        </trans-unit>
        <trans-unit id="b4baa659f5df3a480bf1bbe9b4f50e4e5030b61c" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;OsStrExt::encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a817bf3dc422e9202ff238105af54d744a0e12d" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">这是无损的：在结果字符串上调用&lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt;将始终返回原始代码单元。</target>
        </trans-unit>
        <trans-unit id="628dc171fde34c2da2657493d9e0d1f50a03e413" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsString::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">这是无损：调用&lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsString::from_wide&lt;/code&gt; &lt;/a&gt;然后 &lt;code&gt;encode_wide&lt;/code&gt; 的结果将产生原始代码单元。请注意，编码不会添加最终的空终止符。</target>
        </trans-unit>
        <trans-unit id="77e982184c9ea4360d1954dd63bc884090bdd324" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsStringExt::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151e5762979bf36757d9fa68f187e7676c048da" translate="yes" xml:space="preserve">
          <source>This is more useful when combined with higher-level abstractions, like collecting to a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; where you only care about errors:</source>
          <target state="translated">与更高级别的抽象结合使用时，此功能尤其有用，例如收集到只关心错误的 &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="10329d9d786a635bdda96b8986fb374a569f8990" translate="yes" xml:space="preserve">
          <source>This is normally only useful in macro generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fe1510c25bad6c81eb0b6402e2bd1a4066b7f9" translate="yes" xml:space="preserve">
          <source>This is not currently supported: &lt;code&gt;v&lt;/code&gt; should be defined as &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt;. Parentheses are currently only used with generic types when defining parameters for &lt;code&gt;Fn&lt;/code&gt;-family traits.</source>
          <target state="translated">当前不支持此功能： &lt;code&gt;v&lt;/code&gt; 应该定义为 &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt; 。当前，在定义 &lt;code&gt;Fn&lt;/code&gt; 系列特征的参数时，括号仅与泛型类型一起使用。</target>
        </trans-unit>
        <trans-unit id="711ce4ce5401a3c09d45281217695490f1c55a87" translate="yes" xml:space="preserve">
          <source>This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties. If you're not sure if you should use &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;, just use &lt;code&gt;*mut T&lt;/code&gt;!</source>
          <target state="translated">在使用原始指针构建数据结构时，这通常是正确的选择，但由于其附加属性，最终使用起来更加危险。如果不确定是否应使用 &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; ，请使用 &lt;code&gt;*mut T&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="fa820eea81b725c2fa4febe2a3901035a1fc9e49" translate="yes" xml:space="preserve">
          <source>This is one of the reasons Rust projects that provide a binary have a straightforward &lt;em&gt;src/main.rs&lt;/em&gt; file that calls logic that lives in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. Using that structure, integration tests &lt;em&gt;can&lt;/em&gt; test the library crate with &lt;code&gt;use&lt;/code&gt; to make the important functionality available. If the important functionality works, the small amount of code in the &lt;em&gt;src/main.rs&lt;/em&gt; file will work as well, and that small amount of code doesn&amp;rsquo;t need to be tested.</source>
          <target state="translated">这其中的原因锈提供二进制有一个简单的项目之一&lt;em&gt;的src / main.rs&lt;/em&gt;文件调用逻辑生活在&lt;em&gt;SRC / lib.rs&lt;/em&gt;文件。使用该结构，集成测试&lt;em&gt;可以&lt;/em&gt;测试库箱的 &lt;code&gt;use&lt;/code&gt; 以使重要功能可用。如果重要的功能起作用，那么&lt;em&gt;src / main.rs&lt;/em&gt;文件中的少量代码也将起作用，并且不需要测试少量的代码。</target>
        </trans-unit>
        <trans-unit id="73e2aa9ae5cc887b643d8522a473733b99e09722" translate="yes" xml:space="preserve">
          <source>This is only available on unix platforms and must be imported in order to call the method. Windows platforms have a corresponding &lt;code&gt;AsRawHandle&lt;/code&gt; and &lt;code&gt;AsRawSocket&lt;/code&gt; set of traits.</source>
          <target state="translated">仅在unix平台上可用，并且必须将其导入才能调用该方法。Windows平台具有一组相应的 &lt;code&gt;AsRawHandle&lt;/code&gt; 和 &lt;code&gt;AsRawSocket&lt;/code&gt; 特征集。</target>
        </trans-unit>
        <trans-unit id="b95758d57810f70a3e0dda910c113e0c41898398" translate="yes" xml:space="preserve">
          <source>This is only possible if the iterator has an end, so &lt;code&gt;rev()&lt;/code&gt; only works on &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">仅当迭代器具有结束&lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;才有可能，因此 &lt;code&gt;rev()&lt;/code&gt; 仅适用于DoubleEndedIterator。</target>
        </trans-unit>
        <trans-unit id="3a074412ade07f77d614925409e4080a4208783e" translate="yes" xml:space="preserve">
          <source>This is optimal if:</source>
          <target state="translated">这是最理想的,如果:</target>
        </trans-unit>
        <trans-unit id="37e51cab1c9ec8f6780dbae6b990b1f230875324" translate="yes" xml:space="preserve">
          <source>This is primarily due to ABI incompatibilities between the two attributes. See &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt; for details on this and other limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34b82a0a85b619783fe065420d506ce185b6196" translate="yes" xml:space="preserve">
          <source>This is purely an optimization hint, and may be implemented conservatively: it may return &lt;code&gt;true&lt;/code&gt; for types that don't actually need to be dropped. As such always returning &lt;code&gt;true&lt;/code&gt; would be a valid implementation of this function. However if this function actually returns &lt;code&gt;false&lt;/code&gt;, then you can be certain dropping &lt;code&gt;T&lt;/code&gt; has no side effect.</source>
          <target state="translated">这纯粹是一个优化提示，可以保守地实现：对于实际上不需要删除的类型，它可能返回 &lt;code&gt;true&lt;/code&gt; 。因此，始终返回 &lt;code&gt;true&lt;/code&gt; 将是此函数的有效实现。但是，如果此函数实际上返回 &lt;code&gt;false&lt;/code&gt; ，则可以确定删除 &lt;code&gt;T&lt;/code&gt; 没有副作用。</target>
        </trans-unit>
        <trans-unit id="5e7810a8956ac37cd206f449b307f75cea11f52b" translate="yes" xml:space="preserve">
          <source>This is returned in a Result by either the &lt;a href=&quot;struct.command#method.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt;&lt;code&gt;wait_with_output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">这是通过&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.command#method.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt;方法或&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt;进程的&lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt; &lt;code&gt;wait_with_output&lt;/code&gt; &lt;/a&gt;方法在Result中返回的。</target>
        </trans-unit>
        <trans-unit id="b6ad57d3243660eeae5c83dc6d6e37580997866e" translate="yes" xml:space="preserve">
          <source>This is safe because it is not possible to move out of a shared reference. It may seem like there is an issue here with interior mutability: in fact, it &lt;em&gt;is&lt;/em&gt; possible to move a &lt;code&gt;T&lt;/code&gt; out of a &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. However, this is not a problem as long as there does not also exist a &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; pointing to the same data, and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does not let you create a pinned reference to its contents. See the discussion on &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;pinning projections&quot;&lt;/a&gt; for further details.</source>
          <target state="translated">这是安全的，因为不可能移出共享参考。它可能看起来像有一个问题在这里与室内的可变性：实际上，它&lt;em&gt;是&lt;/em&gt;可以移动一个 &lt;code&gt;T&lt;/code&gt; 出的 &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 。但是，只要不存在指向相同数据的 &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 不允许您创建对其内容的固定引用，这就不成问题。有关更多详细信息，请参见有关&lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&amp;ldquo;固定预测&amp;rdquo;&lt;/a&gt;的讨论。</target>
        </trans-unit>
        <trans-unit id="559d85299736482aa3edc92867921c11931dac34" translate="yes" xml:space="preserve">
          <source>This is safe because passing &lt;code&gt;self&lt;/code&gt; by value guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">这是安全的，因为按值传递 &lt;code&gt;self&lt;/code&gt; 可以确保没有其他线程同时访问原子数据。</target>
        </trans-unit>
        <trans-unit id="fdcd86e75de03ac238cab2145da08762d1c1fa0e" translate="yes" xml:space="preserve">
          <source>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">这样做是安全的,因为可变引用保证没有其他线程并发访问原子数据。</target>
        </trans-unit>
        <trans-unit id="a603b8208d8f49fcc985893385a8e118d832cdea" translate="yes" xml:space="preserve">
          <source>This is safe, because &lt;code&gt;T&lt;/code&gt; is borrowed for the &lt;code&gt;'static&lt;/code&gt; lifetime, which never ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f1c9ceb59d3f4f94d3d3fedf2ebcb7110ae8d6" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">从语义上讲，这等效于调用&lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt;并丢弃结果，但具有以下优点：</target>
        </trans-unit>
        <trans-unit id="f8249e0d4f2746bf5b8aa8a678e0e1e5a321179d" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">从语义上讲，这等效于调用&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt;并丢弃结果，但具有以下优点：</target>
        </trans-unit>
        <trans-unit id="fb69e9b77c8f67d2dd23964f55732bc6174eb1f3" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning with mutexes&lt;/a&gt;.</source>
          <target state="translated">这类似于&lt;a href=&quot;struct.mutex#poisoning&quot;&gt;使用互斥锁中毒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="323433898b799fb03eed09fdd2d727e9828c9a3d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;wake&lt;/code&gt;, but may be slightly less efficient in the case where an owned &lt;code&gt;Waker&lt;/code&gt; is available. This method should be preferred to calling &lt;code&gt;waker.clone().wake()&lt;/code&gt;.</source>
          <target state="translated">这类似于 &lt;code&gt;wake&lt;/code&gt; ，但是在拥有自己的 &lt;code&gt;Waker&lt;/code&gt; 的情况下，效率可能稍低。此方法应该比调用 &lt;code&gt;waker.clone().wake()&lt;/code&gt; 更可取。</target>
        </trans-unit>
        <trans-unit id="67ff9ed313be1a208e09d5213c1e87906d1b8ae8" translate="yes" xml:space="preserve">
          <source>This is similar to taking a reference to the whole &lt;code&gt;String&lt;/code&gt; but with the extra &lt;code&gt;[0..5]&lt;/code&gt; bit. Rather than a reference to the entire &lt;code&gt;String&lt;/code&gt;, it&amp;rsquo;s a reference to a portion of the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">这类似于引用整个 &lt;code&gt;String&lt;/code&gt; ,但带有额外的 &lt;code&gt;[0..5]&lt;/code&gt; 位。而不是对整个参考 &lt;code&gt;String&lt;/code&gt; ，它是向的一部分的参考 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e7a7ddaef0be30145306f6816d2b3ff35a14d32" translate="yes" xml:space="preserve">
          <source>This is similar to the second sub-error, but subtler. It happens in situations like the following:</source>
          <target state="translated">这与第二个子错误类似,但更小。它发生在以下情况。</target>
        </trans-unit>
        <trans-unit id="7512abd4f4f8baf21d2fa3f6cea905e84ac77b34" translate="yes" xml:space="preserve">
          <source>This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The &lt;code&gt;clone&lt;/code&gt; method is expected to not change the source value, and is declared to take &lt;code&gt;&amp;amp;self&lt;/code&gt;, not &lt;code&gt;&amp;amp;mut self&lt;/code&gt;. Therefore, any mutation that happens in the &lt;code&gt;clone&lt;/code&gt; method must use cell types. For example, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; maintains its reference counts within a &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这只是前一种情况的一种特殊情况-但很常见-这种情况：对于看起来是不可变的操作隐藏了可变性。该 &lt;code&gt;clone&lt;/code&gt; 方法，预计不会改变源值，并宣布采取 &lt;code&gt;&amp;amp;self&lt;/code&gt; ，不 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 。因此， &lt;code&gt;clone&lt;/code&gt; 方法中发生的任何突变都必须使用细胞类型。例如， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 维护其参考计数。</target>
        </trans-unit>
        <trans-unit id="022f67943cd560f4bdb5afc8c97b7f6c6d3167eb" translate="yes" xml:space="preserve">
          <source>This is sometimes done as part of an FFI:</source>
          <target state="translated">这有时是作为FFI的一部分进行的。</target>
        </trans-unit>
        <trans-unit id="ce79f7fec51f65c567a6d4b960b891ab223ea0af" translate="yes" xml:space="preserve">
          <source>This is supported on Linux only.</source>
          <target state="translated">这只在Linux上支持。</target>
        </trans-unit>
        <trans-unit id="5d02662201a60807bdb13970d8ae5dbd58d92a03" translate="yes" xml:space="preserve">
          <source>This is supported on Unix only.</source>
          <target state="translated">这只在Unix上支持。</target>
        </trans-unit>
        <trans-unit id="fe81960399abac0748704c3a05349d9cd7f1ac2c" translate="yes" xml:space="preserve">
          <source>This is supported on Windows only.</source>
          <target state="translated">这只在Windows上支持。</target>
        </trans-unit>
        <trans-unit id="7dbd409e3c209511b0279195cd6826fb5e1a2b3b" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;longest&lt;/code&gt; function from Listing 10-22 that returns the longer of two string slices. But now it has an extra parameter named &lt;code&gt;ann&lt;/code&gt; of the generic type &lt;code&gt;T&lt;/code&gt;, which can be filled in by any type that implements the &lt;code&gt;Display&lt;/code&gt; trait as specified by the &lt;code&gt;where&lt;/code&gt; clause. This extra parameter will be printed before the function compares the lengths of the string slices, which is why the &lt;code&gt;Display&lt;/code&gt; trait bound is necessary. Because lifetimes are a type of generic, the declarations of the lifetime parameter &lt;code&gt;'a&lt;/code&gt; and the generic type parameter &lt;code&gt;T&lt;/code&gt; go in the same list inside the angle brackets after the function name.</source>
          <target state="translated">这是清单10-22中 &lt;code&gt;longest&lt;/code&gt; 函数，该函数返回两个字符串切片中的较长者。但是，现在它有了一个名为 &lt;code&gt;ann&lt;/code&gt; 的通用类型 &lt;code&gt;T&lt;/code&gt; 的额外参数，该参数可以由实现 &lt;code&gt;where&lt;/code&gt; 子句指定的 &lt;code&gt;Display&lt;/code&gt; trait 的任何类型填充。在函数比较字符串片段的长度之前，将打印此额外的参数，这就是为什么必须使用 &lt;code&gt;Display&lt;/code&gt; trait绑定的原因。由于生命周期是一种通用类型，因此生命周期参数 &lt;code&gt;'a&lt;/code&gt; 和通用类型参数 &lt;code&gt;T&lt;/code&gt; 的声明位于函数名称后尖括号内的同一列表中。</target>
        </trans-unit>
        <trans-unit id="771b5400b1697f2e03b3ff52d8994e98c72fb56e" translate="yes" xml:space="preserve">
          <source>This is the alignment used for struct fields. It may be smaller than the preferred alignment.</source>
          <target state="translated">这是用于结构字段的对齐方式。它可能小于首选的对齐方式。</target>
        </trans-unit>
        <trans-unit id="d7e12ec340db516b6de450f2a63092abb536959d" translate="yes" xml:space="preserve">
          <source>This is the const generic equivalent of &lt;a href=&quot;#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea5fa4cdf245151000dcd8208cd57fa7396ef40" translate="yes" xml:space="preserve">
          <source>This is the correct syntax:</source>
          <target state="translated">这是正确的语法。</target>
        </trans-unit>
        <trans-unit id="8a3edb9de97e0819d33135bbb50051a98c123c3a" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540ad0b8406b1727e0f455b9b013663295117df7" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next largest representable number.</source>
          <target state="translated">这是 &lt;code&gt;1.0&lt;/code&gt; 与下一个最大可表示数字之间的差。</target>
        </trans-unit>
        <trans-unit id="c620ac5f199d804600d9e6fa867d20d7e4f16f11" translate="yes" xml:space="preserve">
          <source>This is the first example of Rust&amp;rsquo;s safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing. Chapter 9 discusses more of Rust&amp;rsquo;s error handling.</source>
          <target state="translated">这是Rust实施安全原则的第一个示例。在许多低级语言中，不会执行这种检查，并且当您提供错误的索引时，可以访问无效的内存。Rust通过立即退出而不是允许内存访问并继续操作来保护您免受此类错误的侵害。第9章讨论了Rust的更多错误处理。</target>
        </trans-unit>
        <trans-unit id="96d082bf8459464d47b35442a1fa45813a325a53" translate="yes" xml:space="preserve">
          <source>This is the main iterator trait. For more about the concept of iterators generally, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;. In particular, you may want to know how to &lt;a href=&quot;index#implementing-iterator&quot;&gt;implement &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是主要的迭代器特征。有关一般迭代器概念的更多信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。特别是，您可能想知道如何&lt;a href=&quot;index#implementing-iterator&quot;&gt;实现 &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b386764c4159d37f683e85f4c4afa8c88d4fe909" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289f1434eafb60316aca77ad31a00e3c0eb9323a" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">这是索引 &lt;code&gt;str&lt;/code&gt; 的非紧急选择。每当等效的索引操作将崩溃时，将返回&lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="759018d521d201d38bc076c0727a5d9a6e429fac" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#method.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt;的非恐慌形式。</target>
        </trans-unit>
        <trans-unit id="70fed40b0a485aa104ed49c92498ff0b436cf03b" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;的非惊慌变体。</target>
        </trans-unit>
        <trans-unit id="ccd5e95eaa2f4ad9676aca34c8e9ba1ff21b3015" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0528fc88151b305168bd5debfa38b6c659b612" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fe748271e612bae240bf98e735a830b559c459" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3a0dba802b6e4f6285d94d4683f5056846f9fd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;Iterator::fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce445e189c1252f0055062d54b89751ff0fb729" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">这是&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的后面开始接收元素。</target>
        </trans-unit>
        <trans-unit id="bc1780a770503660513f01fa15c1efc71fef0175" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6ff5d62e332d4883802b0cf8675d53b663b171" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f33f9266690c3f1f82aab587ca29e140daa7ab" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">这是&lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的后面开始接收元素。</target>
        </trans-unit>
        <trans-unit id="d46122a89a465fda704ceb8118ba4c1126be2832" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是[ &lt;code&gt;try_fold()&lt;/code&gt; ] 的反向版​​本：它从迭代器的背面开始获取元素。&lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f495531f8eacf0a1680dc0219ed83707197faddd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是[ &lt;code&gt;try_fold()&lt;/code&gt; ] 的反向版​​本：它从迭代器的背面开始获取元素。&lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ec81940d41390cbbcb80997a4e3d957d2b9a317" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是[ &lt;code&gt;try_fold()&lt;/code&gt; ] 的反向版​​本：它从迭代器的背面开始获取元素。&lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ff3fa51ad38f312277040719826a7c977bbcd8a" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是[ &lt;code&gt;try_fold()&lt;/code&gt; ] 的反向版​​本：它从迭代器的背面开始获取元素。&lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383e94e01b1343c9d6bcfb23e7f045e384d94336" translate="yes" xml:space="preserve">
          <source>This is the same as using the &lt;code&gt;==&lt;/code&gt; operator, but less generic: the arguments have to be &lt;code&gt;*const T&lt;/code&gt; raw pointers, not anything that implements &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">这与使用 &lt;code&gt;==&lt;/code&gt; 运算符相同，但通用性较低：参数必须是 &lt;code&gt;*const T&lt;/code&gt; 原始指针，而不是任何实现 &lt;code&gt;PartialEq&lt;/code&gt; 的指针。</target>
        </trans-unit>
        <trans-unit id="22b2f39cdef64a09df83167c24366e9e24591fdf" translate="yes" xml:space="preserve">
          <source>This is the unchecked alternative to indexing the &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">这是索引 &lt;code&gt;str&lt;/code&gt; 的未经检查的替代方法。</target>
        </trans-unit>
        <trans-unit id="589a4243aa6d42e7fc5ac36f0baed5a47e1de444" translate="yes" xml:space="preserve">
          <source>This is used for object safety, to check that a method's receiver type can be dispatched on.</source>
          <target state="translated">这用于对象安全,检查一个方法的接收器类型能否被派发上。</target>
        </trans-unit>
        <trans-unit id="9aea807f1415223ad9d946b1ace7fbf6d55fe5aa" translate="yes" xml:space="preserve">
          <source>This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.</source>
          <target state="translated">当程序员知道线程在一段时间内将无所事事,从而避免浪费计算时间时,就会使用这个方法。</target>
        </trans-unit>
        <trans-unit id="5ce1e416198eb464ee0a2977f8013c35c0e89565" translate="yes" xml:space="preserve">
          <source>This is useful any time that the compiler can't determine that some code is unreachable. For example:</source>
          <target state="translated">在编译器无法确定某些代码无法到达的时候,这一点都很有用。例如:</target>
        </trans-unit>
        <trans-unit id="85e4c5ffc08236fd25e25201dcbaaa8757900c78" translate="yes" xml:space="preserve">
          <source>This is useful for</source>
          <target state="translated">这对以下情况很有用</target>
        </trans-unit>
        <trans-unit id="a885d8fe460e46c9230b0d468a457bef6acf54a6" translate="yes" xml:space="preserve">
          <source>This is useful for a flavor of &quot;optimistic check&quot; before deciding to block on a receiver.</source>
          <target state="translated">这对于在决定对接盘侠进行阻击之前,进行一味的 &quot;乐观检查 &quot;是很有用的。</target>
        </trans-unit>
        <trans-unit id="79e1d9086d9f417d98c9a3f1df01e78fe0db96d9" translate="yes" xml:space="preserve">
          <source>This is useful for initializing types which lazily allocate, like &lt;code&gt;Vec::new&lt;/code&gt; does.</source>
          <target state="translated">这对于初始化延迟分配的类型很有用，例如 &lt;code&gt;Vec::new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08ec962229a27774cdabf85bddcaa5d6f625b9ff" translate="yes" xml:space="preserve">
          <source>This is useful to allow applying iterator adaptors while still retaining ownership of the original iterator.</source>
          <target state="translated">这对于允许应用迭代器适配器,同时仍然保留原始迭代器的所有权非常有用。</target>
        </trans-unit>
        <trans-unit id="920763b96fccf7eb85a93a16a5bdd675d6fd634c" translate="yes" xml:space="preserve">
          <source>This is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c983c1aa2c476c3f346d2a87a469f6be7bac78d1" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; into an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; may contain a value that an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; to an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; (essentially giving the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;'s value modulo &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;) or by simply returning &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;, or by some other method. The &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ccb84e9a4faa353cb290ddc5e855748a76c17b" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;code&gt;i64&lt;/code&gt; into an &lt;code&gt;i32&lt;/code&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;code&gt;i64&lt;/code&gt; may contain a value that an &lt;code&gt;i32&lt;/code&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;code&gt;i64&lt;/code&gt; to an &lt;code&gt;i32&lt;/code&gt; (essentially giving the &lt;code&gt;i64&lt;/code&gt;'s value modulo &lt;code&gt;i32::MAX&lt;/code&gt;) or by simply returning &lt;code&gt;i32::MAX&lt;/code&gt;, or by some other method. The &lt;code&gt;From&lt;/code&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">当您执行的类型转换可能会成功完成但可能还需要特殊处理时，这很有用。例如， &lt;code&gt;i32&lt;/code&gt; 使用&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;特性将 &lt;code&gt;i64&lt;/code&gt; 转换为i32，因为 &lt;code&gt;i64&lt;/code&gt; 可能包含 &lt;code&gt;i32&lt;/code&gt; 无法表示的值，因此转换将丢失数据。这可能通过截断处理 &lt;code&gt;i64&lt;/code&gt; 到 &lt;code&gt;i32&lt;/code&gt; （基本上是给 &lt;code&gt;i64&lt;/code&gt; 的价值模 &lt;code&gt;i32::MAX&lt;/code&gt; ），或简单地返回 &lt;code&gt;i32::MAX&lt;/code&gt; ，或通过其他方法。在 &lt;code&gt;From&lt;/code&gt; 特性适用于完美的转换，所以 &lt;code&gt;TryFrom&lt;/code&gt; 特质会通知程序员类型转换何时会变差，并让他们决定如何处理它。</target>
        </trans-unit>
        <trans-unit id="878335df341d736b2b477f7d269d41d041479a70" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.</source>
          <target state="translated">当你有一个迭代器的迭代器或一个可以变成迭代器的事物的迭代器,而你想去掉一个层次的间接性时,这很有用。</target>
        </trans-unit>
        <trans-unit id="bc06069272831e3fab63600d60da8286a4aa9faf" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator over &lt;code&gt;&amp;amp;T&lt;/code&gt;, but you need an iterator over &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">当在 &lt;code&gt;&amp;amp;T&lt;/code&gt; 上有一个迭代器，但在 &lt;code&gt;T&lt;/code&gt; 上需要一个迭代器时，这很有用。</target>
        </trans-unit>
        <trans-unit id="28c350dd4bfc1f4f50a6db4a558fce8f481fa714" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted list of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望输出格式化的项目列表作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分时，这很有用。</target>
        </trans-unit>
        <trans-unit id="023c37d743c95a28f62cb66dc28c6981840e275e" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted map as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望将格式化的地图作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分输出时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="5a019c845f0ac55c26e73d5fc98b9e29c14a5266" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted set of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望输出格式化的项目集作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分时，这很有用。</target>
        </trans-unit>
        <trans-unit id="742e4efaa0964cab1a9b13d64aa3f1ee505fbe93" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted struct as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望将格式化的结构作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分输出时，这很有用。</target>
        </trans-unit>
        <trans-unit id="7450774ae735743f9affac51ccc2935a02180916" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted tuple as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望将格式化的元组作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分输出时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="678189b9778744d56a77a9ddbd180a89dff66dd0" translate="yes" xml:space="preserve">
          <source>This is usually not needed when writing safe code, as &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;es&lt;/a&gt; already poison themselves when a thread panics while holding the lock.</source>
          <target state="translated">这编写安全的代码时，因为通常不需要&lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; ES&lt;/a&gt;已经毒害自己，当持有的锁，而线程恐慌。</target>
        </trans-unit>
        <trans-unit id="73513599023f5ddb254ee6ed0d00bccac264c338" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="translated">通常与 &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 。然而，当 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;有&lt;/em&gt;没有静态已知的尺寸，例如，切片&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;性状对象&lt;/a&gt;，然后 &lt;code&gt;size_of_val&lt;/code&gt; 可用于获得动态已知大小。</target>
        </trans-unit>
        <trans-unit id="8b96a4f28b82d88010bb7132ad9ee35ef317464c" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val_raw&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abe6d863c59136664f0a7528f19c0cd3ff2fed7" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the exact signature that&amp;rsquo;s in the standard library: in the standard library, &lt;code&gt;add&lt;/code&gt; is defined using generics. Here, we&amp;rsquo;re looking at the signature of &lt;code&gt;add&lt;/code&gt; with concrete types substituted for the generic ones, which is what happens when we call this method with &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">这不是标准库中的确切签名：在标准库中， &lt;code&gt;add&lt;/code&gt; 是使用泛型定义的。在这里，我们正在查看用具体类型替换通用类型的 &lt;code&gt;add&lt;/code&gt; 的签名，这是在我们使用 &lt;code&gt;String&lt;/code&gt; 值调用此方法时发生的情况。我们将在第10章中讨论泛型。此签名为我们提供了了解 &lt;code&gt;+&lt;/code&gt; 运算符的棘手位所需的线索。</target>
        </trans-unit>
        <trans-unit id="677e3e0ad58a3857efcf5b71bd28f251f1ad71c2" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the last you&amp;rsquo;ll see of concurrency in this book: the project in Chapter 20 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.</source>
          <target state="translated">这不是本书中您最后看到的并发性：第20章的项目将比本章讨论的较小示例更实际地使用本章中的概念。</target>
        </trans-unit>
        <trans-unit id="c724cabc6d2e28a46495b5e9f7308161c3ff4773" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method is a good solution. Example:</source>
          <target state="translated">这是不允许的,但使用一个特质来实现一个方法是一个很好的解决方案。例子:</target>
        </trans-unit>
        <trans-unit id="c15fbb2556c65982174521dc6e82a15681dc164d" translate="yes" xml:space="preserve">
          <source>This isn't typically the method you want; these addresses don't typically function on modern systems. Use &lt;code&gt;to_ipv6_mapped&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca75bc59c45502aa721dfcf6b2008b560ce93b8c" translate="yes" xml:space="preserve">
          <source>This issue also ties into the second problem: although &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are configuration variables to our program, variables like &lt;code&gt;contents&lt;/code&gt; are used to perform the program&amp;rsquo;s logic. The longer &lt;code&gt;main&lt;/code&gt; becomes, the more variables we&amp;rsquo;ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It&amp;rsquo;s best to group the configuration variables into one structure to make their purpose clear.</source>
          <target state="translated">此问题还与第二个问题有关：尽管 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 是程序的配置变量，但诸如 &lt;code&gt;contents&lt;/code&gt; 类的变量仍用于执行程序的逻辑。较长的 &lt;code&gt;main&lt;/code&gt; 变，我们需要纳入范围的多个变量;我们范围内的变量越多，跟踪每个变量的目的就越困难。最好将配置变量分组为一个结构，以明确其用途。</target>
        </trans-unit>
        <trans-unit id="f6ff2f3673f7e2d10b1136073892f6a7e26909fe" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">此迭代器已&lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;融合&lt;/a&gt;，但是&lt;strong&gt;未指定&lt;/strong&gt;迭代完成后的 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 的特定值，除了&lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt;一旦不再产生值将返回 &lt;code&gt;true&lt;/code&gt; 之外。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1db674404809b8384b33fb85e1f59e9aa55c87a" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ff5b740b07569a5d9914bbdea6a0fe28474b82" translate="yes" xml:space="preserve">
          <source>This iterator is returned from the &lt;a href=&quot;fn.read_dir&quot;&gt;&lt;code&gt;read_dir&lt;/code&gt;&lt;/a&gt; function of this module and will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Through a &lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt; information like the entry's path and possibly other metadata can be learned.</source>
          <target state="translated">此迭代器从此模块的&lt;a href=&quot;fn.read_dir&quot;&gt; &lt;code&gt;read_dir&lt;/code&gt; &lt;/a&gt;函数返回，并将产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。通过&lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; ,可以&lt;/a&gt;了解类似于条目路径以及可能的其他元数据的信息。</target>
        </trans-unit>
        <trans-unit id="039cfdd22f7232d788dc3924aaf58e6af89b9b42" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned if the corresponding channel has hung up.</source>
          <target state="translated">每当调用&lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;时，此迭代器将阻塞，等待新消息；如果相应的通道已挂断，则将不返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47622e0905704752b067e8fb130b53a4d875da6d" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned when the corresponding channel has hung up.</source>
          <target state="translated">每当调用&lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;时，此迭代器将阻塞，等待新消息，并且当相应的通道挂断时，将不返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d5f1a4f383a40c5608e98cdb7f233b0d0bd50b4" translate="yes" xml:space="preserve">
          <source>This iterator will never block the caller in order to wait for data to become available. Instead, it will return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此迭代器永远不会阻塞调用方，以等待数据可用。相反，它将返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ded90014878b45a9d1013952a0eeccef1815fa3" translate="yes" xml:space="preserve">
          <source>This iterator yields mutable references to the slice's elements, so while the element type of the slice is &lt;code&gt;i32&lt;/code&gt;, the element type of the iterator is &lt;code&gt;&amp;amp;mut i32&lt;/code&gt;.</source>
          <target state="translated">该迭代器产生对slice元素的可变引用，因此，虽然slice的元素类型为 &lt;code&gt;i32&lt;/code&gt; ，但是迭代器的元素类型为 &lt;code&gt;&amp;amp;mut i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11293328eb4e550149e3eb11d18b4b99dadeb4a" translate="yes" xml:space="preserve">
          <source>This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and the primary method is the &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该密钥使用目标平台可用的最快实现。用&lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt;实例化！宏，主要方法是&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="8ba72c9f8d060c616c313ff46104db0834e023c2" translate="yes" xml:space="preserve">
          <source>This kind of reordering is handled transparently by the CPU.</source>
          <target state="translated">这种重新排序是由CPU透明地处理的。</target>
        </trans-unit>
        <trans-unit id="01e9e67a62e244fe3547a3a6a38b452018a02bd0" translate="yes" xml:space="preserve">
          <source>This kind of string &lt;em&gt;can&lt;/em&gt; be mutated:</source>
          <target state="translated">这种字符串&lt;em&gt;可以&lt;/em&gt;被改变：</target>
        </trans-unit>
        <trans-unit id="a40000b09a25d1541d4b670c6d1a695e653d4397" translate="yes" xml:space="preserve">
          <source>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. &lt;code&gt;2.f64&lt;/code&gt; would attempt to call a method named &lt;code&gt;f64&lt;/code&gt; on &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">最后一个示例有所不同，因为无法将后缀语法与以句点结尾的浮点文字一起使用。 &lt;code&gt;2.f64&lt;/code&gt; 将尝试在 &lt;code&gt;2&lt;/code&gt; 上调用名为 &lt;code&gt;f64&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="d48b41e91473a0fe92d3d1ed63ecf51de63aefff" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">该长度以字节为单位，而不是&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或字形。换句话说，可能不是人们认为弦的长度。</target>
        </trans-unit>
        <trans-unit id="73dde2c319f588f84c6b8fc0596849d35bbf8b64" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903d848487fc64b3813a8038fcea8db3d845066a" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">该长度以字节为单位，而不是&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或字形。换句话说，可能不是人们认为弦的长度。</target>
        </trans-unit>
        <trans-unit id="7b4fe84d99fc580ad8ef75775e9a6a1acf338c01" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8980a7dcbb36debff75ad398d722c2e476b435" translate="yes" xml:space="preserve">
          <source>This limitation may be removed in a future version of Rust.</source>
          <target state="translated">这个限制可能会在未来的Rust版本中被删除。</target>
        </trans-unit>
        <trans-unit id="65d7d6e48995b9a8b70ff571d23a4947777c0d68" translate="yes" xml:space="preserve">
          <source>This limitation on the size &lt;code&gt;N&lt;/code&gt; exists because Rust does not yet support code that is generic over the size of an array type. &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Bar; 3]&lt;/code&gt; are instances of same generic type &lt;code&gt;[T; 3]&lt;/code&gt;, but &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Foo; 5]&lt;/code&gt; are entirely different types. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">之所以存在对大小 &lt;code&gt;N&lt;/code&gt; 的限制，是因为Rust尚不支持在数组类型的大小上通用的代码。 &lt;code&gt;[Foo; 3]&lt;/code&gt; 和 &lt;code&gt;[Bar; 3]&lt;/code&gt; 是相同泛型 &lt;code&gt;[T; 3]&lt;/code&gt; ，但 &lt;code&gt;[Foo; 3]&lt;/code&gt; 和 &lt;code&gt;[Foo; 5]&lt;/code&gt; 是完全不同的类型。作为权宜之计，特质实现是静态生成的，最大大小为32。</target>
        </trans-unit>
        <trans-unit id="08204384af7f77c5b07543f234ee809fc102751e" translate="yes" xml:space="preserve">
          <source>This line brings &lt;code&gt;std::io&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">这行代码将 &lt;code&gt;std::io&lt;/code&gt; 和 &lt;code&gt;std::io::Write&lt;/code&gt; 纳入作用域。</target>
        </trans-unit>
        <trans-unit id="c84219e32c60c562866367e57dce5465f094cc72" translate="yes" xml:space="preserve">
          <source>This line creates a new empty string called &lt;code&gt;s&lt;/code&gt;, which we can then load data into. Often, we&amp;rsquo;ll have some initial data that we want to start the string with. For that, we use the &lt;code&gt;to_string&lt;/code&gt; method, which is available on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait, as string literals do. Listing 8-12 shows two examples.</source>
          <target state="translated">该行创建了一个名为 &lt;code&gt;s&lt;/code&gt; 的新空字符串，然后我们可以将数据加载到其中。通常，我们会使用一些初始数据作为字符串的开头。为此，我们使用 &lt;code&gt;to_string&lt;/code&gt; 方法，该方法可在实现 &lt;code&gt;Display&lt;/code&gt; 特征的任何类型上使用，就像字符串文字一样。清单8-12显示了两个示例。</target>
        </trans-unit>
        <trans-unit id="c6d1af215b1b045e01e47bacfa1ae42f66655d33" translate="yes" xml:space="preserve">
          <source>This line creates a new variable named &lt;code&gt;foo&lt;/code&gt; and binds it to the value of the &lt;code&gt;bar&lt;/code&gt; variable. In Rust, variables are immutable by default. We&amp;rsquo;ll be discussing this concept in detail in the &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;Variables and Mutability&amp;rdquo;&lt;/a&gt; section in Chapter 3. The following example shows how to use &lt;code&gt;mut&lt;/code&gt; before the variable name to make a variable mutable:</source>
          <target state="translated">这行代码创建一个名为 &lt;code&gt;foo&lt;/code&gt; 的新变量，并将其绑定到 &lt;code&gt;bar&lt;/code&gt; 变量的值。在Rust中，默认情况下变量是不可变的。我们将在第3章的&lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;变量和可变性&amp;rdquo;&lt;/a&gt;部分中详细讨论这个概念。下面的示例演示如何在变量名称之前使用 &lt;code&gt;mut&lt;/code&gt; 来使变量可变：</target>
        </trans-unit>
        <trans-unit id="f414052fdd19a240f8f368c285f45f2ce792b467" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9eacc9407c12ec62c5abf0aec26e9081e77d6a" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here. First, Rust style is to indent with four spaces, not a tab.</source>
          <target state="translated">这一行在这个小程序中完成了所有的工作:它将文字打印到屏幕上。这里有四个重要的细节需要注意。首先,Rust的风格是用四个空格缩进,而不是制表符。</target>
        </trans-unit>
        <trans-unit id="6bb12529672d4d91a104d1b5e1346fffbd28c07c" translate="yes" xml:space="preserve">
          <source>This line prints the string we saved the user&amp;rsquo;s input in. The set of curly brackets, &lt;code&gt;{}&lt;/code&gt;, is a placeholder: think of &lt;code&gt;{}&lt;/code&gt; as little crab pincers that hold a value in place. You can print more than one value using curly brackets: the first set of curly brackets holds the first value listed after the format string, the second set holds the second value, and so on. Printing multiple values in one call to &lt;code&gt;println!&lt;/code&gt; would look like this:</source>
          <target state="translated">该行显示了我们保存用户输入内容的字符串。大括号 &lt;code&gt;{}&lt;/code&gt; 组是一个占位符：将 &lt;code&gt;{}&lt;/code&gt; 看作是保留了适当值的小蟹钳。您可以使用大括号打印多个值：第一组大括号包含格式字符串后列出的第一个值，第二组大括号包含第二个值，依此类推。一次调用 &lt;code&gt;println!&lt;/code&gt; 打印多个值！看起来像这样：</target>
        </trans-unit>
        <trans-unit id="250f132a4cd3e14f1923c5e6c25a460649fabde4" translate="yes" xml:space="preserve">
          <source>This list is intended to grow over time and it is not recommended to exhaustively match against it.</source>
          <target state="translated">这个榜单的目的是随着时间的推移而增长,不建议详尽对照。</target>
        </trans-unit>
        <trans-unit id="308882c8bb15621452c72c71d1e862ba6ca42816" translate="yes" xml:space="preserve">
          <source>This longer form is equivalent to the example in the previous section but is more verbose. We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.</source>
          <target state="translated">这个较长的形式相当于上一节的例子,但比较啰嗦。我们将特质边界与通用类型参数的声明放在冒号之后,并放在角括号内。</target>
        </trans-unit>
        <trans-unit id="cc7e694b75fd14e7d2942129d96e2363378281a2" translate="yes" xml:space="preserve">
          <source>This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in &lt;code&gt;s1&lt;/code&gt; and bind it to &lt;code&gt;s2&lt;/code&gt;. But this isn&amp;rsquo;t quite what happens.</source>
          <target state="translated">这看起来与之前的代码非常相似，因此我们可以假设它的工作方式是相同的：也就是说，第二行将在 &lt;code&gt;s1&lt;/code&gt; 中复制值并将其绑定到 &lt;code&gt;s2&lt;/code&gt; 。但这不是完全会发生的事情。</target>
        </trans-unit>
        <trans-unit id="1be98a7c6692df395b8bd9dd115eb38bb55be823" translate="yes" xml:space="preserve">
          <source>This macro accepts a 'writer', a format string, and a list of arguments. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3025eb870ba9e5f6ef770103ab20b04b0f42de4f" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c26f6e16b6bec90033e045df684b9983904c03" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;std::fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;std::fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该宏接受格式字符串，参数列表和&amp;ldquo; writer&amp;rdquo;。参数将根据指定的格式字符串进行格式化，并将结果传递给编写器。 writer可以是带有 &lt;code&gt;write_fmt&lt;/code&gt; 方法的任何值；通常，这来自于&lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;std::fmt::Write&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt;特性的实现。宏返回 &lt;code&gt;write_fmt&lt;/code&gt; 方法返回的任何内容；通常是&lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;std::fmt::Result&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80d761ee9febd1152f2043eb4792d1bde7232938" translate="yes" xml:space="preserve">
          <source>This macro bakes in propagation of &lt;code&gt;Pending&lt;/code&gt; signals by returning early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9104464c61f2440f3d22798d14bf9b51373598ab" translate="yes" xml:space="preserve">
          <source>This macro functions by taking a formatting string literal containing &lt;code&gt;{}&lt;/code&gt; for each additional argument passed. &lt;code&gt;format_args!&lt;/code&gt; prepares the additional parameters to ensure the output can be interpreted as a string and canonicalizes the arguments into a single type. Any value that implements the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait can be passed to &lt;code&gt;format_args!&lt;/code&gt;, as can any &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; implementation be passed to a &lt;code&gt;{:?}&lt;/code&gt; within the formatting string.</source>
          <target state="translated">此宏通过为每个传递的附加参数采用包含 &lt;code&gt;{}&lt;/code&gt; 的格式字符串文字来运行。 &lt;code&gt;format_args!&lt;/code&gt; 准备其他参数，以确保输出可以解释为字符串，并将参数规范化为单个类型。任何实现&lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;特性的值都可以传递给 &lt;code&gt;format_args!&lt;/code&gt; ，任何&lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;实现都可以传递给格式字符串内的 &lt;code&gt;{:?}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0f46ebdcffb6d5939dcac636e4ba0ac8074178d" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">该宏具有第二种形式，其中可以提供带有或不带有用于格式化的参数的自定义紧急消息。有关此格式的语法，请参见&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cb7c87fdbeb8a27a8d17493d87d56c13827aded" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5986245d717af402afebe47105d05cdf22c051" translate="yes" xml:space="preserve">
          <source>This macro is provided in the standard library and will detect at runtime whether the specified CPU feature is detected. This does &lt;strong&gt;not&lt;/strong&gt; resolve at compile time unless the specified feature is already enabled for the entire crate. Runtime detection currently relies mostly on the &lt;code&gt;cpuid&lt;/code&gt; instruction.</source>
          <target state="translated">标准库中提供了此宏，它将在运行时检测是否检测到指定的CPU功能。这并&lt;strong&gt;不会&lt;/strong&gt;，除非指定功能，则整个箱子已经启用在编译时解决。当前，运行时检测主要依赖于 &lt;code&gt;cpuid&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="9c76b02a9e85e30ad24e030882216f3064330d6d" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d199c9b2bbee396aca26a7f3417fd4e87ff814" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to None or Err variants.</source>
          <target state="translated">该宏是在示例代码和测试中声明条件的理想方式。 &lt;code&gt;panic!&lt;/code&gt; 与&lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;枚举的 &lt;code&gt;unwrap&lt;/code&gt; 方法紧密相关。两种实现都 &lt;code&gt;panic!&lt;/code&gt; 将它们设置为&amp;ldquo;无&amp;rdquo;或&amp;ldquo;错误&amp;rdquo;变体时。</target>
        </trans-unit>
        <trans-unit id="d0ebce932633e1b0cd797b4ddeb6ac5a11d9e6f7" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;a href=&quot;boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;any/trait.any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0774da3df0d29e08106daf482fff334bcea403" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">此宏用于将紧急情况注入Rust线程，从而使该线程完全发生紧急情况。每个线程的恐慌都可以作为 &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; 类型，以及 &lt;code&gt;panic!&lt;/code&gt; 的单参数形式！宏将是要传输的值。</target>
        </trans-unit>
        <trans-unit id="e7802aaf0db102edbab92f402c03063ff3b73be4" translate="yes" xml:space="preserve">
          <source>This macro only takes one argument which is a string literal of the feature being tested for. The feature names supported are the lowercase versions of the ones defined by Intel in &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;their documentation&lt;/a&gt;.</source>
          <target state="translated">该宏仅接受一个参数，该参数是要测试的功能的字符串文字。支持的功能名称是英特尔在&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;其文档中&lt;/a&gt;定义的功能的小写版本。</target>
        </trans-unit>
        <trans-unit id="4bd8a54709ee381edf667e1b754c2dd4776028dd" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">这个宏产生一个&lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;类型的值。该值可以传递给&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;的宏，以执行有用的重定向。所有其他格式化宏（&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;等）都通过此代理。 &lt;code&gt;format_args!&lt;/code&gt; 与派生宏不同，它避免了堆分配。</target>
        </trans-unit>
        <trans-unit id="209265c4eb72c5eca06cd095d36df90048938379" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d449e18cd48bf8c444aeabc9c847abf69b5ab8d" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, but emits an error during &lt;em&gt;compilation&lt;/em&gt; rather than at &lt;em&gt;runtime&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49c196cc9f23d7594245f1cc87a1f518746592e" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, which emits an error at &lt;em&gt;runtime&lt;/em&gt;, rather than during compilation.</source>
          <target state="translated">当板条箱使用条件编译策略为错误条件提供更好的错误消息时，应使用此宏。这是编译器级别的&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;，它会在&lt;em&gt;运行时&lt;/em&gt;（而不是在编译期间）发出错误。</target>
        </trans-unit>
        <trans-unit id="68d15cf83524f34dd8d8be7a2a8e7bed6740e783" translate="yes" xml:space="preserve">
          <source>This macro supports the same names that &lt;code&gt;#[target_feature]&lt;/code&gt; supports. Unlike &lt;code&gt;#[target_feature]&lt;/code&gt;, however, this macro does not support names separated with a comma. Instead testing for multiple features must be done through separate macro invocations for now.</source>
          <target state="translated">该宏支持 &lt;code&gt;#[target_feature]&lt;/code&gt; 支持的相同名称。但是，与 &lt;code&gt;#[target_feature]&lt;/code&gt; 不同，此宏不支持用逗号分隔的名称。相反，现在必须通过单独的宏调用来测试多个功能。</target>
        </trans-unit>
        <trans-unit id="fefc6add454f34259443790785050840eebbeb57" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</source>
          <target state="translated">这个宏接收任意数量的逗号分隔的标识符,并将它们全部连接成一个,产生一个新标识符的表达式。请注意,由于卫生原因,这个宏不能捕获局部变量。另外,作为一般规则,宏只允许在项、语句或表达式的位置使用。这意味着虽然你可以使用这个宏来引用现有的变量、函数或模块等,但你不能用它定义一个新的变量。</target>
        </trans-unit>
        <trans-unit id="a79ce9bb3fa69012483f80e7a1a2541065700d68" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated literals, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which represents all of the literals concatenated left-to-right.</source>
          <target state="translated">该宏采用任意数量的逗号分隔的文字，产生类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的表达式，该表达式表示从左到右串联的所有文字。</target>
        </trans-unit>
        <trans-unit id="79fc3c2904becf8aa3c820c279472de0fe3a1f68" translate="yes" xml:space="preserve">
          <source>This macro will expand to the value of the named environment variable at compile time, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">该宏将在编译时扩展为指定的环境变量的值，从而产生类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的表达式。</target>
        </trans-unit>
        <trans-unit id="95e973b1ebc33842358cee19e0dba22c8a81f994" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">该宏将产生 &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; ，即文件的内容。</target>
        </trans-unit>
        <trans-unit id="9cdb0bb59a3aefac2ea084695df47352b8cc7f18" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">该宏将产生类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的表达式，该表达式是文件的内容。</target>
        </trans-unit>
        <trans-unit id="8d3907f6b0e9a61a4bdb55de9a362a92915237c3" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the stringification of all the tokens passed to the macro. No restrictions are placed on the syntax of the macro invocation itself.</source>
          <target state="translated">这个宏将产生类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的表达式，该表达式是传递给该宏的所有令牌的字符串化。宏调用本身的语法没有任何限制。</target>
        </trans-unit>
        <trans-unit id="96f8e740156b1fe8242bb1857eb516b34c772e7e" translate="yes" xml:space="preserve">
          <source>This macro would parse the SQL statement inside it and check that it&amp;rsquo;s syntactically correct, which is much more complex processing than a &lt;code&gt;macro_rules!&lt;/code&gt; macro can do. The &lt;code&gt;sql!&lt;/code&gt; macro would be defined like this:</source>
          <target state="translated">该宏将解析其中的SQL语句，并检查其语法是否正确，这比 &lt;code&gt;macro_rules!&lt;/code&gt; 复杂得多！宏可以做。的 &lt;code&gt;sql!&lt;/code&gt; 宏的定义如下：</target>
        </trans-unit>
        <trans-unit id="f58f7dcc462ef7387fceff17b5cae04e3cbcbf04" translate="yes" xml:space="preserve">
          <source>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</source>
          <target state="translated">这使得该特质在作用域中的所有类型上都能实现。因此,如果你试图在此后的另一个类型上实现它,那么这些实现将发生冲突。例子:</target>
        </trans-unit>
        <trans-unit id="dafc2f14b4f56d8dc5d075ff34c826a36e387880" translate="yes" xml:space="preserve">
          <source>This may not actually increase the capacity:</source>
          <target state="translated">这实际上可能并没有增加容量。</target>
        </trans-unit>
        <trans-unit id="af903b6fc00acf0d280f6c29b1e0e8d3aeb94082" translate="yes" xml:space="preserve">
          <source>This may only be called by &lt;code&gt;Read&lt;/code&gt;ers which guarantee that they will not read from buffers passed to &lt;code&gt;Read&lt;/code&gt; methods, and that the return value of the method accurately reflects the number of bytes that have been written to the head of the buffer.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 器只能调用此方法，以确保它们不会从传递给 &lt;code&gt;Read&lt;/code&gt; 方法的缓冲区中读取，并且该方法的返回值准确地反映了已写入缓冲区头部的字节数。</target>
        </trans-unit>
        <trans-unit id="14a8a7c42cf833272747226b7446d6fe81b3ec47" translate="yes" xml:space="preserve">
          <source>This may require additional type hints in the function body.</source>
          <target state="translated">这可能需要在功能体中增加类型提示。</target>
        </trans-unit>
        <trans-unit id="ac8b21b0f73b2747acf512efef8390bcec866c71" translate="yes" xml:space="preserve">
          <source>This means iterator adapters can rely on the source not changing during iteration but they cannot rely on it in their Drop implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07ba109060bf875c034ba50fdb9ffdabfec4929" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all permitted.</source>
          <target state="translated">这意味着 &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 都被允许。</target>
        </trans-unit>
        <trans-unit id="7a8c1c98c2b07fe7a77662bf8cf1e31aa75a3d05" translate="yes" xml:space="preserve">
          <source>This means that any external crate referencing &lt;code&gt;implementation::api::f&lt;/code&gt; would receive a privacy violation, while the path &lt;code&gt;api::f&lt;/code&gt; would be allowed.</source>
          <target state="translated">这意味着引用 &lt;code&gt;implementation::api::f&lt;/code&gt; 任何外部板条箱都会收到隐私侵犯，而允许使用路径 &lt;code&gt;api::f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be2e4dfa333e1a56bbed2f9ca40e5f02293eda70" translate="yes" xml:space="preserve">
          <source>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</source>
          <target state="translated">这意味着,可能前面的一些模式太过笼统,这个模式太过具体,或者顺序不对。</target>
        </trans-unit>
        <trans-unit id="3a6a30f5c049c4edc23b7fd66710a9051982b10a" translate="yes" xml:space="preserve">
          <source>This means that someone can specify such a function:</source>
          <target state="translated">这意味着,有人可以指定这样一个功能。</target>
        </trans-unit>
        <trans-unit id="cb26a69e23fbbf1b07ba0d9979e852887a91fd3d" translate="yes" xml:space="preserve">
          <source>This means that the contents of the first string above &lt;em&gt;will&lt;/em&gt; fit into a &lt;code&gt;char&lt;/code&gt; while the contents of the second string &lt;em&gt;will not&lt;/em&gt;. Trying to create a &lt;code&gt;char&lt;/code&gt; literal with the contents of the second string gives an error:</source>
          <target state="translated">这意味着上面第一个字符串的内容&lt;em&gt;将&lt;/em&gt;适合 &lt;code&gt;char&lt;/code&gt; ,而第二个字符串的内容&lt;em&gt;将不&lt;/em&gt;适合。尝试使用第二个字符串的内容创建 &lt;code&gt;char&lt;/code&gt; 文字会产生错误：</target>
        </trans-unit>
        <trans-unit id="f9131c9dc6b963db63fbff2769fe5ceda6bacdcc" translate="yes" xml:space="preserve">
          <source>This means that the operands don't have to be moved out of.</source>
          <target state="translated">这意味着操作数不必移出。</target>
        </trans-unit>
        <trans-unit id="b2ca51239acb100a6dd5efb03e14c814a0a94286" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;s&lt;/code&gt; reaches the end of &lt;code&gt;demo&lt;/code&gt;, its destructor gets exclusive access to its &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrowed string data. allowing another borrow of that string data (&lt;code&gt;p&lt;/code&gt;), to exist across the drop of &lt;code&gt;s&lt;/code&gt; would be a violation of the principle that &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrows have exclusive, unaliased access to their referenced data.</source>
          <target state="translated">这意味着，当 &lt;code&gt;s&lt;/code&gt; 到达 &lt;code&gt;demo&lt;/code&gt; 的末尾时，其析构函数将获得对其 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 借入的字符串数据的独占访问权。允许在 &lt;code&gt;s&lt;/code&gt; 的整个液滴中再次存在该字符串数据（ &lt;code&gt;p&lt;/code&gt; ）的借项，将违反 &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrows对其引用数据具有独占，非混淆访问的原则。</target>
        </trans-unit>
        <trans-unit id="9b50029fc42e472fbad4bc857af78f98f36c748f" translate="yes" xml:space="preserve">
          <source>This means that, for example, the padding byte in &lt;code&gt;(u8, u16)&lt;/code&gt; is not necessarily zeroed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382ebf724244bccd694c658a6e7769ce6b7c071d" translate="yes" xml:space="preserve">
          <source>This means, that in addition to &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a != b&lt;/code&gt; being strict inverses, the equality must be (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">这意味着，除了 &lt;code&gt;a == b&lt;/code&gt; 和 &lt;code&gt;a != b&lt;/code&gt; 是严格的逆之外，等式还必须是（对于所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="30330510a00e9290fc18b35d20dbe32f6afe0cd7" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;false&lt;/code&gt; after iteration has finished:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cb7c4ca14739fd7d110ae41517acd9e412a5c2" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">这个方法本身是安全的,但正确使用它需要格外小心。另一个线程可以在任何时候改变强计数,包括可能在调用这个方法和对结果采取行动之间。</target>
        </trans-unit>
        <trans-unit id="949f62fcaa7fc2070951a1bf81357a1eb29cd126" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">这个方法本身是安全的,但正确使用它需要格外小心。另一个线程可以在任何时候改变弱点计数,包括可能在调用这个方法和对结果采取行动之间。</target>
        </trans-unit>
        <trans-unit id="3282baf6619178b04f6e093d59df95e6b50b4f0b" translate="yes" xml:space="preserve">
          <source>This method can be used for string data that is &lt;em&gt;terminated&lt;/em&gt;, rather than &lt;em&gt;separated&lt;/em&gt; by a pattern.</source>
          <target state="translated">此方法可用于&lt;em&gt;终止的&lt;/em&gt;字符串数据，而不用模式&lt;em&gt;分隔&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3369ccac8ace2a653ec652b1d0a5f9f1bd24f346" translate="yes" xml:space="preserve">
          <source>This method can be used to reverse a comparison:</source>
          <target state="translated">此方法可用于反向比较。</target>
        </trans-unit>
        <trans-unit id="9f13cbe122409bed70a7bfa8652dd2b252fa340b" translate="yes" xml:space="preserve">
          <source>This method can be useful for situations in which the vector is serving as a buffer for other code, particularly over FFI:</source>
          <target state="translated">这种方法对于向量作为其他代码的缓冲区的情况很有用,特别是在FFI上。</target>
        </trans-unit>
        <trans-unit id="ce975c1398d44efbe8c10a5c85f55c0075a45068" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire byte slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">只有当整个字节分片被成功写入时,本方法才能成功,直到所有数据被写入或出现错误,本方法才会返回。</target>
        </trans-unit>
        <trans-unit id="e42e806090a8aa6caab77166483a1eda09b5296d" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire string slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f7d3cdb0bfa41dd91aa3d1bf03416a16ee48f3" translate="yes" xml:space="preserve">
          <source>This method differs from &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data. Compared with &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, this function has two failure cases instead of one (one for disconnection, one for a full buffer).</source>
          <target state="translated">此方法不同于&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;，如果通道的缓冲区已满或没有接收器正在等待获取某些数据，则立即返回。与&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;相比，此函数有两种故障情况，而不是一种（一种情况是断开连接，一种情况是完整的缓冲区）。</target>
        </trans-unit>
        <trans-unit id="028002d34f3fafd7bc54cd77bcaa912497a3b074" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; pass ownership of the raw file descriptor to the caller. The descriptor is only guaranteed to be valid while the original object has not yet been destroyed.</source>
          <target state="translated">这个方法并&lt;strong&gt;没有&lt;/strong&gt;将原始文件描述符给调用者的所有权。仅当原始对象尚未销毁时，才保证描述符是有效的。</target>
        </trans-unit>
        <trans-unit id="5fd9fa51612a49edd496cd80117e23b29a509eb6" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by microseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one million).</source>
          <target state="translated">这种方法并&lt;strong&gt;没有&lt;/strong&gt;在由微秒表示返回的持续时间的长度。返回的数字始终表示秒的小数部分（即，小于一百万）。</target>
        </trans-unit>
        <trans-unit id="d3a3c1cf0cc150bd1c72971205d2190e708b8d2b" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by milliseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one thousand).</source>
          <target state="translated">这种方法并&lt;strong&gt;没有&lt;/strong&gt;在由毫秒表示返回的持续时间的长度。返回的数字始终代表秒的小数部分（即，小于一千）。</target>
        </trans-unit>
        <trans-unit id="e8135547d5a3a3a5006fe1cbd5d76d770ff2a7a9" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by nanoseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one billion).</source>
          <target state="translated">这种方法并&lt;strong&gt;没有&lt;/strong&gt;在由纳秒表示返回的持续时间的长度。返回的数字始终代表秒的小数部分（即，小于十亿）。</target>
        </trans-unit>
        <trans-unit id="ac2e63056cc906cac74875b70f6f9009af31f73d" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort a deque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc4e2ef2ed35366fa011a172b72477b2d16bbd4" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort or binary search a deque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f6f5d172fff1f1f8e9b8bb728e19c58e51b4b5" translate="yes" xml:space="preserve">
          <source>This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and &lt;em&gt;not&lt;/em&gt; write something like this:</source>
          <target state="translated">该方法不会产生值，但是写入可能会失败。处理错误情况，而&lt;em&gt;不要&lt;/em&gt;编写类似以下内容至关重要：</target>
        </trans-unit>
        <trans-unit id="0b024448d5d7228119631ad22266fba4066f9577" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;ExactSizeIterator::len()&lt;/code&gt;&lt;/a&gt;, so you don't need to implement it yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803e98a2b6e5f0d6a98c75881fdb55c1597f80f0" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;code&gt;self.len()&lt;/code&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">此方法具有使用 &lt;code&gt;self.len()&lt;/code&gt; 的默认实现，因此您无需自己实现。</target>
        </trans-unit>
        <trans-unit id="02fc3c4c098f9a864e6c45270c0a8ae6ffc408ef" translate="yes" xml:space="preserve">
          <source>This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">此方法具有默认实现，因此通常不应直接实现它。但是，如果您可以提供更有效的实现，则可以这样做。请参阅&lt;a href=&quot;trait.exactsizeiterator&quot;&gt;特征级&lt;/a&gt;文档以获取示例。</target>
        </trans-unit>
        <trans-unit id="89f3649aa28c1d3c90be74ebfb70d517cce77458" translate="yes" xml:space="preserve">
          <source>This method has no purpose when either input element &lt;code&gt;T&lt;/code&gt; or output element &lt;code&gt;U&lt;/code&gt; are zero-sized and will return the original slice without splitting anything.</source>
          <target state="translated">当输入元素 &lt;code&gt;T&lt;/code&gt; 或输出元素 &lt;code&gt;U&lt;/code&gt; 的大小为零时，此方法无用，并且将返回原始切片而不拆分任何内容。</target>
        </trans-unit>
        <trans-unit id="08ef0643ebf0dc48a599dc8d5b289675edb9e0a3" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d2a8db1a00abc88d21d10b6113bf279aaebd51" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;std::mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">当值超出范围时，将隐式调用此方法，并且无法显式调用此方法（这是编译器错误&lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;）。但是，前奏中的&lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;std::mem::drop&lt;/code&gt; &lt;/a&gt;函数可用于调用参数的 &lt;code&gt;Drop&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="0b2c9d3aaaa76ea8e330a8973b644085bc25e3bb" translate="yes" xml:space="preserve">
          <source>This method is carefully constructed to avoid allocation. It will consume the error, moving out the bytes, so that a copy of the bytes does not need to be made.</source>
          <target state="translated">这种方法是精心构造的,以避免分配。它将消耗错误,移出字节,这样就不需要对字节进行复制。</target>
        </trans-unit>
        <trans-unit id="ef9d0891851c4c2229a94b62e2e2cf59a2fd15db" translate="yes" xml:space="preserve">
          <source>This method is deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84886aa1dad1934a5c9bdd981667f36e45fab018" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">此方法与&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;等效，除了不进行任何运行时声明，即 &lt;code&gt;v&lt;/code&gt; 不包含0字节，并且它需要实际的字节向量，而不是可以使用Into转换为1的任何东西。</target>
        </trans-unit>
        <trans-unit id="38f2c8e8e67faa398a8a8adc0a46e90cd363606b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0358b021b2254c197a04c16c02e67b7c9901af56" translate="yes" xml:space="preserve">
          <source>This method is essentially a &lt;code&gt;transmute&lt;/code&gt; with respect to the elements in the returned middle slice, so all the usual caveats pertaining to &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; also apply here.</source>
          <target state="translated">该方法本质上是一个 &lt;code&gt;transmute&lt;/code&gt; 相对于在返回的中间片的元件，因此，所有属于通常的告诫 &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; 也适用于此。</target>
        </trans-unit>
        <trans-unit id="dd229ccab2f3fea46c41c098065dd891d877a2e6" translate="yes" xml:space="preserve">
          <source>This method is identical to &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt;, except for the relaxed lifetime bounds, which render it unsafe. For a more complete documentation see &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法与&lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt;相同，除了宽松的生存期限制（使生存期变得不安全）。有关更完整的文档，请参见&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bc2506b00444cfc62462ac1af4908c0bbe44456" translate="yes" xml:space="preserve">
          <source>This method is implemented using up to three seek operations. If this method returns successfully, the seek position is unchanged (i.e. the position before calling this method is the same as afterwards). However, if this method returns an error, the seek position is unspecified.</source>
          <target state="translated">本方法最多使用三个寻求操作来实现。如果本方法成功返回,则寻求位置不变(即调用本方法之前的位置与之后的位置相同)。但是,如果本方法返回错误,则寻求的位置是不指定的。</target>
        </trans-unit>
        <trans-unit id="f531cfc3a2c409d73bd0f5c2e2364c282b1a69bd" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired. &lt;code&gt;Drop&lt;/code&gt; will be invoked on the returned value following normal end-of-scope rules.</source>
          <target state="translated">此方法主要用于移出液滴中的值。您可以使用此方法获取值并根据需要使用它，而不是使用&lt;a href=&quot;#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt;来手动删除该值。遵循正常范围终止规则，将对返回的值调用 &lt;code&gt;Drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff2d30c02e4e3426a2eb2e0e84eb302b53b0327c" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923fe0c4f9dba0ad8dc8e37a00ed66b6a9da0759" translate="yes" xml:space="preserve">
          <source>This method is primarily used to interface with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro, but it is rare that this should explicitly be called. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro should be favored to invoke this method instead.</source>
          <target state="translated">此方法主要用于与&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;接口！宏，但是很少需要显式调用它。在&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;应该偏爱使用宏来调用此方法。</target>
        </trans-unit>
        <trans-unit id="80fc60d5306ac7d19519f64033eaf35397e48023" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法已被软弃用。&lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e4625fa8bf128959917fb79c2180bb0bb7de232" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法已被软弃用。&lt;a href=&quot;../error/trait.error#method.description&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a9beb6c54e6c8b198cf2df220314195725bd7bb" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法已被软弃用。&lt;a href=&quot;error/trait.error#method.description&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5490d12dcf25f9008acb9584a8ddf0c95e1664f2" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法稳定且可用，但不安全。为了解决这个问题，不赞成使用不安全的&lt;a href=&quot;#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a040da9f6f49ab3965186c9b54eab70d6aecfa7" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428465480a8425bf96628f818ad9aad9c7155318" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d24cf3a26d22530ab9cc10e498dc43f87c776a" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881a668b22b8af1fbfcb4abff65037dd8a73fd44" translate="yes" xml:space="preserve">
          <source>This method is unsafe because a &lt;code&gt;Read&lt;/code&gt;er could otherwise return a non-zeroing &lt;code&gt;Initializer&lt;/code&gt; from another &lt;code&gt;Read&lt;/code&gt; type without an &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">这种方法是不安全的，因为一个 &lt;code&gt;Read&lt;/code&gt; 呃否则可能返回非零 &lt;code&gt;Initializer&lt;/code&gt; 从另一个 &lt;code&gt;Read&lt;/code&gt; 类型没有 &lt;code&gt;unsafe&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="272d98e018b9a74f9a82d093db1b7d2de5f94a24" translate="yes" xml:space="preserve">
          <source>This method is useful when doing multiple calls to functions that consume the pinned type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b649b72cfd66bc53cdd1236dc499f467fbbbfc65" translate="yes" xml:space="preserve">
          <source>This method requires &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; to be able clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;#method.resize_with&quot;&gt;&lt;code&gt;resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法要求&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;能够克隆传递的值。如果您需要更大的灵活性（或者想要依靠&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;），请使用&lt;a href=&quot;#method.resize_with&quot;&gt; &lt;code&gt;resize_with&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe86d6b287ee66b5bfe82d8d97c6de5a30a28fea" translate="yes" xml:space="preserve">
          <source>This method requires &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, in order to be able to clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;struct.vec#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a3bfc3f1c3963b065d50d6828d4da511aead6e" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59bebec2345a5a01479f3be93783390bba5fe3b" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95f081db21ce8cf4e6f46e10880425784f2765c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">对于[RFC 4291第2.4节]保留的范围内的地址，此方法返回&lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt;，即具有以下格式的地址：</target>
        </trans-unit>
        <trans-unit id="14217d50c79e4eb45c163835b69cd4e673a45e20" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">根据&lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291第2.5.7节，&lt;/a&gt;此方法对站点本地地址返回&lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c067946f55e22970a3dc70591f782f7bfd3be70c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac7dcf5283432feb1c671ca5dfa7bc7104e0a1d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c542fa498c19ba50cecb51c023284b67bf89ad" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5bb928bae82aca5b2fc0bf565da6017cb0d4d8" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8678f0273a7a7e566a6f4ee8c92fbd30439ee626" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;Ok(())&lt;/code&gt; if the cell was empty and &lt;code&gt;Err(value)&lt;/code&gt; if it was full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe438568aa64ab40ad3ae63a4e80c06e5f2d121" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; after iteration has finished:</source>
          <target state="translated">迭代完成后，此方法返回 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a10727aefe2c0619a67b5c808cec5f4b8a1e7af5" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553b97aa02f0558b1b0de2b63742a555e1d788b0" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe70a42b371f1df3da8be36396abdc2eaf19453" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36badfc81f37e8dd9893bdb06702e1f5b7aef202" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c319c899ab4990e562735b3d21d0f6cd464c7156" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8759d1633206733343524980d7a489afd16956" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f3bbc3554d60688630609ad13846c405e876fac" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。&lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e875552f6e4025920ca5a71d7c281b1fbfaaa2a8" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。&lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="400399c6db28cb18bc3db2944eff105cd4fca3da" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。&lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a47b24f63b5fe410c6da12441f9c98d2fe17c15" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。&lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3cf087c16e29fe754de64f334036b96fe0b3931" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists.</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。</target>
        </trans-unit>
        <trans-unit id="eb17b52a796e0693ad06487790fde93b26d1d781" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。&lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39953b189e90eb45e12641b5213bac17fb6a067f" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。&lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a426df736d2450e1483768eb842876560c3cb8d7" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。&lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64233d3af8194ec0eefc11c727f80c62d14630a" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。&lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="edb583eeb291a512bd3d2447d1fbe080bc3b9dce" translate="yes" xml:space="preserve">
          <source>This method should generally not be invoked manually, but rather through the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro itself.</source>
          <target state="translated">通常不应手动调用此方法，而应通过&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;宏本身。</target>
        </trans-unit>
        <trans-unit id="d7174476c42e976c470e5d3d833837447fe7b624" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.</source>
          <target state="translated">这个方法将片子分割成三个不同的片子:前缀、新类型的正确对齐的中间片子和后缀片子。对于给定的类型和输入分片,该方法尽最大努力使中间分片的长度尽可能大,但只有你的算法的性能应该取决于此,而不是它的正确性。</target>
        </trans-unit>
        <trans-unit id="a7dca763f7ea1b34a0cad9b954868418d78e506c" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method may make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness. It is permissible for all of the input data to be returned as the prefix or suffix slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8000abb209a936f78ade63de708f2749dd5748c7" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">此方法测试 &lt;code&gt;!=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3639f2a22177e5f40d5314d575e638c54018960a" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="e3ea7ba813a098b9b6ae43b0aee731d0092913bf" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00abfa17fbf62bab913260c77c4736307dd6b08" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c257c51217cc2c43c24273fbc2f10164037dd5b1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34550195d18fa1542599bef9324d74efad99aeb1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d32084f8ce776d9a529be0f1da6ec9ca22e44396" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9893b74b381c1707e88afd0a7ed6401e06b38424" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。</target>
        </trans-unit>
        <trans-unit id="9be75e39e05fc52a961a6f8a30bebafa3abc619e" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b084733b90b43f4725bbd31294cb1f36404ce0a" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44184bc5bd845c73d3a6bdc521b7927b64cd5369" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eec657a4246dd487288b986e3d57dfd9657b208" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;trait.partialord#method.gt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0eabc442f100ec2b7e353c049aaaf4ca623d1f2c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator.</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。</target>
        </trans-unit>
        <trans-unit id="4194eb24934481036250e733ab18937ab48da677" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="219eec29ea3645fe37ee0a3de43c26a2abe5b61f" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7907168214aeaea1aa4db413b937e0f747bd41c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e579d59fed2657492555041f61545aa7206f59b6" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;trait.partialord#method.ge&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0e789163efc5086c683b5a1f62c9a3bb50e4538" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。</target>
        </trans-unit>
        <trans-unit id="a9a38093c98e8f8478fc7a4cb9a47c1ad908df47" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d167afca39913e71e4062a05ae7a9d99838896ab" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ebc7cc22118ac04d1f984d545d5be0d85818a1e" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54945ad3f8cac4a154fb7b9e35518b30ae999d4d" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;trait.partialord#method.lt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d161a6ff3e691349ec054ac0d4002d49a30e7893" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator.</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。</target>
        </trans-unit>
        <trans-unit id="aadf89f483a504081f46ca5ef3749d0af43a4387" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb1ab74197bbadea31b206cbb3f4c8f2c4d9f37" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db00fc514ef8b2e5769c8d739b13605dcfb91f42" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bca462ad1eb0c753d442b14b7fe002228f03d1ee" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;trait.partialord#method.le&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f2ae443e73d5f88ef06a1d6b529c7d18527f78a" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法使用&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;值在每次推送时创建新值。如果您希望&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;给定的值，请使用&lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1dc00be165ac3a4a63601e65e376c360363d264c" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ffc4fb20de54f6e75ded6f37d7e6542ba4dcb3" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">此方法使用闭包在每次推送时创建新值。如果您希望&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;给定的值，请使用&lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt;。如果要使用&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;特征来生成值，则可以将&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt;作为第二个参数传递。</target>
        </trans-unit>
        <trans-unit id="94cb38be3cc225054f996a63889a25410328f00e" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;Vec::resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8aba760b1e58965c26c5247df8d78a97a2b7d9" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f44223f055f4bc85ef6eebc9a26838b98e07df" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此方法将验证RFC中定义的格式，并且不会将以下地址（例如 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; &lt;code&gt;fe81::&lt;/code&gt; 或fe81：:）识别为单播本地链接地址。如果您需要不太严格的验证，请使用&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;is_unicast_link_local()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34a9aeb12096c73821e3d3f2146e3bcd68d312a7" translate="yes" xml:space="preserve">
          <source>This method will be deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">不推荐使用此方法，而应使用 &lt;code&gt;u8&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;[u8]&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 上同名的固有方法。</target>
        </trans-unit>
        <trans-unit id="71c3fa499cb951e39a31bf79d7f47ca94405dd75" translate="yes" xml:space="preserve">
          <source>This method will be removed soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab63bf4ac92d7a8265610c22503839aea1e5938" translate="yes" xml:space="preserve">
          <source>This method will block the calling thread if another initialization routine is currently running.</source>
          <target state="translated">如果当前正在运行另一个初始化例程,该方法将阻止调用线程。</target>
        </trans-unit>
        <trans-unit id="fd65ab04cca83f42050b2936debdcfa64855e2e3" translate="yes" xml:space="preserve">
          <source>This method will call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; repeatedly until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, returning the number of times it saw &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; has to be called at least once even if the iterator does not have any elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcd7df93995d5669f9a19d9090b19b5d2473592" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">此方法将连续调用&lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; ,&lt;/a&gt;直到没有更多数据要写入或返回非&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误为止。在成功写入整个缓冲区或发生此类错误之前，此方法将不会返回。从此方法生成的不是&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误将被返回。</target>
        </trans-unit>
        <trans-unit id="0bf4855a0328106cbe0baa3671aad93298aa630b" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">此方法将连续调用&lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; ,&lt;/a&gt;直到没有更多数据要写入或返回非&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误为止。在成功写入整个缓冲区或发生此类错误之前，此方法将不会返回。从此方法生成的不是&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误将被返回。</target>
        </trans-unit>
        <trans-unit id="34bd7dd9f2f6fd228fe4ece502dea492de39f939" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d4273ac7a3ba1d7a87ecc5115120efa61d6d44" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until all buffers have been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3edbd42d79d3d4c4b13caf2b0a59c3d785c0e55" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b531b20d0eb83c8a34e8a69001999cab52351ebf" translate="yes" xml:space="preserve">
          <source>This method will currently always return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, but this may change in future versions.</source>
          <target state="translated">该方法当前将始终返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;，但是在将来的版本中可能会更改。</target>
        </trans-unit>
        <trans-unit id="f5ce2db6ab8281674bdcae7d5e2f97235788a1d6" translate="yes" xml:space="preserve">
          <source>This method will eagerly skip &lt;code&gt;n&lt;/code&gt; elements by calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; up to &lt;code&gt;n&lt;/code&gt; times until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2170c54e7e7e211e3d0e2c65e377ae8bcaea7ac1" translate="yes" xml:space="preserve">
          <source>This method will ensure that any current waiters on the condition variable are awoken. Calls to &lt;code&gt;notify_all()&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">此方法将确保唤醒条件变量上的所有当前侍者。不会以任何方式缓冲对 &lt;code&gt;notify_all()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="149968b75a735130b9e849f252f39d4aeeb3370e" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until it returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. While doing so, it keeps track of the current element. After &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned, &lt;code&gt;last()&lt;/code&gt; will then return the last element it saw.</source>
          <target state="translated">此方法将评估迭代器，直到返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;为止。这样做时，它会跟踪当前元素。后&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;返回， &lt;code&gt;last()&lt;/code&gt; 将回它看到最后一个元素。</target>
        </trans-unit>
        <trans-unit id="60132e29639954faf0b02a7c1a61ca490fca81f1" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until its &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Once &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, &lt;code&gt;count()&lt;/code&gt; returns the number of times it called &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法将评估迭代器，直到其&lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;为止。一旦遇到&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;count()&lt;/code&gt; 返回其调用&lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;的次数。</target>
        </trans-unit>
        <trans-unit id="430231e1c82b4b198abc958a7fd105f7b17a6eb0" translate="yes" xml:space="preserve">
          <source>This method will fail if the socket is not connected. The &lt;code&gt;connect&lt;/code&gt; method will connect this socket to a remote address.</source>
          <target state="translated">如果未连接套接字，此方法将失败。该 &lt;code&gt;connect&lt;/code&gt; 方法此套接字连接到远程地址。</target>
        </trans-unit>
        <trans-unit id="99d3a71bbe68b832fc3370a5188434c797f36ae5" translate="yes" xml:space="preserve">
          <source>This method will never block the caller in order to wait for data to become available. Instead, this will always return immediately with a possible option of pending data on the channel.</source>
          <target state="translated">这个方法永远不会为了等待数据可用而阻止调用者。相反,它总是会立即返回一个可能的通道上的待处理数据的选项。</target>
        </trans-unit>
        <trans-unit id="cbdaac7e9262e1ca34c4fe476a690d8dd791b78c" translate="yes" xml:space="preserve">
          <source>This method will never block the current thread.</source>
          <target state="translated">此方法永远不会阻止当前线程。</target>
        </trans-unit>
        <trans-unit id="46d2c9fdd8f22af9ddb09186941e568038365eb2" translate="yes" xml:space="preserve">
          <source>This method will panic if result is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">如果结果不是有限的，负的或 &lt;code&gt;Duration&lt;/code&gt; 上限，则此方法将出现恐慌。</target>
        </trans-unit>
        <trans-unit id="361fc3f209ee1e7f236b4d7adeffb54823eee70f" translate="yes" xml:space="preserve">
          <source>This method will take care to not copy the vector, for efficiency's sake.</source>
          <target state="translated">这个方法为了提高效率,会注意不要复制矢量。</target>
        </trans-unit>
        <trans-unit id="086f7043b4f8a7fd4a6336d78995f0e85e9d5744" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;key&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6fca229e267292b225ded4f3ea56dd1917d4dd" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;value&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bda4a4da4275b96ba5bd1843478dd37908d7e9" translate="yes" xml:space="preserve">
          <source>This module also provides an implementation of thread-local storage for Rust programs. Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized.</source>
          <target state="translated">本模块还提供了Rust程序的线程本地存储的实现。线程本地存储是一种将数据存储到全局变量中的方法,程序中的每个线程都有自己的副本。线程不共享这些数据,所以访问不需要同步。</target>
        </trans-unit>
        <trans-unit id="a618e47bcd778e6fbdbebc05ca474e36092d34bf" translate="yes" xml:space="preserve">
          <source>This module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of &lt;code&gt;std::os::$platform&lt;/code&gt;.</source>
          <target state="translated">这个模块包含基本方法来操纵本地文件系统的内容。该模块中的所有方法均表示跨平台文件系统操作。在 &lt;code&gt;std::os::$platform&lt;/code&gt; 的扩展特性中可以找到特定于平台的其他功能。</target>
        </trans-unit>
        <trans-unit id="facf45454888eb2d77ede3ccdd2076d5cf487a0e" translate="yes" xml:space="preserve">
          <source>This module contains functions for querying the size and alignment of types, initializing and manipulating memory.</source>
          <target state="translated">这个模块包含了查询类型的大小和对齐方式、初始化和操作内存的函数。</target>
        </trans-unit>
        <trans-unit id="2408b577206af618721c013114d9c06e429f800a" translate="yes" xml:space="preserve">
          <source>This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories.</source>
          <target state="translated">该模块包含了检查环境变量、进程参数、当前目录和其他各种重要目录等各个方面的函数。</target>
        </trans-unit>
        <trans-unit id="493f5d09dd437f62e48924cee92d925e5c7d2ef1" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, a trait for converting &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt;s, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">此模块包含&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;类型，转换&lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt;的特征以及使用&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;可能导致的几种错误类型。</target>
        </trans-unit>
        <trans-unit id="0a09e5de88124067a8f4a272146af1f58ce6f16e" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, the &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt; trait for converting to strings, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15bad5d969fcb97693f6f0bc38018fba7343164" translate="yes" xml:space="preserve">
          <source>This module contains the runtime support for the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings.</source>
          <target state="translated">该模块包含对&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;的运行时支持！语法扩展。该宏在编译器中实现，以发出对该模块的调用，以便在运行时将参数格式化为字符串。</target>
        </trans-unit>
        <trans-unit id="12f15aefb562d878bda21e27716658fa02862f93" translate="yes" xml:space="preserve">
          <source>This module contains the support necessary to capture a stack backtrace of a running OS thread from the OS thread itself. The &lt;code&gt;Backtrace&lt;/code&gt; type supports capturing a stack trace via the &lt;code&gt;Backtrace::capture&lt;/code&gt; and &lt;code&gt;Backtrace::force_capture&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe75678b9da36500f1155d5a63660783d7b96c49" translate="yes" xml:space="preserve">
          <source>This module contains various tools for ordering and comparing values. In summary:</source>
          <target state="translated">该模块包含各种排序和比较值的工具。总的来说:</target>
        </trans-unit>
        <trans-unit id="5526cfdf674b75dda2276399dbf95bab9061f815" translate="yes" xml:space="preserve">
          <source>This module defines atomic versions of a select number of primitive types, including &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicisize&quot;&gt;&lt;code&gt;AtomicIsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicusize&quot;&gt;&lt;code&gt;AtomicUsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomici8&quot;&gt;&lt;code&gt;AtomicI8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicu16&quot;&gt;&lt;code&gt;AtomicU16&lt;/code&gt;&lt;/a&gt;, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</source>
          <target state="translated">该模块定义了一些基本类型的原子版本，包括&lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.atomicisize&quot;&gt; &lt;code&gt;AtomicIsize&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.atomicusize&quot;&gt; &lt;code&gt;AtomicUsize&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.atomici8&quot;&gt; &lt;code&gt;AtomicI8&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.atomicu16&quot;&gt; &lt;code&gt;AtomicU16&lt;/code&gt; &lt;/a&gt;等。原子类型提供了一些操作，当正确使用这些操作时，它们将在线程之间同步更新。</target>
        </trans-unit>
        <trans-unit id="69b6d67047755d0189ccf8e0dd69886ba1af9f48" translate="yes" xml:space="preserve">
          <source>This module exists for technical reasons, the primary documentation for &lt;code&gt;char&lt;/code&gt; is directly on &lt;a href=&quot;../primitive.char&quot;&gt;the &lt;code&gt;char&lt;/code&gt; primitive type&lt;/a&gt; itself.</source>
          <target state="translated">此模块存在技术上的原因，对主文档 &lt;code&gt;char&lt;/code&gt; 是直接在&lt;a href=&quot;../primitive.char&quot;&gt;所述 &lt;code&gt;char&lt;/code&gt; 基元类型&lt;/a&gt;本身。</target>
        </trans-unit>
        <trans-unit id="0c05c40f88eef085aa06e135cdea7a637a633c60" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;Any&lt;/code&gt; trait, which enables dynamic typing of any &lt;code&gt;'static&lt;/code&gt; type through runtime reflection.</source>
          <target state="translated">该模块实现了 &lt;code&gt;Any&lt;/code&gt; 特征，该特征允许通过运行时反射来动态键入任何 &lt;code&gt;'static&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="a2779c978566f8d66cd98dfb5457c45d53a57fb6" translate="yes" xml:space="preserve">
          <source>This module is largely organized by type:</source>
          <target state="translated">本模块主要是按类型组织的。</target>
        </trans-unit>
        <trans-unit id="5be07f93f33ed08d424575dcac18854b8631d380" translate="yes" xml:space="preserve">
          <source>This module is mostly concerned with spawning and interacting with child processes, but it also provides &lt;a href=&quot;fn.abort&quot;&gt;&lt;code&gt;abort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.exit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; for terminating the current process.</source>
          <target state="translated">此模块主要与产生和与子进程交互有关，但它也提供&lt;a href=&quot;fn.abort&quot;&gt; &lt;code&gt;abort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.exit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt;以终止当前进程。</target>
        </trans-unit>
        <trans-unit id="288daae4ba933c2cf1c52332e7aec01da8baaf15" translate="yes" xml:space="preserve">
          <source>This module is the home of the iterator implementations for the iterators implemented on &lt;code&gt;char&lt;/code&gt;, as well as some useful constants and conversion functions that convert various types to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">该模块是在 &lt;code&gt;char&lt;/code&gt; 上实现的迭代器的迭代器实现的宿主，以及一些有用的常量和将各种类型转换为 &lt;code&gt;char&lt;/code&gt; 的转换函数。</target>
        </trans-unit>
        <trans-unit id="55568ed1c38eacf7d09bc4bc93efa4b457d73318" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;Permissions::readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16223be8f664aa8af7792fdf4f8c15d5b579360d" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">该模块当前仅提供一点信息&lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt;，该信息在所有当前支持的平台上公开。通过&lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt;特性可以使用特定于Unix的功能，例如模式位。</target>
        </trans-unit>
        <trans-unit id="72abc30b878e9efe98c4c560589176b50cfcfb02" translate="yes" xml:space="preserve">
          <source>This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use &lt;code&gt;#[derive(Hash)]&lt;/code&gt;:</source>
          <target state="translated">该模块提供了一种通用的方法来计算值的哈希值。使类型可 &lt;code&gt;#[derive(Hash)]&lt;/code&gt; 的最简单方法是使用＃[derive（Hash）]：</target>
        </trans-unit>
        <trans-unit id="8f6357e74fc7527ed8e55102f82ccb8843f20d51" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f32&lt;/code&gt; floating point data type.</source>
          <target state="translated">该模块提供特定于 &lt;code&gt;f32&lt;/code&gt; 浮点数据类型实现的常量。</target>
        </trans-unit>
        <trans-unit id="87f0d2ad3a049e2ea757e82944e2e6b1d2f310c4" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f64&lt;/code&gt; floating point data type.</source>
          <target state="translated">该模块提供特定于 &lt;code&gt;f64&lt;/code&gt; 浮点数据类型的实现的常量。</target>
        </trans-unit>
        <trans-unit id="4dd1d432064e6f3e28ac8c1d81caf06446f388ba" translate="yes" xml:space="preserve">
          <source>This module provides message-based communication over channels, concretely defined among three types:</source>
          <target state="translated">该模块提供基于消息的通道通信,具体定义为三种类型。</target>
        </trans-unit>
        <trans-unit id="bfedf6f4f14d905a894526b273dfe17f7e7c03dc" translate="yes" xml:space="preserve">
          <source>This module provides networking functionality for the Transmission Control and User Datagram Protocols, as well as types for IP and socket addresses.</source>
          <target state="translated">该模块提供了传输控制和用户数据报协议的联网功能,以及IP和套接字地址的类型。</target>
        </trans-unit>
        <trans-unit id="fcfa8dfe7aed9682173752b15b6103829ea655a1" translate="yes" xml:space="preserve">
          <source>This module provides some extra types that are useful when doing numerical work. See the individual documentation for each piece for more information.</source>
          <target state="translated">这个模块提供了一些额外的类型,在进行数值工作时很有用。更多信息请参见每个模块的文档。</target>
        </trans-unit>
        <trans-unit id="b42dc453d74574a22f838766ed6a6210b7719f9b" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">该模块提供了两种类型，&lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;（类似于&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;），用于抽象地处理路径。这些类型分别是&lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 的&lt;/a&gt;瘦包装器，这意味着它们根据本地平台的路径语法直接在字符串上工作。</target>
        </trans-unit>
        <trans-unit id="a9add5ffa74ddef61504588ae8fe02f3fc02034e" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fe72f6bcf1faf654e10546253a992773369d18" translate="yes" xml:space="preserve">
          <source>This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.</source>
          <target state="translated">这个模块提供了处理非Rust接口数据的实用程序,比如其他编程语言和底层操作系统。它主要用于FFI(Foreign Function Interface)绑定和需要与其他语言交换类似C语言字符串的代码。</target>
        </trans-unit>
        <trans-unit id="523a58a1796e44e7bd8c46d95ef23447cedfbc5f" translate="yes" xml:space="preserve">
          <source>This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfbd1c67f1485adce8aa9ca96b08fda6c8d21af" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">该互斥锁将阻止线程等待锁可用。互斥锁也可以通过&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;构造函数进行静态初始化或创建。每个互斥锁都有一个类型参数，代表它要保护的数据。只能通过&lt;a href=&quot;#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;返回的RAII保护访问数据，这保证了只有互斥锁被锁定时才可以访问数据。</target>
        </trans-unit>
        <trans-unit id="37c35fdf98665e8061d3ede706452fcafbf6bf45" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;struct.mutex#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bb4ef8774a69f40318879a20a2f5485ae10af2" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f3b065f3863bd74d78c00a2522270062418669" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do O(n) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">这永远不需要重新分配,但如果循环缓冲区不恰好在分配的开始,则需要做O(n)数据移动。</target>
        </trans-unit>
        <trans-unit id="d28b87d734ed0d5315fcb74f17b2994ec84a38d2" translate="yes" xml:space="preserve">
          <source>This new slice goes from &lt;code&gt;begin&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;, including &lt;code&gt;begin&lt;/code&gt; but excluding &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">这种新的切片去从 &lt;code&gt;begin&lt;/code&gt; 到 &lt;code&gt;end&lt;/code&gt; ，包括 &lt;code&gt;begin&lt;/code&gt; ，但不包括 &lt;code&gt;end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5e5d3eaf75778ffc4640687e8cefa2e10e75497" translate="yes" xml:space="preserve">
          <source>This next example calls a supertrait method on a generic parameter.</source>
          <target state="translated">下面这个例子调用了一个通用参数上的supertrait方法。</target>
        </trans-unit>
        <trans-unit id="9f7ad17f03d80b97ecff41fe1815f8dca0918d1f" translate="yes" xml:space="preserve">
          <source>This next example gives &lt;code&gt;radius&lt;/code&gt; a default implementation using the &lt;code&gt;area&lt;/code&gt; function from &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">下一个示例使用 &lt;code&gt;Shape&lt;/code&gt; 中的 &lt;code&gt;area&lt;/code&gt; 函数为 &lt;code&gt;radius&lt;/code&gt; 提供默认实现。</target>
        </trans-unit>
        <trans-unit id="50d4d7072a1ea5b824d1df9626f273fc9c52a75a" translate="yes" xml:space="preserve">
          <source>This number is a lower bound; the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; might be able to hold more, but is guaranteed to be able to hold at least this many.</source>
          <target state="translated">此数字是一个下限；在 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 可能能够容纳更多的，但是保证能够容纳至少该许多。</target>
        </trans-unit>
        <trans-unit id="75625b78a6cc53054a38dc48c604ece0622bfe30" translate="yes" xml:space="preserve">
          <source>This number is simply useful for passing to other methods, like &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt;&lt;code&gt;OsString::with_capacity&lt;/code&gt;&lt;/a&gt; to avoid reallocations.</source>
          <target state="translated">此数字对于传递给其他方法（例如&lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt; &lt;code&gt;OsString::with_capacity&lt;/code&gt; &lt;/a&gt;以避免重新分配非常有用。</target>
        </trans-unit>
        <trans-unit id="1f022d625542e31d83b61a7cfb496898fc698f8a" translate="yes" xml:space="preserve">
          <source>This only differs from the previous &lt;code&gt;impl&lt;/code&gt; in that the parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;ForeignTrait2&lt;/code&gt; have been swapped. This example does &lt;em&gt;not&lt;/em&gt; violate the orphan rule; it is permitted.</source>
          <target state="translated">从以前这仅不同 &lt;code&gt;impl&lt;/code&gt; ，所述参数 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;ForeignTrait2&lt;/code&gt; 已经交换。这个例子并&lt;em&gt;没有&lt;/em&gt;违反规则的孤儿; 这是允许的。</target>
        </trans-unit>
        <trans-unit id="1833c0a27c1d09954fa6a057a5eb72b9706f31ec" translate="yes" xml:space="preserve">
          <source>This only includes environment variables explicitly set with &lt;a href=&quot;struct.command#method.env&quot;&gt;&lt;code&gt;Command::env&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.envs&quot;&gt;&lt;code&gt;Command::envs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.env_remove&quot;&gt;&lt;code&gt;Command::env_remove&lt;/code&gt;&lt;/a&gt;. It does not include environment variables that will be inherited by the child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123296246acbbeb137b9c0c76f971008749a56bb" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;fs::set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">此操作也&lt;strong&gt;不会&lt;/strong&gt;修改文件。要修改文件系统，请使用&lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;fs::set_permissions&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="7036bf2f2a1e56b239ac49dd49a90706f4ff18c2" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0bbc4d892938033fbacd4684ea2a287c924f8c" translate="yes" xml:space="preserve">
          <source>This operation is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">此操作为 &lt;code&gt;O(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd1a487434fc87832e2f1a787954854ff60dfa9b" translate="yes" xml:space="preserve">
          <source>This operation is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdec81639aa08f036b813714ac253cba45f17ed" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called 'reduce' or 'inject'.</source>
          <target state="translated">这种操作有时被称为 &quot;减少 &quot;或 &quot;注入&quot;。</target>
        </trans-unit>
        <trans-unit id="c8451edf8bf7bc5bb1bf0555fcc9a5705a25da14" translate="yes" xml:space="preserve">
          <source>This operation performs an unconditional mapping without tailoring. That is, the conversion is independent of context and language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fd1d86e77ef341cc160d32009392653fd89ec1" translate="yes" xml:space="preserve">
          <source>This operation rounds towards zero, truncating any fractional part of the exact result.</source>
          <target state="translated">这个操作向零进位,将精确结果的任何小数部分截断。</target>
        </trans-unit>
        <trans-unit id="77029037758bda804fd792f27ba1f29cea457a7e" translate="yes" xml:space="preserve">
          <source>This operation satisfies &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt;. The result has the same sign as the left operand.</source>
          <target state="translated">该运算满足 &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt; 。结果与左操作数的符号相同。</target>
        </trans-unit>
        <trans-unit id="bdbe7ca28eb7e43951e771605b8bd474b48c29e7" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time and &lt;em&gt;O&lt;/em&gt;(1) memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43df87c6439b0a85582f9e67d3c1fce146118f3d" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d494ef70142bea4ddf2b4f6d9f09545f47dd54e" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c9bdd59dbbaca42da37bc9d33eec68b2af8961" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time and O(1) memory.</source>
          <target state="translated">这个操作应该用O(1)时间和O(1)内存来计算。</target>
        </trans-unit>
        <trans-unit id="fc7c0f50f52c35ea7e364b7e26d103277ce95b38" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time.</source>
          <target state="translated">这个操作的计算时间应该是O(1)。</target>
        </trans-unit>
        <trans-unit id="a13a41f53da524732e21aa1da4b3958def62f00f" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(n) time.</source>
          <target state="translated">这个操作的计算时间应该是O(n)。</target>
        </trans-unit>
        <trans-unit id="4da5d428cc5f4bb1f1eadb7b45f2669f2c6be87e" translate="yes" xml:space="preserve">
          <source>This operation was interrupted.</source>
          <target state="translated">这个操作被打断了。</target>
        </trans-unit>
        <trans-unit id="e5b25bf34db3082fbebf881dd2f3b63132ce24a9" translate="yes" xml:space="preserve">
          <source>This operation wraps around on overflow.</source>
          <target state="translated">这个操作在溢出时环绕。</target>
        </trans-unit>
        <trans-unit id="513292ffc7d15c4c6459299bf349f4e8ef41bcc6" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此选项默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07732c105324f285891b421be7b1897cf45eb1a8" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created if the file does not yet already exist.</source>
          <target state="translated">这个选项表明,如果文件还不存在,是否会创建一个新的文件。</target>
        </trans-unit>
        <trans-unit id="2ab719a36168121ae6911773d2659e3887ae7b87" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created. No file is allowed to exist at the target location, also no (dangling) symlink.</source>
          <target state="translated">这个选项表示是否要创建一个新的文件,目标位置不允许有文件存在,也不允许有(悬空)符号链接。目标位置不允许存在任何文件,也不允许有(悬空的)符号链接。</target>
        </trans-unit>
        <trans-unit id="1997355865e9c95bba24957f07adb48aa7900b34" translate="yes" xml:space="preserve">
          <source>This option is useful because it is atomic. Otherwise between checking whether a file exists and creating a new one, the file may have been created by another process (a TOCTOU race condition / attack).</source>
          <target state="translated">这个选项很有用,因为它是原子性的。否则在检查文件是否存在和创建新文件之间,文件可能已经被另一个进程创建了(TOCTOU竞赛条件/攻击)。</target>
        </trans-unit>
        <trans-unit id="4d1d1f446736eda75bb94ad6c4911fc032b1110f" translate="yes" xml:space="preserve">
          <source>This option, when true, means that writes will append to a file instead of overwriting previous contents. Note that setting &lt;code&gt;.write(true).append(true)&lt;/code&gt; has the same effect as setting only &lt;code&gt;.append(true)&lt;/code&gt;.</source>
          <target state="translated">此选项为true时，表示写入将追加到文件，而不是覆盖先前的内容。请注意，设置 &lt;code&gt;.write(true).append(true)&lt;/code&gt; 它和设置只有相同的效果 &lt;code&gt;.append(true)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="279fd5d225ffc9cf4a6694f03d2272dc1973056a" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;read&lt;/code&gt;-able if opened.</source>
          <target state="translated">该选项为true时，表示如果打开该文件，则该文件应为 &lt;code&gt;read&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa691cde7b75893eb561d3865c9d79612f73f71" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;write&lt;/code&gt;-able if opened.</source>
          <target state="translated">该选项为true时，表示打开该文件应为可 &lt;code&gt;write&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="42af0ae9cc5372b7ccd519ad313f0abe9e0cfe15" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a load.</source>
          <target state="translated">该排序仅适用于可以执行负载的操作。</target>
        </trans-unit>
        <trans-unit id="20a3da5b9e12d0ccdf3e64c2e589466b4721fced" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a store.</source>
          <target state="translated">这种排序只适用于可以执行存储的操作。</target>
        </trans-unit>
        <trans-unit id="ea76b31c997f4d8a61f17e8560093311b945344f" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that combine both loads and stores.</source>
          <target state="translated">这种订购方式只适用于同时进行加载和存储的操作。</target>
        </trans-unit>
        <trans-unit id="a87804f30fcdf78425015d26ec12efca3e1a08c7" translate="yes" xml:space="preserve">
          <source>This output is better: we now have a reasonable error message. However, we also have extraneous information we don&amp;rsquo;t want to give to our users. Perhaps using the technique we used in Listing 9-10 isn&amp;rsquo;t the best to use here: a call to &lt;code&gt;panic!&lt;/code&gt; is more appropriate for a programming problem than a usage problem, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;as discussed in Chapter 9&lt;/a&gt;. Instead, we can use the other technique you learned about in Chapter 9&amp;mdash;&lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;returning a &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; that indicates either success or an error.</source>
          <target state="translated">输出更好：我们现在有一条合理的错误消息。但是，我们也有不想提供给用户的无关信息。也许使用清单9-10中使用的技术不是此处最好的使用：引起 &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;如第9章所述&lt;/a&gt;，比使用问题更适合编程问题。相反，我们可以使用你在第三章了解了其他技术的9- &lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;返回 &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;，表示成功或错误。</target>
        </trans-unit>
        <trans-unit id="04051f730c7eeba40e7dd9250f9fd3ae55f310b9" translate="yes" xml:space="preserve">
          <source>This output isn&amp;rsquo;t what we wanted. We want to call the &lt;code&gt;baby_name&lt;/code&gt; function that is part of the &lt;code&gt;Animal&lt;/code&gt; trait that we implemented on &lt;code&gt;Dog&lt;/code&gt; so the code prints &lt;code&gt;A baby dog is called a puppy&lt;/code&gt;. The technique of specifying the trait name that we used in Listing 19-18 doesn&amp;rsquo;t help here; if we change &lt;code&gt;main&lt;/code&gt; to the code in Listing 19-20, we&amp;rsquo;ll get a compilation error.</source>
          <target state="translated">此输出不是我们想要的。我们要调用 &lt;code&gt;baby_name&lt;/code&gt; 函数，该函数是我们在 &lt;code&gt;Dog&lt;/code&gt; 上实现的 &lt;code&gt;Animal&lt;/code&gt; 特质的一部分，因此代码可以打印出来 &lt;code&gt;A baby dog is called a puppy&lt;/code&gt; 。清单19-18中使用的指定特征名称的技术在这里没有帮助；如果将 &lt;code&gt;main&lt;/code&gt; 更改为清单19-20中的代码，则会收到编译错误。</target>
        </trans-unit>
        <trans-unit id="66b4788ea5425d4692dd1ffafd058fec8508d60c" translate="yes" xml:space="preserve">
          <source>This output shows &lt;code&gt;cargo test&lt;/code&gt; only ran the tests for the &lt;code&gt;add-one&lt;/code&gt; crate and didn&amp;rsquo;t run the &lt;code&gt;adder&lt;/code&gt; crate tests.</source>
          <target state="translated">此输出显示 &lt;code&gt;cargo test&lt;/code&gt; 只跑了测试 &lt;code&gt;add-one&lt;/code&gt; 箱子，并没有运行 &lt;code&gt;adder&lt;/code&gt; 箱测试。</target>
        </trans-unit>
        <trans-unit id="f91d4073e1806ac4e46d9be9407b7439ade530c5" translate="yes" xml:space="preserve">
          <source>This outputs:</source>
          <target state="translated">该产出:</target>
        </trans-unit>
        <trans-unit id="220a338b4d08066eba2a22fb127e73c40665ebcb" translate="yes" xml:space="preserve">
          <source>This overwrites pinned data, but that is okay: its destructor gets run before being overwritten, so no pinning guarantee is violated.</source>
          <target state="translated">这将覆盖被钉定的数据,但这没关系:在被覆盖之前,它的析构器会被运行,所以没有违反钉定保证。</target>
        </trans-unit>
        <trans-unit id="05caefb888af241727a56b286e8ae483a7d9633f" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">此页面记录了&lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;遵循规则的正式规范。它们最初是在&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550中&lt;/a&gt;指定的，从中复制了大部分文本，并在后续的RFC中进行了扩展。</target>
        </trans-unit>
        <trans-unit id="3b9633b5692298146f03a49947c6dcff6df1f7b9" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87b1d9607de86149c082e3d8de19453e0048df2" translate="yes" xml:space="preserve">
          <source>This pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we&amp;rsquo;ve allocated on the heap. Let&amp;rsquo;s explore some of those situations now.</source>
          <target state="translated">这种模式对Rust代码的编写方式有深远的影响。现在看来似乎很简单，但是在更复杂的情况下，当我们想让多个变量使用我们在堆上分配的数据时，代码的行为可能出乎意料。现在让我们探讨其中的一些情况。</target>
        </trans-unit>
        <trans-unit id="ebae1cd81adce77daea1f3e37e663633c554fab5" translate="yes" xml:space="preserve">
          <source>This pattern is about separating concerns: &lt;em&gt;main.rs&lt;/em&gt; handles running the program, and &lt;em&gt;lib.rs&lt;/em&gt; handles all the logic of the task at hand. Because you can&amp;rsquo;t test the &lt;code&gt;main&lt;/code&gt; function directly, this structure lets you test all of your program&amp;rsquo;s logic by moving it into functions in &lt;em&gt;lib.rs&lt;/em&gt;. The only code that remains in &lt;em&gt;main.rs&lt;/em&gt; will be small enough to verify its correctness by reading it. Let&amp;rsquo;s rework our program by following this process.</source>
          <target state="translated">这种模式是关于分离关注点的：&lt;em&gt;main.rs&lt;/em&gt;处理运行程序，而&lt;em&gt;lib.rs&lt;/em&gt;处理手头任务的所有逻辑。因为您不能直接测试 &lt;code&gt;main&lt;/code&gt; 函数，所以这种结构可以通过将其移至&lt;em&gt;lib.rs中的&lt;/em&gt;函数中&lt;em&gt;来&lt;/em&gt;测试程序的所有逻辑。保留在&lt;em&gt;main.rs中&lt;/em&gt;的唯一代码将足够小，可以通过读取代码来验证其正确性。让我们按照以下过程重做我们的程序。</target>
        </trans-unit>
        <trans-unit id="4f7fef1aec609824d9a98cbd4986f806fb8112f5" translate="yes" xml:space="preserve">
          <source>This pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">当这个模式的一个子模式是可以反驳的。</target>
        </trans-unit>
        <trans-unit id="8e7824ffc5e192a74a0014b97fd199a69a9bbad1" translate="yes" xml:space="preserve">
          <source>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator &lt;code&gt;?&lt;/code&gt; to make this easier.</source>
          <target state="translated">这种传播错误的模式在Rust中很常见，以至于Rust提供了问号运算符 &lt;code&gt;?&lt;/code&gt; 使它更容易。</target>
        </trans-unit>
        <trans-unit id="be8e420bedd2fafb3e2ace598d4c2a4fc61a219a" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its lowercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">它无需裁剪即可执行复杂的无条件映射：根据&lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode数据库&lt;/a&gt;和其他复杂映射&lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt;，将一个Unicode字符映射为其小写字母。这里不考虑条件映射（基于上下文或语言）。</target>
        </trans-unit>
        <trans-unit id="2bedef26ecd391020afcece167562372d74e3b11" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its uppercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">它无需剪裁即可执行复杂的无条件映射：根据&lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode数据库&lt;/a&gt;和其他复杂映射&lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt;，将一个Unicode字符映射为其大写形式。这里不考虑条件映射（基于上下文或语言）。</target>
        </trans-unit>
        <trans-unit id="367fd59cc7a5ce52d6910a709b90bfcbe81a7ab5" translate="yes" xml:space="preserve">
          <source>This piece of Rust history is relevant because it&amp;rsquo;s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.</source>
          <target state="translated">Rust的这段历史很重要，因为可能会出现更多确定性模式并将其添加到编译器中。将来，可能需要更少的生命周期注释。</target>
        </trans-unit>
        <trans-unit id="4d1e98917aa47fb301eb32dc85055855554e0b37" translate="yes" xml:space="preserve">
          <source>This pinned future is then polled by calling the &lt;a href=&quot;../../std/future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;Future::poll&lt;/code&gt;&lt;/a&gt; method and passing it the current &lt;a href=&quot;#task-context&quot;&gt;task context&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7cedc5fc51216f120f0eb8fae3379dc963620e" translate="yes" xml:space="preserve">
          <source>This prints output like:</source>
          <target state="translated">这就打印出了这样的输出。</target>
        </trans-unit>
        <trans-unit id="ff9f7a5e1d4525cd7d8438461ac9c53da48b455e" translate="yes" xml:space="preserve">
          <source>This prints to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;:</source>
          <target state="translated">打印到&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3c9f3b33a54ec1f8657331a04066cc462bed4e33" translate="yes" xml:space="preserve">
          <source>This problem can be solved by specifying from which trait we want to use the &lt;code&gt;Bar&lt;/code&gt; type:</source>
          <target state="translated">可以通过指定要使用 &lt;code&gt;Bar&lt;/code&gt; 类型的特征来解决此问题：</target>
        </trans-unit>
        <trans-unit id="fc4e53a566f64cd7b3bd5c8e48b6dab0075560d7" translate="yes" xml:space="preserve">
          <source>This process does not take into account the mutability or lifetime of the receiver, or whether a method is &lt;code&gt;unsafe&lt;/code&gt;. Once a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.</source>
          <target state="translated">此过程未考虑接收方的可变性或生存期，也未考虑方法是否 &lt;code&gt;unsafe&lt;/code&gt; 。查找方法后，如果由于一个或多个原因而无法调用该方法，则结果是编译器错误。</target>
        </trans-unit>
        <trans-unit id="1ff3edc7107794fccb9370413ce9f2edb3d33555" translate="yes" xml:space="preserve">
          <source>This process is just one of many ways to write software, but TDD can help drive code design as well. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.</source>
          <target state="translated">这个过程只是编写软件的众多方法之一,但TDD也可以帮助推动代码设计。在编写使测试通过的代码之前,先编写测试,有助于在整个过程中保持较高的测试覆盖率。</target>
        </trans-unit>
        <trans-unit id="2a5870cc6149419aa4b701948d1d720f8c2eb21c" translate="yes" xml:space="preserve">
          <source>This program compiles without any errors and would also do so if we used &lt;code&gt;word&lt;/code&gt; after calling &lt;code&gt;s.clear()&lt;/code&gt;. Because &lt;code&gt;word&lt;/code&gt; isn&amp;rsquo;t connected to the state of &lt;code&gt;s&lt;/code&gt; at all, &lt;code&gt;word&lt;/code&gt; still contains the value &lt;code&gt;5&lt;/code&gt;. We could use that value &lt;code&gt;5&lt;/code&gt; with the variable &lt;code&gt;s&lt;/code&gt; to try to extract the first word out, but this would be a bug because the contents of &lt;code&gt;s&lt;/code&gt; have changed since we saved &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">该程序的编译没有任何错误，如果我们在调用 &lt;code&gt;s.clear()&lt;/code&gt; 之后使用 &lt;code&gt;word&lt;/code&gt; ，也可以这样做。因为 &lt;code&gt;word&lt;/code&gt; 根本不连接到 &lt;code&gt;s&lt;/code&gt; 的状态，所以 &lt;code&gt;word&lt;/code&gt; 仍然包含值 &lt;code&gt;5&lt;/code&gt; 。我们可以将值 &lt;code&gt;5&lt;/code&gt; 与变量 &lt;code&gt;s&lt;/code&gt; 一起使用以尝试提取第一个单词，但这将是一个错误，因为自从我们在 &lt;code&gt;word&lt;/code&gt; 中保存 &lt;code&gt;5&lt;/code&gt; 以来 &lt;code&gt;s&lt;/code&gt; 的内容已更改。</target>
        </trans-unit>
        <trans-unit id="a1a216c5bb2240db271ccf5242339067640e2983" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their index. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">该程序创建一个元组 &lt;code&gt;x&lt;/code&gt; ，然后使用它们的索引为每个元素创建新变量。与大多数编程语言一样，元组中的第一个索引为0。</target>
        </trans-unit>
        <trans-unit id="a953795409deaf59d9e6550cf24f5329cf86ee13" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their respective indices. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052f0899e565e8d2644e743be0e56bf26e6e1767" translate="yes" xml:space="preserve">
          <source>This program first binds &lt;code&gt;x&lt;/code&gt; to a value of &lt;code&gt;5&lt;/code&gt;. Then it shadows &lt;code&gt;x&lt;/code&gt; by repeating &lt;code&gt;let x =&lt;/code&gt;, taking the original value and adding &lt;code&gt;1&lt;/code&gt; so the value of &lt;code&gt;x&lt;/code&gt; is then &lt;code&gt;6&lt;/code&gt;. The third &lt;code&gt;let&lt;/code&gt; statement also shadows &lt;code&gt;x&lt;/code&gt;, multiplying the previous value by &lt;code&gt;2&lt;/code&gt; to give &lt;code&gt;x&lt;/code&gt; a final value of &lt;code&gt;12&lt;/code&gt;. When we run this program, it will output the following:</source>
          <target state="translated">该程序首先将 &lt;code&gt;x&lt;/code&gt; 绑定为 &lt;code&gt;5&lt;/code&gt; 。然后，它阴影 &lt;code&gt;x&lt;/code&gt; 通过重复 &lt;code&gt;let x =&lt;/code&gt; ，取原始值和添加 &lt;code&gt;1&lt;/code&gt; 这样的值 &lt;code&gt;x&lt;/code&gt; 是则 &lt;code&gt;6&lt;/code&gt; 。第三个 &lt;code&gt;let&lt;/code&gt; 语句也将 &lt;code&gt;x&lt;/code&gt; 遮盖起来，将先前的值乘以 &lt;code&gt;2&lt;/code&gt; 得到 &lt;code&gt;x&lt;/code&gt; 的最终值为 &lt;code&gt;12&lt;/code&gt; 。当我们运行该程序时，它将输出以下内容：</target>
        </trans-unit>
        <trans-unit id="e37eff19d0df592c13224ef2e32fd74387b55f9e" translate="yes" xml:space="preserve">
          <source>This program first creates a tuple and binds it to the variable &lt;code&gt;tup&lt;/code&gt;. It then uses a pattern with &lt;code&gt;let&lt;/code&gt; to take &lt;code&gt;tup&lt;/code&gt; and turn it into three separate variables, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. This is called &lt;em&gt;destructuring&lt;/em&gt;, because it breaks the single tuple into three parts. Finally, the program prints the value of &lt;code&gt;y&lt;/code&gt;, which is &lt;code&gt;6.4&lt;/code&gt;.</source>
          <target state="translated">该程序首先创建一个元组并将其绑定到变量 &lt;code&gt;tup&lt;/code&gt; 。然后，它使用 &lt;code&gt;let&lt;/code&gt; 的模式将 &lt;code&gt;tup&lt;/code&gt; 转换为三个独立的变量 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 。这称为&lt;em&gt;解构&lt;/em&gt;，因为它会将单个元组分为三部分。最后，程序打印的值 &lt;code&gt;y&lt;/code&gt; ，这是 &lt;code&gt;6.4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e68e59981686f4d6d9628e4a0f06c39a18431f20" translate="yes" xml:space="preserve">
          <source>This program has four possible paths it can take. After running it, you should see the following output:</source>
          <target state="translated">这个程序有四种可能的路径。运行后,你应该看到以下输出。</target>
        </trans-unit>
        <trans-unit id="c268368ea9194ea4e99d8e793596c3443d5a9397" translate="yes" xml:space="preserve">
          <source>This project was a hands-on way to introduce you to many new Rust concepts: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, the use of external crates, and more. In the next few chapters, you&amp;rsquo;ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</source>
          <target state="translated">该项目是向您介绍许多Rust新概念的动手方式： &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;match&lt;/code&gt; ，方法，关联函数，外部包装箱的使用等。在接下来的几章中，您将更详细地了解这些概念。第3章介绍了大多数编程语言所具有的概念，例如变量，数据类型和函数，并介绍了如何在Rust中使用它们。第4章探讨所有权，此功能使Rust与其他语言有所不同。第5章讨论结构和方法语法，第6章介绍枚举的工作方式。</target>
        </trans-unit>
        <trans-unit id="9ce38c4decb31cc4f3034ac7fae7c79d93e80f53" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, and has no extra methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab41f4f49ac9b596f3ff341e670c3c513d2c2a1e" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;code&gt;PartialEq&lt;/code&gt;, and has no extra methods.</source>
          <target state="translated">编译器无法检查此属性，因此 &lt;code&gt;Eq&lt;/code&gt; 表示 &lt;code&gt;PartialEq&lt;/code&gt; ，并且没有其他方法。</target>
        </trans-unit>
        <trans-unit id="1608442363fd58986072b46f4e6a650827d3385c" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;.</source>
          <target state="translated">此属性由&lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="25a4736ccf9a4ba3c3e3dac30177800bc1f743c9" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;.</source>
          <target state="translated">此属性由&lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="2cdf66b6082611e25a822825249d22e6f28f1917" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">此属性由&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="93af0d07e68cafd035375823424d1e725ddb07d1" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt;.</source>
          <target state="translated">此属性在&lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849中&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="85df454e96ffa6c63ed8ab37d8086b690c9dba86" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt;.</source>
          <target state="translated">此属性在&lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193中&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="9d5a4dec1164aed352e96ad9af690b1a3591dc76" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">此属性在&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291中&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="c731a3c6e670f4842c76f756fa1e0f4c4f1cfae6" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;em&gt;UNIX Network Programming, Second Edition&lt;/em&gt;, W. Richard Stevens, p. 891; see also &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;.</source>
          <target state="translated">此属性在&lt;em&gt;UNIX Network Programming，第二版&lt;/em&gt;，W。Richard Stevens，p。891; 另请参阅&lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19926d7df32802514fef095810b287a92fa4b874" translate="yes" xml:space="preserve">
          <source>This queue has &lt;code&gt;O(1)&lt;/code&gt; amortized inserts and removals from both ends of the container. It also has &lt;code&gt;O(1)&lt;/code&gt; indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">此队列在容器的两端具有 &lt;code&gt;O(1)&lt;/code&gt; 分摊的插入和删除。它还具有像矢量一样的 &lt;code&gt;O(1)&lt;/code&gt; 索引。所包含的元素不需要是可复制的，并且如果所包含的类型是可发送的，则队列将是可发送的。</target>
        </trans-unit>
        <trans-unit id="f222b6950bf888a7c8ce05739a640f15b3f1b84f" translate="yes" xml:space="preserve">
          <source>This queue has &lt;em&gt;O&lt;/em&gt;(1) amortized inserts and removals from both ends of the container. It also has &lt;em&gt;O&lt;/em&gt;(1) indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae16a9ff1b9b0bb4dc2773f7faab160bd7347257" translate="yes" xml:space="preserve">
          <source>This reader has reached its &quot;end of file&quot; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will &lt;em&gt;always&lt;/em&gt; no longer be able to produce bytes.</source>
          <target state="translated">该阅读器已到达其&amp;ldquo;文件结尾&amp;rdquo;，可能不再能够产生字节。请注意，这并不意味着读取器将&lt;em&gt;永远&lt;/em&gt;不再能够产生字节。</target>
        </trans-unit>
        <trans-unit id="eabbe1cac74b5970cf00777c8a04a9b08b503051" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">此重新排序具有附加属性，即使用比较器功能，位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即，不分配）和 &lt;code&gt;O(n)&lt;/code&gt; 最坏的情况。在其他库中，此功能也称为&amp;ldquo;第k个元素&amp;rdquo;。它使用提供的比较器函数返回以下值的三元组：所有元素小于给定索引处的元素，给定索引处的值以及所有元素大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="5a5e3f81a187820f825f4369ca83b2c286d9273d" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58333e6fd2204efb6d059b5e0ebaa3ad2ae11cea" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">此重新排序具有附加属性，即使用密钥提取功能，位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即，不分配）和 &lt;code&gt;O(n)&lt;/code&gt; 最坏的情况。在其他库中，此功能也称为&amp;ldquo;第k个元素&amp;rdquo;。它使用提供的键提取函数返回以下值的三元组：所有元素小于给定索引处的元素，给定索引处的值以及所有元素大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="c83a0af8a141703ce8a894f271d81b6b5d0d2d99" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b0ecb2451beab6446b7792a5f32ac5b93e64f7" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">此重新排序具有附加属性，即位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即未分配）和 &lt;code&gt;O(n)&lt;/code&gt; 最坏的情况。在其他库中，此功能也被称为&amp;ldquo;第k个元素&amp;rdquo;。它返回以下值的三元组：所有元素小于给定索引处的元素，给定索引的值以及所有元素大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="3d259af27d2572df43e2afe02e6f4d51f6ff06a9" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a44d46360998129b78ed15d687f727979c543e5" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums.</source>
          <target state="translated">这种表示方法可以应用于结构、联合和枚举。</target>
        </trans-unit>
        <trans-unit id="c79281349d10df09672689425c0c484e6ef587c0" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums. The exception is &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enums&lt;/a&gt; for which the &lt;code&gt;C&lt;/code&gt; representation is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d003da75e5c18c6d78ec752d4c5ea2c1005e03" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; so that we can ignore the pinning invariants when unwrapping it.</source>
          <target state="translated">这要求此 &lt;code&gt;Pin&lt;/code&gt; 内的数据为&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; ,&lt;/a&gt;以便在展开时可以忽略固定不变。</target>
        </trans-unit>
        <trans-unit id="84a024e08861a138f89bc49f72665722f5345893" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">这要求此 &lt;code&gt;Pin&lt;/code&gt; 内的数据为 &lt;code&gt;Unpin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb8049ba5b3a969809828fb6b20b4c6f803c243a" translate="yes" xml:space="preserve">
          <source>This restriction allows for mutation but in a very controlled fashion. It&amp;rsquo;s something that new Rustaceans struggle with, because most languages let you mutate whenever you&amp;rsquo;d like.</source>
          <target state="translated">该限制允许突变，但是以非常受控的方式。这是新的Rustaceans苦苦挣扎的事情，因为大多数语言都允许您随时更改。</target>
        </trans-unit>
        <trans-unit id="b9005ee922bd85c1b8cdd5bf9e647bc71bc7e1d1" translate="yes" xml:space="preserve">
          <source>This restricts us to a &lt;code&gt;Screen&lt;/code&gt; instance that has a list of components all of type &lt;code&gt;Button&lt;/code&gt; or all of type &lt;code&gt;TextField&lt;/code&gt;. If you&amp;rsquo;ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</source>
          <target state="translated">这将我们限制为一个 &lt;code&gt;Screen&lt;/code&gt; 实例，该实例具有一个全部为 &lt;code&gt;Button&lt;/code&gt; 类型或全部 &lt;code&gt;TextField&lt;/code&gt; 类型的组件的列表。如果只使用同质集合，则最好使用泛型和特征范围，因为定义将在编译时进行单态化以使用具体类型。</target>
        </trans-unit>
        <trans-unit id="fef61557094c53c94d8f4b9c87d239c1c4ddf6a3" translate="yes" xml:space="preserve">
          <source>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message in this case would print the value we got from the &lt;code&gt;greeting&lt;/code&gt; function. Let&amp;rsquo;s change the test function, giving it a custom failure message made from a format string with a placeholder filled in with the actual value we got from the &lt;code&gt;greeting&lt;/code&gt; function:</source>
          <target state="translated">此结果仅表明断言失败以及断言在哪一行上。在这种情况下，更有用的失败消息将显示从 &lt;code&gt;greeting&lt;/code&gt; 函数获得的值。让我们更改测试功能，为它提供一个自定义的失败消息，该消息是由格式字符串组成的，占位符填充了我们从 &lt;code&gt;greeting&lt;/code&gt; 函数获得的实际值：</target>
        </trans-unit>
        <trans-unit id="0886cd5bf439fbbc8be3535b3d5401de7c87877b" translate="yes" xml:space="preserve">
          <source>This return type means the call to &lt;code&gt;File::open&lt;/code&gt; might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The &lt;code&gt;File::open&lt;/code&gt; function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the &lt;code&gt;Result&lt;/code&gt; enum conveys.</source>
          <target state="translated">此返回类型意味着对 &lt;code&gt;File::open&lt;/code&gt; 的调用可能会成功，并返回一个我们可以读取或写入的文件句柄。函数调用也可能失败：例如，该文件可能不存在，或者我们可能没有访问该文件的权限。该 &lt;code&gt;File::open&lt;/code&gt; 功能需要有一种方式来告诉我们，无论是成功还是失败，并在同一时间给我们任何文件句柄或错误信息。该信息正是 &lt;code&gt;Result&lt;/code&gt; 枚举所传达的信息。</target>
        </trans-unit>
        <trans-unit id="6e6467b9314c67467a583133eaf79a55bec1323c" translate="yes" xml:space="preserve">
          <source>This returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the working directory will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7256f6dfb124c4206009cc4970395f092ae3141" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;None&lt;/code&gt; if the cursor is currently pointing to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3770e7d2efd1b08fe66eb571f2a780fb54e25f" translate="yes" xml:space="preserve">
          <source>This returns a numeric identifier for the thread identified by this &lt;code&gt;ThreadId&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368beec57f1181b8799a91ee73ada8b4184da78e" translate="yes" xml:space="preserve">
          <source>This reuses all the nodes from &lt;code&gt;other&lt;/code&gt; and moves them into &lt;code&gt;self&lt;/code&gt;. After this operation, &lt;code&gt;other&lt;/code&gt; becomes empty.</source>
          <target state="translated">这将从 &lt;code&gt;other&lt;/code&gt; 节点重用所有节点，并将它们移到 &lt;code&gt;self&lt;/code&gt; 。此操作后， &lt;code&gt;other&lt;/code&gt; 变为空。</target>
        </trans-unit>
        <trans-unit id="7730271090bac7f074841851b1b821f9fc7fca43" translate="yes" xml:space="preserve">
          <source>This rework may seem like overkill for our small program, but we&amp;rsquo;re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It&amp;rsquo;s good to check your progress often, to help identify the cause of problems when they occur.</source>
          <target state="translated">对于我们的小型程序来说，这种返工似乎有些过头，但是我们正在逐步进行小型重构。进行更改后，再次运行该程序以验证参数解析仍然有效。最好经常检查进度，以帮助确定问题发生的原因。</target>
        </trans-unit>
        <trans-unit id="c68a9d1019f31cc86d07a97f90c903ea86167b11" translate="yes" xml:space="preserve">
          <source>This rule also applies to type parameters of impl blocks that contain const methods</source>
          <target state="translated">这个规则也适用于包含 const 方法的 impl 块的类型参数。</target>
        </trans-unit>
        <trans-unit id="c9e400474c407c09b7fb37164368bcd30fbe8830" translate="yes" xml:space="preserve">
          <source>This runs the code in &lt;em&gt;adder/src/main.rs&lt;/em&gt;, which depends on the &lt;code&gt;add-one&lt;/code&gt; crate.</source>
          <target state="translated">这将在&lt;em&gt;adder / src / main.rs中&lt;/em&gt;运行代码，具体取决于 &lt;code&gt;add-one&lt;/code&gt; 板条箱。</target>
        </trans-unit>
        <trans-unit id="e6b2224800e73c42ee25267c2896a776ab41e710" translate="yes" xml:space="preserve">
          <source>This section documents features that affect the ABI of the compiled output of a crate.</source>
          <target state="translated">本节记录了影响装箱的编译输出的ABI的特征。</target>
        </trans-unit>
        <trans-unit id="7dc2765b02ef149354a7a9ee16a696edf0827240" translate="yes" xml:space="preserve">
          <source>This section documents features that define some aspects of the Rust runtime.</source>
          <target state="translated">本节记录了定义Rust运行时某些方面的特性。</target>
        </trans-unit>
        <trans-unit id="f7c12226b9e0c0ca24fa6bdd6239b023bf8ef3a4" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;CString&lt;/code&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">仅应使用通过在 &lt;code&gt;CString&lt;/code&gt; 上调用&lt;a href=&quot;#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt;获得的指针来调用此方法。其他用法（例如，尝试获取由外来代码分配的字符串的所有权）可能导致未定义的行为或分配器损坏。</target>
        </trans-unit>
        <trans-unit id="bb13fd72f340b7885313dcc12025456f86beff96" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de4781e84fd1ffb8326c915806ff4604cbf7406" translate="yes" xml:space="preserve">
          <source>This shows the source code file with the &lt;em&gt;.rs&lt;/em&gt; extension, the executable file (&lt;em&gt;main.exe&lt;/em&gt; on Windows, but &lt;em&gt;main&lt;/em&gt; on all other platforms), and, when using Windows, a file containing debugging information with the &lt;em&gt;.pdb&lt;/em&gt; extension. From here, you run the &lt;em&gt;main&lt;/em&gt; or &lt;em&gt;main.exe&lt;/em&gt; file, like this:</source>
          <target state="translated">这显示了带有&lt;em&gt;.rs&lt;/em&gt;扩展名的源代码文件，可执行文件（在Windows 上是&lt;em&gt;main.exe&lt;/em&gt;，在所有其他平台上是&lt;em&gt;main&lt;/em&gt;），以及在使用Windows时，包含一个带有&lt;em&gt;.pdb&lt;/em&gt;扩展名的调试信息的文件。在这里，运行&lt;em&gt;main&lt;/em&gt;或&lt;em&gt;main.exe&lt;/em&gt;文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="9575f8046ce99c60fbe347fdb162c3debc44c697" translate="yes" xml:space="preserve">
          <source>This slice has the type &lt;code&gt;&amp;amp;[i32]&lt;/code&gt;. It works the same way as string slices do, by storing a reference to the first element and a length. You&amp;rsquo;ll use this kind of slice for all sorts of other collections. We&amp;rsquo;ll discuss these collections in detail when we talk about vectors in Chapter 8.</source>
          <target state="translated">该切片的类型为 &lt;code&gt;&amp;amp;[i32]&lt;/code&gt; 。通过存储对第一个元素和长度的引用，它的工作方式与字符串切片相同。您将在所有其他集合中使用这种切片。在第8章中讨论向量时，我们将详细讨论这些集合。</target>
        </trans-unit>
        <trans-unit id="d65fb4bd24471a81f14e38e503058f70c64833b3" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c9c4b26823864ca42f73d970b5f61574652362" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fe498c20a11bda205dc93f4390f850884c310c" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n + n log n)&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">这种排序是稳定的（即，不对相等元素进行重新排序），并且在 &lt;code&gt;O(m n + n log n)&lt;/code&gt; 最坏的情况下（键函数为 &lt;code&gt;O(m)&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="04ff5f9e434224075f07c47221408f586ed69430" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">这种排序是稳定的（即，不对相等元素进行重新排序），并且在 &lt;code&gt;O(m n log(m n))&lt;/code&gt; 最坏的情况下，键函数是 &lt;code&gt;O(m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13defa388ad16a8832cba0851748fe2d9c59598b" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n * log(n))&lt;/code&gt; worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bb618262e9818d4542507320a836e4faf4b56f" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">这种排序是稳定的（即，不会对相等的元素重新排序），并且 &lt;code&gt;O(n log n)&lt;/code&gt; 最坏的情况。</target>
        </trans-unit>
        <trans-unit id="342fc35a79498863eed086153ecf4de54d803470" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e6ed2e7770cad1c08fcd52e4c75266e91bca66" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; + &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fa553880d5f214b25277a39b204d8402684264" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8094b9acbcdfe817a2beca8fbbfd03d36adf019" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">这种排序是不稳定的（即可能重新排序相等的元素），就地（即不分配）和 &lt;code&gt;O(m n log(m n))&lt;/code&gt; 最坏的情况，其中关键函数是 &lt;code&gt;O(m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e852a79da20e649bf213cb6826ee95c589ae984" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">这种排序是不稳定的（即可能重新排列相等的元素），就地（即不分配）和 &lt;code&gt;O(n log n)&lt;/code&gt; 最坏的情况。</target>
        </trans-unit>
        <trans-unit id="3d7156d28541cb0cabeaa7410dd06cdaa9199652" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e0c73c0881bd5d99646c6bd52683bfabd1a90e" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(m * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9136d07194a4e8e43750309da02e688255bd47" translate="yes" xml:space="preserve">
          <source>This sort of behavior has been known to &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;lead to privilege escalation&lt;/a&gt; when used incorrectly.</source>
          <target state="translated">如果使用不当，这种行为会&lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;导致特权升级&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4609a563600ff8952232a98685a394486b72fb56" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has been suspended, and typically corresponds to a &lt;code&gt;yield&lt;/code&gt; statement. The value provided in this variant corresponds to the expression passed to &lt;code&gt;yield&lt;/code&gt; and allows generators to provide a value each time they yield.</source>
          <target state="translated">此状态表明生成器已暂停，通常对应于 &lt;code&gt;yield&lt;/code&gt; 语句。此变量中提供的值与传递给 &lt;code&gt;yield&lt;/code&gt; 的表达式相对应，并允许生成器在每次生成时提供一个值。</target>
        </trans-unit>
        <trans-unit id="90c88a5ca708244c3219f050c7309e58bf365755" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has finished execution with the provided value. Once a generator has returned &lt;code&gt;Complete&lt;/code&gt; it is considered a programmer error to call &lt;code&gt;resume&lt;/code&gt; again.</source>
          <target state="translated">此状态表明生成器已使用提供的值完成了执行。生成器返回 &lt;code&gt;Complete&lt;/code&gt; ，再次调用 &lt;code&gt;resume&lt;/code&gt; 将被视为程序员错误。</target>
        </trans-unit>
        <trans-unit id="7be578f8354e75e786ae7f8a72194e570efdeae6" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;</source>
          <target state="translated">此流将被忽略。这等效于将流附加到 &lt;code&gt;/dev/null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86aaaf1ade8618d076dfddfcf43a493fbd9d9208" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047e86b07f343619951ab342d709e9864cc54c3d" translate="yes" xml:space="preserve">
          <source>This struct has one field, &lt;code&gt;part&lt;/code&gt;, that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of &lt;code&gt;ImportantExcerpt&lt;/code&gt; can&amp;rsquo;t outlive the reference it holds in its &lt;code&gt;part&lt;/code&gt; field.</source>
          <target state="translated">该结构具有一个字段 &lt;code&gt;part&lt;/code&gt; ，其中包含一个字符串切片，这是一个引用。与泛型数据类型一样，我们在结构名称之后的尖括号内声明泛型生命周期参数的名称，以便可以在结构定义的主体中使用生命周期参数。此注释表示 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 的实例不能超过其在 &lt;code&gt;part&lt;/code&gt; 字段中保存的引用的寿命。</target>
        </trans-unit>
        <trans-unit id="035a190c93ffcb98a162f4a1c124850fba76f70b" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该结构与 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 和 &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; 类的类型具有相同的布局。</target>
        </trans-unit>
        <trans-unit id="8bcde4812fcc7ef55a0760fedbc39c027f9accb6" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fc6455134464feceba11cc2db121b5a8d643b0" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt;&lt;code&gt;Vec::sort_by_key&lt;/code&gt;&lt;/a&gt; and can be used to reverse order a part of a key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698bb1f1506a6aa8b90b6f64dc7e32c0c5091a12" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;code&gt;Vec::sort_by_key&lt;/code&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">该结构是与 &lt;code&gt;Vec::sort_by_key&lt;/code&gt; 类的函数一起使用的辅助函数，可用于对键的一部分进行反向排序。</target>
        </trans-unit>
        <trans-unit id="84ced59217a045f0ae6136d2f9bd0162d392046f" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;env::args()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421112f55866033bf937c2c2104c004765f83d6c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;env::args_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d98990c007f08843ac1df1a07fad048ba02e034" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_args&quot;&gt;&lt;code&gt;Command::get_args&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34405b53d7303b0dec8e54e6aa5a0abefbaa23c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_envs&quot;&gt;&lt;code&gt;Command::get_envs&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2147718c894a448fcb5bace3573d8c66021b6ecf" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt;&lt;code&gt;Vec::drain_filter&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b56bd91b0140c9f3d261bb2e7de1a84ee87136c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;Vec::splice()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b94fdb25d3a1999fbb00df483466c3f3ad93974" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;（通过所提供的&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;性状）。</target>
        </trans-unit>
        <trans-unit id="0f993739b1a6e12d97f61853ab3a7aeead8ab4b9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks&quot;&gt;&lt;code&gt;array_chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306d58f57f3d10dc00f2031814b48c48929d8df3" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks_mut&quot;&gt;&lt;code&gt;array_chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3c9f948ac0eb252b070770390b8ad86aa3b895" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_windows&quot;&gt;&lt;code&gt;array_windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd8330957d499a2a2bc9ec6116864588108859d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;上的&lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="4f546acf131aa1e22a602b9ef3fb82d4387eee8e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e45db796c91b4ce48eb20085844caa57f6053703" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4164f449a467d7ed1b48f5a88a1f8a74fb26a190" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt;&lt;code&gt;chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt; &lt;code&gt;chunks_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76b48770dc5ec192ca6962e1d7faa3bd68e942ab" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上的&lt;a href=&quot;../primitive.slice#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="7681a887be4ac8a42d7f0ef28706aee3c6323619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="523facc9e10029a951175d54b1f37f2671749ed6" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt;&lt;code&gt;rchunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt; &lt;code&gt;rchunks&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建的。</target>
        </trans-unit>
        <trans-unit id="7743c6e4ca6fc913a9f4d37b6de12a320056fa8b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt;&lt;code&gt;rchunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt; &lt;code&gt;rchunks_exact&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建。</target>
        </trans-unit>
        <trans-unit id="82404af50a38a848751818c48976a9a56b795818" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt;&lt;code&gt;rchunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt; &lt;code&gt;rchunks_exact_mut&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建。</target>
        </trans-unit>
        <trans-unit id="711c0f689f1d3a75f7b5a1b1833bc925f8986127" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt;&lt;code&gt;rchunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt; &lt;code&gt;rchunks_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ffea197c31595a869becf274e9c9ef3509b405a" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a28e12c215b6246a69d2f856da858d720de99619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt;&lt;code&gt;rsplit_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt; &lt;code&gt;rsplit_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1ddb16a3352ab0f837d4fac934c98e22db158e5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建的。</target>
        </trans-unit>
        <trans-unit id="2305be064f2e36144fd442bf726fd4dd5a160216" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt;&lt;code&gt;rsplitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt; &lt;code&gt;rsplitn_mut&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建。</target>
        </trans-unit>
        <trans-unit id="9d2c4405dee882e98a94c3681ae8ce615cfcc3f7" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;的&lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="abdc8d3421db5241b7ca4544a7b51d6159d67e49" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt;&lt;code&gt;split_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">此结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;的&lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt; &lt;code&gt;split_mut&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="b850789ebec6b616db674ca7582ef014921e3e50" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;的&lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;splitn&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="fcbac1aabe82a2c466b31106e57bd4691b6a4588" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt;&lt;code&gt;splitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt; &lt;code&gt;splitn_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4faa0b9911c89c4588e753ca1891a11cb9aac5c2" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;上创建的。</target>
        </trans-unit>
        <trans-unit id="972c0f2531dd3e046ad902a7f6f569ef9de9571e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="9dc716c653425077e3bf50725d3ddc775e25fe94" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构由&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt; &lt;code&gt;char_indices&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="607ded9325aedcb5c140c227e32c8ad28d5439d9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="eb31472d0cae7541e173fe527a7087a142820c04" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt;&lt;code&gt;encode_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt; &lt;code&gt;encode_utf16&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e7c273a10bb61ef5da70d27b34dc57f12929254d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt;&lt;code&gt;split_ascii_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt; &lt;code&gt;split_ascii_whitespace&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e335f4d066241eacb01d34cbc9797fdfc696dc6b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f9cd50ffb5bf76be59d59fc2f81ddf738ff0464b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;std::env::args&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该结构是由&lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;std::env::args&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0ec39f7b0daa2776e166f7fac0653e5c7c5e4333" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;std::env::args_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该结构是由&lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;std::env::args_os&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d49df01529faa1803ee9ac5934efa956bfb59ca5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.string#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.string#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7821d89ece3dc45805333802521c4ece28a6ec77" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="df074a53b5359b4dd926d5ab8c21cb3fdb8391e4" translate="yes" xml:space="preserve">
          <source>This struct is created with the &lt;a href=&quot;../primitive.str#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="5a1492f5f04561e29bfe6f623f2dc30782a50bbf" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df7525ac9b1331bb51b51ca2c5df8a11c0a1c0e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">通常通过调用&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt;创建此结构。请参阅&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt;的文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="8dc7e6b8159c36d037a08968dd41820bb2c65481" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0cc773f4b725ed1f190beeb33e3f1817949265" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;repeat()&lt;/code&gt; for more details.</source>
          <target state="translated">通常通过调用&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;创建此结构。请参阅 &lt;code&gt;repeat()&lt;/code&gt; 的文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="24b0eaa40ab28907590f0749ecb8c76a4046ae2e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc05dce26bdc09f8fc488132c92d5215b0e0bb48" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;sink()&lt;/code&gt; for more details.</source>
          <target state="translated">通常通过调用&lt;a href=&quot;fn.sink&quot;&gt; &lt;code&gt;sink&lt;/code&gt; &lt;/a&gt;创建此结构。有关更多详细信息，请参见 &lt;code&gt;sink()&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="6405be6b1dfbc1fabe9afe38ed753782ffca52fa" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a732d552fb11922cbdd232738709d5ceaab3ab0" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;lines()&lt;/code&gt; for more details.</source>
          <target state="translated">通常通过在 &lt;code&gt;BufRead&lt;/code&gt; 上调用&lt;a href=&quot;trait.bufread#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt;来创建此结构。请参阅 &lt;code&gt;lines()&lt;/code&gt; 的文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="f6120cd0b709f995e698179414e725d511642b6c" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57521da9d072a5a75b7ef81a11e1941632c07769" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;split()&lt;/code&gt; for more details.</source>
          <target state="translated">通常通过在 &lt;code&gt;BufRead&lt;/code&gt; 上调用&lt;a href=&quot;trait.bufread#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt;创建此结构。请参阅 &lt;code&gt;split()&lt;/code&gt; 的文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="e1deb8df82a06cf7e25723eca2d9b3c3500c212f" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">通常通过在读取器上调用&lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;来创建此结构。请参阅&lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="137e3be8282a7112c63c8d5b6052cbdcefad663e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">通常通过在阅读器上调用&lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt;来创建此结构。请参阅&lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt;的文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="047a4ebdecfd5e2897b79c73996497448f62e8a9" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">该结构通常是通过调用读取器上的&lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;创建的。请参阅&lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;的文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="a7395af01bd4a50c6dfb48da98c0430b70139ec6" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此结构用于&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.child#structfield.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;字段中。</target>
        </trans-unit>
        <trans-unit id="45d9e2d1a8753395175acd043fb98b742fa0c7b1" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此结构用于&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.child#structfield.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;字段中。</target>
        </trans-unit>
        <trans-unit id="a0e77c1cd6c1d6c1011116ad5fd2720b269732ff" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此结构用于&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.child#structfield.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;字段中。</target>
        </trans-unit>
        <trans-unit id="c78ae69a32ba5f8bbcb17b7abd5cf067694229aa" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c446cff104f615e56344282bb3df53e735cf1fdb" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;env::vars()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b2bbf5e29e3f661a1f1f7db6c4d0d2f77172fd" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31822658b6e7064c66c1754cfb13fa7a6a0cb6b1" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;PanicInfo::location()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3b3caed2d7f9ef42e3b6090d38c4f7a8f595c9" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;std::env::split_paths&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该结构由&lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;std::env::split_paths&lt;/code&gt; &lt;/a&gt;函数创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="763fd05613c0342afc387ef243d7b2fcab0e70ec" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;std::env::vars&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该结构由&lt;a href=&quot;fn.vars&quot;&gt; &lt;code&gt;std::env::vars&lt;/code&gt; &lt;/a&gt;函数创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="aeb9c6eb7e34424ffff3b1a0d353cc1e7da71bbe" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;std::env::vars_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该结构由&lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;std::env::vars_os&lt;/code&gt; &lt;/a&gt;函数创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="49ca05175d2c16657b8d4f1e47558a6913b20cd1" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;方法创建。</target>
        </trans-unit>
        <trans-unit id="4a6f95cf45a5bcc128684cebfbd05d3880902f8d" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;location&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;struct.panicinfo&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;struct.panicinfo&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.panicinfo#method.location&quot;&gt; &lt;code&gt;location&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="0ba43b358d72c0f70633e8ff8edbb3820ba26ae8" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;和try_read方法&lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37c48c912f9cb67a5286393a48bcb5981e2a346b" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.rwlock#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;和try_write方法&lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1b64e1281a00cf103b0dc5f24e83df69f16eb4c" translate="yes" xml:space="preserve">
          <source>This structure is returned from the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;metadata&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;symlink_metadata&lt;/code&gt;&lt;/a&gt; function or method and represents known metadata about a file such as its permissions, size, modification times, etc.</source>
          <target state="translated">此结构从&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;metadata&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;symlink_metadata&lt;/code&gt; &lt;/a&gt;函数或方法返回，并表示有关文件的已知元数据，例如其权限，大小，修改时间等。</target>
        </trans-unit>
        <trans-unit id="a90c6bba494b412af840afa94f3d4327e4e6ac5c" translate="yes" xml:space="preserve">
          <source>This structure is used to represent and manage child processes. A child process is created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct, which configures the spawning process and can itself be constructed using a builder-style interface.</source>
          <target state="translated">此结构用于表示和管理子进程。子进程是通过&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt;结构创建的，该结构配置了生成过程，并且可以使用生成器样式的界面来构造它本身。</target>
        </trans-unit>
        <trans-unit id="21f163fe5401a35062783545bd12a7fe23e7c94b" translate="yes" xml:space="preserve">
          <source>This structure represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.</source>
          <target state="translated">这个结构表示格式字符串及其参数的安全预编译版本。因为不能安全地在运行时生成,所以没有给出构造函数,字段是私有的,以防止修改。</target>
        </trans-unit>
        <trans-unit id="0adc11971ab38c810ebf2248ed011aa51008e125" translate="yes" xml:space="preserve">
          <source>This suffers the same restrictions and reasoning as implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, see there for details.</source>
          <target state="translated">与实施&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; 一样&lt;/a&gt;，这也受到相同的限制和推理，请参见此处。</target>
        </trans-unit>
        <trans-unit id="6f2d7a21c40fec745cf07aea5a678e00b27d1d6d" translate="yes" xml:space="preserve">
          <source>This sums up every integer in a vector, rejecting the sum if a negative element is encountered:</source>
          <target state="translated">对向量中的每一个整数进行求和,如果遇到负数元素,则拒绝求和。</target>
        </trans-unit>
        <trans-unit id="3b38ed7b25f08579fef293fd7b9ae8fd73fe03b3" translate="yes" xml:space="preserve">
          <source>This sums up the position of the character 'a' in a vector of strings, if a word did not have the character 'a' the operation returns &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">这总结了字符&amp;ldquo; a&amp;rdquo;在字符串向量中的位置，如果单词没有字符&amp;ldquo; a&amp;rdquo;，则操作返回 &lt;code&gt;None&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b7b5e0845ef8959eb8d683ea0316747264243c8d" translate="yes" xml:space="preserve">
          <source>This syntax seems comparable to that of generics. So why not just define the &lt;code&gt;Iterator&lt;/code&gt; trait with generics, as shown in Listing 19-13?</source>
          <target state="translated">此语法似乎与泛型类似。那么，为什么不仅仅使用泛型来定义 &lt;code&gt;Iterator&lt;/code&gt; 特质，如清单19-13所示？</target>
        </trans-unit>
        <trans-unit id="2e389d45d6848629d7d0a8141a0d2eefc943d3d3" translate="yes" xml:space="preserve">
          <source>This syntax should look familiar from our discussions on how to define traits in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named &lt;code&gt;Screen&lt;/code&gt; that holds a vector named &lt;code&gt;components&lt;/code&gt;. This vector is of type &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt;, which is a trait object; it&amp;rsquo;s a stand-in for any type inside a &lt;code&gt;Box&lt;/code&gt; that implements the &lt;code&gt;Draw&lt;/code&gt; trait.</source>
          <target state="translated">从我们在第10章中如何定义特征的讨论中，该语法应该看起来很熟悉。接下来是一些新语法：清单17-4定义了一个名为 &lt;code&gt;Screen&lt;/code&gt; 的结构，其中包含一个名为 &lt;code&gt;components&lt;/code&gt; 的向量。此向量的类型为 &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; ，这是一个特征对象；它是实现 &lt;code&gt;Draw&lt;/code&gt; 特性的 &lt;code&gt;Box&lt;/code&gt; 中任何类型的替代。</target>
        </trans-unit>
        <trans-unit id="157ddb41dd66b7335f1aa23c99d8dc3500848966" translate="yes" xml:space="preserve">
          <source>This syntax specifies that we want the X type from MyTrait, as made concrete in MyStruct. The reason that we cannot simply use &lt;code&gt;MyStruct::X&lt;/code&gt; is that MyStruct might implement two different traits with identically-named associated types. This syntax allows disambiguation between the two.</source>
          <target state="translated">此语法指定我们要从MyTrait获得X类型，就像在MyStruct中将其具体化一样。我们不能简单地使用 &lt;code&gt;MyStruct::X&lt;/code&gt; 是MyStruct可能实现两个具有相同名称的关联类型的不同特征。这种语法可以消除两者之间的歧义。</target>
        </trans-unit>
        <trans-unit id="6be1eead3ada3953477a6dbe51c912612a272761" translate="yes" xml:space="preserve">
          <source>This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model and the single-threaded async I/O model. If you&amp;rsquo;re interested in this topic, you can read more about other solutions and try to implement them in Rust; with a low-level language like Rust, all of these options are possible.</source>
          <target state="translated">该技术只是提高Web服务器吞吐量的众多方法之一。您可能会探讨的其他选项是fork / join模型和单线程异步I / O模型。如果您对此主题感兴趣，可以阅读有关其他解决方案的更多信息，并尝试在Rust中实现它们。使用Rust这样的低级语言，所有这些选项都是可能的。</target>
        </trans-unit>
        <trans-unit id="731e8ea356524b34210881afc68de295a0e37bff" translate="yes" xml:space="preserve">
          <source>This technique is pretty neat! By using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we have an outwardly immutable &lt;code&gt;List&lt;/code&gt; value. But we can use the methods on &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it&amp;rsquo;s sometimes worth trading a bit of speed for this flexibility in our data structures.</source>
          <target state="translated">这项技术非常好用！通过使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，我们有了一个向外不变的 &lt;code&gt;List&lt;/code&gt; 值。但是我们可以使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 上的方法来访问其内部可变性，因此可以在需要时修改数据。借用规则的运行时检查可保护我们免受数据争用的影响，有时值得以速度为代价来换取数据结构中的这种灵活性。</target>
        </trans-unit>
        <trans-unit id="9283a8a2efae9e1f40a1d640e7fbf1f6c7025c52" translate="yes" xml:space="preserve">
          <source>This tells us the return type of the &lt;code&gt;File::open&lt;/code&gt; function is a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in here with the type of the success value, &lt;code&gt;std::fs::File&lt;/code&gt;, which is a file handle. The type of &lt;code&gt;E&lt;/code&gt; used in the error value is &lt;code&gt;std::io::Error&lt;/code&gt;.</source>
          <target state="translated">这告诉我们 &lt;code&gt;File::open&lt;/code&gt; 函数的返回类型是 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 。通用参数 &lt;code&gt;T&lt;/code&gt; 在此处已填写成功值的类型 &lt;code&gt;std::fs::File&lt;/code&gt; ，它是一个文件句柄。错误值中使用的 &lt;code&gt;E&lt;/code&gt; 类型为 &lt;code&gt;std::io::Error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1369ebc6a80c7328fbe0b2bd897392d17a8945de" translate="yes" xml:space="preserve">
          <source>This test code defines a &lt;code&gt;MockMessenger&lt;/code&gt; struct that has a &lt;code&gt;sent_messages&lt;/code&gt; field with a &lt;code&gt;Vec&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; values to keep track of the messages it&amp;rsquo;s told to send. We also define an associated function &lt;code&gt;new&lt;/code&gt; to make it convenient to create new &lt;code&gt;MockMessenger&lt;/code&gt; values that start with an empty list of messages. We then implement the &lt;code&gt;Messenger&lt;/code&gt; trait for &lt;code&gt;MockMessenger&lt;/code&gt; so we can give a &lt;code&gt;MockMessenger&lt;/code&gt; to a &lt;code&gt;LimitTracker&lt;/code&gt;. In the definition of the &lt;code&gt;send&lt;/code&gt; method, we take the message passed in as a parameter and store it in the &lt;code&gt;MockMessenger&lt;/code&gt; list of &lt;code&gt;sent_messages&lt;/code&gt;.</source>
          <target state="translated">该测试代码定义了一个 &lt;code&gt;MockMessenger&lt;/code&gt; 结构，该结构具有一个 &lt;code&gt;sent_messages&lt;/code&gt; 字段，该字段具有 &lt;code&gt;Vec&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; 值，以跟踪被告知要发送的消息。我们还定义了一个 &lt;code&gt;new&lt;/code&gt; 的关联函数，以方便创建以空消息列表开头的新 &lt;code&gt;MockMessenger&lt;/code&gt; 值。然后，我们为 &lt;code&gt;MockMessenger&lt;/code&gt; 实现 &lt;code&gt;Messenger&lt;/code&gt; 特质，以便将 &lt;code&gt;MockMessenger&lt;/code&gt; 赋予 &lt;code&gt;LimitTracker&lt;/code&gt; 。在 &lt;code&gt;send&lt;/code&gt; 方法的定义中，我们将传入的消息作为参数，并将其存储在以下 &lt;code&gt;MockMessenger&lt;/code&gt; 列表中： &lt;code&gt;sent_messages&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf7bdfe2c080bcfbd294561ba32984ed7b6655c2" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Cacher&lt;/code&gt; instance with a closure that returns the value passed into it. We call the &lt;code&gt;value&lt;/code&gt; method on this &lt;code&gt;Cacher&lt;/code&gt; instance with an &lt;code&gt;arg&lt;/code&gt; value of 1 and then an &lt;code&gt;arg&lt;/code&gt; value of 2, and we expect the call to &lt;code&gt;value&lt;/code&gt; with the &lt;code&gt;arg&lt;/code&gt; value of 2 to return 2.</source>
          <target state="translated">该测试将创建一个新的带有闭包的 &lt;code&gt;Cacher&lt;/code&gt; 实例，该实例返回传递给它的值。我们在此 &lt;code&gt;Cacher&lt;/code&gt; 实例上使用 &lt;code&gt;arg&lt;/code&gt; 值1和 &lt;code&gt;arg&lt;/code&gt; 值2 调用 &lt;code&gt;value&lt;/code&gt; 方法，并期望对 &lt;code&gt;arg&lt;/code&gt; 值2的 &lt;code&gt;value&lt;/code&gt; 的调用返回2。</target>
        </trans-unit>
        <trans-unit id="72299afca54f19e85015cb228f6cdc67fc73f999" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Counter&lt;/code&gt; instance in the &lt;code&gt;counter&lt;/code&gt; variable and then calls &lt;code&gt;next&lt;/code&gt; repeatedly, verifying that we have implemented the behavior we want this iterator to have: returning the values from 1 to 5.</source>
          <target state="translated">此测试在 &lt;code&gt;counter&lt;/code&gt; 变量中创建一个新的 &lt;code&gt;Counter&lt;/code&gt; 实例，然后重复调用 &lt;code&gt;next&lt;/code&gt; ，以验证我们是否实现了希望此迭代器具有的行为：将值从1返回到5。</target>
        </trans-unit>
        <trans-unit id="05dea38628c56d1ac2dee0da9506b8c1998c15fa" translate="yes" xml:space="preserve">
          <source>This test searches for the string &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. The text we&amp;rsquo;re searching is three lines, only one of which contains &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. We assert that the value returned from the &lt;code&gt;search&lt;/code&gt; function contains only the line we expect.</source>
          <target state="translated">此测试搜索字符串 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 。我们正在搜索的文本是三行，其中只有一行包含 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 。我们断言从 &lt;code&gt;search&lt;/code&gt; 函数返回的值仅包含我们期望的行。</target>
        </trans-unit>
        <trans-unit id="ddca2fdf5e68d60216a77aaaba507a1415303561" translate="yes" xml:space="preserve">
          <source>This test will pass because the value we put in the &lt;code&gt;should_panic&lt;/code&gt; attribute&amp;rsquo;s &lt;code&gt;expected&lt;/code&gt; parameter is a substring of the message that the &lt;code&gt;Guess::new&lt;/code&gt; function panics with. We could have specified the entire panic message that we expect, which in this case would be &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; What you choose to specify in the expected parameter for &lt;code&gt;should_panic&lt;/code&gt; depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; case.</source>
          <target state="translated">该测试将通过，因为我们放入 &lt;code&gt;should_panic&lt;/code&gt; 属性的 &lt;code&gt;expected&lt;/code&gt; 参数中的值是 &lt;code&gt;Guess::new&lt;/code&gt; 函数恐慌的消息的子字符串。我们可能已经指定了我们期望的整个恐慌消息，在这种情况下， &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; 您在 &lt;code&gt;should_panic&lt;/code&gt; 的预期参数中选择要指定的值取决于恐慌的程度消息是唯一的还是动态的，以及您希望测试的精确度。在这种情况下，紧急消息的子字符串足以确保测试函数中的代码在 &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; case时执行else。</target>
        </trans-unit>
        <trans-unit id="bbe227be9e7db744874fde49a6fb7f9f9cde2ed8" translate="yes" xml:space="preserve">
          <source>This text is available in &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;paperback and ebook format from No Starch Press&lt;/a&gt;.</source>
          <target state="translated">该文本可&lt;a href=&quot;https://nostarch.com/rust&quot;&gt;从No Starch Press&lt;/a&gt;以平装本和电子书格式获得。</target>
        </trans-unit>
        <trans-unit id="abaa655d972948c0991360be1b3331d77edb5df2" translate="yes" xml:space="preserve">
          <source>This time when we compile the code, we get a different set of errors:</source>
          <target state="translated">这次我们编译代码时,得到的是一组不同的错误。</target>
        </trans-unit>
        <trans-unit id="ef45f877ddb3c6c79878e62a645c0f1bb5d754ab" translate="yes" xml:space="preserve">
          <source>This time when we run the &lt;code&gt;should_panic&lt;/code&gt; test, it will fail:</source>
          <target state="translated">这次，当我们运行 &lt;code&gt;should_panic&lt;/code&gt; 测试时，它将失败：</target>
        </trans-unit>
        <trans-unit id="927ffba8c6b861ab1b3ffedb0e60fa4989110409" translate="yes" xml:space="preserve">
          <source>This time, before we create the first spawned thread, we call &lt;code&gt;clone&lt;/code&gt; on the sending end of the channel. This will give us a new sending handle we can pass to the first spawned thread. We pass the original sending end of the channel to a second spawned thread. This gives us two threads, each sending different messages to the receiving end of the channel.</source>
          <target state="translated">这次，在创建第一个衍生线程之前，我们在通道的发送端调用 &lt;code&gt;clone&lt;/code&gt; 。这将为我们提供一个新的发送句柄，我们可以将其传递给第一个产生的线程。我们将通道的原始发送端传递给第二个生成的线程。这给了我们两个线程，每个线程向通道的接收端发送不同的消息。</target>
        </trans-unit>
        <trans-unit id="03b02e99d0c7b36f56fe77cf1bc6781836989a07" translate="yes" xml:space="preserve">
          <source>This time, the spawned thread has a vector of strings that we want to send to the main thread. We iterate over them, sending each individually, and pause between each by calling the &lt;code&gt;thread::sleep&lt;/code&gt; function with a &lt;code&gt;Duration&lt;/code&gt; value of 1 second.</source>
          <target state="translated">这次，生成的线程具有一个我们要发送到主线程的字符串向量。我们遍历它们，分别发送它们，并通过调用 &lt;code&gt;Duration&lt;/code&gt; :值为1秒的 &lt;code&gt;thread::sleep&lt;/code&gt; 函数在它们之间暂停。</target>
        </trans-unit>
        <trans-unit id="704e60202fcb30892563c7bc7f66fbb6decda49f" translate="yes" xml:space="preserve">
          <source>This trait allows constructing network objects like &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.udpsocket&quot;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt; easily with values of various types for the bind/connection address. It is needed because sometimes one type is more appropriate than the other: for simple uses a string like &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; is much nicer than manual construction of the corresponding &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, but sometimes &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; value is &lt;em&gt;the&lt;/em&gt; main source of the address, and converting it to some other type (e.g., a string) just for it to be converted back to &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; in constructor methods is pointless.</source>
          <target state="translated">此特征允许使用绑定/连接地址的各种类型的值轻松构造&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.udpsocket&quot;&gt; &lt;code&gt;UdpSocket&lt;/code&gt; 之&lt;/a&gt;类的网络对象。之所以需要它，是因为有时一种类型比另一种类型更合适：对于简单的用法，像 &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; 这样的字符串比相应的&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; 的&lt;/a&gt;手动构造要好得多，但有时&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;值是地址&lt;em&gt;的&lt;/em&gt;主要来源，并进行转换仅将其转换为构造函数方法中的&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;，将其转换为其他类型（例如，字符串）是没有意义的。</target>
        </trans-unit>
        <trans-unit id="f4c03571c99fa2a4a0d6d2bd73efa6856a353a75" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;a href=&quot;trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6796333a1773b86bb39aa9af35062f79738f2038" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1802ac1cfe1536c265ef2f2bdbe3a05ea51c03f9" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">对于没有完全对等关系的类型，此特征允许部分相等。例如，在浮点数 &lt;code&gt;NaN != NaN&lt;/code&gt; ，因此浮点类型实现 &lt;code&gt;PartialEq&lt;/code&gt; 而不是 &lt;code&gt;Eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff1d61ee8b274d07d29615e751a57961b3d97e97" translate="yes" xml:space="preserve">
          <source>This trait can be used to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. An executor can define an implementation of this trait, and use that to construct a Waker to pass to the tasks that are executed on that executor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bebce9a7c84fca1499f5aca86035aeb53d64365" translate="yes" xml:space="preserve">
          <source>This trait can be used to implement other traits on fixed-size arrays without causing much metadata bloat.</source>
          <target state="translated">这个特质可以用来在固定大小的数组上实现其他的特质,而不会造成很多元数据的膨胀。</target>
        </trans-unit>
        <trans-unit id="45737752ce770a5a32320c65da9b598f29acafd8" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5800007da2c584795de3c7fc5ff71b96b272866c" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="translated">如果所有字段均为 &lt;code&gt;Clone&lt;/code&gt; ,则可以将此特征与 &lt;code&gt;#[derive]&lt;/code&gt; 一起使用。该 &lt;code&gt;derive&lt;/code&gt; 的d执行&lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;呼吁&lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;上的每个字段。</target>
        </trans-unit>
        <trans-unit id="e6a77474d17602cdca329051113afe871aed6794" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields implement &lt;code&gt;Debug&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d for structs, it will use the name of the &lt;code&gt;struct&lt;/code&gt;, then &lt;code&gt;{&lt;/code&gt;, then a comma-separated list of each field's name and &lt;code&gt;Debug&lt;/code&gt; value, then &lt;code&gt;}&lt;/code&gt;. For &lt;code&gt;enum&lt;/code&gt;s, it will use the name of the variant and, if applicable, &lt;code&gt;(&lt;/code&gt;, then the &lt;code&gt;Debug&lt;/code&gt; values of the fields, then &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">如果所有字段都实现 &lt;code&gt;Debug&lt;/code&gt; ,则此特征可以与 &lt;code&gt;#[derive]&lt;/code&gt; 一起使用。当 &lt;code&gt;derive&lt;/code&gt; d的结构，它将使用的名称 &lt;code&gt;struct&lt;/code&gt; ，然后 &lt;code&gt;{&lt;/code&gt; ，然后每个字段的名称和一个逗号分隔的列表 &lt;code&gt;Debug&lt;/code&gt; 值，然后 &lt;code&gt;}&lt;/code&gt; 。对于 &lt;code&gt;enum&lt;/code&gt; ，它将使用变量的名称，如果适用，将使用 &lt;code&gt;(&lt;/code&gt; ，然后是字段的 &lt;code&gt;Debug&lt;/code&gt; 值，然后是 &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1a45e25757830b253d95a2bc878b147cc25a79e" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all of the type's fields implement &lt;code&gt;Default&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, it will use the default value for each field's type.</source>
          <target state="translated">如果所有类型的字段都实现 &lt;code&gt;Default&lt;/code&gt; ，则此特征可以与 &lt;code&gt;#[derive]&lt;/code&gt; 一起使用。当 &lt;code&gt;derive&lt;/code&gt; d，它将使用每个字段的类型的默认值。</target>
        </trans-unit>
        <trans-unit id="2676a9e67ccce40e213776c8079ad50bcc6e9ebc" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographic_order&quot;&gt;lexicographic&lt;/a&gt; ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom discriminant order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09d6ff7ae1d14cf4065033999ff08ecaa8a87ff" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom declaration order.</source>
          <target state="translated">此特征可以与 &lt;code&gt;#[derive]&lt;/code&gt; 一起使用。当在结构上 &lt;code&gt;derive&lt;/code&gt; d时，它将基于该结构成员的自上而下的声明顺序生成字典顺序。当从枚举 &lt;code&gt;derive&lt;/code&gt; d时，变体按其自上而下的声明顺序进行排序。</target>
        </trans-unit>
        <trans-unit id="9c8b40d33d991fc237bdd0ad2e6af05e65ea6f04" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom discriminant order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c69254ea90ce1d6926208560c4e9d29d5a8ded" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, two instances are equal if all fields are equal, and not equal if any fields are not equal. When &lt;code&gt;derive&lt;/code&gt;d on enums, each variant is equal to itself and not equal to the other variants.</source>
          <target state="translated">此特征可以与 &lt;code&gt;#[derive]&lt;/code&gt; 一起使用。当在结构上 &lt;code&gt;derive&lt;/code&gt; d时，如果所有字段都相等，则两个实例相等；如果任何字段不相等，则两个实例不相等。当从枚举 &lt;code&gt;derive&lt;/code&gt; d时，每个变量都等于其自身，而不等于其他变量。</target>
        </trans-unit>
        <trans-unit id="d52b5ae617172e107648185da3f817960014bc61" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, because &lt;code&gt;Eq&lt;/code&gt; has no extra methods, it is only informing the compiler that this is an equivalence relation rather than a partial equivalence relation. Note that the &lt;code&gt;derive&lt;/code&gt; strategy requires all fields are &lt;code&gt;Eq&lt;/code&gt;, which isn't always desired.</source>
          <target state="translated">此特征可以与 &lt;code&gt;#[derive]&lt;/code&gt; 一起使用。当 &lt;code&gt;derive&lt;/code&gt; d时，由于 &lt;code&gt;Eq&lt;/code&gt; 没有额外的方法，所以它仅通知编译器这是等价关系，而不是部分等价关系。请注意， &lt;code&gt;derive&lt;/code&gt; 策略要求所有字段都是 &lt;code&gt;Eq&lt;/code&gt; ，这并不总是需要的。</target>
        </trans-unit>
        <trans-unit id="7f803568cc6e1099a89a4940b9eb35200f2785e5" translate="yes" xml:space="preserve">
          <source>This trait is &lt;code&gt;unsafe&lt;/code&gt; because its implementation must be correct for the safety of &lt;code&gt;unsafe trait TrustedLen&lt;/code&gt; implementations, and the results of using this trait can otherwise be trusted by &lt;code&gt;unsafe&lt;/code&gt; code to be correct and fulfill the listed obligations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec116d7c92b2e4ed9689a8552deb9b1c3c9f209" translate="yes" xml:space="preserve">
          <source>This trait is a memory-safe and ergonomic alternative to constructing a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;. It supports the common executor design in which the data used to wake up a task is stored in an &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;. Some executors (especially those for embedded systems) cannot use this API, which is why &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; exists as an alternative for those systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8679bc430feac142d06128a89f1af63473e460" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for almost every type.</source>
          <target state="translated">几乎每个类型都会自动实现这个特性。</target>
        </trans-unit>
        <trans-unit id="ce8cc586f2666a5f5f3d6650a18ec09e61d24a39" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for any type which implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait. As such, &lt;code&gt;ToString&lt;/code&gt; shouldn't be implemented directly: &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; should be implemented instead, and you get the &lt;code&gt;ToString&lt;/code&gt; implementation for free.</source>
          <target state="translated">对于任何实现了&lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; trait的类型，都会自动实现此trait。因此，不应直接实现 &lt;code&gt;ToString&lt;/code&gt; ：应改为实现&lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;，并且您可以免费获得 &lt;code&gt;ToString&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="82a06decfe065900879f7436e10b252705283acf" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for every type and does not add any guarantees to &lt;a href=&quot;../mem/struct.discriminant&quot;&gt;&lt;code&gt;mem::Discriminant&lt;/code&gt;&lt;/a&gt;. It is &lt;strong&gt;undefined behavior&lt;/strong&gt; to transmute between &lt;code&gt;DiscriminantKind::Discriminant&lt;/code&gt; and &lt;code&gt;mem::Discriminant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3b32607a26276b7eeb2dc3f257150496699a30" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented when the compiler determines it's appropriate.</source>
          <target state="translated">当编译器认为合适时,会自动实现这个特性。</target>
        </trans-unit>
        <trans-unit id="494ae62c6025e3f79bcb3a8e54a1efc9a121264f" translate="yes" xml:space="preserve">
          <source>This trait is implemented by default for many types and behaves similarly in terms of inference of implementation to the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; traits. The purpose of this trait is to encode what types are safe to cross a &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; boundary with no fear of unwind safety.</source>
          <target state="translated">默认情况下，许多特征都实现了此特征，并且在实现的推断上类似于&amp;ldquo; &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;特征。此特征的目的是编码哪些类型可以安全地跨过&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt;边界而不必担心展开安全性。</target>
        </trans-unit>
        <trans-unit id="6fb1b7be6434ef1f997fff7cbfd045083e8560fe" translate="yes" xml:space="preserve">
          <source>This trait is namely not implemented by &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&lt;/code&gt;&lt;/a&gt;, the root of all interior mutability.</source>
          <target state="translated">也就是说，所有内部可变性的根源&lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&lt;/code&gt; &lt;/a&gt;都没有实现此特征。</target>
        </trans-unit>
        <trans-unit id="1d0c0de184f4ceb6563275bbcba7c14bd0a8edcc" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; which is used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">此特征类似于用于在可变引用之间进行转换的&lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt;。如果您需要进行昂贵的转换，最好使用 &lt;code&gt;&amp;amp;T&lt;/code&gt; 类型实现&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;或编写自定义函数。</target>
        </trans-unit>
        <trans-unit id="72c951714ee4a3342d70f41b91f0921e7e49ebf0" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; but used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">此特征类似于&lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; ,&lt;/a&gt;但用于在可变引用之间进行转换。如果您需要进行昂贵的转换，最好使用 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 类型实现&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;或编写自定义函数。</target>
        </trans-unit>
        <trans-unit id="1a731da3b36000bb0e86dfbd3105e49bf55c952e" translate="yes" xml:space="preserve">
          <source>This trait is the type which this modules requires when formatting information. This is similar to the standard library's &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait, but it is only intended for use in libcore.</source>
          <target state="translated">此特征是此模块在格式化信息时需要的类型。这类似于标准库的&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt;特征，但仅适用于libcore。</target>
        </trans-unit>
        <trans-unit id="0b733d2267c635d65e2675dc57b25279df45e854" translate="yes" xml:space="preserve">
          <source>This trait is used for generic address resolution when constructing network objects. By default it is implemented for the following types:</source>
          <target state="translated">当构建网络对象时,这个特性用于通用地址解析。默认情况下,它是为以下类型实现的。</target>
        </trans-unit>
        <trans-unit id="1e3fe626c5ddea26b813fe813b589bf866e90fcc" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d670e5f44288c65ae601422a01219d930136f211" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此特征用于在迭代器上实现&lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; &lt;/a&gt;方法。可以通过&lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; &lt;/a&gt;方法生成实现特征的类型。像&lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; &lt;/a&gt;一样，很少应直接调用此特征，而应通过&lt;a href=&quot;trait.iterator#method.product&quot;&gt; &lt;code&gt;Iterator::product&lt;/code&gt; &lt;/a&gt;与之交互。</target>
        </trans-unit>
        <trans-unit id="45f3e129667be9feede25a178448a0d3c4ddec5b" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91608e2b2b005f5d3b20c487cd2efcf273838ce" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此特征用于在迭代器上实现&lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;方法。可以通过&lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;方法生成实现特征的类型。像&lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; &lt;/a&gt;一样，很少应直接调用此特征，而应通过&lt;a href=&quot;trait.iterator#method.sum&quot;&gt; &lt;code&gt;Iterator::sum&lt;/code&gt; &lt;/a&gt;与之交互。</target>
        </trans-unit>
        <trans-unit id="b392534a7b8b5e656825847e787994b0e838f382" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="translated">只有在遵守合同的情况下才能实现此特征。具有此特征的消费者必须检查&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt;的上限。</target>
        </trans-unit>
        <trans-unit id="6d78a10342907305049d898a7fef5c559c08564a" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26cbb7d217e71e5e8a2a5d99b20ac95a15952a0" translate="yes" xml:space="preserve">
          <source>This trait only accepts UTF-8&amp;ndash;encoded data and is not &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;flushable&lt;/a&gt;. If you only want to accept Unicode and you don't need flushing, you should implement this trait; otherwise you should implement &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b09db877c076776794822e006bb3f0094cf13d" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the back (right) of a string.</source>
          <target state="translated">这个特性提供了从一个字符串的背面(右边)开始搜索非重叠匹配的模式的方法。</target>
        </trans-unit>
        <trans-unit id="581e031865e09ba379141c2883157c1d8acecf2b" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the front (left) of a string.</source>
          <target state="translated">这个特性提供了从一个字符串的前面(左边)开始搜索非重叠匹配的模式的方法。</target>
        </trans-unit>
        <trans-unit id="577d84c8d58ef48b8ffaf1a01ef5ed3b028f5279" translate="yes" xml:space="preserve">
          <source>This trait provides transitive access to source-stage in an interator-adapter pipeline under the conditions that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d02b91849e023371b70419d209ec71d8ae7432d" translate="yes" xml:space="preserve">
          <source>This trait should generally not be implemented by consumers of the standard library. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro accepts an instance of &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait is favored over implementing this trait.</source>
          <target state="translated">标准库的使用者通常不应实现此特征。在&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;宏接受&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt;的实例，并且&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt;特质优于实现此特质。</target>
        </trans-unit>
        <trans-unit id="6159bc779b64f1381d56daf00e89fd123440f35d" translate="yes" xml:space="preserve">
          <source>This tree shows how some of the modules nest inside one another (for example, &lt;code&gt;hosting&lt;/code&gt; nests inside &lt;code&gt;front_of_house&lt;/code&gt;). The tree also shows that some modules are &lt;em&gt;siblings&lt;/em&gt; to each other, meaning they&amp;rsquo;re defined in the same module (&lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt; are defined within &lt;code&gt;front_of_house&lt;/code&gt;). To continue the family metaphor, if module A is contained inside module B, we say that module A is the &lt;em&gt;child&lt;/em&gt; of module B and that module B is the &lt;em&gt;parent&lt;/em&gt; of module A. Notice that the entire module tree is rooted under the implicit module named &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">这棵树显示了一些模块如何相互嵌套（例如，在 &lt;code&gt;front_of_house&lt;/code&gt; 内部 &lt;code&gt;hosting&lt;/code&gt; 嵌套）。该树还显示了某些模块彼此为&lt;em&gt;同级&lt;/em&gt;，这意味着它们在同一模块中定义（ &lt;code&gt;hosting&lt;/code&gt; 和 &lt;code&gt;serving&lt;/code&gt; 在 &lt;code&gt;front_of_house&lt;/code&gt; 中定义）。为了继续这个家族隐喻，如果模块A包含在模块B中，我们说模块A是模块B 的&lt;em&gt;子代&lt;/em&gt;，而模块B是模块A 的&lt;em&gt;父代&lt;/em&gt;。请注意，整个模块树都植根于名为的隐式模块下。 &lt;code&gt;crate&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a2a59de8ad5e3abf90b08ea27feb4c5c9564363" translate="yes" xml:space="preserve">
          <source>This trick is very sneaky and complicated. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make perfect sense; someday, it will be completely unnecessary.</source>
          <target state="translated">这个技巧非常狡猾而且复杂。如果这不是很合理，请不要担心。总有一天，这完全没有必要。</target>
        </trans-unit>
        <trans-unit id="e51c9b4abf7ac4d9724545d7cabc828636bce6da" translate="yes" xml:space="preserve">
          <source>This type can represent a wide range of decimal numbers, like &lt;code&gt;3.5&lt;/code&gt;, &lt;code&gt;27&lt;/code&gt;, &lt;code&gt;-113.75&lt;/code&gt;, &lt;code&gt;0.0078125&lt;/code&gt;, &lt;code&gt;34359738368&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt;. So unlike integer types (such as &lt;code&gt;i32&lt;/code&gt;), floating point types can represent non-integer numbers, too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b151d516c842037f13cd18d29f046aea06e0121e" translate="yes" xml:space="preserve">
          <source>This type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">此类型的大小不能明确定义，因为它必须任意大（因为我们可以将 &lt;code&gt;ListNode&lt;/code&gt; 嵌套到任何深度）。特别，</target>
        </trans-unit>
        <trans-unit id="84f5f45f7092418ba53ffa588ed49cf6c55b3005" translate="yes" xml:space="preserve">
          <source>This type does not support transmission of an error other than that an error occurred. Any extra information must be arranged to be transmitted through some other means.</source>
          <target state="translated">这种类型不支持传输发生错误以外的错误。任何额外的信息必须安排通过其他方式传输。</target>
        </trans-unit>
        <trans-unit id="ca06708cb31886f20e9999f83e4a96bd88513b09" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;a href=&quot;../../primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型与&lt;a href=&quot;../../primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。</target>
        </trans-unit>
        <trans-unit id="7ed5168f106b9ae49d6a5ac8c4fbf062da809a4c" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">此类型与 &lt;code&gt;*mut T&lt;/code&gt; 具有相同的内存表示形式。</target>
        </trans-unit>
        <trans-unit id="bde0ba16d9d2a17d2da79db3c616fd2db5d4b738" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基本整数类型&lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11fe8d9ef82cc58363e607b1900488902f96b062" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基础整数类型&lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae2c41e53be3c451cd7fe9d715ded32f7f324930" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基本整数类型&lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8709735902527f53136366bbc4da81e059b1cf29" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基本整数类型&lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22a2662795b52aff8d9d5db4f32fbfd5a6eae45b" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基础整数类型&lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0e9d5aecbbcb90f5394cd93afd041c8660e20d3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基本整数类型&lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2b9ce184354cce38ff31805f5b9e99cf85271c3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基本整数类型&lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f3b430d11ed80e34dede1d2fe612c5e93a3e75e" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基本整数类型&lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da5885bb51df1018c63942e6cd581107a9d67b99" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基本整数类型&lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1494d8fbdc9903b4f7f4ce3473fbf110556d56ce" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">此类型与基础整数类型&lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;具有相同的内存表示形式。有关原子类型和非原子类型之间的区别的更多信息，以及有关此类型的可移植性的信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd773ba06290a2ef0eb43046e43b15b9753a1b01" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此类型通过将调用转发到在 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性中注册的分配器（如果有的话）或 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值来实现&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性。</target>
        </trans-unit>
        <trans-unit id="0d10c935129b21e89e6454b38394b060ce3b284b" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acd93eca07f0189a95b444e7590b0d811f50e31" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;code&gt;GlobalAlloc&lt;/code&gt; trait and Rust programs by default work as if they had this definition:</source>
          <target state="translated">此类型默认情况下实现 &lt;code&gt;GlobalAlloc&lt;/code&gt; trait和Rust程序，就像它们具有以下定义一样：</target>
        </trans-unit>
        <trans-unit id="58e8fa6622de2c31c9adb96ad4ef78c440c610d0" translate="yes" xml:space="preserve">
          <source>This type is a thread-safe &lt;code&gt;Lazy&lt;/code&gt;, and can be used in statics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c766a6dd40937d2b1bee433cf315fc82a362370f" translate="yes" xml:space="preserve">
          <source>This type is a thread-safe &lt;code&gt;OnceCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466a15ddbbbf930acad97c2c30afa51f3b95564c" translate="yes" xml:space="preserve">
          <source>This type is broadly used across &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; for any operation which may produce an error.</source>
          <target state="translated">此类型在&lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::io&lt;/code&gt; &lt;/a&gt;广泛用于可能产生错误的任何操作。</target>
        </trans-unit>
        <trans-unit id="37345f83ba0c67385672d5daf1593634da8686e6" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt;&lt;code&gt;from_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型是&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;上&lt;a href=&quot;struct.string#method.from_utf16&quot;&gt; &lt;code&gt;from_utf16&lt;/code&gt; &lt;/a&gt;方法的错误类型。</target>
        </trans-unit>
        <trans-unit id="8498c071c2463be5580b4f49150396661778b8bc" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. It is designed in such a way to carefully avoid reallocations: the &lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt; method will give back the byte vector that was used in the conversion attempt.</source>
          <target state="translated">此类型是&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;上&lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;方法的错误类型。它的设计方式旨在避免重新分配：&lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt; &lt;code&gt;into_bytes&lt;/code&gt; &lt;/a&gt;方法将返回转换尝试中使用的字节向量。</target>
        </trans-unit>
        <trans-unit id="d92453a7345aece96356ae2979efa1f42765d4ea" translate="yes" xml:space="preserve">
          <source>This type is very similar to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many bits. Please see &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double precision values&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b84d2000b910b8457b4220e8938add88b701b5" translate="yes" xml:space="preserve">
          <source>This type of lock allows a number of readers or at most one writer at any point in time. The write portion of this lock typically allows modification of the underlying data (exclusive access) and the read portion of this lock typically allows for read-only access (shared access).</source>
          <target state="translated">这种类型的锁允许在任何时间点上有若干个读者或最多一个作家。这种锁的写部分通常允许修改基础数据(独占访问),而这种锁的读部分通常允许只读访问(共享访问)。</target>
        </trans-unit>
        <trans-unit id="c6101d6dc5e2fd547d5ca4f8075c490b739700a9" translate="yes" xml:space="preserve">
          <source>This type provides methods like &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt;&lt;code&gt;set_extension&lt;/code&gt;&lt;/a&gt; that mutate the path in place. It also implements &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, meaning that all methods on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slices are available on &lt;code&gt;PathBuf&lt;/code&gt; values as well.</source>
          <target state="translated">此类型提供诸如&lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt; &lt;code&gt;set_extension&lt;/code&gt; 之&lt;/a&gt;类的方法，这些方法会改变路径。它还实现了&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; to &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;，这意味着&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;切片上的所有方法也可以在 &lt;code&gt;PathBuf&lt;/code&gt; 值上使用。</target>
        </trans-unit>
        <trans-unit id="e5c0f0dd2b187cb6784df147ee7001123c8936c0" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型表示对空终止的字节数组的借用引用。可以从 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; slice 安全地构造它，或者从原始 &lt;code&gt;*const c_char&lt;/code&gt; 不安全地构造它。然后可以通过执行UTF-8验证将其转换为Rust &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;，或者转换为拥有的&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="020b3bfb2ee1251c34f42849931a1e6222269e82" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e18df5bb8ad819c600cd4afb1d82afc59b7f998" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a string in the operating system's preferred representation.</source>
          <target state="translated">该类型表示在操作系统的首选表示法中对字符串的借用引用。</target>
        </trans-unit>
        <trans-unit id="6142b61fe2d2c68dea4ad8a85d9dc10ccc2f98b3" translate="yes" xml:space="preserve">
          <source>This type represents a stack backtrace for an OS thread captured at a previous point in time. In some instances the &lt;code&gt;Backtrace&lt;/code&gt; type may internally be empty due to configuration. For more information see &lt;code&gt;Backtrace::capture&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b774085d693678b6b309fbc90af8e885fb4742c" translate="yes" xml:space="preserve">
          <source>This type represents the status code a process can return to its parent under normal termination.</source>
          <target state="translated">此类型表示一个进程在正常终止时可以返回其父进程的状态码。</target>
        </trans-unit>
        <trans-unit id="8b966cfbeebcefe7f0330e7e9f54f7098bf1152f" translate="yes" xml:space="preserve">
          <source>This type serves the purpose of being able to safely generate a C-compatible string from a Rust byte slice or vector. An instance of this type is a static guarantee that the underlying bytes contain no interior 0 bytes (&quot;nul characters&quot;) and that the final byte is 0 (&quot;nul terminator&quot;).</source>
          <target state="translated">这个类型的作用是能够从 Rust 字节片或向量中安全地生成一个 C 兼容的字符串,这个类型的实例是静态地保证底层字节不包含内部 0 字节 (&quot;nul 字符&quot;),并且最后一个字节是 0 (&quot;nul 终结符&quot;)。这个类型的实例是静态保证,底层字节不包含内部0字节(&quot;nul字符&quot;),最后一个字节是0(&quot;nul终结符&quot;)。</target>
        </trans-unit>
        <trans-unit id="7d87337ad285058ac7367e471ff8622a41dfdd71" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or  on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="translated">这个类型支持多个操作的用于检查的路径，包括破路径成它的组分（由分离 &lt;code&gt;/&lt;/code&gt; Unix和由任一 &lt;code&gt;/&lt;/code&gt; 或Windows），提取的文件名，在确定路径是否是绝对的，等等。</target>
        </trans-unit>
        <trans-unit id="5d992ca66aeeffa4346515aab9e07f94a5a7aea4" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22ec26e83b1f093f0fa10a8ffd75ef588107911" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="translated">此类型几乎总是&lt;a href=&quot;../../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt;，可以保证是Rust中的&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754单精度浮点数&lt;/a&gt;。也就是说，该标准从技术上仅保证它是浮点数，并且它的精度可能低于 &lt;code&gt;f32&lt;/code&gt; 或根本不遵循IEEE-754标准。</target>
        </trans-unit>
        <trans-unit id="b34eb94d33cfcd2b81be054dc12a48e0b5f8dc2f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="translated">这种类型几乎总是&lt;a href=&quot;../../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt;，可以保证是Rust中的&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754双精度浮点数&lt;/a&gt;。也就是说，该标准从技术上仅保证它是至少具有&lt;a href=&quot;type.c_float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;精度的浮点数，并且它可以是 &lt;code&gt;f32&lt;/code&gt; 或与IEEE-754标准完全不同的东西。</target>
        </trans-unit>
        <trans-unit id="2713919b8810fb3f44c86782b09415ed3b59cda3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="translated">这种类型几乎总是&lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt;，但在某些深奥的系统上可能有所不同。C标准从技术上仅要求此类型是至少16位的有符号整数；例如，某些系统可能将其定义为 &lt;code&gt;i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0d84326d8675408ac530de354cda2d1a8ac7eb3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">这种类型几乎总是&lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;，但是在某些深奥的系统上可能有所不同。从技术上讲，C标准仅要求这种类型是一个有符号的整数，其长度至少为&lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt;的大小; 例如，某些系统将其定义为&lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab581f0ea98e052030c778602ef0ca98c399648d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.i128&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">这种类型几乎总是&lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;，但在某些系统上可能有所不同。C标准从技术上仅要求此类型为至少64位且至少为&lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt;大小的有符号整数，尽管在实践中，没有任何系统具有不为 &lt;code&gt;i64&lt;/code&gt; 的 &lt;code&gt;long long&lt;/code&gt; ，因为大多数系统都没有具有标准化的&lt;a href=&quot;../../primitive.i128&quot;&gt; &lt;code&gt;i128&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="15b5edcf451c79ce2991144552b8f569664ab769" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这种类型几乎总是&lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;，但在某些深奥的系统上可能有所不同。C标准从技术上仅要求此类型是无符号整数，并且其大小与&lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="8ba1b7005ffb5ad84714cb0adcd9cce8dfd29a44" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">这种类型几乎总是&lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;，但在某些深奥的系统上可能有所不同。C标准从技术上仅要求此类型是与&lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;大小相同的无符号整数；例如，某些系统将其定义为&lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10f7763a2c07ba8b71ea9cbe73fe235f098f6f03" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.u128&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">此类型几乎总是&lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt;，但在某些系统上可能有所不同。从技术上讲，C标准仅要求此类型是无符号整数，并且具有&lt;a href=&quot;type.c_longlong&quot;&gt; &lt;code&gt;long long&lt;/code&gt; &lt;/a&gt;的大小，尽管在实践中，没有系统会具有不是 &lt;code&gt;u64&lt;/code&gt; 的 &lt;code&gt;long long&lt;/code&gt; ，因为大多数系统都没有标准化的&lt;a href=&quot;../../primitive.u128&quot;&gt; &lt;code&gt;u128&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="62b8bfd925dec29031c9f9af8d15530118a5f2ce" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c674b282d61f34daea9ef2ee13aae39fb8505b63" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f64.html&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8042a19bb3c7392d0a03d8aac515052ed54c02" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5a6e28ddb1307caa7a25d8ee94ecc741d04f02" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab7786704bfcc1276eecf70ffb134c89a7de414" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i128.html&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d3f0d1d67d74135ffdd410a290383d90e8fe31" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202dca95d3eb592c40ce655fef3c1ec8be90922f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469cb3e6510770c6f62e6ffb0ed8eda80a71067d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u128.html&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf97ad06e74edf68697dac1b4dcee83cfa2a22b5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="translated">此类型将始终为&lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;。最值得注意的是，许多基于Linux的系统都采用 &lt;code&gt;i64&lt;/code&gt; ，而Windows则采用 &lt;code&gt;i32&lt;/code&gt; 。C标准技术只要求这种类型为带符号整数，它是至少32位和中的至少大小&lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;，虽然在实践中，没有系统将有一个 &lt;code&gt;long&lt;/code&gt; 既不是 &lt;code&gt;i32&lt;/code&gt; 也不 &lt;code&gt;i64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7164487891e0a7833d4edf15c16beda44c3572d5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型将始终为&lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt;，但为了完整性起见将其包括在内。它定义为与C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;大小相同的有符号整数。</target>
        </trans-unit>
        <trans-unit id="9ffb84596c9e59eea63cf919456fbd81bc2d5347" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="translated">这种类型的永远是&lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;还是&lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt;。最值得注意的是，许多基于Linux的系统承担 &lt;code&gt;u64&lt;/code&gt; ，但Windows假定 &lt;code&gt;u32&lt;/code&gt; 。C标准技术只要求这种类型是具有的尺寸的无符号整数&lt;a href=&quot;type.c_long&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt;，虽然在实践中，没有系统将具有 &lt;code&gt;ulong&lt;/code&gt; 既不是 &lt;code&gt;u32&lt;/code&gt; 也不 &lt;code&gt;u64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="702c3c35c3eb36099eb087128d0090cf4cdc5cb9" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型将始终为&lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;，但为了完整性起见包含此类型。它被定义为与C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;大小相同的无符号整数。</target>
        </trans-unit>
        <trans-unit id="3bd4e6f17c1fadac181d74e7c6fccf81e88a4338" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d40fc3671ec7ae824bd7929d61ce78e74ef07a2" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i8.html&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f45d2d1c5aca56d0bed11f4011cece6101639" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb106d3debd5b58c7a1ae3e283c55499cf8e5484" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4424cbb3fbb90751454ec3bf9577dceb9d9a320d" translate="yes" xml:space="preserve">
          <source>This typedef is generally used to avoid writing out &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt; directly and is otherwise a direct mapping to &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常使用这种typedef来避免直接写出&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt;，否则直接映射到&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9571d5615d4085a615ed7c5ad4cadc1ded956713" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it read a particular number of bytes but only a smaller number of bytes could be read.</source>
          <target state="translated">这通常意味着一个操作只有在读取特定数量的字节时才能成功,但只能读取较少数量的字节。</target>
        </trans-unit>
        <trans-unit id="692f047748f56fd7b6dd085f2d1ee90a117e619a" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it wrote a particular number of bytes but only a smaller number of bytes could be written.</source>
          <target state="translated">这通常意味着一个操作只有在写入特定数量的字节时才能成功,但只能写入较少数量的字节。</target>
        </trans-unit>
        <trans-unit id="066666922981580e3c6ec7b57246e05ce6d242d4" translate="yes" xml:space="preserve">
          <source>This usage of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create safe nullable pointers is so common that Rust does special optimizations to make the representation of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type.</source>
          <target state="translated">的这种用法&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;创建平安可空指针是很常见的，不生锈特殊的优化，使的表示&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 一个指针。Rust中的可选指针与任何其他指针类型一样有效地存储。</target>
        </trans-unit>
        <trans-unit id="3473dac5d293883be110e74db63b95a407d1ea5c" translate="yes" xml:space="preserve">
          <source>This usage of &lt;code&gt;extern&lt;/code&gt; does not require &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;extern&lt;/code&gt; 不需要 &lt;code&gt;unsafe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d52ccca3efa09c9ce1760baf0a04fa97e3aed552" translate="yes" xml:space="preserve">
          <source>This use of a &lt;code&gt;where&lt;/code&gt; clause is strange - a more common usage would look something like the following:</source>
          <target state="translated">对 &lt;code&gt;where&lt;/code&gt; 子句的这种用法很奇怪-更为常见的用法如下所示：</target>
        </trans-unit>
        <trans-unit id="3ee77b0606c712a9409edf4f68e92618c8d2ee4a" translate="yes" xml:space="preserve">
          <source>This value is not suitable for passing to &lt;code&gt;Path::new&lt;/code&gt; or similar constructors when the host platform and target platform differ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ededb49250daf0db79bbb927c06d879d238521da" translate="yes" xml:space="preserve">
          <source>This value sets the time-to-live field that is used in every packet sent from this socket.</source>
          <target state="translated">这个值设置了从这个套接字发送的每个数据包所使用的活期时间字段。</target>
        </trans-unit>
        <trans-unit id="75beec589ecae6a039a7d01c52fb4b4aea8d427f" translate="yes" xml:space="preserve">
          <source>This value should be considered only a hint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d769cb0769d945ca70d65f4d25befb01295f124d" translate="yes" xml:space="preserve">
          <source>This variant is also constructed when a &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; is misplaced within a string either on its own or in the middle of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413d9b4dc5521012c4ffcf2dbef4c140f61e2a52" translate="yes" xml:space="preserve">
          <source>This variant is the most common one, it represents references to files or directories.</source>
          <target state="translated">这个变体是最常见的,它代表对文件或目录的引用。</target>
        </trans-unit>
        <trans-unit id="8ad9c1ff17fcdcd8bc09eee76d183971a27c0cfe" translate="yes" xml:space="preserve">
          <source>This variant will be emitted when the parsing string has a value of zero, which would be illegal for non-zero types.</source>
          <target state="translated">当解析字符串的值为零时,这个变体将被发出,这对于非零类型来说是非法的。</target>
        </trans-unit>
        <trans-unit id="f262b16f3428e356cf4b0dde5dbe8613ec4091d5" translate="yes" xml:space="preserve">
          <source>This version of the text assumes you&amp;rsquo;re using Rust 1.41.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e89485f5fe729fa0419251d6d1b6a0bc0fb1791" translate="yes" xml:space="preserve">
          <source>This version of the text assumes you&amp;rsquo;re using Rust 1.41.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676fb636ec3ef59315a4dc9ef64f5fbe3403351d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0051a5a0c2153685b22e3e481253428438ae9b0d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;code&gt;CString&lt;/code&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">这样， &lt;code&gt;CString&lt;/code&gt; 在 &lt;code&gt;hello&lt;/code&gt; 中的生存期包含 &lt;code&gt;ptr&lt;/code&gt; 和 &lt;code&gt;unsafe&lt;/code&gt; 块的生存期。</target>
        </trans-unit>
        <trans-unit id="6a66e53cbccdcf1dd0b129068e28220aa1da407b" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be23e02db6f58e9303929f35bcf996dc6954c461" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87576c37932e7e920719c7c3053295204953101" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">这将总是&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c37af121800fff05f23ea7195ec86eae7b112d6" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt;</source>
          <target state="translated">这将总是&lt;a href=&quot;macro.panic&quot;&gt;惊慌！&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7ba30b4423020d7c6174593849644ce672a970c" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt; because &lt;code&gt;unimplemented!&lt;/code&gt; is just a shorthand for &lt;code&gt;panic!&lt;/code&gt; with a fixed, specific message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9dc67930c6219a678b4690efb3c9a2b4b3cc3e" translate="yes" xml:space="preserve">
          <source>This will be a max-heap.</source>
          <target state="translated">这将是一个最大的堆。</target>
        </trans-unit>
        <trans-unit id="835f899ffcb476aee6b318f9e24a76f9e21b8043" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61949&quot;&gt;issue-61949&lt;/a&gt; for this limitation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850691bcf932c0c55cd89eb4535ca90e22acf61f" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the tracking issue for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49146&quot;&gt;conditionals&lt;/a&gt; or &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;loops&lt;/a&gt; in a const context for the current status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fffbe8e22b797d8b6890d54d873414453d3490a" translate="yes" xml:space="preserve">
          <source>This will cause an error:</source>
          <target state="translated">这将导致一个错误。</target>
        </trans-unit>
        <trans-unit id="5b06471f77c7403c58187c73c7a664a50663e032" translate="yes" xml:space="preserve">
          <source>This will commonly, but not always, be a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; or &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常，但并非总是如此，它是 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 或&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a8b17614cf7c240a7a1eb116da8eea5f59c7b71" translate="yes" xml:space="preserve">
          <source>This will compile, because it has the constraint on the type parameter:</source>
          <target state="translated">这将被编译,因为它有类型参数的约束。</target>
        </trans-unit>
        <trans-unit id="3520fed49c822ab60288ef2f8f669d15b4a41e6f" translate="yes" xml:space="preserve">
          <source>This will compile:</source>
          <target state="translated">这样就可以编译了。</target>
        </trans-unit>
        <trans-unit id="49cc821a81b4f339dbb259efc2d82e6ee470759f" translate="yes" xml:space="preserve">
          <source>This will create a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This conversion is very inexpensive, and so generally, functions will accept &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific reason.</source>
          <target state="translated">这将创建一个&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;从 &lt;code&gt;String&lt;/code&gt; ，并传递它，这种转换是非常便宜，所以一般情况下，功能将接受&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; S作为参数，除非他们需要一个 &lt;code&gt;String&lt;/code&gt; 因为某种特定原因。</target>
        </trans-unit>
        <trans-unit id="1b5cc9b9f228f1bae8ee73a71afeed4d549dd793" translate="yes" xml:space="preserve">
          <source>This will create a thread using default parameters of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt;, if you want to specify the stack size or the name of the thread, use this API instead.</source>
          <target state="translated">这将使用&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; 的&lt;/a&gt;默认参数创建一个线程，如果您想指定堆栈大小或线程名称，请改用此API。</target>
        </trans-unit>
        <trans-unit id="e391cc107c46641450ffa0654fcfb8cbca70a73b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../rc/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">这将减少强引用计数。如果强引用计数达到零，那么仅有的其他引用（如果有）为&lt;a href=&quot;../rc/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;，因此我们 &lt;code&gt;drop&lt;/code&gt; 内部值。</target>
        </trans-unit>
        <trans-unit id="97b7f84f70f9d3f5d6303968924e2733780bc78b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../sync/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">这将减少强引用计数。如果强引用计数达到零，那么仅有的其他引用（如果有）为&lt;a href=&quot;../sync/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;，因此我们 &lt;code&gt;drop&lt;/code&gt; 内部值。</target>
        </trans-unit>
        <trans-unit id="b917396cbcb63b72ec008aadc499d642c7abbf61" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">这将减少强引用计数。如果强引用计数达到零，那么仅有的其他引用（如果有）为&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;，因此我们 &lt;code&gt;drop&lt;/code&gt; 内部值。</target>
        </trans-unit>
        <trans-unit id="0e9819c7b2177172935ef1092ecc4f74eaf1578f" translate="yes" xml:space="preserve">
          <source>This will drop any excess capacity.</source>
          <target state="translated">这将掉落任何多余的容量。</target>
        </trans-unit>
        <trans-unit id="354a015dbdb2ab35ae4e0b061d1f50f5025f7cbe" translate="yes" xml:space="preserve">
          <source>This will escape characters with the Rust syntax of the form &lt;code&gt;\u{NNNNNN}&lt;/code&gt; where &lt;code&gt;NNNNNN&lt;/code&gt; is a hexadecimal representation.</source>
          <target state="translated">这将使用 &lt;code&gt;\u{NNNNNN}&lt;/code&gt; 格式的Rust语法转义字符，其中 &lt;code&gt;NNNNNN&lt;/code&gt; 是十六进制表示形式。</target>
        </trans-unit>
        <trans-unit id="c51882eef9b6927fb20dc2b079d5f33d822ffcef" translate="yes" xml:space="preserve">
          <source>This will escape the characters similar to the &lt;code&gt;Debug&lt;/code&gt; implementations of &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">这将转义类似于 &lt;code&gt;str&lt;/code&gt; 或 &lt;code&gt;char&lt;/code&gt; 的 &lt;code&gt;Debug&lt;/code&gt; 实现的字符。</target>
        </trans-unit>
        <trans-unit id="7463a3fbad059d7822b7a64865f64ec71f56ca6c" translate="yes" xml:space="preserve">
          <source>This will fail because the compiler does not know which instance of &lt;code&gt;Foo&lt;/code&gt; to call &lt;code&gt;bar&lt;/code&gt; on. Change &lt;code&gt;Foo::bar()&lt;/code&gt; to &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; to resolve the error.</source>
          <target state="translated">这将失败，因为编译器不知道在哪个 &lt;code&gt;Foo&lt;/code&gt; 实例上调用 &lt;code&gt;bar&lt;/code&gt; 。将 &lt;code&gt;Foo::bar()&lt;/code&gt; 更改为 &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; 可解决该错误。</target>
        </trans-unit>
        <trans-unit id="b95565727f175f666e1822f4733ae91ef6a1780e" translate="yes" xml:space="preserve">
          <source>This will fail to compile because we cannot implement a trait for a type if both the trait and the type are not defined by the current crate. This is due to Rust's orphaning rules. To bypass this, you can implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">这将无法编译，因为如果当前包装箱中未同时定义特征和类型，则无法为该类型实现特征。这是由于Rust的孤立规则。要绕过它，您可以直接实现&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8648eb6ea2730446e0cfb046319d740aba54d8bb" translate="yes" xml:space="preserve">
          <source>This will fail to compile in older versions of the language because Rust's orphaning rules used to be a little bit more strict. To bypass this, you could implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c41f14d1e2c5310aaa0b927129f701a7031c03a" translate="yes" xml:space="preserve">
          <source>This will invoke the &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; macro if the provided expression cannot be evaluated to &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">这会引起&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;如果提供的表达式无法在运行时评估为 &lt;code&gt;true&lt;/code&gt; ，则为宏。</target>
        </trans-unit>
        <trans-unit id="2deb5f847f234caa59a2e70f4ab65edaeb2fdead" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet.</source>
          <target state="translated">如果这个线程还没有引用这个键,这将懒惰地初始化这个值。</target>
        </trans-unit>
        <trans-unit id="2be746d77ee47101c5a961aeebfbec50b6101d49" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an &lt;a href=&quot;struct.accesserror&quot;&gt;&lt;code&gt;AccessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该线程尚未引用此键，则将延迟初始化该值。如果密钥已被销毁（如果在析构函数中调用此密钥，则可能会发生），此函数将返回&lt;a href=&quot;struct.accesserror&quot;&gt; &lt;code&gt;AccessError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3800eafd69cf59aa81eb6bb72cb9493004b5c43e" translate="yes" xml:space="preserve">
          <source>This will make &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; persist for the remainder of your shell session. It can be unset with the &lt;code&gt;Remove-Item&lt;/code&gt; cmdlet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b457d7ac05dde73ffae7dfa5283d452dba90a68" translate="yes" xml:space="preserve">
          <source>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</source>
          <target state="translated">这不会打印任何值,因为我们只是创建了一个迭代器,而不是使用它。编译器会警告我们这种行为。</target>
        </trans-unit>
        <trans-unit id="7884f03c74d608aa53fe96a0fe19b6f01fc64a4e" translate="yes" xml:space="preserve">
          <source>This will not work if the new name is on a different mount point.</source>
          <target state="translated">如果新名称在不同的挂载点上,这将无法使用。</target>
        </trans-unit>
        <trans-unit id="29502fa64160996ff78f02e55cbb4b83b39e3b0d" translate="yes" xml:space="preserve">
          <source>This will not:</source>
          <target state="translated">这不会。</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">这将输出以下内容。</target>
        </trans-unit>
        <trans-unit id="01e646d50274ee113a75cb82fc9f837874518988" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;append&lt;/code&gt; flags on the &lt;code&gt;OpenOptions&lt;/code&gt; structure. This method provides fine-grained control over the permissions to read, write and append data, attributes (like hidden and system), and extended attributes.</source>
          <target state="translated">这将覆盖 &lt;code&gt;OpenOptions&lt;/code&gt; 结构上的 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;append&lt;/code&gt; 标志。此方法提供对读取，写入和附加数据，属性（如隐藏属性和系统属性）和扩展属性的权限的细粒度控制。</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475997c398cd5b2921c0cb8cd3f062a1e5e787e7" translate="yes" xml:space="preserve">
          <source>This will print &quot;('a', 1), ('b', 2), ('c', 3)&quot;.</source>
          <target state="translated">这将打印&quot;('a',1),('b',2),('c',3)&quot;。</target>
        </trans-unit>
        <trans-unit id="3a5f8c78def77453ab00074a3cd30ff4dd27218b" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, each on their own line.</source>
          <target state="translated">这将打印 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;5&lt;/code&gt; ，每行一行。</target>
        </trans-unit>
        <trans-unit id="45cc5d4168a6948db8686b2c0a8d37fbb64175cc" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt;.</source>
          <target state="translated">这将打印 &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3cd6bbcdf4b75c4bbd0f80ed7b9518ac88ecb8" translate="yes" xml:space="preserve">
          <source>This will print the numbers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt;, each on their own line.</source>
          <target state="translated">这将在各自的行上打印数字 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a40fac0ea22a56e98579c9cc97554e4f4a65b5bb" translate="yes" xml:space="preserve">
          <source>This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?</source>
          <target state="translated">这将打印出1到5的数字,每个数字都在它们自己的行上。但是你会注意到一些东西:我们从来没有在我们的向量上调用任何东西来产生迭代器。那是什么原因呢?</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">这将打印。</target>
        </trans-unit>
        <trans-unit id="e3f9d6eebc7d0a9c3006485e1bf2fe9250c18991" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;send&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">这将导致 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; ， &lt;code&gt;recv&lt;/code&gt; 和 &lt;code&gt;send&lt;/code&gt; 操作变得无阻塞，即立即从其调用返回。如果IO操作成功，则返回 &lt;code&gt;Ok&lt;/code&gt; ，并且无需采取进一步措施。如果IO操作无法完成并且需要重试，则返回类型为&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;的错误。</target>
        </trans-unit>
        <trans-unit id="4b3da21af1f8f50bfb5fb08b425cfbfeb0c3196a" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;recv&lt;/code&gt;, &lt;code&gt;recv_from&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;send_to&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">这将导致 &lt;code&gt;recv&lt;/code&gt; ， &lt;code&gt;recv_from&lt;/code&gt; ， &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;send_to&lt;/code&gt; 操作变为非阻塞，即立即从其调用返回。如果IO操作成功，则返回 &lt;code&gt;Ok&lt;/code&gt; ，无需采取进一步措施。如果IO操作无法完成并且需要重试，则返回类型为&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;的错误。</target>
        </trans-unit>
        <trans-unit id="5f9e536d8780a7dfeadd69ff71cc712be79eb591" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../../../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e7ab507f523fe704d7f615781e7105b958a139" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">这将导致 &lt;code&gt;accept&lt;/code&gt; 操作变得非阻塞，即立即从其调用返回。如果IO操作成功，则返回 &lt;code&gt;Ok&lt;/code&gt; ，无需采取进一步措施。如果IO操作无法完成并且需要重试，则返回类型为&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;的错误。</target>
        </trans-unit>
        <trans-unit id="b55e73be7a2382bca6297d35304f77d90844f6fa" translate="yes" xml:space="preserve">
          <source>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</source>
          <target state="translated">这将检索存储在底层套接字中的错误,并在过程中清除该字段。这对于在调用之间检查错误很有用。</target>
        </trans-unit>
        <trans-unit id="88ce8a4d0f2f6725fab10313d205fd945723d024" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Metadata&lt;/code&gt; instance was created from a call to &lt;code&gt;DirEntry::metadata&lt;/code&gt;. If this &lt;code&gt;Metadata&lt;/code&gt; was created by using &lt;code&gt;fs::metadata&lt;/code&gt; or &lt;code&gt;File::metadata&lt;/code&gt;, then this will return &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f194e7c7453fbebb97c4d612baa72decde0dd60" translate="yes" xml:space="preserve">
          <source>This will return an error when the IP version of the local socket does not match that returned from &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当本地套接字的IP版本与&lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt;返回的IP版本不匹配时，这将返回错误。</target>
        </trans-unit>
        <trans-unit id="fc0cdcc30572aec7d1df1cbb47d079cf5a14ac66" translate="yes" xml:space="preserve">
          <source>This will succeed even if there are outstanding weak references.</source>
          <target state="translated">即使有突出的弱项参考,也会成功。</target>
        </trans-unit>
        <trans-unit id="2bd1f4c0ae47dc79d8ec8c7bba4ba6b5d8664eba" translate="yes" xml:space="preserve">
          <source>This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers.</source>
          <target state="translated">这将使用 &lt;code&gt;clone&lt;/code&gt; 来复制表达式，因此应谨慎使用具有非标准 &lt;code&gt;Clone&lt;/code&gt; 实现的类型。例如， &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; 将创建一个向量，其中有五个引用指向相同的装箱整数值，而不是五个引用指向独立装箱整数的值。</target>
        </trans-unit>
        <trans-unit id="1af0f8715542d97c1e40ad188906242d9ebb10f7" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;Box&lt;/code&gt; is a pointer, so its size is well-known.</source>
          <target state="translated">之所以 &lt;code&gt;Box&lt;/code&gt; 是因为Box是一个指针，因此它的大小是众所周知的。</target>
        </trans-unit>
        <trans-unit id="e6ae7145b95212826784b081e816d005693796fd" translate="yes" xml:space="preserve">
          <source>This works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the &lt;code&gt;Screen&lt;/code&gt; struct using a generic type and a trait bound as in Listing 17-6:</source>
          <target state="translated">这与定义使用带有特征边界的泛型类型参数的结构的工作方式不同。泛型类型参数一次只能用一种具体类型代替，而特征对象允许在运行时为特征对象填充多种具体类型。例如，我们可以使用通用类型和特征绑定来定义 &lt;code&gt;Screen&lt;/code&gt; 结构，如清单17-6所示：</target>
        </trans-unit>
        <trans-unit id="a99f3af5ecd17821d147ce27f764af7ca400396e" translate="yes" xml:space="preserve">
          <source>This works fine, but when the method gains generic parameters, we can have a problem.</source>
          <target state="translated">这很好用,但当方法获得通用参数时,我们就会出现问题。</target>
        </trans-unit>
        <trans-unit id="d71531129bdd4b29a09ed683d862d9540e2e5d1c" translate="yes" xml:space="preserve">
          <source>This works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data &lt;em&gt;does&lt;/em&gt; get copied.</source>
          <target state="translated">这工作得很好，并且显式地产生了图4-3所示的行为，在该行为中&lt;em&gt;确实&lt;/em&gt;复制了堆数据。</target>
        </trans-unit>
        <trans-unit id="bfbfb994099b13008a48f4d00df577d26e30661c" translate="yes" xml:space="preserve">
          <source>This works without any problems. Ownership is moved out, and nothing is deallocated.</source>
          <target state="translated">这个工作没有任何问题。所有权被迁出,没有任何东西被转移。</target>
        </trans-unit>
        <trans-unit id="6c438e4eca96ad10f658e6fd464bdd00bbab9e0b" translate="yes" xml:space="preserve">
          <source>This wrapper helps with explicitly documenting the drop order dependencies between fields of the type:</source>
          <target state="translated">这个包装器有助于显式地记录该类型字段之间的顺序依赖关系。</target>
        </trans-unit>
        <trans-unit id="77c94458816b78e926120564c533b185a38f9981" translate="yes" xml:space="preserve">
          <source>This wrapper is 0-cost.</source>
          <target state="translated">这个包装物是0成本的。</target>
        </trans-unit>
        <trans-unit id="bb9a9b150cc6f7bfa7d25085c5da29bd09b9aebf" translate="yes" xml:space="preserve">
          <source>This zero-sized type &lt;em&gt;coerces&lt;/em&gt; to a regular function pointer. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf6fbbeb84fc23d69997d38f588cc8535a0a6a" translate="yes" xml:space="preserve">
          <source>Though they both have scary names, &lt;code&gt;PhantomData&lt;/code&gt; and 'phantom types' are related, but not identical. A phantom type parameter is simply a type parameter which is never used. In Rust, this often causes the compiler to complain, and the solution is to add a &quot;dummy&quot; use by way of &lt;code&gt;PhantomData&lt;/code&gt;.</source>
          <target state="translated">尽管它们都有可怕的名称，但 &lt;code&gt;PhantomData&lt;/code&gt; 和&amp;ldquo;幻像类型&amp;rdquo;是相关的，但并不完全相同。幻像类型参数只是从未使用过的类型参数。在Rust中，这通常会导致编译器抱怨，解决方案是通过 &lt;code&gt;PhantomData&lt;/code&gt; 添加&amp;ldquo;虚拟&amp;rdquo;使用。</target>
        </trans-unit>
        <trans-unit id="394004c26aaecc036ffcf91c8fc18935b18646a0" translate="yes" xml:space="preserve">
          <source>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</source>
          <target state="translated">虽然这个例子看起来很无害,也很容易解决,但当遇到消耗值的函数时,问题就很明显了。</target>
        </trans-unit>
        <trans-unit id="68fc8c5fcce31dacdf37236f648493191d2504be" translate="yes" xml:space="preserve">
          <source>Though this method is safe for any two pointers, note that its result will be mostly useless if the two pointers aren't into the same allocated object, for example if they point to two different local variables.</source>
          <target state="translated">虽然这个方法对任何两个指针都是安全的,但要注意的是,如果两个指针不是进入同一个分配的对象,比如它们指向两个不同的局部变量,那么这个方法的结果将大部分是无用的。</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">螺纹安全</target>
        </trans-unit>
        <trans-unit id="8acbe8abc881f5530528aa5ba52eb0a3d5f4e21c" translate="yes" xml:space="preserve">
          <source>Thread factory, which can be used in order to configure the properties of a new thread.</source>
          <target state="translated">线程工厂,可以用来配置新线程的属性。</target>
        </trans-unit>
        <trans-unit id="3f259cba637903dc7da0506c4d921b66c4b2c1d2" translate="yes" xml:space="preserve">
          <source>Thread with a specified name:</source>
          <target state="translated">有指定名称的线程。</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">线程本地存储</target>
        </trans-unit>
        <trans-unit id="031ccc205829651d22cb916d91b65f0a8f208375" translate="yes" xml:space="preserve">
          <source>Thread::borrow</source>
          <target state="translated">Thread::borrow</target>
        </trans-unit>
        <trans-unit id="c95c792ba6b184afddca7a8e36aefd1fbf1d6ade" translate="yes" xml:space="preserve">
          <source>Thread::borrow_mut</source>
          <target state="translated">Thread::borrow_mut</target>
        </trans-unit>
        <trans-unit id="dbb6daabaec761c7c46cdca4426de7d2af20b09f" translate="yes" xml:space="preserve">
          <source>Thread::clone</source>
          <target state="translated">Thread::clone</target>
        </trans-unit>
        <trans-unit id="e27a758e7d203684411b93372f7af767f3888a92" translate="yes" xml:space="preserve">
          <source>Thread::clone_from</source>
          <target state="translated">Thread::clone_from</target>
        </trans-unit>
        <trans-unit id="21aa2dd81c0fa05128232b310f0bc9892cddef0b" translate="yes" xml:space="preserve">
          <source>Thread::clone_into</source>
          <target state="translated">Thread::clone_into</target>
        </trans-unit>
        <trans-unit id="070b95410e1e4362fb02748c2208a536c3a47c62" translate="yes" xml:space="preserve">
          <source>Thread::fmt</source>
          <target state="translated">Thread::fmt</target>
        </trans-unit>
        <trans-unit id="15bec62911f03b003cb69d406b3848ca01770f8f" translate="yes" xml:space="preserve">
          <source>Thread::from</source>
          <target state="translated">Thread::from</target>
        </trans-unit>
        <trans-unit id="4a91eeba81f613beaaf6029aae0e32dad80d38b8" translate="yes" xml:space="preserve">
          <source>Thread::id</source>
          <target state="translated">Thread::id</target>
        </trans-unit>
        <trans-unit id="b2a4ffaaac236ade773000faaa7bef3c1f0cc8f6" translate="yes" xml:space="preserve">
          <source>Thread::into</source>
          <target state="translated">Thread::into</target>
        </trans-unit>
        <trans-unit id="344f7d7a1faf3f99cb05399e695391adc35f7d18" translate="yes" xml:space="preserve">
          <source>Thread::name</source>
          <target state="translated">Thread::name</target>
        </trans-unit>
        <trans-unit id="2dcbcae4f337ba144bfa61f602dbf53a215ffbaa" translate="yes" xml:space="preserve">
          <source>Thread::to_owned</source>
          <target state="translated">Thread::to_owned</target>
        </trans-unit>
        <trans-unit id="08e8a562777dded639d27f7f44cfadcf3bf00a5e" translate="yes" xml:space="preserve">
          <source>Thread::try_from</source>
          <target state="translated">Thread::try_from</target>
        </trans-unit>
        <trans-unit id="ea003eda575d811cf577619ef02836592885180a" translate="yes" xml:space="preserve">
          <source>Thread::try_into</source>
          <target state="translated">Thread::try_into</target>
        </trans-unit>
        <trans-unit id="ee3875fc112ad5bc121f3e391fcecb3da4daa377" translate="yes" xml:space="preserve">
          <source>Thread::type_id</source>
          <target state="translated">Thread::type_id</target>
        </trans-unit>
        <trans-unit id="a2b67a0f80271fce8e8b3bd5ec25f2445ebea8c7" translate="yes" xml:space="preserve">
          <source>Thread::unpark</source>
          <target state="translated">Thread::unpark</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="e1f6247a7eef6633e4e5d83608be9b3187e0c969" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow</source>
          <target state="translated">ThreadId::borrow</target>
        </trans-unit>
        <trans-unit id="22f5c0c99a3c51f5db8e51f093d172c44439f9bc" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow_mut</source>
          <target state="translated">ThreadId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f272ac73f50e66007497d727840b4334ee1f128b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone</source>
          <target state="translated">ThreadId::clone</target>
        </trans-unit>
        <trans-unit id="6c35d53945f00e081a8257913c3ad292495b0c89" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_from</source>
          <target state="translated">ThreadId::clone_from</target>
        </trans-unit>
        <trans-unit id="9abe12a7685c82abc8d5bcbb6509a690fccefb0b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_into</source>
          <target state="translated">ThreadId::clone_into</target>
        </trans-unit>
        <trans-unit id="1fcd1d752fe2d53f1b3acff5f74fcaa56fbea5a4" translate="yes" xml:space="preserve">
          <source>ThreadId::eq</source>
          <target state="translated">ThreadId::eq</target>
        </trans-unit>
        <trans-unit id="02c70e2223708a5777dae53420e0c974498720e0" translate="yes" xml:space="preserve">
          <source>ThreadId::fmt</source>
          <target state="translated">ThreadId::fmt</target>
        </trans-unit>
        <trans-unit id="b838b903c39a24240409358be89ed6329a9df09a" translate="yes" xml:space="preserve">
          <source>ThreadId::from</source>
          <target state="translated">ThreadId::from</target>
        </trans-unit>
        <trans-unit id="ddc023441f52408bece6bf2ff774b50209750066" translate="yes" xml:space="preserve">
          <source>ThreadId::hash</source>
          <target state="translated">ThreadId::hash</target>
        </trans-unit>
        <trans-unit id="8244a05f09ebefd9016fbce0f8394db6f762584b" translate="yes" xml:space="preserve">
          <source>ThreadId::hash_slice</source>
          <target state="translated">ThreadId::hash_slice</target>
        </trans-unit>
        <trans-unit id="fd5bfcfa29d7d00b83774a3201acbc0e51fa4872" translate="yes" xml:space="preserve">
          <source>ThreadId::into</source>
          <target state="translated">ThreadId::into</target>
        </trans-unit>
        <trans-unit id="a87f4470467c3e753de867438c3b5d2edf68e527" translate="yes" xml:space="preserve">
          <source>ThreadId::ne</source>
          <target state="translated">ThreadId::ne</target>
        </trans-unit>
        <trans-unit id="3cd41ae993fc3fddaa9fb843d50a8938bb01dd02" translate="yes" xml:space="preserve">
          <source>ThreadId::to_owned</source>
          <target state="translated">ThreadId::to_owned</target>
        </trans-unit>
        <trans-unit id="c7ce06f7b4875caccd8b2ef7310bb3589387aaa7" translate="yes" xml:space="preserve">
          <source>ThreadId::try_from</source>
          <target state="translated">ThreadId::try_from</target>
        </trans-unit>
        <trans-unit id="1723d15638b0712b0610f447b496de925bf9fce1" translate="yes" xml:space="preserve">
          <source>ThreadId::try_into</source>
          <target state="translated">ThreadId::try_into</target>
        </trans-unit>
        <trans-unit id="586fd641683540c80a212ba3dd698b0a2d8e64c3" translate="yes" xml:space="preserve">
          <source>ThreadId::type_id</source>
          <target state="translated">ThreadId::type_id</target>
        </trans-unit>
        <trans-unit id="c8f829eec28b00e160b939476f6112a322b89854" translate="yes" xml:space="preserve">
          <source>Threads are able to have associated names for identification purposes. By default, spawned threads are unnamed. To specify a name for a thread, build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired thread name to &lt;a href=&quot;struct.builder#method.name&quot;&gt;&lt;code&gt;Builder::name&lt;/code&gt;&lt;/a&gt;. To retrieve the thread name from within the thread, use &lt;a href=&quot;struct.thread#method.name&quot;&gt;&lt;code&gt;Thread::name&lt;/code&gt;&lt;/a&gt;. A couple examples of where the name of a thread gets used:</source>
          <target state="translated">线程能够具有关联的名称以用于识别。默认情况下，生成的线程是未命名的。要为线程指定名称，请使用&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt;构建线程，然后将所需的线程名称传递给&lt;a href=&quot;struct.builder#method.name&quot;&gt; &lt;code&gt;Builder::name&lt;/code&gt; &lt;/a&gt;。要从线程内部检索线程名称，请使用&lt;a href=&quot;struct.thread#method.name&quot;&gt; &lt;code&gt;Thread::name&lt;/code&gt; &lt;/a&gt;。几个使用线程名称的地方的例子：</target>
        </trans-unit>
        <trans-unit id="fac19ffa706cd7f7c61cd4298da14db7d3225341" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; type, which you can get in one of two ways:</source>
          <target state="translated">线程通过&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;类型表示，您可以通过以下两种方式之一来获取：</target>
        </trans-unit>
        <trans-unit id="dfac2e4a30b24c7a0b51fc7ce730d2b041ad7fac" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;code&gt;Thread&lt;/code&gt; type, which you can get in one of two ways:</source>
          <target state="translated">线程通过 &lt;code&gt;Thread&lt;/code&gt; 类型表示，您可以通过以下两种方式之一来获取：</target>
        </trans-unit>
        <trans-unit id="61ca9f4a8a357e814dec07995e4960f9fb1789c1" translate="yes" xml:space="preserve">
          <source>Threads by default have no name specified:</source>
          <target state="translated">默认情况下,线程没有指定名称。</target>
        </trans-unit>
        <trans-unit id="968a06f03211a8e28589507e83ecbad68bacd321" translate="yes" xml:space="preserve">
          <source>Three examples of &lt;code&gt;extern crate&lt;/code&gt; declarations:</source>
          <target state="translated">&lt;code&gt;extern crate&lt;/code&gt; 声明的三个示例：</target>
        </trans-unit>
        <trans-unit id="adf3f084c350f9e4e1af9b596fea76609465c5c2" translate="yes" xml:space="preserve">
          <source>Throughout the book, you&amp;rsquo;ve seen examples of many kinds of patterns. In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</source>
          <target state="translated">在整本书中，您已经看到了多种模式的示例。在本节中，我们收集了模式中所有有效的语法，并讨论了为什么可能要使用每个语法。</target>
        </trans-unit>
        <trans-unit id="60bf7601d61de03ae0783bd8d23bcd9c972360eb" translate="yes" xml:space="preserve">
          <source>Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;. Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">在整个文档中，我们将遵循一些约定。对于所有操作，集合的大小用n表示。如果该操作涉及另一个集合，则它包含m个元素。带有&lt;em&gt;摊余&lt;/em&gt;成本的工序带有 &lt;code&gt;*&lt;/code&gt; 后缀。&lt;em&gt;预期&lt;/em&gt;成本的运算后带有 &lt;code&gt;~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="238f30330684e8f9c133d5faa32478b32bb7092d" translate="yes" xml:space="preserve">
          <source>Throughout this book, we&amp;rsquo;ve used &lt;code&gt;let&lt;/code&gt; like this hundreds of times, and although you might not have realized it, you were using patterns! More formally, a &lt;code&gt;let&lt;/code&gt; statement looks like this:</source>
          <target state="translated">在本书中，我们已经使用 &lt;code&gt;let&lt;/code&gt; 了数百次，尽管您可能没有意识到，但是您正在使用模式！更正式地说， &lt;code&gt;let&lt;/code&gt; 语句如下所示：</target>
        </trans-unit>
        <trans-unit id="3b79edbe5b3429757c6a6c5658f9e500a2a9f5f8" translate="yes" xml:space="preserve">
          <source>Thus the pattern of &lt;code&gt;yield&lt;/code&gt;ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.</source>
          <target state="translated">因此，在实现低级共享资源或同步原语时，轮询失败后的 &lt;code&gt;yield&lt;/code&gt; 模式相当普遍。</target>
        </trans-unit>
        <trans-unit id="821dfcf79b1432754988865d9447fbfdba546e04" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ref&lt;/code&gt; is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</source>
          <target state="translated">因此， &lt;code&gt;ref&lt;/code&gt; 不是要匹配的对象。其目的专门是使匹配的绑定成为参考，而不是潜在地复制或移动匹配的内容。</target>
        </trans-unit>
        <trans-unit id="f25396ffdb747466e5fd6748ffb6e2945d105f98" translate="yes" xml:space="preserve">
          <source>Thus, a sensible way to handle a thread panic is to either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="667c88e4323d998577ae614b3d0f0d63105deed4" translate="yes" xml:space="preserve">
          <source>Time complexity</source>
          <target state="translated">时间复杂度</target>
        </trans-unit>
        <trans-unit id="87e54a385b9de69cf35ac4ab359d69ed9aa1950a" translate="yes" xml:space="preserve">
          <source>To &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;</source>
          <target state="translated">要 &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; 还是不要 &lt;code&gt;panic!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c0ba38264d0a297ae9df50179b24027837bbba6" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;RHS&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">要添加 &lt;code&gt;Millimeters&lt;/code&gt; 和 &lt;code&gt;Meters&lt;/code&gt; ，我们指定 &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; 来设置 &lt;code&gt;RHS&lt;/code&gt; 类型参数的值，而不是使用默认的 &lt;code&gt;Self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cba3d2f6052bb257fd3b265e03522cd76a90182d" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;Rhs&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e27f28761495c993b1d146a55214b33393a503" translate="yes" xml:space="preserve">
          <source>To allow customization in specific cases most users won&amp;rsquo;t need</source>
          <target state="translated">要允许在特定情况下进行自定义，大多数用户不需要</target>
        </trans-unit>
        <trans-unit id="b1d5c30e2acf4bd68628daf0a08fcdb7d03b4380" translate="yes" xml:space="preserve">
          <source>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</source>
          <target state="translated">为了帮助进行适当的设计,下面的场景被明确声明为单线程代码的合法场景。</target>
        </trans-unit>
        <trans-unit id="3ff5f80d30f1f493faf134bdcac7192bc4fe0c89" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Arc&lt;/code&gt; using &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt;&lt;code&gt;Arc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了避免内存泄漏的指针必须被转换回一 &lt;code&gt;Arc&lt;/code&gt; 使用&lt;a href=&quot;struct.arc#method.from_raw&quot;&gt; &lt;code&gt;Arc::from_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1e40b418899dc58e251a0e3e3662f5034b84fa8" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Rc&lt;/code&gt; using &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt;&lt;code&gt;Rc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了避免内存泄漏的指针必须被转换回一个 &lt;code&gt;Rc&lt;/code&gt; 使用&lt;a href=&quot;struct.rc#method.from_raw&quot;&gt; &lt;code&gt;Rc::from_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a5ee855a608ecd864fa2e7b73853f23dfbb067b" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; references that alias, the returned slice borrows its lifetime from the iterator the method is applied on.</source>
          <target state="translated">为避免创建引用该别名的 &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; ，返回的切片从应用该方法的迭代器借用其生存期。</target>
        </trans-unit>
        <trans-unit id="ffa0cd99296c4663ce93793ddad7c9407847a5e2" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut&lt;/code&gt; references that alias, this is forced to consume the iterator.</source>
          <target state="translated">为了避免创建 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 别名的＆mut引用，这被强制使用迭代器。</target>
        </trans-unit>
        <trans-unit id="1aefc821eaa401be8625ea8100fecfc992fdeed8" translate="yes" xml:space="preserve">
          <source>To avoid having &lt;code&gt;common&lt;/code&gt; appear in the test output, instead of creating &lt;em&gt;tests/common.rs&lt;/em&gt;, we&amp;rsquo;ll create &lt;em&gt;tests/common/mod.rs&lt;/em&gt;. This is an alternate naming convention that Rust also understands. Naming the file this way tells Rust not to treat the &lt;code&gt;common&lt;/code&gt; module as an integration test file. When we move the &lt;code&gt;setup&lt;/code&gt; function code into &lt;em&gt;tests/common/mod.rs&lt;/em&gt; and delete the &lt;em&gt;tests/common.rs&lt;/em&gt; file, the section in the test output will no longer appear. Files in subdirectories of the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t get compiled as separate crates or have sections in the test output.</source>
          <target state="translated">为了避免 &lt;code&gt;common&lt;/code&gt; 出现在测试输出，而不是创建&lt;em&gt;测试/ common.rs&lt;/em&gt;，我们将创建&lt;em&gt;测试/普通/ mod.rs&lt;/em&gt;。这是Rust也可以理解的另一种命名约定。用这种方式命名文件告诉Rust不要将 &lt;code&gt;common&lt;/code&gt; 模块视为集成测试文件。当我们将 &lt;code&gt;setup&lt;/code&gt; 功能代码移至&lt;em&gt;tests / common / mod.rs&lt;/em&gt;并删除&lt;em&gt;tests / common.rs&lt;/em&gt;文件时，测试输出中的部分将不再出现。&lt;em&gt;测试&lt;/em&gt;目录子目录中的文件不会被编译为单独的板条箱，也不会在测试输出中包含节。</target>
        </trans-unit>
        <trans-unit id="3621c2a13fc7da454e2221c729cf687e93b1bda8" translate="yes" xml:space="preserve">
          <source>To avoid it, you have to replace the non-constant value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7a1a1787370230342d01e7d26cc5eb0fdaf231" translate="yes" xml:space="preserve">
          <source>To avoid the error there are a couple of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1645dd8754fa06f0f760253ea0a8f05162d861bf" translate="yes" xml:space="preserve">
          <source>To avoid this error, first bind the temporary to a named local variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ceede3cc5738536ea015edb67ed85c3d3dcd2e" translate="yes" xml:space="preserve">
          <source>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</source>
          <target state="translated">为了避免这个错误,你必须只保留其中的一个,而删除其他的。所以,让我们拿我们的例子来修复它。</target>
        </trans-unit>
        <trans-unit id="a30b99a191595831b8cb7e0383bc895012a3666a" translate="yes" xml:space="preserve">
          <source>To avoid this kind of error, ensure that at least one local type is referenced by the &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">为了避免这种错误，请确保 &lt;code&gt;impl&lt;/code&gt; 引用了至少一个本地类型：</target>
        </trans-unit>
        <trans-unit id="a83579bf275c61511e259b0f6a5393712638d88c" translate="yes" xml:space="preserve">
          <source>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</source>
          <target state="translated">为了避免这些问题,你必须让类型正确匹配。所以我们可以像这样修复前面的例子。</target>
        </trans-unit>
        <trans-unit id="8cca79e59af2d0e450f9f7893d8b74973a17a0c1" translate="yes" xml:space="preserve">
          <source>To be able to index into a type it needs to implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait. Example:</source>
          <target state="translated">为了能够索引到类型，它需要实现 &lt;code&gt;std::ops::Index&lt;/code&gt; 特性。例：</target>
        </trans-unit>
        <trans-unit id="e0c4569eca23f12e74ce8e43ea0b16ae30221104" translate="yes" xml:space="preserve">
          <source>To be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.</source>
          <target state="translated">要说明的是:大多数功能将在所有版本上都可用。使用任何Rust版本的开发者都会随着新的稳定版本的发布而继续看到改进。然而,在某些情况下,主要是当新的关键字被添加时,一些新功能可能只在以后的版本中可用。如果您想利用这些功能,您需要切换版本。</target>
        </trans-unit>
        <trans-unit id="28519d7825ab9ef768276a220fcc5248c6cfd08d" translate="yes" xml:space="preserve">
          <source>To be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.</source>
          <target state="translated">一个匹配器必须满足以下三个不变量才有效。FIRST和FOLLOW的定义将在后面描述。</target>
        </trans-unit>
        <trans-unit id="4dcb6216e57dabede5c512636b8402fc6577f67d" translate="yes" xml:space="preserve">
          <source>To better understand how these work in Rust, read the &lt;a href=&quot;book/ch13-01-closures&quot;&gt;Closures&lt;/a&gt; chapter of the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27f02149ea4da378573490ec467ba6b8b5c842f" translate="yes" xml:space="preserve">
          <source>To better understand why we need two separate loops, imagine a scenario with two workers. If we used a single loop to iterate through each worker, on the first iteration a terminate message would be sent down the channel and &lt;code&gt;join&lt;/code&gt; called on the first worker&amp;rsquo;s thread. If that first worker was busy processing a request at that moment, the second worker would pick up the terminate message from the channel and shut down. We would be left waiting on the first worker to shut down, but it never would because the second thread picked up the terminate message. Deadlock!</source>
          <target state="translated">为了更好地理解为什么我们需要两个单独的循环，请设想一个有两个工作人员的场景。如果我们使用单个循环迭代每个工作程序，则在第一个迭代中，终止消息将在通道上发送，并在第一个工作程序的线程上调用 &lt;code&gt;join&lt;/code&gt; 。如果第一位员工当时正忙于处理请求，则第二位员工将从通道中接收终止消息并关闭。我们将等待第一个工作程序关闭，但绝不会因为第二个线程接收到了终止消息。僵局！</target>
        </trans-unit>
        <trans-unit id="a92bd1b796549d070a95e516f74d8da028284983" translate="yes" xml:space="preserve">
          <source>To bind the matched value of a pattern to a variable, use the syntax &lt;code&gt;variable @ subpattern&lt;/code&gt;. For example, the following binds the value 2 to &lt;code&gt;e&lt;/code&gt; (not the entire range: the range here is a range subpattern).</source>
          <target state="translated">要将模式的匹配值绑定到变量，请使用语法 &lt;code&gt;variable @ subpattern&lt;/code&gt; 。例如，以下内容将值2绑定到 &lt;code&gt;e&lt;/code&gt; （而不是整个范围：此​​处的范围是范围子模式）。</target>
        </trans-unit>
        <trans-unit id="b830c9413c38579d4ef7795bcf7bbde269208939" translate="yes" xml:space="preserve">
          <source>To build or modify paths, use &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要构建或修改路径，请使用&lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bfa1e223892bc7e4bd4f7e711edfd1f7972be85d" translate="yes" xml:space="preserve">
          <source>To calculate the layout of a &lt;code&gt;#[repr(C)]&lt;/code&gt; structure and the offsets of the fields from its fields' layouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a716f5c06d1b56904d9c9ecdfaef8a89e71a7435" translate="yes" xml:space="preserve">
          <source>To calculate the value of &lt;code&gt;prediction&lt;/code&gt;, this code iterates through each of the 12 values in &lt;code&gt;coefficients&lt;/code&gt; and uses the &lt;code&gt;zip&lt;/code&gt; method to pair the coefficient values with the previous 12 values in &lt;code&gt;buffer&lt;/code&gt;. Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum &lt;code&gt;qlp_shift&lt;/code&gt; bits to the right.</source>
          <target state="translated">为了计算 &lt;code&gt;prediction&lt;/code&gt; 值，此代码循环访问 &lt;code&gt;coefficients&lt;/code&gt; 中的12个值，并使用 &lt;code&gt;zip&lt;/code&gt; 方法将系数值与 &lt;code&gt;buffer&lt;/code&gt; 的前12个值配对。然后，对于每一对，我们将这些值相乘，对所有结果求和，然后将求和 &lt;code&gt;qlp_shift&lt;/code&gt; 位中的位右移。</target>
        </trans-unit>
        <trans-unit id="e1e36c60ac0b0cf3c0b11863470e32d28a059d98" translate="yes" xml:space="preserve">
          <source>To call the &lt;code&gt;fly&lt;/code&gt; methods from either the &lt;code&gt;Pilot&lt;/code&gt; trait or the &lt;code&gt;Wizard&lt;/code&gt; trait, we need to use more explicit syntax to specify which &lt;code&gt;fly&lt;/code&gt; method we mean. Listing 19-18 demonstrates this syntax.</source>
          <target state="translated">要从&amp;ldquo; &lt;code&gt;Pilot&lt;/code&gt; 特征或&amp;ldquo; &lt;code&gt;Wizard&lt;/code&gt; 特征调用 &lt;code&gt;fly&lt;/code&gt; 方法，我们需要使用更明确的语法来指定我们所指的 &lt;code&gt;fly&lt;/code&gt; 方法。清单19-18演示了这种语法。</target>
        </trans-unit>
        <trans-unit id="5c07c5eaca75954c044b220e0d9378c6ce45b1a4" translate="yes" xml:space="preserve">
          <source>To call this associated function, we use the &lt;code&gt;::&lt;/code&gt; syntax with the struct name; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; is an example. This function is namespaced by the struct: the &lt;code&gt;::&lt;/code&gt; syntax is used for both associated functions and namespaces created by modules. We&amp;rsquo;ll discuss modules in Chapter 7.</source>
          <target state="translated">要调用此关联函数，我们将 &lt;code&gt;::&lt;/code&gt; 语法与结构名一起使用； &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; 是一个例子。这个功能是通过该结构的命名空间：在 &lt;code&gt;::&lt;/code&gt; 语法用于通过模块创建的两个相关联的功能和命名空间。我们将在第7章中讨论模块。</target>
        </trans-unit>
        <trans-unit id="191c93d8beeacd6897f106d1c47af3f257c7dd5f" translate="yes" xml:space="preserve">
          <source>To call this code with only those types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we can add &lt;code&gt;Copy&lt;/code&gt; to the trait bounds of &lt;code&gt;T&lt;/code&gt;! Listing 10-15 shows the complete code of a generic &lt;code&gt;largest&lt;/code&gt; function that will compile as long as the types of the values in the slice that we pass into the function implement the &lt;code&gt;PartialOrd&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Copy&lt;/code&gt; traits, like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; do.</source>
          <target state="translated">要仅使用实现 &lt;code&gt;Copy&lt;/code&gt; 特征的那些类型来调用此代码，我们可以将 &lt;code&gt;Copy&lt;/code&gt; 添加到 &lt;code&gt;T&lt;/code&gt; 的特征边界！清单10-15显示了一个通用的 &lt;code&gt;largest&lt;/code&gt; 函数的完整代码，只要我们传递给该函数的slice中的值的类型实现 &lt;code&gt;PartialOrd&lt;/code&gt; &lt;em&gt;和&lt;/em&gt; &lt;code&gt;Copy&lt;/code&gt; 特性，就可以编译该代码，例如 &lt;code&gt;i32&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; do。</target>
        </trans-unit>
        <trans-unit id="2ae7caef9479d77c77a3d3a0a7f430defd27a454" translate="yes" xml:space="preserve">
          <source>To change the value that the mutable reference refers to, we have to use the dereference operator (&lt;code&gt;*&lt;/code&gt;) to get to the value in &lt;code&gt;i&lt;/code&gt; before we can use the &lt;code&gt;+=&lt;/code&gt; operator. We&amp;rsquo;ll talk more about the dereference operator in the &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;Following the Pointer to the Value with the Dereference Operator&amp;rdquo;&lt;/a&gt; section of Chapter 15.</source>
          <target state="translated">要更改可变引用所引用的值，必须先使用解引用运算符（ &lt;code&gt;*&lt;/code&gt; ）来获取 &lt;code&gt;i&lt;/code&gt; 中的值，然后才能使用 &lt;code&gt;+=&lt;/code&gt; 运算符。我们将在第15章的&lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;使用指向&lt;/a&gt;引用运算符跟随指针到值&amp;rdquo;部分中详细讨论指向引用运算符。</target>
        </trans-unit>
        <trans-unit id="8d0f5fc712b1dc8e53a799fd7ad61e2d58ce4f6e" translate="yes" xml:space="preserve">
          <source>To check the type for the return type of a function with multiple return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff93ea5d521caed491ca6edf931b71effa3ca726" translate="yes" xml:space="preserve">
          <source>To check whether you have Rust installed correctly, open a shell and enter this line:</source>
          <target state="translated">要检查你是否正确安装了Rust,打开一个shell并输入这一行。</target>
        </trans-unit>
        <trans-unit id="b81a5a29868dab97f44f48c2bd716ec3edc16d7e" translate="yes" xml:space="preserve">
          <source>To combine &lt;code&gt;repr(transparent)&lt;/code&gt; with type parameters, &lt;code&gt;PhantomData&lt;/code&gt; may be useful:</source>
          <target state="translated">要将 &lt;code&gt;repr(transparent)&lt;/code&gt; 与类型参数结合使用， &lt;code&gt;PhantomData&lt;/code&gt; 可能有用：</target>
        </trans-unit>
        <trans-unit id="ac3f03b22205947cc54e2019b2f0993969841a80" translate="yes" xml:space="preserve">
          <source>To confuse things further, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;on the Web&lt;/a&gt;&lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, and &lt;code&gt;windows-1252&lt;/code&gt; are all aliases for a superset of Windows-1252 that fills the remaining blanks with corresponding C0 and C1 control codes.</source>
          <target state="translated">更令人困惑的是，&lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;在Web &lt;/a&gt; &lt;code&gt;ascii&lt;/code&gt; 上， &lt;code&gt;iso-8859-1&lt;/code&gt; 和 &lt;code&gt;windows-1252&lt;/code&gt; 都是Windows-1252超集的别名，该超集用相应的C0和C1控制代码填充了其余空白。</target>
        </trans-unit>
        <trans-unit id="9e961e97b1bab5bb4d05da5fe7c2fc74357a8b93" translate="yes" xml:space="preserve">
          <source>To consume the old state, the &lt;code&gt;request_review&lt;/code&gt; method needs to take ownership of the state value. This is where the &lt;code&gt;Option&lt;/code&gt; in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; comes in: we call the &lt;code&gt;take&lt;/code&gt; method to take the &lt;code&gt;Some&lt;/code&gt; value out of the &lt;code&gt;state&lt;/code&gt; field and leave a &lt;code&gt;None&lt;/code&gt; in its place, because Rust doesn&amp;rsquo;t let us have unpopulated fields in structs. This lets us move the &lt;code&gt;state&lt;/code&gt; value out of &lt;code&gt;Post&lt;/code&gt; rather than borrowing it. Then we&amp;rsquo;ll set the post&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; value to the result of this operation.</source>
          <target state="translated">要使用旧状态， &lt;code&gt;request_review&lt;/code&gt; 方法需要取得状态值的所有权。这是该 &lt;code&gt;Option&lt;/code&gt; 的 &lt;code&gt;state&lt;/code&gt; 的领域 &lt;code&gt;Post&lt;/code&gt; 进来：我们所说的 &lt;code&gt;take&lt;/code&gt; 方法采取 &lt;code&gt;Some&lt;/code&gt; 价值出来的 &lt;code&gt;state&lt;/code&gt; 领域，并留下一个 &lt;code&gt;None&lt;/code&gt; 在它的位置，因为锈病不会让我们在结构无人居住领域。这使我们可以将 &lt;code&gt;state&lt;/code&gt; 值移出 &lt;code&gt;Post&lt;/code&gt; 而不是借用它。然后，我们将帖子的 &lt;code&gt;state&lt;/code&gt; 值设置为此操作的结果。</target>
        </trans-unit>
        <trans-unit id="f337e083c37a19b6c9f78383e9d486a4274f1380" translate="yes" xml:space="preserve">
          <source>To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise &quot;you used a private item of another module and weren't allowed to.&quot;</source>
          <target state="translated">为了控制接口是否可以跨模块使用,Rust会检查每一个项的使用情况,看是否应该被允许。这时就会产生隐私警告,否则就会出现 &quot;你使用了另一个模块的私有项目,但不允许 &quot;的情况。</target>
        </trans-unit>
        <trans-unit id="ba21f5abea5c571067a1a7d57de3d3aa5bc54641" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;../string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">要将单个值转换为字符串，请使用&lt;a href=&quot;../string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt;方法。这将使用&lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;格式特征。</target>
        </trans-unit>
        <trans-unit id="3cb338cb9ed195af952f18624a8d65c1ca64787f" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">要将单个值转换为字符串，请使用&lt;a href=&quot;string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt;方法。这将使用&lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;格式特征。</target>
        </trans-unit>
        <trans-unit id="015234ea3f6220712aedf5ea26711d734042f76e" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;match&lt;/code&gt; expression that compares the values of the outer &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We&amp;rsquo;ll talk about match guards later in the &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;Extra Conditionals with Match Guards&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">要创建一个比较外部 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的值的 &lt;code&gt;match&lt;/code&gt; 表达式，而不是引入阴影变量，我们需要使用匹配保护条件。稍后，我们将在&lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;带有&lt;/a&gt;防卫队​​的附加条件&amp;rdquo;部分中讨论防卫队。</target>
        </trans-unit>
        <trans-unit id="d6a361bf034a44065bf4d983adf9bd5159e505a7" translate="yes" xml:space="preserve">
          <source>To create a new thread, we call the &lt;code&gt;thread::spawn&lt;/code&gt; function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</source>
          <target state="translated">为了创建一个新线程，我们调用 &lt;code&gt;thread::spawn&lt;/code&gt; 函数，并给它传递一个闭包（我们在第13章中讨论了闭包），其中包含了我们要在新线程中运行的代码。清单16-1中的示例打印主线程中的一些文本，以及新线程中的其他文本：</target>
        </trans-unit>
        <trans-unit id="aa89b2295fcdc6f9c080aa3a4a8e8468c77980e1" translate="yes" xml:space="preserve">
          <source>To create a new, empty vector, we can call the &lt;code&gt;Vec::new&lt;/code&gt; function, as shown in Listing 8-1.</source>
          <target state="translated">要创建一个新的空向量，我们可以调用 &lt;code&gt;Vec::new&lt;/code&gt; 函数，如清单8-1所示。</target>
        </trans-unit>
        <trans-unit id="1a88aa76c7ad4f90214c55053637e980f11dd3a9" translate="yes" xml:space="preserve">
          <source>To create a vector and then add elements to it, we can use the &lt;code&gt;push&lt;/code&gt; method, as shown in Listing 8-3.</source>
          <target state="translated">要创建一个向量，然后向其中添加元素，我们可以使用 &lt;code&gt;push&lt;/code&gt; 方法，如清单8-3所示。</target>
        </trans-unit>
        <trans-unit id="00c0015adacecd8350d6133979871ae1b1edfe94" translate="yes" xml:space="preserve">
          <source>To define a &lt;code&gt;Point&lt;/code&gt; struct where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we can change the definition of &lt;code&gt;Point&lt;/code&gt; to be generic over types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">要定义 &lt;code&gt;Point&lt;/code&gt; 结构，其中 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都是泛型但可以具有不同的类型，我们可以使用多个泛型类型参数。例如，清单10-8，我们可以改变的定义 &lt;code&gt;Point&lt;/code&gt; 到超过类型通用 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 其中 &lt;code&gt;x&lt;/code&gt; 是式 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是类型的 &lt;code&gt;U&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48e3d6adfbf70e45f3b29de0115bced82f45c8ba" translate="yes" xml:space="preserve">
          <source>To define a macro, you use the &lt;code&gt;macro_rules!&lt;/code&gt; construct. Let&amp;rsquo;s explore how to use &lt;code&gt;macro_rules!&lt;/code&gt; by looking at how the &lt;code&gt;vec!&lt;/code&gt; macro is defined. Chapter 8 covered how we can use the &lt;code&gt;vec!&lt;/code&gt; macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:</source>
          <target state="translated">要定义宏，请使用 &lt;code&gt;macro_rules!&lt;/code&gt; 构造。让我们探索如何使用 &lt;code&gt;macro_rules!&lt;/code&gt; 通过看如何 &lt;code&gt;vec!&lt;/code&gt; 宏已定义。第8章介绍了如何使用 &lt;code&gt;vec!&lt;/code&gt; 宏以创建具有特定值的新向量。例如，下面的宏创建一个包含三个整数的新向量：</target>
        </trans-unit>
        <trans-unit id="0305c11d131bdcb2f62d25c1e047d31c7b279a29" translate="yes" xml:space="preserve">
          <source>To define a struct, we enter the keyword &lt;code&gt;struct&lt;/code&gt; and name the entire struct. A struct&amp;rsquo;s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call &lt;em&gt;fields&lt;/em&gt;. For example, Listing 5-1 shows a struct that stores information about a user account.</source>
          <target state="translated">要定义一个结构，我们输入关键字 &lt;code&gt;struct&lt;/code&gt; 并命名整个结构。结构的名称应描述分组在一起的数据的重要性。然后，在大括号内，定义数据段的名称和类型，我们将其称为&lt;em&gt;field&lt;/em&gt;。例如，清单5-1显示了一个存储有关用户帐户信息的结构。</target>
        </trans-unit>
        <trans-unit id="8f9b83d2cc8d6fc88b967504ac913c99c3032360" translate="yes" xml:space="preserve">
          <source>To define a tuple struct, start with the &lt;code&gt;struct&lt;/code&gt; keyword and the struct name followed by the types in the tuple. For example, here are definitions and usages of two tuple structs named &lt;code&gt;Color&lt;/code&gt; and &lt;code&gt;Point&lt;/code&gt;:</source>
          <target state="translated">要定义元组结构，请以 &lt;code&gt;struct&lt;/code&gt; 关键字和结构名称开头，后跟元组中的类型。例如，以下是两个名为 &lt;code&gt;Color&lt;/code&gt; 和 &lt;code&gt;Point&lt;/code&gt; 的元组结构的定义和用法：</target>
        </trans-unit>
        <trans-unit id="bf22e9ab26d9ba6ee6b2e46fe0b19d5124fc0343" translate="yes" xml:space="preserve">
          <source>To define the function within the context of &lt;code&gt;Rectangle&lt;/code&gt;, we start an &lt;code&gt;impl&lt;/code&gt; (implementation) block. Then we move the &lt;code&gt;area&lt;/code&gt; function within the &lt;code&gt;impl&lt;/code&gt; curly brackets and change the first (and in this case, only) parameter to be &lt;code&gt;self&lt;/code&gt; in the signature and everywhere within the body. In &lt;code&gt;main&lt;/code&gt;, where we called the &lt;code&gt;area&lt;/code&gt; function and passed &lt;code&gt;rect1&lt;/code&gt; as an argument, we can instead use &lt;em&gt;method syntax&lt;/em&gt; to call the &lt;code&gt;area&lt;/code&gt; method on our &lt;code&gt;Rectangle&lt;/code&gt; instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</source>
          <target state="translated">为了在 &lt;code&gt;Rectangle&lt;/code&gt; 的上下文中定义函数，我们启动一个 &lt;code&gt;impl&lt;/code&gt; （实现）块。然后，我们将 &lt;code&gt;area&lt;/code&gt; 函数移动到 &lt;code&gt;impl&lt;/code&gt; 大括号内，并将第一个（在这种情况下，仅）参数更改为签名中以及正文中各处的 &lt;code&gt;self&lt;/code&gt; 。在 &lt;code&gt;main&lt;/code&gt; 中，我们调用了 &lt;code&gt;area&lt;/code&gt; 函数并传递了 &lt;code&gt;rect1&lt;/code&gt; 作为参数，我们可以改用&lt;em&gt;方法语法&lt;/em&gt;在 &lt;code&gt;Rectangle&lt;/code&gt; 实例上调用 &lt;code&gt;area&lt;/code&gt; 方法。方法的语法在实例之后：我们在方法名称，括号和任何参数后面添加一个点。</target>
        </trans-unit>
        <trans-unit id="2de6b544c44b76668f6d2936d8d501f7f9f3abad" translate="yes" xml:space="preserve">
          <source>To demonstrate how to run a subset of tests, we&amp;rsquo;ll create three tests for our &lt;code&gt;add_two&lt;/code&gt; function, as shown in Listing 11-11, and choose which ones to run.</source>
          <target state="translated">为了演示如何运行测试的子集，我们将为 &lt;code&gt;add_two&lt;/code&gt; 函数创建三个测试，如清单11-11所示，然后选择要运行的测试。</target>
        </trans-unit>
        <trans-unit id="e75dc3dfe6b153a0ceea282766b5c4d1615452e1" translate="yes" xml:space="preserve">
          <source>To demonstrate, let&amp;rsquo;s create an iterator that will only ever count from 1 to 5. First, we&amp;rsquo;ll create a struct to hold some values. Then we&amp;rsquo;ll make this struct into an iterator by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait and using the values in that implementation.</source>
          <target state="translated">为了演示，让我们创建一个只会从1到5计数的迭代器。首先，我们将创建一个结构来保存一些值。然后，通过实现 &lt;code&gt;Iterator&lt;/code&gt; trait并使用该实现中的值，使该结构成为迭代器。</target>
        </trans-unit>
        <trans-unit id="b6b548838142d67d34f12bfbc64f7cdb12a47cc6" translate="yes" xml:space="preserve">
          <source>To determine how much space to allocate for a &lt;code&gt;Message&lt;/code&gt; value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that &lt;code&gt;Message::Quit&lt;/code&gt; doesn&amp;rsquo;t need any space, &lt;code&gt;Message::Move&lt;/code&gt; needs enough space to store two &lt;code&gt;i32&lt;/code&gt; values, and so forth. Because only one variant will be used, the most space a &lt;code&gt;Message&lt;/code&gt; value will need is the space it would take to store the largest of its variants.</source>
          <target state="translated">为了确定为 &lt;code&gt;Message&lt;/code&gt; 值分配多少空间，Rust会遍历每个变体以查看哪个变体需要最多的空间。 Rust看到 &lt;code&gt;Message::Quit&lt;/code&gt; 不需要任何空间， &lt;code&gt;Message::Move&lt;/code&gt; 需要足够的空间来存储两个 &lt;code&gt;i32&lt;/code&gt; 值，依此类推。因为将仅使用一个变体，所以 &lt;code&gt;Message&lt;/code&gt; 值所需的最大空间就是存储最大变体所需的空间。</target>
        </trans-unit>
        <trans-unit id="375df8edff8c14a24952e9e1d54e255a42b357a9" translate="yes" xml:space="preserve">
          <source>To determine if a &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, we need to check if &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. However, to do this check, we need to determine that &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. To determine this, we check if &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, and so on. This is clearly a recursive requirement that can't be resolved directly.</source>
          <target state="translated">要确定 &lt;code&gt;T&lt;/code&gt; 是否为 &lt;code&gt;Foo&lt;/code&gt; ，我们需要检查 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 是否为 &lt;code&gt;Foo&lt;/code&gt; 。但是，要执行此检查，我们需要确定 &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 是 &lt;code&gt;Foo&lt;/code&gt; 。为了确定这一点，我们检查 &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 是否为 &lt;code&gt;Foo&lt;/code&gt; ，依此类推。显然，这是一个递归要求，无法直接解决。</target>
        </trans-unit>
        <trans-unit id="b8666f35753eb530d957bee0ef54848c41571aca" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要确定 &lt;code&gt;Duration&lt;/code&gt; 表示的总秒数，请结合使用 &lt;code&gt;as_secs&lt;/code&gt; 和&lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="08d2c31864b299072e74b4018700dfb17575ecb3" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c73fc588227a5e5b304d8e85115a9b2d547b13e" translate="yes" xml:space="preserve">
          <source>To determine whether to use loops or iterators, you need to know which version of our &lt;code&gt;search&lt;/code&gt; functions is faster: the version with an explicit &lt;code&gt;for&lt;/code&gt; loop or the version with iterators.</source>
          <target state="translated">要确定是使用循环还是迭代器，您需要知道 &lt;code&gt;search&lt;/code&gt; 功能的哪个版本更快：带显式 &lt;code&gt;for&lt;/code&gt; 循环的版本或带迭代器的版本。</target>
        </trans-unit>
        <trans-unit id="235f6ddc8fb93b9bc27bd450e93516c6f056381f" translate="yes" xml:space="preserve">
          <source>To disambiguate and tell Rust that we want to use the implementation of &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt;, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</source>
          <target state="translated">为了消除歧义并告诉Rust我们要使用 &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt; 的实现，我们需要使用完全限定的语法。清单19-21演示了如何使用完全限定的语法。</target>
        </trans-unit>
        <trans-unit id="f6bc5e83e5f978fc7521ec1ad0ec48fc0bc1e6d4" translate="yes" xml:space="preserve">
          <source>To do this in a language with inheritance, we might define a class named &lt;code&gt;Component&lt;/code&gt; that has a method named &lt;code&gt;draw&lt;/code&gt; on it. The other classes, such as &lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Image&lt;/code&gt;, and &lt;code&gt;SelectBox&lt;/code&gt;, would inherit from &lt;code&gt;Component&lt;/code&gt; and thus inherit the &lt;code&gt;draw&lt;/code&gt; method. They could each override the &lt;code&gt;draw&lt;/code&gt; method to define their custom behavior, but the framework could treat all of the types as if they were &lt;code&gt;Component&lt;/code&gt; instances and call &lt;code&gt;draw&lt;/code&gt; on them. But because Rust doesn&amp;rsquo;t have inheritance, we need another way to structure the &lt;code&gt;gui&lt;/code&gt; library to allow users to extend it with new types.</source>
          <target state="translated">要使用具有继承性的语言来执行此操作，我们可以定义一个名为 &lt;code&gt;Component&lt;/code&gt; 的类，该类具有一个名为 &lt;code&gt;draw&lt;/code&gt; 的方法。其他类（例如 &lt;code&gt;Button&lt;/code&gt; ， &lt;code&gt;Image&lt;/code&gt; 和 &lt;code&gt;SelectBox&lt;/code&gt; )将从 &lt;code&gt;Component&lt;/code&gt; 继承，从而继承 &lt;code&gt;draw&lt;/code&gt; 方法。他们可以在每个覆盖的 &lt;code&gt;draw&lt;/code&gt; 方法来定义自己的定制行为，但框架可以治疗所有类型的，好像他们是 &lt;code&gt;Component&lt;/code&gt; 实例并调用 &lt;code&gt;draw&lt;/code&gt; 他们。但是因为Rust没有继承，所以我们需要另一种方式来构造 &lt;code&gt;gui&lt;/code&gt; 库，以允许用户使用新类型扩展它。</target>
        </trans-unit>
        <trans-unit id="4978131923d35532be220aa91636f57efe0f7f12" translate="yes" xml:space="preserve">
          <source>To easily implement the Clone trait, you can also use &lt;code&gt;#[derive(Clone)]&lt;/code&gt;. Example:</source>
          <target state="translated">为了轻松实现Clone特质，您还可以使用 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="d0cd2dd965d6ad9f646e83059dd95c728c0a97cf" translate="yes" xml:space="preserve">
          <source>To eliminate this duplication, we can create an abstraction by defining a function that operates on any list of integers given to it in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.</source>
          <target state="translated">为了消除这种重复,我们可以通过定义一个函数来创建一个抽象的概念,这个函数可以对参数中给它的任何整数列表进行操作。这个解决方案使我们的代码更加清晰,让我们可以抽象地表达在列表中寻找最大数字的概念。</target>
        </trans-unit>
        <trans-unit id="29cf48fa5d156f2e83366c6a4eab852452303d3f" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;minigrep&lt;/code&gt; to read the values of command line arguments we pass to it, we&amp;rsquo;ll need a function provided in Rust&amp;rsquo;s standard library, which is &lt;code&gt;std::env::args&lt;/code&gt;. This function returns an iterator of the command line arguments that were given to &lt;code&gt;minigrep&lt;/code&gt;. We&amp;rsquo;ll cover iterators fully in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the &lt;code&gt;collect&lt;/code&gt; method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.</source>
          <target state="translated">为了使 &lt;code&gt;minigrep&lt;/code&gt; 能够读取传递给它的命令行参数的值，我们需要Rust的标准库中提供的函数 &lt;code&gt;std::env::args&lt;/code&gt; 。此函数返回给 &lt;code&gt;minigrep&lt;/code&gt; 的命令行参数的迭代器。我们将在&lt;a href=&quot;ch13-00-functional-features&quot;&gt;第13章中&lt;/a&gt;全面介绍迭代器。现在，您只需要了解有关迭代器的两个细节：迭代器会生成一系列值，并且我们可以在迭代器上调用 &lt;code&gt;collect&lt;/code&gt; 方法，以将其转换为一个集合，例如向量，其中包含迭代器生成的所有元素。</target>
        </trans-unit>
        <trans-unit id="ad43deb7c3d4847ed4f9b3c47149e285bd2d149c" translate="yes" xml:space="preserve">
          <source>To enable multiple ownership, Rust has a type called &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, which is an abbreviation for &lt;em&gt;reference counting&lt;/em&gt;. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</source>
          <target state="translated">为了启用多重所有权，Rust具有一个称为 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 的类型，这是&lt;em&gt;引用计数&lt;/em&gt;的缩写。所述 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 型跟踪引用的数目的到其确定值是否仍在使用的值。如果某个值的引用为零，则可以清除该值，而不会导致任何引用无效。</target>
        </trans-unit>
        <trans-unit id="e59e1050701d5494b23014e46f9317fad2eac0b0" translate="yes" xml:space="preserve">
          <source>To enable this feature on a nightly version of rustc, add the &lt;code&gt;const_fn&lt;/code&gt; feature flag:</source>
          <target state="translated">要在每晚版本的rustc上启用此功能，请添加 &lt;code&gt;const_fn&lt;/code&gt; 功能标记：</target>
        </trans-unit>
        <trans-unit id="d24a8c41c8e51812d2f6a3d4df4d4bc30f42fd94" translate="yes" xml:space="preserve">
          <source>To ensure memory safety, there&amp;rsquo;s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers &lt;code&gt;s1&lt;/code&gt; to no longer be valid and, therefore, Rust doesn&amp;rsquo;t need to free anything when &lt;code&gt;s1&lt;/code&gt; goes out of scope. Check out what happens when you try to use &lt;code&gt;s1&lt;/code&gt; after &lt;code&gt;s2&lt;/code&gt; is created; it won&amp;rsquo;t work:</source>
          <target state="translated">为了确保内存安全，在Rust中，在这种情况下会发生的事情还有一个细节。Rust不会尝试复制分配的内存，而是认为 &lt;code&gt;s1&lt;/code&gt; 不再有效，因此，当 &lt;code&gt;s1&lt;/code&gt; 超出范围时，Rust不需要释放任何内容。检查创建 &lt;code&gt;s2&lt;/code&gt; 之后尝试使用 &lt;code&gt;s1&lt;/code&gt; 会发生什么情况；它不起作用：</target>
        </trans-unit>
        <trans-unit id="44d8c4aeacd237bf73174a5745772ccb9ea1f421" translate="yes" xml:space="preserve">
          <source>To ensure soundness, Safe Rust is restricted enough that it can be automatically checked. Sometimes, however, it is necessary to write code that is correct for reasons which are too clever for the compiler to understand. In those cases, you need to use Unsafe Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccd9133d33f00e1b04fd5409b4bd62ab4182d4d" translate="yes" xml:space="preserve">
          <source>To extend a type without breaking existing code</source>
          <target state="translated">要在不破坏现有代码的情况下扩展一个类型</target>
        </trans-unit>
        <trans-unit id="7b84fa9a4a555e1a74d29f79dcd3abb8731f5940" translate="yes" xml:space="preserve">
          <source>To find the common type for a series of if branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27ddccf4caea85a4bf8ac030a69155b2d937a94" translate="yes" xml:space="preserve">
          <source>To find the common type for a series of match arms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd607b32ed771d3a582f20b6ce2e41a23d6c8021" translate="yes" xml:space="preserve">
          <source>To find the common type for array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986aa5a06f6c7eab4fbf8758ab21e34c28998b7b" translate="yes" xml:space="preserve">
          <source>To find the largest number in two different lists of numbers, we can duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.</source>
          <target state="translated">为了在两个不同的数字列表中找到最大的数字,我们可以重复清单10-1中的代码,并在程序中两个不同的地方使用相同的逻辑,如清单10-2所示。</target>
        </trans-unit>
        <trans-unit id="886ceb6ce4fcd41c44c60891b1e238be8050a3e5" translate="yes" xml:space="preserve">
          <source>To find the type for the return type of a closure with multiple return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05412e512ad05fb982373163c001384a6dc6dc41" translate="yes" xml:space="preserve">
          <source>To fix such code, put them in an extern &quot;C&quot; block:</source>
          <target state="translated">要修正这样的代码,把它们放在一个外部的 &quot;C &quot;块中。</target>
        </trans-unit>
        <trans-unit id="3f641101a15aa5663f425af7eca864860358c2b4" translate="yes" xml:space="preserve">
          <source>To fix the compiler error in Listing 16-3, we can use the error message&amp;rsquo;s advice:</source>
          <target state="translated">要修复清单16-3中的编译器错误，我们可以使用错误消息的建议：</target>
        </trans-unit>
        <trans-unit id="35eb0225e4203818949db81d35253471e9bc1946" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove patterns (&lt;code&gt;_&lt;/code&gt; is allowed though). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4b2f5b453763912d29b2bc8e5d29a39885b8b2" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove the duplicate declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a982630d24bce9f0c2bacf99524398a473cc7ece" translate="yes" xml:space="preserve">
          <source>To fix the previous code example, we derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a70249adaf4eb50343b8e3cb8c112aee0c4394d" translate="yes" xml:space="preserve">
          <source>To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using &lt;code&gt;let&lt;/code&gt;, we can use &lt;code&gt;if let&lt;/code&gt;. Then if the pattern doesn&amp;rsquo;t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</source>
          <target state="translated">为了解决需要可重构模式的不可重构模式的问题，我们可以更改使用该模式的代码：代替使用 &lt;code&gt;let&lt;/code&gt; ，可以使用 &lt;code&gt;if let&lt;/code&gt; 。然后，如果模式不匹配，则代码将跳过大括号中的代码，从而提供一种有效地继续执行的方法。清单18-9显示了如何修复清单18-8中的代码。</target>
        </trans-unit>
        <trans-unit id="3d38f12fb6a882b38564fce2f1f7c9cb9d1796dd" translate="yes" xml:space="preserve">
          <source>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</source>
          <target state="translated">要解决这个问题,可以删除未知的元项目,或者如果你提供了错误的名称,可以重新命名它。</target>
        </trans-unit>
        <trans-unit id="ff15ef440d8fd65fc53847fcd7d27134b37684e0" translate="yes" xml:space="preserve">
          <source>To fix the problem, remove all but one of the meta items with the same key.</source>
          <target state="translated">要解决这个问题,除了一个相同键的元项目外,其他都要删除。</target>
        </trans-unit>
        <trans-unit id="ea6969ed4bf2de9ff5e1987bde2a5974361798c0" translate="yes" xml:space="preserve">
          <source>To fix this and consume the iterator, we&amp;rsquo;ll use the &lt;code&gt;collect&lt;/code&gt; method, which we used in Chapter 12 with &lt;code&gt;env::args&lt;/code&gt; in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.</source>
          <target state="translated">为了解决这个问题并使用迭代器，我们将使用 &lt;code&gt;collect&lt;/code&gt; 方法，该方法在第12章中与清单12-1中的 &lt;code&gt;env::args&lt;/code&gt; 一起使用。此方法使用迭代器，并将结果值收集到收集数据类型中。</target>
        </trans-unit>
        <trans-unit id="7ddafefb4eada6e20a8873619c096afec9d9e821" translate="yes" xml:space="preserve">
          <source>To fix this error we need to spell out &lt;code&gt;Self&lt;/code&gt; to &lt;code&gt;S&amp;lt;'a&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00f739419dcbd64823b1ea3abe0a10a9be4cbba" translate="yes" xml:space="preserve">
          <source>To fix this error, add a &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b190c393f2e104afe11b9ff6d75785abc13b4fac" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing digits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f9240b7df9e2cdcc942864074f152c08f49afd" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing double quote at the end of the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a45c1a4916fd6685c913af98c59a6ca44a92d9" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing quote:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bc23db223a3a7adb6fd2ea01135a7a51e21b23" translate="yes" xml:space="preserve">
          <source>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</source>
          <target state="translated">要解决这个错误,请检查你没有拼错字段的名称,或者字段确实存在。例子:</target>
        </trans-unit>
        <trans-unit id="75b750ac4b7d89ba0d9d76afc4c969c263359a34" translate="yes" xml:space="preserve">
          <source>To fix this error, compile your code for a Rust target that supports the TrustZone-M extension. The current possible targets are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f0d68c9258ec3385682a9e7888b4d82a961453" translate="yes" xml:space="preserve">
          <source>To fix this error, declare &lt;code&gt;ss&lt;/code&gt; as mutable by using the &lt;code&gt;mut&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a10ae82ce30bea6273b20c3ae88287f346a01ba" translate="yes" xml:space="preserve">
          <source>To fix this error, declare your entry function with a C ABI, using &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4c03a79b5dd9aa983287afa6ca9be17b72579d" translate="yes" xml:space="preserve">
          <source>To fix this error, don't try to cast directly between thin and fat pointers.</source>
          <target state="translated">为了解决这个错误,不要尝试在瘦指针和胖指针之间直接投掷。</target>
        </trans-unit>
        <trans-unit id="851cef01fbc24aa508b07321c6a80e736f5740f3" translate="yes" xml:space="preserve">
          <source>To fix this error, either lessen the expected lifetime or find a way to not have to use this reference outside of its current scope (by running the code directly in the same block for example?):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf449e499fd02815621561773f0782493f1f5ff" translate="yes" xml:space="preserve">
          <source>To fix this error, either split into multiple match arms:</source>
          <target state="translated">要解决这个错误,要么拆成多个比赛臂。</target>
        </trans-unit>
        <trans-unit id="4a625dc9e5fa99f625b4f36ca500334a72e9f93e" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d5e036d18215af29bf5d6026ec79c924cc4630" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</source>
          <target state="translated">要解决这个错误,请确保在尝试访问变量之前,你没有任何其他引用。</target>
        </trans-unit>
        <trans-unit id="c41c6753158354db97000bee3e6d1e71d162a5c2" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure the match arm kind is the same as the expression matched.</source>
          <target state="translated">要修复这个错误,请确保匹配臂种类与匹配的表达式相同。</target>
        </trans-unit>
        <trans-unit id="0e0f8c883662f36aaeadf872304efd94871b85a2" translate="yes" xml:space="preserve">
          <source>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</source>
          <target state="translated">要解决这个错误,只需更改绑定的名称,以避免影子以下之一。</target>
        </trans-unit>
        <trans-unit id="547cd595fdb912c2692881e0fc69f7e09c4e06b4" translate="yes" xml:space="preserve">
          <source>To fix this error, just specify the type of the variable. Example:</source>
          <target state="translated">要解决这个错误,只需指定变量的类型。例子:</target>
        </trans-unit>
        <trans-unit id="ac9826f4a5f0aca5be2cbd8435bee957e2a23961" translate="yes" xml:space="preserve">
          <source>To fix this error, just use the same mode in both cases. Generally using &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; where not already used will fix this:</source>
          <target state="translated">要解决此错误，在两种情况下只需使用相同的模式即可。通常在尚未使用的地方使用 &lt;code&gt;ref&lt;/code&gt; 或 &lt;code&gt;ref mut&lt;/code&gt; 可以解决此问题：</target>
        </trans-unit>
        <trans-unit id="f5f3bd9b98cede2f9883569f89f15b8f146e95f8" translate="yes" xml:space="preserve">
          <source>To fix this error, please be sure that the module is in scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130e6cb76ab8ba2e39f9316003d15648f16e824e" translate="yes" xml:space="preserve">
          <source>To fix this error, please check that this type implements this binary operation. Example:</source>
          <target state="translated">要修复这个错误,请检查这个类型是否实现了这个二进制操作。例子:</target>
        </trans-unit>
        <trans-unit id="5f8bccc6c37b14540562ff31ba77c03a4a691b62" translate="yes" xml:space="preserve">
          <source>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</source>
          <target state="translated">为了解决这个错误,请确保结构的所有字段都是公共的,或者实现一个函数以方便实例化。例子:请确保结构的所有字段都是公共的,或者实现一个函数以方便实例化。</target>
        </trans-unit>
        <trans-unit id="342e8c2f7a1ada9b484baabdc9d06d406ca80a54" translate="yes" xml:space="preserve">
          <source>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</source>
          <target state="translated">为了解决这个错误,请在类型上实现一个特质或将其封装在一个结构中。例子:</target>
        </trans-unit>
        <trans-unit id="befadb1ed4ec4a8c074944e9002910bb635c2bda" translate="yes" xml:space="preserve">
          <source>To fix this error, please remove the visibility qualifier when it is not required. Example:</source>
          <target state="translated">为了解决这个错误,请在不需要的时候去掉可见性限定词。例如:</target>
        </trans-unit>
        <trans-unit id="dd5bba6de2aa5f4e39e98433e92b409c0d3ccac5" translate="yes" xml:space="preserve">
          <source>To fix this error, please replace the value with a constant. Example:</source>
          <target state="translated">要解决这个错误,请用一个常数来代替该值。例子:</target>
        </trans-unit>
        <trans-unit id="29332719480b2d3d455368380fd1815d30eebf29" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</source>
          <target state="translated">要修复这个错误,请确认方法名没有拼写错误,并确认你确实实现了正确的特征项。例子:请确认方法名称没有拼错,并确认你确实实现了正确的性状项。</target>
        </trans-unit>
        <trans-unit id="d6526d13f1c406efebc4022cedccc7bfc1d5dbc7" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</source>
          <target state="translated">要修复这个错误,请确认您没有拼错类型名称,您确实声明了它或将它导入到作用域中。例子。</target>
        </trans-unit>
        <trans-unit id="e76357808cad4720013a780f0b9c4aca40fe0097" translate="yes" xml:space="preserve">
          <source>To fix this error, remove the null characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0aa8ad2a46bb3a87624f0ae14dc2151334230f" translate="yes" xml:space="preserve">
          <source>To fix this error, replace the pattern argument with a regular one. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5459bb70fc45530a8171a7e09df41fa4c970e0d5" translate="yes" xml:space="preserve">
          <source>To fix this error, use a concrete type for the const parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca68924d905d97b9f1af1bea1e0a2d8cf16561fb" translate="yes" xml:space="preserve">
          <source>To fix this error, we need to move the &lt;code&gt;Shark&lt;/code&gt; struct inside the &lt;code&gt;Sea&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140824e6ec67ac2a81b7a4c3bb6daa38bc47f6d7" translate="yes" xml:space="preserve">
          <source>To fix this error, you can declare &lt;code&gt;create_some&lt;/code&gt; as a constant function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da3993819cb20099d5b634dd66120eb7048a481" translate="yes" xml:space="preserve">
          <source>To fix this error, you can finish using the closure before using the captured variable:</source>
          <target state="translated">为了解决这个错误,你可以在使用捕获的变量之前完成使用闭包。</target>
        </trans-unit>
        <trans-unit id="271f576e3469a4d5c3d47381caa4c74a644868c6" translate="yes" xml:space="preserve">
          <source>To fix this error, you can use the tuple pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3282af9d0d83b5725d812a840935cf798392f05" translate="yes" xml:space="preserve">
          <source>To fix this error, you have to move &lt;code&gt;yield&lt;/code&gt; out of the &lt;code&gt;async&lt;/code&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62676a2c0346704243e5e296c782b376a8f848ca" translate="yes" xml:space="preserve">
          <source>To fix this error, you have two solutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18371bc4c07ba0c41f6206f4861a5d76f0f6e55" translate="yes" xml:space="preserve">
          <source>To fix this error, you need to mark all the parent implementations as default. Example:</source>
          <target state="translated">为了解决这个错误,你需要将所有的父实现标记为默认。例子:</target>
        </trans-unit>
        <trans-unit id="cf4fd1eefb95ff6d8562a2c0c639ea77e8a69e6e" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">要解决此问题，请在参数中使用生命周期，或使用 &lt;code&gt;'static&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="9bc21023f3e82d02ae5ca480adede6bb29ef608c" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use the &lt;code&gt;'static&lt;/code&gt; lifetime. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2e9d61c37258f8ed9cce9fe2929803d6d2313b" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the inputs, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">要解决此问题，请在输入中使用生命周期，或使用 &lt;code&gt;'static&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="1c9273cf829edc7ecc1d2ffb40566c6ec5264a53" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the generics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d656f4427ec08945a130e9ab24f44d356e73c6" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the return keyword or move the expression into a function. Example:</source>
          <target state="translated">要解决这个问题,只需删除返回关键字或将表达式移到函数中即可。例子:</target>
        </trans-unit>
        <trans-unit id="f7f17c649ffe42ea1218c2db05314ba8b680b067" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the super trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6045b449bd1ac38773b2f91ba227f233a40af26b" translate="yes" xml:space="preserve">
          <source>To fix this issue, the lifetime in the const generic need to be changed to &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9924221c408a112fe763d167c1b4a29e5c450e04" translate="yes" xml:space="preserve">
          <source>To fix this issue, you have to rename at least one of the two imports. Example:</source>
          <target state="translated">要解决这个问题,你必须重命名两个进口中的至少一个。例子:</target>
        </trans-unit>
        <trans-unit id="8b92f6f0312b161fc6e42dd1de00eb946169f081" translate="yes" xml:space="preserve">
          <source>To fix this problem, we&amp;rsquo;ll modify the threads so they listen for either a &lt;code&gt;Job&lt;/code&gt; to run or a signal that they should stop listening and exit the infinite loop. Instead of &lt;code&gt;Job&lt;/code&gt; instances, our channel will send one of these two enum variants.</source>
          <target state="translated">要解决此问题，我们将修改线程，以便它们侦听要运行的 &lt;code&gt;Job&lt;/code&gt; 或它们应停止侦听并退出无限循环的信号。我们的频道将发送这两个枚举变量之一，而不是 &lt;code&gt;Job&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="c3ddf887a4b5f979d5c4754fbe5d3842c28e8398" translate="yes" xml:space="preserve">
          <source>To fix this problem, you can do either of these things:</source>
          <target state="translated">要解决这个问题,你可以做这些事情之一。</target>
        </trans-unit>
        <trans-unit id="d1040dc78ad7b42b1b39bcb93179f38486776a0b" translate="yes" xml:space="preserve">
          <source>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</source>
          <target state="translated">为了解决这个问题,你需要创建一个局部变量来存储值,而不是依赖一个临时变量。例如,你可以将原来的程序改成以下内容。</target>
        </trans-unit>
        <trans-unit id="038c4ea9697da9d94b0b431c704689f74be084b1" translate="yes" xml:space="preserve">
          <source>To fix this we have to define the lifetime at the function or impl level and use that lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;. For example you can define the lifetime at the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396fe77bfe601f99ac29d2d6217b45f0b4c303c2" translate="yes" xml:space="preserve">
          <source>To fix this we have to use the labeled block properly. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360a9b00506f1addbb3267f917ea23dd8584e790" translate="yes" xml:space="preserve">
          <source>To fix this, add a label specifying which loop is being broken out of:</source>
          <target state="translated">要解决这个问题,可以添加一个标签,指定哪个循环被断开。</target>
        </trans-unit>
        <trans-unit id="4f4f5291163064ff6fda56abd889a7618c40d282" translate="yes" xml:space="preserve">
          <source>To fix this, add an implementation for each default method from the trait:</source>
          <target state="translated">为了解决这个问题,从trait中为每个默认方法添加一个实现。</target>
        </trans-unit>
        <trans-unit id="56a92651d517e6a1850a1ad3d4745e7b392eba21" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for that crate as well. Building the &lt;code&gt;adder&lt;/code&gt; crate will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in the workspace using the &lt;code&gt;rand&lt;/code&gt; crate will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="translated">要解决此问题，请编辑 &lt;code&gt;adder&lt;/code&gt; 板条箱的&lt;em&gt;Cargo.toml&lt;/em&gt;文件，并指出 &lt;code&gt;rand&lt;/code&gt; 也是该板条箱的依赖项。构建 &lt;code&gt;adder&lt;/code&gt; 箱子将增加 &lt;code&gt;rand&lt;/code&gt; 到依赖关系列表 &lt;code&gt;adder&lt;/code&gt; 在&lt;em&gt;Cargo.lock&lt;/em&gt;，但没有额外的副本 &lt;code&gt;rand&lt;/code&gt; 将被下载。 Cargo确保使用 &lt;code&gt;rand&lt;/code&gt; 板条箱的工作区中的每个板条箱都将使用相同的版本。在工作区中使用相同版本的 &lt;code&gt;rand&lt;/code&gt; 可以节省空间，因为我们不会有多个副本，并确保工作区中的板条箱彼此兼容。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d9a4693a46d51eb0d6120d0488c70fc938ea0de" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for it as well. Building the &lt;code&gt;adder&lt;/code&gt; package will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in every package in the workspace using the &lt;code&gt;rand&lt;/code&gt; package will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd753bd45e01fa10b5929e59eda068f06c82e05" translate="yes" xml:space="preserve">
          <source>To fix this, either remove the outer reference:</source>
          <target state="translated">要解决这个问题,要么去掉外指。</target>
        </trans-unit>
        <trans-unit id="cb0074c2565e11e981fa6efe9e6d5af9f075e607" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that any declared variables are initialized before being used. Example:</source>
          <target state="translated">为了解决这个问题,请确保在使用之前对所有声明的变量进行初始化。例子:</target>
        </trans-unit>
        <trans-unit id="437601cd4925a7106ff21615c74bc484d85aef14" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</source>
          <target state="translated">要解决这个问题,请确保名称的拼写正确,并且使用了初始化器的正确形式。</target>
        </trans-unit>
        <trans-unit id="890f488bd89f18960203be014ab27fb39dfc6d22" translate="yes" xml:space="preserve">
          <source>To fix this, it is suggested to use a &lt;code&gt;where Self: Sized&lt;/code&gt; bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</source>
          <target state="translated">要解决此问题，如果您不想使用类型参数调用该方法，建议使用与上述子错误的修复类似的 &lt;code&gt;where Self: Sized&lt;/code&gt; 限制：</target>
        </trans-unit>
        <trans-unit id="c7b0cc36b1cf18605167b9e261109b879dd0c485" translate="yes" xml:space="preserve">
          <source>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</source>
          <target state="translated">为了解决这个问题,请手动设置下一个枚举值,或者将具有最大值的枚举变量放在枚举的最后。例子</target>
        </trans-unit>
        <trans-unit id="fa4bb08fcba49cd98aef8848abbf20a6a3f3bfcb" translate="yes" xml:space="preserve">
          <source>To fix this, replace the generic parameter with the specializations that you need:</source>
          <target state="translated">要解决这个问题,请用你需要的专业参数替换通用参数。</target>
        </trans-unit>
        <trans-unit id="0f9e6f402abcaecb02615cbeb4f9eaf1b18503a7" translate="yes" xml:space="preserve">
          <source>To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">为了解决这个问题,可以将该值提取为const,然后使用。</target>
        </trans-unit>
        <trans-unit id="34e96f574d6d4b3f0139f4794453e1b644fdb7fa" translate="yes" xml:space="preserve">
          <source>To fix this, we implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; and satisfy the constraint that &lt;code&gt;OutlinePrint&lt;/code&gt; requires, like so:</source>
          <target state="translated">为了解决这个问题，我们实现了 &lt;code&gt;Point&lt;/code&gt; on &lt;code&gt;Display&lt;/code&gt; 并满足 &lt;code&gt;OutlinePrint&lt;/code&gt; 所需的约束，如下所示：</target>
        </trans-unit>
        <trans-unit id="1afba8b0958bf7d54c00a1e357d6112f94820fbc" translate="yes" xml:space="preserve">
          <source>To fix this, you must reference the lifetime &lt;code&gt;'x&lt;/code&gt; from the return type. For example, changing the return type to &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; would work:</source>
          <target state="translated">要解决此问题，必须从返回类型引用生存期 &lt;code&gt;'x&lt;/code&gt; 。例如，将返回类型更改为 &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; 将起作用：</target>
        </trans-unit>
        <trans-unit id="7f876767b17c3198e0a111feeef857c2ed3d8806" translate="yes" xml:space="preserve">
          <source>To forcibly capture a backtrace regardless of environment variables, use the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c5b5034aa90905612a009b913793af12d3e3ac" translate="yes" xml:space="preserve">
          <source>To further refine the game&amp;rsquo;s behavior, rather than crashing the program when the user inputs a non-number, let&amp;rsquo;s make the game ignore a non-number so the user can continue guessing. We can do that by altering the line where &lt;code&gt;guess&lt;/code&gt; is converted from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;u32&lt;/code&gt;, as shown in Listing 2-5.</source>
          <target state="translated">为了进一步完善游戏的行为，而不是在用户输入非数字时使程序崩溃，我们让游戏忽略非数字，以便用户继续猜测。我们可以通过更改将 &lt;code&gt;guess&lt;/code&gt; 从 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;u32&lt;/code&gt; 的行来做到这一点，如清单2-5所示。</target>
        </trans-unit>
        <trans-unit id="bea9207f63bde7916694d159ff6b4254f0892dc5" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要获取可变的字符串切片，请参见&lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="baed129549ca4f37d13996fe220fb567ab069ac8" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8139e232eb226615d326fd45327940952c09f923" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0238d96367a691acb632dbf4d73cc5fd2a706ad9" translate="yes" xml:space="preserve">
          <source>To get a pointer to a boxed value, dereference the box:</source>
          <target state="translated">要获得一个指向盒状值的指针,取消对盒状值的引用。</target>
        </trans-unit>
        <trans-unit id="8f1e8a2f8899e777c3546c1b586cd81156849069" translate="yes" xml:space="preserve">
          <source>To get a specific value from a struct, we can use dot notation. If we wanted just this user&amp;rsquo;s email address, we could use &lt;code&gt;user1.email&lt;/code&gt; wherever we wanted to use this value. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the &lt;code&gt;email&lt;/code&gt; field of a mutable &lt;code&gt;User&lt;/code&gt; instance.</source>
          <target state="translated">要从结构中获取特定值，我们可以使用点表示法。如果只需要该用户的电子邮件地址，则可以在需要使用此值的任何地方使用 &lt;code&gt;user1.email&lt;/code&gt; 。如果实例是可变的，则可以通过使用点表示法并将其分配给特定字段来更改值。清单5-3显示了如何更改可变 &lt;code&gt;User&lt;/code&gt; 实例的 &lt;code&gt;email&lt;/code&gt; 字段中的值。</target>
        </trans-unit>
        <trans-unit id="ffd19be588eb8df1e329d2bc1905f6d517e8c370" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要获取不可变的字符串切片，请参见&lt;a href=&quot;#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="4160b8923a79d4ccc00d36a66c387740f16ca557" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce6e3247525a78442e0ee3f76231a67e813fe82" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29270bb604499679be31005db9630fdff3a329f3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要获取不可变的字符串切片，请参见&lt;a href=&quot;#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="1773350f816d14b08d14b8fc6f4503505910e146" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130eb39bd47cd566af1912b3ccb9f5e133aeacd3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bbcb0bb220df37e8c688ef821b8733765b09b5" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要获取可变的字符串切片，请参见&lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7b8786ffc3edfea977e5fb933b851cad79af05d7" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f032d280d4b30ddfbcd15e779b494aafdce282" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0349cd0d37a5287741f4237e8c49df43c4e0c6" translate="yes" xml:space="preserve">
          <source>To get this out of the way: you should probably just use &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison. Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a good enough choice to get started.</source>
          <target state="translated">为了避免这种情况：您可能应该只使用&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;。这两个集合涵盖了通用数据存储和处理的大多数用例。他们非常擅长于做自己的工作。标准库中的所有其他集合都有特定的用例，在这些用例中它们是最佳选择，但相比之下，这些用例只是边缘&lt;em&gt;领域&lt;/em&gt;。即使 &lt;code&gt;Vec&lt;/code&gt; 和 &lt;code&gt;HashMap&lt;/code&gt; 在技​​术上不是最佳选择，它们也可能是入门的不错选择。</target>
        </trans-unit>
        <trans-unit id="18773042303056fd8c79476f3616f355ff443a51" translate="yes" xml:space="preserve">
          <source>To handle the error case and print a user-friendly message, we need to update &lt;code&gt;main&lt;/code&gt; to handle the &lt;code&gt;Result&lt;/code&gt; being returned by &lt;code&gt;Config::new&lt;/code&gt;, as shown in Listing 12-10. We&amp;rsquo;ll also take the responsibility of exiting the command line tool with a nonzero error code from &lt;code&gt;panic!&lt;/code&gt; and implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.</source>
          <target state="translated">为了处理错误情况并输出一条用户友好的消息，我们需要更新 &lt;code&gt;main&lt;/code&gt; 以处理 &lt;code&gt;Config::new&lt;/code&gt; 返回的 &lt;code&gt;Result&lt;/code&gt; ，如清单12-10所示。我们还将负责从 &lt;code&gt;panic!&lt;/code&gt; 中退出带有非零错误代码的命令行工具！并手动实施。非零退出状态是一种约定，用于向调用我们的程序的进程发出信号，告知该程序以错误状态退出。</target>
        </trans-unit>
        <trans-unit id="482ebf3be5fe8298225b2e8f09ccc5e7f7c51bf1" translate="yes" xml:space="preserve">
          <source>To help IDE integration, the Rust project distributes the &lt;em&gt;Rust Language Server&lt;/em&gt; (&lt;code&gt;rls&lt;/code&gt;). This tool speaks the &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt;, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use the &lt;code&gt;rls&lt;/code&gt;, such as &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;the Rust plug-in for Visual Studio Code&lt;/a&gt;.</source>
          <target state="translated">为了帮助集成IDE，Rust项目分发了&lt;em&gt;Rust语言服务器&lt;/em&gt;（ &lt;code&gt;rls&lt;/code&gt; ）。该工具使用&lt;a href=&quot;http://langserver.org/&quot;&gt;语言服务器协议&lt;/a&gt;，这是IDE和编程语言相互通信的规范。不同的客户端可以使用 &lt;code&gt;rls&lt;/code&gt; ，例如&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio Code的Rust插件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20b8f11e3eb504aaf128f283d04500f6915052b5" translate="yes" xml:space="preserve">
          <source>To illustrate situations where closures that can capture their environment are useful as function parameters, let&amp;rsquo;s move on to our next topic: iterators.</source>
          <target state="translated">为了说明可以捕获其环境的闭包用作函数参数的情况，让我们继续下一个主题：迭代器。</target>
        </trans-unit>
        <trans-unit id="6bb8bf87527987f23e438b1c1bc78391e818826e" translate="yes" xml:space="preserve">
          <source>To illustrate the rules of ownership, we need a data type that is more complex than the ones we covered in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3. The types covered previously are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data.</source>
          <target state="translated">为了说明所有权规则，我们需要一个比第3章&lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;数据类型&amp;rdquo;&lt;/a&gt;部分介绍的数据类型更复杂的数据类型。先前介绍的类型都存储在堆栈中，并在其作用域弹出时从堆栈中弹出。结束了，但是我们想查看存储在堆上的数据，并探索Rust如何知道何时清理该数据。</target>
        </trans-unit>
        <trans-unit id="60712450a97e23097bf6dbe8ed26e2265884e8b7" translate="yes" xml:space="preserve">
          <source>To implement the behavior we want &lt;code&gt;gui&lt;/code&gt; to have, we&amp;rsquo;ll define a trait named &lt;code&gt;Draw&lt;/code&gt; that will have one method named &lt;code&gt;draw&lt;/code&gt;. Then we can define a vector that takes a &lt;em&gt;trait object&lt;/em&gt;. A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a &lt;code&gt;&amp;amp;&lt;/code&gt; reference or a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, then the &lt;code&gt;dyn&lt;/code&gt; keyword, and then specifying the relevant trait. (We&amp;rsquo;ll talk about the reason trait objects must use a pointer in Chapter 19 in the section &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;Dynamically Sized Types and the &lt;code&gt;Sized&lt;/code&gt; Trait.&amp;rdquo;&lt;/a&gt;) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust&amp;rsquo;s type system will ensure at compile time that any value used in that context will implement the trait object&amp;rsquo;s trait. Consequently, we don&amp;rsquo;t need to know all the possible types at compile time.</source>
          <target state="translated">为了实现 &lt;code&gt;gui&lt;/code&gt; 想要的行为，我们将定义一个名为 &lt;code&gt;Draw&lt;/code&gt; 的特征，该特征将具有一个名为 &lt;code&gt;draw&lt;/code&gt; 的方法。然后我们可以定义一个接受&lt;em&gt;特征对象&lt;/em&gt;的向量。特征对象既指向实现我们指定特征的类型的实例，也指向用于在运行时查找该类型的特征方法的表。通过指定某种指针（例如 &lt;code&gt;&amp;amp;&lt;/code&gt; 引用或 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 智能指针），然后指定 &lt;code&gt;dyn&lt;/code&gt; 关键字，然后指定相关特征，可以创建特征对象。 （我们将在第19章&lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;动态大小类型和&lt;/a&gt; &lt;code&gt;Sized&lt;/code&gt; 确定的部分&amp;rdquo;中讨论特征对象必须使用指针的原因。特征。&amp;rdquo; ）我们可以使用特征对象代替泛型或具体类型。无论我们在哪里使用trait对象，Rust的类型系统都将确保在编译时在该上下文中使用的任何值都将实现trait对象的trait。因此，我们不需要在编译时就知道所有可能的类型。</target>
        </trans-unit>
        <trans-unit id="f5e8a5c28a454d1f90112a6c60c0f8aea2b5196d" translate="yes" xml:space="preserve">
          <source>To improve our program, we&amp;rsquo;ll fix four problems that have to do with the program&amp;rsquo;s structure and how it&amp;rsquo;s handling potential errors.</source>
          <target state="translated">为了改进我们的程序，我们将修复与程序的结构以及如何处理潜在错误有关的四个问题。</target>
        </trans-unit>
        <trans-unit id="bf9b4462d1a02f4d70e5d13cf8540c79a5e14d1a" translate="yes" xml:space="preserve">
          <source>To incorporate the &lt;code&gt;Message&lt;/code&gt; enum, we need to change &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; in two places: the definition of &lt;code&gt;ThreadPool&lt;/code&gt; and the signature of &lt;code&gt;Worker::new&lt;/code&gt;. The &lt;code&gt;execute&lt;/code&gt; method of &lt;code&gt;ThreadPool&lt;/code&gt; needs to send jobs wrapped in the &lt;code&gt;Message::NewJob&lt;/code&gt; variant. Then, in &lt;code&gt;Worker::new&lt;/code&gt; where a &lt;code&gt;Message&lt;/code&gt; is received from the channel, the job will be processed if the &lt;code&gt;NewJob&lt;/code&gt; variant is received, and the thread will break out of the loop if the &lt;code&gt;Terminate&lt;/code&gt; variant is received.</source>
          <target state="translated">为了合并 &lt;code&gt;Message&lt;/code&gt; 枚举，我们需要在两个地方将 &lt;code&gt;Job&lt;/code&gt; 更改为 &lt;code&gt;Message&lt;/code&gt; ： &lt;code&gt;ThreadPool&lt;/code&gt; 的定义和 &lt;code&gt;Worker::new&lt;/code&gt; 的签名。 &lt;code&gt;ThreadPool&lt;/code&gt; 的 &lt;code&gt;execute&lt;/code&gt; 方法需要发送包装在 &lt;code&gt;Message::NewJob&lt;/code&gt; 变量中的作业。然后，在 &lt;code&gt;Worker::new&lt;/code&gt; 其中 &lt;code&gt;Message&lt;/code&gt; 是从信道接收，该作业将被如果处理的 &lt;code&gt;NewJob&lt;/code&gt; 接收变体中，并且如果该线程将中断环路的出 &lt;code&gt;Terminate&lt;/code&gt; 接收的变体。</target>
        </trans-unit>
        <trans-unit id="0f9206704ddf29e2ebea715304ccfd9e3f3ba5f3" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;rustfmt&lt;/code&gt;, enter the following:</source>
          <target state="translated">要安装 &lt;code&gt;rustfmt&lt;/code&gt; ，请输入以下内容：</target>
        </trans-unit>
        <trans-unit id="35fe5fa9574aed79cc4c533785f5e0d142e0e320" translate="yes" xml:space="preserve">
          <source>To install Clippy, enter the following:</source>
          <target state="translated">要安装Clippy,请输入以下内容。</target>
        </trans-unit>
        <trans-unit id="44d584ca391c2045c83ab8a58e67b2e401ab33be" translate="yes" xml:space="preserve">
          <source>To install the &lt;code&gt;rls&lt;/code&gt;, enter the following:</source>
          <target state="translated">要安装 &lt;code&gt;rls&lt;/code&gt; ，请输入以下内容：</target>
        </trans-unit>
        <trans-unit id="71a54c2518d0f86ead8ba016e32755cf1ca226ed" translate="yes" xml:space="preserve">
          <source>To interact with a &lt;code&gt;Formatter&lt;/code&gt;, you'll call various methods to change the various options related to formatting. For examples, please see the documentation of the methods defined on &lt;code&gt;Formatter&lt;/code&gt; below.</source>
          <target state="translated">要与 &lt;code&gt;Formatter&lt;/code&gt; 进行交互，您将调用各种方法来更改与格式化有关的各种选项。有关示例，请参阅下面的 &lt;code&gt;Formatter&lt;/code&gt; 上定义的方法的文档。</target>
        </trans-unit>
        <trans-unit id="b498caa788bb95865cf7ae29f319574a69dd854b" translate="yes" xml:space="preserve">
          <source>To isolate unsafe code as much as possible, it&amp;rsquo;s best to enclose unsafe code within a safe abstraction and provide a safe API, which we&amp;rsquo;ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of &lt;code&gt;unsafe&lt;/code&gt; from leaking out into all the places that you or your users might want to use the functionality implemented with &lt;code&gt;unsafe&lt;/code&gt; code, because using a safe abstraction is safe.</source>
          <target state="translated">为了尽可能地隔离不安全的代码，最好将不安全的代码包含在安全的抽象中并提供安全的API，我们将在本章的后面部分讨论不安全的函数和方法时对此进行讨论。标准库的某些部分实现为对已审核的不安全代码的安全抽象。在安全抽象中包装不安全代码可以防止 &lt;code&gt;unsafe&lt;/code&gt; 使用的情况泄漏到您或您的用户可能希望使用通过 &lt;code&gt;unsafe&lt;/code&gt; 代码实现的功能的所有位置，因为使用安全抽象是安全的。</target>
        </trans-unit>
        <trans-unit id="a6753382b748af96b119a035edd05c7a836b948d" translate="yes" xml:space="preserve">
          <source>To learn about the other kinds of collections provided by the standard library, see &lt;a href=&quot;../std/collections/index&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">要了解标准库提供的其他种类的集合，请参阅&lt;a href=&quot;../std/collections/index&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dbbd03b2e667a7e6b225ed1de228878e32e5817" translate="yes" xml:space="preserve">
          <source>To learn more about allowing access, see the documentation for the &lt;a href=&quot;keyword.pub&quot;&gt;&lt;code&gt;pub&lt;/code&gt;&lt;/a&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2736d1e6ef2a3faad24038e53f6bde645f76d87" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非ASCII字符外，要小写ASCII字符，请使用&lt;a href=&quot;#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e94e0d4cfd63a504442f11c93df0afa614a2f0d4" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非ASCII字符外，要小写ASCII字符，请使用&lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt; &lt;code&gt;str::to_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63a5fbbc07007136d2c958a62c0c4ca27bbb449c" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab2513e3de2d60d109900818fb2429fd91b99d2" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要就地小写值，请使用&lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef146744579c27e21ed699daf39b3a3250767c77" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要就地小写值，请使用&lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67608258687aa72b226fb9d75937d3aa5583b343" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6481a0667301c8cf17a1fc74a4e7ea446e2ab9" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a33f76160389c879809056277f95cb426933c88" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cfe6c801715fff699dce762afc98ca7e8ff1fa" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0549668b9dec3f8fe6cc76087d773d360d9c8f" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;struct.osstr#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd861f60ceee6cd011393e0efbd8975fcac733a1" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e4a3f169edf0cfb32c3841ee2bea7479d1a5e1" translate="yes" xml:space="preserve">
          <source>To make a struct that holds a closure, we need to specify the type of the closure, because a struct definition needs to know the types of each of its fields. Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different. To define structs, enums, or function parameters that use closures, we use generics and trait bounds, as we discussed in Chapter 10.</source>
          <target state="translated">要制作一个容纳闭包的结构,我们需要指定闭包的类型,因为一个结构定义需要知道它的每个字段的类型。每个闭包实例都有自己唯一的匿名类型:也就是说,即使两个闭包具有相同的签名,它们的类型仍然被认为是不同的。为了定义使用闭包的结构、枚举或函数参数,我们使用了泛型和特质边界,正如我们在第10章中讨论的那样。</target>
        </trans-unit>
        <trans-unit id="f551bbd5751f05a17c69a727dd31a7a20561b4f8" translate="yes" xml:space="preserve">
          <source>To make it valid, write the following:</source>
          <target state="translated">为了使其有效,请写出以下内容。</target>
        </trans-unit>
        <trans-unit id="11b284dcb2ba4ceac9f02b253f7b17b9698ddf3b" translate="yes" xml:space="preserve">
          <source>To make struct &lt;code&gt;Bar&lt;/code&gt; only visible in module &lt;code&gt;foo&lt;/code&gt; the &lt;code&gt;in&lt;/code&gt; keyword should be used:</source>
          <target state="translated">为了使结构 &lt;code&gt;Bar&lt;/code&gt; 仅模块可见 &lt;code&gt;foo&lt;/code&gt; 的 &lt;code&gt;in&lt;/code&gt; 关键字应使用：</target>
        </trans-unit>
        <trans-unit id="fc2021393a94974377e271f291f7d97ada3aa985" translate="yes" xml:space="preserve">
          <source>To make the child node aware of its parent, we need to add a &lt;code&gt;parent&lt;/code&gt; field to our &lt;code&gt;Node&lt;/code&gt; struct definition. The trouble is in deciding what the type of &lt;code&gt;parent&lt;/code&gt; should be. We know it can&amp;rsquo;t contain an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, because that would create a reference cycle with &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;branch.children&lt;/code&gt; pointing to &lt;code&gt;leaf&lt;/code&gt;, which would cause their &lt;code&gt;strong_count&lt;/code&gt; values to never be 0.</source>
          <target state="translated">为了使子节点知道其父节点，我们需要在 &lt;code&gt;Node&lt;/code&gt; 的结构定义中添加一个 &lt;code&gt;parent&lt;/code&gt; 字段。问题在于确定 &lt;code&gt;parent&lt;/code&gt; 的类型。我们知道它不能包含 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; ，因为这将创建一个参考循环，其中 &lt;code&gt;leaf.parent&lt;/code&gt; 指向 &lt;code&gt;branch&lt;/code&gt; ， &lt;code&gt;branch.children&lt;/code&gt; 指向 &lt;code&gt;leaf&lt;/code&gt; ，这将导致它们的 &lt;code&gt;strong_count&lt;/code&gt; 值永远不会为0。</target>
        </trans-unit>
        <trans-unit id="d22320c45b662fb11c8113dfcbe82f4c5091e1e8" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b483d37995579653b3a66a999867efa81ab8f9" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;code&gt;Drop&lt;/code&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="translated">为了使此工作有效，列表中的每个元素都有指向其前任和后任的指针。只能在固定元素时添加元素，因为四处移动元素会使指针无效。此外，链表元素的 &lt;code&gt;Drop&lt;/code&gt; 实现将修补其前任和后继的指针，以将自身从列表中删除。</target>
        </trans-unit>
        <trans-unit id="addd7b5a3eab2bcc498269d4b5030ddd2652429e" translate="yes" xml:space="preserve">
          <source>To many people, polymorphism is synonymous with inheritance. But it&amp;rsquo;s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</source>
          <target state="translated">对许多人来说，多态是继承的代名词。但这实际上是一个更通用的概念，指的是可以使用多种类型的数据的代码。对于继承，这些类型通常是子类。</target>
        </trans-unit>
        <trans-unit id="e542c92de7f2ff8b0e65e4059a685882563b6c24" translate="yes" xml:space="preserve">
          <source>To measure elapsed time reliably, use &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1808ba5fbc9308fb8282df842ce731348ff5abf" translate="yes" xml:space="preserve">
          <source>To model pointers to opaque types in FFI, until &lt;code&gt;extern type&lt;/code&gt; is stabilized, it is recommended to use a newtype wrapper around an empty byte array. See the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; for details.</source>
          <target state="translated">要在FFI中为指向不透明类型的指针建模，直到稳定 &lt;code&gt;extern type&lt;/code&gt; ，建议在空字节数组周围使用新类型包装器。有关详细信息，请参见&lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92f1c0826630a6e44e7c7249d92c4a26d91785e3" translate="yes" xml:space="preserve">
          <source>To obtain error description as a string, use &lt;code&gt;to_string()&lt;/code&gt;.</source>
          <target state="translated">要获取错误描述作为字符串，请使用 &lt;code&gt;to_string()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0354419a51c55b7a4f425ab3291d7b635b1d30c9" translate="yes" xml:space="preserve">
          <source>To parameterize the types in the new function we&amp;rsquo;ll define, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we&amp;rsquo;ll use &lt;code&gt;T&lt;/code&gt; because, by convention, parameter names in Rust are short, often just a letter, and Rust&amp;rsquo;s type-naming convention is CamelCase. Short for &amp;ldquo;type,&amp;rdquo; &lt;code&gt;T&lt;/code&gt; is the default choice of most Rust programmers.</source>
          <target state="translated">为了在我们将要定义的新函数中对类型进行参数化，我们需要命名类型参数，就像对函数的value参数进行命名一样。您可以使用任何标识符作为类型参数名称。但是我们将使用 &lt;code&gt;T&lt;/code&gt; ,因为按照惯例，Rust中的参数名称很短，通常只是一个字母，Rust的类型命名惯例是CamelCase。 &lt;code&gt;T&lt;/code&gt; 是&amp;ldquo;类型&amp;rdquo;的缩写，是大多数Rust程序员的默认选择。</target>
        </trans-unit>
        <trans-unit id="075fa626d389c13dd84df398e2b600267ba414fd" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="translated">要解析路径，您可以从&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;切片创建&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;切片并开始提出问题：</target>
        </trans-unit>
        <trans-unit id="a91f9eb8a09ec43223d4a3a69ca02691cc9a5535" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f45d830d337ce8a4f493ea8b6014f97c0fb6eb" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要传递单个参数，请参见&lt;a href=&quot;#method.arg&quot;&gt; &lt;code&gt;arg&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30a7bace681f793e8820181cf7574f94401b280d" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3d970a69fb7cac0396fffe3d7483eb856d59e9" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要传递多个参数，请参见&lt;a href=&quot;#method.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f24e6cb8e923f8cee5441a6183ab318931f04cf1" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc2c49e6f2624612dfa9af5bb72c9d5988a62aa" translate="yes" xml:space="preserve">
          <source>To perform async recursion, the &lt;code&gt;async fn&lt;/code&gt; needs to be desugared such that the &lt;code&gt;Future&lt;/code&gt; is explicit in the return type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6d76d570505ba666bcda7baecd5871dcf2d3a2" translate="yes" xml:space="preserve">
          <source>To prevent this scenario, we first put all of our &lt;code&gt;Terminate&lt;/code&gt; messages on the channel in one loop; then we join on all the threads in another loop. Each worker will stop receiving requests on the channel once it gets a terminate message. So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before &lt;code&gt;join&lt;/code&gt; is called on its thread.</source>
          <target state="translated">为避免这种情况，我们首先将所有 &lt;code&gt;Terminate&lt;/code&gt; 消息放在一个循环中；然后我们在另一个循环中加入所有线程。一旦收到终止消息，每个工作人员将停止在通道上接收请求。因此，我们可以确定，如果发送的终止消息数量与工作线程数相同，则每个工作线程都会在线程调用 &lt;code&gt;join&lt;/code&gt; 之前收到终止消息。</target>
        </trans-unit>
        <trans-unit id="add5b6cf5a307a5e6af227f8cc2b7b101db763e7" translate="yes" xml:space="preserve">
          <source>To protect your program from this sort of vulnerability, if you try to read an element at an index that doesn&amp;rsquo;t exist, Rust will stop execution and refuse to continue. Let&amp;rsquo;s try it and see:</source>
          <target state="translated">为了保护您的程序免受此类漏洞的侵害，如果您尝试在不存在的索引处读取元素，Rust将停止执行并拒绝继续执行。让我们尝试一下，看看：</target>
        </trans-unit>
        <trans-unit id="fb3ab9d085bae205d404a7ba202d1b27f55784c2" translate="yes" xml:space="preserve">
          <source>To recover from a poisoned mutex:</source>
          <target state="translated">要想从中毒的哑铃中恢复过来。</target>
        </trans-unit>
        <trans-unit id="e0f842e4093b64f03623cd49c1c17718cfbe95dc" translate="yes" xml:space="preserve">
          <source>To remove the internal organization from the public API, we can modify the &lt;code&gt;art&lt;/code&gt; crate code in Listing 14-3 to add &lt;code&gt;pub use&lt;/code&gt; statements to re-export the items at the top level, as shown in Listing 14-5:</source>
          <target state="translated">要从公共API中删除内部组织，我们可以修改清单14-3中的 &lt;code&gt;art&lt;/code&gt; crate代码，以添加 &lt;code&gt;pub use&lt;/code&gt; 语句以在顶层重新导出项目，如清单14-5所示：</target>
        </trans-unit>
        <trans-unit id="5b0280b8819ec3479f9646e558c6310c8632f058" translate="yes" xml:space="preserve">
          <source>To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</source>
          <target state="translated">为了解决模棱两可的问题,程序员可以使用更具体的路径、类型或特征来引用他们想要的方法或函数。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
