<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2ec6cd19695748bdc3218a5649d6ac291b66845a" translate="yes" xml:space="preserve">
          <source>BTreeSet::intersection</source>
          <target state="translated">BTreeSet::intersection</target>
        </trans-unit>
        <trans-unit id="d885d81e267a989f9b6f96d27d81a920eec34664" translate="yes" xml:space="preserve">
          <source>BTreeSet::into</source>
          <target state="translated">BTreeSet::into</target>
        </trans-unit>
        <trans-unit id="f09a0e4a6b10a390e2f04fd66332a740593fc953" translate="yes" xml:space="preserve">
          <source>BTreeSet::into_iter</source>
          <target state="translated">BTreeSet::into_iter</target>
        </trans-unit>
        <trans-unit id="a2120b284c22116b26329e55b63c0619a0f8641f" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_disjoint</source>
          <target state="translated">BTreeSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="fa3982b7c70f77cdc4a183838b7ec4738fe0c535" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_empty</source>
          <target state="translated">BTreeSet::is_empty</target>
        </trans-unit>
        <trans-unit id="f1e3ee85ccb9602474d41d5d154e3e8901defc32" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_subset</source>
          <target state="translated">BTreeSet::is_subset</target>
        </trans-unit>
        <trans-unit id="56a933bbd8f86feb814db247df53b23e17a9695d" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_superset</source>
          <target state="translated">BTreeSet::is_superset</target>
        </trans-unit>
        <trans-unit id="b5818b3b23dd28b80dc81cc819a86f1ec187aacf" translate="yes" xml:space="preserve">
          <source>BTreeSet::iter</source>
          <target state="translated">BTreeSet::iter</target>
        </trans-unit>
        <trans-unit id="de70e88d73a501b174fd29598eceebcee11a3887" translate="yes" xml:space="preserve">
          <source>BTreeSet::le</source>
          <target state="translated">BTreeSet::le</target>
        </trans-unit>
        <trans-unit id="d6f9cf6208fd574420dfb2b2c0da01ae4ce09d55" translate="yes" xml:space="preserve">
          <source>BTreeSet::len</source>
          <target state="translated">BTreeSet::len</target>
        </trans-unit>
        <trans-unit id="b1797fe67e7fb20ec6e3d268d0239e6f0a7e8a35" translate="yes" xml:space="preserve">
          <source>BTreeSet::lt</source>
          <target state="translated">BTreeSet::lt</target>
        </trans-unit>
        <trans-unit id="a9e0d4eb0cfb5c71cb33c6469839efbbe2cc32b4" translate="yes" xml:space="preserve">
          <source>BTreeSet::max</source>
          <target state="translated">BTreeSet::max</target>
        </trans-unit>
        <trans-unit id="05e2ada4eca69c113c843b5a4bf4e82b6cbab803" translate="yes" xml:space="preserve">
          <source>BTreeSet::min</source>
          <target state="translated">BTreeSet::min</target>
        </trans-unit>
        <trans-unit id="1bf7816f409ee91ea7b933df2aa5aafb248eb221" translate="yes" xml:space="preserve">
          <source>BTreeSet::ne</source>
          <target state="translated">BTreeSet::ne</target>
        </trans-unit>
        <trans-unit id="eaf3ecdf9b29068bb6526653c7887b6ce53f95db" translate="yes" xml:space="preserve">
          <source>BTreeSet::new</source>
          <target state="translated">BTreeSet::new</target>
        </trans-unit>
        <trans-unit id="df8c5a54c5b8f9c4c785c5ef82c145a8f51964cb" translate="yes" xml:space="preserve">
          <source>BTreeSet::partial_cmp</source>
          <target state="translated">BTreeSet::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d87bbd755881f1e9919b94d6de0e6bf8ffad49ba" translate="yes" xml:space="preserve">
          <source>BTreeSet::range</source>
          <target state="translated">BTreeSet::range</target>
        </trans-unit>
        <trans-unit id="ef12ebd2434d1cb833ec3822d788df805d7d9bd6" translate="yes" xml:space="preserve">
          <source>BTreeSet::remove</source>
          <target state="translated">BTreeSet::remove</target>
        </trans-unit>
        <trans-unit id="9478913c250333ed4078096ba5b68c78bc2a2420" translate="yes" xml:space="preserve">
          <source>BTreeSet::replace</source>
          <target state="translated">BTreeSet::replace</target>
        </trans-unit>
        <trans-unit id="3c5930911fa948ea3f0f63bb1262c5e03b59d4c8" translate="yes" xml:space="preserve">
          <source>BTreeSet::split_off</source>
          <target state="translated">BTreeSet::split_off</target>
        </trans-unit>
        <trans-unit id="c4362726060659abf8310f7f4e795bc37b50e1bc" translate="yes" xml:space="preserve">
          <source>BTreeSet::sub</source>
          <target state="translated">BTreeSet::sub</target>
        </trans-unit>
        <trans-unit id="1dc28627821fcb677e88cc0779199b1f7545d0d5" translate="yes" xml:space="preserve">
          <source>BTreeSet::symmetric_difference</source>
          <target state="translated">BTreeSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="2164e4022af6db54cb98c455e4d65521424dc945" translate="yes" xml:space="preserve">
          <source>BTreeSet::take</source>
          <target state="translated">BTreeSet::take</target>
        </trans-unit>
        <trans-unit id="976d0d251360ff452f9cb215b1b7bd9b85411230" translate="yes" xml:space="preserve">
          <source>BTreeSet::to_owned</source>
          <target state="translated">BTreeSet::to_owned</target>
        </trans-unit>
        <trans-unit id="0992e1b4495c890673b5468165634f32bea3f77d" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_from</source>
          <target state="translated">BTreeSet::try_from</target>
        </trans-unit>
        <trans-unit id="00828429015178852a18ee4ff94e0453f5ca2ad3" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_into</source>
          <target state="translated">BTreeSet::try_into</target>
        </trans-unit>
        <trans-unit id="6292b066b8d0a77ef6636bc177c940749dde0313" translate="yes" xml:space="preserve">
          <source>BTreeSet::type_id</source>
          <target state="translated">BTreeSet::type_id</target>
        </trans-unit>
        <trans-unit id="a20d276d5c8ff0b1126047f789b8548caf5f132d" translate="yes" xml:space="preserve">
          <source>BTreeSet::union</source>
          <target state="translated">BTreeSet::union</target>
        </trans-unit>
        <trans-unit id="a211a3e292d0c406efdf997cbec3abf1f2bc9197" translate="yes" xml:space="preserve">
          <source>BYTE_ESCAPE :</source>
          <target state="translated">BYTE_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="e985813955ef288c8ead5994a2092542fb8c5bfb" translate="yes" xml:space="preserve">
          <source>BYTE_LITERAL :</source>
          <target state="translated">BYTE_LITERAL :</target>
        </trans-unit>
        <trans-unit id="e07c048067fa9215a18b4b2891f03e3f5148f8fe" translate="yes" xml:space="preserve">
          <source>BYTE_STRING_LITERAL :</source>
          <target state="translated">BYTE_STRING_LITERAL 。</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="0ad42765ddcf1bcbae887f2d660cffdf1e817617" translate="yes" xml:space="preserve">
          <source>Background:</source>
          <target state="translated">Background:</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="2df2f36ad1b16c1667285665d27221aa512fe540" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">反斜杠转义为 &lt;code&gt;\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a92ed9890561e42d2d0eb715d201f51180f68785" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">反斜杠转义为 &lt;code&gt;\\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb6f955aacbe511f0166d8a199d4db6ed90499a5" translate="yes" xml:space="preserve">
          <source>Backtrace</source>
          <target state="translated">Backtrace</target>
        </trans-unit>
        <trans-unit id="b85c431b74d8d9af7df1e8cd976473ac0177f68e" translate="yes" xml:space="preserve">
          <source>BacktraceStatus</source>
          <target state="translated">BacktraceStatus</target>
        </trans-unit>
        <trans-unit id="6eb0761000f5c4f5765ae1bd324bf97fbcf48d1d" translate="yes" xml:space="preserve">
          <source>Backtraces are attempted to be as accurate as possible, but no guarantees are provided about the exact accuracy of a backtrace. Instruction pointers, symbol names, filenames, line numbers, etc, may all be incorrect when reported. Accuracy is attempted on a best-effort basis, however, and bugs are always welcome to indicate areas of improvement!</source>
          <target state="translated">我们试图尽可能准确地进行回溯,但不保证回溯的准确性。指令指针、符号名称、文件名、行号等,在报告时都可能不正确。然而,准确度是在尽力的基础上尝试的,欢迎提出错误,指出需要改进的地方。</target>
        </trans-unit>
        <trans-unit id="10c02649e226d430bd75a5b6315a41c0db9992a2" translate="yes" xml:space="preserve">
          <source>Barrier</source>
          <target state="translated">Barrier</target>
        </trans-unit>
        <trans-unit id="05bc93718262068d5416ebba28511ebef76c4e14" translate="yes" xml:space="preserve">
          <source>Barrier::borrow</source>
          <target state="translated">Barrier::borrow</target>
        </trans-unit>
        <trans-unit id="48d8a6ca5d7ebcc052fa58321357d3bc36aa03a7" translate="yes" xml:space="preserve">
          <source>Barrier::borrow_mut</source>
          <target state="translated">Barrier::borrow_mut</target>
        </trans-unit>
        <trans-unit id="248c7b32ba40054cd50084ccaaff12b9c63d122a" translate="yes" xml:space="preserve">
          <source>Barrier::fmt</source>
          <target state="translated">Barrier::fmt</target>
        </trans-unit>
        <trans-unit id="d7dd85fbb601276305eb0ee52f6cb5d377f1fcc6" translate="yes" xml:space="preserve">
          <source>Barrier::from</source>
          <target state="translated">Barrier::from</target>
        </trans-unit>
        <trans-unit id="b342290a92d4444218a0ad57c6d277b796cd87a3" translate="yes" xml:space="preserve">
          <source>Barrier::into</source>
          <target state="translated">Barrier::into</target>
        </trans-unit>
        <trans-unit id="7468c224f8c905662e2e9c948739eef5bda7db0f" translate="yes" xml:space="preserve">
          <source>Barrier::new</source>
          <target state="translated">Barrier::new</target>
        </trans-unit>
        <trans-unit id="e30be523849f626aaa57ff5ee4069d25af8b70d1" translate="yes" xml:space="preserve">
          <source>Barrier::try_from</source>
          <target state="translated">Barrier::try_from</target>
        </trans-unit>
        <trans-unit id="e446147c6eb4453799cb6b4e470660354d138fed" translate="yes" xml:space="preserve">
          <source>Barrier::try_into</source>
          <target state="translated">Barrier::try_into</target>
        </trans-unit>
        <trans-unit id="97c7cb229080f5ec6d48954bf4e25fbf0b1b07ce" translate="yes" xml:space="preserve">
          <source>Barrier::type_id</source>
          <target state="translated">Barrier::type_id</target>
        </trans-unit>
        <trans-unit id="89f8492b0a8df428938e6f6ec1470925533e2645" translate="yes" xml:space="preserve">
          <source>Barrier::wait</source>
          <target state="translated">Barrier::wait</target>
        </trans-unit>
        <trans-unit id="1fdffd384d740408663001485f7d1d001cd2a0cd" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult</source>
          <target state="translated">BarrierWaitResult</target>
        </trans-unit>
        <trans-unit id="e4a4959fb6b835a4c39d1adf5dc13e01c6574236" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow</source>
          <target state="translated">BarrierWaitResult::borrow</target>
        </trans-unit>
        <trans-unit id="df6d4d2a45b72573796ce25c163ceca562fea277" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow_mut</source>
          <target state="translated">BarrierWaitResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ab607187cf3b656038040cc905673df49597a85b" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::fmt</source>
          <target state="translated">BarrierWaitResult::fmt</target>
        </trans-unit>
        <trans-unit id="40c08de59f1f4830ac002ad44e2d3553862e48a4" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::from</source>
          <target state="translated">BarrierWaitResult::from</target>
        </trans-unit>
        <trans-unit id="0ad014a8be36da91076930d7e3b4ff7218ef30aa" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::into</source>
          <target state="translated">BarrierWaitResult::into</target>
        </trans-unit>
        <trans-unit id="24471f5273b1cd68c1f7b8b58afe489ead7b1e9c" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::is_leader</source>
          <target state="translated">BarrierWaitResult::is_leader</target>
        </trans-unit>
        <trans-unit id="30b419cdf31db8213f868433400e90eb5bd6bd09" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_from</source>
          <target state="translated">BarrierWaitResult::try_from</target>
        </trans-unit>
        <trans-unit id="917cd48270dee8a42dabe702984f20fa69cc47a8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_into</source>
          <target state="translated">BarrierWaitResult::try_into</target>
        </trans-unit>
        <trans-unit id="29252f73362aacd393a5eec57cfc8edfc91915f8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::type_id</source>
          <target state="translated">BarrierWaitResult::type_id</target>
        </trans-unit>
        <trans-unit id="0798504393a70fe84f8d6d8445159e80798bd3ac" translate="yes" xml:space="preserve">
          <source>Barriers are re-usable after all threads have rendezvoused once, and can be used continuously.</source>
          <target state="translated">屏障在所有线程会合一次后可重复使用,可连续使用。</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">基本使用方法</target>
        </trans-unit>
        <trans-unit id="e688514e6e0a6b01ae26314b3eb88e5e53881bcb" translate="yes" xml:space="preserve">
          <source>Basic behavior:</source>
          <target state="translated">基本行为。</target>
        </trans-unit>
        <trans-unit id="11bf4d2856fba52165f40435250d1ec2e6c3316a" translate="yes" xml:space="preserve">
          <source>Basic functions for dealing with memory.</source>
          <target state="translated">处理内存的基本功能。</target>
        </trans-unit>
        <trans-unit id="ec83756dfd527ebf8f2a042db474987a95d353c4" translate="yes" xml:space="preserve">
          <source>Basic implementation of &lt;code&gt;FromStr&lt;/code&gt; on an example &lt;code&gt;Point&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;FromStr&lt;/code&gt; 在示例 &lt;code&gt;Point&lt;/code&gt; 类型上的基本实现：</target>
        </trans-unit>
        <trans-unit id="c3d9f55cf67e9ea4d900c6c2497ec5a08343c0a5" translate="yes" xml:space="preserve">
          <source>Basic mathematical constants.</source>
          <target state="translated">基本数学常数。</target>
        </trans-unit>
        <trans-unit id="03619f20093f70d07eb4c7482bb00f0ec8e3c3fc" translate="yes" xml:space="preserve">
          <source>Basic pattern matching on &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; 的&lt;/a&gt;基本模式匹配：</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">基本用途</target>
        </trans-unit>
        <trans-unit id="30a9f8a0441549550539e36ec0f9f9002255cfd0" translate="yes" xml:space="preserve">
          <source>Basic usage example:</source>
          <target state="translated">基本用法示例。</target>
        </trans-unit>
        <trans-unit id="4ba20db65bc2f86fd8313d56d1906d6e40c680fc" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, a type that implements &lt;code&gt;FromStr&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 的&lt;/a&gt;基本用法，一种实现 &lt;code&gt;FromStr&lt;/code&gt; 的类型：</target>
        </trans-unit>
        <trans-unit id="e86fea8c030e7f6d48033a20b07738fb6cc7d1e1" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 的&lt;/a&gt;基本用法：</target>
        </trans-unit>
        <trans-unit id="a8f910f3980e5f4caf7f91e6c92b1c5ff7ef8744" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;&amp;amp;i32&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;amp;i32&lt;/code&gt; 的基本用法：</target>
        </trans-unit>
        <trans-unit id="4b7db61f0810a48b5403cec32d70374937db6803" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;f64&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; 的基本用法：</target>
        </trans-unit>
        <trans-unit id="473dba01450bbaa0ba0aec1bf0715ab6ef2ccb9f" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;i32&lt;/code&gt; 的基本用法：</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">基本用途。</target>
        </trans-unit>
        <trans-unit id="ae854127dfb82027c5681daec7e882045161fa8e" translate="yes" xml:space="preserve">
          <source>Be a &lt;a href=&quot;associated-items#methods&quot;&gt;method&lt;/a&gt; that does not use &lt;code&gt;Self&lt;/code&gt; except in the type of the receiver.</source>
          <target state="translated">是&lt;a href=&quot;associated-items#methods&quot;&gt;一种&lt;/a&gt;除了接收者类型以外都不使用&amp;ldquo; &lt;code&gt;Self&lt;/code&gt; &amp;rdquo;的方法。</target>
        </trans-unit>
        <trans-unit id="a9609503521663742afb4db6d34fce975c5ef790" translate="yes" xml:space="preserve">
          <source>Be aware that operations on seemingly non-ASCII characters can sometimes have unexpected results. Consider this example:</source>
          <target state="translated">请注意,对看似非ASCII字符的操作有时会产生意想不到的结果。请看这个例子。</target>
        </trans-unit>
        <trans-unit id="f7eed2246078297c7f3c1974fe5ece00f24fc71c" translate="yes" xml:space="preserve">
          <source>Be careful when publishing a crate because a publish is &lt;em&gt;permanent&lt;/em&gt;. The version can never be overwritten, and the code cannot be deleted. One major goal of &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; is to act as a permanent archive of code so that builds of all projects that depend on crates from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; will continue to work. Allowing version deletions would make fulfilling that goal impossible. However, there is no limit to the number of crate versions you can publish.</source>
          <target state="translated">发布板条箱时要小心，因为发布是&lt;em&gt;永久性的&lt;/em&gt;。该版本永远不会被覆盖，并且代码也无法删除。&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io的&lt;/a&gt;一个主要目标是充当代码的永久存档，以便依赖&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io的crates.io&lt;/a&gt;的所有项目的构建将继续起作用。允许删除版本将无法实现该目标。但是，您可以发布的板条箱版本数量没有限制。</target>
        </trans-unit>
        <trans-unit id="dca86f7e9af3880530e74de899f022486c60c4c6" translate="yes" xml:space="preserve">
          <source>Be representable in the return type &lt;code&gt;Int&lt;/code&gt;, after truncating off its fractional part</source>
          <target state="translated">截断其小数部分后，可以在返回类型 &lt;code&gt;Int&lt;/code&gt; 中表示</target>
        </trans-unit>
        <trans-unit id="944c776ebe8836f4d5f40423d2d077f777d1f2db" translate="yes" xml:space="preserve">
          <source>Be sure to copy over any bounds as well:</source>
          <target state="translated">一定要把所有的界限也复制过来。</target>
        </trans-unit>
        <trans-unit id="b7d22470344866c1dcd5a2efc22d2e6cb51a1ab2" translate="yes" xml:space="preserve">
          <source>Bear in mind that methods on infinite iterators, even those for which a result can be determined mathematically in finite time, may not terminate. Specifically, methods such as &lt;a href=&quot;trait.iterator#method.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, which in the general case require traversing every element in the iterator, are likely not to return successfully for any infinite iterators.</source>
          <target state="translated">请记住，无限迭代器上的方法，即使可以在有限时间内数学确定结果的方法，也可能不会终止。具体来说，通常需要遍历迭代器中每个元素的诸如&lt;a href=&quot;trait.iterator#method.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; 之类的&lt;/a&gt;方法对于任何无限迭代器都可能不会成功返回。</target>
        </trans-unit>
        <trans-unit id="3d00abb1d72a8bac8ecec238c14739dba53b4125" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Animal::baby_name&lt;/code&gt; is an associated function rather than a method, and thus doesn&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter, Rust can&amp;rsquo;t figure out which implementation of &lt;code&gt;Animal::baby_name&lt;/code&gt; we want. We&amp;rsquo;ll get this compiler error:</source>
          <target state="translated">由于 &lt;code&gt;Animal::baby_name&lt;/code&gt; 是关联的函数而不是方法，因此没有 &lt;code&gt;self&lt;/code&gt; 参数，因此Rust无法确定我们想要哪个 &lt;code&gt;Animal::baby_name&lt;/code&gt; 实现。我们将收到此编译器错误：</target>
        </trans-unit>
        <trans-unit id="e982f4d1ceaa6ebce2e39ce35fa3517925f4eb60" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Drop::drop&lt;/code&gt; is used to clean up a value, it may be dangerous to use this value after the method has been called. As &lt;code&gt;Drop::drop&lt;/code&gt; does not take ownership of its input, Rust prevents misuse by not allowing you to call &lt;code&gt;Drop::drop&lt;/code&gt; directly.</source>
          <target state="translated">由于 &lt;code&gt;Drop::drop&lt;/code&gt; 用于清除值，因此在调用方法后使用该值可能很危险。由于 &lt;code&gt;Drop::drop&lt;/code&gt; 不拥有其输入的所有权，因此Rust不允许您直接调用 &lt;code&gt;Drop::drop&lt;/code&gt; 来防止滥用。</target>
        </trans-unit>
        <trans-unit id="c77d0afa61b96acdbbf5c9bd8c7ad5776b21e2a7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Kilometers&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are the same type, we can add values of both types and we can pass &lt;code&gt;Kilometers&lt;/code&gt; values to functions that take &lt;code&gt;i32&lt;/code&gt; parameters. However, using this method, we don&amp;rsquo;t get the type checking benefits that we get from the newtype pattern discussed earlier.</source>
          <target state="translated">由于 &lt;code&gt;Kilometers&lt;/code&gt; 和 &lt;code&gt;i32&lt;/code&gt; 是同一类型，因此我们可以将这两种类型的值相加，并且可以将 &lt;code&gt;Kilometers&lt;/code&gt; 值传递给采用 &lt;code&gt;i32&lt;/code&gt; 参数的函数。但是，使用这种方法无法获得前面讨论的新类型模式所带来的类型检查优势。</target>
        </trans-unit>
        <trans-unit id="6b9cbc9e966e04746993324da12bc0b094791922" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; allows mutable borrows checked at runtime, you can mutate the value inside the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; even when the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is immutable.</source>
          <target state="translated">因为 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 允许可变的借位在运行时检查，可以突变内部的值 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 即使当 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 是不可变的。</target>
        </trans-unit>
        <trans-unit id="3648820fdd060b2ae98ec9efe9a7aa20de6bd4e7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;_x&lt;/code&gt; is moved into the function, it is automatically dropped before the function returns.</source>
          <target state="translated">由于 &lt;code&gt;_x&lt;/code&gt; 已移入函数，因此它将在函数返回之前自动删除。</target>
        </trans-unit>
        <trans-unit id="02501fd298567a0388a172b4febd506fefcf8337" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which collection you're trying to collect into.</source>
          <target state="translated">由于 &lt;code&gt;collect()&lt;/code&gt; 非常通用，因此可能导致类型推断问题。这样， &lt;code&gt;collect()&lt;/code&gt; 是您会亲切地看到被称为&amp;ldquo; turbofish&amp;rdquo;的语法之一的::: &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; 。这有助于推理算法特别了解您要收集到的集合。</target>
        </trans-unit>
        <trans-unit id="f792523afdd09554f3c4c09b932d34d5d3beab5f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:</source>
          <target state="translated">因为 &lt;code&gt;collect()&lt;/code&gt; 只关心您要收集的内容，所以您仍然可以对turbofish 使用部分类型提示 &lt;code&gt;_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b2e79e04cb1d4d369cbb0462d719cf25107b631b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fancy_ref&lt;/code&gt; still holds a reference to &lt;code&gt;fancy_num&lt;/code&gt;, &lt;code&gt;fancy_num&lt;/code&gt; can't be assigned to a new value as it would invalidate the reference.</source>
          <target state="translated">由于 &lt;code&gt;fancy_ref&lt;/code&gt; 仍然保留对 &lt;code&gt;fancy_num&lt;/code&gt; 的引用，因此无法将 &lt;code&gt;fancy_num&lt;/code&gt; 分配给新值，因为它将使该引用无效。</target>
        </trans-unit>
        <trans-unit id="ad62e74aea9006b0878a087eb02874ec0ddf69c6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;find()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">因为 &lt;code&gt;find()&lt;/code&gt; 接受引用，并且许多迭代器遍历引用，所以这会导致参数为双重引用的情况出现混乱。您可以在下面的示例中使用 &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; 看到这种效果。</target>
        </trans-unit>
        <trans-unit id="8154baa71c56f29ade9fab7717781feba4bbd572" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;if&lt;/code&gt; is an expression, we can use it on the right side of a &lt;code&gt;let&lt;/code&gt; statement, as in Listing 3-2.</source>
          <target state="translated">因为 &lt;code&gt;if&lt;/code&gt; 是一个表达式，所以我们可以在 &lt;code&gt;let&lt;/code&gt; 语句的右侧使用它，如清单3-2所示。</target>
        </trans-unit>
        <trans-unit id="9997aaaef6017b0cb2af61885b73aab100c2b5f6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map&lt;/code&gt; takes a closure, we can specify any operation we want to perform on each item. This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the &lt;code&gt;Iterator&lt;/code&gt; trait provides.</source>
          <target state="translated">由于 &lt;code&gt;map&lt;/code&gt; 采用闭包形式，因此我们可以指定要对每个项目执行的任何操作。这是一个很好的示例，说明了闭包如何让您自定义某些行为，同时重用 &lt;code&gt;Iterator&lt;/code&gt; 特征提供的迭代行为。</target>
        </trans-unit>
        <trans-unit id="b6c4314864b0e06485267f3ca664e542a4a9d24f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="translated">因为 &lt;code&gt;map_while()&lt;/code&gt; 需要查看该值以查看是否应该包含它，所以使用迭代器的人会看到它已被删除：</target>
        </trans-unit>
        <trans-unit id="3d80f24c4a2216ac3e891c23c7f333250fe61032" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;parse&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;parse&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which type you're trying to parse into.</source>
          <target state="translated">由于 &lt;code&gt;parse&lt;/code&gt; 是如此笼统，因此可能导致类型推断问题。因此， &lt;code&gt;parse&lt;/code&gt; 是您会发现该语法被亲切地称为&amp;ldquo; turbofish&amp;rdquo;的少数几次之一：:: &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; 。这有助于推理算法特别了解您要解析为哪种类型。</target>
        </trans-unit>
        <trans-unit id="f088d61355fe261cd42315fc674f33d7a3ce9310" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;peek()&lt;/code&gt; returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below.</source>
          <target state="translated">因为 &lt;code&gt;peek()&lt;/code&gt; 返回一个引用，并且许多迭代器遍历该引用，所以在返回值是双引用的情况下可能会造成混淆。您可以在下面的示例中看到这种效果。</target>
        </trans-unit>
        <trans-unit id="9a4418890cc2a26bb07a69375b759eb2f8d9d03d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;peek_mut()&lt;/code&gt; returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below.</source>
          <target state="translated">因为 &lt;code&gt;peek_mut()&lt;/code&gt; 返回一个引用，并且许多迭代器在该引用上进行迭代，所以在返回值是双引用的情况下可能会造成混淆。您可以在下面的示例中看到这种效果。</target>
        </trans-unit>
        <trans-unit id="a7eb647ad22291b28a51fd607cc84aff6f4abc83" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;rfind()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">因为 &lt;code&gt;rfind()&lt;/code&gt; 接受引用，并且许多迭代器遍历引用，所以这导致参数可能是双重引用的情况可能令人困惑。您可以在下面的示例中使用 &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; 看到这种效果。</target>
        </trans-unit>
        <trans-unit id="ddf1f7383234f0909d810cef598c63fc6f240534" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;s&lt;/code&gt; is created inside &lt;code&gt;dangle&lt;/code&gt;, when the code of &lt;code&gt;dangle&lt;/code&gt; is finished, &lt;code&gt;s&lt;/code&gt; will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid &lt;code&gt;String&lt;/code&gt;. That&amp;rsquo;s no good! Rust won&amp;rsquo;t let us do this.</source>
          <target state="translated">因为 &lt;code&gt;s&lt;/code&gt; 是内部产生 &lt;code&gt;dangle&lt;/code&gt; ，当所述代码 &lt;code&gt;dangle&lt;/code&gt; 完成时， &lt;code&gt;s&lt;/code&gt; 将被释放。但是我们试图返回对它的引用。这意味着此引用将指向无效的 &lt;code&gt;String&lt;/code&gt; 。那不好！Rust不会让我们这样做。</target>
        </trans-unit>
        <trans-unit id="ad3a4a81012df51bdd1c2d631b8bd2d26a080ac6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;take_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="translated">因为 &lt;code&gt;take_while()&lt;/code&gt; 需要查看该值以查看是否应该包含它，所以使用迭代器的人会看到它已被删除：</target>
        </trans-unit>
        <trans-unit id="a2c09e5f782c06a87c2e923fecb0abf777de8d4b" translate="yes" xml:space="preserve">
          <source>Because Rust compiles generic code into code that specifies the type in each instance, we pay no runtime cost for using generics. When the code runs, it performs just as it would if we had duplicated each definition by hand. The process of monomorphization makes Rust&amp;rsquo;s generics extremely efficient at runtime.</source>
          <target state="translated">因为Rust将通用代码编译成在每个实例中指定类型的代码，所以我们无需为使用通用而付出任何运行时成本。代码运行时，它的性能与我们手工复制每个定义时的性能相同。单态化的过程使Rust的泛型在运行时非常高效。</target>
        </trans-unit>
        <trans-unit id="cb2c4627fadc957440586a7d9c240acafefffc6b" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer, Rust always knows how much space a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; needs: a pointer&amp;rsquo;s size doesn&amp;rsquo;t change based on the amount of data it&amp;rsquo;s pointing to. This means we can put a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; inside the &lt;code&gt;Cons&lt;/code&gt; variant instead of another &lt;code&gt;List&lt;/code&gt; value directly. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will point to the next &lt;code&gt;List&lt;/code&gt; value that will be on the heap rather than inside the &lt;code&gt;Cons&lt;/code&gt; variant. Conceptually, we still have a list, created with lists &amp;ldquo;holding&amp;rdquo; other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</source>
          <target state="translated">因为 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 是指针，所以Rust始终知道 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 需要多少空间：指针的大小不会根据其指向的数据量而变化。这意味着我们可以在 &lt;code&gt;Cons&lt;/code&gt; 变量中放置 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ，而不是直接在另一个 &lt;code&gt;List&lt;/code&gt; 值中放置。的 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 将指向下一个 &lt;code&gt;List&lt;/code&gt; 值，这将是在堆上而不是内部 &lt;code&gt;Cons&lt;/code&gt; 变体。从概念上讲，我们仍然有一个列表，该列表是用列表&amp;ldquo;保存&amp;rdquo;其他列表创建的，但是此实现现在更像是将项目彼此相邻放置而不是彼此放置。</target>
        </trans-unit>
        <trans-unit id="cf81e03b95485ed347873e7e3fe9e72472e6c6b8" translate="yes" xml:space="preserve">
          <source>Because async blocks construct a future, they define an &lt;strong&gt;async context&lt;/strong&gt; which can in turn contain &lt;a href=&quot;await-expr&quot;&gt;&lt;code&gt;await&lt;/code&gt; expressions&lt;/a&gt;. Async contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks.</source>
          <target state="translated">因为异步块构成了一个未来，所以它们定义了一个&lt;strong&gt;异步上下文&lt;/strong&gt;，该&lt;strong&gt;上下文&lt;/strong&gt;又可以包含&lt;a href=&quot;await-expr&quot;&gt; &lt;code&gt;await&lt;/code&gt; 表达式&lt;/a&gt;。异步上下文是由异步块以及异步函数的主体建立的，异步函数的语义是根据异步块定义的。</target>
        </trans-unit>
        <trans-unit id="1af0938fa6746a245ca497556ef936994388e62f" translate="yes" xml:space="preserve">
          <source>Because captures are often by reference, the following general rules arise:</source>
          <target state="translated">由于捕捉往往是通过参考,因此产生了以下一般规则。</target>
        </trans-unit>
        <trans-unit id="48453fbdaf06b97c2a50276382893c7136610cb4" translate="yes" xml:space="preserve">
          <source>Because forgetting a value is allowed, any &lt;code&gt;unsafe&lt;/code&gt; code you write must allow for this possibility. You cannot return a value and expect that the caller will necessarily run the value's destructor.</source>
          <target state="translated">因为允许忘记一个值，所以您编写的任何 &lt;code&gt;unsafe&lt;/code&gt; 代码都必须允许这种可能性。您不能返回值，并且期望调用者一定会运行该值的析构函数。</target>
        </trans-unit>
        <trans-unit id="757a75cd5c62512d1ecdcf5444c4066082ba840e" translate="yes" xml:space="preserve">
          <source>Because having variable names match the fields is common and because writing &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; contains a lot of duplication, there is a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 18-13 shows code that behaves in the same way as the code in Listing 18-12, but the variables created in the &lt;code&gt;let&lt;/code&gt; pattern are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; instead of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">因为使变量名匹配字段是常见的，并且因为写 &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; 包含很多重复项，匹配结构域的模式有一个简写：您只需要列出结构域的名称，并且从该模式创建的变量将具有相同的名称。清单18-13显示了与清单18-12中的代码行为相同的代码，但是在 &lt;code&gt;let&lt;/code&gt; 模式中创建的变量是 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 而不是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83438caeb4e092f6346d53e11e3dc5cc7d15ebb0" translate="yes" xml:space="preserve">
          <source>Because marker traits are allowed to have multiple implementations for the same type, it's not allowed to override anything in those implementations, as it would be ambiguous which override should actually be used.</source>
          <target state="translated">因为标记性状允许同一类型有多个实现,所以不允许在这些实现中覆盖任何东西,因为实际应该使用哪个覆盖会有歧义。</target>
        </trans-unit>
        <trans-unit id="e1154d896f41e24691d4a2066a20e9a97b30a6b0" translate="yes" xml:space="preserve">
          <source>Because of the call to the &lt;code&gt;foo&lt;/code&gt; macro, the compiler guesses that the missing module could be inside it and fails because the macro definition cannot be found.</source>
          <target state="translated">由于对 &lt;code&gt;foo&lt;/code&gt; 宏的调用，编译器猜测缺少的模块可能在其中，并且由于找不到宏定义而失败。</target>
        </trans-unit>
        <trans-unit id="620af94cb9d051d4dfe9f749a85e09b10b24aa07" translate="yes" xml:space="preserve">
          <source>Because of the early return, &lt;code&gt;try!&lt;/code&gt; can only be used in functions that return &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于早日返回，请 &lt;code&gt;try!&lt;/code&gt; 只能用于返回&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; 的&lt;/a&gt;函数中。</target>
        </trans-unit>
        <trans-unit id="9c9db3f614804b168272d0d3012c3d9bae7f766b" translate="yes" xml:space="preserve">
          <source>Because of this dual purpose, it is possible to create types that are not useful for interfacing with the C programming language.</source>
          <target state="translated">由于这种双重目的,可以创建一些对与C语言编程语言接口无用的类型。</target>
        </trans-unit>
        <trans-unit id="6eba9459a54a420c4009843eca1a3d7462a26445" translate="yes" xml:space="preserve">
          <source>Because of this recursive dropping, you do not need to implement this trait unless your type needs its own destructor logic.</source>
          <target state="translated">由于这种递归的投放,你不需要实现这个特性,除非你的类型需要自己的destructor逻辑。</target>
        </trans-unit>
        <trans-unit id="df92f9c80443d85d1d1f8c4ed514d9988ba7345d" translate="yes" xml:space="preserve">
          <source>Because of this, the behavior when both &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; exist differs. On Unix, if &lt;code&gt;from&lt;/code&gt; is a directory, &lt;code&gt;to&lt;/code&gt; must also be an (empty) directory. If &lt;code&gt;from&lt;/code&gt; is not a directory, &lt;code&gt;to&lt;/code&gt; must also be not a directory. In contrast, on Windows, &lt;code&gt;from&lt;/code&gt; can be anything, but &lt;code&gt;to&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be a directory.</source>
          <target state="translated">正因为如此，该行为，当两者 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 存在不同。在Unix上，如果 &lt;code&gt;from&lt;/code&gt; 是目录，则 &lt;code&gt;to&lt;/code&gt; 也必须是一个（空）目录。如果 &lt;code&gt;from&lt;/code&gt; 不是目录，则 &lt;code&gt;to&lt;/code&gt; 也一定不是目录。与此相反，在Windows上， &lt;code&gt;from&lt;/code&gt; 可以是任何东西，但 &lt;code&gt;to&lt;/code&gt; 绝&lt;em&gt;不能&lt;/em&gt;是一个目录。</target>
        </trans-unit>
        <trans-unit id="edb25a77d997330fe82c62f487b65b2a449f7a57" translate="yes" xml:space="preserve">
          <source>Because of this, you must give the numeric literal or binding a type:</source>
          <target state="translated">正因为如此,你必须给数字文字或绑定一个类型。</target>
        </trans-unit>
        <trans-unit id="f5828ddf70feaedc77b7fe1498bca4e7ef61a70f" translate="yes" xml:space="preserve">
          <source>Because ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the more you&amp;rsquo;ll be able to naturally develop code that is safe and efficient. Keep at it!</source>
          <target state="translated">因为所有权是许多程序员的新概念，所以它确实需要一些时间来习惯。好消息是，您对Rust和所有权系统的规则越有经验，就越能自然开发安全有效的代码。继续吧！</target>
        </trans-unit>
        <trans-unit id="e400474ad8de5abb677ee1fb6adda287a3d95af5" translate="yes" xml:space="preserve">
          <source>Because raw entries provide much more low-level control, it's much easier to put the HashMap into an inconsistent state which, while memory-safe, will cause the map to produce seemingly random results. Higher-level and more foolproof APIs like &lt;code&gt;entry&lt;/code&gt; should be preferred when possible.</source>
          <target state="translated">由于原始条目提供了更多的低层控制，因此将HashMap置于不一致状态会容易得多，尽管这种状态是内存安全的，但会导致映射产生看似随机的结果。尽可能使用更高级，更简单的API（例如 &lt;code&gt;entry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25432f6301bbde0b420035486d49aeb28bde5fd2" translate="yes" xml:space="preserve">
          <source>Because some analysis is impossible, if the Rust compiler can&amp;rsquo;t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it&amp;rsquo;s conservative. If Rust accepted an incorrect program, users wouldn&amp;rsquo;t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type is useful when you&amp;rsquo;re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</source>
          <target state="translated">由于无法进行某些分析，因此，如果Rust编译器无法确定代码是否符合所有权规则，则可能会拒绝正确的程序；这样，它很保守。如果Rust接受了不正确的程序，则用户将无法信任Rust提供的保证。但是，如果Rust拒绝正确的程序，程序员将感到不便，但是不会发生灾难性事件。该 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 当你确定你的代码如下借用规则类型是有用的，但编译器无法理解和保证。</target>
        </trans-unit>
        <trans-unit id="029a6be2649372b5b88e5ae502ff0638c469c42e" translate="yes" xml:space="preserve">
          <source>Because strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options. Some of them can seem redundant, but they all have their place! In this case, &lt;code&gt;String::from&lt;/code&gt; and &lt;code&gt;to_string&lt;/code&gt; do the same thing, so which you choose is a matter of style.</source>
          <target state="translated">因为字符串用于很多事情，所以我们可以对字符串使用许多不同的通用API，从而为我们提供了很多选择。其中一些似乎多余，但它们都有自己的位置！在这种情况下， &lt;code&gt;String::from&lt;/code&gt; 和 &lt;code&gt;to_string&lt;/code&gt; 会做同样的事情，因此您选择的样式是问题。</target>
        </trans-unit>
        <trans-unit id="1b950a204977447e5ef7cd3c6942f49baa8eb222" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;enumerate&lt;/code&gt; method returns a tuple, we can use patterns to destructure that tuple, just like everywhere else in Rust. So in the &lt;code&gt;for&lt;/code&gt; loop, we specify a pattern that has &lt;code&gt;i&lt;/code&gt; for the index in the tuple and &lt;code&gt;&amp;amp;item&lt;/code&gt; for the single byte in the tuple. Because we get a reference to the element from &lt;code&gt;.iter().enumerate()&lt;/code&gt;, we use &lt;code&gt;&amp;amp;&lt;/code&gt; in the pattern.</source>
          <target state="translated">因为 &lt;code&gt;enumerate&lt;/code&gt; 方法返回一个元组，所以我们可以使用模式来破坏该元组，就像Rust中的其他地方一样。因此，在 &lt;code&gt;for&lt;/code&gt; 循环中，我们指定一个模式，该模式在元组中的索引中具有 &lt;code&gt;i&lt;/code&gt; ，在元组中的单个字节中具有 &lt;code&gt;&amp;amp;item&lt;/code&gt; 。因为我们从 &lt;code&gt;.iter().enumerate()&lt;/code&gt; 获得对元素的引用，所以在模式中使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bad4d17c2470c688d65e4cf4cd29dd8d9a6843c" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;fly&lt;/code&gt; method takes a &lt;code&gt;self&lt;/code&gt; parameter, if we had two &lt;em&gt;types&lt;/em&gt; that both implement one &lt;em&gt;trait&lt;/em&gt;, Rust could figure out which implementation of a trait to use based on the type of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">因为 &lt;code&gt;fly&lt;/code&gt; 方法带有一个 &lt;code&gt;self&lt;/code&gt; 参数，所以如果我们有两种都实现一个&lt;em&gt;特征的&lt;/em&gt;&lt;em&gt;类型&lt;/em&gt;，Rust可以根据 &lt;code&gt;self&lt;/code&gt; 的类型确定要使用哪种特征实现。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dfa04ea7812d8d0a045650338922229931556bb" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;toast&lt;/code&gt; field in the &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct is public, in &lt;code&gt;eat_at_restaurant&lt;/code&gt; we can write and read to the &lt;code&gt;toast&lt;/code&gt; field using dot notation. Notice that we can&amp;rsquo;t use the &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because &lt;code&gt;seasonal_fruit&lt;/code&gt; is private. Try uncommenting the line modifying the &lt;code&gt;seasonal_fruit&lt;/code&gt; field value to see what error you get!</source>
          <target state="translated">由于 &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 结构中的 &lt;code&gt;toast&lt;/code&gt; 字段是公共的，因此在 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中,我们可以使用点符号对 &lt;code&gt;toast&lt;/code&gt; 字段进行写入和读取。请注意，我们不能使用 &lt;code&gt;seasonal_fruit&lt;/code&gt; 现场 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 因为 &lt;code&gt;seasonal_fruit&lt;/code&gt; 是私人的。尝试取消注释修改 &lt;code&gt;seasonal_fruit&lt;/code&gt; 字段值的行的注释，以查看出现什么错误！</target>
        </trans-unit>
        <trans-unit id="185de19b862032b52b28484b2c6cc55792a266c3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;write&lt;/code&gt; operation could fail, we use &lt;code&gt;unwrap&lt;/code&gt; on any error result as before. Again, in a real application you would add error handling here. Finally, &lt;code&gt;flush&lt;/code&gt; will wait and prevent the program from continuing until all the bytes are written to the connection; &lt;code&gt;TcpStream&lt;/code&gt; contains an internal buffer to minimize calls to the underlying operating system.</source>
          <target state="translated">因为 &lt;code&gt;write&lt;/code&gt; 操作可能失败，所以我们像以前一样对任何错误结果使用 &lt;code&gt;unwrap&lt;/code&gt; 。同样，在实际的应用程序中，您将在此处添加错误处理。最后， &lt;code&gt;flush&lt;/code&gt; 将等待并阻止程序继续运行，直到将所有字节写入连接为止。 &lt;code&gt;TcpStream&lt;/code&gt; 包含一个内部缓冲区，以最大程度地减少对底层操作系统的调用。</target>
        </trans-unit>
        <trans-unit id="1b1f6fd955e3dd56c20447476cad2f0ff374150c" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;filter()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">因为传递给 &lt;code&gt;filter()&lt;/code&gt; 的闭包采用了引用，并且许多迭代器都在引用上进行迭代，所以这可能导致混乱的情况，其中闭包的类型是双重引用：</target>
        </trans-unit>
        <trans-unit id="58c9579a8a89655df95e712d81cbf2a21bf02a65" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;skip_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">因为传递给 &lt;code&gt;skip_while()&lt;/code&gt; 的闭包采用了引用，并且许多迭代器都在引用上进行迭代，所以这可能导致混乱的情况，其中闭包的类型是双重引用：</target>
        </trans-unit>
        <trans-unit id="8479afb170cef741fbbcede9d3610679171e5033" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;take_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">因为传递给 &lt;code&gt;take_while()&lt;/code&gt; 的闭包采用了引用，并且许多迭代器都在引用上进行迭代，所以这可能导致混乱的情况，其中闭包的类型是双重引用：</target>
        </trans-unit>
        <trans-unit id="2eb937137f69efc7f4d05e71e805b680ad9ce55c" translate="yes" xml:space="preserve">
          <source>Because the correct result of the &lt;code&gt;can_hold&lt;/code&gt; function in this case is &lt;code&gt;false&lt;/code&gt;, we need to negate that result before we pass it to the &lt;code&gt;assert!&lt;/code&gt; macro. As a result, our test will pass if &lt;code&gt;can_hold&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">因为在这种情况下 &lt;code&gt;can_hold&lt;/code&gt; 函数的正确结果为 &lt;code&gt;false&lt;/code&gt; ，所以我们需要在将该结果传递给 &lt;code&gt;assert!&lt;/code&gt; 之前将其取反！宏。结果，如果 &lt;code&gt;can_hold&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ，我们的测试将通过：</target>
        </trans-unit>
        <trans-unit id="90666aa0415ee00d8f72df1807729b34de2b7424" translate="yes" xml:space="preserve">
          <source>Because the function item type explicitly identifies the function, the item types of different functions - different items, or the same item with different generics - are distinct, and mixing them will create a type error:</source>
          <target state="translated">因为函数项类型明确标识了函数,所以不同函数的项类型--不同的项,或者同一项不同的属,都是不同的,混用会产生类型错误。</target>
        </trans-unit>
        <trans-unit id="91472ca2849f01f7f3aadf84c45216c15e72f922" translate="yes" xml:space="preserve">
          <source>Because the goal is to keep all these rules inside the structs that implement &lt;code&gt;State&lt;/code&gt;, we call a &lt;code&gt;content&lt;/code&gt; method on the value in &lt;code&gt;state&lt;/code&gt; and pass the post instance (that is, &lt;code&gt;self&lt;/code&gt;) as an argument. Then we return the value that is returned from using the &lt;code&gt;content&lt;/code&gt; method on the &lt;code&gt;state&lt;/code&gt; value.</source>
          <target state="translated">因为目标是将所有这些规则保留在实现 &lt;code&gt;State&lt;/code&gt; 的结构中，所以我们对 &lt;code&gt;state&lt;/code&gt; 中的值调用 &lt;code&gt;content&lt;/code&gt; 方法，并将post实例（即 &lt;code&gt;self&lt;/code&gt; ）作为参数传递。然后，我们在 &lt;code&gt;state&lt;/code&gt; 值上返回使用 &lt;code&gt;content&lt;/code&gt; 方法返回的值。</target>
        </trans-unit>
        <trans-unit id="030b08f8ea47335b102e955f832da8f8f1553c44" translate="yes" xml:space="preserve">
          <source>Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the &lt;em&gt;field init shorthand&lt;/em&gt; syntax to rewrite &lt;code&gt;build_user&lt;/code&gt; so that it behaves exactly the same but doesn&amp;rsquo;t have the repetition of &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt;, as shown in Listing 5-5.</source>
          <target state="translated">因为清单5-5中的参数名称和struct字段名称完全相同，所以我们可以使用&lt;em&gt;field init速记&lt;/em&gt;语法重写 &lt;code&gt;build_user&lt;/code&gt; ，使其行为完全相同，但不会重复 &lt;code&gt;email&lt;/code&gt; 和 &lt;code&gt;username&lt;/code&gt; ，例如如清单5-5所示。</target>
        </trans-unit>
        <trans-unit id="d69419dfb414355067e2d4508090380593ccdd03" translate="yes" xml:space="preserve">
          <source>Because the standard library has this blanket implementation, we can call the &lt;code&gt;to_string&lt;/code&gt; method defined by the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. For example, we can turn integers into their corresponding &lt;code&gt;String&lt;/code&gt; values like this because integers implement &lt;code&gt;Display&lt;/code&gt;:</source>
          <target state="translated">因为标准库具有这种全面的实现，所以我们可以在实现 &lt;code&gt;Display&lt;/code&gt; 特性的任何类型上调用 &lt;code&gt;ToString&lt;/code&gt; 特性定义的 &lt;code&gt;to_string&lt;/code&gt; 方法。例如，我们可以像这样将整数转换为其相应的 &lt;code&gt;String&lt;/code&gt; 值，因为整数实现 &lt;code&gt;Display&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="37ef1e15d186d9fd04a65d1942d30d946ce68135" translate="yes" xml:space="preserve">
          <source>Because the third rule really only applies in method signatures, we&amp;rsquo;ll look at lifetimes in that context next to see why the third rule means we don&amp;rsquo;t have to annotate lifetimes in method signatures very often.</source>
          <target state="translated">因为第三条规则实际上仅适用于方法签名，所以接下来我们将在该上下文中查看生命周期，以了解为什么第三条规则意味着我们不必经常在方法签名中注释生命周期。</target>
        </trans-unit>
        <trans-unit id="70d45c4687665d4e0a5b39f62a85fe258555be07" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="translated">因为 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 引用的值可能已被删除，所以要对 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 指向的值进行任何操作，必须确保该值仍然存在。通过在 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 实例上调用 &lt;code&gt;upgrade&lt;/code&gt; 方法来执行此操作，该方法将返回 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 。你会得到的结果 &lt;code&gt;Some&lt;/code&gt; 如果 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值一直没有下降还和结果 &lt;code&gt;None&lt;/code&gt; ，如果 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值已被删除。由于 &lt;code&gt;upgrade&lt;/code&gt; 返回 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ，Rust将确保&amp;ldquo; &lt;code&gt;Some&lt;/code&gt; 情况&amp;rdquo;和&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 大小写被处理，并且不会有无效的指针。</target>
        </trans-unit>
        <trans-unit id="d8bf4707482fe4f59a8a059222ee5cf8616fe8ba" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="translated">因为 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 引用的值可能已被删除，所以要对 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 指向的值进行任何操作，必须确保该值仍然存在。为此，请在 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 实例上调用 &lt;code&gt;upgrade&lt;/code&gt; 方法，该实例将返回 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 。你会得到的结果 &lt;code&gt;Some&lt;/code&gt; 如果 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值一直没有下降还和结果 &lt;code&gt;None&lt;/code&gt; ，如果 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值已被删除。由于 &lt;code&gt;upgrade&lt;/code&gt; 返回 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ，因此Rust将确保&amp;ldquo; &lt;code&gt;Some&lt;/code&gt; 情况&amp;rdquo;和&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 大小写被处理，并且不会有无效的指针。</target>
        </trans-unit>
        <trans-unit id="14741fffc1dc74532e1921d454b0c26246f646ef" translate="yes" xml:space="preserve">
          <source>Because the vast majority of Rust projects use Cargo, the rest of this book assumes that you&amp;rsquo;re using Cargo too. Cargo comes installed with Rust if you used the official installers discussed in the &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo;&lt;/a&gt; section. If you installed Rust through some other means, check whether Cargo is installed by entering the following into your terminal:</source>
          <target state="translated">由于绝大多数Rust项目都使用Cargo，因此本书的其余部分都假定您也在使用Cargo。如果您使用了&lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;ldquo;安装&amp;rdquo;&lt;/a&gt;一节中讨论的官方安装程序，则Rust会随货一起安装货物。如果您通过其他方式安装了Rust，请在终端中输入以下内容，检查是否已安装Cargo：</target>
        </trans-unit>
        <trans-unit id="50d3009a3e9b08a6e3dea49369c4a3eff85c4a99" translate="yes" xml:space="preserve">
          <source>Because they are traits, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; are implemented by a number of other types, and you can implement them for your types too. As such, you'll see a few different types of I/O throughout the documentation in this module: &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;s, and sometimes even &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;s. For example, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; adds a &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; method, which we can use on &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">因为他们的特质，&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;由很多其他类型的实现，并且可以实现他们为你的类型了。这样，您将在本模块的整个文档中看到几种不同类型的I / O：&lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;，有时甚至是&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。例如，&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;添加了一个&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;方法，我们可以在&lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 上&lt;/a&gt;使用它：</target>
        </trans-unit>
        <trans-unit id="e07ae336ff59e9ed0b225ca89429b661de0679cf" translate="yes" xml:space="preserve">
          <source>Because this declaration is in the &lt;code&gt;std::io&lt;/code&gt; module, we can use the fully qualified alias &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt;&amp;mdash;that is, a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with the &lt;code&gt;E&lt;/code&gt; filled in as &lt;code&gt;std::io::Error&lt;/code&gt;. The &lt;code&gt;Write&lt;/code&gt; trait function signatures end up looking like this:</source>
          <target state="translated">由于此声明位于 &lt;code&gt;std::io&lt;/code&gt; 模块中，因此我们可以使用完全限定的别名 &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt; -即， &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;E&lt;/code&gt; 填充为 &lt;code&gt;std::io::Error&lt;/code&gt; 。在 &lt;code&gt;Write&lt;/code&gt; 特征函数签名最终看起来是这样的：</target>
        </trans-unit>
        <trans-unit id="4d78cf22aaa22c544c68896425f6652ea68b656d" translate="yes" xml:space="preserve">
          <source>Because this error message starts with the text we specified, &lt;code&gt;Failed to open hello.txt&lt;/code&gt;, it will be easier to find where in the code this error message is coming from. If we use &lt;code&gt;unwrap&lt;/code&gt; in multiple places, it can take more time to figure out exactly which &lt;code&gt;unwrap&lt;/code&gt; is causing the panic because all &lt;code&gt;unwrap&lt;/code&gt; calls that panic print the same message.</source>
          <target state="translated">由于此错误消息以我们指定的文本（ &lt;code&gt;Failed to open hello.txt&lt;/code&gt; ，因此更容易找到此错误消息来自何处。如果我们使用 &lt;code&gt;unwrap&lt;/code&gt; 在多个地方，可能需要更多的时间来弄清楚到底哪些 &lt;code&gt;unwrap&lt;/code&gt; 引起，因为所有的恐慌 &lt;code&gt;unwrap&lt;/code&gt; 调用，恐慌打印相同的消息。</target>
        </trans-unit>
        <trans-unit id="f9ecc9d043c4a1c0a98d5acfc2202fd98ea778e6" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.option#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.option#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于此功能可能会引起恐慌，因此一般不建议使用该功能。相反，更喜欢使用模式匹配并显式处理&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;情况，或调用&lt;a href=&quot;enum.option#method.unwrap_or&quot;&gt; &lt;code&gt;unwrap_or&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;enum.option#method.unwrap_or_default&quot;&gt; &lt;code&gt;unwrap_or_default&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="324230b46d81d1ff99203ce38c74a82aa7a9a294" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.result#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.result#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于此功能可能会引起恐慌，因此一般不建议使用该功能。相反，更喜欢使用模式匹配并显式处理&lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;情况，或者调用&lt;a href=&quot;enum.result#method.unwrap_or&quot;&gt; &lt;code&gt;unwrap_or&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;enum.result#method.unwrap_or_default&quot;&gt; &lt;code&gt;unwrap_or_default&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4fba9e24de13af0b7e1e106a0a89b1207341158" translate="yes" xml:space="preserve">
          <source>Because this representation delegates type layout to another type, it cannot be used with any other representation.</source>
          <target state="translated">因为这个表示法将类型布局委托给另一个类型,所以它不能与任何其他表示法一起使用。</target>
        </trans-unit>
        <trans-unit id="210e09fafaa62c8b440f8de035b1059405d433ec" translate="yes" xml:space="preserve">
          <source>Because transparent enums are represented exactly like one of their variants at run time, said variant must be uniquely determined. If there is no variant, or if there are multiple variants, it is not clear how the enum should be represented.</source>
          <target state="translated">因为透明枚举在运行时的表示方式与它们的一个变体完全相同,所以所述变体必须是唯一确定的。如果没有变体,或者有多个变体,就不清楚该如何表示枚举。</target>
        </trans-unit>
        <trans-unit id="fcd01a50be2628ee7e2de7196f3290d3a3e7d1ae" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-sized types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="translated">由于透明结构在运行时完全像其字段之一一样表示，因此必须唯一确定该字段。如果没有字段，或者有多个字段，则不清楚应如何表示该结构。请注意，零尺寸类型的字段（例如 &lt;code&gt;PhantomData&lt;/code&gt; ）也可以与包含实际数据的字段并存，它们不计入此错误。当涉及泛型类型时（如上例所示），将报告错误，因为type参数的大小可能为非零。</target>
        </trans-unit>
        <trans-unit id="986c4abde2bf1faaf2d6c694b66e22c945ede5c1" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-typed types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="translated">由于透明结构在运行时完全像其字段之一一样表示，因此必须唯一确定该字段。如果没有字段，或者有多个字段，则不清楚应如何表示该结构。请注意，零类型类型的字段（例如 &lt;code&gt;PhantomData&lt;/code&gt; ）也可以与包含实际数据的字段并存，它们不计入此错误。当涉及泛型类型时（如上例所示），将报告错误，因为type参数的大小可能为非零。</target>
        </trans-unit>
        <trans-unit id="f937fa2c0a9f5f4a819643c4edaf58d80a839cab" translate="yes" xml:space="preserve">
          <source>Because tuple elements don't have a name, they can only be accessed by pattern-matching or by using &lt;code&gt;N&lt;/code&gt; directly as a field to access the &lt;code&gt;N&lt;/code&gt;th element.</source>
          <target state="translated">由于元组元素没有名称，因此只能通过模式匹配或直接将 &lt;code&gt;N&lt;/code&gt; 用作访问第 &lt;code&gt;N&lt;/code&gt; 个元素的字段来访问它们。</target>
        </trans-unit>
        <trans-unit id="efb0d44a57a7bf30820d634e0cfe1255770c836f" translate="yes" xml:space="preserve">
          <source>Because two equal values need to produce the same hash value, the implementation of &lt;code&gt;Hash&lt;/code&gt; needs to ignore ASCII case, too:</source>
          <target state="translated">因为两个相等的值需要产生相同的哈希值，所以 &lt;code&gt;Hash&lt;/code&gt; 的实现也需要忽略ASCII大小写：</target>
        </trans-unit>
        <trans-unit id="b787dccee7a3448c9761d599ebe1a0e8e174bf88" translate="yes" xml:space="preserve">
          <source>Because types that are made up of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits are automatically also &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt;, we don&amp;rsquo;t have to implement those traits manually. As marker traits, they don&amp;rsquo;t even have any methods to implement. They&amp;rsquo;re just useful for enforcing invariants related to concurrency.</source>
          <target state="translated">由于由 &lt;code&gt;Send&lt;/code&gt; 和 &lt;code&gt;Sync&lt;/code&gt; 特征构成的类型也自动 &lt;code&gt;Send&lt;/code&gt; 和 &lt;code&gt;Sync&lt;/code&gt; ，因此我们不必手动实现这些特征。作为标记特征，它们甚至没有任何实现方法。它们仅用于强制执行与并发相关的不变量。</target>
        </trans-unit>
        <trans-unit id="e80dfd56aee472a3a988ee77f8d092b4c7dec341" translate="yes" xml:space="preserve">
          <source>Because we called the function with &lt;code&gt;5&lt;/code&gt; as the value for &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt; is passed as the value for &lt;code&gt;y&lt;/code&gt;, the two strings are printed with these values.</source>
          <target state="translated">因为我们用 &lt;code&gt;5&lt;/code&gt; 作为 &lt;code&gt;x&lt;/code&gt; 的值调用了函数，并且将 &lt;code&gt;6&lt;/code&gt; 作为 &lt;code&gt;y&lt;/code&gt; 的值传递了函数，所以两个字符串都印有这些值。</target>
        </trans-unit>
        <trans-unit id="085b82e8e32a790482293e536266e4e46e15732c" translate="yes" xml:space="preserve">
          <source>Because we didn&amp;rsquo;t cover (and couldn&amp;rsquo;t cover!) every valid value with the pattern &lt;code&gt;Some(x)&lt;/code&gt;, Rust rightfully produces a compiler error.</source>
          <target state="translated">因为我们没有使用模式 &lt;code&gt;Some(x)&lt;/code&gt; 覆盖（也无法覆盖！）每个有效值，所以Rust正确地产生了编译器错误。</target>
        </trans-unit>
        <trans-unit id="c4e7a282ae038191d5b4c16b5d5eaad3c33d3637" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any code that pauses or delays in the &lt;code&gt;for&lt;/code&gt; loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.</source>
          <target state="translated">因为我们在主线程的 &lt;code&gt;for&lt;/code&gt; 循环中没有暂停或延迟的任何代码，所以我们可以知道主线程正在等待从生成的线程接收值。</target>
        </trans-unit>
        <trans-unit id="9a0bac08c9a7a0c19671aaf3dbc27401041da77e" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any tests we&amp;rsquo;ve marked as ignored, the summary shows &lt;code&gt;0 ignored&lt;/code&gt;. We also haven&amp;rsquo;t filtered the tests being run, so the end of the summary shows &lt;code&gt;0 filtered out&lt;/code&gt;. We&amp;rsquo;ll talk about ignoring and filtering out tests in the next section, &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">由于我们没有任何被标记为已忽略的测试，因此摘要显示 &lt;code&gt;0 ignored&lt;/code&gt; 。我们还没有过滤正在运行的测试，因此摘要末尾显示 &lt;code&gt;0 filtered out&lt;/code&gt; 。在下一部分&lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;控制测试的运行方式&amp;rdquo;中&lt;/a&gt;，我们将讨论忽略和过滤掉测试。</target>
        </trans-unit>
        <trans-unit id="19d2af6731059978bb0fd7b94ea0d510b217b381" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t need them anymore, let&amp;rsquo;s remove the &lt;code&gt;println!&lt;/code&gt; statements from &lt;em&gt;src/lib.rs&lt;/em&gt; and &lt;em&gt;src/main.rs&lt;/em&gt; that we used to check the program&amp;rsquo;s behavior. Then, in &lt;em&gt;src/lib.rs&lt;/em&gt;, we&amp;rsquo;ll add a &lt;code&gt;tests&lt;/code&gt; module with a test function, as we did in &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;Chapter 11&lt;/a&gt;. The test function specifies the behavior we want the &lt;code&gt;search&lt;/code&gt; function to have: it will take a query and the text to search for the query in, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test, which won&amp;rsquo;t compile yet.</source>
          <target state="translated">因为我们不再需要它们，所以我们删除 &lt;code&gt;println!&lt;/code&gt; 从报表&lt;em&gt;的src / lib.rs&lt;/em&gt;和&lt;em&gt;SRC / main.rs&lt;/em&gt;我们用来检查程序的行为。然后，在&lt;em&gt;src / lib.rs中&lt;/em&gt;，我们将像&lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;第11章&lt;/a&gt;一样添加一个带有测试功能的 &lt;code&gt;tests&lt;/code&gt; 模块。测试函数指定了我们希望 &lt;code&gt;search&lt;/code&gt; 函数具有的行为：它将接受一个查询和要在其中搜索查询的文本，并且它将仅返回包含查询的文本中的行。清单12-15显示了此测试，该测试尚未编译。</target>
        </trans-unit>
        <trans-unit id="27d7fc6d652236fca2f45fe08fc889c62e6d8253" translate="yes" xml:space="preserve">
          <source>Because we just mentioned coins, let&amp;rsquo;s use them as an example using &lt;code&gt;match&lt;/code&gt;! We can write a function that can take an unknown United States coin and, in a similar way as the counting machine, determine which coin it is and return its value in cents, as shown here in Listing 6-3.</source>
          <target state="translated">因为我们刚刚提到了硬币，所以让我们将其作为使用 &lt;code&gt;match&lt;/code&gt; 的示例！我们可以编写一个函数，该函数可以提取一个未知的美国硬币，并以类似于计数机的方式确定它是哪个硬币，并以美分返回其价值，如清单6-3所示。</target>
        </trans-unit>
        <trans-unit id="564bbf6a7d7bf6b1e61c40462e20a2bae78026d7" translate="yes" xml:space="preserve">
          <source>Because we made the &lt;code&gt;Appetizer&lt;/code&gt; enum public, we can use the &lt;code&gt;Soup&lt;/code&gt; and &lt;code&gt;Salad&lt;/code&gt; variants in &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Enums aren&amp;rsquo;t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with &lt;code&gt;pub&lt;/code&gt; in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with &lt;code&gt;pub&lt;/code&gt;.</source>
          <target state="translated">因为我们公开了 &lt;code&gt;Appetizer&lt;/code&gt; 枚举，所以我们可以在 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中使用 &lt;code&gt;Soup&lt;/code&gt; 和 &lt;code&gt;Salad&lt;/code&gt; 变体。除非枚举变量是公共变量，否则枚举不是很有用。在每种情况下都必须用 &lt;code&gt;pub&lt;/code&gt; 注释所有枚举变量会很烦人，因此枚举变量的默认设置是公开的。结构通常在不公开其字段的情况下很有用，因此结构字段遵循一般默认规则，即除非使用 &lt;code&gt;pub&lt;/code&gt; 注释，否则所有内容均为私有。</target>
        </trans-unit>
        <trans-unit id="e429697f925edbd87724bb6af67eea48f644c38e" translate="yes" xml:space="preserve">
          <source>Because we need to go through the &lt;code&gt;String&lt;/code&gt; element by element and check whether a value is a space, we&amp;rsquo;ll convert our &lt;code&gt;String&lt;/code&gt; to an array of bytes using the &lt;code&gt;as_bytes&lt;/code&gt; method:</source>
          <target state="translated">因为我们需要逐个检查 &lt;code&gt;String&lt;/code&gt; 元素并检查值是否为空格，所以我们将使用 &lt;code&gt;as_bytes&lt;/code&gt; 方法将 &lt;code&gt;String&lt;/code&gt; 转换为字节数组：</target>
        </trans-unit>
        <trans-unit id="78563068540adbc0f963cccfafb7b2fef86f3a05" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve encapsulated the implementation details of the struct &lt;code&gt;AveragedCollection&lt;/code&gt;, we can easily change aspects, such as the data structure, in the future. For instance, we could use a &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; instead of a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; for the &lt;code&gt;list&lt;/code&gt; field. As long as the signatures of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; public methods stay the same, code using &lt;code&gt;AveragedCollection&lt;/code&gt; wouldn&amp;rsquo;t need to change. If we made &lt;code&gt;list&lt;/code&gt; public instead, this wouldn&amp;rsquo;t necessarily be the case: &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; have different methods for adding and removing items, so the external code would likely have to change if it were modifying &lt;code&gt;list&lt;/code&gt; directly.</source>
          <target state="translated">因为我们已经封装了 &lt;code&gt;AveragedCollection&lt;/code&gt; 结构的实现细节，所以将来我们可以轻松更改方面，例如数据结构。例如，我们可以使用 &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; 代替 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 作为 &lt;code&gt;list&lt;/code&gt; 字段。只要 &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;remove&lt;/code&gt; 和 &lt;code&gt;average&lt;/code&gt; 公共方法的签名保持不变，使用 &lt;code&gt;AveragedCollection&lt;/code&gt; 的代码就不需要更改。如果我们改为公开 &lt;code&gt;list&lt;/code&gt; ，则不一定是这种情况： &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 具有添加和删除项目的不同方法，因此如果外部代码直接修改 &lt;code&gt;list&lt;/code&gt; 则可能必须更改外部代码。</target>
        </trans-unit>
        <trans-unit id="012f083807416b28f83d8847eef6766da2f64d4c" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve given initial &lt;code&gt;i32&lt;/code&gt; values, Rust can infer that the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt;, and the type annotation isn&amp;rsquo;t necessary. Next, we&amp;rsquo;ll look at how to modify a vector.</source>
          <target state="translated">因为我们已经给出了初始 &lt;code&gt;i32&lt;/code&gt; 值，所以Rust可以推断 &lt;code&gt;v&lt;/code&gt; 的类型是 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; ，并且不需要类型注释。接下来，我们将研究如何修改向量。</target>
        </trans-unit>
        <trans-unit id="9fe6f6ecc3242b6ec15902f2774b2a48334d7481" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve specified that &lt;code&gt;OutlinePrint&lt;/code&gt; requires the &lt;code&gt;Display&lt;/code&gt; trait, we can use the &lt;code&gt;to_string&lt;/code&gt; function that is automatically implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;. If we tried to use &lt;code&gt;to_string&lt;/code&gt; without adding a colon and specifying the &lt;code&gt;Display&lt;/code&gt; trait after the trait name, we&amp;rsquo;d get an error saying that no method named &lt;code&gt;to_string&lt;/code&gt; was found for the type &lt;code&gt;&amp;amp;Self&lt;/code&gt; in the current scope.</source>
          <target state="translated">因为我们指定了 &lt;code&gt;OutlinePrint&lt;/code&gt; 需要 &lt;code&gt;Display&lt;/code&gt; 特征，所以我们可以使用 &lt;code&gt;to_string&lt;/code&gt; 函数，该函数针对实现 &lt;code&gt;Display&lt;/code&gt; 的任何类型自动实现。如果我们尝试使用 &lt;code&gt;to_string&lt;/code&gt; 而不添加冒号并在特征名称后指定 &lt;code&gt;Display&lt;/code&gt; 特征，则将收到一条错误消息，指出在当前范围内未为类型 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 找到名为 &lt;code&gt;to_string&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="627748e661f805aeaed04a41d6aadf854f4f0452" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">因为我们没有缓冲，所以我们依次写入每个字节，从而导致每个写入的字节产生系统调用的开销。我们可以用 &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 来解决这个问题：</target>
        </trans-unit>
        <trans-unit id="a715fdf861e47ef758515cd362976557a262f981" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&lt;/code&gt;:</source>
          <target state="translated">因为没有缓冲，所以我们依次写入每个字节，从而导致每个字节写入系统调用的开销。我们可以使用 &lt;code&gt;BufWriter&lt;/code&gt; 来解决此问题：</target>
        </trans-unit>
        <trans-unit id="cbd558490c4d9352a7af3024ff9549f8d11edc55" translate="yes" xml:space="preserve">
          <source>Because you can stack-allocate a &lt;code&gt;[u8; N]&lt;/code&gt;, and you can take a &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt; of it, this function is one way to have a stack-allocated string. There is an example of this in the examples section below.</source>
          <target state="translated">因为您可以堆栈分配 &lt;code&gt;[u8; N]&lt;/code&gt; ，并且可以使用&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt;，此函数是具有堆栈分配字符串的一种方法。下面的示例部分提供了一个示例。</target>
        </trans-unit>
        <trans-unit id="abb004f87792d4a102d3232d143d81ed4ffc2ed8" translate="yes" xml:space="preserve">
          <source>Before an expression used as a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">在表达式之前用作&lt;a href=&quot;statements&quot;&gt;语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fb622789c9cc297dc766f85b7b47e7c5b64a4c2" translate="yes" xml:space="preserve">
          <source>Before diving into generics syntax, let&amp;rsquo;s first look at how to remove duplication that doesn&amp;rsquo;t involve generic types by extracting a function. Then we&amp;rsquo;ll apply this technique to extract a generic function! In the same way that you recognize duplicated code to extract into a function, you&amp;rsquo;ll start to recognize duplicated code that can use generics.</source>
          <target state="translated">在深入探讨泛型语法之前，让我们首先看看如何通过提取函数来删除不涉及泛型类型的重复项。然后，我们将应用此技术来提取泛型函数！以与识别要提取到函数中的重复代码相同的方式，您将开始识别可以使用泛型的重复代码。</target>
        </trans-unit>
        <trans-unit id="beaf5bffc2c85ad951a60c9ddac3eebe2cec9b8f" translate="yes" xml:space="preserve">
          <source>Before explaining more, let's talk about how this module is structured:</source>
          <target state="translated">在解释更多之前,我们先说说这个模块的结构。</target>
        </trans-unit>
        <trans-unit id="cd09ad07440aee110c115ad35adea181d0515ee9" translate="yes" xml:space="preserve">
          <source>Before running a Rust program, you must compile it using the Rust compiler by entering the &lt;code&gt;rustc&lt;/code&gt; command and passing it the name of your source file, like this:</source>
          <target state="translated">在运行Rust程序之前，您必须使用Rust编译器通过输入 &lt;code&gt;rustc&lt;/code&gt; 命令并向其传递源文件的名称来对其进行编译，如下所示：</target>
        </trans-unit>
        <trans-unit id="992020b016b482ffafd2657fccaa8d509f2063e9" translate="yes" xml:space="preserve">
          <source>Before the loop, we declare a variable named &lt;code&gt;counter&lt;/code&gt; and initialize it to &lt;code&gt;0&lt;/code&gt;. Then we declare a variable named &lt;code&gt;result&lt;/code&gt; to hold the value returned from the loop. On every iteration of the loop, we add &lt;code&gt;1&lt;/code&gt; to the &lt;code&gt;counter&lt;/code&gt; variable, and then check whether the counter is equal to &lt;code&gt;10&lt;/code&gt;. When it is, we use the &lt;code&gt;break&lt;/code&gt; keyword with the value &lt;code&gt;counter * 2&lt;/code&gt;. After the loop, we use a semicolon to end the statement that assigns the value to &lt;code&gt;result&lt;/code&gt;. Finally, we print the value in &lt;code&gt;result&lt;/code&gt;, which in this case is 20.</source>
          <target state="translated">在循环之前，我们声明一个名为 &lt;code&gt;counter&lt;/code&gt; 的变量并将其初始化为 &lt;code&gt;0&lt;/code&gt; 。然后，我们声明一个名为 &lt;code&gt;result&lt;/code&gt; 的变量，以保存从循环返回的值。在循环的每次迭代中，我们将 &lt;code&gt;1&lt;/code&gt; 加到 &lt;code&gt;counter&lt;/code&gt; 变量上，然后检查counter是否等于 &lt;code&gt;10&lt;/code&gt; 。如果是，我们将 &lt;code&gt;break&lt;/code&gt; 关键字与值 &lt;code&gt;counter * 2&lt;/code&gt; 。循环后，我们使用分号结束将值分配给 &lt;code&gt;result&lt;/code&gt; 的语句。最后，我们在 &lt;code&gt;result&lt;/code&gt; 中输出值，在本例中为20。</target>
        </trans-unit>
        <trans-unit id="31a496e8ed09fdd1bd621c7cc15fdcecbd8eebc7" translate="yes" xml:space="preserve">
          <source>Before we begin implementing a thread pool, let&amp;rsquo;s talk about what using the pool should look like. When you&amp;rsquo;re trying to design code, writing the client interface first can help guide your design. Write the API of the code so it&amp;rsquo;s structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.</source>
          <target state="translated">在开始实现线程池之前，让我们先讨论一下使用该线程池的外观。当您尝试设计代码时，首先编写客户端接口可以帮助指导您的设计。编写代码的API，以便按照您希望的方式进行结构化；然后在该结构中实现功能，而不是实现功能，然后设计公共API。</target>
        </trans-unit>
        <trans-unit id="5531bdacd5e27e11cff8fcc2e36e3c004527f8b8" translate="yes" xml:space="preserve">
          <source>Before we discuss this use case for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, we&amp;rsquo;ll cover the syntax and how to interact with values stored within a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在讨论 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 这个用例之前，我们将介绍语法以及如何与 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 存储的值进行交互。</target>
        </trans-unit>
        <trans-unit id="d85d751d3cdedcf3deebd350f36e7cb28a00a5d2" translate="yes" xml:space="preserve">
          <source>Before we go into more details to explain the guarantees and choices associated with &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt;, we discuss some examples for how it might be used. Feel free to &lt;a href=&quot;#drop-guarantee&quot;&gt;skip to where the theoretical discussion continues&lt;/a&gt;.</source>
          <target state="translated">在我们进一步解释与 &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 相关的保证和选择之前，我们将讨论一些有关如何使用它的示例。随意&lt;a href=&quot;#drop-guarantee&quot;&gt;跳到理论讨论继续进行的地方&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e5cb50dd4a282df49da6b5ffaeda1d9ab676ba8" translate="yes" xml:space="preserve">
          <source>Before you can publish any crates, you need to create an account on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and get an API token. To do so, visit the home page at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and log in via a GitHub account. (The GitHub account is currently a requirement, but the site might support other ways of creating an account in the future.) Once you&amp;rsquo;re logged in, visit your account settings at &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; and retrieve your API key. Then run the &lt;code&gt;cargo login&lt;/code&gt; command with your API key, like this:</source>
          <target state="translated">在发布任何包装箱之前，您需要在&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;上创建一个帐户并获取API令牌。为此，请访问&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io主页&lt;/a&gt;并通过GitHub帐户登录。（当前需要GitHub帐户，但该站点将来可能会支持其他创建帐户的方法。）登录后，请访问&lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/上&lt;/a&gt;的帐户设置并检索您的帐户。API密钥。然后使用您的API密钥运行 &lt;code&gt;cargo login&lt;/code&gt; 命令，如下所示：</target>
        </trans-unit>
        <trans-unit id="842beb51ca9c5417a27f472386d0e0d52dcc074f" translate="yes" xml:space="preserve">
          <source>Before:</source>
          <target state="translated">Before:</target>
        </trans-unit>
        <trans-unit id="bb11daf93347e89962e3d0ed85d6b809ec3ab729" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt; can reference crates in the extern prelude, so it is considered unidiomatic to use &lt;code&gt;extern crate&lt;/code&gt;.</source>
          <target state="translated">从2018年版本开始，&lt;a href=&quot;use-declarations&quot;&gt;use声明&lt;/a&gt;可以在extern序言中引用板条箱，因此使用 &lt;code&gt;extern crate&lt;/code&gt; 被认为是不习惯的。</target>
        </trans-unit>
        <trans-unit id="f69c63a9aa10f7772ed95a8efc915f42e685135b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; has been promoted to a strict keyword.</source>
          <target state="translated">从2018年版开始， &lt;code&gt;dyn&lt;/code&gt; 已被提升为严格关键字。</target>
        </trans-unit>
        <trans-unit id="747fb066bbb4af54f78aaa8f212256984b77092b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; is a true keyword and is not allowed in paths, so the parentheses are not necessary.</source>
          <target state="translated">从2018年版开始， &lt;code&gt;dyn&lt;/code&gt; 是一个真关键字，并且在路径中不允许使用，因此不需要括号。</target>
        </trans-unit>
        <trans-unit id="88113dc243c443e4dd51d39dc5f37a435a2966eb" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, function or method parameter patterns are no longer optional. Also, all irrefutable patterns are allowed as long as there is a body. Without a body, the limitations listed above are still in effect.</source>
          <target state="translated">从2018年版开始,函数或方法参数模式不再是可选的。另外,只要有主体,所有不可反驳的模式都是允许的。如果没有主体,上述限制仍然有效。</target>
        </trans-unit>
        <trans-unit id="72201b43a6b1623bf8606d5ddd5bead0602a3d00" translate="yes" xml:space="preserve">
          <source>Beginning with the 2018 Edition, paths starting with &lt;code&gt;::&lt;/code&gt; can only reference crates.</source>
          <target state="translated">从2018版开始，以 &lt;code&gt;::&lt;/code&gt; 开头的路径只能引用包装箱。</target>
        </trans-unit>
        <trans-unit id="020cfc8d7ce4473da0deda931f3cf2410d4b4068" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned.</source>
          <target state="translated">像 &lt;code&gt;alloc&lt;/code&gt; 一样，但是还确保在返回之前将内容设置为零。</target>
        </trans-unit>
        <trans-unit id="26b6dab3100989fb3cbafd53582c862ac5c9f9f9" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">像 &lt;code&gt;alloc&lt;/code&gt; 一样，但是还确保在返回之前将内容设置为零。&lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cebb7ac8ceac00cf4605e1537d21a42ae0a8334d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">像 &lt;code&gt;alloc&lt;/code&gt; 一样，但是还确保在返回之前将内容设置为零。&lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e653935f1fa40764a2f934dcfa1f795f0a0636d1" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized.</source>
          <target state="translated">像 &lt;code&gt;alloc&lt;/code&gt; 一样，但是也确保返回的内存是零初始化的。</target>
        </trans-unit>
        <trans-unit id="082a664b538f66f0a51ac4134a98aba6f77d5cde" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;alloc/trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">像 &lt;code&gt;alloc&lt;/code&gt; 一样，但是也确保返回的内存是零初始化的。&lt;a href=&quot;alloc/trait.allocref#method.alloc_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be234e6a7de7bb5e73ad2c0df1090886fa61a11b" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">像 &lt;code&gt;alloc&lt;/code&gt; 一样，但是也确保返回的内存是零初始化的。&lt;a href=&quot;trait.allocref#method.alloc_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16853ad48a342bbd03514f294c9cb5b40dbdc15d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">行为类似于 &lt;code&gt;alloc&lt;/code&gt; ，但也返回返回的块的整个大小。对于某些 &lt;code&gt;layout&lt;/code&gt; 输入（例如数组），这可能包括可用于其他数据的额外存储。</target>
        </trans-unit>
        <trans-unit id="40c1d1b115b0d7d4586e89d6b5493bd9bd25a35d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">行为类似于 &lt;code&gt;alloc&lt;/code&gt; ，但也返回返回的块的整个大小。对于某些 &lt;code&gt;layout&lt;/code&gt; 输入（例如数组），这可能包括可用于其他数据的额外存储。&lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e2179173aab44374db1b01f282be73f03846d7f" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized.</source>
          <target state="translated">行为类似于 &lt;code&gt;allocate&lt;/code&gt; ，但也确保返回的内存为零初始化。</target>
        </trans-unit>
        <trans-unit id="96a2513654f4015a77e125e9a50451e03d6371d9" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;alloc/trait.allocator#method.allocate_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">行为类似于 &lt;code&gt;allocate&lt;/code&gt; ，但也确保返回的内存为零初始化。&lt;a href=&quot;alloc/trait.allocator#method.allocate_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb8d63977cd22736576846575120dedadc2c07c4" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;trait.allocator#method.allocate_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">行为类似于 &lt;code&gt;allocate&lt;/code&gt; ，但也确保返回的内存为零初始化。&lt;a href=&quot;trait.allocator#method.allocate_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43a391a0a4b347a23ddcc04fdba39ef2f889911c" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned.</source>
          <target state="translated">行为类似于 &lt;code&gt;grow&lt;/code&gt; ，但还确保在将新内容返回之前将其设置为零。</target>
        </trans-unit>
        <trans-unit id="27028f3e8d3b71893211313af49a0378a2b4d868" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;alloc/trait.allocator#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">行为类似于 &lt;code&gt;grow&lt;/code&gt; ，但还确保在将新内容返回之前将其设置为零。&lt;a href=&quot;alloc/trait.allocator#method.grow_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcc5bb4de65f26b5cfc9c0d306890b6a3dfd8426" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;alloc/trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">行为类似于 &lt;code&gt;grow&lt;/code&gt; ，但还确保在将新内容返回之前将其设置为零。&lt;a href=&quot;alloc/trait.allocref#method.grow_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="744e0952faceb3c028105041422c82f4480ac4f5" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;trait.allocator#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">行为类似于 &lt;code&gt;grow&lt;/code&gt; ，但还确保在将新内容返回之前将其设置为零。&lt;a href=&quot;trait.allocator#method.grow_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b00b17315ce422677165dd747a2622a3bae967c2" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">行为类似于 &lt;code&gt;grow&lt;/code&gt; ，但还确保在将新内容返回之前将其设置为零。&lt;a href=&quot;trait.allocref#method.grow_zeroed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6dee35b4dc6dfa21486bfd27863270c134037f5" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">行为类似于 &lt;code&gt;realloc&lt;/code&gt; ，但也返回返回的块的整个大小。对于某些 &lt;code&gt;layout&lt;/code&gt; 输入（例如数组），这可能包括可用于其他数据的额外存储。</target>
        </trans-unit>
        <trans-unit id="c12028831748d6fe621f72695ab145b2de0f2ea6" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">行为类似于 &lt;code&gt;realloc&lt;/code&gt; ，但也返回返回的块的整个大小。对于某些 &lt;code&gt;layout&lt;/code&gt; 输入（例如数组），这可能包括可用于其他数据的额外存储。&lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="095fb761bd6565ed9b50c488d53be7f174ad6258" translate="yes" xml:space="preserve">
          <source>Behavior considered undefined</source>
          <target state="translated">被视为未定义的行为</target>
        </trans-unit>
        <trans-unit id="387f0e642c525f9f6e8bb2a3ac2dfb1f45db317b" translate="yes" xml:space="preserve">
          <source>Behavior during const evaluation</source>
          <target state="translated">建筑物评价期间的行为</target>
        </trans-unit>
        <trans-unit id="b1544a3801fc2d10e0c4fa2700cbde205e380188" translate="yes" xml:space="preserve">
          <source>Behavior is undefined if any of the following conditions are violated:</source>
          <target state="translated">如果违反以下任何一个条件,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="9d1d94b77ecaf322c48c942eb7769975f61f7e1b" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code id=&quot;behavior-not-considered-unsafe&quot;&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">行为不被认为是 &lt;code id=&quot;behavior-not-considered-unsafe&quot;&gt;unsafe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c89d307ed32970842af58f6e49fccbe4976a8de" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">不被视为 &lt;code&gt;unsafe&lt;/code&gt; 行为</target>
        </trans-unit>
        <trans-unit id="56466d174610967ccd7c4e4d2f8e7fb575e6e68b" translate="yes" xml:space="preserve">
          <source>Being unable to change the value of a variable might have reminded you of another programming concept that most other languages have: &lt;em&gt;constants&lt;/em&gt;. Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.</source>
          <target state="translated">无法更改变量的值可能使您想起了大多数其他语言都具有的另一个编程概念：&lt;em&gt;常量&lt;/em&gt;。与不可变变量一样，常量是绑定到名称且不允许更改的值，但是常量和变量之间存在一些差异。</target>
        </trans-unit>
        <trans-unit id="2b1f5f4233d209308eb232700a1ebe15446b03df" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. Chapter 19 covers more complex scenarios involving lifetime annotations as well as some advanced type system features. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="translated">信不信由你，您将在本章讨论的主题上学习更多的知识：第17章讨论了特征对象，这是使用特征的另一种方法。第19章介绍了涉及生存期注释以及一些高级类型系统功能的更复杂的方案。但是接下来，您将学习如何在Rust中编写测试，以便确保您的代码能够正常工作。</target>
        </trans-unit>
        <trans-unit id="58b3731b9aba86dccac77d4faa0d50972846f846" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the &lt;a href=&quot;../reference/index&quot;&gt;Rust Reference&lt;/a&gt;. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="translated">信不信由你，在本章中讨论的主题上，还有更多要学习的知识：第17章讨论了特征对象，这是使用特征的另一种方法。还有一些涉及生命周期注释的更复杂的方案，只有在非常高级的方案中才需要使用。对于这些，您应该阅读&lt;a href=&quot;../reference/index&quot;&gt;Rust参考&lt;/a&gt;。但是接下来，您将学习如何在Rust中编写测试，以便确保您的代码能够正常工作。</target>
        </trans-unit>
        <trans-unit id="d677fae0ad7b93321bdf5902d4670326f019ecfb" translate="yes" xml:space="preserve">
          <source>Below are formal inductive definitions for FIRST and LAST.</source>
          <target state="translated">以下是FIRST和LAST的正式归纳定义。</target>
        </trans-unit>
        <trans-unit id="9aa1c322ef5127bad20114a3c08180f48d6a1ff0" translate="yes" xml:space="preserve">
          <source>Below are some examples of FIRST and LAST. (Note in particular how the special &amp;epsilon; element is introduced and eliminated based on the interaction between the pieces of the input.)</source>
          <target state="translated">以下是FIRST和LAST的一些示例。（请特别注意如何根据输入部分之间的相互作用引入和消除特殊的&amp;epsilon;元素。）</target>
        </trans-unit>
        <trans-unit id="7b50be87542e5985746393609c4b0d26c14c49a1" translate="yes" xml:space="preserve">
          <source>Below is an example that shows under what conditions the compiler keeps a &lt;code&gt;static&lt;/code&gt; item in the output object file.</source>
          <target state="translated">下面的示例显示了编译器在什么条件下将 &lt;code&gt;static&lt;/code&gt; 项目保留在输出对象文件中。</target>
        </trans-unit>
        <trans-unit id="1aa487609f84f4a503144112602dbfe1aef5f203" translate="yes" xml:space="preserve">
          <source>Below is shown a &lt;code&gt;panic_handler&lt;/code&gt; function that logs the panic message and then halts the thread.</source>
          <target state="translated">下面显示了 &lt;code&gt;panic_handler&lt;/code&gt; 函数，该函数记录紧急消息，然后暂停线程。</target>
        </trans-unit>
        <trans-unit id="2a2f598979a5de21d86b57d75eda1c3bfc34d2c7" translate="yes" xml:space="preserve">
          <source>Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.</source>
          <target state="translated">除了基本的数据类型外,标准库主要关注的是对常见平台的差异进行抽象,最主要的是Windows和Unix衍生品。</target>
        </trans-unit>
        <trans-unit id="f03b60f7e52b7ce49ed1e4f9fa511c452a2185bb" translate="yes" xml:space="preserve">
          <source>Beta</source>
          <target state="translated">Beta</target>
        </trans-unit>
        <trans-unit id="234f044b4bf52384fd2873935962aa4a005b114a" translate="yes" xml:space="preserve">
          <source>Beyond that, there are two important traits that are provided: &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt;. Both of these build on top of a reader to control how the reading happens. &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; lets you control where the next byte is coming from:</source>
          <target state="translated">除此之外，还提供了两个重要的特征：&lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt;。两者都建立在阅读器之上，以控制阅读的发生方式。&lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;可让您控制下一个字节的来源：</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="528a653c1337877f018509c599539f6092a1c73c" translate="yes" xml:space="preserve">
          <source>Binary integer</source>
          <target state="translated">二进制整数</target>
        </trans-unit>
        <trans-unit id="c45c03039baf74ccb71d2cd15ae8c1ec54d6c3fc" translate="yes" xml:space="preserve">
          <source>Binary operator expressions (&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt;).</source>
          <target state="translated">二元运算表达式（&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="19f576ed80d6aac8fef3b9d639229b5cf1b86087" translate="yes" xml:space="preserve">
          <source>Binary operators expressions are all written with infix notation. This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="translated">二进制运算符表达式都以中缀符号编写。下表总结了算术和逻辑二进制运算符在原始类型上的行为，以及哪些特征用于使其他类型的这些运算符超载。请记住，带符号整数始终使用二进制补码表示。所有这些运算符的操作数都是在&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;值表达式上下文&lt;/a&gt;中评估的，因此可以移动或复制。</target>
        </trans-unit>
        <trans-unit id="b6f95426a2cf8937585653a08dca6cfe16953252" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; for a given element.</source>
          <target state="translated">二进制在此排序的 &lt;code&gt;VecDeque&lt;/code&gt; 中搜索给定的元素。</target>
        </trans-unit>
        <trans-unit id="8777ed96f02081635aa44ae43b6a05d44029601f" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; with a comparator function.</source>
          <target state="translated">二进制使用比较器功能搜索此排序的 &lt;code&gt;VecDeque&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f6d0c15889ade3f758276e9309a88e8f0daaa91" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; with a key extraction function.</source>
          <target state="translated">Binary使用密钥提取功能搜索此排序的 &lt;code&gt;VecDeque&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb24e7a177053effeaa97b02e6e1d53bea903394" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice for a given element.</source>
          <target state="translated">二进制对给定元素的这个排序片进行搜索。</target>
        </trans-unit>
        <trans-unit id="342759ca0bc54fef96ecf37bc0ddadb9e9d73749" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a comparator function.</source>
          <target state="translated">二进制用比较器函数搜索这个排序的片子。</target>
        </trans-unit>
        <trans-unit id="7bc8abd5fd12b3c23822c666fc1626829d2282bf" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a key extraction function.</source>
          <target state="translated">二进制用键提取功能搜索这个排序的片子。</target>
        </trans-unit>
        <trans-unit id="0f756fdf55ff6fbf54d5489a870831d4c60ffda7" translate="yes" xml:space="preserve">
          <source>Binary::fmt</source>
          <target state="translated">Binary::fmt</target>
        </trans-unit>
        <trans-unit id="f4b68b2fab22d221207f75497f220c953edad9fd" translate="yes" xml:space="preserve">
          <source>BinaryHeap</source>
          <target state="translated">BinaryHeap</target>
        </trans-unit>
        <trans-unit id="dacf4e220750a1b0f951db1cac365b1b687b357f" translate="yes" xml:space="preserve">
          <source>BinaryHeap::append</source>
          <target state="translated">BinaryHeap::append</target>
        </trans-unit>
        <trans-unit id="237581b8c07d3a6f7c2056bca73d832b0ff9b185" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow</source>
          <target state="translated">BinaryHeap::borrow</target>
        </trans-unit>
        <trans-unit id="6cc1c3995d6cbe9775c025f1c009843f3a795e95" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow_mut</source>
          <target state="translated">BinaryHeap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ea651796c70f924cd09768869629d83a528f3966" translate="yes" xml:space="preserve">
          <source>BinaryHeap::capacity</source>
          <target state="translated">BinaryHeap::capacity</target>
        </trans-unit>
        <trans-unit id="4db927bbac3d9fd9afcc396f05abd8a6d2369849" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clear</source>
          <target state="translated">BinaryHeap::clear</target>
        </trans-unit>
        <trans-unit id="44380118a5aafd372e4d29c4729fc27883446a63" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone</source>
          <target state="translated">BinaryHeap::clone</target>
        </trans-unit>
        <trans-unit id="c4238fb46fd7eaa2a0823eded93fee09138cb72e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_from</source>
          <target state="translated">BinaryHeap::clone_from</target>
        </trans-unit>
        <trans-unit id="b77853e2e7d4b57b08f38a8fa17f28d29076c075" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_into</source>
          <target state="translated">BinaryHeap::clone_into</target>
        </trans-unit>
        <trans-unit id="d4e562b332ce963cb95b5b307cb7485615e014fc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::default</source>
          <target state="translated">BinaryHeap::default</target>
        </trans-unit>
        <trans-unit id="fdc5438d4f6cad011f4663afcc9664e54dc0d85e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::drain</source>
          <target state="translated">BinaryHeap::drain</target>
        </trans-unit>
        <trans-unit id="0aaca4d42181f37288aa7e21316d709a6ff71f49" translate="yes" xml:space="preserve">
          <source>BinaryHeap::extend</source>
          <target state="translated">BinaryHeap::extend</target>
        </trans-unit>
        <trans-unit id="f4c67172d6c1cdb39c6636230b079c173cf83f2c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::fmt</source>
          <target state="translated">BinaryHeap::fmt</target>
        </trans-unit>
        <trans-unit id="871dac7b5ceedfbec71447a6d6ed9de357acd044" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from</source>
          <target state="translated">BinaryHeap::from</target>
        </trans-unit>
        <trans-unit id="f175a9eb33f99d6629fe67f65984c4a890519755" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from_iter</source>
          <target state="translated">BinaryHeap::from_iter</target>
        </trans-unit>
        <trans-unit id="abdea679542fd107e906ae5d58ce503cb54c014d" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into</source>
          <target state="translated">BinaryHeap::into</target>
        </trans-unit>
        <trans-unit id="45541a8cf8b33e80b63d4c7b7d8a3acfe03252c0" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_iter</source>
          <target state="translated">BinaryHeap::into_iter</target>
        </trans-unit>
        <trans-unit id="a4f3a26fa362623ceae23603112262e72024f7b9" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_sorted_vec</source>
          <target state="translated">BinaryHeap::into_sorted_vec</target>
        </trans-unit>
        <trans-unit id="1db086875600549522e8a9e52684ebd526b5b129" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_vec</source>
          <target state="translated">BinaryHeap::into_vec</target>
        </trans-unit>
        <trans-unit id="a112ebac833a70561b615451c2e74f51b6f19a74" translate="yes" xml:space="preserve">
          <source>BinaryHeap::is_empty</source>
          <target state="translated">BinaryHeap::is_empty</target>
        </trans-unit>
        <trans-unit id="0ee572360922722532c0921740eb1f614a7ab7ce" translate="yes" xml:space="preserve">
          <source>BinaryHeap::iter</source>
          <target state="translated">BinaryHeap::iter</target>
        </trans-unit>
        <trans-unit id="119b277a11fb08dfc4b80fb6b74bafd3221914e4" translate="yes" xml:space="preserve">
          <source>BinaryHeap::len</source>
          <target state="translated">BinaryHeap::len</target>
        </trans-unit>
        <trans-unit id="227d527ad8e44dcb2418c2e7e8e075d2359fb772" translate="yes" xml:space="preserve">
          <source>BinaryHeap::new</source>
          <target state="translated">BinaryHeap::new</target>
        </trans-unit>
        <trans-unit id="1fed1ee8afbb235ea1f87d7947786969b3a00687" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek</source>
          <target state="translated">BinaryHeap::peek</target>
        </trans-unit>
        <trans-unit id="23133fcfda988b66f1b73cca51b41c4297acc6b5" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek_mut</source>
          <target state="translated">BinaryHeap::peek_mut</target>
        </trans-unit>
        <trans-unit id="d6e00b82d35a37cd32b1907ca0812180a4fe6813" translate="yes" xml:space="preserve">
          <source>BinaryHeap::pop</source>
          <target state="translated">BinaryHeap::pop</target>
        </trans-unit>
        <trans-unit id="9d087a89ba80a46d773a7b420f9c4e221911780c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::push</source>
          <target state="translated">BinaryHeap::push</target>
        </trans-unit>
        <trans-unit id="f989d57cf0e0868e0ab3e99ccd663f3feb35ed09" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve</source>
          <target state="translated">BinaryHeap::reserve</target>
        </trans-unit>
        <trans-unit id="2c3a34b08e6d7927826662441c85562fbe689c5c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve_exact</source>
          <target state="translated">BinaryHeap::reserve_exact</target>
        </trans-unit>
        <trans-unit id="7748954939d681e885fda180afed19fde978c11a" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to</source>
          <target state="translated">BinaryHeap::shrink_to</target>
        </trans-unit>
        <trans-unit id="a6cb12e1cadaa03dc4bd1cee0a924e07fbf651bc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to_fit</source>
          <target state="translated">BinaryHeap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="3173fa304efc6acd170d96dcfc16d265f0d5bb04" translate="yes" xml:space="preserve">
          <source>BinaryHeap::to_owned</source>
          <target state="translated">BinaryHeap::to_owned</target>
        </trans-unit>
        <trans-unit id="545a06b62d55dcf95e6aed766f34093361650315" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_from</source>
          <target state="translated">BinaryHeap::try_from</target>
        </trans-unit>
        <trans-unit id="9ff50e94eaf55b6f7a7c5638416c4db484934500" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_into</source>
          <target state="translated">BinaryHeap::try_into</target>
        </trans-unit>
        <trans-unit id="337697412c6fd50a3b2ba815044c47d165af3cd6" translate="yes" xml:space="preserve">
          <source>BinaryHeap::type_id</source>
          <target state="translated">BinaryHeap::type_id</target>
        </trans-unit>
        <trans-unit id="8acc5ae886b9efd0dc8fb7d4fc82df425c356c37" translate="yes" xml:space="preserve">
          <source>BinaryHeap::with_capacity</source>
          <target state="translated">BinaryHeap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c33a043d5763d9b3ea7f89a9ac614fa68ca83bc4" translate="yes" xml:space="preserve">
          <source>Bind a TCP listener to an address, listen for connections, and read bytes in nonblocking mode:</source>
          <target state="translated">将TCP监听器绑定到一个地址,监听连接,并在非阻塞模式下读取字节。</target>
        </trans-unit>
        <trans-unit id="359dde3378dea26f13c20bf3ab1abd7d31ba2c01" translate="yes" xml:space="preserve">
          <source>Bind a value to a variable.</source>
          <target state="translated">将一个值绑定到一个变量上。</target>
        </trans-unit>
        <trans-unit id="d22542d4de6d5029b1ac0ccd7c008fc51102ba8b" translate="yes" xml:space="preserve">
          <source>Bind by reference during pattern matching.</source>
          <target state="translated">在模式匹配过程中通过引用进行绑定。</target>
        </trans-unit>
        <trans-unit id="069dbd36e80b491e8ea0d0898b003375a28c5f42" translate="yes" xml:space="preserve">
          <source>Binding all paths matching a given prefix, using the asterisk wildcard syntax &lt;code&gt;use a::b::*;&lt;/code&gt;.</source>
          <target state="translated">使用星号通配符语法 &lt;code&gt;use a::b::*;&lt;/code&gt; 所有与给定前缀匹配的路径绑定在一起，使用a :: b :: *; 。</target>
        </trans-unit>
        <trans-unit id="edac8dc0f66a2e81b54912d09ade5eca329f5dcd" translate="yes" xml:space="preserve">
          <source>Binding modes</source>
          <target state="translated">绑定模式</target>
        </trans-unit>
        <trans-unit id="30c9ed787b1702852e9d605cfb98fe4532008152" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;#method.local_addr&quot;&gt;&lt;code&gt;local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">端口号为0的绑定将要求OS为该侦听器分配端口。可以通过&lt;a href=&quot;#method.local_addr&quot;&gt; &lt;code&gt;local_addr&lt;/code&gt; &lt;/a&gt;方法查询分配的端口。</target>
        </trans-unit>
        <trans-unit id="ace7ad2d8af42b873b8f9c931c9515626c9ccb54" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;struct.tcplistener#method.local_addr&quot;&gt;&lt;code&gt;TcpListener::local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">端口号为0的绑定将要求OS为该侦听器分配端口。可以通过&lt;a href=&quot;struct.tcplistener#method.local_addr&quot;&gt; &lt;code&gt;TcpListener::local_addr&lt;/code&gt; &lt;/a&gt;方法查询分配的端口。</target>
        </trans-unit>
        <trans-unit id="2c4806bd148356225d8f9e9c34e40c18cd70837a" translate="yes" xml:space="preserve">
          <source>Binds a reference to the &lt;code&gt;name&lt;/code&gt; field to the variable &lt;code&gt;person_name&lt;/code&gt;.</source>
          <target state="translated">将对 &lt;code&gt;name&lt;/code&gt; 字段的引用绑定到变量 &lt;code&gt;person_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="597ad73fbf9aa40cebae5f999cfe7db4afecce4e" translate="yes" xml:space="preserve">
          <source>BitAnd::bitand</source>
          <target state="translated">BitAnd::bitand</target>
        </trans-unit>
        <trans-unit id="943b337ab11ab98e677d691725140875e5b353e9" translate="yes" xml:space="preserve">
          <source>BitAndAssign</source>
          <target state="translated">BitAndAssign</target>
        </trans-unit>
        <trans-unit id="f5e3873189453b3d2f6432bcad61a66bb4d9501b" translate="yes" xml:space="preserve">
          <source>BitAndAssign::bitand_assign</source>
          <target state="translated">BitAndAssign::bitand_assign</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="44191b5eea700acecf61cce1d97b9be216180188" translate="yes" xml:space="preserve">
          <source>BitOr::bitor</source>
          <target state="translated">BitOr::bitor</target>
        </trans-unit>
        <trans-unit id="960e956c7d9aabe97b11d326569299236d4948a9" translate="yes" xml:space="preserve">
          <source>BitOrAssign</source>
          <target state="translated">BitOrAssign</target>
        </trans-unit>
        <trans-unit id="3034c1fbe2a99f07e023c8c2cb9d42ee22ccc4c1" translate="yes" xml:space="preserve">
          <source>BitOrAssign::bitor_assign</source>
          <target state="translated">BitOrAssign::bitor_assign</target>
        </trans-unit>
        <trans-unit id="427e64f1c1cbca75038d127034792de35e048e3d" translate="yes" xml:space="preserve">
          <source>BitXor</source>
          <target state="translated">BitXor</target>
        </trans-unit>
        <trans-unit id="2e397bf0da401d643f9083e54c584225e131c7ca" translate="yes" xml:space="preserve">
          <source>BitXor::bitxor</source>
          <target state="translated">BitXor::bitxor</target>
        </trans-unit>
        <trans-unit id="6a826e6c5b73b200c07a57a2aec1b711ff40e1d4" translate="yes" xml:space="preserve">
          <source>BitXorAssign</source>
          <target state="translated">BitXorAssign</target>
        </trans-unit>
        <trans-unit id="cbbbcfd713c363f58df6976ea8f22e15d59645d6" translate="yes" xml:space="preserve">
          <source>BitXorAssign::bitxor_assign</source>
          <target state="translated">BitXorAssign::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="77e08df74f0783fd374c97b42304776b3399af7d" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot; with the current value.</source>
          <target state="translated">位上的 &quot;和 &quot;与当前值。</target>
        </trans-unit>
        <trans-unit id="2c404667875b6822ca47e4a6888c165e459b533c" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;nand&quot; with the current value.</source>
          <target state="translated">位上的 &quot;nand &quot;与当前值。</target>
        </trans-unit>
        <trans-unit id="1f35aa22f6cd34a5220faabf04cbbb20527ee643" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot; with the current value.</source>
          <target state="translated">位上的 &quot;或 &quot;与当前值。</target>
        </trans-unit>
        <trans-unit id="5c076254fac7febb41ccccf46680d5e14a161fa4" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot; with the current value.</source>
          <target state="translated">位地与当前值 &quot;xor&quot;。</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">位元 AND</target>
        </trans-unit>
        <trans-unit id="4a9a6c94eeeaf50fe1cbac8c1cdc883b234d3b2b" translate="yes" xml:space="preserve">
          <source>Bitwise AND and assignment</source>
          <target state="translated">位性 AND 和赋值</target>
        </trans-unit>
        <trans-unit id="714d6d47971ffbb15128b6a55a03723a5c596cc3" translate="yes" xml:space="preserve">
          <source>Bitwise And assignment</source>
          <target state="translated">比特和赋值</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">位智不</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">位式OR</target>
        </trans-unit>
        <trans-unit id="ea162d3eb732111137dc7e851592f946afbda822" translate="yes" xml:space="preserve">
          <source>Bitwise OR and assignment</source>
          <target state="translated">位向OR和赋值</target>
        </trans-unit>
        <trans-unit id="efa8078cf56f653efb920477181cc2fe85068270" translate="yes" xml:space="preserve">
          <source>Bitwise Or assignment</source>
          <target state="translated">位或赋值</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">位向XOR</target>
        </trans-unit>
        <trans-unit id="e3e1709ce290a67ec5f21e03a6b6317c9f304436" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment</source>
          <target state="translated">位XOR赋值</target>
        </trans-unit>
        <trans-unit id="1f5eabb7a575f79f20f4d75b3fa1ac6c470a8bf6" translate="yes" xml:space="preserve">
          <source>Bitwise and Logical XOR</source>
          <target state="translated">位式和逻辑XOR</target>
        </trans-unit>
        <trans-unit id="f5a1528826bb49fb0b14c31ab4934d10465ebdc5" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value.</source>
          <target state="translated">位和与当前值,返回前值。</target>
        </trans-unit>
        <trans-unit id="ad214175503cf05c10c463c5f6a4d2dbb82dbf24" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位显示当前值，并返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52dda2454098469eb02e841cfd17da11a1a8b11c" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位显示当前值，并返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c63ecd3d802b04a4e0e8dfab8248d912515dec0" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位显示当前值，并返回前一个值。通过将 &lt;code&gt;fetch_and&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过fetch_and方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b6a21a8674eebce391a665fc4970562e774c483" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位显示当前值，并返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63f47ad2a1e6e1fb335c5dc45db81e8017584432" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位显示当前值，并返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="translated">位独占OR</target>
        </trans-unit>
        <trans-unit id="87474ce9659a0e1b133611bb2ae41c7ede6c0a5d" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR and assignment</source>
          <target state="translated">位独占OR和赋值</target>
        </trans-unit>
        <trans-unit id="868d075a0dad8cd3d8fb9f9f26964659d2c6164a" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value.</source>
          <target state="translated">与当前值进行位式nand,返回前值。</target>
        </trans-unit>
        <trans-unit id="544da95df04807eeb86f0e070273fd4dd28cb7cf" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前值按位与，返回前一个值。可通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; 传递给 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 类型的std :: sync :: atomic :: AtomicBool类型使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d773083e9bfa18a72e7f0b0ab1c138c37ef42288" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前值按位与，返回前一个值。通过将 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过fetch_nand方法在 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 类型的std :: sync :: atomicBool类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="203338bb702fd121bec1c0bf9d6a954aecd4347e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前值按位与，返回前一个值。可通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; 传递给 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 类型的std :: sync :: atomic :: AtomicBool类型使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6134a1fe2a25d4dbb615e6688200dbe8e85fe9f6" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前值按位与，返回前一个值。可通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，从而在 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8ddb011394cb17fb806f98da48b371ebbb0870e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前值按位与，返回前一个值。可通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，从而在 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60a4df2d9448161e88049fa61b8cadfe600ad676" translate="yes" xml:space="preserve">
          <source>Bitwise or logical complement</source>
          <target state="translated">位式或逻辑补充</target>
        </trans-unit>
        <trans-unit id="7b4a22d8edc7cc62ea1716050e10c7737c8c1e1f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value.</source>
          <target state="translated">位或与当前值,返回前值。</target>
        </trans-unit>
        <trans-unit id="535640642d3aa1c0482deebda0463eaa8ec0186f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位或具有当前值，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5bd0c7ff8a606308243e5fe0283ace8408191438" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位或具有当前值，返回前一个值。可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; 来在std :: sync :: atomic类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d6bccdc0a09c0e78855aa36b6446bb0697edc37" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位或具有当前值，返回前一个值。可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; 来在std :: sync :: atomic类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7457b18d65f2f07bafb68e32e88a446590597ffd" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位或具有当前值，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a1e96dd5049ad694cd97688db2eb461734bf5e6" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按位或具有当前值，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="181decb693bb642be494fbe5c52383467e0c228c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value.</source>
          <target state="translated">与当前值进行位xor,返回前一个值。</target>
        </trans-unit>
        <trans-unit id="aa1d7bc97bda02349e1fee1efbf8d66b5e91fc88" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与当前值按位异或，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3805cb63a3c1121fa142484c3b378fcb265aa95c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与当前值按位异或，返回前一个值。此内在函数的稳定版本可通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上获得，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; 。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5ce9f030ae16f9b2b741aab2abe9cb20f55a4eb" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与当前值按位异或，返回前一个值。可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上通过将此&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; 来在std :: sync :: atomic类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15836191977a94f34a9eedc80d403307d7b6d4ed" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与当前值按位异或，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffe95ab6a76bb352e681774fae150809af8a6615" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与当前值按位异或，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88de087af89700f4c1004e0042a100c96cfad709" translate="yes" xml:space="preserve">
          <source>Blanket Implementations</source>
          <target state="translated">一揽子实施</target>
        </trans-unit>
        <trans-unit id="7ebf10e8c63d15dc33875a65edf15f33311b088f" translate="yes" xml:space="preserve">
          <source>Blanket implementation</source>
          <target state="translated">一揽子执行</target>
        </trans-unit>
        <trans-unit id="b62ea629ea517115ba87dea634c655ff0a340dd4" translate="yes" xml:space="preserve">
          <source>Blanket implementations appear in the documentation for the trait in the &amp;ldquo;Implementors&amp;rdquo; section.</source>
          <target state="translated">一揽子实施方式显示在&amp;ldquo;实现者&amp;rdquo;部分的特征文档中。</target>
        </trans-unit>
        <trans-unit id="a06bbda0eab9ea08dbe94577274cbb7b473571d4" translate="yes" xml:space="preserve">
          <source>Block comment</source>
          <target state="translated">阻止评论</target>
        </trans-unit>
        <trans-unit id="684096ae991ba36b90c5953d624c41ac5080dfdf" translate="yes" xml:space="preserve">
          <source>Block expression</source>
          <target state="translated">块状表达</target>
        </trans-unit>
        <trans-unit id="8b403969dc1821977a4545f2dd574d603b1654fd" translate="yes" xml:space="preserve">
          <source>Block expressions</source>
          <target state="translated">块状表达</target>
        </trans-unit>
        <trans-unit id="7805c38c778b7b8d59aebeff2b37473f6e635d86" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, and tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="translated">块表达式作为&lt;a href=&quot;array-expr&quot;&gt;数组表达式&lt;/a&gt;，&lt;a href=&quot;tuple-expr&quot;&gt;元组表达式&lt;/a&gt;，&lt;a href=&quot;call-expr&quot;&gt;调用表达式&lt;/a&gt;以及元组样式的&lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt;和&lt;a href=&quot;enum-variant-expr&quot;&gt;enum变量&lt;/a&gt;表达式的元素。</target>
        </trans-unit>
        <trans-unit id="9e069137567cf4c22756c0a181e015e273f3b097" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="translated">块表达式作为&lt;a href=&quot;array-expr&quot;&gt;数组表达式&lt;/a&gt;，&lt;a href=&quot;tuple-expr&quot;&gt;元组表达式&lt;/a&gt;，&lt;a href=&quot;call-expr&quot;&gt;调用表达式&lt;/a&gt;，元组样式的&lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt;和&lt;a href=&quot;enum-variant-expr&quot;&gt;枚举变量&lt;/a&gt;表达式的元素。</target>
        </trans-unit>
        <trans-unit id="502282ec9c201c5e6057f4beae39b5897d6f29ed" translate="yes" xml:space="preserve">
          <source>Block expressions used as a &lt;a href=&quot;../statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">块表达式用作&lt;a href=&quot;../statements&quot;&gt;语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d83a4ba900681b1d6bb448e76ababb6b95a22052" translate="yes" xml:space="preserve">
          <source>Blocks are always &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt; and evaluate the last expression in value expression context. This can be used to force moving a value if really needed. For example, the following example fails on the call to &lt;code&gt;consume_self&lt;/code&gt; because the struct was moved out of &lt;code&gt;s&lt;/code&gt; in the block expression.</source>
          <target state="translated">块始终是&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;值表达式，&lt;/a&gt;并在值表达式上下文中评估最后一个表达式。如果确实需要，可以使用它来强制移动值。例如，下面的例子在调用失败 &lt;code&gt;consume_self&lt;/code&gt; 因为该结构被移动的出 &lt;code&gt;s&lt;/code&gt; 在块的表达。</target>
        </trans-unit>
        <trans-unit id="c18efbe7496c8880dfb8b33f1bb639d10ba9c80d" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="translated">块写成 &lt;code&gt;{&lt;/code&gt; ，然后是任何&lt;a href=&quot;../attributes&quot;&gt;内部属性&lt;/a&gt;，然后是&lt;a href=&quot;../statements&quot;&gt;语句&lt;/a&gt;，然后是可选表达式，最后是 &lt;code&gt;}&lt;/code&gt; 。通常需要在语句后加上分号，但有两个例外。项目声明语句后不必加分号。表达式语句通常需要以下分号，除非其外部表达式是流控制表达式。此外，允许在语句之间使用多余的分号，但这些分号不会影响语义。</target>
        </trans-unit>
        <trans-unit id="ae067769ea09e9988dc3c94bd840ffd9a2112129" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed by a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="translated">块写成 &lt;code&gt;{&lt;/code&gt; ，然后是任何&lt;a href=&quot;../attributes&quot;&gt;内部属性&lt;/a&gt;，然后是&lt;a href=&quot;../statements&quot;&gt;语句&lt;/a&gt;，然后是可选表达式，最后是 &lt;code&gt;}&lt;/code&gt; 。通常需要在语句后加上分号，但有两个例外。项目声明语句后不必加分号。表达式语句通常需要以下分号，除非其外部表达式是流控制表达式。此外，允许在语句之间使用多余的分号，但这些分号不会影响语义。</target>
        </trans-unit>
        <trans-unit id="b3b5253f4cf51bfc8b7e410d8b0b217d0e9c0335" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until all threads have rendezvoused here.</source>
          <target state="translated">封锁当前线程,直到所有线程在此会合。</target>
        </trans-unit>
        <trans-unit id="d45aaa4f52bf36a05dbf87c3a8418aac5e1ca210" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the provided condition is false.</source>
          <target state="translated">封锁当前线程,直到这个条件变量收到通知,并且提供的条件为假。</target>
        </trans-unit>
        <trans-unit id="6fa33f5cb6fe4954947bbb580e0c51b7b87a1d8c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the required condition is met. Spurious wakeups are ignored and this function will only return once the condition has been met.</source>
          <target state="translated">封锁当前线程,直到该条件变量收到通知并满足所需条件。虚假的唤醒会被忽略,而且这个函数只有在条件被满足后才会返回。</target>
        </trans-unit>
        <trans-unit id="80e976210b81b30997de305efb4640d505e6cf39" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification.</source>
          <target state="translated">封锁当前线程,直到该条件变量收到通知。</target>
        </trans-unit>
        <trans-unit id="410a3ef0dd4f7761ff571ad2f23d0ad96832450b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).</source>
          <target state="translated">除非或直到当前线程的令牌可用或达到指定的持续时间,否则会被封锁(可能会虚假唤醒)。</target>
        </trans-unit>
        <trans-unit id="7e4f7a13eb5259dea6da862f685681bb73f6e91b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available.</source>
          <target state="translated">封锁,除非或直到当前线程的令牌可用。</target>
        </trans-unit>
        <trans-unit id="e81a87a7fdc340ba3287800ef9018a00b1adc455" translate="yes" xml:space="preserve">
          <source>Blocks: if a block has type &lt;code&gt;U&lt;/code&gt;, then the last expression in the block (if it is not semicolon-terminated) is a coercion site to &lt;code&gt;U&lt;/code&gt;. This includes blocks which are part of control flow statements, such as &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, if the block has a known type.</source>
          <target state="translated">块：如果块的类型为 &lt;code&gt;U&lt;/code&gt; ，则块中的最后一个表达式（如果不是分号结尾的）是 &lt;code&gt;U&lt;/code&gt; 的强制位置。这包括作为控制流语句一部分的块，例如 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; ，如果块具有已知类型。</target>
        </trans-unit>
        <trans-unit id="104329f4432c8b8b5d3c19fc3d250dfe2ab027d2" translate="yes" xml:space="preserve">
          <source>Bodies of unsafe functions are effectively &lt;code&gt;unsafe&lt;/code&gt; blocks, so to perform other unsafe operations within an unsafe function, we don&amp;rsquo;t need to add another &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">不安全功能的实体实际上是 &lt;code&gt;unsafe&lt;/code&gt; 块，因此要在不安全功能中执行其他不安全的操作，我们不需要添加其他 &lt;code&gt;unsafe&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="translated">布尔型文字</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">布尔型</target>
        </trans-unit>
        <trans-unit id="cb4702d3f3cd69e09a0563d0dcdc4d54d0023693" translate="yes" xml:space="preserve">
          <source>Borrow</source>
          <target state="translated">Borrow</target>
        </trans-unit>
        <trans-unit id="1fd0a944ea8cfb257b2b56f1afcd67ff9e3b25e2" translate="yes" xml:space="preserve">
          <source>Borrow operators</source>
          <target state="translated">借款人</target>
        </trans-unit>
        <trans-unit id="08ef91a49ea57c4babbbcf16cff803659fb46ac3" translate="yes" xml:space="preserve">
          <source>Borrow::borrow</source>
          <target state="translated">Borrow::borrow</target>
        </trans-unit>
        <trans-unit id="2928c5f6ce470ed45869ce9bc666a02f1b276c3c" translate="yes" xml:space="preserve">
          <source>BorrowError</source>
          <target state="translated">BorrowError</target>
        </trans-unit>
        <trans-unit id="cd83210bbc26f6a86f78acc2c5aab6cb300d7a3f" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow</source>
          <target state="translated">BorrowError::borrow</target>
        </trans-unit>
        <trans-unit id="522f3d26a1b9c184b1451ca62d5ed845e00d0b54" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow_mut</source>
          <target state="translated">BorrowError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7a951e76d02cd0d1326baee884b3df884ef7505b" translate="yes" xml:space="preserve">
          <source>BorrowError::cause</source>
          <target state="translated">BorrowError::cause</target>
        </trans-unit>
        <trans-unit id="9346d595a8c0688d171353745aeb9cb098c34080" translate="yes" xml:space="preserve">
          <source>BorrowError::description</source>
          <target state="translated">BorrowError::description</target>
        </trans-unit>
        <trans-unit id="89396ee3db16dbcc29597b262afc46558ed2366f" translate="yes" xml:space="preserve">
          <source>BorrowError::fmt</source>
          <target state="translated">BorrowError::fmt</target>
        </trans-unit>
        <trans-unit id="f021a214bcd178a0ea344c71db12231f4f31c50f" translate="yes" xml:space="preserve">
          <source>BorrowError::from</source>
          <target state="translated">BorrowError::from</target>
        </trans-unit>
        <trans-unit id="886751874954c88f3e019db825f51742642c3fcc" translate="yes" xml:space="preserve">
          <source>BorrowError::into</source>
          <target state="translated">BorrowError::into</target>
        </trans-unit>
        <trans-unit id="26e12b28f77d9243f30385a8268af2b47555aa7c" translate="yes" xml:space="preserve">
          <source>BorrowError::source</source>
          <target state="translated">BorrowError::source</target>
        </trans-unit>
        <trans-unit id="13b09f10b5e2154e8e5ae8b9b7bc53371a685504" translate="yes" xml:space="preserve">
          <source>BorrowError::to_string</source>
          <target state="translated">BorrowError::to_string</target>
        </trans-unit>
        <trans-unit id="2ce8439dd5781fe13a435aac312be62b63c7c5be" translate="yes" xml:space="preserve">
          <source>BorrowError::try_from</source>
          <target state="translated">BorrowError::try_from</target>
        </trans-unit>
        <trans-unit id="433ecad73e66b8dc9a31fe37870bbe334a572245" translate="yes" xml:space="preserve">
          <source>BorrowError::try_into</source>
          <target state="translated">BorrowError::try_into</target>
        </trans-unit>
        <trans-unit id="65acd86f1a255edf5a9bf5a76b81126963ed5e13" translate="yes" xml:space="preserve">
          <source>BorrowError::type_id</source>
          <target state="translated">BorrowError::type_id</target>
        </trans-unit>
        <trans-unit id="7ecce6e07f46ad690e4097354d0bc6aaa0f99008" translate="yes" xml:space="preserve">
          <source>BorrowMut</source>
          <target state="translated">BorrowMut</target>
        </trans-unit>
        <trans-unit id="d9285d895ed643451254273bc8c4bbd62b0abca2" translate="yes" xml:space="preserve">
          <source>BorrowMut::borrow_mut</source>
          <target state="translated">BorrowMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="05ef9e71b85c91963a382e2cbdd7ebb51b1ef2c3" translate="yes" xml:space="preserve">
          <source>BorrowMutError</source>
          <target state="translated">BorrowMutError</target>
        </trans-unit>
        <trans-unit id="6c84f92cc03620eeb60a2a75a6198806e41c99cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow</source>
          <target state="translated">BorrowMutError::borrow</target>
        </trans-unit>
        <trans-unit id="c9194e522b34f7f0397b113f83851e0a0750ebff" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow_mut</source>
          <target state="translated">BorrowMutError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="320189f255d75bf0531f1d4da80752757ad88765" translate="yes" xml:space="preserve">
          <source>BorrowMutError::cause</source>
          <target state="translated">BorrowMutError::cause</target>
        </trans-unit>
        <trans-unit id="5d91335b7a43a382a81f901fb2092637fc2b1b30" translate="yes" xml:space="preserve">
          <source>BorrowMutError::description</source>
          <target state="translated">BorrowMutError::description</target>
        </trans-unit>
        <trans-unit id="de7386f3e6ce0f0541da576e92b462815d327aa2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::fmt</source>
          <target state="translated">BorrowMutError::fmt</target>
        </trans-unit>
        <trans-unit id="0eaaabb7614aee38df98b183695570760d2a3bd8" translate="yes" xml:space="preserve">
          <source>BorrowMutError::from</source>
          <target state="translated">BorrowMutError::from</target>
        </trans-unit>
        <trans-unit id="f361017eeaa59fd5af6e66dc8387dd7623505766" translate="yes" xml:space="preserve">
          <source>BorrowMutError::into</source>
          <target state="translated">BorrowMutError::into</target>
        </trans-unit>
        <trans-unit id="4c422d071ef6d2a11942aa38c90bd2712b395f0a" translate="yes" xml:space="preserve">
          <source>BorrowMutError::source</source>
          <target state="translated">BorrowMutError::source</target>
        </trans-unit>
        <trans-unit id="2eb0e23a66aa4d528bf24f44d0b10d6fbb428403" translate="yes" xml:space="preserve">
          <source>BorrowMutError::to_string</source>
          <target state="translated">BorrowMutError::to_string</target>
        </trans-unit>
        <trans-unit id="b02bd0326962794fede5f5e186f12a2fd926a13b" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_from</source>
          <target state="translated">BorrowMutError::try_from</target>
        </trans-unit>
        <trans-unit id="6719140c2e78bc9c851d093ca84a7d95a4fe42cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_into</source>
          <target state="translated">BorrowMutError::try_into</target>
        </trans-unit>
        <trans-unit id="aed34dec1357c0aa84876bb9c79b00511d803df2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::type_id</source>
          <target state="translated">BorrowMutError::type_id</target>
        </trans-unit>
        <trans-unit id="5868e9faf108a7771c407ab907889934dd63b50a" translate="yes" xml:space="preserve">
          <source>Borrowed data.</source>
          <target state="translated">借来的数据。</target>
        </trans-unit>
        <trans-unit id="c7098078c609573d3fe94c28cfeb29c10812c3db" translate="yes" xml:space="preserve">
          <source>Borrowed pointer type</source>
          <target state="translated">借用指针类型</target>
        </trans-unit>
        <trans-unit id="74d965d163933b4d9c245330d676a9a3a774550a" translate="yes" xml:space="preserve">
          <source>Borrowed reference to an OS string (see &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">借用了对OS字符串的引用（请参阅&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="885dff407470f8d8cfa69af65835344b4ec2492e" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it.</source>
          <target state="translated">借用一个迭代器,而不是消耗它。</target>
        </trans-unit>
        <trans-unit id="e4b68387bd9a788e153fefb151f2e36c5cc3e492" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">借用一个迭代器，而不是使用它。&lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c2a592fe9d3573696dcb4e01f0c58c8f29d9729" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">借用一个迭代器，而不是使用它。&lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9f6098309a428e4660e57ac0d7a128a57eb4f3" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">借用一个迭代器，而不是使用它。&lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d7aa1610c7d0263c276944863186c7f5b54aca" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">借用一个迭代器，而不是使用它。&lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0448c3473f95cd23244ee44dd3147a10fd3dd487" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">借用一个迭代器，而不是使用它。&lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f99b7e6b9280152eedd396f475e3d3c1511ee27c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&lt;code&gt;dyn Trait&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt; in return types have a an implicit &lt;code&gt;'static&lt;/code&gt; requirement, meaning that the value implementing them that is being returned has to be either a &lt;code&gt;'static&lt;/code&gt; borrow or an owned value.</source>
          <target state="translated">无论&lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt; &lt;code&gt;dyn Trait&lt;/code&gt; &lt;/a&gt;，并&lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt; &lt;code&gt;impl Trait&lt;/code&gt; &lt;/a&gt;的返回类型有一个隐含的 &lt;code&gt;'static&lt;/code&gt; 的要求，这意味着价值实现正被退回，必须为一个他们 &lt;code&gt;'static&lt;/code&gt; 借用或拥有的价值。</target>
        </trans-unit>
        <trans-unit id="5f521714f9167c57599a72f6be51da170e80a3dd" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;items/constant-items&quot;&gt;constant&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; declarations of reference types have &lt;em&gt;implicit&lt;/em&gt;&lt;code&gt;'static&lt;/code&gt; lifetimes unless an explicit lifetime is specified. As such, the constant declarations involving &lt;code&gt;'static&lt;/code&gt; above may be written without the lifetimes.</source>
          <target state="translated">两个&lt;a href=&quot;items/constant-items&quot;&gt;恒定&lt;/a&gt;和&lt;a href=&quot;items/static-items&quot;&gt;静态&lt;/a&gt;引用类型的声明具有&lt;em&gt;隐式&lt;/em&gt; &lt;code&gt;'static&lt;/code&gt; ，除非指定了明确的寿命的寿命。这样，涉及 &lt;code&gt;'static&lt;/code&gt; 上面的&amp;rdquo;的常量声明可能没有生存期。</target>
        </trans-unit>
        <trans-unit id="05a5142bb4165da20e62a15a12a49d69f51e7d7c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es and &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;s are poisoned whenever a thread fails while the lock is held. The precise semantics for when a lock is poisoned is documented on each lock, but once a lock is poisoned then all future acquisitions will return this error.</source>
          <target state="translated">这两种&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; ES和&lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt;，只要同时持有锁的线程失败s的中毒。锁中毒的确切语义记录在每个锁上，但是一旦锁中毒，则所有将来的获取都将返回此错误。</target>
        </trans-unit>
        <trans-unit id="92f3e1242e71f216f2553ecade5c0b56c112c46f" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">无论 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dst&lt;/code&gt; 必须正确对齐。</target>
        </trans-unit>
        <trans-unit id="c1a304706d4634a69f512f48a553ca6de0a57224" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">两个 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须是&lt;a href=&quot;index#safety&quot;&gt;有效的&lt;/a&gt;用于读取和写入的 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="62b58df899df91147ad1851a44f1534537b8baae" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes.</source>
          <target state="translated">这两个 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须是&lt;a href=&quot;index#safety&quot;&gt;有效&lt;/a&gt;的读取和写入。</target>
        </trans-unit>
        <trans-unit id="2af274f82063aea319dd50db89daaff81dd41c5b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">两个 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须是&lt;a href=&quot;index#safety&quot;&gt;有效的&lt;/a&gt;用于读取和写入的 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="f6aa81faf4ff06762f89afa21d147f447e5913ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes.</source>
          <target state="translated">这两个 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须是&lt;a href=&quot;index#safety&quot;&gt;有效&lt;/a&gt;的读取和写入操作。</target>
        </trans-unit>
        <trans-unit id="ab994fd6a56d4038a2b10fa7688bd17375033138" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">这两个 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须正确对齐。</target>
        </trans-unit>
        <trans-unit id="c79da800bdef51dcfa75d10a65ea136a827d95b9" translate="yes" xml:space="preserve">
          <source>Both absolute and relative paths are followed by one or more identifiers separated by double colons (&lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">绝对和相对路径接着是一个或多个标识符中分离由双冒号（ &lt;code&gt;::&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c285e2e79ff8d2abdbcbfce35a32a0f639fd60af" translate="yes" xml:space="preserve">
          <source>Both are equivalent to:</source>
          <target state="translated">两者相当于。</target>
        </trans-unit>
        <trans-unit id="d969a72eda5767cc021898e028fbe0fc071270ae" translate="yes" xml:space="preserve">
          <source>Both attributes can be used on &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;. When applied to a function in a &lt;a href=&quot;../items/traits&quot;&gt;trait&lt;/a&gt;, they apply only to that function when used as a default function for a trait implementation and not to all trait implementations. The attributes have no effect on a trait function without a body.</source>
          <target state="translated">这两个属性都可以在&lt;a href=&quot;../items/functions&quot;&gt;函数&lt;/a&gt;上使用。当应用于&lt;a href=&quot;../items/traits&quot;&gt;特征&lt;/a&gt;中的功能时，它们仅用作特征实现的默认功能时才适用于该功能，而不适用于所有特征实现。这些属性对没有主体的特征功能没有影响。</target>
        </trans-unit>
        <trans-unit id="969434c27ab08daa9144a7ddff09f258b6b015fd" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="translated">两个匹配臂都必须产生&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;类型的值，但是由于 &lt;code&gt;break&lt;/code&gt; 根本不会产生任何值，我们知道它永远不会产生不是&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;的值。这说明了 &lt;code&gt;!&lt;/code&gt; 的另一种行为。类型-具有类型的表达式 &lt;code&gt;!&lt;/code&gt; 将强制转换为其他任何类型。</target>
        </trans-unit>
        <trans-unit id="f415dc3d7d35015fcd0e7c895d9cc2c978758324" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="translated">两个匹配臂都必须产生&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;类型的值，但是由于 &lt;code&gt;break&lt;/code&gt; 根本不会产生值，我们知道它永远不会产生不是&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;的值。这说明了 &lt;code&gt;!&lt;/code&gt; 的另一种行为。类型-类型的表达式 &lt;code&gt;!&lt;/code&gt; 将强制转换为其他任何类型。</target>
        </trans-unit>
        <trans-unit id="cc4e0abfff334b57590e92cdeed48cb0b5815f3f" translate="yes" xml:space="preserve">
          <source>Both of the following must be true:</source>
          <target state="translated">以下两项必须为真。</target>
        </trans-unit>
        <trans-unit id="8047c2fba1b8345d0b2a7bfe41d16519cea0cd82" translate="yes" xml:space="preserve">
          <source>Both pointers must be &lt;em&gt;derived from&lt;/em&gt; a pointer to the same object. (See below for an example.)</source>
          <target state="translated">两个指针都必须&lt;em&gt;从&lt;/em&gt;指向同一对象的指针&lt;em&gt;派生&lt;/em&gt;。（请参见下面的示例。）</target>
        </trans-unit>
        <trans-unit id="2bf778379c09be3c08a3e90c46c05409146c7bf5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;DraftPost&lt;/code&gt; structs have a private &lt;code&gt;content&lt;/code&gt; field that stores the blog post text. The structs no longer have the &lt;code&gt;state&lt;/code&gt; field because we&amp;rsquo;re moving the encoding of the state to the types of the structs. The &lt;code&gt;Post&lt;/code&gt; struct will represent a published post, and it has a &lt;code&gt;content&lt;/code&gt; method that returns the &lt;code&gt;content&lt;/code&gt;.</source>
          <target state="translated">无论是 &lt;code&gt;Post&lt;/code&gt; 和 &lt;code&gt;DraftPost&lt;/code&gt; 结构有私人 &lt;code&gt;content&lt;/code&gt; 字段存储博客文章的文本。结构不再具有 &lt;code&gt;state&lt;/code&gt; 字段，因为我们正在将状态的编码移动到结构的类型。该 &lt;code&gt;Post&lt;/code&gt; 结构将代表发布后，它有一个 &lt;code&gt;content&lt;/code&gt; 方法返回的 &lt;code&gt;content&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15171a122c9ce22a8b1a51961d40b1161cecfb6b" translate="yes" xml:space="preserve">
          <source>Both the lower- and upper-bounds (&lt;code&gt;l&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt; respectively) are provided, because an allocator based on size classes could misbehave if one attempts to deallocate a block without providing a correct value for its size (i.e., one within the range &lt;code&gt;[l, u]&lt;/code&gt;).</source>
          <target state="translated">提供下限和上限（分别为 &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;u&lt;/code&gt; ），因为如果尝试取消分配一个块而不提供其大小的正确值（即 &lt;code&gt;[l, u]&lt;/code&gt; 范围内的一个值），则基于大小类的分配器可能会出现异常。，u]）。</target>
        </trans-unit>
        <trans-unit id="98967fc7894aa4615d5bff073afe78f05a767908" translate="yes" xml:space="preserve">
          <source>Both the reading and the writing portions of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;的读取和写入部分均应关闭。</target>
        </trans-unit>
        <trans-unit id="c7bb49751d5e5b9335e672e163e91914b0f06be3" translate="yes" xml:space="preserve">
          <source>Both the stack and the heap are parts of memory that are available to your code to use at runtime, but they are structured in different ways. The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as &lt;em&gt;last in, first out&lt;/em&gt;. Think of a stack of plates: when you add more plates, you put them on top of the pile, and when you need a plate, you take one off the top. Adding or removing plates from the middle or bottom wouldn&amp;rsquo;t work as well! Adding data is called &lt;em&gt;pushing onto the stack&lt;/em&gt;, and removing data is called &lt;em&gt;popping off the stack&lt;/em&gt;.</source>
          <target state="translated">堆栈和堆都是代码可在运行时使用的内存部分，但是它们的结构不同。堆栈按获取值的顺序存储值，并以相反的顺序删除值。这称为后进&lt;em&gt;先出&lt;/em&gt;。想想一堆盘子：添加更多的盘子时，将它们放在堆的顶部，而当需要一块盘子时，则从顶部取下一个盘子。从中间或底部添加或删除板都无法正常工作！添加数据称为&lt;em&gt;压入堆栈&lt;/em&gt;，而删除数据称为&lt;em&gt;弹出堆栈&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0d50912827dc83752805291122efdab8614525af" translate="yes" xml:space="preserve">
          <source>Both the starting and other pointer must be either in bounds or one byte past the end of the same allocated object.</source>
          <target state="translated">起始指针和另一个指针都必须在界内,或者在同一分配对象的结束后一个字节。</target>
        </trans-unit>
        <trans-unit id="d01b29b32d289e0c8b9a18df5a84772808d7bfc2" translate="yes" xml:space="preserve">
          <source>Both the starting and other pointer must be either in bounds or one byte past the end of the same allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="translated">起始指针和另一个指针都必须在界内,或者在同一分配对象结束后的一个字节内。注意,在Rust中,每个(堆栈分配的)变量都被认为是一个单独的分配对象。</target>
        </trans-unit>
        <trans-unit id="72784f6c1c0665f0bf4dbcd1fd7585be3cfa702f" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of an allocated object. If either pointer is out of bounds or arithmetic overflow occurs then any further use of the returned value will result in undefined behavior.</source>
          <target state="translated">起始指针和结果指针都必须在界内,或者在分配对象结束后的一个字节内,如果其中一个指针超出界内或者发生算术溢出,那么进一步使用返回值将导致未定义行为。如果任何一个指针出界或发生算术溢出,那么任何进一步使用返回值的行为都将导致未定义。</target>
        </trans-unit>
        <trans-unit id="ab5604b532321bee04b244b342d737f8189eea86" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object.</source>
          <target state="translated">起始指针和结果指针都必须在界内,或者在同一分配对象的末端过一个字节。</target>
        </trans-unit>
        <trans-unit id="b2aa47636e98a60617bcdd3e67a5924dfb004f66" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="translated">起始指针和结果指针都必须在界内,或者是在同一个分配对象的末端一个字节之后。请注意,在Rust中,每个(堆栈分配的)变量都被认为是一个单独的分配对象。</target>
        </trans-unit>
        <trans-unit id="66fee1cf29e97c8fc0875ae5e9908b627fd1605d" translate="yes" xml:space="preserve">
          <source>Both types must have the same size. Neither the original, nor the result, may be an &lt;a href=&quot;https://doc.rust-lang.org/nomicon/what-unsafe-does.html&quot;&gt;invalid value&lt;/a&gt;.</source>
          <target state="translated">两种类型的大小必须相同。原始值或结果都不能是&lt;a href=&quot;https://doc.rust-lang.org/nomicon/what-unsafe-does.html&quot;&gt;无效值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c346acf685cb1f6817015d7708b959e84444f26" translate="yes" xml:space="preserve">
          <source>Bound</source>
          <target state="translated">Bound</target>
        </trans-unit>
        <trans-unit id="6b7a8fef068d73e848dac8523afae549fc821d96" translate="yes" xml:space="preserve">
          <source>Bound::borrow</source>
          <target state="translated">Bound::borrow</target>
        </trans-unit>
        <trans-unit id="18bb2e890d75080b556aef676184c5919be5992a" translate="yes" xml:space="preserve">
          <source>Bound::borrow_mut</source>
          <target state="translated">Bound::borrow_mut</target>
        </trans-unit>
        <trans-unit id="377e882cd7fc9a872bb54ce900229dd706dfc18e" translate="yes" xml:space="preserve">
          <source>Bound::clone</source>
          <target state="translated">Bound::clone</target>
        </trans-unit>
        <trans-unit id="27441f23a3225df9857b23126eebcbeaa6dcfa57" translate="yes" xml:space="preserve">
          <source>Bound::clone_from</source>
          <target state="translated">Bound::clone_from</target>
        </trans-unit>
        <trans-unit id="d4f69fa455be1a2d7f74f09dcf28628a95d81806" translate="yes" xml:space="preserve">
          <source>Bound::clone_into</source>
          <target state="translated">Bound::clone_into</target>
        </trans-unit>
        <trans-unit id="252db2d859de80913734f1d7a97d46b455067071" translate="yes" xml:space="preserve">
          <source>Bound::cloned</source>
          <target state="translated">Bound::cloned</target>
        </trans-unit>
        <trans-unit id="46c76647f9ac933b457df321f87cbafee078c04b" translate="yes" xml:space="preserve">
          <source>Bound::eq</source>
          <target state="translated">Bound::eq</target>
        </trans-unit>
        <trans-unit id="109b368628394a6771e9026bb249cb9a770aa495" translate="yes" xml:space="preserve">
          <source>Bound::fmt</source>
          <target state="translated">Bound::fmt</target>
        </trans-unit>
        <trans-unit id="d2a47e1914c25c25b3e40fc39fb12d33547d7e82" translate="yes" xml:space="preserve">
          <source>Bound::from</source>
          <target state="translated">Bound::from</target>
        </trans-unit>
        <trans-unit id="ba919ff9d1df1744fb627fa7855b8f05cc2b77ed" translate="yes" xml:space="preserve">
          <source>Bound::hash</source>
          <target state="translated">Bound::hash</target>
        </trans-unit>
        <trans-unit id="5a473f87e1bb852dc398c279b415db545cd4b24e" translate="yes" xml:space="preserve">
          <source>Bound::hash_slice</source>
          <target state="translated">Bound::hash_slice</target>
        </trans-unit>
        <trans-unit id="54778a9e486243aa16573515109523bbf492d0d1" translate="yes" xml:space="preserve">
          <source>Bound::into</source>
          <target state="translated">Bound::into</target>
        </trans-unit>
        <trans-unit id="dedfd5e96791c9889a42b174f98bd419bce5e68f" translate="yes" xml:space="preserve">
          <source>Bound::ne</source>
          <target state="translated">Bound::ne</target>
        </trans-unit>
        <trans-unit id="ab242a98c5b08c66ef7dc6a8a0cb34b4b2961e44" translate="yes" xml:space="preserve">
          <source>Bound::to_owned</source>
          <target state="translated">Bound::to_owned</target>
        </trans-unit>
        <trans-unit id="9a69c2090e4312fb09b145cc8cc6bd670302d586" translate="yes" xml:space="preserve">
          <source>Bound::try_from</source>
          <target state="translated">Bound::try_from</target>
        </trans-unit>
        <trans-unit id="763620a7caa5bb18601b6f9a97d64ddf732e2329" translate="yes" xml:space="preserve">
          <source>Bound::try_into</source>
          <target state="translated">Bound::try_into</target>
        </trans-unit>
        <trans-unit id="f370fdaa52e7ec335a260ab2d97b2ca401271f1b" translate="yes" xml:space="preserve">
          <source>Bound::type_id</source>
          <target state="translated">Bound::type_id</target>
        </trans-unit>
        <trans-unit id="c5964dba854ca10e309192dd054d46319ddd1bae" translate="yes" xml:space="preserve">
          <source>Bounds are constraints on a type or trait. For example, if a bound is placed on the argument a function takes, types passed to that function must abide by that constraint.</source>
          <target state="translated">约束是对类型或特性的约束。例如,如果一个函数的参数有一个约束,那么传递给该函数的类型必须遵守这个约束。</target>
        </trans-unit>
        <trans-unit id="ca6bc4b3d93728fa4fe8f6d78ae36c82b188ed72" translate="yes" xml:space="preserve">
          <source>Bounds on an item must be satisfied when using the item. When type checking and borrow checking a generic item, the bounds can be used to determine that a trait is implemented for a type. For example, given &lt;code&gt;Ty: Trait&lt;/code&gt;</source>
          <target state="translated">使用物品时，必须满足物品上的界限。在进行类型检查和借阅检查通用项目时，可以使用边界来确定是否为类型实现了特征。例如，给定 &lt;code&gt;Ty: Trait&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8db62bb4eebb31a7863a25492026fe5ef94ccb8d" translate="yes" xml:space="preserve">
          <source>Bounds that don't use the item's parameters or higher-ranked lifetimes are checked when the item is defined. It is an error for such a bound to be false.</source>
          <target state="translated">在定义项目时,会检查不使用项目的参数或更高等级的寿命的边界。如果这种界限为假,则是错误的。</target>
        </trans-unit>
        <trans-unit id="4b064da5fe9593f583b40c21207783b175e1ebf2" translate="yes" xml:space="preserve">
          <source>Bounds written after declaring a &lt;a href=&quot;items/generics&quot;&gt;generic parameter&lt;/a&gt;: &lt;code&gt;fn f&amp;lt;A: Copy&amp;gt;() {}&lt;/code&gt; is the same as &lt;code&gt;fn f&amp;lt;A&amp;gt; where A: Copy () {}&lt;/code&gt;.</source>
          <target state="translated">声明&lt;a href=&quot;items/generics&quot;&gt;通用参数&lt;/a&gt;后写的界限： &lt;code&gt;fn f&amp;lt;A: Copy&amp;gt;() {}&lt;/code&gt; 与 &lt;code&gt;fn f&amp;lt;A&amp;gt; where A: Copy () {}&lt;/code&gt; 相同，其中A：Copy（）{}。</target>
        </trans-unit>
        <trans-unit id="239ca5767afac9641593464ce02bc454d6ac07a9" translate="yes" xml:space="preserve">
          <source>Box</source>
          <target state="translated">Box</target>
        </trans-unit>
        <trans-unit id="98f85596ae7b9b42504e10a1325d441abcd2486d" translate="yes" xml:space="preserve">
          <source>Box::all</source>
          <target state="translated">Box::all</target>
        </trans-unit>
        <trans-unit id="b639107f3271721c720775da7e802911f662b1b1" translate="yes" xml:space="preserve">
          <source>Box::any</source>
          <target state="translated">Box::any</target>
        </trans-unit>
        <trans-unit id="7c64d4849917073ddc48c9ebb00f360df4c9d7a4" translate="yes" xml:space="preserve">
          <source>Box::as_mut</source>
          <target state="translated">Box::as_mut</target>
        </trans-unit>
        <trans-unit id="6848e42541571d900c21f082d7585fb9168d4af7" translate="yes" xml:space="preserve">
          <source>Box::as_ref</source>
          <target state="translated">Box::as_ref</target>
        </trans-unit>
        <trans-unit id="6d56f42ac2a542e91194b361d21189ab4bd414b3" translate="yes" xml:space="preserve">
          <source>Box::borrow</source>
          <target state="translated">Box::borrow</target>
        </trans-unit>
        <trans-unit id="c99f2a149a7bc2bb960eba8eda77967bcecf0e8d" translate="yes" xml:space="preserve">
          <source>Box::borrow_mut</source>
          <target state="translated">Box::borrow_mut</target>
        </trans-unit>
        <trans-unit id="17f5075e3006cf9d119c727bb0e54e46c7eebaa6" translate="yes" xml:space="preserve">
          <source>Box::by_ref</source>
          <target state="translated">Box::by_ref</target>
        </trans-unit>
        <trans-unit id="61d60a2dfd95d2edba019ae7a505a5a8b6bad430" translate="yes" xml:space="preserve">
          <source>Box::bytes</source>
          <target state="translated">Box::bytes</target>
        </trans-unit>
        <trans-unit id="46fe884decfe5370e5c5fe2408915b53963bbffb" translate="yes" xml:space="preserve">
          <source>Box::call</source>
          <target state="translated">Box::call</target>
        </trans-unit>
        <trans-unit id="374988426e0ba138e6f583dbe0ce037ce343561c" translate="yes" xml:space="preserve">
          <source>Box::call_mut</source>
          <target state="translated">Box::call_mut</target>
        </trans-unit>
        <trans-unit id="221be09338afb54138c6ba69b6155871dd1f1604" translate="yes" xml:space="preserve">
          <source>Box::call_once</source>
          <target state="translated">Box::call_once</target>
        </trans-unit>
        <trans-unit id="212e1a3fbba385ceea9d2d039d37d904ae132bdd" translate="yes" xml:space="preserve">
          <source>Box::cause</source>
          <target state="translated">Box::cause</target>
        </trans-unit>
        <trans-unit id="1eb80191936cdac28f33c70fb0561232cbe1a0ce" translate="yes" xml:space="preserve">
          <source>Box::chain</source>
          <target state="translated">Box::chain</target>
        </trans-unit>
        <trans-unit id="9a890655e788211db3d21c5daf10e4fa6bedbf64" translate="yes" xml:space="preserve">
          <source>Box::clamp</source>
          <target state="translated">Box::clamp</target>
        </trans-unit>
        <trans-unit id="332b16f27092792c1ac7aba3b13ed4a2b647f865" translate="yes" xml:space="preserve">
          <source>Box::clone</source>
          <target state="translated">Box::clone</target>
        </trans-unit>
        <trans-unit id="0511825945441353f0c46a388bf94987ad6afb32" translate="yes" xml:space="preserve">
          <source>Box::clone_from</source>
          <target state="translated">Box::clone_from</target>
        </trans-unit>
        <trans-unit id="df3fac12d073e919e309cdc2ac6374e292180e78" translate="yes" xml:space="preserve">
          <source>Box::clone_into</source>
          <target state="translated">Box::clone_into</target>
        </trans-unit>
        <trans-unit id="6e363e6d0300a78f70074a806f60975e864accad" translate="yes" xml:space="preserve">
          <source>Box::cloned</source>
          <target state="translated">Box::cloned</target>
        </trans-unit>
        <trans-unit id="6c96b7576d584aee2f26ba1a32a3f04121f43e20" translate="yes" xml:space="preserve">
          <source>Box::cmp</source>
          <target state="translated">Box::cmp</target>
        </trans-unit>
        <trans-unit id="eeef833143ebcf0bc697aec2eefdc455624f9e0d" translate="yes" xml:space="preserve">
          <source>Box::collect</source>
          <target state="translated">Box::collect</target>
        </trans-unit>
        <trans-unit id="3d0f23afd6563472c47a167b48b8410fc559e492" translate="yes" xml:space="preserve">
          <source>Box::consume</source>
          <target state="translated">Box::consume</target>
        </trans-unit>
        <trans-unit id="44105eeec746662536d53672c3fb78098daee296" translate="yes" xml:space="preserve">
          <source>Box::copied</source>
          <target state="translated">Box::copied</target>
        </trans-unit>
        <trans-unit id="7ad1e95ce02daa64c1eaef18f06b9d8a7b568791" translate="yes" xml:space="preserve">
          <source>Box::count</source>
          <target state="translated">Box::count</target>
        </trans-unit>
        <trans-unit id="63ba5f4100a0be0c367e10e279bbb76a90044076" translate="yes" xml:space="preserve">
          <source>Box::cycle</source>
          <target state="translated">Box::cycle</target>
        </trans-unit>
        <trans-unit id="3100809b3c22540251ee4d32f870f0ab5d85f812" translate="yes" xml:space="preserve">
          <source>Box::default</source>
          <target state="translated">Box::default</target>
        </trans-unit>
        <trans-unit id="d2afb24813ad916ee3f3c876745772187d20e4b6" translate="yes" xml:space="preserve">
          <source>Box::deref</source>
          <target state="translated">Box::deref</target>
        </trans-unit>
        <trans-unit id="c38310d47b15e572611b4edc0c34463c00ac8351" translate="yes" xml:space="preserve">
          <source>Box::deref_mut</source>
          <target state="translated">Box::deref_mut</target>
        </trans-unit>
        <trans-unit id="4407e689e2360934dc281ec09f440aa221be5ae6" translate="yes" xml:space="preserve">
          <source>Box::description</source>
          <target state="translated">Box::description</target>
        </trans-unit>
        <trans-unit id="3166dd8642b65175a3bd7c7a52199fb715fe0594" translate="yes" xml:space="preserve">
          <source>Box::downcast</source>
          <target state="translated">Box::downcast</target>
        </trans-unit>
        <trans-unit id="daa5d80c59542cc920cd455f7d64b23c983bc609" translate="yes" xml:space="preserve">
          <source>Box::drop</source>
          <target state="translated">Box::drop</target>
        </trans-unit>
        <trans-unit id="1ce09716c9c1deae7f81c32dcf52fa616b12ca02" translate="yes" xml:space="preserve">
          <source>Box::enumerate</source>
          <target state="translated">Box::enumerate</target>
        </trans-unit>
        <trans-unit id="6cf03ef281bd05acc9e8788a558b01545153452e" translate="yes" xml:space="preserve">
          <source>Box::eq</source>
          <target state="translated">Box::eq</target>
        </trans-unit>
        <trans-unit id="4d3c429c86bcb5b6eb5c6bb097bc1d76c3b6d725" translate="yes" xml:space="preserve">
          <source>Box::fill_buf</source>
          <target state="translated">Box::fill_buf</target>
        </trans-unit>
        <trans-unit id="e0cfe090654acd2813dda2cadb04ff611bd40f8c" translate="yes" xml:space="preserve">
          <source>Box::filter</source>
          <target state="translated">Box::filter</target>
        </trans-unit>
        <trans-unit id="883f1c107d0f7a023ce3ace96cd45f32b3a24f77" translate="yes" xml:space="preserve">
          <source>Box::filter_map</source>
          <target state="translated">Box::filter_map</target>
        </trans-unit>
        <trans-unit id="8dba1be2d1b661c2a19ed51cf35f61687ebb811c" translate="yes" xml:space="preserve">
          <source>Box::find</source>
          <target state="translated">Box::find</target>
        </trans-unit>
        <trans-unit id="f1e4c766b00488cdb2e145cf4a27a074f88b9608" translate="yes" xml:space="preserve">
          <source>Box::find_map</source>
          <target state="translated">Box::find_map</target>
        </trans-unit>
        <trans-unit id="c5e9fddfd660282ca666cc6d744b46cd9a98281c" translate="yes" xml:space="preserve">
          <source>Box::finish</source>
          <target state="translated">Box::finish</target>
        </trans-unit>
        <trans-unit id="7698c71e0db1c73d3407ac25452c69edf519bc43" translate="yes" xml:space="preserve">
          <source>Box::flat_map</source>
          <target state="translated">Box::flat_map</target>
        </trans-unit>
        <trans-unit id="59e78e2254012fa056fb63d3af090ff23d9caa18" translate="yes" xml:space="preserve">
          <source>Box::flatten</source>
          <target state="translated">Box::flatten</target>
        </trans-unit>
        <trans-unit id="a6f7e58af02021c1636cef25915365d21c74a8a2" translate="yes" xml:space="preserve">
          <source>Box::flush</source>
          <target state="translated">Box::flush</target>
        </trans-unit>
        <trans-unit id="c6784df312e8ae8f90011ca22e8d36adb66a847a" translate="yes" xml:space="preserve">
          <source>Box::fmt</source>
          <target state="translated">Box::fmt</target>
        </trans-unit>
        <trans-unit id="fddbdef17bce1a8df59157b8fd1db42560d5f3ee" translate="yes" xml:space="preserve">
          <source>Box::fold</source>
          <target state="translated">Box::fold</target>
        </trans-unit>
        <trans-unit id="0a52ad01f142af48e3794dd7e59fc9bc3c7aa5d4" translate="yes" xml:space="preserve">
          <source>Box::for_each</source>
          <target state="translated">Box::for_each</target>
        </trans-unit>
        <trans-unit id="ed62e9121c4c62c0d5ce944ae44d5048012950db" translate="yes" xml:space="preserve">
          <source>Box::from</source>
          <target state="translated">Box::from</target>
        </trans-unit>
        <trans-unit id="91aab981ee80cfea73883f72f3f4a7df87328afd" translate="yes" xml:space="preserve">
          <source>Box::from_iter</source>
          <target state="translated">Box::from_iter</target>
        </trans-unit>
        <trans-unit id="99a56fd56f3eda7092816760238ede7c3fa6109f" translate="yes" xml:space="preserve">
          <source>Box::from_raw</source>
          <target state="translated">Box::from_raw</target>
        </trans-unit>
        <trans-unit id="10348aa1512f4c519b5613b846a2d8d6cfc47b88" translate="yes" xml:space="preserve">
          <source>Box::fuse</source>
          <target state="translated">Box::fuse</target>
        </trans-unit>
        <trans-unit id="530d37fa415cfa7c32ec4b55571698e45da6f959" translate="yes" xml:space="preserve">
          <source>Box::ge</source>
          <target state="translated">Box::ge</target>
        </trans-unit>
        <trans-unit id="4b72a4352f4fe91f47f069cdabc6e6ad95f13b44" translate="yes" xml:space="preserve">
          <source>Box::gt</source>
          <target state="translated">Box::gt</target>
        </trans-unit>
        <trans-unit id="16c6635f4bb22fdb3cea4763415a3155c214ed75" translate="yes" xml:space="preserve">
          <source>Box::hash</source>
          <target state="translated">Box::hash</target>
        </trans-unit>
        <trans-unit id="4c2a4b460b5d8fc9bdda66cc71714fbab479852a" translate="yes" xml:space="preserve">
          <source>Box::hash_slice</source>
          <target state="translated">Box::hash_slice</target>
        </trans-unit>
        <trans-unit id="343ef75a47ac9840e34ddf7a2da0d02c25787582" translate="yes" xml:space="preserve">
          <source>Box::initializer</source>
          <target state="translated">Box::initializer</target>
        </trans-unit>
        <trans-unit id="63ff0ff3838d20603f1ee804508fc3e64e303af2" translate="yes" xml:space="preserve">
          <source>Box::inspect</source>
          <target state="translated">Box::inspect</target>
        </trans-unit>
        <trans-unit id="85607e14d6de81746b803858c2540ca8c6b44bdb" translate="yes" xml:space="preserve">
          <source>Box::into</source>
          <target state="translated">Box::into</target>
        </trans-unit>
        <trans-unit id="f6b1af13daabe54761e736d7c80500ab6b9a1674" translate="yes" xml:space="preserve">
          <source>Box::into_iter</source>
          <target state="translated">Box::into_iter</target>
        </trans-unit>
        <trans-unit id="acbaecb1989ceef80f562e795d009f33656980ca" translate="yes" xml:space="preserve">
          <source>Box::into_pin</source>
          <target state="translated">Box::into_pin</target>
        </trans-unit>
        <trans-unit id="4842429f228dc17504f648e08a5f4f16e0e2062a" translate="yes" xml:space="preserve">
          <source>Box::into_raw</source>
          <target state="translated">Box::into_raw</target>
        </trans-unit>
        <trans-unit id="3f79bc4ecb72c296f646e58c0e20ae529797f781" translate="yes" xml:space="preserve">
          <source>Box::into_raw_non_null</source>
          <target state="translated">Box::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="3614510072231db3137f0d7aeb928f934f1c493d" translate="yes" xml:space="preserve">
          <source>Box::into_searcher</source>
          <target state="translated">Box::into_searcher</target>
        </trans-unit>
        <trans-unit id="2a8c6b52f333bc0cef92fffa23a800dc8255b691" translate="yes" xml:space="preserve">
          <source>Box::is_contained_in</source>
          <target state="translated">Box::is_contained_in</target>
        </trans-unit>
        <trans-unit id="6f2c2c3465fb0d25bc14172b3cdf438dd8946893" translate="yes" xml:space="preserve">
          <source>Box::is_empty</source>
          <target state="translated">Box::is_empty</target>
        </trans-unit>
        <trans-unit id="5ce85dca8b5589117e52c9eb46ed6631b186778a" translate="yes" xml:space="preserve">
          <source>Box::is_prefix_of</source>
          <target state="translated">Box::is_prefix_of</target>
        </trans-unit>
        <trans-unit id="b2d0a3538bcce4d4341580322555cb175af9e055" translate="yes" xml:space="preserve">
          <source>Box::is_sorted</source>
          <target state="translated">Box::is_sorted</target>
        </trans-unit>
        <trans-unit id="e8bc76461809058c2bf78bd03616e55f959cee1e" translate="yes" xml:space="preserve">
          <source>Box::is_sorted_by</source>
          <target state="translated">Box::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0a88b0e90b45af6841206b9222039635add3e64f" translate="yes" xml:space="preserve">
          <source>Box::is_sorted_by_key</source>
          <target state="translated">Box::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="a72dc555efdbfa80a6b0d5c0b4f285602f05c856" translate="yes" xml:space="preserve">
          <source>Box::is_suffix_of</source>
          <target state="translated">Box::is_suffix_of</target>
        </trans-unit>
        <trans-unit id="e5727693a6c4cd3248cc40c999eef24607bc94c4" translate="yes" xml:space="preserve">
          <source>Box::last</source>
          <target state="translated">Box::last</target>
        </trans-unit>
        <trans-unit id="d894e0ab37daa6ed36ffcb6dc6f6ae6feafe4d29" translate="yes" xml:space="preserve">
          <source>Box::le</source>
          <target state="translated">Box::le</target>
        </trans-unit>
        <trans-unit id="bb0f72b159e3eafd1c056e394655cd200d490416" translate="yes" xml:space="preserve">
          <source>Box::leak</source>
          <target state="translated">Box::leak</target>
        </trans-unit>
        <trans-unit id="d677d8cc4fbf16dda95f7cc9f6f227fc9bf5458e" translate="yes" xml:space="preserve">
          <source>Box::len</source>
          <target state="translated">Box::len</target>
        </trans-unit>
        <trans-unit id="45bad95b762a8b026bd24017358dab88a4d6860e" translate="yes" xml:space="preserve">
          <source>Box::lines</source>
          <target state="translated">Box::lines</target>
        </trans-unit>
        <trans-unit id="72b25c9787fb55646beeb56c75cec4a153ebed4b" translate="yes" xml:space="preserve">
          <source>Box::lt</source>
          <target state="translated">Box::lt</target>
        </trans-unit>
        <trans-unit id="f2618ca0d7141ef535495cca35bfb5aa17708bc5" translate="yes" xml:space="preserve">
          <source>Box::map</source>
          <target state="translated">Box::map</target>
        </trans-unit>
        <trans-unit id="0bc41a6cab2d616f4a773cadf7a4a0287ec2ab6e" translate="yes" xml:space="preserve">
          <source>Box::max</source>
          <target state="translated">Box::max</target>
        </trans-unit>
        <trans-unit id="b5a62311ec4389dcea655a4a653acc770ae70df8" translate="yes" xml:space="preserve">
          <source>Box::max_by</source>
          <target state="translated">Box::max_by</target>
        </trans-unit>
        <trans-unit id="d0583d8c8a9191551534a635b566f913b18db0e0" translate="yes" xml:space="preserve">
          <source>Box::max_by_key</source>
          <target state="translated">Box::max_by_key</target>
        </trans-unit>
        <trans-unit id="5516ccddf3095fdf20b85d48497a76f13db9f3ab" translate="yes" xml:space="preserve">
          <source>Box::min</source>
          <target state="translated">Box::min</target>
        </trans-unit>
        <trans-unit id="57731c7eaf53528b46c94a8f5b04067977541b8e" translate="yes" xml:space="preserve">
          <source>Box::min_by</source>
          <target state="translated">Box::min_by</target>
        </trans-unit>
        <trans-unit id="5e6b2f4822e5c3d83d1318a14c7f1a3668b8120b" translate="yes" xml:space="preserve">
          <source>Box::min_by_key</source>
          <target state="translated">Box::min_by_key</target>
        </trans-unit>
        <trans-unit id="4df5d8b53f02075451eb004c4d2840a8ab301c06" translate="yes" xml:space="preserve">
          <source>Box::ne</source>
          <target state="translated">Box::ne</target>
        </trans-unit>
        <trans-unit id="1cb94d98d7b75dacb7e7e360644f9c7e2642829f" translate="yes" xml:space="preserve">
          <source>Box::new</source>
          <target state="translated">Box::new</target>
        </trans-unit>
        <trans-unit id="773581cb76ebc7fffb4b726bb7032d772321f18e" translate="yes" xml:space="preserve">
          <source>Box::next</source>
          <target state="translated">Box::next</target>
        </trans-unit>
        <trans-unit id="39a9d8e0d1ae73478ca6c4fc28570233d4f2d14d" translate="yes" xml:space="preserve">
          <source>Box::next_back</source>
          <target state="translated">Box::next_back</target>
        </trans-unit>
        <trans-unit id="ca8b4b8a75b7ab2fc6b63b0e3e0d3d3ac349fcbc" translate="yes" xml:space="preserve">
          <source>Box::nth</source>
          <target state="translated">Box::nth</target>
        </trans-unit>
        <trans-unit id="be1768702f171a2bca631f2dada36573e66e8f4c" translate="yes" xml:space="preserve">
          <source>Box::nth_back</source>
          <target state="translated">Box::nth_back</target>
        </trans-unit>
        <trans-unit id="33b92276543ebbb381ab00cfcca61326250e018b" translate="yes" xml:space="preserve">
          <source>Box::partial_cmp</source>
          <target state="translated">Box::partial_cmp</target>
        </trans-unit>
        <trans-unit id="5b3f3a9486d3aeafde57fba826b8530482d99578" translate="yes" xml:space="preserve">
          <source>Box::partition</source>
          <target state="translated">Box::partition</target>
        </trans-unit>
        <trans-unit id="25aab183ce8da5ce9aed71f8d43b59e269353ccd" translate="yes" xml:space="preserve">
          <source>Box::peekable</source>
          <target state="translated">Box::peekable</target>
        </trans-unit>
        <trans-unit id="7019628ce869ea317ecd4415266260c422269408" translate="yes" xml:space="preserve">
          <source>Box::pin</source>
          <target state="translated">Box::pin</target>
        </trans-unit>
        <trans-unit id="a64f04fc6eed8dea5f38347397b9cc737e345f6e" translate="yes" xml:space="preserve">
          <source>Box::poll</source>
          <target state="translated">Box::poll</target>
        </trans-unit>
        <trans-unit id="66f2f092e4949c0626ea7b22dc1d4ebcf3d8b35e" translate="yes" xml:space="preserve">
          <source>Box::position</source>
          <target state="translated">Box::position</target>
        </trans-unit>
        <trans-unit id="57081d934e6bca1d6c19e21b481ef88439c1ee29" translate="yes" xml:space="preserve">
          <source>Box::product</source>
          <target state="translated">Box::product</target>
        </trans-unit>
        <trans-unit id="ea6a41b1734b82596faa66a349b6d33c1eda5c8d" translate="yes" xml:space="preserve">
          <source>Box::read</source>
          <target state="translated">Box::read</target>
        </trans-unit>
        <trans-unit id="69cd72a2d8a6222800a925198c4edf4f739e25b2" translate="yes" xml:space="preserve">
          <source>Box::read_exact</source>
          <target state="translated">Box::read_exact</target>
        </trans-unit>
        <trans-unit id="59c4bf761ac478484370f960e729c2e181694f6b" translate="yes" xml:space="preserve">
          <source>Box::read_line</source>
          <target state="translated">Box::read_line</target>
        </trans-unit>
        <trans-unit id="225ac79c4a0e4ea7979de019038d83deebd58806" translate="yes" xml:space="preserve">
          <source>Box::read_to_end</source>
          <target state="translated">Box::read_to_end</target>
        </trans-unit>
        <trans-unit id="205cd1994c8e50578c7806614a239f1080cfe645" translate="yes" xml:space="preserve">
          <source>Box::read_to_string</source>
          <target state="translated">Box::read_to_string</target>
        </trans-unit>
        <trans-unit id="4c38943094e12187cb5a7db1759bb984e9e47e21" translate="yes" xml:space="preserve">
          <source>Box::read_until</source>
          <target state="translated">Box::read_until</target>
        </trans-unit>
        <trans-unit id="16e2f9a63976d963a9dadcb35033a821c2fd7839" translate="yes" xml:space="preserve">
          <source>Box::read_vectored</source>
          <target state="translated">Box::read_vectored</target>
        </trans-unit>
        <trans-unit id="be7cce92911dcff76ffbac8e0427e42b77defdcf" translate="yes" xml:space="preserve">
          <source>Box::resume</source>
          <target state="translated">Box::resume</target>
        </trans-unit>
        <trans-unit id="ba5e0dd2c587258859a5333578ab5d32da0e967a" translate="yes" xml:space="preserve">
          <source>Box::rev</source>
          <target state="translated">Box::rev</target>
        </trans-unit>
        <trans-unit id="481e8d3053595c86bd37ed7ee98159dd62804d15" translate="yes" xml:space="preserve">
          <source>Box::rfind</source>
          <target state="translated">Box::rfind</target>
        </trans-unit>
        <trans-unit id="54e7ee564e103a781122b5dcc4e5a645a42b47bd" translate="yes" xml:space="preserve">
          <source>Box::rfold</source>
          <target state="translated">Box::rfold</target>
        </trans-unit>
        <trans-unit id="3a8d8f3503f8d9c26ee23ddbea5e59c9d42ec95c" translate="yes" xml:space="preserve">
          <source>Box::rposition</source>
          <target state="translated">Box::rposition</target>
        </trans-unit>
        <trans-unit id="9ac7a2e2ffe1a294d38f090349bc38f76aec74fc" translate="yes" xml:space="preserve">
          <source>Box::scan</source>
          <target state="translated">Box::scan</target>
        </trans-unit>
        <trans-unit id="96b0a5023a90b5ef63be3a93fee81259968341fc" translate="yes" xml:space="preserve">
          <source>Box::seek</source>
          <target state="translated">Box::seek</target>
        </trans-unit>
        <trans-unit id="74f4a9a8cd31d8cee51b7c80648f8274c91f190c" translate="yes" xml:space="preserve">
          <source>Box::size_hint</source>
          <target state="translated">Box::size_hint</target>
        </trans-unit>
        <trans-unit id="d72a34eac3284a3b3a67c2581cf2c305c16367ed" translate="yes" xml:space="preserve">
          <source>Box::skip</source>
          <target state="translated">Box::skip</target>
        </trans-unit>
        <trans-unit id="ba0e0743f07d0bf5ee26ccb3b8bb456ca5c70a56" translate="yes" xml:space="preserve">
          <source>Box::skip_while</source>
          <target state="translated">Box::skip_while</target>
        </trans-unit>
        <trans-unit id="b4722d8b75a76a5d774eca59914b8e1f4a48cca6" translate="yes" xml:space="preserve">
          <source>Box::source</source>
          <target state="translated">Box::source</target>
        </trans-unit>
        <trans-unit id="6e2bc46519fb279c9f87dbfe9d290154772983d7" translate="yes" xml:space="preserve">
          <source>Box::split</source>
          <target state="translated">Box::split</target>
        </trans-unit>
        <trans-unit id="225ff95675533f61ead8e887a7efbf592dd8a88f" translate="yes" xml:space="preserve">
          <source>Box::step_by</source>
          <target state="translated">Box::step_by</target>
        </trans-unit>
        <trans-unit id="33aa1522a0173cb9f96a98672c2ecf9a96e294c9" translate="yes" xml:space="preserve">
          <source>Box::stream_len</source>
          <target state="translated">Box::stream_len</target>
        </trans-unit>
        <trans-unit id="8371eaea74f952c9831c9ca9261a497c2c38eef9" translate="yes" xml:space="preserve">
          <source>Box::stream_position</source>
          <target state="translated">Box::stream_position</target>
        </trans-unit>
        <trans-unit id="6a478949bfaddf9def7439c2f20d3359d537230c" translate="yes" xml:space="preserve">
          <source>Box::sum</source>
          <target state="translated">Box::sum</target>
        </trans-unit>
        <trans-unit id="3c2abaa93fcb6bfd17a1261c06f7ff566f12ec7e" translate="yes" xml:space="preserve">
          <source>Box::take</source>
          <target state="translated">Box::take</target>
        </trans-unit>
        <trans-unit id="83963a222e9c0ad7e60f41957e4013159d79d919" translate="yes" xml:space="preserve">
          <source>Box::take_while</source>
          <target state="translated">Box::take_while</target>
        </trans-unit>
        <trans-unit id="97ebc881815c3d1efcf8d9cc64f80490df826bb5" translate="yes" xml:space="preserve">
          <source>Box::to_owned</source>
          <target state="translated">Box::to_owned</target>
        </trans-unit>
        <trans-unit id="e508f4dc0d39c5987210d26aebaa3c2b4fce966c" translate="yes" xml:space="preserve">
          <source>Box::to_string</source>
          <target state="translated">Box::to_string</target>
        </trans-unit>
        <trans-unit id="34d3b2ca86670782e3636c41900e981e1db73054" translate="yes" xml:space="preserve">
          <source>Box::try_fold</source>
          <target state="translated">Box::try_fold</target>
        </trans-unit>
        <trans-unit id="4db298c22768eb776696c78cedb8c0ae9382c043" translate="yes" xml:space="preserve">
          <source>Box::try_for_each</source>
          <target state="translated">Box::try_for_each</target>
        </trans-unit>
        <trans-unit id="7ac87b84f99e12af4f84963a001dac862d957033" translate="yes" xml:space="preserve">
          <source>Box::try_from</source>
          <target state="translated">Box::try_from</target>
        </trans-unit>
        <trans-unit id="1190ad3065eb03769687c99bebeafccd52070617" translate="yes" xml:space="preserve">
          <source>Box::try_into</source>
          <target state="translated">Box::try_into</target>
        </trans-unit>
        <trans-unit id="190b967a40f310701525c6f92772eaa4b9d2bd91" translate="yes" xml:space="preserve">
          <source>Box::try_rfold</source>
          <target state="translated">Box::try_rfold</target>
        </trans-unit>
        <trans-unit id="e36c00466fad6adf381b361fedd323c0c0614989" translate="yes" xml:space="preserve">
          <source>Box::type_id</source>
          <target state="translated">Box::type_id</target>
        </trans-unit>
        <trans-unit id="04ea83b7ee01a03b421cd55b0df6992834e06afd" translate="yes" xml:space="preserve">
          <source>Box::unzip</source>
          <target state="translated">Box::unzip</target>
        </trans-unit>
        <trans-unit id="f72865295b955292507dfb70d5c51051dce354f9" translate="yes" xml:space="preserve">
          <source>Box::write</source>
          <target state="translated">Box::write</target>
        </trans-unit>
        <trans-unit id="a94c15e5cef594b7628ec618df5db798a9a567ec" translate="yes" xml:space="preserve">
          <source>Box::write_all</source>
          <target state="translated">Box::write_all</target>
        </trans-unit>
        <trans-unit id="d6fe1ce7bcfe4c269caf62f37074c2cd561a9897" translate="yes" xml:space="preserve">
          <source>Box::write_fmt</source>
          <target state="translated">Box::write_fmt</target>
        </trans-unit>
        <trans-unit id="56912c1495209bdea8854c66cc01bcdf4719afb0" translate="yes" xml:space="preserve">
          <source>Box::write_i128</source>
          <target state="translated">Box::write_i128</target>
        </trans-unit>
        <trans-unit id="d8e0c426cff723fe078d8e082d1a63933f6fa573" translate="yes" xml:space="preserve">
          <source>Box::write_i16</source>
          <target state="translated">Box::write_i16</target>
        </trans-unit>
        <trans-unit id="b68b48a66507e48ff6196e7556e4456e2d325cec" translate="yes" xml:space="preserve">
          <source>Box::write_i32</source>
          <target state="translated">Box::write_i32</target>
        </trans-unit>
        <trans-unit id="1e11f9892c3582d233d19c49b718f4eb56d5716f" translate="yes" xml:space="preserve">
          <source>Box::write_i64</source>
          <target state="translated">Box::write_i64</target>
        </trans-unit>
        <trans-unit id="2c4fbd1565526cebde3d781e65ee574490c3d5c4" translate="yes" xml:space="preserve">
          <source>Box::write_i8</source>
          <target state="translated">Box::write_i8</target>
        </trans-unit>
        <trans-unit id="be62022bb4b9817d94a1db6940ba1ef163a6bd39" translate="yes" xml:space="preserve">
          <source>Box::write_isize</source>
          <target state="translated">Box::write_isize</target>
        </trans-unit>
        <trans-unit id="2096d69d1a029ab28f266f5d6155819f93d05482" translate="yes" xml:space="preserve">
          <source>Box::write_u128</source>
          <target state="translated">Box::write_u128</target>
        </trans-unit>
        <trans-unit id="4bae89c6a373e3f8634ed54d131ceda19618fee5" translate="yes" xml:space="preserve">
          <source>Box::write_u16</source>
          <target state="translated">Box::write_u16</target>
        </trans-unit>
        <trans-unit id="71e4bac27351110d97b5fef0556d35917fbefb90" translate="yes" xml:space="preserve">
          <source>Box::write_u32</source>
          <target state="translated">Box::write_u32</target>
        </trans-unit>
        <trans-unit id="5abd678e805a3ff64f5524701426655948efcbfa" translate="yes" xml:space="preserve">
          <source>Box::write_u64</source>
          <target state="translated">Box::write_u64</target>
        </trans-unit>
        <trans-unit id="cf853a1d87ba811daf4dddf980c6bca3ee9f7551" translate="yes" xml:space="preserve">
          <source>Box::write_u8</source>
          <target state="translated">Box::write_u8</target>
        </trans-unit>
        <trans-unit id="570c96fc9a4d7852a96d0f8be3123d2af8641252" translate="yes" xml:space="preserve">
          <source>Box::write_usize</source>
          <target state="translated">Box::write_usize</target>
        </trans-unit>
        <trans-unit id="8c5f38686db9dd2e3d3338655cf9aa7453b4beec" translate="yes" xml:space="preserve">
          <source>Box::write_vectored</source>
          <target state="translated">Box::write_vectored</target>
        </trans-unit>
        <trans-unit id="58b9235154ec59648f9006bdb375b1a70414fdbc" translate="yes" xml:space="preserve">
          <source>Box::zip</source>
          <target state="translated">Box::zip</target>
        </trans-unit>
        <trans-unit id="1f1c95cf9dbdc5a10d4adddb4bd7ed9693d03299" translate="yes" xml:space="preserve">
          <source>Boxes don&amp;rsquo;t have performance overhead, other than storing their data on the heap instead of on the stack. But they don&amp;rsquo;t have many extra capabilities either. You&amp;rsquo;ll use them most often in these situations:</source>
          <target state="translated">除了将数据存储在堆而不是堆栈上之外，存储盒没有性能开销。但是它们也没有很多额外的功能。在以下情况下，您将最常使用它们：</target>
        </trans-unit>
        <trans-unit id="aae55045560cd96320cd77d712fdc24ac8ab83dc" translate="yes" xml:space="preserve">
          <source>Boxes provide only the indirection and heap allocation; they don&amp;rsquo;t have any other special capabilities, like those we&amp;rsquo;ll see with the other smart pointer types. They also don&amp;rsquo;t have any performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need. We&amp;rsquo;ll look at more use cases for boxes in Chapter 17, too.</source>
          <target state="translated">框仅提供间接和堆分配；它们没有任何其他特殊功能，就像我们将在其他智能指针类型中看到的那样。它们也没有这些特殊功能带来的任何性能开销，因此它们在诸如cons列表之类的情况下非常有用，在这些情况下，间接访问是我们唯一需要的功能。我们还将在第17章中讨论盒子的更多用例。</target>
        </trans-unit>
        <trans-unit id="e42a1e70b4003a66462fd8b1b6f1d551425eedd6" translate="yes" xml:space="preserve">
          <source>Bracket</source>
          <target state="translated">Bracket</target>
        </trans-unit>
        <trans-unit id="acb83a12e9c51df23e23f19306bba0bcb0739442" translate="yes" xml:space="preserve">
          <source>Bracket punctuation is used in various parts of the grammar. An open bracket must always be paired with a close bracket. Brackets and the tokens within them are referred to as &quot;token trees&quot; in &lt;a href=&quot;macros-by-example&quot;&gt;macros&lt;/a&gt;. The three types of brackets are:</source>
          <target state="translated">括号的标点符号用于语法的各个部分。左方括号必须始终与右方括号配对。括号和其中的令牌在&lt;a href=&quot;macros-by-example&quot;&gt;宏中&lt;/a&gt;称为&amp;ldquo;令牌树&amp;rdquo; 。括号的三种类型是：</target>
        </trans-unit>
        <trans-unit id="4a3ba41cdc1bb875b6f34a0f7504f134b4c82482" translate="yes" xml:space="preserve">
          <source>Breaking cycles with &lt;code&gt;Weak&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="d3dfd81f5eef2bda69d2fe0e0bb117502ea1d295" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt; on accesses through raw pointers; a subset of the rules used by C.</source>
          <target state="translated">打破&lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;指针重叠规则&lt;/a&gt;通过原始指针访问; C使用的规则的子集。</target>
        </trans-unit>
        <trans-unit id="f28978f6dd2c2e9099f5d850ca4e0176d065b5c7" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt;. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;T&lt;/code&gt; follow LLVM&amp;rsquo;s scoped &lt;a href=&quot;http://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt; model, except if the &lt;code&gt;&amp;amp;T&lt;/code&gt; contains an &lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打破&lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;指针别名规则&lt;/a&gt;。 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;T&lt;/code&gt; 遵循LLVM的范围化&lt;a href=&quot;http://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt;模型，除非 &lt;code&gt;&amp;amp;T&lt;/code&gt; 包含&lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d59f171a0fa025c3f69ece6ee2db2dff781f37b" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;https://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt;. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;T&lt;/code&gt; follow LLVM&amp;rsquo;s scoped &lt;a href=&quot;https://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt; model, except if the &lt;code&gt;&amp;amp;T&lt;/code&gt; contains an &lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打破&lt;a href=&quot;https://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;指针别名规则&lt;/a&gt;。 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;T&lt;/code&gt; 遵循LLVM的范围化&lt;a href=&quot;https://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt;模型，除非 &lt;code&gt;&amp;amp;T&lt;/code&gt; 包含&lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a02e7efbe4ea860996a720e8eb0268c763977ce" translate="yes" xml:space="preserve">
          <source>Bringing Paths into Scope with the &lt;code id=&quot;bringing-paths-into-scope-with-the-use-keyword&quot;&gt;use&lt;/code&gt; Keyword</source>
          <target state="translated">&lt;code id=&quot;bringing-paths-into-scope-with-the-use-keyword&quot;&gt;use&lt;/code&gt; 关键字将路径带入范围</target>
        </trans-unit>
        <trans-unit id="de407e52f1ad71f30175ca74f0b3e4d7802969ce" translate="yes" xml:space="preserve">
          <source>BufRead</source>
          <target state="translated">BufRead</target>
        </trans-unit>
        <trans-unit id="8b3cd1796576fb8d47f83bdc75d05d245fd7a0c8" translate="yes" xml:space="preserve">
          <source>BufRead::consume</source>
          <target state="translated">BufRead::consume</target>
        </trans-unit>
        <trans-unit id="4d60e62622ce6e5b2975982fde7166d4b99157d4" translate="yes" xml:space="preserve">
          <source>BufRead::fill_buf</source>
          <target state="translated">BufRead::fill_buf</target>
        </trans-unit>
        <trans-unit id="6454a42afc6b7f969ba1e20a170de8e3b928a4de" translate="yes" xml:space="preserve">
          <source>BufRead::lines</source>
          <target state="translated">BufRead::lines</target>
        </trans-unit>
        <trans-unit id="a22b5e33039f43dd9be253a22ba693c7821fc40d" translate="yes" xml:space="preserve">
          <source>BufRead::read_line</source>
          <target state="translated">BufRead::read_line</target>
        </trans-unit>
        <trans-unit id="138f0ef5dd5df09e1375e2687113f694b0a114b9" translate="yes" xml:space="preserve">
          <source>BufRead::read_until</source>
          <target state="translated">BufRead::read_until</target>
        </trans-unit>
        <trans-unit id="afb4634d5bb2cfba4eca69e0cbaed77038a91269" translate="yes" xml:space="preserve">
          <source>BufRead::split</source>
          <target state="translated">BufRead::split</target>
        </trans-unit>
        <trans-unit id="232d94f57b3293280b5ad36975b73111f3c6dfa0" translate="yes" xml:space="preserve">
          <source>BufReader</source>
          <target state="translated">BufReader</target>
        </trans-unit>
        <trans-unit id="cb39e958e39ef179b2597f4ef6e19c98ca4fc4d5" translate="yes" xml:space="preserve">
          <source>BufReader and BufWriter</source>
          <target state="translated">BufReader和BufWriter</target>
        </trans-unit>
        <trans-unit id="30498daca312f601d5026a239b4f9877ca9ee7af" translate="yes" xml:space="preserve">
          <source>BufReader::borrow</source>
          <target state="translated">BufReader::borrow</target>
        </trans-unit>
        <trans-unit id="46b667a41b30eb52818f00950425d6b07af15300" translate="yes" xml:space="preserve">
          <source>BufReader::borrow_mut</source>
          <target state="translated">BufReader::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6abdb3c76752714b4a06017a9219fa1f25214580" translate="yes" xml:space="preserve">
          <source>BufReader::buffer</source>
          <target state="translated">BufReader::buffer</target>
        </trans-unit>
        <trans-unit id="8a5b395c3f2044900bdcdf2f9ebf60ebd12d7819" translate="yes" xml:space="preserve">
          <source>BufReader::by_ref</source>
          <target state="translated">BufReader::by_ref</target>
        </trans-unit>
        <trans-unit id="6e8f568e8d439bbf991a8a007e038953a8f83b25" translate="yes" xml:space="preserve">
          <source>BufReader::bytes</source>
          <target state="translated">BufReader::bytes</target>
        </trans-unit>
        <trans-unit id="111bdc9e9c0fa8f11edaf0bb19720dadd4d441c2" translate="yes" xml:space="preserve">
          <source>BufReader::chain</source>
          <target state="translated">BufReader::chain</target>
        </trans-unit>
        <trans-unit id="698d6344bd09525535c43a69fdbd270c56fe0314" translate="yes" xml:space="preserve">
          <source>BufReader::consume</source>
          <target state="translated">BufReader::consume</target>
        </trans-unit>
        <trans-unit id="d753e03e42fea9b39b03754697893d50f45f25ac" translate="yes" xml:space="preserve">
          <source>BufReader::fill_buf</source>
          <target state="translated">BufReader::fill_buf</target>
        </trans-unit>
        <trans-unit id="4002c8a4271852b7c3dc4a005ad07b6218b6d9be" translate="yes" xml:space="preserve">
          <source>BufReader::fmt</source>
          <target state="translated">BufReader::fmt</target>
        </trans-unit>
        <trans-unit id="588a32e3d887d2adc2a42cbd852909e916738169" translate="yes" xml:space="preserve">
          <source>BufReader::from</source>
          <target state="translated">BufReader::from</target>
        </trans-unit>
        <trans-unit id="a565473360a69fedb15e98a54613f95fb3b56dfd" translate="yes" xml:space="preserve">
          <source>BufReader::get_mut</source>
          <target state="translated">BufReader::get_mut</target>
        </trans-unit>
        <trans-unit id="5594c6c6ae64375a5d272ff27f83db1d85077211" translate="yes" xml:space="preserve">
          <source>BufReader::get_ref</source>
          <target state="translated">BufReader::get_ref</target>
        </trans-unit>
        <trans-unit id="1e90aba1df228b628f7c7f3e2ab8e5bae2aa2919" translate="yes" xml:space="preserve">
          <source>BufReader::initializer</source>
          <target state="translated">BufReader::initializer</target>
        </trans-unit>
        <trans-unit id="9dfefe7d50b25c323182190a7738d15409036741" translate="yes" xml:space="preserve">
          <source>BufReader::into</source>
          <target state="translated">BufReader::into</target>
        </trans-unit>
        <trans-unit id="7af433e3bd4af270fc73a60a513c7c29c50b1691" translate="yes" xml:space="preserve">
          <source>BufReader::into_inner</source>
          <target state="translated">BufReader::into_inner</target>
        </trans-unit>
        <trans-unit id="015fca5819c404e186e79049e56378d531c3a868" translate="yes" xml:space="preserve">
          <source>BufReader::lines</source>
          <target state="translated">BufReader::lines</target>
        </trans-unit>
        <trans-unit id="261dc9dd5d56c7bd6b24e8c4987e0bacc36d731b" translate="yes" xml:space="preserve">
          <source>BufReader::new</source>
          <target state="translated">BufReader::new</target>
        </trans-unit>
        <trans-unit id="474a9aceabea88ca192dfa1182137bb4a5716f95" translate="yes" xml:space="preserve">
          <source>BufReader::read</source>
          <target state="translated">BufReader::read</target>
        </trans-unit>
        <trans-unit id="8fb011a69fd96b7a252fae27bab3618d9916ea15" translate="yes" xml:space="preserve">
          <source>BufReader::read_exact</source>
          <target state="translated">BufReader::read_exact</target>
        </trans-unit>
        <trans-unit id="043d1ca9b3f16093053e017427e6b59fce891b84" translate="yes" xml:space="preserve">
          <source>BufReader::read_line</source>
          <target state="translated">BufReader::read_line</target>
        </trans-unit>
        <trans-unit id="0cf3db2b85b3a36c4fe27bb356f920ec381e6a39" translate="yes" xml:space="preserve">
          <source>BufReader::read_to_end</source>
          <target state="translated">BufReader::read_to_end</target>
        </trans-unit>
        <trans-unit id="c014e4bd71ac8b1202507174a0590c77d72041f7" translate="yes" xml:space="preserve">
          <source>BufReader::read_to_string</source>
          <target state="translated">BufReader::read_to_string</target>
        </trans-unit>
        <trans-unit id="bf7f4de24e9cecff5fc9e9886289abdb93482e12" translate="yes" xml:space="preserve">
          <source>BufReader::read_until</source>
          <target state="translated">BufReader::read_until</target>
        </trans-unit>
        <trans-unit id="f1ac9fb503b6a30e103494d5ed7e213639e7e66d" translate="yes" xml:space="preserve">
          <source>BufReader::read_vectored</source>
          <target state="translated">BufReader::read_vectored</target>
        </trans-unit>
        <trans-unit id="b8518cd0ac9ab115738a223331f69d244e196ae1" translate="yes" xml:space="preserve">
          <source>BufReader::seek</source>
          <target state="translated">BufReader::seek</target>
        </trans-unit>
        <trans-unit id="99a5d03be61779b43803bbfee3dbfdce8a113d6d" translate="yes" xml:space="preserve">
          <source>BufReader::seek_relative</source>
          <target state="translated">BufReader::seek_relative</target>
        </trans-unit>
        <trans-unit id="43d93e963620260620093d161241006ece71cae8" translate="yes" xml:space="preserve">
          <source>BufReader::split</source>
          <target state="translated">BufReader::split</target>
        </trans-unit>
        <trans-unit id="e0ac1010e5c4fb0756b34d4592bffff3a410e86d" translate="yes" xml:space="preserve">
          <source>BufReader::stream_len</source>
          <target state="translated">BufReader::stream_len</target>
        </trans-unit>
        <trans-unit id="ca5bf56485cb95f3a60dbe8260139b54147feee2" translate="yes" xml:space="preserve">
          <source>BufReader::stream_position</source>
          <target state="translated">BufReader::stream_position</target>
        </trans-unit>
        <trans-unit id="70fc9c931ae2fc7872314fb275a9549018b33695" translate="yes" xml:space="preserve">
          <source>BufReader::take</source>
          <target state="translated">BufReader::take</target>
        </trans-unit>
        <trans-unit id="4d06dc939cd79e29aeb98db83609f9129bc27937" translate="yes" xml:space="preserve">
          <source>BufReader::try_from</source>
          <target state="translated">BufReader::try_from</target>
        </trans-unit>
        <trans-unit id="9cf0b40fa99c93bde7e68af3011e8e90b8e27ca1" translate="yes" xml:space="preserve">
          <source>BufReader::try_into</source>
          <target state="translated">BufReader::try_into</target>
        </trans-unit>
        <trans-unit id="c0358cb609681901098856ec216b94cf80a87fed" translate="yes" xml:space="preserve">
          <source>BufReader::type_id</source>
          <target state="translated">BufReader::type_id</target>
        </trans-unit>
        <trans-unit id="76a07371464a5bc5c675c8a1103f1bfcdcb90928" translate="yes" xml:space="preserve">
          <source>BufReader::with_capacity</source>
          <target state="translated">BufReader::with_capacity</target>
        </trans-unit>
        <trans-unit id="eb547b03e4fb9da19636fe86aa475ec275f26aea" translate="yes" xml:space="preserve">
          <source>BufWriter</source>
          <target state="translated">BufWriter</target>
        </trans-unit>
        <trans-unit id="c0fe0ec21d292209b8751b7b3bbc325ff8c3dfdd" translate="yes" xml:space="preserve">
          <source>BufWriter::borrow</source>
          <target state="translated">BufWriter::borrow</target>
        </trans-unit>
        <trans-unit id="2adb49e625ca6186b4c41c7d1737d0e2634f05fb" translate="yes" xml:space="preserve">
          <source>BufWriter::borrow_mut</source>
          <target state="translated">BufWriter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3ac09907f785459d01129cbdf9eb5797fc53c72" translate="yes" xml:space="preserve">
          <source>BufWriter::buffer</source>
          <target state="translated">BufWriter::buffer</target>
        </trans-unit>
        <trans-unit id="a82155a82c33131bd98d9e864c9f25f36481894a" translate="yes" xml:space="preserve">
          <source>BufWriter::by_ref</source>
          <target state="translated">BufWriter::by_ref</target>
        </trans-unit>
        <trans-unit id="31f24b83e544c2b05b1fbfd0a2b99edbc784d128" translate="yes" xml:space="preserve">
          <source>BufWriter::drop</source>
          <target state="translated">BufWriter::drop</target>
        </trans-unit>
        <trans-unit id="70ed6813c46c4821d4c3ceb922ec9e68c5b46a68" translate="yes" xml:space="preserve">
          <source>BufWriter::flush</source>
          <target state="translated">BufWriter::flush</target>
        </trans-unit>
        <trans-unit id="e322ea4bb3c530e22344a65d6d425dbe30797f57" translate="yes" xml:space="preserve">
          <source>BufWriter::fmt</source>
          <target state="translated">BufWriter::fmt</target>
        </trans-unit>
        <trans-unit id="ae28528b6704424a2fa6c25aacbe28d13e5e2328" translate="yes" xml:space="preserve">
          <source>BufWriter::from</source>
          <target state="translated">BufWriter::from</target>
        </trans-unit>
        <trans-unit id="8f2da80a85c436ae0e170c960857685d65f2c7fa" translate="yes" xml:space="preserve">
          <source>BufWriter::get_mut</source>
          <target state="translated">BufWriter::get_mut</target>
        </trans-unit>
        <trans-unit id="ae8ffbf65314cc80e578ef8e21fd9216b111a598" translate="yes" xml:space="preserve">
          <source>BufWriter::get_ref</source>
          <target state="translated">BufWriter::get_ref</target>
        </trans-unit>
        <trans-unit id="c2bb0d2480650e2a139a3ac97642b7fac7000daf" translate="yes" xml:space="preserve">
          <source>BufWriter::into</source>
          <target state="translated">BufWriter::into</target>
        </trans-unit>
        <trans-unit id="a254cafb67eb39c14e0dd9b99733426aaca0cce1" translate="yes" xml:space="preserve">
          <source>BufWriter::into_inner</source>
          <target state="translated">BufWriter::into_inner</target>
        </trans-unit>
        <trans-unit id="0d50fa17068770487074b33532e6632cdc747a7d" translate="yes" xml:space="preserve">
          <source>BufWriter::new</source>
          <target state="translated">BufWriter::new</target>
        </trans-unit>
        <trans-unit id="8acb320f731050f7faa230a67adf20edf2a91802" translate="yes" xml:space="preserve">
          <source>BufWriter::seek</source>
          <target state="translated">BufWriter::seek</target>
        </trans-unit>
        <trans-unit id="0bc901a9b97e04338c295bff32fc59abb34658a0" translate="yes" xml:space="preserve">
          <source>BufWriter::stream_len</source>
          <target state="translated">BufWriter::stream_len</target>
        </trans-unit>
        <trans-unit id="aef24c4f9e117e8540e0bceb74c3c1079dca3c4a" translate="yes" xml:space="preserve">
          <source>BufWriter::stream_position</source>
          <target state="translated">BufWriter::stream_position</target>
        </trans-unit>
        <trans-unit id="c3a46f518f714d6be6bad831bd9935498f844ddb" translate="yes" xml:space="preserve">
          <source>BufWriter::try_from</source>
          <target state="translated">BufWriter::try_from</target>
        </trans-unit>
        <trans-unit id="d12f6fca054766123bb42142de217202212ff449" translate="yes" xml:space="preserve">
          <source>BufWriter::try_into</source>
          <target state="translated">BufWriter::try_into</target>
        </trans-unit>
        <trans-unit id="8af6d7318c0dbf54915f72f0993742b25781c289" translate="yes" xml:space="preserve">
          <source>BufWriter::type_id</source>
          <target state="translated">BufWriter::type_id</target>
        </trans-unit>
        <trans-unit id="7f3e3e6e70dd67251f7be13ef8952baade49da92" translate="yes" xml:space="preserve">
          <source>BufWriter::with_capacity</source>
          <target state="translated">BufWriter::with_capacity</target>
        </trans-unit>
        <trans-unit id="04509abb12d543e33b20e9a92d6a3a9ce8f7becf" translate="yes" xml:space="preserve">
          <source>BufWriter::write</source>
          <target state="translated">BufWriter::write</target>
        </trans-unit>
        <trans-unit id="7904c0be7d3caaf53c1b1cdb84256218cdaa0206" translate="yes" xml:space="preserve">
          <source>BufWriter::write_all</source>
          <target state="translated">BufWriter::write_all</target>
        </trans-unit>
        <trans-unit id="1656f0c433aa13f34246f1c4269f0f93dd7be7a2" translate="yes" xml:space="preserve">
          <source>BufWriter::write_fmt</source>
          <target state="translated">BufWriter::write_fmt</target>
        </trans-unit>
        <trans-unit id="34b5f10d3b6a9f9a1dbde260a02e2b2206afca57" translate="yes" xml:space="preserve">
          <source>BufWriter::write_vectored</source>
          <target state="translated">BufWriter::write_vectored</target>
        </trans-unit>
        <trans-unit id="930e02964f6bea5730ba5c65d98e4f502a26535a" translate="yes" xml:space="preserve">
          <source>Buffering behavior:</source>
          <target state="translated">缓冲行为。</target>
        </trans-unit>
        <trans-unit id="c236b467cd75457e8973d308434bf8606946e8b7" translate="yes" xml:space="preserve">
          <source>Bugs that happen only in certain situations and are hard to reproduce and fix reliably</source>
          <target state="translated">只有在某些情况下才会发生的错误,并且难以可靠地重现和修复。</target>
        </trans-unit>
        <trans-unit id="c123195418c1603314c7d0aac5cbca5fe90623f5" translate="yes" xml:space="preserve">
          <source>Build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired stack size to &lt;a href=&quot;struct.builder#method.stack_size&quot;&gt;&lt;code&gt;Builder::stack_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt;构建线程，然后将所需的堆栈大小传递给&lt;a href=&quot;struct.builder#method.stack_size&quot;&gt; &lt;code&gt;Builder::stack_size&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97ac06ac37241fed7f3a8298db93e9bbc2d242b6" translate="yes" xml:space="preserve">
          <source>BuildHasher</source>
          <target state="translated">BuildHasher</target>
        </trans-unit>
        <trans-unit id="aaba5ed0cc289313d5a04c86f6c4f1a124a0ff97" translate="yes" xml:space="preserve">
          <source>BuildHasher::build_hasher</source>
          <target state="translated">BuildHasher::build_hasher</target>
        </trans-unit>
        <trans-unit id="6972ec88ec81efc886ecfcc5774a514315adaba3" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault</source>
          <target state="translated">BuildHasherDefault</target>
        </trans-unit>
        <trans-unit id="3b3934e3550748f2a7b58e6593d8d16993a3f234" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::borrow</source>
          <target state="translated">BuildHasherDefault::borrow</target>
        </trans-unit>
        <trans-unit id="f55eee0b0d59698190e3d541df7887945783f03c" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::borrow_mut</source>
          <target state="translated">BuildHasherDefault::borrow_mut</target>
        </trans-unit>
        <trans-unit id="9a17d9b6eba5bdb1a3199b04f87f79fe486b4427" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::build_hasher</source>
          <target state="translated">BuildHasherDefault::build_hasher</target>
        </trans-unit>
        <trans-unit id="3378e7d2427ed05874269a577e08932c432618d4" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone</source>
          <target state="translated">BuildHasherDefault::clone</target>
        </trans-unit>
        <trans-unit id="010bd4789bebb3ef5a2996e2b1be4fdb5f283ea4" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone_from</source>
          <target state="translated">BuildHasherDefault::clone_from</target>
        </trans-unit>
        <trans-unit id="e746cdbc6b12a8b851323bb7c641b3af90edca43" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone_into</source>
          <target state="translated">BuildHasherDefault::clone_into</target>
        </trans-unit>
        <trans-unit id="52e1f05a4973d5628107a410168778a062f1bf48" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::default</source>
          <target state="translated">BuildHasherDefault::default</target>
        </trans-unit>
        <trans-unit id="805858a4f2f04c612c4359d30c11b771cbbf2670" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::eq</source>
          <target state="translated">BuildHasherDefault::eq</target>
        </trans-unit>
        <trans-unit id="a489341b69637e6985483361e2ba9bd4e930658e" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::fmt</source>
          <target state="translated">BuildHasherDefault::fmt</target>
        </trans-unit>
        <trans-unit id="7dc7ccadfebe0f90b3109993492f2510fdea1e97" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::from</source>
          <target state="translated">BuildHasherDefault::from</target>
        </trans-unit>
        <trans-unit id="b214b1f4540f86833e16b1674e570a06864bb810" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::into</source>
          <target state="translated">BuildHasherDefault::into</target>
        </trans-unit>
        <trans-unit id="3124ec3e2cb6d3f2d095ae07854f9d9f327708f0" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::ne</source>
          <target state="translated">BuildHasherDefault::ne</target>
        </trans-unit>
        <trans-unit id="3e47f2f0c29a4813a680f3068d5450f9f31a9f4d" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::to_owned</source>
          <target state="translated">BuildHasherDefault::to_owned</target>
        </trans-unit>
        <trans-unit id="36b39c1513469044cd761bd64a80f0c4a9902c0a" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::try_from</source>
          <target state="translated">BuildHasherDefault::try_from</target>
        </trans-unit>
        <trans-unit id="6b3bf2bc5c2ef00504b85f45d8356c19b7018273" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::try_into</source>
          <target state="translated">BuildHasherDefault::try_into</target>
        </trans-unit>
        <trans-unit id="c27d762f5384033048f5c3b6349a62aa6d74a8ff" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::type_id</source>
          <target state="translated">BuildHasherDefault::type_id</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="004d20f8006198411988eea17651cdf655cc4482" translate="yes" xml:space="preserve">
          <source>Builder methods are provided to change these defaults and otherwise configure the process.</source>
          <target state="translated">提供了生成器方法来改变这些默认值和配置流程。</target>
        </trans-unit>
        <trans-unit id="e817e9752d05edc9cdf54971d106867fe037888c" translate="yes" xml:space="preserve">
          <source>Builder::borrow</source>
          <target state="translated">Builder::borrow</target>
        </trans-unit>
        <trans-unit id="94bb1918ddf68bff15586c79a231491744cc5934" translate="yes" xml:space="preserve">
          <source>Builder::borrow_mut</source>
          <target state="translated">Builder::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f7d73832b38ead1d7c82f9bab9bcef56bfdd3661" translate="yes" xml:space="preserve">
          <source>Builder::fmt</source>
          <target state="translated">Builder::fmt</target>
        </trans-unit>
        <trans-unit id="e7b6a7ffdb6a96182506cdb6f845b1b5f8083113" translate="yes" xml:space="preserve">
          <source>Builder::from</source>
          <target state="translated">Builder::from</target>
        </trans-unit>
        <trans-unit id="c646de2596ac054c72581071ffd5afa499f6b38e" translate="yes" xml:space="preserve">
          <source>Builder::into</source>
          <target state="translated">Builder::into</target>
        </trans-unit>
        <trans-unit id="25158ae2faf4770ff3631697763e4f649748735c" translate="yes" xml:space="preserve">
          <source>Builder::name</source>
          <target state="translated">Builder::name</target>
        </trans-unit>
        <trans-unit id="a2fdc90cb0342f15602e461493244bbda8d11380" translate="yes" xml:space="preserve">
          <source>Builder::new</source>
          <target state="translated">Builder::new</target>
        </trans-unit>
        <trans-unit id="a5c0502ee99c0af55e1f1a9757c75ceb61f0e365" translate="yes" xml:space="preserve">
          <source>Builder::spawn</source>
          <target state="translated">Builder::spawn</target>
        </trans-unit>
        <trans-unit id="d28e4127e494164e81f16f028a028d507078db82" translate="yes" xml:space="preserve">
          <source>Builder::spawn_unchecked</source>
          <target state="translated">Builder::spawn_unchecked</target>
        </trans-unit>
        <trans-unit id="79550b63f469160e0886e9b4b6fb46be05f50a29" translate="yes" xml:space="preserve">
          <source>Builder::stack_size</source>
          <target state="translated">Builder::stack_size</target>
        </trans-unit>
        <trans-unit id="96b55ab18feea8a44f0d0d096d39f3af52a2e131" translate="yes" xml:space="preserve">
          <source>Builder::try_from</source>
          <target state="translated">Builder::try_from</target>
        </trans-unit>
        <trans-unit id="77877ce5fde9f3242e4b6af9ede23afdcb23f7db" translate="yes" xml:space="preserve">
          <source>Builder::try_into</source>
          <target state="translated">Builder::try_into</target>
        </trans-unit>
        <trans-unit id="6247790fc07eec46462f144d1ed4dedc1cb780eb" translate="yes" xml:space="preserve">
          <source>Builder::type_id</source>
          <target state="translated">Builder::type_id</target>
        </trans-unit>
        <trans-unit id="3bf882813c900c304e2632ba4dffda0948193670" translate="yes" xml:space="preserve">
          <source>Building a Single-Threaded Web Server</source>
          <target state="translated">构建单线程Web服务器</target>
        </trans-unit>
        <trans-unit id="253443e211e899460868732743aa41ea5e5f944a" translate="yes" xml:space="preserve">
          <source>Building and Running a Cargo Project</source>
          <target state="translated">建立和运行一个货运项目</target>
        </trans-unit>
        <trans-unit id="1916501f700c410fd7bea37cffb5b95a293dc381" translate="yes" xml:space="preserve">
          <source>Building for Release</source>
          <target state="translated">为发布而建设</target>
        </trans-unit>
        <trans-unit id="0ad2d2fb6e92d2b6c89500bfdd36e70bf53d31d2" translate="yes" xml:space="preserve">
          <source>Building the &lt;code id=&quot;building-the-threadpool-struct-using-compiler-driven-development&quot;&gt;ThreadPool&lt;/code&gt; Struct Using Compiler Driven Development</source>
          <target state="translated">使用编译器驱动的开发构建 &lt;code id=&quot;building-the-threadpool-struct-using-compiler-driven-development&quot;&gt;ThreadPool&lt;/code&gt; 结构</target>
        </trans-unit>
        <trans-unit id="20da59d3c16c7bbc43ecdc04a9ed654b4ef329d2" translate="yes" xml:space="preserve">
          <source>Built in &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;negation&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;arithmetic, logical&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean&lt;/a&gt; operators used on integer and floating point types, &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">内置用于整数和浮点类型 &lt;code&gt;bool&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; 的&lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;求反&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;算术，逻辑&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;比较&lt;/a&gt;或&lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;惰性布尔&lt;/a&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="89e36b16f75fb9635eac3a25e8d8d0058e587b9c" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;negation&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;arithmetic&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;logical&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean&lt;/a&gt; operators used on integer and floating point types, &lt;code&gt;bool&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">内置&lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;否定&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;算术&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;逻辑&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;比较&lt;/a&gt;或&lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;惰性布尔&lt;/a&gt;运算符，用于整数和浮点类型， &lt;code&gt;bool&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd0f66ac77e682a233d8ddb635dd00b67a90ab76" translate="yes" xml:space="preserve">
          <source>Built-in attributes</source>
          <target state="translated">内置属性</target>
        </trans-unit>
        <trans-unit id="1dac87263c85b5a8f82799db9805041e3360af6d" translate="yes" xml:space="preserve">
          <source>Built-in attributes index</source>
          <target state="translated">内置属性索引</target>
        </trans-unit>
        <trans-unit id="3b55724056edf0c168a344b916c46cc4f550e2f6" translate="yes" xml:space="preserve">
          <source>Built-in types are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types. User-defined types have limited capabilities.</source>
          <target state="translated">内建类型与语言紧密结合在一起,其方式是用户定义类型无法模仿的。用户定义类型的能力有限。</target>
        </trans-unit>
        <trans-unit id="6c6bb0e181beb9458279ac502a39fa01da91b8fe" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;drain_filter&lt;/code&gt; is easier to use. &lt;code&gt;drain_filter&lt;/code&gt; is also more efficient, because it can backshift the elements of the array in bulk.</source>
          <target state="translated">但是 &lt;code&gt;drain_filter&lt;/code&gt; 更易于使用。 &lt;code&gt;drain_filter&lt;/code&gt; 也更有效，因为它可以使数组的元素大量回移。</target>
        </trans-unit>
        <trans-unit id="ab56537680f4a94c82e8bdfe87270e033203a404" translate="yes" xml:space="preserve">
          <source>But Rust isn&amp;rsquo;t limited to low-level systems programming. It&amp;rsquo;s expressive and ergonomic enough to make CLI apps, web servers, and many other kinds of code quite pleasant to write &amp;mdash; you&amp;rsquo;ll find simple examples of both later in the book. Working with Rust allows you to build skills that transfer from one domain to another; you can learn Rust by writing a web app, then apply those same skills to target your Raspberry Pi.</source>
          <target state="translated">但是Rust不仅限于底层系统编程。它具有足够的表达力和人体工程学特性，使CLI应用程序，Web服务器和许多其他类型的代码编写起来非常令人愉悦-在本书后面的部分中，您将找到这两者的简单示例。使用Rust可以使您建立从一个领域转移到另一个领域的技能；您可以通过编写网络应用程序来学习Rust，然后将同样的技能应用于Raspberry Pi。</target>
        </trans-unit>
        <trans-unit id="c9bc5d1aa2362cf2e31f1ee01e7de1ef4e0a2d19" translate="yes" xml:space="preserve">
          <source>But again, the compiler gives us a helpful note:</source>
          <target state="translated">但是,编译器又给了我们一个有用的说明。</target>
        </trans-unit>
        <trans-unit id="b5737faee592fa19b426fe0f0898f071a967af3e" translate="yes" xml:space="preserve">
          <source>But are the two implementations truly equivalent? The intuitive assumption might be that the more low-level loop will be faster. Let&amp;rsquo;s talk about performance.</source>
          <target state="translated">但是，这两个实现真的等效吗？直观的假设可能是，更底层的循环会更快。让我们谈谈性能。</target>
        </trans-unit>
        <trans-unit id="d5233374bc70817ae86cada9a53675c9bf92e0c7" translate="yes" xml:space="preserve">
          <source>But be sure to remember that valid Unicode scalar values may be made up of more than 1 byte.</source>
          <target state="translated">但一定要记住,有效的Unicode标量值可能是由多个字节组成的。</target>
        </trans-unit>
        <trans-unit id="0f72ae39afec7a59586e27c05c7b3e5e6adecf93" translate="yes" xml:space="preserve">
          <source>But before we get started, we should mention one detail: the method we&amp;rsquo;ll use won&amp;rsquo;t be the best way to build a web server with Rust. A number of production-ready crates are available on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; that provide more complete web server and thread pool implementations than we&amp;rsquo;ll build.</source>
          <target state="translated">但是，在开始之前，我们应该提到一个细节：我们将使用的方法并不是用Rust构建Web服务器的最佳方法。&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;上有许多生产就绪的板条箱，这些板条箱提供了比我们要构建的更完整的Web服务器和线程池实现。</target>
        </trans-unit>
        <trans-unit id="2b053f01b33d2a55c1c75c2c507abf7135d9a246" translate="yes" xml:space="preserve">
          <source>But by default, Cargo will only look for versions greater than &lt;code&gt;0.3.0&lt;/code&gt; and less than &lt;code&gt;0.4.0&lt;/code&gt;. If the &lt;code&gt;rand&lt;/code&gt; crate has released two new versions, &lt;code&gt;0.3.15&lt;/code&gt; and &lt;code&gt;0.4.0&lt;/code&gt;, you would see the following if you ran &lt;code&gt;cargo update&lt;/code&gt;:</source>
          <target state="translated">但默认情况下，Cargo将仅查找大于 &lt;code&gt;0.3.0&lt;/code&gt; 且小于 &lt;code&gt;0.4.0&lt;/code&gt; 的版本。如果 &lt;code&gt;rand&lt;/code&gt; 箱子发布了两个新版本 &lt;code&gt;0.3.15&lt;/code&gt; 和 &lt;code&gt;0.4.0&lt;/code&gt; ，则在运行 &lt;code&gt;cargo update&lt;/code&gt; 会看到以下内容：</target>
        </trans-unit>
        <trans-unit id="041215ad4156f8d52d141c6b1d6e0db864c4a8a2" translate="yes" xml:space="preserve">
          <source>But by default, Cargo will only look for versions greater than &lt;code&gt;0.5.5&lt;/code&gt; and less than &lt;code&gt;0.6.0&lt;/code&gt;. If the &lt;code&gt;rand&lt;/code&gt; crate has released two new versions, &lt;code&gt;0.5.6&lt;/code&gt; and &lt;code&gt;0.6.0&lt;/code&gt;, you would see the following if you ran &lt;code&gt;cargo update&lt;/code&gt;:</source>
          <target state="translated">但默认情况下，Cargo将仅查找大于 &lt;code&gt;0.5.5&lt;/code&gt; 且小于 &lt;code&gt;0.6.0&lt;/code&gt; 的版本。如果 &lt;code&gt;rand&lt;/code&gt; 箱子发布了两个新版本 &lt;code&gt;0.5.6&lt;/code&gt; 和 &lt;code&gt;0.6.0&lt;/code&gt; ，则在运行 &lt;code&gt;cargo update&lt;/code&gt; 会看到以下内容：</target>
        </trans-unit>
        <trans-unit id="48958431e414a42071536586c915fe4c3022be36" translate="yes" xml:space="preserve">
          <source>But for now, let&amp;rsquo;s work around this problem using a handy trick. We can tell Rust explicitly that in this case we can take ownership of the value inside the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;; then, once we have ownership of the closure, we can call it. This involves defining a new trait &lt;code&gt;FnBox&lt;/code&gt; with the method &lt;code&gt;call_box&lt;/code&gt; that will use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in its signature, defining &lt;code&gt;FnBox&lt;/code&gt; for any type that implements &lt;code&gt;FnOnce()&lt;/code&gt;, changing our type alias to use the new trait, and changing &lt;code&gt;Worker&lt;/code&gt; to use the &lt;code&gt;call_box&lt;/code&gt; method. These changes are shown in Listing 20-21.</source>
          <target state="translated">但是现在，让我们使用方便的技巧来解决此问题。我们可以明确地告诉Rust，在这种情况下，我们可以使用 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 获取 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 内部值的所有权：Box &amp;lt;Self&amp;gt; ;然后，一旦我们拥有闭合的所有权，就可以调用它。这涉及使用将在其签名中使用 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 的方法 &lt;code&gt;call_box&lt;/code&gt; 定义新特征 &lt;code&gt;FnBox&lt;/code&gt; ，为实现 &lt;code&gt;FnOnce()&lt;/code&gt; 的任何类型定义 &lt;code&gt;FnBox&lt;/code&gt; ，更改类型别名以使用新特征，并更改 &lt;code&gt;Worker&lt;/code&gt; 以使用该 &lt;code&gt;call_box&lt;/code&gt; 方法。这些更改如清单20-21所示。</target>
        </trans-unit>
        <trans-unit id="0be702d32a09b655da72a7b7225dc839aaba10a3" translate="yes" xml:space="preserve">
          <source>But for the following two exceptions, this function is semantically equivalent to &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">但是对于以下两个例外，此函数在语义上等效于&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="470268269eb0c32844b8d1e2e02e3f2f66584bd8" translate="yes" xml:space="preserve">
          <source>But if we used the different structs, which each have their own type, we couldn&amp;rsquo;t as easily define a function to take any of these kinds of messages as we could with the &lt;code&gt;Message&lt;/code&gt; enum defined in Listing 6-2, which is a single type.</source>
          <target state="translated">但是，如果我们使用不同的结构，每个结构都有自己的类型，我们将无法像清单6-2中定义的 &lt;code&gt;Message&lt;/code&gt; 枚举那样轻松地定义一个函数来接收任何此类消息类型。</target>
        </trans-unit>
        <trans-unit id="79200d10e04d305f55f7036bcbaaafae7d4d999b" translate="yes" xml:space="preserve">
          <source>But if your closure has state, iterating backwards may act in a way you do not expect. Let's go through an example. First, in the forward direction:</source>
          <target state="translated">但如果你的闭包有状态,向后迭代可能会以一种你意想不到的方式进行。我们通过一个例子来说明。首先,在前进的方向上。</target>
        </trans-unit>
        <trans-unit id="42768b6451354f549c20c5936efbed0901a61a1c" translate="yes" xml:space="preserve">
          <source>But let&amp;rsquo;s see what happens when we instead move &lt;code&gt;handle.join()&lt;/code&gt; before the &lt;code&gt;for&lt;/code&gt; loop in &lt;code&gt;main&lt;/code&gt;, like this:</source>
          <target state="translated">但是让我们看看当我们在 &lt;code&gt;main&lt;/code&gt; 的 &lt;code&gt;for&lt;/code&gt; 循环之前移动 &lt;code&gt;handle.join()&lt;/code&gt; 时会发生什么：</target>
        </trans-unit>
        <trans-unit id="1fbf462a87fb38288cb0e833c1357211d81cfbfe" translate="yes" xml:space="preserve">
          <source>But mutability can be very useful. Variables are immutable only by default; as you did in Chapter 2, you can make them mutable by adding &lt;code&gt;mut&lt;/code&gt; in front of the variable name. In addition to allowing this value to change, &lt;code&gt;mut&lt;/code&gt; conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable value.</source>
          <target state="translated">但是可变性可能非常有用。变量仅在默认情况下是不可变的。就像在第2章中所做的那样，可以通过在变量名前面添加 &lt;code&gt;mut&lt;/code&gt; 使其可变。除了允许更改此值之外， &lt;code&gt;mut&lt;/code&gt; 还通过指示代码的其他部分将更改此变量值，将意图传达给将来的代码阅读者。</target>
        </trans-unit>
        <trans-unit id="e1df74418ef370eb96db59d017c1ab1ddf4aab63" translate="yes" xml:space="preserve">
          <source>But mutability can be very useful. Variables are immutable only by default; as you did in Chapter 2, you can make them mutable by adding &lt;code&gt;mut&lt;/code&gt; in front of the variable name. In addition to allowing this value to change, &lt;code&gt;mut&lt;/code&gt; conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable&amp;rsquo;s value.</source>
          <target state="translated">但是可变性可能非常有用。变量仅在默认情况下是不可变的。就像在第2章中所做的那样，可以通过在变量名前面添加 &lt;code&gt;mut&lt;/code&gt; 使其可变。除了允许更改此值之外， &lt;code&gt;mut&lt;/code&gt; 还通过指示代码的其他部分将更改此变量的值，将意图传达给将来的代码阅读者。</target>
        </trans-unit>
        <trans-unit id="ca01c2ad1998dcba761dee195dffb89226d07502" translate="yes" xml:space="preserve">
          <source>But mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope. This code will fail:</source>
          <target state="translated">但是可变引用有一个很大的限制:在一个特定的作用域中,你只能有一个对特定数据的可变引用。这段代码会失败。</target>
        </trans-unit>
        <trans-unit id="c6250d5ccc2a1416a071df325ba8b22edb3b1273" translate="yes" xml:space="preserve">
          <source>But structs aren&amp;rsquo;t the only way you can create custom types: let&amp;rsquo;s turn to Rust&amp;rsquo;s enum feature to add another tool to your toolbox.</source>
          <target state="translated">但是结构并不是创建自定义类型的唯一方法：让我们转到Rust的枚举功能，向您的工具箱添加另一个工具。</target>
        </trans-unit>
        <trans-unit id="e46bfa80d370a9ed637759cea72a8f30b0485064" translate="yes" xml:space="preserve">
          <source>But this approach is error prone; we could cause the program to panic if the index length is incorrect. It&amp;rsquo;s also slow, because the compiler adds runtime code to perform the conditional check on every element on every iteration through the loop.</source>
          <target state="translated">但是这种方法容易出错。如果索引长度不正确，我们可能会导致程序崩溃。这也很慢，因为编译器添加了运行时代码，以对循环中每次迭代的每个元素执行条件检查。</target>
        </trans-unit>
        <trans-unit id="de89e89b70a2e3c19b2a830c292d1b9e969da48e" translate="yes" xml:space="preserve">
          <source>But this code does:</source>
          <target state="translated">但这段代码确实如此。</target>
        </trans-unit>
        <trans-unit id="52cdbd656052ab3ea671f0d02157a3b7b3a6c824" translate="yes" xml:space="preserve">
          <source>But this code seems to contradict what we just learned: we don&amp;rsquo;t have a call to &lt;code&gt;clone&lt;/code&gt;, but &lt;code&gt;x&lt;/code&gt; is still valid and wasn&amp;rsquo;t moved into &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">但是这段代码似乎与我们刚刚学到的东西相矛盾：我们没有调用 &lt;code&gt;clone&lt;/code&gt; 的调用，但是 &lt;code&gt;x&lt;/code&gt; 仍然有效并且没有移入 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f041deb6530f49ecfbaae593b78e17efac482d38" translate="yes" xml:space="preserve">
          <source>But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Rust has a feature for this concept, called &lt;em&gt;references&lt;/em&gt;.</source>
          <target state="translated">但这对于一个应该很普遍的概念来说是太多的仪式和大量的工作。对我们来说幸运的是，Rust具有此概念的功能，称为&lt;em&gt;参考&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2ad53668e46657588df9ef2114136e4f4dac0e42" translate="yes" xml:space="preserve">
          <source>But we also have to make some small changes to &lt;code&gt;main&lt;/code&gt;. The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods return new instances rather than modifying the struct they&amp;rsquo;re called on, so we need to add more &lt;code&gt;let post =&lt;/code&gt; shadowing assignments to save the returned instances. We also can&amp;rsquo;t have the assertions about the draft and pending review post&amp;rsquo;s contents be empty strings, nor do we need them: we can&amp;rsquo;t compile code that tries to use the content of posts in those states any longer. The updated code in &lt;code&gt;main&lt;/code&gt; is shown in Listing 17-21:</source>
          <target state="translated">但是我们还必须对 &lt;code&gt;main&lt;/code&gt; 进行一些小的更改。该 &lt;code&gt;request_review&lt;/code&gt; 和 &lt;code&gt;approve&lt;/code&gt; 方法返回新的实例，而不是修改他们是所谓的结构，所以我们需要添加更多的 &lt;code&gt;let post =&lt;/code&gt; 阴影分配要保存返回实例。我们也不能将关于草稿和待审核帖子内容的断言设为空字符串，也不需要它们：我们无法再编译试图使用这些状态中帖子内容的代码。清单17-21显示了 &lt;code&gt;main&lt;/code&gt; 中更新的代码：</target>
        </trans-unit>
        <trans-unit id="08cb86c283fbceae016dfe9e91e73ec38c2b76a7" translate="yes" xml:space="preserve">
          <source>But we can&amp;rsquo;t implement external traits on external types. For example, we can&amp;rsquo;t implement the &lt;code&gt;Display&lt;/code&gt; trait on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; within our &lt;code&gt;aggregator&lt;/code&gt; crate, because &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; are defined in the standard library and aren&amp;rsquo;t local to our &lt;code&gt;aggregator&lt;/code&gt; crate. This restriction is part of a property of programs called &lt;em&gt;coherence&lt;/em&gt;, and more specifically the &lt;em&gt;orphan rule&lt;/em&gt;, so named because the parent type is not present. This rule ensures that other people&amp;rsquo;s code can&amp;rsquo;t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn&amp;rsquo;t know which implementation to use.</source>
          <target state="translated">但是我们不能在外部类型上实现外部特征。例如，我们可以不执行 &lt;code&gt;Display&lt;/code&gt; 对性状 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 我们的内 &lt;code&gt;aggregator&lt;/code&gt; 箱，因为 &lt;code&gt;Display&lt;/code&gt; 和 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 标准库中定义和不是本地到我们的 &lt;code&gt;aggregator&lt;/code&gt; 箱子。此限制是程序的一部分，称为&lt;em&gt;Coherence&lt;/em&gt;，并且更具体地讲是&lt;em&gt;orphan规则&lt;/em&gt;，之所以这样命名是因为不存在父类型。此规则确保其他人的代码不会破坏您的代码，反之亦然。没有规则，两个箱子可以为相同类型实现相同的特征，而Rust将不知道使用哪种实现。</target>
        </trans-unit>
        <trans-unit id="e2def28f767ccc15567e67d96a674194d2cda727" translate="yes" xml:space="preserve">
          <source>But we&amp;rsquo;re not quite done yet! In the worker, our closure being passed to &lt;code&gt;thread::spawn&lt;/code&gt; still only &lt;em&gt;references&lt;/em&gt; the receiving end of the channel. Instead, we need the closure to loop forever, asking the receiving end of the channel for a job and running the job when it gets one. Let&amp;rsquo;s make the change shown in Listing 20-20 to &lt;code&gt;Worker::new&lt;/code&gt;.</source>
          <target state="translated">但是我们还没有完成！在worker中，传递给 &lt;code&gt;thread::spawn&lt;/code&gt; 闭包仍然仅&lt;em&gt;引用&lt;/em&gt;通道的接收端。取而代之的是，我们需要闭包永远循环，向通道的接收端询问作业，并在获得作业时运行该作业。让我们将清单20-20中显示的更改更改为 &lt;code&gt;Worker::new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91d9b7bfa8f54bae2ca712d22c222ac19da54446" translate="yes" xml:space="preserve">
          <source>But what use is a type you can never create values for? Recall the code from Listing 2-5; we&amp;rsquo;ve reproduced part of it here in Listing 19-26.</source>
          <target state="translated">但是，您永远不能为其创建值的类型有什么用？回顾清单2-5中的代码；我们在清单19-26中复制了其中的一部分。</target>
        </trans-unit>
        <trans-unit id="f5817afbaa27eca7b4e5b48d721c41770590cf6f" translate="yes" xml:space="preserve">
          <source>But when it comes to supporting this in traits, there are &lt;a href=&quot;https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/&quot;&gt;a few implementation issues&lt;/a&gt;. One of them is returning &lt;code&gt;impl Trait&lt;/code&gt; in traits is not supported, as it would require &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44265&quot;&gt;Generic Associated Types&lt;/a&gt; to be supported:</source>
          <target state="translated">但是，在特性方面支持这一点时，存在&lt;a href=&quot;https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/&quot;&gt;一些实现问题&lt;/a&gt;。其中之一是不支持返回trait特质的 &lt;code&gt;impl Trait&lt;/code&gt; ，因为这将需要支持&lt;a href=&quot;https://github.com/rust-lang/rust/issues/44265&quot;&gt;通用关联类型&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3b1144e8d867db6585bb0fed6af4e27df37f58b6" translate="yes" xml:space="preserve">
          <source>But you&amp;rsquo;ll more often see them used in this format, with the comment on a separate line above the code it&amp;rsquo;s annotating:</source>
          <target state="translated">但是，您会更经常看到它们以这种格式使用，并且在其所注释的代码上方的单独一行中添加了注释：</target>
        </trans-unit>
        <trans-unit id="14c5580ac9c2810afbb01f7bb2cceb390e04edb0" translate="yes" xml:space="preserve">
          <source>By adding &lt;code&gt;--undo&lt;/code&gt; to the command, you can also undo a yank and allow projects to start depending on a version again:</source>
          <target state="translated">通过在命令中添加 &lt;code&gt;--undo&lt;/code&gt; ，还可以撤消yank并允许项目再次根据版本启动：</target>
        </trans-unit>
        <trans-unit id="57268469c25c87f6ad4c099c6346794a32838869" translate="yes" xml:space="preserve">
          <source>By adding the &lt;code&gt;move&lt;/code&gt; keyword before the closure, we force the closure to take ownership of the values it&amp;rsquo;s using rather than allowing Rust to infer that it should borrow the values. The modification to Listing 16-3 shown in Listing 16-5 will compile and run as we intend:</source>
          <target state="translated">通过在闭包之前添加 &lt;code&gt;move&lt;/code&gt; 关键字，我们强制闭包获取其使用的值的所有权，而不是允许Rust推断它应该借用这些值。清单16-5中显示的对清单16-3的修改将按照我们的预期进行编译和运行：</target>
        </trans-unit>
        <trans-unit id="24cf831e0672b0a0d0cb2aabe568cf79d0a637c3" translate="yes" xml:space="preserve">
          <source>By changing &lt;code&gt;impl PartialEq for Book&lt;/code&gt; to &lt;code&gt;impl PartialEq&amp;lt;BookFormat&amp;gt; for Book&lt;/code&gt;, we allow &lt;code&gt;BookFormat&lt;/code&gt;s to be compared with &lt;code&gt;Book&lt;/code&gt;s.</source>
          <target state="translated">通过将 &lt;code&gt;impl PartialEq for Book&lt;/code&gt; 的 &lt;code&gt;impl PartialEq&amp;lt;BookFormat&amp;gt; for Book&lt;/code&gt; 更改为Book的impl PartialEq &amp;lt;BookFormat&amp;gt;，我们可以将 &lt;code&gt;BookFormat&lt;/code&gt; 与 &lt;code&gt;Book&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="376ca023c76f3036478e22fdb169869008d8aa9e" translate="yes" xml:space="preserve">
          <source>By controlling which tests run, you can make sure your &lt;code&gt;cargo test&lt;/code&gt; results will be fast. When you&amp;rsquo;re at a point where it makes sense to check the results of the &lt;code&gt;ignored&lt;/code&gt; tests and you have time to wait for the results, you can run &lt;code&gt;cargo test -- --ignored&lt;/code&gt; instead.</source>
          <target state="translated">通过控制运行哪些测试，可以确保您的 &lt;code&gt;cargo test&lt;/code&gt; 结果很快。当您需要检查 &lt;code&gt;ignored&lt;/code&gt; 测试的结果并且有时间等待结果时，可以运行 &lt;code&gt;cargo test -- --ignored&lt;/code&gt; 忽略。</target>
        </trans-unit>
        <trans-unit id="5a2bb1d27a87d404cc9474290490c53d74fd41c0" translate="yes" xml:space="preserve">
          <source>By convention, &lt;code&gt;self.cmp(&amp;amp;other)&lt;/code&gt; returns the ordering matching the expression &lt;code&gt;self &amp;lt;operator&amp;gt; other&lt;/code&gt; if true.</source>
          <target state="translated">按照约定，如果为true ，则 &lt;code&gt;self.cmp(&amp;amp;other)&lt;/code&gt; 返回与表达式 &lt;code&gt;self &amp;lt;operator&amp;gt; other&lt;/code&gt; 匹配的排序。</target>
        </trans-unit>
        <trans-unit id="de8a1d92f6dd3bd8db18180b7b2a50fb4ed9f5aa" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;security_qos_flags&lt;/code&gt; is not set. It should be specified when opening a named pipe, to control to which degree a server process can act on behalf of a client process (security impersonation level).</source>
          <target state="translated">默认情况下，未设置 &lt;code&gt;security_qos_flags&lt;/code&gt; 。在打开命名管道时应指定此名称，以控制服务器进程可以代表客户端进程执行的程度（安全模拟级别）。</target>
        </trans-unit>
        <trans-unit id="6095051ff401d433de5d730cac4f12b5941e6537" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;share_mode&lt;/code&gt; is set to &lt;code&gt;FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE&lt;/code&gt;. This allows other processes to read, write, and delete/rename the same file while it is open. Removing any of the flags will prevent other processes from performing the corresponding operation until the file handle is closed.</source>
          <target state="translated">默认情况下， &lt;code&gt;share_mode&lt;/code&gt; 设置为 &lt;code&gt;FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE&lt;/code&gt; 。这允许其他进程在打开同一文件时读取，写入以及删除/重命名该文件。删除任何标志将阻止其他进程执行相应的操作，直到关闭文件句柄。</target>
        </trans-unit>
        <trans-unit id="45de1662a54cdc16cef2847d72223197060768f7" translate="yes" xml:space="preserve">
          <source>By default external blocks assume that the library they are calling uses the standard C ABI on the specific platform. Other ABIs may be specified using an &lt;code&gt;abi&lt;/code&gt; string, as shown here:</source>
          <target state="translated">默认情况下，外部块假定它们正在调用的库在特定平台上使用标准C ABI。其他ABI可以使用 &lt;code&gt;abi&lt;/code&gt; 字符串指定，如下所示：</target>
        </trans-unit>
        <trans-unit id="fc473c24bd4f443ffeef08b0cf6f41ff8de8d915" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; statements consume all they can, which can sometimes be a problem, when you don't really need the value to be moved and owned:</source>
          <target state="translated">默认情况下，当您实际上不需要移动和拥有值时，&lt;a href=&quot;keyword.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;语句会尽其所能，这有时会是一个问题：</target>
        </trans-unit>
        <trans-unit id="ad11d86076f62fa9cc433e025f374e132c103f7a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;HashMap&lt;/code&gt; uses a &amp;ldquo;cryptographically strong&amp;rdquo;&lt;sup&gt;&lt;a href=&quot;#siphash&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; hashing function that can provide resistance to Denial of Service (DoS) attacks. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it. If you profile your code and find that the default hash function is too slow for your purposes, you can switch to another function by specifying a different &lt;em&gt;hasher&lt;/em&gt;. A hasher is a type that implements the &lt;code&gt;BuildHasher&lt;/code&gt; trait. We&amp;rsquo;ll talk about traits and how to implement them in Chapter 10. You don&amp;rsquo;t necessarily have to implement your own hasher from scratch; &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; has libraries shared by other Rust users that provide hashers implementing many common hashing algorithms.</source>
          <target state="translated">默认情况下， &lt;code&gt;HashMap&lt;/code&gt; 使用&amp;ldquo;具有强大加密功能&amp;rdquo;的&lt;sup&gt;&lt;a href=&quot;#siphash&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;哈希函数，可以抵抗拒绝服务（DoS）攻击。这不是可用的最快的哈希算法，但是性能下降带来的更好安全性的权衡是值得的。如果您对代码进行概要分析并发现默认哈希函数对于您的目的而言太慢，则可以通过指定其他&lt;em&gt;hasher&lt;/em&gt;来切换到另一个函数。散列器是实现 &lt;code&gt;BuildHasher&lt;/code&gt; 特性的一种类型。在第10章中，我们将讨论特性以及如何实现它们。您不必从头开始实现自己的哈希器。&lt;a href=&quot;https://crates.io/&quot;&gt;箱子&lt;/a&gt; 拥有其他Rust用户共享的库，这些库提供实现许多常见哈希算法的哈希器。</target>
        </trans-unit>
        <trans-unit id="da46918183f148a703a5dca98e668e41fe0f6742" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;HashMap&lt;/code&gt; uses a hashing algorithm selected to provide resistance against HashDoS attacks. The algorithm is randomly seeded, and a reasonable best-effort is made to generate this seed from a high quality, secure source of randomness provided by the host without blocking the program. Because of this, the randomness of the seed depends on the output quality of the system's random number generator when the seed is created. In particular, seeds generated when the system's entropy pool is abnormally low such as during system boot may be of a lower quality.</source>
          <target state="translated">默认情况下， &lt;code&gt;HashMap&lt;/code&gt; 使用选择用于提供对HashDoS攻击的抵抗力的哈希算法。该算法是随机种子的，并且做出了合理的努力，以从主机提供的高质量，安全的随机源生成该种子，而不会阻塞程序。因此，种子的随机性取决于创建种子时系统的随机数生成器的输出质量。特别地，当系统的熵池异常低时（例如在系统引导期间）生成的种子可能具有较低的质量。</target>
        </trans-unit>
        <trans-unit id="d651c937af4d96b8135fb3517b9d184e89c5453c" translate="yes" xml:space="preserve">
          <source>By default, Rust brings only a few types into the scope of every program in &lt;a href=&quot;../std/prelude/index&quot;&gt;the &lt;em&gt;prelude&lt;/em&gt;&lt;/a&gt;. If a type you want to use isn&amp;rsquo;t in the prelude, you have to bring that type into scope explicitly with a &lt;code&gt;use&lt;/code&gt; statement. Using the &lt;code&gt;std::io&lt;/code&gt; library provides you with a number of useful features, including the ability to accept user input.</source>
          <target state="translated">默认情况下，锈病带来的只有少数类型到每一个程序的范围&lt;a href=&quot;../std/prelude/index&quot;&gt;的&lt;em&gt;序幕&lt;/em&gt;&lt;/a&gt;。如果您要使用的类型不在序幕中，则必须 &lt;code&gt;use&lt;/code&gt; 语句将该类型显式引入作用域。使用 &lt;code&gt;std::io&lt;/code&gt; 库为您提供了许多有用的功能，包括接受用户输入的能力。</target>
        </trans-unit>
        <trans-unit id="0c4c1f7def0235335f03f717a82baeaf139f3d6d" translate="yes" xml:space="preserve">
          <source>By default, a macro has no path-based scope. However, if it has the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute, then it is declared in the crate root scope and can be referred to normally as such:</source>
          <target state="translated">默认情况下，宏没有基于路径的作用域。但是，如果它具有 &lt;code&gt;#[macro_export]&lt;/code&gt; 属性，则在箱根范围中声明它，并且通常可以这样称呼它：</target>
        </trans-unit>
        <trans-unit id="0cbf310ab8fadfa7c76780733e623179e3214d1c" translate="yes" xml:space="preserve">
          <source>By default, all identifiers referred to in a macro are expanded as-is, and are looked up at the macro's invocation site. This can lead to issues if a macro refers to an item or macro which isn't in scope at the invocation site. To alleviate this, the &lt;code&gt;$crate&lt;/code&gt; metavariable can be used at the start of a path to force lookup to occur inside the crate defining the macro.</source>
          <target state="translated">默认情况下，宏中引用的所有标识符均按原样扩展，并在宏的调用站点中查找。如果宏引用的项目或宏不在调用站点的范围内，则可能导致问题。为了减轻这种情况，可以在路径的开头使用 &lt;code&gt;$crate&lt;/code&gt; 变量，以强制在定义宏的板条箱内进行查找。</target>
        </trans-unit>
        <trans-unit id="642089d05c107d61f37af46fec5f28d39e938fae" translate="yes" xml:space="preserve">
          <source>By default, all types in Rust are movable. Rust allows passing all types by-value, and common smart-pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; allow replacing and moving the values they contain: you can move out of a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or you can use &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wraps a pointer type &lt;code&gt;P&lt;/code&gt;, so &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; functions much like a regular &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;: when a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; gets dropped, so do its contents, and the memory gets deallocated. Similarly, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; is a lot like &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. However, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does not let clients actually obtain a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to pinned data, which implies that you cannot use operations such as &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">默认情况下，Rust中的所有类型都是可移动的。 Rust允许按值传递所有类型，而&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 等常见的智能指针类型允许替换和移动它们包含的值：您可以移出&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，也可以使用&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;包装了指针类型 &lt;code&gt;P&lt;/code&gt; ，因此&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 功能与常规&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;相似：当删除&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 时，其内容也将被释放，并且内存被释放。同样，&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 很像 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 。但是，&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;不允许客户端实际获得&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 来固定数据，这意味着您不能使用诸如&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="85f73f88e9b11f78d793846432896a45a47d865c" translate="yes" xml:space="preserve">
          <source>By default, all types in Rust are movable. Rust allows passing all types by-value, and common smart-pointer types such as &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; allow replacing and moving the values they contain: you can move out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, or you can use &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wraps a pointer type &lt;code&gt;P&lt;/code&gt;, so &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; functions much like a regular &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: when a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; gets dropped, so do its contents, and the memory gets deallocated. Similarly, &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; is a lot like &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. However, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does not let clients actually obtain a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to pinned data, which implies that you cannot use operations such as &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">默认情况下，Rust中的所有类型都是可移动的。 Rust允许按值传递所有类型，而 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 等常见的智能指针类型允许替换和移动它们包含的值：您可以移出 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ，也可以使用&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;包装了指针类型 &lt;code&gt;P&lt;/code&gt; ，因此 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 功能与常规 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 相似：当删除 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 时，其内容也是如此，并且内存被释放。类似地， &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 很像 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 。但是，&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;不允许客户实际获得 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 固定数据，这意味着您不能使用诸如&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="df4968e3432ef000f1bcc3fb95cf2b7eb0f19a6b" translate="yes" xml:space="preserve">
          <source>By default, everything in Rust is &lt;em&gt;private&lt;/em&gt;, with two exceptions: Associated items in a &lt;code&gt;pub&lt;/code&gt; Trait are public by default; Enum variants in a &lt;code&gt;pub&lt;/code&gt; enum are also public by default. When an item is declared as &lt;code&gt;pub&lt;/code&gt;, it can be thought of as being accessible to the outside world. For example:</source>
          <target state="translated">默认情况下，Rust中的所有内容都是&lt;em&gt;private&lt;/em&gt;，但有两个例外： &lt;code&gt;pub&lt;/code&gt; Trait中的关联项目默认情况下是公共的；默认情况下， &lt;code&gt;pub&lt;/code&gt; 枚举中的Enum变体也是公开的。当一个项目被声明为 &lt;code&gt;pub&lt;/code&gt; 时，可以认为它是外界可以访问的。例如：</target>
        </trans-unit>
        <trans-unit id="e8c258fdae97b1ecf4c355834b8cc2789a53356b" translate="yes" xml:space="preserve">
          <source>By default, generic functions will work only on types that have a known size at compile time. However, you can use the following special syntax to relax this restriction:</source>
          <target state="translated">默认情况下,泛型函数只适用于在编译时已知大小的类型。然而,你可以使用下面的特殊语法来放宽这个限制。</target>
        </trans-unit>
        <trans-unit id="a9c4cd7fe13c5d5855eca814505fcc712b580495" translate="yes" xml:space="preserve">
          <source>By default, identifier patterns bind a variable to a copy of or move from the matched value depending on whether the matched value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. This can be changed to bind to a reference by using the &lt;code&gt;ref&lt;/code&gt; keyword, or to a mutable reference using &lt;code&gt;ref mut&lt;/code&gt;. For example:</source>
          <target state="translated">默认情况下，标识符模式根据匹配值是否实现&lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，将变量绑定到匹配值的副本或从匹配值移动。可以将其更改为使用 &lt;code&gt;ref&lt;/code&gt; 关键字绑定到引用，或使用 &lt;code&gt;ref mut&lt;/code&gt; 绑定到可变引用。例如：</target>
        </trans-unit>
        <trans-unit id="972aa10d3aec7b320258dca3f2fe0bcadcd844ff" translate="yes" xml:space="preserve">
          <source>By default, if a test passes, Rust&amp;rsquo;s test library captures anything printed to standard output. For example, if we call &lt;code&gt;println!&lt;/code&gt; in a test and the test passes, we won&amp;rsquo;t see the &lt;code&gt;println!&lt;/code&gt; output in the terminal; we&amp;rsquo;ll see only the line that indicates the test passed. If a test fails, we&amp;rsquo;ll see whatever was printed to standard output with the rest of the failure message.</source>
          <target state="translated">默认情况下，如果测试通过，Rust的测试库将捕获打印到标准输出的所有内容。例如，如果我们调用 &lt;code&gt;println!&lt;/code&gt; 在测试中，测试通过，我们看不到 &lt;code&gt;println!&lt;/code&gt; 在终端输出；我们只会看到表明测试已通过的行。如果测试失败，我们将在其余失败消息中看到打印到标准输出的所有内容。</target>
        </trans-unit>
        <trans-unit id="d95184642912361a38b12a6b5acfd4cc05172698" translate="yes" xml:space="preserve">
          <source>By default, stdin, stdout and stderr are inherited from the parent.</source>
          <target state="translated">默认情况下,stdin、stdout和stderr都是从父类继承的。</target>
        </trans-unit>
        <trans-unit id="f620f1067d553e3bfb80fd71b1c203148dc846fc" translate="yes" xml:space="preserve">
          <source>By default, stdin, stdout and stderr are inherited from the parent. In order to capture the output into this &lt;code&gt;Result&amp;lt;Output&amp;gt;&lt;/code&gt; it is necessary to create new pipes between parent and child. Use &lt;code&gt;stdout(Stdio::piped())&lt;/code&gt; or &lt;code&gt;stderr(Stdio::piped())&lt;/code&gt;, respectively.</source>
          <target state="translated">默认情况下，stdin，stdout和stderr是从父级继承的。为了将输出捕获到此 &lt;code&gt;Result&amp;lt;Output&amp;gt;&lt;/code&gt; ，有必要在父级和子级之间创建新管道。分别使用 &lt;code&gt;stdout(Stdio::piped())&lt;/code&gt; 或 &lt;code&gt;stderr(Stdio::piped())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a3d2a96946537e440c011c1b793bac6cb6bf93c" translate="yes" xml:space="preserve">
          <source>By default, stdout and stderr are captured (and used to provide the resulting output). Stdin is not inherited from the parent and any attempt by the child process to read from the stdin stream will result in the stream immediately closing.</source>
          <target state="translated">默认情况下,stdout和stderr被捕获(并用于提供结果输出)。Stdin不从父进程继承,子进程试图从stdin流中读取的任何尝试都会导致该流立即关闭。</target>
        </trans-unit>
        <trans-unit id="ef6b7759d538ef3f99e9eadac17fdfe2aa668d92" translate="yes" xml:space="preserve">
          <source>By default, variable bindings have 'move semantics.' In other words:</source>
          <target state="translated">默认情况下,变量绑定具有 &quot;移动语义&quot;。换句话说。</target>
        </trans-unit>
        <trans-unit id="07d2d74e176689aec98a3f3118957a0424dbbe81" translate="yes" xml:space="preserve">
          <source>By default, variables in Rust are immutable. To fix this error, add the keyword &lt;code&gt;mut&lt;/code&gt; after the keyword &lt;code&gt;let&lt;/code&gt; when declaring the variable. For example:</source>
          <target state="translated">默认情况下，Rust中的变量是不可变的。要解决此错误，请在声明变量时在关键字 &lt;code&gt;let&lt;/code&gt; 之后添加关键字 &lt;code&gt;mut&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="878411518946b9f6ea5793ecae83ce111ee3e9e7" translate="yes" xml:space="preserve">
          <source>By default, when a panic occurs, the program starts &lt;em&gt;unwinding&lt;/em&gt;, which means Rust walks back up the stack and cleans up the data from each function it encounters. But this walking back and cleanup is a lot of work. The alternative is to immediately &lt;em&gt;abort&lt;/em&gt;, which ends the program without cleaning up. Memory that the program was using will then need to be cleaned up by the operating system. If in your project you need to make the resulting binary as small as possible, you can switch from unwinding to aborting upon a panic by adding &lt;code&gt;panic = 'abort'&lt;/code&gt; to the appropriate &lt;code&gt;[profile]&lt;/code&gt; sections in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. For example, if you want to abort on panic in release mode, add this:</source>
          <target state="translated">默认情况下，当出现紧急情况时，程序将开始&lt;em&gt;平仓&lt;/em&gt;，这意味着Rust会返回堆栈并从遇到的每个函数中清除数据。但是，此后退和清理工作量很大。另一种选择是立即&lt;em&gt;中止&lt;/em&gt;，这将结束程序而不进行清理。然后，操作系统将需要清理程序正在使用的内存。如果在项目中需要使生成的二进制文件尽可能小，则可以通过将 &lt;code&gt;panic = 'abort'&lt;/code&gt; 添加到&lt;em&gt;Cargo.toml&lt;/em&gt;文件中相应的 &lt;code&gt;[profile]&lt;/code&gt; 部分，从&lt;em&gt;崩溃变为崩溃&lt;/em&gt;。例如，如果要在释放模式下因紧急情况而中止，请添加以下内容：</target>
        </trans-unit>
        <trans-unit id="70961236b49c3241db36d35bd68586bfb070a6d8" translate="yes" xml:space="preserve">
          <source>By implementing &lt;code&gt;FromIterator&lt;/code&gt; for a type, you define how it will be created from an iterator. This is common for types which describe a collection of some kind.</source>
          <target state="translated">通过为类型实现 &lt;code&gt;FromIterator&lt;/code&gt; ，可以定义如何从迭代器创建它。这对于描述某种集合的类型很常见。</target>
        </trans-unit>
        <trans-unit id="8fe6d2f7538ddf4711df03e9fa6aac2aec872193" translate="yes" xml:space="preserve">
          <source>By implementing &lt;code&gt;IntoIterator&lt;/code&gt; for a type, you define how it will be converted to an iterator. This is common for types which describe a collection of some kind.</source>
          <target state="translated">通过为类型实现 &lt;code&gt;IntoIterator&lt;/code&gt; ，可以定义如何将其转换为迭代器。这对于描述某种集合的类型很常见。</target>
        </trans-unit>
        <trans-unit id="a0afc41378ee2d3e0b24873888e49fe44ab2bb88" translate="yes" xml:space="preserve">
          <source>By implementing the state pattern exactly as it&amp;rsquo;s defined for object-oriented languages, we&amp;rsquo;re not taking as full advantage of Rust&amp;rsquo;s strengths as we could. Let&amp;rsquo;s look at some changes we can make to the &lt;code&gt;blog&lt;/code&gt; crate that can make invalid states and transitions into compile time errors.</source>
          <target state="translated">通过完全按照面向对象语言所定义的方式来实现状态模式，我们无法充分利用Rust的优势。让我们看一下我们可以对 &lt;code&gt;blog&lt;/code&gt; 箱进行的一些更改，这些更改可以使无效状态和转换为编译时错误。</target>
        </trans-unit>
        <trans-unit id="46180f00b512e17d9f64273f452da441a283a2bb" translate="yes" xml:space="preserve">
          <source>By inserting the &lt;code&gt;unsafe&lt;/code&gt; block around our call to &lt;code&gt;dangerous&lt;/code&gt;, we&amp;rsquo;re asserting to Rust that we&amp;rsquo;ve read the function&amp;rsquo;s documentation, we understand how to use it properly, and we&amp;rsquo;ve verified that we&amp;rsquo;re fulfilling the contract of the function.</source>
          <target state="translated">通过将 &lt;code&gt;unsafe&lt;/code&gt; 围绕我们调用块 &lt;code&gt;dangerous&lt;/code&gt; ，我们主张以锈我们已经读取功能的文档，我们知道如何正确地使用它，而且我们已经证实，我们正在履行职能的合同。</target>
        </trans-unit>
        <trans-unit id="ebd43141acc082c32de2ba198e30637d83a5941d" translate="yes" xml:space="preserve">
          <source>By introducing the explicit &lt;code&gt;let value&lt;/code&gt;, we allocate storage that will last until the end of the enclosing block (when &lt;code&gt;value&lt;/code&gt; goes out of scope). When we borrow &lt;code&gt;&amp;amp;value&lt;/code&gt;, we are borrowing a local variable that already exists, and hence no temporary is created.</source>
          <target state="translated">通过引入显式的 &lt;code&gt;let value&lt;/code&gt; ，我们分配将持续到封闭块末尾的存储（当 &lt;code&gt;value&lt;/code&gt; 超出范围时）。当我们借用 &lt;code&gt;&amp;amp;value&lt;/code&gt; 时，我们借用的是已经存在的局部变量，因此不会创建任何临时变量。</target>
        </trans-unit>
        <trans-unit id="69e12568cda798dc4c41d36b6782b17be36886bc" translate="yes" xml:space="preserve">
          <source>By now, you&amp;rsquo;ve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 20, we&amp;rsquo;ll look at a few aspects of the language you might run into every once in a while. You can use this chapter as a reference for when you encounter any unknowns when using Rust. The features you&amp;rsquo;ll learn to use in this chapter are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.</source>
          <target state="translated">到目前为止，您已经了解了Rust编程语言中最常用的部分。在第20章中进行更多项目之前，我们将不时地探究一下您可能会遇到的几种语言。您可以在使用Rust时遇到任何未知情况时参考本章。您将在本章中学习使用的功能在非常特殊的情况下很有用。尽管您可能不经常接触它们，但我们希望确保您了解Rust提供的所有功能。</target>
        </trans-unit>
        <trans-unit id="3b8d2c5ef438bc901d43221175865fde334c590c" translate="yes" xml:space="preserve">
          <source>By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust&amp;rsquo;s guarantees don&amp;rsquo;t apply.</source>
          <target state="translated">通过选择不让Rust强制执行这些保证，您可以放弃保证的安全，以换取更高的性能或与不适用Rust保证的另一种语言或硬件进行交互的能力。</target>
        </trans-unit>
        <trans-unit id="27764f2a26f0e207cc2fb6a676294f8c54a5721a" translate="yes" xml:space="preserve">
          <source>By requesting the current thread, using the &lt;a href=&quot;fn.current&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">通过请求当前线程，使用&lt;a href=&quot;fn.current&quot;&gt; &lt;code&gt;thread::current&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="cbc7153ee55504f6099241a26bcc3f7667184521" translate="yes" xml:space="preserve">
          <source>By spawning a new thread, e.g., using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function, and calling &lt;a href=&quot;struct.joinhandle#method.thread&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; on the &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过产生新线程（例如，使用&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;函数），并在&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt;上调用&lt;a href=&quot;struct.joinhandle#method.thread&quot;&gt; &lt;code&gt;thread&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12606d21fd7d24ec782af86e2fc775ab3b2a1534" translate="yes" xml:space="preserve">
          <source>By the same token, if your slice includes the last byte of the &lt;code&gt;String&lt;/code&gt;, you can drop the trailing number. That means these are equal:</source>
          <target state="translated">同样，如果您的分片包含 &lt;code&gt;String&lt;/code&gt; 的最后一个字节，则可以删除尾随数字。这意味着这些是相等的：</target>
        </trans-unit>
        <trans-unit id="eed2e06fae66dfdcb759c3aa75071abdbcec3d30" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;impl Summary&lt;/code&gt; for the return type, we specify that the &lt;code&gt;returns_summarizable&lt;/code&gt; function returns some type that implements the &lt;code&gt;Summary&lt;/code&gt; trait without naming the concrete type. In this case, &lt;code&gt;returns_summarizable&lt;/code&gt; returns a &lt;code&gt;Tweet&lt;/code&gt;, but the code calling this function doesn&amp;rsquo;t know that.</source>
          <target state="translated">通过使用 &lt;code&gt;impl Summary&lt;/code&gt; 作为返回类型，我们指定 &lt;code&gt;returns_summarizable&lt;/code&gt; 函数返回某种实现 &lt;code&gt;Summary&lt;/code&gt; 特性的类型，而无需命名具体类型。在这种情况下， &lt;code&gt;returns_summarizable&lt;/code&gt; 返回 &lt;code&gt;Tweet&lt;/code&gt; ，但是调用此函数的代码不知道。</target>
        </trans-unit>
        <trans-unit id="e9aacb122cfae0a7a0d083ca40090e9b5f6410c8" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;loop&lt;/code&gt; instead and acquiring the lock and a job within the block rather than outside it, the &lt;code&gt;MutexGuard&lt;/code&gt; returned from the &lt;code&gt;lock&lt;/code&gt; method is dropped as soon as the &lt;code&gt;let job&lt;/code&gt; statement ends. This ensures that the lock is held during the call to &lt;code&gt;recv&lt;/code&gt;, but it is released before the call to &lt;code&gt;job.call_box()&lt;/code&gt;, allowing multiple requests to be serviced concurrently.</source>
          <target state="translated">通过使用 &lt;code&gt;loop&lt;/code&gt; 代替并在块中而不是在块外部获取锁和作业，一旦 &lt;code&gt;let job&lt;/code&gt; 语句结束，将从 &lt;code&gt;lock&lt;/code&gt; 方法返回的 &lt;code&gt;MutexGuard&lt;/code&gt; 丢弃。这样可以确保在调用 &lt;code&gt;recv&lt;/code&gt; 期间保留该锁，但在调用 &lt;code&gt;job.call_box()&lt;/code&gt; 之前将其释放，从而允许同时处理多个请求。</target>
        </trans-unit>
        <trans-unit id="a1dc62ff68dd92e2b08c605e1735e02b6fb42d3d" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;loop&lt;/code&gt; instead and acquiring the lock without assigning to a variable, the temporary &lt;code&gt;MutexGuard&lt;/code&gt; returned from the &lt;code&gt;lock&lt;/code&gt; method is dropped as soon as the &lt;code&gt;let job&lt;/code&gt; statement ends. This ensures that the lock is held during the call to &lt;code&gt;recv&lt;/code&gt;, but it is released before the call to &lt;code&gt;job()&lt;/code&gt;, allowing multiple requests to be serviced concurrently.</source>
          <target state="translated">通过使用 &lt;code&gt;loop&lt;/code&gt; 而不是在没有分配变量的情况下获取锁，一旦 &lt;code&gt;let job&lt;/code&gt; 语句结束，将从 &lt;code&gt;lock&lt;/code&gt; 方法返回的临时 &lt;code&gt;MutexGuard&lt;/code&gt; 删除。这样可以确保在调用 &lt;code&gt;recv&lt;/code&gt; 期间保留该锁，但在调用 &lt;code&gt;job()&lt;/code&gt; 之前将其释放，从而允许同时处理多个请求。</target>
        </trans-unit>
        <trans-unit id="96a33cddb0085e977a7cbf3fab6625f1af56ae11" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;pub use&lt;/code&gt;, external code can now call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function using &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt;. If we hadn&amp;rsquo;t specified &lt;code&gt;pub use&lt;/code&gt;, the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function could call &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in its scope, but external code couldn&amp;rsquo;t take advantage of this new path.</source>
          <target state="translated">通过使用 &lt;code&gt;pub use&lt;/code&gt; ，外部代码现在可以使用 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数。如果未指定 &lt;code&gt;pub use&lt;/code&gt; ， &lt;code&gt;eat_at_restaurant&lt;/code&gt; 函数可以在其作用域内调用 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; ，但是外部代码无法利用此新路径。</target>
        </trans-unit>
        <trans-unit id="433cfee29840720f9bbafd30efe0a38d5e74bfb2" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;unsafe impl&lt;/code&gt;, we&amp;rsquo;re promising that we&amp;rsquo;ll uphold the invariants that the compiler can&amp;rsquo;t verify.</source>
          <target state="translated">通过使用 &lt;code&gt;unsafe impl&lt;/code&gt; ，我们承诺将支持编译器无法验证的不变式。</target>
        </trans-unit>
        <trans-unit id="9f1a9fce35b987ffd7d1760b4240dc3939988c2c" translate="yes" xml:space="preserve">
          <source>By using a trait bound with an &lt;code&gt;impl&lt;/code&gt; block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits. For example, the type &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 10-16 always implements the &lt;code&gt;new&lt;/code&gt; function. But &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; only implements the &lt;code&gt;cmp_display&lt;/code&gt; method if its inner type &lt;code&gt;T&lt;/code&gt; implements the &lt;code&gt;PartialOrd&lt;/code&gt; trait that enables comparison &lt;em&gt;and&lt;/em&gt; the &lt;code&gt;Display&lt;/code&gt; trait that enables printing.</source>
          <target state="translated">通过使用与使用通用类型参数的 &lt;code&gt;impl&lt;/code&gt; 块绑定的特征，我们可以为实现指定特征的类型有条件地实现方法。例如，清单10-16中的 &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; 类型始终实现 &lt;code&gt;new&lt;/code&gt; 功能。但是 &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; 仅在其内部类型 &lt;code&gt;T&lt;/code&gt; 实现实现比较的 &lt;code&gt;PartialOrd&lt;/code&gt; 特性&lt;em&gt;和&lt;/em&gt;实现打印的 &lt;code&gt;Display&lt;/code&gt; 特性时才实现 &lt;code&gt;cmp_display&lt;/code&gt; 方法。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e575a61c7bb4198f04719172d2b19e840714927a" translate="yes" xml:space="preserve">
          <source>By using modules, we can group related definitions together and name why they&amp;rsquo;re related. Programmers using this code would have an easier time finding the definitions they wanted to use because they could navigate the code based on the groups rather than having to read through all the definitions. Programmers adding new functionality to this code would know where to place the code to keep the program organized.</source>
          <target state="translated">通过使用模块，我们可以将相关的定义分组在一起，并命名它们为什么相关。使用此代码的程序员可以更轻松地找到他们想要使用的定义，因为他们可以基于组导航代码，而不必阅读所有定义。向该代码添加新功能的程序员将知道将代码放置在何处，以保持程序的组织性。</target>
        </trans-unit>
        <trans-unit id="0b9231ce9a42a6d6d2c8f8b26aa846a1ea4f8ea3" translate="yes" xml:space="preserve">
          <source>By using these and other tools in the Rust ecosystem, developers can be productive while writing systems-level code.</source>
          <target state="translated">通过使用Rust生态系统中的这些和其他工具,开发人员可以在编写系统级代码的同时提高工作效率。</target>
        </trans-unit>
        <trans-unit id="2b10818a6a4d9d5c0ec3347fc6c8f03ab8bee8b6" translate="yes" xml:space="preserve">
          <source>By using this method, you are making a promise about the &lt;code&gt;P::Deref&lt;/code&gt; and &lt;code&gt;P::DerefMut&lt;/code&gt; implementations, if they exist. Most importantly, they must not move out of their &lt;code&gt;self&lt;/code&gt; arguments: &lt;code&gt;Pin::as_mut&lt;/code&gt; and &lt;code&gt;Pin::as_ref&lt;/code&gt; will call &lt;code&gt;DerefMut::deref_mut&lt;/code&gt; and &lt;code&gt;Deref::deref&lt;/code&gt;&lt;em&gt;on the pinned pointer&lt;/em&gt; and expect these methods to uphold the pinning invariants. Moreover, by calling this method you promise that the reference &lt;code&gt;P&lt;/code&gt; dereferences to will not be moved out of again; in particular, it must not be possible to obtain a &lt;code&gt;&amp;amp;mut P::Target&lt;/code&gt; and then move out of that reference (using, for example &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">通过使用此方法，您可以保证 &lt;code&gt;P::Deref&lt;/code&gt; 和 &lt;code&gt;P::DerefMut&lt;/code&gt; 实现（如果存在）。最重要的是，它们一定不能移出自己的 &lt;code&gt;self&lt;/code&gt; 变量： &lt;code&gt;Pin::as_mut&lt;/code&gt; 和 &lt;code&gt;Pin::as_ref&lt;/code&gt; 将&lt;em&gt;在固定指针上&lt;/em&gt;调用 &lt;code&gt;DerefMut::deref_mut&lt;/code&gt; 和 &lt;code&gt;Deref::deref&lt;/code&gt; &lt;em&gt;，&lt;/em&gt;并期望这些方法支持固定不变。此外，通过调用此方法，您保证引用 &lt;code&gt;P&lt;/code&gt; 取消引用的对象不会再次移出；而是，不再引用该引用。特别是，必须不可能获得 &lt;code&gt;&amp;amp;mut P::Target&lt;/code&gt; 然后移出该引用（例如，使用&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bcdb56a053eed7c5213a43f696d9db1ac84162fc" translate="yes" xml:space="preserve">
          <source>By using trait bounds we can accept arguments of different types as long as they can be converted to the specified type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">通过使用特征边界，我们可以接受不同类型的参数，只要它们可以转换为指定的类型 &lt;code&gt;T&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="301603101f50fc1a91e6b20fad60e030ba9789b8" translate="yes" xml:space="preserve">
          <source>By wrapping the stream with a &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;, these ten writes are all grouped together by the buffer and will all be written out in one system call when the &lt;code&gt;stream&lt;/code&gt; is flushed.</source>
          <target state="translated">通过使用 &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 包装流，这十次写操作全部由缓冲区分组，并且在刷新 &lt;code&gt;stream&lt;/code&gt; 时将全部在一个系统调用中写出。</target>
        </trans-unit>
        <trans-unit id="8dae0e28ac851e86945ef16395330c4f51fd0970" translate="yes" xml:space="preserve">
          <source>By wrapping the stream with a &lt;code&gt;BufWriter&lt;/code&gt;, these ten writes are all grouped together by the buffer, and will all be written out in one system call when the &lt;code&gt;stream&lt;/code&gt; is dropped.</source>
          <target state="translated">通过用 &lt;code&gt;BufWriter&lt;/code&gt; 包装流，这十次写操作全部由缓冲区分组，并且在删除 &lt;code&gt;stream&lt;/code&gt; 时都将在一个系统调用中全部写出。</target>
        </trans-unit>
        <trans-unit id="1548ce31fadb001aea0a12a579d52d9306c7253a" translate="yes" xml:space="preserve">
          <source>Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type &lt;code&gt;T&lt;/code&gt;, while doing nothing at all.</source>
          <target state="translated">假装产生类型 &lt;code&gt;T&lt;/code&gt; 的值，从而完全不执行任何操作，从而绕过了Rust的常规内存初始化检查。</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="afdbaede89ef0f8a02124c499ef64ef1f0406d22" translate="yes" xml:space="preserve">
          <source>Byte (&lt;code&gt;u8&lt;/code&gt; only)</source>
          <target state="translated">字节（仅适用于 &lt;code&gt;u8&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e461b64db66675f3379c1e15d16c6c99827a8b32" translate="yes" xml:space="preserve">
          <source>Byte and byte string literals</source>
          <target state="translated">字节和字节字符串字元</target>
        </trans-unit>
        <trans-unit id="bed6860ca009a5f59b4930b17f9fae2513fd51cb" translate="yes" xml:space="preserve">
          <source>Byte escapes</source>
          <target state="translated">字节逃逸</target>
        </trans-unit>
        <trans-unit id="2bf9a238164dde110e7112a731c7b6d180525024" translate="yes" xml:space="preserve">
          <source>Byte literals</source>
          <target state="translated">字节文字</target>
        </trans-unit>
        <trans-unit id="65c69de6b60d275943eb0b345c38a4da863d03c4" translate="yes" xml:space="preserve">
          <source>Byte order mark</source>
          <target state="translated">字节序号</target>
        </trans-unit>
        <trans-unit id="e7860363275fd51d964677e4db11dc87fb2b83e0" translate="yes" xml:space="preserve">
          <source>Byte string</source>
          <target state="translated">字节串</target>
        </trans-unit>
        <trans-unit id="7510135fa5665d61b3d40af81c44ebe6703847a9" translate="yes" xml:space="preserve">
          <source>Byte string literal; constructs a &lt;code&gt;[u8]&lt;/code&gt; instead of a string</source>
          <target state="translated">字节字符串文字；构造一个 &lt;code&gt;[u8]&lt;/code&gt; 而不是一个字符串</target>
        </trans-unit>
        <trans-unit id="d5501080013d3dce57e266b31385c7ea19dd9672" translate="yes" xml:space="preserve">
          <source>Byte string literals</source>
          <target state="translated">字节串字数</target>
        </trans-unit>
        <trans-unit id="013842b4ad25a64e13616ea1267e8fb94bd63a6f" translate="yes" xml:space="preserve">
          <source>Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be making near-constant calls to the operating system. To help with this, &lt;code&gt;std::io&lt;/code&gt; comes with two structs, &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt;, which wrap readers and writers. The wrapper uses a buffer, reducing the number of calls and providing nicer methods for accessing exactly what you want.</source>
          <target state="translated">基于字节的接口笨拙且效率低下，因为我们需要对操作系统进行近乎恒定的调用。为了解决这个问题， &lt;code&gt;std::io&lt;/code&gt; 带有两个结构&lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; &lt;/a&gt;，它们包装了读者和作家。包装器使用缓冲区，从而减少了调用次数，并提供了更好的方法来访问所需的内容。</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="f4b810da1a34c6717e9522d90aa84dd16327cb38" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;0..old_layout.size()&lt;/code&gt; are preserved from the original allocation.</source>
          <target state="translated">字节 &lt;code&gt;0..old_layout.size()&lt;/code&gt; 从原始分配保留。</target>
        </trans-unit>
        <trans-unit id="97b74d3f6f2a9ba3378b8d5ad47f1a4ae59fcd37" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;old_layout.size()..old_size&lt;/code&gt; will either be preserved or zeroed, depending on the allocator implementation. &lt;code&gt;old_size&lt;/code&gt; refers to the size of the memory block prior to the &lt;code&gt;grow_zeroed&lt;/code&gt; call, which may be larger than the size that was originally requested when it was allocated.</source>
          <target state="translated">字节 &lt;code&gt;old_layout.size()..old_size&lt;/code&gt; 将保留还是清零，具体取决于分配器的实现。 &lt;code&gt;old_size&lt;/code&gt; 是指 &lt;code&gt;grow_zeroed&lt;/code&gt; 调用之前的内存块大小，它可能大于分配时最初请求的大小。</target>
        </trans-unit>
        <trans-unit id="d5598f7ac23eed1d65ff56a4e36412084f03533d" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;old_size..new_size&lt;/code&gt; are zeroed. &lt;code&gt;new_size&lt;/code&gt; refers to the size of the memory block returned by the &lt;code&gt;grow_zeroed&lt;/code&gt; call.</source>
          <target state="translated">字节 &lt;code&gt;old_size..new_size&lt;/code&gt; 被清零。 &lt;code&gt;new_size&lt;/code&gt; 是指 &lt;code&gt;grow_zeroed&lt;/code&gt; 调用返回的内存块的大小。</target>
        </trans-unit>
        <trans-unit id="ac774cda628eb294788ac5a8af4246ebdb046c2e" translate="yes" xml:space="preserve">
          <source>Bytes and Scalar Values and Grapheme Clusters! Oh My!</source>
          <target state="translated">字节和标量值以及词素簇! 哦,我的天!</target>
        </trans-unit>
        <trans-unit id="63a26fef0a88c04dcaa35220a18f6ec6efa06bb9" translate="yes" xml:space="preserve">
          <source>Bytes::all</source>
          <target state="translated">Bytes::all</target>
        </trans-unit>
        <trans-unit id="ce7f0f3ceb8a803663be41eda4062efc6e909fc1" translate="yes" xml:space="preserve">
          <source>Bytes::any</source>
          <target state="translated">Bytes::any</target>
        </trans-unit>
        <trans-unit id="979369045d5514f553522214d3aeb625b48dd8a9" translate="yes" xml:space="preserve">
          <source>Bytes::borrow</source>
          <target state="translated">Bytes::borrow</target>
        </trans-unit>
        <trans-unit id="113f2dc7029b7c717fa9381d4e2943d9b1b2fc76" translate="yes" xml:space="preserve">
          <source>Bytes::borrow_mut</source>
          <target state="translated">Bytes::borrow_mut</target>
        </trans-unit>
        <trans-unit id="34427e43eec5e510b45622026cd37a560d9c2986" translate="yes" xml:space="preserve">
          <source>Bytes::by_ref</source>
          <target state="translated">Bytes::by_ref</target>
        </trans-unit>
        <trans-unit id="f07eec0f48fad142ac4fee1d3559e7e8d852d460" translate="yes" xml:space="preserve">
          <source>Bytes::chain</source>
          <target state="translated">Bytes::chain</target>
        </trans-unit>
        <trans-unit id="e0bf1210a39ee968daf6f1af8bf1ba9b5fc128dd" translate="yes" xml:space="preserve">
          <source>Bytes::clone</source>
          <target state="translated">Bytes::clone</target>
        </trans-unit>
        <trans-unit id="d328e30cabdbfda128a510cf1e8c0e446be3fec8" translate="yes" xml:space="preserve">
          <source>Bytes::clone_from</source>
          <target state="translated">Bytes::clone_from</target>
        </trans-unit>
        <trans-unit id="297e685afff3be463f3a3c3239b3251c10cb9c58" translate="yes" xml:space="preserve">
          <source>Bytes::clone_into</source>
          <target state="translated">Bytes::clone_into</target>
        </trans-unit>
        <trans-unit id="df2a47344e3e5b26dba12c9f96d298455119f06c" translate="yes" xml:space="preserve">
          <source>Bytes::cloned</source>
          <target state="translated">Bytes::cloned</target>
        </trans-unit>
        <trans-unit id="8c02ce01cfc4f2e89b9e4d7eed3369aa07faf8c3" translate="yes" xml:space="preserve">
          <source>Bytes::cmp</source>
          <target state="translated">Bytes::cmp</target>
        </trans-unit>
        <trans-unit id="299642d3a1e23a4fa629457b5fe1a7d7023f1ab5" translate="yes" xml:space="preserve">
          <source>Bytes::collect</source>
          <target state="translated">Bytes::collect</target>
        </trans-unit>
        <trans-unit id="6f693335f9495019383b9eadbf3b449bcfc675f9" translate="yes" xml:space="preserve">
          <source>Bytes::copied</source>
          <target state="translated">Bytes::copied</target>
        </trans-unit>
        <trans-unit id="93d1e678c86a68151617f0b02af7cadb48251558" translate="yes" xml:space="preserve">
          <source>Bytes::count</source>
          <target state="translated">Bytes::count</target>
        </trans-unit>
        <trans-unit id="1e5c00a470b7fc4f8da25723aad0fc52e134f397" translate="yes" xml:space="preserve">
          <source>Bytes::cycle</source>
          <target state="translated">Bytes::cycle</target>
        </trans-unit>
        <trans-unit id="9d81621cbab864e41b9591bee2a211c1e6fb3870" translate="yes" xml:space="preserve">
          <source>Bytes::enumerate</source>
          <target state="translated">Bytes::enumerate</target>
        </trans-unit>
        <trans-unit id="ea17a535e18dd3c17944b57230746af970ccf214" translate="yes" xml:space="preserve">
          <source>Bytes::eq</source>
          <target state="translated">Bytes::eq</target>
        </trans-unit>
        <trans-unit id="491e10ca5d759167723a7ee86c3ca2eea1265ab7" translate="yes" xml:space="preserve">
          <source>Bytes::filter</source>
          <target state="translated">Bytes::filter</target>
        </trans-unit>
        <trans-unit id="9742812b0b1477fbb5396ffff48eb2034a65761d" translate="yes" xml:space="preserve">
          <source>Bytes::filter_map</source>
          <target state="translated">Bytes::filter_map</target>
        </trans-unit>
        <trans-unit id="63e7f3cfad0e9eae54402838e01bfca54ca3afa5" translate="yes" xml:space="preserve">
          <source>Bytes::find</source>
          <target state="translated">Bytes::find</target>
        </trans-unit>
        <trans-unit id="290c24197673b5bfcbef8c08eea1c3d3b80c4622" translate="yes" xml:space="preserve">
          <source>Bytes::find_map</source>
          <target state="translated">Bytes::find_map</target>
        </trans-unit>
        <trans-unit id="9f757e2b209fe7676c23fb7de2d9a9666f266a57" translate="yes" xml:space="preserve">
          <source>Bytes::flat_map</source>
          <target state="translated">Bytes::flat_map</target>
        </trans-unit>
        <trans-unit id="ebffc4bee04033b63ddade2d5c137b7551135bbd" translate="yes" xml:space="preserve">
          <source>Bytes::flatten</source>
          <target state="translated">Bytes::flatten</target>
        </trans-unit>
        <trans-unit id="59f9148fe24ec4969d305fc0671cc3b707da545a" translate="yes" xml:space="preserve">
          <source>Bytes::fmt</source>
          <target state="translated">Bytes::fmt</target>
        </trans-unit>
        <trans-unit id="a8078f4655b1978965a5909b5351cb14c6583a92" translate="yes" xml:space="preserve">
          <source>Bytes::fold</source>
          <target state="translated">Bytes::fold</target>
        </trans-unit>
        <trans-unit id="7f2d08f4da0fc0d0fb55752871e004cb4680946d" translate="yes" xml:space="preserve">
          <source>Bytes::for_each</source>
          <target state="translated">Bytes::for_each</target>
        </trans-unit>
        <trans-unit id="62699a9360bcc212fa6c249680ba5b7f48e3fb42" translate="yes" xml:space="preserve">
          <source>Bytes::from</source>
          <target state="translated">Bytes::from</target>
        </trans-unit>
        <trans-unit id="603aaacbdc014366acd2253fbfbd1087387d3bd3" translate="yes" xml:space="preserve">
          <source>Bytes::fuse</source>
          <target state="translated">Bytes::fuse</target>
        </trans-unit>
        <trans-unit id="ef1515771c9b976e1008ae36cc109565b4569ae9" translate="yes" xml:space="preserve">
          <source>Bytes::ge</source>
          <target state="translated">Bytes::ge</target>
        </trans-unit>
        <trans-unit id="445e8b743c0007a524c7e482f8c83e4f69760410" translate="yes" xml:space="preserve">
          <source>Bytes::gt</source>
          <target state="translated">Bytes::gt</target>
        </trans-unit>
        <trans-unit id="24ede3c149e7de7883c58aaa99ee5d5463be74e6" translate="yes" xml:space="preserve">
          <source>Bytes::inspect</source>
          <target state="translated">Bytes::inspect</target>
        </trans-unit>
        <trans-unit id="8cfa8a5aca1d21185175b454e814b3c9674137dc" translate="yes" xml:space="preserve">
          <source>Bytes::into</source>
          <target state="translated">Bytes::into</target>
        </trans-unit>
        <trans-unit id="28993249bc6a265b1f1403816b2a9c4d5624ad5b" translate="yes" xml:space="preserve">
          <source>Bytes::into_iter</source>
          <target state="translated">Bytes::into_iter</target>
        </trans-unit>
        <trans-unit id="290c12fce35e73f7ad4e780c36b8daeaf1f6eaf9" translate="yes" xml:space="preserve">
          <source>Bytes::is_empty</source>
          <target state="translated">Bytes::is_empty</target>
        </trans-unit>
        <trans-unit id="37772f76db83eabf7ef6ed6382f4a6562ec04eaa" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted</source>
          <target state="translated">Bytes::is_sorted</target>
        </trans-unit>
        <trans-unit id="63f09c7e5213825da442ff7939106416cc2db665" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted_by</source>
          <target state="translated">Bytes::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="b26f21acb6f08d8c9a5ac1405c3ead0d4c9a6b00" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted_by_key</source>
          <target state="translated">Bytes::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f50aedc8dbbe9f4f7c0a8193c92f7fe881b11817" translate="yes" xml:space="preserve">
          <source>Bytes::last</source>
          <target state="translated">Bytes::last</target>
        </trans-unit>
        <trans-unit id="725cf533de1247b9f7939a230859f03c71c3a394" translate="yes" xml:space="preserve">
          <source>Bytes::le</source>
          <target state="translated">Bytes::le</target>
        </trans-unit>
        <trans-unit id="ae500d3c2531704059d772fbff739f3873572e45" translate="yes" xml:space="preserve">
          <source>Bytes::len</source>
          <target state="translated">Bytes::len</target>
        </trans-unit>
        <trans-unit id="b194acd634d0bc66745521f9549d62c66e9a152e" translate="yes" xml:space="preserve">
          <source>Bytes::lt</source>
          <target state="translated">Bytes::lt</target>
        </trans-unit>
        <trans-unit id="61ba21505c7ffe82b863e8bcbc73617c7e13b85c" translate="yes" xml:space="preserve">
          <source>Bytes::map</source>
          <target state="translated">Bytes::map</target>
        </trans-unit>
        <trans-unit id="fe2bc9537a5830454b8a500254016c0d67be2211" translate="yes" xml:space="preserve">
          <source>Bytes::max</source>
          <target state="translated">Bytes::max</target>
        </trans-unit>
        <trans-unit id="43d95dea33020faf006b7b4de468897537052a42" translate="yes" xml:space="preserve">
          <source>Bytes::max_by</source>
          <target state="translated">Bytes::max_by</target>
        </trans-unit>
        <trans-unit id="f7973f4371d6448647f6bb7f82a3cd4cc0be52b8" translate="yes" xml:space="preserve">
          <source>Bytes::max_by_key</source>
          <target state="translated">Bytes::max_by_key</target>
        </trans-unit>
        <trans-unit id="c3d094313a068051eedc54593c00089e5d5e0eaa" translate="yes" xml:space="preserve">
          <source>Bytes::min</source>
          <target state="translated">Bytes::min</target>
        </trans-unit>
        <trans-unit id="a26247387b6acf6339ec71745edbdff81c2ade56" translate="yes" xml:space="preserve">
          <source>Bytes::min_by</source>
          <target state="translated">Bytes::min_by</target>
        </trans-unit>
        <trans-unit id="f5a98f7f6167a1b442d3efa2009d49ad462460d2" translate="yes" xml:space="preserve">
          <source>Bytes::min_by_key</source>
          <target state="translated">Bytes::min_by_key</target>
        </trans-unit>
        <trans-unit id="be90f56db4ada597b587d016fd327003ea0bc760" translate="yes" xml:space="preserve">
          <source>Bytes::ne</source>
          <target state="translated">Bytes::ne</target>
        </trans-unit>
        <trans-unit id="d23038a4910063cad42deff4ad9cf09d48b283fc" translate="yes" xml:space="preserve">
          <source>Bytes::next</source>
          <target state="translated">Bytes::next</target>
        </trans-unit>
        <trans-unit id="8748f7bca019be483c7116e17eaefea91e8337c8" translate="yes" xml:space="preserve">
          <source>Bytes::next_back</source>
          <target state="translated">Bytes::next_back</target>
        </trans-unit>
        <trans-unit id="1a968f4f100322f4def3905de036617309b7b5ca" translate="yes" xml:space="preserve">
          <source>Bytes::nth</source>
          <target state="translated">Bytes::nth</target>
        </trans-unit>
        <trans-unit id="7015bc5abccea19494e4724bb7c18d8ce992e0ad" translate="yes" xml:space="preserve">
          <source>Bytes::nth_back</source>
          <target state="translated">Bytes::nth_back</target>
        </trans-unit>
        <trans-unit id="984cab5be49f32fc6d25120ded4daae67af8fff5" translate="yes" xml:space="preserve">
          <source>Bytes::partial_cmp</source>
          <target state="translated">Bytes::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c5a60b3f92a5a9558e9901c7ea8df4400c6ec0e1" translate="yes" xml:space="preserve">
          <source>Bytes::partition</source>
          <target state="translated">Bytes::partition</target>
        </trans-unit>
        <trans-unit id="fd964e1b6678d8175a0f6d2defa63df03aeae2a2" translate="yes" xml:space="preserve">
          <source>Bytes::peekable</source>
          <target state="translated">Bytes::peekable</target>
        </trans-unit>
        <trans-unit id="7a779a538f4d43ba65ab857aaed4f38c84785133" translate="yes" xml:space="preserve">
          <source>Bytes::position</source>
          <target state="translated">Bytes::position</target>
        </trans-unit>
        <trans-unit id="e26b896020a4dd543d300e63cedf53c6c693b23f" translate="yes" xml:space="preserve">
          <source>Bytes::product</source>
          <target state="translated">Bytes::product</target>
        </trans-unit>
        <trans-unit id="9520a4396d3dd25e6d144b70f3b61774361a54c7" translate="yes" xml:space="preserve">
          <source>Bytes::rev</source>
          <target state="translated">Bytes::rev</target>
        </trans-unit>
        <trans-unit id="c91ff74ba08c7c6ea28c25fc12b5996c8b1497a4" translate="yes" xml:space="preserve">
          <source>Bytes::rfind</source>
          <target state="translated">Bytes::rfind</target>
        </trans-unit>
        <trans-unit id="6d8c28436a470bc527732d151cc6081f1ba37f43" translate="yes" xml:space="preserve">
          <source>Bytes::rfold</source>
          <target state="translated">Bytes::rfold</target>
        </trans-unit>
        <trans-unit id="952ea423fc26cfa8babe6fc58fba9d219ed14f15" translate="yes" xml:space="preserve">
          <source>Bytes::rposition</source>
          <target state="translated">Bytes::rposition</target>
        </trans-unit>
        <trans-unit id="5ca3ed55d60687599d621bf21650f4ef1969fe93" translate="yes" xml:space="preserve">
          <source>Bytes::scan</source>
          <target state="translated">Bytes::scan</target>
        </trans-unit>
        <trans-unit id="ab036dbdadf0542cb3bddc197d995e0027d66c95" translate="yes" xml:space="preserve">
          <source>Bytes::size_hint</source>
          <target state="translated">Bytes::size_hint</target>
        </trans-unit>
        <trans-unit id="7aea93693f858b30cc323b010a39049b5066d25e" translate="yes" xml:space="preserve">
          <source>Bytes::skip</source>
          <target state="translated">Bytes::skip</target>
        </trans-unit>
        <trans-unit id="1238ebec8be4b2a081cb75d76acedcc89efe036e" translate="yes" xml:space="preserve">
          <source>Bytes::skip_while</source>
          <target state="translated">Bytes::skip_while</target>
        </trans-unit>
        <trans-unit id="9c76a1cf5e4f9d6e469d340364ab845f02735723" translate="yes" xml:space="preserve">
          <source>Bytes::step_by</source>
          <target state="translated">Bytes::step_by</target>
        </trans-unit>
        <trans-unit id="79350f102ae506e77c2e1822a20d032e242e08cf" translate="yes" xml:space="preserve">
          <source>Bytes::sum</source>
          <target state="translated">Bytes::sum</target>
        </trans-unit>
        <trans-unit id="4668fe7f8a3335637251054d9c9c06434224fd9e" translate="yes" xml:space="preserve">
          <source>Bytes::take</source>
          <target state="translated">Bytes::take</target>
        </trans-unit>
        <trans-unit id="8188c9f2c65727da6ad6418e7435a0a4d4ae1b63" translate="yes" xml:space="preserve">
          <source>Bytes::take_while</source>
          <target state="translated">Bytes::take_while</target>
        </trans-unit>
        <trans-unit id="1e3d429d72ab5a83b39ca62419e469d95fab4a82" translate="yes" xml:space="preserve">
          <source>Bytes::to_owned</source>
          <target state="translated">Bytes::to_owned</target>
        </trans-unit>
        <trans-unit id="557ed7e76c591066179253aea6bd6a17cfa01f82" translate="yes" xml:space="preserve">
          <source>Bytes::try_fold</source>
          <target state="translated">Bytes::try_fold</target>
        </trans-unit>
        <trans-unit id="3a174ee7598d8449eeadbf2f070bb9163bfdbeef" translate="yes" xml:space="preserve">
          <source>Bytes::try_for_each</source>
          <target state="translated">Bytes::try_for_each</target>
        </trans-unit>
        <trans-unit id="35ddd98f9595299a1b8243f3586e6b1c8d7fa048" translate="yes" xml:space="preserve">
          <source>Bytes::try_from</source>
          <target state="translated">Bytes::try_from</target>
        </trans-unit>
        <trans-unit id="fdf97aa086611d5f965642e0fa40ebed09455a54" translate="yes" xml:space="preserve">
          <source>Bytes::try_into</source>
          <target state="translated">Bytes::try_into</target>
        </trans-unit>
        <trans-unit id="e81eae2ced7b712e89d1325cb3b29c2687db0961" translate="yes" xml:space="preserve">
          <source>Bytes::try_rfold</source>
          <target state="translated">Bytes::try_rfold</target>
        </trans-unit>
        <trans-unit id="93ac1e902ab13110128cd8b40340c9498d027d14" translate="yes" xml:space="preserve">
          <source>Bytes::type_id</source>
          <target state="translated">Bytes::type_id</target>
        </trans-unit>
        <trans-unit id="b8daa236d91d2a612c5d7612ed9d46cc96bcda6a" translate="yes" xml:space="preserve">
          <source>Bytes::unzip</source>
          <target state="translated">Bytes::unzip</target>
        </trans-unit>
        <trans-unit id="47375bdc573035dbf1f0a151a6ddce0a88145906" translate="yes" xml:space="preserve">
          <source>Bytes::zip</source>
          <target state="translated">Bytes::zip</target>
        </trans-unit>
        <trans-unit id="10de289426da74ae5996820227d1ae99ba3ca1bf" translate="yes" xml:space="preserve">
          <source>C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character &lt;code&gt;'\0'&lt;/code&gt;. See &lt;a href=&quot;../../ffi/struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">C字符最常用于制作C字符串。与Rust不同的是，Rust的字符串长度包含在字符串的旁边，而C字符串则以字符 &lt;code&gt;'\0'&lt;/code&gt; 标记字符串的结尾。有关更多信息，请参见&lt;a href=&quot;../../ffi/struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec4ff1ee46ab9f978c49b43b23216a55c335e53d" translate="yes" xml:space="preserve">
          <source>C strings are different from Rust strings:</source>
          <target state="translated">C 字符串与 Rust 字符串不同。</target>
        </trans-unit>
        <trans-unit id="4d0a3cd3d0843046e9dc208601e2f872fffb7682" translate="yes" xml:space="preserve">
          <source>C#: attributes</source>
          <target state="translated">C#:属性</target>
        </trans-unit>
        <trans-unit id="8f7e71dd73911b35b0704326383804842772d25d" translate="yes" xml:space="preserve">
          <source>C++: references, RAII, smart pointers, move semantics, monomorphization, memory model</source>
          <target state="translated">C++:引用、RAII、智能指针、移动语义、单态化、内存模型。</target>
        </trans-unit>
        <trans-unit id="d6f809f9a8c2683f3d057fe632dca0828c0f7e4a" translate="yes" xml:space="preserve">
          <source>C-like enum</source>
          <target state="translated">类C列举</target>
        </trans-unit>
        <trans-unit id="ce41a223396980a3e03634cbe778c52da0c75b6e" translate="yes" xml:space="preserve">
          <source>CAPITAL</source>
          <target state="translated">CAPITAL</target>
        </trans-unit>
        <trans-unit id="ee6b489f0289728c3819dc331f1663c96ca0785c" translate="yes" xml:space="preserve">
          <source>CHAR_LITERAL</source>
          <target state="translated">CHAR_LITERAL</target>
        </trans-unit>
        <trans-unit id="69b56ccff3a6c4424734f57c05d156739380a264" translate="yes" xml:space="preserve">
          <source>CHAR_LITERAL :</source>
          <target state="translated">CHAR_LITERAL :</target>
        </trans-unit>
        <trans-unit id="c855bb9cac705e9e3b723e75b21f4d07cd808dc4" translate="yes" xml:space="preserve">
          <source>CStr</source>
          <target state="translated">CStr</target>
        </trans-unit>
        <trans-unit id="6d8a542fd21b3338ea60a85ae47f0c199d520fae" translate="yes" xml:space="preserve">
          <source>CStr::as_ptr</source>
          <target state="translated">CStr::as_ptr</target>
        </trans-unit>
        <trans-unit id="1f95e3e4ec8be2f019c66897e9c3b6624d851e96" translate="yes" xml:space="preserve">
          <source>CStr::as_ref</source>
          <target state="translated">CStr::as_ref</target>
        </trans-unit>
        <trans-unit id="d700139dd31629deaacc42e4bc9a9d4d45caef0d" translate="yes" xml:space="preserve">
          <source>CStr::borrow</source>
          <target state="translated">CStr::borrow</target>
        </trans-unit>
        <trans-unit id="cc55b0f7e0eedd59a730a23f4f91745521f7abe7" translate="yes" xml:space="preserve">
          <source>CStr::borrow_mut</source>
          <target state="translated">CStr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcca1c0586380cf9ec8aaa4478ef4dea99e9db80" translate="yes" xml:space="preserve">
          <source>CStr::clamp</source>
          <target state="translated">CStr::clamp</target>
        </trans-unit>
        <trans-unit id="95ad44c6acf49d720b284daa7324a4c4e8ee9b77" translate="yes" xml:space="preserve">
          <source>CStr::clone_into</source>
          <target state="translated">CStr::clone_into</target>
        </trans-unit>
        <trans-unit id="17ee9041b05f19b08c9a207a0b264abb06217788" translate="yes" xml:space="preserve">
          <source>CStr::cmp</source>
          <target state="translated">CStr::cmp</target>
        </trans-unit>
        <trans-unit id="ef2eafc91f57240446e72aeaeeb2a32e68e97a8b" translate="yes" xml:space="preserve">
          <source>CStr::default</source>
          <target state="translated">CStr::default</target>
        </trans-unit>
        <trans-unit id="54ffaa14459cec5f2273ff104ef1742c78574036" translate="yes" xml:space="preserve">
          <source>CStr::eq</source>
          <target state="translated">CStr::eq</target>
        </trans-unit>
        <trans-unit id="0c4c69764320e8a42e866e61f90c9ac980102de3" translate="yes" xml:space="preserve">
          <source>CStr::fmt</source>
          <target state="translated">CStr::fmt</target>
        </trans-unit>
        <trans-unit id="e9fd5cc915fb0074a2adb82bcea1b9cf07e8ac22" translate="yes" xml:space="preserve">
          <source>CStr::from</source>
          <target state="translated">CStr::from</target>
        </trans-unit>
        <trans-unit id="fef3690a19e427664444d03dfffa43ae3fa6be59" translate="yes" xml:space="preserve">
          <source>CStr::from_bytes_with_nul</source>
          <target state="translated">CStr::from_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="75111e68b3cace6dc1f25160989a55c75672d185" translate="yes" xml:space="preserve">
          <source>CStr::from_bytes_with_nul_unchecked</source>
          <target state="translated">CStr::from_bytes_with_nul_unchecked</target>
        </trans-unit>
        <trans-unit id="137aefe4f0efa206a17e644e536709f7164f7036" translate="yes" xml:space="preserve">
          <source>CStr::from_ptr</source>
          <target state="translated">CStr::from_ptr</target>
        </trans-unit>
        <trans-unit id="3445b2e9c6d30848e46a0c458e92c18f5478648a" translate="yes" xml:space="preserve">
          <source>CStr::ge</source>
          <target state="translated">CStr::ge</target>
        </trans-unit>
        <trans-unit id="728fbce40efc66cebd46be16b8f1cf779090113f" translate="yes" xml:space="preserve">
          <source>CStr::gt</source>
          <target state="translated">CStr::gt</target>
        </trans-unit>
        <trans-unit id="be0afeee394794477755e07edeb627b53d61bdf3" translate="yes" xml:space="preserve">
          <source>CStr::hash</source>
          <target state="translated">CStr::hash</target>
        </trans-unit>
        <trans-unit id="bb72c84064e334eba596cbe9844aa70e70ee849a" translate="yes" xml:space="preserve">
          <source>CStr::hash_slice</source>
          <target state="translated">CStr::hash_slice</target>
        </trans-unit>
        <trans-unit id="c6bf567f09e2b2bd042059269552397aad871cae" translate="yes" xml:space="preserve">
          <source>CStr::into_c_string</source>
          <target state="translated">CStr::into_c_string</target>
        </trans-unit>
        <trans-unit id="69ab262092debd4569770196660f4febe98420dc" translate="yes" xml:space="preserve">
          <source>CStr::le</source>
          <target state="translated">CStr::le</target>
        </trans-unit>
        <trans-unit id="f1e9e41f63590d10b51a2a294c025ee665034901" translate="yes" xml:space="preserve">
          <source>CStr::lt</source>
          <target state="translated">CStr::lt</target>
        </trans-unit>
        <trans-unit id="348c458cc35acb0213f545d380dceae16ee7b792" translate="yes" xml:space="preserve">
          <source>CStr::max</source>
          <target state="translated">CStr::max</target>
        </trans-unit>
        <trans-unit id="000883cbb32a65bd5d06415a6ea2b885840b8dea" translate="yes" xml:space="preserve">
          <source>CStr::min</source>
          <target state="translated">CStr::min</target>
        </trans-unit>
        <trans-unit id="9f6acbf3ad450fc26ec407cb9b07020457f45140" translate="yes" xml:space="preserve">
          <source>CStr::ne</source>
          <target state="translated">CStr::ne</target>
        </trans-unit>
        <trans-unit id="7abb5f8b92e7fded6ba1d77d76970093cc652367" translate="yes" xml:space="preserve">
          <source>CStr::partial_cmp</source>
          <target state="translated">CStr::partial_cmp</target>
        </trans-unit>
        <trans-unit id="65caa5cdc2514ebded75efc52eddee11acbc1be0" translate="yes" xml:space="preserve">
          <source>CStr::to_bytes</source>
          <target state="translated">CStr::to_bytes</target>
        </trans-unit>
        <trans-unit id="e4257d44ce77a2f26ac5c252e77fb8c42eef081a" translate="yes" xml:space="preserve">
          <source>CStr::to_bytes_with_nul</source>
          <target state="translated">CStr::to_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="44ead7aea7dc02cf1786c76006d27afcf9a480c8" translate="yes" xml:space="preserve">
          <source>CStr::to_owned</source>
          <target state="translated">CStr::to_owned</target>
        </trans-unit>
        <trans-unit id="ad62220819d69a73a1b88d26957191be23aa8128" translate="yes" xml:space="preserve">
          <source>CStr::to_str</source>
          <target state="translated">CStr::to_str</target>
        </trans-unit>
        <trans-unit id="f8b6323ef660a7621fafb52f71e3630988494495" translate="yes" xml:space="preserve">
          <source>CStr::to_string_lossy</source>
          <target state="translated">CStr::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="1cc3da01043c1b71efdad57e85215058364b7064" translate="yes" xml:space="preserve">
          <source>CStr::type_id</source>
          <target state="translated">CStr::type_id</target>
        </trans-unit>
        <trans-unit id="10fdabde5da32be8abb7d3568067d963d8ef529e" translate="yes" xml:space="preserve">
          <source>CString</source>
          <target state="translated">CString</target>
        </trans-unit>
        <trans-unit id="52e001b95a1b9cf3308a26a6e981035005eab758" translate="yes" xml:space="preserve">
          <source>CString::as_bytes</source>
          <target state="translated">CString::as_bytes</target>
        </trans-unit>
        <trans-unit id="13cab1dddf5c51f1e61f9eee6b49a5636b9bd814" translate="yes" xml:space="preserve">
          <source>CString::as_bytes_with_nul</source>
          <target state="translated">CString::as_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="797335508475be49326111108ab36a086a72caa3" translate="yes" xml:space="preserve">
          <source>CString::as_c_str</source>
          <target state="translated">CString::as_c_str</target>
        </trans-unit>
        <trans-unit id="7de000d37b9a976d4527e4c70754ba8afd0351c7" translate="yes" xml:space="preserve">
          <source>CString::as_ptr</source>
          <target state="translated">CString::as_ptr</target>
        </trans-unit>
        <trans-unit id="bc0fb3daa028d7ff58f6946c49b2f5b96bc9d602" translate="yes" xml:space="preserve">
          <source>CString::as_ref</source>
          <target state="translated">CString::as_ref</target>
        </trans-unit>
        <trans-unit id="36a33aa7aa5aa4d2d81432af9a988f0f942736ad" translate="yes" xml:space="preserve">
          <source>CString::borrow</source>
          <target state="translated">CString::borrow</target>
        </trans-unit>
        <trans-unit id="8528461b0edd762ff495176944d805d1dde0f8ec" translate="yes" xml:space="preserve">
          <source>CString::borrow_mut</source>
          <target state="translated">CString::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2a50234e42cd54310e4916caa569a9a5aa96a13c" translate="yes" xml:space="preserve">
          <source>CString::clamp</source>
          <target state="translated">CString::clamp</target>
        </trans-unit>
        <trans-unit id="24f213d2e0d20a811ae38f00f41648ad4c89ab8e" translate="yes" xml:space="preserve">
          <source>CString::clone</source>
          <target state="translated">CString::clone</target>
        </trans-unit>
        <trans-unit id="7f0df7e2af8f0985cf2add0b160cbcac287070e5" translate="yes" xml:space="preserve">
          <source>CString::clone_from</source>
          <target state="translated">CString::clone_from</target>
        </trans-unit>
        <trans-unit id="3cabdc5e34bb6bea49169d33f360d4ee04f6ed25" translate="yes" xml:space="preserve">
          <source>CString::clone_into</source>
          <target state="translated">CString::clone_into</target>
        </trans-unit>
        <trans-unit id="d7277d1a271df4865a6f33570de006450712f4a0" translate="yes" xml:space="preserve">
          <source>CString::cmp</source>
          <target state="translated">CString::cmp</target>
        </trans-unit>
        <trans-unit id="baa89c11dc8118d826240007d81976bd7413a3b6" translate="yes" xml:space="preserve">
          <source>CString::default</source>
          <target state="translated">CString::default</target>
        </trans-unit>
        <trans-unit id="347d98047b56cd9966454be82309f4e8529682ff" translate="yes" xml:space="preserve">
          <source>CString::deref</source>
          <target state="translated">CString::deref</target>
        </trans-unit>
        <trans-unit id="ab34938730f49553f7aecab1bb2c2843aa651704" translate="yes" xml:space="preserve">
          <source>CString::drop</source>
          <target state="translated">CString::drop</target>
        </trans-unit>
        <trans-unit id="60996dc07ecd992dd60d5ceec16cc375ea67d6b9" translate="yes" xml:space="preserve">
          <source>CString::eq</source>
          <target state="translated">CString::eq</target>
        </trans-unit>
        <trans-unit id="e70be0cad84fe664f3a9891f184d6d6a7283a582" translate="yes" xml:space="preserve">
          <source>CString::fmt</source>
          <target state="translated">CString::fmt</target>
        </trans-unit>
        <trans-unit id="cbf381ece793251aee2eeadc010afe3c0f4a86e0" translate="yes" xml:space="preserve">
          <source>CString::from</source>
          <target state="translated">CString::from</target>
        </trans-unit>
        <trans-unit id="a143620acced132aa78acde78ce1bd6ab7b63f7e" translate="yes" xml:space="preserve">
          <source>CString::from_raw</source>
          <target state="translated">CString::from_raw</target>
        </trans-unit>
        <trans-unit id="dc9b49de9e2271c2ed3506615af6e6d8c4861395" translate="yes" xml:space="preserve">
          <source>CString::from_vec_unchecked</source>
          <target state="translated">CString::from_vec_unchecked</target>
        </trans-unit>
        <trans-unit id="1a539736b4bb0e500f677893082fd23c664398df" translate="yes" xml:space="preserve">
          <source>CString::ge</source>
          <target state="translated">CString::ge</target>
        </trans-unit>
        <trans-unit id="668f249df3f7a2e1e7a9e166dd065bd8ea489b01" translate="yes" xml:space="preserve">
          <source>CString::gt</source>
          <target state="translated">CString::gt</target>
        </trans-unit>
        <trans-unit id="e46cf065cca5e3cd1f01cce699aa22189f1cb26b" translate="yes" xml:space="preserve">
          <source>CString::hash</source>
          <target state="translated">CString::hash</target>
        </trans-unit>
        <trans-unit id="0833d863637dfd6ed73ce7a7ea13d011f707f04d" translate="yes" xml:space="preserve">
          <source>CString::hash_slice</source>
          <target state="translated">CString::hash_slice</target>
        </trans-unit>
        <trans-unit id="432d0b1932bbe3eb2d6ef0fa7ec29b9397259ae9" translate="yes" xml:space="preserve">
          <source>CString::index</source>
          <target state="translated">CString::index</target>
        </trans-unit>
        <trans-unit id="cd0ce393340efaa8f18ad5cb50aad07f3d2eeea4" translate="yes" xml:space="preserve">
          <source>CString::into</source>
          <target state="translated">CString::into</target>
        </trans-unit>
        <trans-unit id="59bfaa59d401f415773f033626b7896ccc5c6f79" translate="yes" xml:space="preserve">
          <source>CString::into_boxed_c_str</source>
          <target state="translated">CString::into_boxed_c_str</target>
        </trans-unit>
        <trans-unit id="96b480440e4b607a24895b6512350ea1afafd31c" translate="yes" xml:space="preserve">
          <source>CString::into_bytes</source>
          <target state="translated">CString::into_bytes</target>
        </trans-unit>
        <trans-unit id="cc5eefdedab1063685f507370a9d8ab88c34cbda" translate="yes" xml:space="preserve">
          <source>CString::into_bytes_with_nul</source>
          <target state="translated">CString::into_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="aefcc1dc128b6b5cd3742344d58563aafb746370" translate="yes" xml:space="preserve">
          <source>CString::into_raw</source>
          <target state="translated">CString::into_raw</target>
        </trans-unit>
        <trans-unit id="f2693a15445d228f3db30100d51e43c8372af6e2" translate="yes" xml:space="preserve">
          <source>CString::into_string</source>
          <target state="translated">CString::into_string</target>
        </trans-unit>
        <trans-unit id="8bee9b3af5aa7e5de7c21a5ebc17b1acccf5ee8e" translate="yes" xml:space="preserve">
          <source>CString::le</source>
          <target state="translated">CString::le</target>
        </trans-unit>
        <trans-unit id="a139512687d9e3c6e3a92b9473958b2f7df1eb47" translate="yes" xml:space="preserve">
          <source>CString::lt</source>
          <target state="translated">CString::lt</target>
        </trans-unit>
        <trans-unit id="eaaa87d3cf20a5d0e070b569e586340d5ecb604f" translate="yes" xml:space="preserve">
          <source>CString::max</source>
          <target state="translated">CString::max</target>
        </trans-unit>
        <trans-unit id="72b7071a2efa7b6ad66daf332571bc9f191bed64" translate="yes" xml:space="preserve">
          <source>CString::min</source>
          <target state="translated">CString::min</target>
        </trans-unit>
        <trans-unit id="2516dc9b57566e8c9c5ced5df9a3f6886f48ed5c" translate="yes" xml:space="preserve">
          <source>CString::ne</source>
          <target state="translated">CString::ne</target>
        </trans-unit>
        <trans-unit id="057c250d247622d3e7250ede8d66d4f4fe5f006a" translate="yes" xml:space="preserve">
          <source>CString::new</source>
          <target state="translated">CString::new</target>
        </trans-unit>
        <trans-unit id="eff1b495447d52f2ff92fe44126c3e0f7e62bd18" translate="yes" xml:space="preserve">
          <source>CString::partial_cmp</source>
          <target state="translated">CString::partial_cmp</target>
        </trans-unit>
        <trans-unit id="ba7cc72bb439ffacb3c246cdf7d4ea38bf7c37ba" translate="yes" xml:space="preserve">
          <source>CString::to_bytes</source>
          <target state="translated">CString::to_bytes</target>
        </trans-unit>
        <trans-unit id="52c93cc3f089d3ead1daed54786cb1adefbefc0e" translate="yes" xml:space="preserve">
          <source>CString::to_bytes_with_nul</source>
          <target state="translated">CString::to_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="d066a96cc2aeab0a52ff35a69bfade1ebb5b679e" translate="yes" xml:space="preserve">
          <source>CString::to_owned</source>
          <target state="translated">CString::to_owned</target>
        </trans-unit>
        <trans-unit id="2511594a074122956a7b9aac6c3b45531240e7fc" translate="yes" xml:space="preserve">
          <source>CString::to_str</source>
          <target state="translated">CString::to_str</target>
        </trans-unit>
        <trans-unit id="b9d046be15dc8b7b1d4ad0b19b0da5323bf450ae" translate="yes" xml:space="preserve">
          <source>CString::to_string_lossy</source>
          <target state="translated">CString::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="9d84fa601d6e1d36b0d57472ca64c553b64dab03" translate="yes" xml:space="preserve">
          <source>CString::try_from</source>
          <target state="translated">CString::try_from</target>
        </trans-unit>
        <trans-unit id="f11ef73d8e97b738c053ffd9938664b3d2273bd5" translate="yes" xml:space="preserve">
          <source>CString::try_into</source>
          <target state="translated">CString::try_into</target>
        </trans-unit>
        <trans-unit id="1a51fb95b46c52bf3add938b9cfe7d50ef6bacbf" translate="yes" xml:space="preserve">
          <source>CString::type_id</source>
          <target state="translated">CString::type_id</target>
        </trans-unit>
        <trans-unit id="ec9fe493034beaebc0e01624240518933e14a78a" translate="yes" xml:space="preserve">
          <source>Caching values is a generally useful behavior that we might want to use in other parts of our code with different closures. However, there are two problems with the current implementation of &lt;code&gt;Cacher&lt;/code&gt; that would make reusing it in different contexts difficult.</source>
          <target state="translated">缓存值是一种普遍有用的行为，我们可能希望在代码的其他部分使用不同的闭包。但是，当前 &lt;code&gt;Cacher&lt;/code&gt; 的实现存在两个问题，这将使在不同环境下重用它很困难。</target>
        </trans-unit>
        <trans-unit id="ca70ff3bbc1574ec864e13a85775af1c9fd2dc54" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;self&lt;/code&gt; + &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">计算 &lt;code&gt;self&lt;/code&gt; + &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c60cc01325d6ae275f88e47a24f1234f7eab35f7" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;self&lt;/code&gt; - &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">计算 &lt;code&gt;self&lt;/code&gt; - &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2ce2b6e7049ed5ebef3ea78f7f49e41b51d70f5" translate="yes" xml:space="preserve">
          <source>Calculates Euclidean division, the matching method for &lt;code&gt;rem_euclid&lt;/code&gt;.</source>
          <target state="translated">计算欧几里得除法，这是 &lt;code&gt;rem_euclid&lt;/code&gt; 的匹配方法。</target>
        </trans-unit>
        <trans-unit id="9f1a1acd0979000f557bd9fe260b8e844069c43f" translate="yes" xml:space="preserve">
          <source>Calculates the distance between two pointers. The returned value is in units of T: the distance in bytes is divided by &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;.</source>
          <target state="translated">计算两个指针之间的距离。返回的值以T为单位：以字节为单位的距离除以 &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5127f08bc025120d1faa493287d1d0eee0006108" translate="yes" xml:space="preserve">
          <source>Calculates the divisor when &lt;code&gt;self&lt;/code&gt; is divided by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;self&lt;/code&gt; 除以 &lt;code&gt;rhs&lt;/code&gt; 时计算除数。</target>
        </trans-unit>
        <trans-unit id="fc217ee649e4f99c72864fd7fe451c173d18439f" translate="yes" xml:space="preserve">
          <source>Calculates the least nonnegative remainder of &lt;code&gt;self (mod rhs)&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;self (mod rhs)&lt;/code&gt; 的最小非负余数（mod rhs）。</target>
        </trans-unit>
        <trans-unit id="aa698abba4132e7de76a90696509e57b698e9680" translate="yes" xml:space="preserve">
          <source>Calculates the least remainder of &lt;code&gt;self (mod rhs)&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;self (mod rhs)&lt;/code&gt; 的最小余数（mod rhs）。</target>
        </trans-unit>
        <trans-unit id="c7ea3c4efe85a6701802881e07221808f6b72f10" translate="yes" xml:space="preserve">
          <source>Calculates the length of the hypotenuse of a right-angle triangle given legs of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">给定腿长 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ,计算直角三角形的斜边的长度。</target>
        </trans-unit>
        <trans-unit id="2204ea9d183af2eb3c958e206adf62733fcb72b8" translate="yes" xml:space="preserve">
          <source>Calculates the multiplication of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 的乘积。</target>
        </trans-unit>
        <trans-unit id="e1f0a45d6193bb4f48999acaf0e6da752bd21197" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer (convenience for &lt;code&gt;.offset((count as isize).wrapping_neg())&lt;/code&gt;).</source>
          <target state="translated">计算指针的偏移量（ &lt;code&gt;.offset((count as isize).wrapping_neg())&lt;/code&gt; 便利））。</target>
        </trans-unit>
        <trans-unit id="2cdd04036e314797a2d49a1129ff94310c799250" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer (convenience for &lt;code&gt;.offset(count as isize)&lt;/code&gt;).</source>
          <target state="translated">计算指针的偏移量（ &lt;code&gt;.offset(count as isize)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5c58135d353fa0b65d9d7d232ccec38157ca294b" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic.</source>
          <target state="translated">使用包装算术计算指针的偏移量。</target>
        </trans-unit>
        <trans-unit id="3a96ac2990d9d6aa59d405db07b7ab3697d51ab5" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. (convenience for &lt;code&gt;.wrapping_offset((count as isize).wrapping_sub())&lt;/code&gt;)</source>
          <target state="translated">使用包装算法计算与指针的偏移量。（ &lt;code&gt;.wrapping_offset((count as isize).wrapping_sub())&lt;/code&gt; 便利））</target>
        </trans-unit>
        <trans-unit id="4437f7540901d3da485cf44951a321623f5d54ea" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. (convenience for &lt;code&gt;.wrapping_offset(count as isize)&lt;/code&gt;)</source>
          <target state="translated">使用包装算法计算与指针的偏移量。（ &lt;code&gt;.wrapping_offset(count as isize)&lt;/code&gt; 便利）</target>
        </trans-unit>
        <trans-unit id="fced3b907bf59a9a00c1e327030e6d3af8cc26ee" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. &lt;code&gt;count&lt;/code&gt; is in units of T; e.g., a &lt;code&gt;count&lt;/code&gt; of 3 represents a pointer offset of &lt;code&gt;3 * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">使用包装算法计算与指针的偏移量。 &lt;code&gt;count&lt;/code&gt; 以T为单位；例如， &lt;code&gt;count&lt;/code&gt; 3表示指针偏移量 &lt;code&gt;3 * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="bb349c3d2b61d501336bb2fe8cf2ff557d376135" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer, potentially wrapping.</source>
          <target state="translated">计算指针的偏移量,可能是包装。</target>
        </trans-unit>
        <trans-unit id="bceae705a5fda0d95a2adc01d7e85d8d0a2f7b90" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer.</source>
          <target state="translated">计算指针的偏移量。</target>
        </trans-unit>
        <trans-unit id="20e05ec484d26186b0ee114ebaa6c93c15ef1c02" translate="yes" xml:space="preserve">
          <source>Calculates the quotient of Euclidean division &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;.</source>
          <target state="translated">计算欧几里得除数 &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; 的商。</target>
        </trans-unit>
        <trans-unit id="39720ba2c3f54664835e5cfd429b8dbb6ddb3ddb" translate="yes" xml:space="preserve">
          <source>Calculates the quotient of Euclidean division of &lt;code&gt;self&lt;/code&gt; by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">计算的欧几里得除法的商 &lt;code&gt;self&lt;/code&gt; 的 &lt;code&gt;rhs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5a8c64bc432948fb8acbf8240c8594765e8fa48" translate="yes" xml:space="preserve">
          <source>Calculates the remainder &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; as if by Euclidean division.</source>
          <target state="translated">以欧几里得除法计算剩余的 &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd73ba699034056b9c5150298e8d456b025d264b" translate="yes" xml:space="preserve">
          <source>Calculates the remainder when &lt;code&gt;self&lt;/code&gt; is divided by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;self&lt;/code&gt; 除以 &lt;code&gt;rhs&lt;/code&gt; 时的余数。</target>
        </trans-unit>
        <trans-unit id="beb148e8941aab843a69c5323a4e82bfc27fae30" translate="yes" xml:space="preserve">
          <source>Calculations in applications like audio decoders often prioritize performance most highly. Here, we&amp;rsquo;re creating an iterator, using two adaptors, and then consuming the value. What assembly code would this Rust code compile to? Well, as of this writing, it compiles down to the same assembly you&amp;rsquo;d write by hand. There&amp;rsquo;s no loop at all corresponding to the iteration over the values in &lt;code&gt;coefficients&lt;/code&gt;: Rust knows that there are 12 iterations, so it &amp;ldquo;unrolls&amp;rdquo; the loop. &lt;em&gt;Unrolling&lt;/em&gt; is an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.</source>
          <target state="translated">诸如音频解码器之类的应用程序中的计算通常会优先考虑性能。在这里，我们使用两个适配器创建一个迭代器，然后使用该值。该Rust代码将编译为什么汇编代码？好吧，在撰写本文时，它可以编译为您用手编写的同一程序集。有一个在所有相应于迭过的值没有循环 &lt;code&gt;coefficients&lt;/code&gt; ：铁锈知道有12次迭代，所以它&amp;ldquo;解开&amp;rdquo;循环。&lt;em&gt;展开&lt;/em&gt;是一种优化，它消除了循环控制代码的开销，而是为循环的每次迭代生成重复的代码。</target>
        </trans-unit>
        <trans-unit id="f8b36fa1c392c82310456798302780289916c221" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;unsafe&lt;/code&gt; functions</source>
          <target state="translated">调用 &lt;code&gt;unsafe&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="21f282ae75f0466a6ba7a1e840066c459209e8a0" translate="yes" xml:space="preserve">
          <source>Call an unsafe function or method</source>
          <target state="translated">调用一个不安全的函数或方法</target>
        </trans-unit>
        <trans-unit id="0298ffd4d4d74b375411d1b2e3969f0f3205473d" translate="yes" xml:space="preserve">
          <source>Call expressions</source>
          <target state="translated">呼叫表达式</target>
        </trans-unit>
        <trans-unit id="6249f8a9ffd810d4ed69b84e3c802196af864e8b" translate="yes" xml:space="preserve">
          <source>Call traits and coercions</source>
          <target state="translated">呼叫特征和胁迫</target>
        </trans-unit>
        <trans-unit id="0c2ff20766f3c9231511aafd553b6c2bff815c3d" translate="yes" xml:space="preserve">
          <source>Callers in turn must expect the source to be in any state that is consistent with its public API since adapters sitting between it and the source have the same access. In particular an adapter may have consumed more elements than strictly necessary.</source>
          <target state="translated">调用者则必须期望源处于与其公共API一致的任何状态,因为位于它和源之间的适配器具有相同的访问权限。特别是适配器可能消耗了超过严格必要的元素。</target>
        </trans-unit>
        <trans-unit id="3c586bbc683322c086eef8701f61479b8313e2e3" translate="yes" xml:space="preserve">
          <source>Callers of memory allocation APIs wishing to abort computation in response to an allocation error are encouraged to call this function, rather than directly invoking &lt;code&gt;panic!&lt;/code&gt; or similar.</source>
          <target state="translated">鼓励那些希望响应分配错误而中止计算的内存分配API调用者调用此函数，而不是直接引发 &lt;code&gt;panic!&lt;/code&gt; 或类似。</target>
        </trans-unit>
        <trans-unit id="0a1fed80ce769e9299beec7ef90b5a7b9c915af1" translate="yes" xml:space="preserve">
          <source>Callers of this function are responsible that these preconditions are satisfied:</source>
          <target state="translated">该函数的调用者要负责满足这些前提条件。</target>
        </trans-unit>
        <trans-unit id="d1c291d9a0fdcacf48fd819bb42d20e5d81ebaea" translate="yes" xml:space="preserve">
          <source>Callers of this function are responsible that three preconditions are satisfied:</source>
          <target state="translated">该函数的调用者负责满足三个前提条件。</target>
        </trans-unit>
        <trans-unit id="7d8639a217f023f0e5aaf72760a98b8b29436661" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing.</source>
          <target state="translated">调用&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;（或其他环绕它的函数）将使父进程等待直到子进程实际退出后再继续。</target>
        </trans-unit>
        <trans-unit id="481d687176f898ccda26367fc40f1ddb55f0bae7" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing.</source>
          <target state="translated">调用&lt;a href=&quot;struct.child#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;（或其他环绕它的函数）将使父进程等待，直到子进程实际退出后才能继续。</target>
        </trans-unit>
        <trans-unit id="b5deeaea616be877d309408666a16c136418ff8a" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; guarantees that at least one value of the iterator's underlying source has been moved out and the result of the iterator chain could be inserted in its place, assuming structural constraints of the source allow such an insertion. In other words this trait indicates that an iterator pipeline can be collected in place.</source>
          <target state="translated">调用&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;保证迭代器的基础源的至少一个值已移出，并且迭代器链的结果可以插入到它的位置，假设源的结构约束允许这种插入。换句话说，此特征表明可以在适当位置收集迭代器管道。</target>
        </trans-unit>
        <trans-unit id="2e7c98d8910ba30f7a29fe334c3bdf59a65f7d25" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; this way gets repetitive. Rust has a construct which can call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; on your iterator, until it reaches &lt;code&gt;None&lt;/code&gt;. Let's go over that next.</source>
          <target state="translated">这种方式&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;调用变得重复。Rust具有一个可以在迭代器上调用&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;的构造，直到达到 &lt;code&gt;None&lt;/code&gt; 为止。让我们接下来再说。</target>
        </trans-unit>
        <trans-unit id="062a68bd5946d6865cea7336de4cb67da3dd476e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code id=&quot;calling-confignew-and-handling-errors&quot;&gt;Config::new&lt;/code&gt; and Handling Errors</source>
          <target state="translated">调用 &lt;code id=&quot;calling-confignew-and-handling-errors&quot;&gt;Config::new&lt;/code&gt; 和处理错误</target>
        </trans-unit>
        <trans-unit id="05271cdf6db26718c2abf90da7409799d4703173" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_back_by(0)&lt;/code&gt; does not consume any elements and always returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用 &lt;code&gt;advance_back_by(0)&lt;/code&gt; 不会消耗任何元素，并且始终返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(())&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2db88eb30c547ef9dcc31ceb834f1125361cdd6" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_back_by(0)&lt;/code&gt; does not consume any elements and always returns [&lt;code&gt;Ok(())&lt;/code&gt;].</source>
          <target state="translated">调用 &lt;code&gt;advance_back_by(0)&lt;/code&gt; 不会消耗任何元素，并且始终返回[ &lt;code&gt;Ok(())&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="df6f9e29581ee3a7fb3292d54be3a75552132038" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_by(0)&lt;/code&gt; does not consume any elements and always returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用 &lt;code&gt;advance_by(0)&lt;/code&gt; 不会消耗任何元素，并且始终返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(())&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29810a8b26f09a3007bc1a15cd51bd68ab82979c" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_by(0)&lt;/code&gt; does not consume any elements and always returns [&lt;code&gt;Ok(())&lt;/code&gt;].</source>
          <target state="translated">调用 &lt;code&gt;advance_by(0)&lt;/code&gt; 不会消耗任何元素，并且始终返回[ &lt;code&gt;Ok(())&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="e40c65454f5635fc0b10e5666dc4831c6b5a85ea" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;into_owned&lt;/code&gt; on a &lt;code&gt;Cow::Borrowed&lt;/code&gt; clones the underlying data and becomes a &lt;code&gt;Cow::Owned&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;Cow::Borrowed&lt;/code&gt; 上调用 &lt;code&gt;into_owned&lt;/code&gt; 克隆基础数据，并成为 &lt;code&gt;Cow::Owned&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d45f4417b85022c3db61725f3af3e2cc322eb41e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;into_owned&lt;/code&gt; on a &lt;code&gt;Cow::Owned&lt;/code&gt; is a no-op:</source>
          <target state="translated">在 &lt;code&gt;Cow::Owned&lt;/code&gt; 上调用 &lt;code&gt;into_owned&lt;/code&gt; 是no-op：</target>
        </trans-unit>
        <trans-unit id="695c031ebd8b1d35a483a10782e7c17d879fd0d1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;join&lt;/code&gt; on the handle blocks the thread currently running until the thread represented by the handle terminates. &lt;em&gt;Blocking&lt;/em&gt; a thread means that thread is prevented from performing work or exiting. Because we&amp;rsquo;ve put the call to &lt;code&gt;join&lt;/code&gt; after the main thread&amp;rsquo;s &lt;code&gt;for&lt;/code&gt; loop, running Listing 16-2 should produce output similar to this:</source>
          <target state="translated">在句柄上调用 &lt;code&gt;join&lt;/code&gt; 会阻塞当前正在运行的线程，直到由该句柄表示的线程终止。&lt;em&gt;阻塞&lt;/em&gt;线程意味着&lt;em&gt;阻止&lt;/em&gt;线程执行工作或退出。因为我们已经将调用 &lt;code&gt;join&lt;/code&gt; 到主线程的 &lt;code&gt;for&lt;/code&gt; 循环之后，所以运行清单16-2应该会产生类似于以下的输出：</target>
        </trans-unit>
        <trans-unit id="bba53e5336fa9eed56530a5c7e1f4d704c60b408" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;next()&lt;/code&gt; this way gets repetitive. Rust has a construct which can call &lt;code&gt;next()&lt;/code&gt; on your iterator, until it reaches &lt;code&gt;None&lt;/code&gt;. Let's go over that next.</source>
          <target state="translated">以这种方式调用 &lt;code&gt;next()&lt;/code&gt; 会重复。Rust具有可以在迭代器上调用 &lt;code&gt;next()&lt;/code&gt; 的构造，直到达到 &lt;code&gt;None&lt;/code&gt; 为止。让我们接下来再说。</target>
        </trans-unit>
        <trans-unit id="52eefc013b01e5d9adae0a652dc16672febe75fe" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;nth()&lt;/code&gt; multiple times doesn't rewind the iterator:</source>
          <target state="translated">多次调用 &lt;code&gt;nth()&lt;/code&gt; 不会回退迭代器：</target>
        </trans-unit>
        <trans-unit id="162f7cd67f7da63727e6f1ac3373291fc6afc8f1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;nth_back()&lt;/code&gt; multiple times doesn't rewind the iterator:</source>
          <target state="translated">多次调用 &lt;code&gt;nth_back()&lt;/code&gt; 不会回退迭代器：</target>
        </trans-unit>
        <trans-unit id="c598d6b0bb84ae897f110d0577b80a5562b3ffe9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;CStr&lt;/code&gt; containing invalid UTF-8:</source>
          <target state="translated">在包含无效UTF-8 的 &lt;code&gt;CStr&lt;/code&gt; 上调用 &lt;code&gt;to_string_lossy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e6835821e80fa4f9f034eef42e8cd6c55d7f554" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;CStr&lt;/code&gt; containing valid UTF-8:</source>
          <target state="translated">在包含有效UTF-8 的 &lt;code&gt;CStr&lt;/code&gt; 上调用 &lt;code&gt;to_string_lossy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7c7011eb1a41a55a7c56907e801179e9dea5b3cf" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;Path&lt;/code&gt; with valid unicode:</source>
          <target state="translated">使用有效的unicode 在 &lt;code&gt;Path&lt;/code&gt; 上调用 &lt;code&gt;to_string_lossy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f31c7c45b0c7aeef2d4d0ffc68da4406c29790a0" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on an &lt;code&gt;OsStr&lt;/code&gt; with invalid unicode:</source>
          <target state="translated">使用无效的Unicode 在 &lt;code&gt;OsStr&lt;/code&gt; 上调用 &lt;code&gt;to_string_lossy&lt;/code&gt; ：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
