<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1fd449b5671c0c531048bf228bce50b5745274bb" translate="yes" xml:space="preserve">
          <source>The connection was aborted (terminated) by the remote server.</source>
          <target state="translated">连接被远程服务器中止(终止)。</target>
        </trans-unit>
        <trans-unit id="394cd4f1c44fd561007d2b956b477de854f22ebc" translate="yes" xml:space="preserve">
          <source>The connection was refused by the remote server.</source>
          <target state="translated">远程服务器拒绝了该连接。</target>
        </trans-unit>
        <trans-unit id="ee9eafc82d73396db6a743b750893f5328ee460c" translate="yes" xml:space="preserve">
          <source>The connection was reset by the remote server.</source>
          <target state="translated">该连接被远程服务器重置。</target>
        </trans-unit>
        <trans-unit id="c5c0b8221782b43e8764b446a2f5d5156fcf8b34" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">删除该值后，连接将关闭。连接的读取和写入部分也可以使用&lt;a href=&quot;#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;方法单独关闭。</target>
        </trans-unit>
        <trans-unit id="ee6719cfaf61adca10461f2b171bde13e23a4a41" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">删除该值时，连接将关闭。连接的读取和写入部分也可以使用&lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;方法单独关闭。</target>
        </trans-unit>
        <trans-unit id="98a1585e2f9a061b72de9d4f949a75a416a4fb56" translate="yes" xml:space="preserve">
          <source>The cons function concept has made its way into more general functional programming jargon: &amp;ldquo;to cons &lt;em&gt;x&lt;/em&gt; onto &lt;em&gt;y&lt;/em&gt;&amp;rdquo; informally means to construct a new container instance by putting the element &lt;em&gt;x&lt;/em&gt; at the start of this new container, followed by the container &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">cons函数概念已进入更通用的函数式编程术语中：&amp;ldquo;将&lt;em&gt;x&lt;/em&gt; cons 到&lt;em&gt;y&lt;/em&gt; &amp;rdquo;非正式意味着通过将元素&lt;em&gt;x&lt;/em&gt;放在此新容器的开头，然后是容器&lt;em&gt;y&lt;/em&gt;来构造新的容器实例。</target>
        </trans-unit>
        <trans-unit id="3946118b0e2f7f5ec1675cedbf82ccd7c8d576ce" translate="yes" xml:space="preserve">
          <source>The contents of &lt;em&gt;src/lib.rs&lt;/em&gt; should have the signatures shown in Listing 12-13 (we&amp;rsquo;ve omitted the bodies of the functions for brevity). Note that this won&amp;rsquo;t compile until we modify &lt;em&gt;src/main.rs&lt;/em&gt; in Listing 12-14.</source>
          <target state="translated">&lt;em&gt;src / lib.rs&lt;/em&gt;的内容应具有清单12-13中所示的签名（为简洁起见，我们省略了函数体）。请注意，只有在清单12-14中修改&lt;em&gt;src / main.rs时&lt;/em&gt;，它才会编译。</target>
        </trans-unit>
        <trans-unit id="4fb4cd20ff2b04a7f8f088847ce2546308d2b8ce" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;em&gt;src/lib.rs&lt;/em&gt; file in your &lt;code&gt;adder&lt;/code&gt; library should look like Listing 11-1.</source>
          <target state="translated">&lt;code&gt;adder&lt;/code&gt; 库中&lt;em&gt;src / lib.rs&lt;/em&gt;文件的内容应类似于清单11-1。</target>
        </trans-unit>
        <trans-unit id="1735f7c56c57e86fb0b029da9024a55f63cc6d92" translate="yes" xml:space="preserve">
          <source>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</source>
          <target state="translated">重复的内容必须能跟上前面的内容,后面的内容也必须能跟上重复的内容。</target>
        </trans-unit>
        <trans-unit id="33e5fb5d650df50a2e77352564f0bccccceac217" translate="yes" xml:space="preserve">
          <source>The contents of the returned &lt;a href=&quot;../raw/struct.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; consistent across Unix platforms. The &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; trait contains the cross-Unix abstractions contained within the raw stat.</source>
          <target state="translated">返回的内容&lt;a href=&quot;../raw/struct.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;是&lt;strong&gt;不&lt;/strong&gt;跨越Unix平台上是一致的。该 &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; 特质包含包含原始统计内的跨Unix的抽象。</target>
        </trans-unit>
        <trans-unit id="0770383d0616ee4e47049d055237250b7b2bfaef" translate="yes" xml:space="preserve">
          <source>The conversion allocates on the heap and moves &lt;code&gt;t&lt;/code&gt; from the stack into it.</source>
          <target state="translated">转换在堆上分配，并将 &lt;code&gt;t&lt;/code&gt; 从堆栈移到堆中。</target>
        </trans-unit>
        <trans-unit id="66e8c9afb284902c1e321d76aa570359994fd792" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;../ffi/struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">转换使用&lt;a href=&quot;../ffi/struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;，并删除终止的NUL字节。</target>
        </trans-unit>
        <trans-unit id="b49f9ee7f1f30037339c1daa1d1e1cd395843299" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">转换使用&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;，并删除终止的NUL字节。</target>
        </trans-unit>
        <trans-unit id="9ff60369ad0f3cbf8d85443d93a8bb4f7f1f7686" translate="yes" xml:space="preserve">
          <source>The conversion copies the data, and includes an allocation on the heap.</source>
          <target state="translated">转换会复制数据,并包括堆上的分配。</target>
        </trans-unit>
        <trans-unit id="cbdea02b60597ccd54b5d9dbad9b3681336b3420" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">未来的核心方法 &lt;code&gt;poll&lt;/code&gt; ，&lt;em&gt;试图&lt;/em&gt;解决将来成最终值。如果值未准备好，则此方法不会阻塞。相反，计划在可能的情况下通过再次 &lt;code&gt;poll&lt;/code&gt; 进一步唤醒当前任务。传递给 &lt;code&gt;poll&lt;/code&gt; 方法的 &lt;code&gt;context&lt;/code&gt; 可以提供&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;，这是用于唤醒当前任务的句柄。</target>
        </trans-unit>
        <trans-unit id="af0586e1698754134d6653d1c35d55045868b007" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;code&gt;Waker&lt;/code&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">未来的核心方法 &lt;code&gt;poll&lt;/code&gt; ，&lt;em&gt;试图&lt;/em&gt;解决将来成最终值。如果值未准备好，则此方法不会阻塞。相反，计划在可能的情况下通过再次 &lt;code&gt;poll&lt;/code&gt; 进一步唤醒当前任务。传递给 &lt;code&gt;poll&lt;/code&gt; 方法的 &lt;code&gt;context&lt;/code&gt; 可以提供 &lt;code&gt;Waker&lt;/code&gt; ，这是用于唤醒当前任务的句柄。</target>
        </trans-unit>
        <trans-unit id="7cb53e3d2cc08f8c1b0d6306a44e9e0ab47f9511" translate="yes" xml:space="preserve">
          <source>The core of the error states that there are &lt;em&gt;mismatched types&lt;/em&gt;. Rust has a strong, static type system. However, it also has type inference. When we wrote &lt;code&gt;let mut guess = String::new()&lt;/code&gt;, Rust was able to infer that &lt;code&gt;guess&lt;/code&gt; should be a &lt;code&gt;String&lt;/code&gt; and didn&amp;rsquo;t make us write the type. The &lt;code&gt;secret_number&lt;/code&gt;, on the other hand, is a number type. A few number types can have a value between 1 and 100: &lt;code&gt;i32&lt;/code&gt;, a 32-bit number; &lt;code&gt;u32&lt;/code&gt;, an unsigned 32-bit number; &lt;code&gt;i64&lt;/code&gt;, a 64-bit number; as well as others. Rust defaults to an &lt;code&gt;i32&lt;/code&gt;, which is the type of &lt;code&gt;secret_number&lt;/code&gt; unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.</source>
          <target state="translated">错误的核心是&lt;em&gt;类型不匹配&lt;/em&gt;。 Rust具有强大的静态类型系统。但是，它也具有类型推断。当我们编写 &lt;code&gt;let mut guess = String::new()&lt;/code&gt; ，Rust能够推断出 &lt;code&gt;guess&lt;/code&gt; 应该是 &lt;code&gt;String&lt;/code&gt; ，而不是让我们编写类型。的 &lt;code&gt;secret_number&lt;/code&gt; ，在另一方面，是一个数字型。一些数字类型的值可以在1到100之间： &lt;code&gt;i32&lt;/code&gt; （32位数字）； &lt;code&gt;u32&lt;/code&gt; ，一个无符号的32位数字； &lt;code&gt;i64&lt;/code&gt; ，一个64位数字；以及其他。 Rust默认为 &lt;code&gt;i32&lt;/code&gt; ，这是 &lt;code&gt;secret_number&lt;/code&gt; 的类型除非您在其他地方添加类型信息，否则将导致Rust推断其他数字类型。错误的原因是Rust无法比较字符串和数字类型。</target>
        </trans-unit>
        <trans-unit id="ddff64ad7c369ce0737f5b8b0b3f4b7511787cca" translate="yes" xml:space="preserve">
          <source>The core primitive for interior mutability in Rust.</source>
          <target state="translated">Rust中内部突变性的核心基元。</target>
        </trans-unit>
        <trans-unit id="e23a80c74457fb7f3e04241567981840f6b6a5f0" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt;. The corresponding const implementations are in &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</source>
          <target state="translated">相应的定义在 &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt; 。相应的const实现位于 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="159b3bf04af466ed5bc13962fe870a560dd18283" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt;.</source>
          <target state="translated">相应的定义在 &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="46698ed84aa8c683839a27c0dd70bde9fa62d21c" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Arc&lt;/code&gt; is not consumed. The pointer is valid for as long as there are strong counts in the &lt;code&gt;Arc&lt;/code&gt;.</source>
          <target state="translated">计数不会受到任何影响，并且不会消耗 &lt;code&gt;Arc&lt;/code&gt; 。只要在 &lt;code&gt;Arc&lt;/code&gt; 中存在强计数，指针就有效。</target>
        </trans-unit>
        <trans-unit id="77f706694dca621192d20fdc480b2fbc8fb70f49" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Rc&lt;/code&gt; is not consumed. The pointer is valid for as long there are strong counts in the &lt;code&gt;Rc&lt;/code&gt;.</source>
          <target state="translated">计数不会受到任何影响，并且不会消耗 &lt;code&gt;Rc&lt;/code&gt; 。只要 &lt;code&gt;Rc&lt;/code&gt; 中有很强的计数，指针就有效。</target>
        </trans-unit>
        <trans-unit id="5d69c16c8fa846f1af610002036c48591d43f28f" translate="yes" xml:space="preserve">
          <source>The crate name must not be empty, and must only contain &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode alphanumeric&lt;/a&gt; or &lt;code&gt;-&lt;/code&gt; (U+002D) characters.</source>
          <target state="translated">箱子名称不能为空，并且只能包含&lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode字母数字&lt;/a&gt;或 &lt;code&gt;-&lt;/code&gt; （U + 002D）字符。</target>
        </trans-unit>
        <trans-unit id="be4dd5125e77acafd163c79956b21bce0b41caf8" translate="yes" xml:space="preserve">
          <source>The created map has the default initial capacity.</source>
          <target state="translated">创建的地图具有默认的初始容量。</target>
        </trans-unit>
        <trans-unit id="a9c04b6351b379cccf29eab61f8204218529d934" translate="yes" xml:space="preserve">
          <source>The current algorithm is an adaptive, iterative merge sort inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</source>
          <target state="translated">当前的算法是一种受&lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;启发的自适应迭代合并排序。在切片几乎被排序或由两个或多个依次连接的排序序列组成的情况下，它设计得非常快。</target>
        </trans-unit>
        <trans-unit id="bf4d84cfe0f7a72eb4a521a3a9fe9d6ec790d19e" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;pattern-defeating quicksort&lt;/a&gt; by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</source>
          <target state="translated">当前算法基于Orson Peters的&lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;模式破坏快速排序&lt;/a&gt;，该算法将随机快速排序的快速平均情况与堆排序的最坏情况结合在一起，同时在具有某些模式的切片上实现了线性时间。它使用一些随机化来避免简并的情况，但是使用固定的种子始终提供确定性的行为。</target>
        </trans-unit>
        <trans-unit id="17185ac0ce099c141b9827d28f04ee4d12e294f8" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前算法基于用于&lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt;的相同quicksort算法的quickselect部分。</target>
        </trans-unit>
        <trans-unit id="593e3fc1b65f7b6d06f9c45167b067a1a762655b" translate="yes" xml:space="preserve">
          <source>The current file cursor is not affected by this function.</source>
          <target state="translated">当前文件光标不受此功能影响。</target>
        </trans-unit>
        <trans-unit id="b3777ab23f3b1144c9a96d550ee493d6bc6e2d44" translate="yes" xml:space="preserve">
          <source>The current implementation uses the same infrastructure as compiler diagnostics and debuginfo, but this is not guaranteed.</source>
          <target state="translated">目前的实现使用了与编译器诊断和debuginfo相同的基础设施,但这并不保证。</target>
        </trans-unit>
        <trans-unit id="3346ba5eca8038cde57805738abeaa90cd6a63c6" translate="yes" xml:space="preserve">
          <source>The current module path can be thought of as the hierarchy of modules leading back up to the crate root. The first component of the path returned is the name of the crate currently being compiled.</source>
          <target state="translated">当前的模块路径可以被认为是模块的层次结构,一直到箱子根部。返回路径的第一部分是当前正在编译的模块的名称。</target>
        </trans-unit>
        <trans-unit id="bdf915fa340c78bb10eee5926542917da6f9a74d" translate="yes" xml:space="preserve">
          <source>The current process does not have the permission rights to access &lt;code&gt;from&lt;/code&gt; or write &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">当前的进程没有许可权访问 &lt;code&gt;from&lt;/code&gt; 或写 &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b9c6f166ff606296d138016ea8392f66f7ed63a" translate="yes" xml:space="preserve">
          <source>The current status of a backtrace, indicating whether it was captured or whether it is empty for some other reason.</source>
          <target state="translated">回溯的当前状态,表示是否被捕获或是否因其他原因为空。</target>
        </trans-unit>
        <trans-unit id="aa1cdfe5525c9cd270fc9b5826bff19009fb273e" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following.</source>
          <target state="translated">当前版本的prelude（版本1）位于&lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt;，并重新导出以下内容。</target>
        </trans-unit>
        <trans-unit id="c9ba6afb3853703b17e8a712fa55252cfe708a67" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following:</source>
          <target state="translated">当前版本的prelude（版本1）位于&lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt;，并重新导出以下内容：</target>
        </trans-unit>
        <trans-unit id="912528c0cfbd7646c08850f1e407245a6bf7145e" translate="yes" xml:space="preserve">
          <source>The cursor is pointing to the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="translated">如果列表为空,则光标指向 &quot;幽灵 &quot;非元素。</target>
        </trans-unit>
        <trans-unit id="b9ad03e9a3edaaa56118f6fc3f2871f3d642b3c0" translate="yes" xml:space="preserve">
          <source>The data could not be sent on the &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; because it would require that the callee block to send the data.</source>
          <target state="translated">无法在&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;上发送数据，因为这将要求被调用者块发送数据。</target>
        </trans-unit>
        <trans-unit id="caac8e332d6bed98dbe6a446c232bbf7ded49130" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">此特征公开的数据成员与&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt;结构的成员相对应。</target>
        </trans-unit>
        <trans-unit id="113312da9f41c00330f3f6a2627f87633cf51181" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">此特征公开的数据成员与&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt;结构的成员相对应。</target>
        </trans-unit>
        <trans-unit id="c9421f388aa0f6bda7993e70317be2c01ffcdb74" translate="yes" xml:space="preserve">
          <source>The data protected by the mutex can be accessed through this guard via its &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">可以通过此保护程序通过其&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;实现访问互斥量保护的数据。</target>
        </trans-unit>
        <trans-unit id="a8b69bce2135d478ffa031311b309f0dc7de4fc2" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stderr.</source>
          <target state="translated">进程写入stderr的数据。</target>
        </trans-unit>
        <trans-unit id="5ad3bfb524d0ca744c539d652ec4054ab0b9dc35" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stdout.</source>
          <target state="translated">进程写入stdout的数据。</target>
        </trans-unit>
        <trans-unit id="f0f62565562b0bbca1d9e555b1c167c8869cc294" translate="yes" xml:space="preserve">
          <source>The declaration of &lt;code&gt;another_function&lt;/code&gt; has one parameter named &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; is specified as &lt;code&gt;i32&lt;/code&gt;. When &lt;code&gt;5&lt;/code&gt; is passed to &lt;code&gt;another_function&lt;/code&gt;, the &lt;code&gt;println!&lt;/code&gt; macro puts &lt;code&gt;5&lt;/code&gt; where the pair of curly brackets were in the format string.</source>
          <target state="translated">声明 &lt;code&gt;another_function&lt;/code&gt; 有一个参数叫 &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; 的类型指定为 &lt;code&gt;i32&lt;/code&gt; 。当 &lt;code&gt;5&lt;/code&gt; 传递给 &lt;code&gt;another_function&lt;/code&gt; 时， &lt;code&gt;println!&lt;/code&gt; 宏将 &lt;code&gt;5&lt;/code&gt; 放在一对大括号中格式字符串的位置。</target>
        </trans-unit>
        <trans-unit id="f3e2b77707e4042bb7d326cf080f9fda22d6fd02" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The default for numeric formatters is also a space character but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag (see below) is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">非数字的默认&lt;a href=&quot;#fillalignment&quot;&gt;填充/对齐方式&lt;/a&gt;是空格，并左对齐。数字格式器的默认值也是空格字符，但具有右对齐。如果为数字指定了 &lt;code&gt;0&lt;/code&gt; 标志（请参见下文），则隐式填充字符为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a4c3f3e9f4bf073db3de78ffdfd8f78a08679d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">非数字的默认&lt;a href=&quot;#fillalignment&quot;&gt;填充/对齐方式&lt;/a&gt;是空格，并左对齐。数字格式化程序的默认值也是一个空格，但带有右对齐。如果为数字指定了 &lt;code&gt;0&lt;/code&gt; 标志，则隐式填充字符为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e71d3da519e1259cb4d0ff052a4082fe544273e4" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;struct.randomstate&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.randomstate&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;使用的默认&lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81a33ca44ce969a6a0433a7aff9f0392c46b2e52" translate="yes" xml:space="preserve">
          <source>The default behavior of this function is to print a message to standard error and abort the process. It can be replaced with &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此功能的默认行为是将消息打印为标准错误并中止该过程。可以将其替换为&lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe48c8009742af8ee8a3efe0842a923bc01bf9d" translate="yes" xml:space="preserve">
          <source>The default generic type in this code is within the &lt;code&gt;Add&lt;/code&gt; trait. Here is its definition:</source>
          <target state="translated">此代码中的默认泛型类型在 &lt;code&gt;Add&lt;/code&gt; trait中。这是它的定义：</target>
        </trans-unit>
        <trans-unit id="697b922437171b9fe1e8c84494c4b161d6fd03d3" translate="yes" xml:space="preserve">
          <source>The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against attacks such as HashDoS.</source>
          <target state="translated">当前默认的哈希算法是SipHash 1-3，尽管将来可能会随时更改。尽管它的性能在中型密钥方面非常有竞争力，但其他哈希算法在小密钥（例如整数）和大密钥（例如长字符串）上的性能将胜过它，尽管这些算法通常&lt;em&gt;无法&lt;/em&gt;抵御HashDoS等攻击。</target>
        </trans-unit>
        <trans-unit id="80e587164750efd5907b562bcc2c0ec8621ca1dc" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">默认实现使用提供的第一个非空缓冲区调用&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;，如果不存在，则为空。</target>
        </trans-unit>
        <trans-unit id="73b38e69c912c9cd2a1d35da9b4cb8282e56833f" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;read&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">默认实现使用提供的第一个非空缓冲区调用 &lt;code&gt;read&lt;/code&gt; ，如果不存在，则为空。</target>
        </trans-unit>
        <trans-unit id="2e19ee8802e471056a9e27a45d3086893e133973" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;write&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">默认实现使用提供的第一个非空缓冲区调用 &lt;code&gt;write&lt;/code&gt; ，如果不存在，则为空。</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">默认的实现什么也不做。</target>
        </trans-unit>
        <trans-unit id="cda4f183b9995aecf4b0037179612271bde1f6bd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;(0, &lt;/code&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; which is correct for any iterator.</source>
          <target state="translated">默认实现返回 &lt;code&gt;(0, &lt;/code&gt; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; ，这对于任何迭代器都是正确的。</target>
        </trans-unit>
        <trans-unit id="e33ad58e76bb269caa1c45076544afb93bb1e40d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">默认实现返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="969fb25f2024192b2aecf3ee3a177be1b86acfb5" translate="yes" xml:space="preserve">
          <source>The default implementation returns an initializer which will zero buffers.</source>
          <target state="translated">默认实现返回一个初始化器,将缓冲区清零。</target>
        </trans-unit>
        <trans-unit id="bb3d803ebf5acd8c1abc49ce5f1cae9b36493095" translate="yes" xml:space="preserve">
          <source>The default implementations are returning &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; to indicate a successful execution. In case of a failure, &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; is returned.</source>
          <target state="translated">默认实现返回 &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; 以指示成功执行。如果失败，则返回 &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31cdcfae6f2b31eff3f08e0d9f029eeb9ec7bee1" translate="yes" xml:space="preserve">
          <source>The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:</source>
          <target state="translated">选择默认值时,倾向于产生在各种语言中都合法的字形,包括C++11和类似的C家族语言。具体规则是:</target>
        </trans-unit>
        <trans-unit id="b02cae987658ffb74f03215f87762f2599f0c7eb" translate="yes" xml:space="preserve">
          <source>The default memory allocator provided by the operating system.</source>
          <target state="translated">操作系统提供的默认内存分配器。</target>
        </trans-unit>
        <trans-unit id="1dd4678ade75055f3987aad761b36a01d2353c9f" translate="yes" xml:space="preserve">
          <source>The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads:</source>
          <target state="translated">产卵线程的默认堆栈大小是2 MiB,不过这个特定的堆栈大小在未来可能会改变。有两种方法可以手动指定产卵线程的堆栈大小。</target>
        </trans-unit>
        <trans-unit id="0f91c7ab56b392b9e17d4e1e13452f2f412a7407" translate="yes" xml:space="preserve">
          <source>The definition for complex NTs deserves some justification. SEP_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences &lt;code&gt;&amp;alpha;&lt;/code&gt;. This occurs when either &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; is used, in which case there could be zero repetitions. In theory, this could also occur if &lt;code&gt;+&lt;/code&gt; was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.</source>
          <target state="translated">复杂NT的定义值得证明。SEP_SET（M）定义了分隔符可能是M的有效第一个标记的可能性，当定义了分隔符并且重复的片段可能为空时，就会发生这种情况。ALPHA_SET（M）定义了复数NT可能为空的可能性，这意味着M的有效第一令牌是随后的令牌树序列 &lt;code&gt;&amp;alpha;&lt;/code&gt; 的令牌。当 &lt;code&gt;\*&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; 时，会发生这种情况 使用，在这种情况下，可能有零个重复。从理论上讲，如果 &lt;code&gt;+&lt;/code&gt; 与可能为空的重复片段一起使用，也会发生这种情况，但是第三个不变式禁止这样做。</target>
        </trans-unit>
        <trans-unit id="985a8049c57bbba61492d3048826a9b3471b56f7" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;Config&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; 的定义</target>
        </trans-unit>
        <trans-unit id="830ab684e6b9340db4f9c07a73c12e27ccb95977" translate="yes" xml:space="preserve">
          <source>The dereference operator</source>
          <target state="translated">减法运算符</target>
        </trans-unit>
        <trans-unit id="75ad44a3ef91af0a45f2841a370dda11b833e07f" translate="yes" xml:space="preserve">
          <source>The desired behavior of the &lt;code&gt;generate_workout&lt;/code&gt; function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</source>
          <target state="translated">&lt;code&gt;generate_workout&lt;/code&gt; 函数的期望行为是，首先检查用户是想要低强度锻炼（由小于25的数字表示）还是高强度锻炼（由25或更大的数字表示）。</target>
        </trans-unit>
        <trans-unit id="f11d06267e33f3ae0370e1b473dace96a1d49d65" translate="yes" xml:space="preserve">
          <source>The destructor of a type &lt;code&gt;T&lt;/code&gt; consists of:</source>
          <target state="translated">类型 &lt;code&gt;T&lt;/code&gt; 的析构函数包括：</target>
        </trans-unit>
        <trans-unit id="be2c8573e9de352b5e8e680cfa4b055e97512426" translate="yes" xml:space="preserve">
          <source>The destructor of a type consists of</source>
          <target state="translated">类型的析产器由以下部分组成</target>
        </trans-unit>
        <trans-unit id="c9c60944e1a21001c2063c93ac3b0f4cb46946e2" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">结构的析构函数不得将结构域移出其参数。这是&lt;a href=&quot;#drop-implementation&quot;&gt;上一节中&lt;/a&gt;提到的确切点： &lt;code&gt;drop&lt;/code&gt; 接受 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，但是该结构（及其字段）可能之前已被固定。您必须保证不要在&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;实施中移动字段。特别是，如前所述，这意味着您的结构&lt;em&gt;不得&lt;/em&gt;为 &lt;code&gt;#[repr(packed)]&lt;/code&gt; 。有关如何编写&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; 的信息&lt;/a&gt;，请参见该部分，以使编译器可以帮助您避免意外破坏钉扎。</target>
        </trans-unit>
        <trans-unit id="30054f3bf420ad868745eedcb4cc73a1da34e82c" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;code&gt;Drop&lt;/code&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;code&gt;drop&lt;/code&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">结构的析构函数不得将结构域移出其参数。这是&lt;a href=&quot;#drop-implementation&quot;&gt;上一节中&lt;/a&gt;提到的确切点： &lt;code&gt;drop&lt;/code&gt; 需要 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，但是struct（以及它的字段）可能之前已经固定。您必须保证不要在 &lt;code&gt;Drop&lt;/code&gt; 实施中移动字段。特别是，如前所述，这意味着您的结构&lt;em&gt;不得&lt;/em&gt;为 &lt;code&gt;#[repr(packed)]&lt;/code&gt; 。有关如何编写 &lt;code&gt;drop&lt;/code&gt; 的信息，请参见该部分，以使编译器可以帮助您避免意外破坏钉扎。</target>
        </trans-unit>
        <trans-unit id="f85efc5c824a33e7773d4a9703af1abcf28610ef" translate="yes" xml:space="preserve">
          <source>The difference between 'the prelude' and these other preludes is that they are not automatically &lt;code&gt;use&lt;/code&gt;'d, and must be imported manually. This is still easier than importing all of their constituent components.</source>
          <target state="translated">&amp;ldquo;前奏&amp;rdquo;和其他前奏之间的区别在于它们不会自动 &lt;code&gt;use&lt;/code&gt; &amp;ldquo; d&amp;rdquo;，而必须手动导入。这仍然比导入其所有组成组件容易。</target>
        </trans-unit>
        <trans-unit id="505a24f6c966bf30ebbdd0623555d0248f90c11b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;macro.unimplemented&quot;&gt;&lt;code&gt;unimplemented!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;todo!&lt;/code&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="translated">&lt;a href=&quot;macro.unimplemented&quot;&gt; &lt;code&gt;unimplemented!&lt;/code&gt; &lt;/a&gt;之间的区别！和 &lt;code&gt;todo!&lt;/code&gt; 是在做的那 &lt;code&gt;todo!&lt;/code&gt; 传达了稍后实现功能的意图，并且消息&amp;ldquo;尚未实现&amp;rdquo;， &lt;code&gt;unimplemented!&lt;/code&gt; 没有任何这样的主张。它的消息是&amp;ldquo;未实现&amp;rdquo;。还有一些IDE会标记为 &lt;code&gt;todo!&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="03297ced74ba958f935a37ee67580ef54eeb9a79" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;unimplemented!&lt;/code&gt; and &lt;a href=&quot;macro.todo&quot;&gt;&lt;code&gt;todo!&lt;/code&gt;&lt;/a&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;unimplemented!&lt;/code&gt; 之间的区别！和&lt;a href=&quot;macro.todo&quot;&gt; &lt;code&gt;todo!&lt;/code&gt; &lt;/a&gt;是在做的那 &lt;code&gt;todo!&lt;/code&gt; 传达了稍后实现功能的意图，并且消息&amp;ldquo;尚未实现&amp;rdquo;， &lt;code&gt;unimplemented!&lt;/code&gt; 没有任何这样的主张。它的消息是&amp;ldquo;未实现&amp;rdquo;。还有一些IDE会标记为 &lt;code&gt;todo!&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="3d53ebfe9f22c1eb14437a5afaa7bab7ac81b640" translate="yes" xml:space="preserve">
          <source>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; or any other type, we could have multiple implementations of &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt;. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the &lt;code&gt;next&lt;/code&gt; method on &lt;code&gt;Counter&lt;/code&gt;, we would have to provide type annotations to indicate which implementation of &lt;code&gt;Iterator&lt;/code&gt; we want to use.</source>
          <target state="translated">不同之处在于，如清单19-13所示，在使用泛型时，我们必须在每个实现中对类型进行注释。因为我们还可 &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; 或任何其他类型实现Iterator &amp;lt;String&amp;gt;，所以我们可以有多个 &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt; 的实现。换句话说，当特征具有通用参数时，可以为一个类型实现多次，每次更改通用类型参数的具体类型。当我们在 &lt;code&gt;Counter&lt;/code&gt; 上使用 &lt;code&gt;next&lt;/code&gt; 方法时，我们将必须提供类型注释，以指示我们要使用 &lt;code&gt;Iterator&lt;/code&gt; 的哪种实现。</target>
        </trans-unit>
        <trans-unit id="5d4f5e1a47f10d66452650a5f161fd164ebd410d" translate="yes" xml:space="preserve">
          <source>The differences about paths and the &lt;code&gt;use&lt;/code&gt; keyword between the 2015 and 2018 editions can also be found in the &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">还可以在《&lt;a href=&quot;../reference/items/use-declarations&quot;&gt;参考》中&lt;/a&gt;找到2015年版和2018年版之间关于路径和 &lt;code&gt;use&lt;/code&gt; 关键字的区别。</target>
        </trans-unit>
        <trans-unit id="d9b61b2f901725762b56d16bf06bea0055df6804" translate="yes" xml:space="preserve">
          <source>The different behavior of files in the &lt;em&gt;tests&lt;/em&gt; directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;Separating Modules into Different Files&amp;rdquo;&lt;/a&gt; section of Chapter 7 to extract them into a common module. For example, if we create &lt;em&gt;tests/common.rs&lt;/em&gt; and place a function named &lt;code&gt;setup&lt;/code&gt; in it, we can add some code to &lt;code&gt;setup&lt;/code&gt; that we want to call from multiple test functions in multiple test files:</source>
          <target state="translated">当您具有一组在多个集成测试文件中有用的帮助程序功能并且尝试按照第7章的&lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;将模块分为不同的文件&amp;rdquo;&lt;/a&gt;部分中的步骤操作时，&lt;em&gt;tests&lt;/em&gt;目录中文件的不同行为最为明显。将它们提取到一个通用模块中。例如，如果我们创建&lt;em&gt;测试/ common.rs&lt;/em&gt;并放置一个命名的功能 &lt;code&gt;setup&lt;/code&gt; 中，我们可以添加一些代码来 &lt;code&gt;setup&lt;/code&gt; 我们希望从多个测试文件的多个测试功能调用：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5be1c02c26fe5ef598a5696a274160d696e7977" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 的不同含义</target>
        </trans-unit>
        <trans-unit id="1fd895f49df6ac41f021206eb05bd5dfbc8e5ada" translate="yes" xml:space="preserve">
          <source>The directories and files used for loading external file modules can be influenced with the &lt;code&gt;path&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 属性会影响用于加载外部文件模块的目录和文件。</target>
        </trans-unit>
        <trans-unit id="1e92ecf8e1ea3e2a6e4c02654c525e112d825547" translate="yes" xml:space="preserve">
          <source>The directory isn't empty.</source>
          <target state="translated">目录不是空的。</target>
        </trans-unit>
        <trans-unit id="8e9718c5436468359091854f47e29ace6b258c73" translate="yes" xml:space="preserve">
          <source>The discriminant enum from the example &lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;earlier&lt;/a&gt; then becomes:</source>
          <target state="translated">然后，&lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;前面&lt;/a&gt;示例中的判别式枚举变为：</target>
        </trans-unit>
        <trans-unit id="5406bf9928b412a24605eecb2ec809ade9b2bfca" translate="yes" xml:space="preserve">
          <source>The discriminant of an enum variant may change if the enum definition changes. A discriminant of some variant will not change between compilations with the same compiler.</source>
          <target state="translated">如果枚举定义改变,枚举变体的判别式可能会改变。某些变体的判别式在同一个编译器的编译过程中不会改变。</target>
        </trans-unit>
        <trans-unit id="e1e71495d678a5d4be21061931a65d8862bd4e7e" translate="yes" xml:space="preserve">
          <source>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</source>
          <target state="translated">距离在界内,不能依靠 &quot;环绕 &quot;地址空间。</target>
        </trans-unit>
        <trans-unit id="6c785ac664fd8d2346ca1bb482fcd8b5593d6af3" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">指针之间的距离（&lt;strong&gt;以字节为单位&lt;/strong&gt;）不会溢出 &lt;code&gt;isize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd1487c3b6f63cdfefd3896403e040d0a14037e5" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, in bytes, must be an exact multiple of the size of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">指针之间的距离（以字节为单位）必须是 &lt;code&gt;T&lt;/code&gt; 大小的精确倍数。</target>
        </trans-unit>
        <trans-unit id="c85eee3f8fcb1e3d7acfa8c71113a8ed01e9b6ce" translate="yes" xml:space="preserve">
          <source>The division assignment operator &lt;code&gt;/=&lt;/code&gt;.</source>
          <target state="translated">除法运算符 &lt;code&gt;/=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fac0cbbb13a4ae4385140ac3ccea99961d57c224" translate="yes" xml:space="preserve">
          <source>The division operator &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">除法运算符 &lt;code&gt;/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4bae769945be3db52fcb8fef6b0f5ad9c54eef4" translate="yes" xml:space="preserve">
          <source>The documentation for this keyword is &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;not yet complete&lt;/a&gt;. Pull requests welcome!</source>
          <target state="translated">此关键字的文档&lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;尚未完成&lt;/a&gt;。拉请求欢迎！</target>
        </trans-unit>
        <trans-unit id="7092af2bcd91c441c2dfc4c8d572a11dfce60e91" translate="yes" xml:space="preserve">
          <source>The double colon (&lt;code&gt;::&lt;/code&gt;) is an operator that allows us to namespace this particular &lt;code&gt;from&lt;/code&gt; function under the &lt;code&gt;String&lt;/code&gt; type rather than using some sort of name like &lt;code&gt;string_from&lt;/code&gt;. We&amp;rsquo;ll discuss this syntax more in the &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;Method Syntax&amp;rdquo;&lt;/a&gt; section of Chapter 5 and when we talk about namespacing with modules in &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; in Chapter 7.</source>
          <target state="translated">双冒号（ &lt;code&gt;::&lt;/code&gt; ）是运营商，使我们能够命名空间这个特殊的 &lt;code&gt;from&lt;/code&gt; 下函数 &lt;code&gt;String&lt;/code&gt; 类型，而不是使用某种类似名称的 &lt;code&gt;string_from&lt;/code&gt; 。我们将在第5章的&lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;方法语法&amp;rdquo;&lt;/a&gt;部分中以及在第7章的&lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;&lt;/a&gt;在模块树中引用项目的路径&amp;rdquo;中讨论模块的命名空间时，将详细讨论该语法。</target>
        </trans-unit>
        <trans-unit id="27b2d1743e157ab144583c8c6b85ea9ad0092f0b" translate="yes" xml:space="preserve">
          <source>The downside of using &lt;code&gt;if let&lt;/code&gt; expressions is that the compiler doesn&amp;rsquo;t check exhaustiveness, whereas with &lt;code&gt;match&lt;/code&gt; expressions it does. If we omitted the last &lt;code&gt;else&lt;/code&gt; block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</source>
          <target state="translated">使用 &lt;code&gt;if let&lt;/code&gt; 表达式的不利之处在于，编译器不检查穷举性，而对于 &lt;code&gt;match&lt;/code&gt; 表达式则进行检查。如果我们省略了最后一个 &lt;code&gt;else&lt;/code&gt; 块，因此错过了某些情况的处理，则编译器不会向我们警告可能的逻辑错误。</target>
        </trans-unit>
        <trans-unit id="e387e6a833f24807236bb7fd7266c18e39a1df6d" translate="yes" xml:space="preserve">
          <source>The downside of using this technique is that &lt;code&gt;Wrapper&lt;/code&gt; is a new type, so it doesn&amp;rsquo;t have the methods of the value it&amp;rsquo;s holding. We would have to implement all the methods of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directly on &lt;code&gt;Wrapper&lt;/code&gt; such that the methods delegate to &lt;code&gt;self.0&lt;/code&gt;, which would allow us to treat &lt;code&gt;Wrapper&lt;/code&gt; exactly like a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. If we wanted the new type to have every method the inner type has, implementing the &lt;code&gt;Deref&lt;/code&gt; trait (discussed in Chapter 15 in the &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;Treating Smart Pointers Like Regular References with the &lt;code&gt;Deref&lt;/code&gt; Trait&amp;rdquo;&lt;/a&gt; section) on the &lt;code&gt;Wrapper&lt;/code&gt; to return the inner type would be a solution. If we don&amp;rsquo;t want the &lt;code&gt;Wrapper&lt;/code&gt; type to have all the methods of the inner type&amp;mdash;for example, to restrict the &lt;code&gt;Wrapper&lt;/code&gt; type&amp;rsquo;s behavior&amp;mdash;we would have to implement just the methods we do want manually.</source>
          <target state="translated">使用此技术的缺点是 &lt;code&gt;Wrapper&lt;/code&gt; 是一种新类型，因此它没有持有其值的方法。我们将必须直接在 &lt;code&gt;Wrapper&lt;/code&gt; 上实现 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 所有方法，以使这些方法委托给 &lt;code&gt;self.0&lt;/code&gt; ，这将使我们能够像对待 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 一样对待 &lt;code&gt;Wrapper&lt;/code&gt; 。如果我们希望新的类型有每个方法的内部类型有，实施 &lt;code&gt;Deref&lt;/code&gt; 特征（在第15章中讨论的&lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;与处理智能指针像普通参考&lt;/a&gt; &lt;code&gt;Deref&lt;/code&gt; 特质&amp;rdquo;的部分） &lt;code&gt;Wrapper&lt;/code&gt; 返回内部类型将是一个解决方案。如果我们不希望 &lt;code&gt;Wrapper&lt;/code&gt; 类型具有内部类型的所有方法（例如，限制 &lt;code&gt;Wrapper&lt;/code&gt; 类型的行为），则仅需手动实现我们想要的方法即可。</target>
        </trans-unit>
        <trans-unit id="0e7aa88c59ccdb8f5ae43f1abe07297a4d7ace58" translate="yes" xml:space="preserve">
          <source>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&amp;rsquo;re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</source>
          <target state="translated">实现宏而不是函数的缺点是，宏定义比函数定义更复杂，因为您正在编写用于编写Rust代码的Rust代码。由于存在这种间接性，因此宏定义通常比函数定义更难于阅读，理解和维护。</target>
        </trans-unit>
        <trans-unit id="719fc8d49d59015d6dffe7ccc55e5816d1966b0e" translate="yes" xml:space="preserve">
          <source>The duration of one microsecond.</source>
          <target state="translated">一微秒的持续时间。</target>
        </trans-unit>
        <trans-unit id="e68beeeb11183a3ff18abb9e6896356e66b6200f" translate="yes" xml:space="preserve">
          <source>The duration of one millisecond.</source>
          <target state="translated">一毫秒的持续时间。</target>
        </trans-unit>
        <trans-unit id="e9d186359c1c80de39171fea4281a767f86db9c5" translate="yes" xml:space="preserve">
          <source>The duration of one nanosecond.</source>
          <target state="translated">一纳秒的持续时间。</target>
        </trans-unit>
        <trans-unit id="926b58a37c99c224d9cf0ad023e9e79f2bae5af3" translate="yes" xml:space="preserve">
          <source>The duration of one second.</source>
          <target state="translated">一秒钟的时间。</target>
        </trans-unit>
        <trans-unit id="51e82336197f20c9062a20d4490259f940ada0fe" translate="yes" xml:space="preserve">
          <source>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; object or &lt;code&gt;fn()&lt;/code&gt; pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">最简单的解决方法是将您的闭包重写为顶级函数或方法。在某些情况下，您还可以通过捕获引用自身的 &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; 对象或 &lt;code&gt;fn()&lt;/code&gt; 指针来使自己的闭包调用自身。这是允许的，因为闭包将通过虚拟调用来调用自身，因此不直接引用其自身的&lt;em&gt;type&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8b90152377c4d2fa6a58836b95414b3c64c66683" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;HashMap&lt;/code&gt; 与自定义键类型一起使用的最简单方法是派生&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;。我们还必须派生&lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fdc4a2a7876216a8a5156bcc124c1c5c1d13c54" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;HashMap&lt;/code&gt; 与自定义键类型一起使用的最简单方法是派生&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;。我们还必须派生&lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b835cd73ddea2cd4aee637c4f9c2cd855ee696f" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;HashSet&lt;/code&gt; 与自定义类型一起使用的最简单方法是派生&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;。我们还必须导出&lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;，这将在以后由&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="bcd32a61d8029373ce3811b4c81b01b04e2fcd8a" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;HashSet&lt;/code&gt; 与自定义类型一起使用的最简单方法是派生&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;。我们还必须导出&lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;，这将在以后由&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="4abca09eae529f079207e693c4204e4240160458" translate="yes" xml:space="preserve">
          <source>The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">即使迭代器直到最后才被消耗,元素范围也会被删除。</target>
        </trans-unit>
        <trans-unit id="857f1367d5858bf310bc19ad475cfec76822e623" translate="yes" xml:space="preserve">
          <source>The element that was removed is returned, and the cursor is moved to point to the next element in the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">返回已删除的元素，并移动光标以指向 &lt;code&gt;LinkedList&lt;/code&gt; 中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="17d488f8279ef9d0e051cac2f43dff0a68f18b2b" translate="yes" xml:space="preserve">
          <source>The elements are removed in arbitrary order.</source>
          <target state="translated">元素按任意顺序删除。</target>
        </trans-unit>
        <trans-unit id="5fe5f813b6a2f233abc73bad03a94ec158695239" translate="yes" xml:space="preserve">
          <source>The elements at &lt;code&gt;old_len..new_len&lt;/code&gt; must be initialized.</source>
          <target state="translated">必须初始化 &lt;code&gt;old_len..new_len&lt;/code&gt; 上的元素。</target>
        </trans-unit>
        <trans-unit id="2bafc31dee9d33ba4d10ed67ef0f71ab38bfff69" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/array&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last. *</source>
          <target state="translated">一个的元件&lt;a href=&quot;types/array&quot;&gt;阵列&lt;/a&gt;或拥有的&lt;a href=&quot;types/array&quot;&gt;切片&lt;/a&gt;从第一元件到最后丢弃。*</target>
        </trans-unit>
        <trans-unit id="1e3e69cc26857f9c1293b40c529b047e54164338" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last.</source>
          <target state="translated">一个的元件&lt;a href=&quot;types/array&quot;&gt;阵列&lt;/a&gt;或拥有的&lt;a href=&quot;types/slice&quot;&gt;切片&lt;/a&gt;从第一元件到最后丢弃。</target>
        </trans-unit>
        <trans-unit id="2aa9bb19de05cfdf90da669db74c8f4ff87b16d5" translate="yes" xml:space="preserve">
          <source>The elements yielded by &lt;code&gt;DoubleEndedIterator&lt;/code&gt;'s methods may differ from the ones yielded by &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;'s methods:</source>
          <target state="translated">&lt;code&gt;DoubleEndedIterator&lt;/code&gt; 方法产生的元素可能与&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;方法产生的元素不同：</target>
        </trans-unit>
        <trans-unit id="88efd616f1a1b2e8d8f2dcc3a848a8c623471404" translate="yes" xml:space="preserve">
          <source>The elision rules don&amp;rsquo;t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&amp;rsquo;t guess what the lifetime of the remaining references should be. In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</source>
          <target state="translated">省略规则不能提供完整的推断。如果Rust确定性地应用了规则，但是在引用的生存期方面仍然存在歧义，编译器将不会猜测其余引用的生存期。在这种情况下，编译器会给您一个错误，您可以通过添加生存期注释来解决该错误，而这些生存期注释会指定引用之间的关系，而您不必猜测，而是可以解决该错误。</target>
        </trans-unit>
        <trans-unit id="3e3b658969dac70797ae99e22406a5919df5b0c6" translate="yes" xml:space="preserve">
          <source>The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. As with all struct expressions, all of the fields of the struct must be &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt;, even those not explicitly named.</source>
          <target state="translated">整个表达式使用给定字段的给定值，并移动或复制基本表达式中的其余字段。与所有结构表达式一样，该结构的所有字段都必须是&lt;a href=&quot;../visibility-and-privacy&quot;&gt;可见的&lt;/a&gt;，即使未明确命名的字段也是如此。</target>
        </trans-unit>
        <trans-unit id="a0574dfce03935016b1e7370699d140878e68385" translate="yes" xml:space="preserve">
          <source>The entire file name if the file name begins with &lt;code&gt;.&lt;/code&gt; and has no other &lt;code&gt;.&lt;/code&gt;s within;</source>
          <target state="translated">如果文件名以开头，则为整个文件名 &lt;code&gt;.&lt;/code&gt; 并且没有其他的 &lt;code&gt;.&lt;/code&gt; 内</target>
        </trans-unit>
        <trans-unit id="e83cf0228defdcd6e7afea0984d3278d36eab74c" translate="yes" xml:space="preserve">
          <source>The entire file name if there is no embedded &lt;code&gt;.&lt;/code&gt;;</source>
          <target state="translated">整个文件名（如果未嵌入） &lt;code&gt;.&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3fa274546f438640798ab62aae39ac18398db5cc" translate="yes" xml:space="preserve">
          <source>The entire function</source>
          <target state="translated">整个功能</target>
        </trans-unit>
        <trans-unit id="8a5d709e7f69a77cb8061cae38e47a941e97332f" translate="yes" xml:space="preserve">
          <source>The entire function body.</source>
          <target state="translated">整个功能体。</target>
        </trans-unit>
        <trans-unit id="5c15c39c685d0906fec325e3d5c2bea1c6eb708a" translate="yes" xml:space="preserve">
          <source>The entire function scope is the outer most scope.</source>
          <target state="translated">整个函数范围是最外层的范围。</target>
        </trans-unit>
        <trans-unit id="9b8eedec31f30287b3b74ad1f2675a525e2c3cf5" translate="yes" xml:space="preserve">
          <source>The entire hash map is generic over a key type &lt;code&gt;K&lt;/code&gt;. Because these keys are stored with the hash map, this type has to own the key&amp;rsquo;s data. When inserting a key-value pair, the map is given such a &lt;code&gt;K&lt;/code&gt; and needs to find the correct hash bucket and check if the key is already present based on that &lt;code&gt;K&lt;/code&gt;. It therefore requires &lt;code&gt;K: Hash + Eq&lt;/code&gt;.</source>
          <target state="translated">整个哈希图在键类型 &lt;code&gt;K&lt;/code&gt; 上是通用的。由于这些密钥与哈希映射一起存储，因此此类型必须拥有密钥的数据。插入键值对时，会给映射提供这样的 &lt;code&gt;K&lt;/code&gt; ,并且需要找到正确的哈希值存储区，并根据 &lt;code&gt;K&lt;/code&gt; 来检查键是否已经存在。因此，它需要 &lt;code&gt;K: Hash + Eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0297c1c788a21e67f6b7fde15406ec3888485937" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects.</source>
          <target state="translated">该分片的整个内存范围必须包含在一个分配对象中! 分片不能跨越多个分配对象。</target>
        </trans-unit>
        <trans-unit id="d250d768cfabd095635656557072ab76a1e3cbad" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects. See &lt;a href=&quot;#incorrect-usage&quot;&gt;below&lt;/a&gt; for an example incorrectly not taking this into account.</source>
          <target state="translated">此片的整个内存范围必须包含在一个分配的对象中！切片永远不能跨越多个分配的对象。参见&lt;a href=&quot;#incorrect-usage&quot;&gt;下面&lt;/a&gt;的示例，错误地没有考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="97dea0260f138033ef7cf2f5ca57a634d6eea616" translate="yes" xml:space="preserve">
          <source>The entry point of the program was marked as &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="translated">该程序的入口点被标记为 &lt;code&gt;async&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82f98df6718e5a9d6fd411d1cc853597af7467ed" translate="yes" xml:space="preserve">
          <source>The error and the note tell the story: Rust strings don&amp;rsquo;t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.</source>
          <target state="translated">错误和注释说明了这个故事：Rust字符串不支持索引。但是为什么不呢？要回答这个问题，我们需要讨论Rust如何在内存中存储字符串。</target>
        </trans-unit>
        <trans-unit id="41a72aa86a9d9e55bed7f9841f1b9fdc25696e6c" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals and on numeric bindings without an identified concrete type:</source>
          <target state="translated">该错误发生在数字字面和没有确定具体类型的数字绑定上。</target>
        </trans-unit>
        <trans-unit id="1decc58ff466451824639b9b2033b046dfa94fee" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals:</source>
          <target state="translated">该错误发生在数字文字上。</target>
        </trans-unit>
        <trans-unit id="39121a17de405ba30c8238c549d55b70becaf449" translate="yes" xml:space="preserve">
          <source>The error indicates that Rust expected a &lt;code&gt;bool&lt;/code&gt; but got an integer. Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide &lt;code&gt;if&lt;/code&gt; with a Boolean as its condition. If we want the &lt;code&gt;if&lt;/code&gt; code block to run only when a number is not equal to &lt;code&gt;0&lt;/code&gt;, for example, we can change the &lt;code&gt;if&lt;/code&gt; expression to the following:</source>
          <target state="translated">该错误表明Rust期望 &lt;code&gt;bool&lt;/code&gt; 但是得到了一个整数。与Ruby和JavaScript等语言不同，Rust不会自动尝试将非布尔类型转换为布尔值。你必须是明确的，始终提供 &lt;code&gt;if&lt;/code&gt; 用一个布尔为条件。例如，如果我们希望 &lt;code&gt;if&lt;/code&gt; 代码块仅在一个数字不等于 &lt;code&gt;0&lt;/code&gt; 时运行，则可以将 &lt;code&gt;if&lt;/code&gt; 表达式更改为以下内容：</target>
        </trans-unit>
        <trans-unit id="82fe814b563c83c1ad42c2a44464d60e45abeb59" translate="yes" xml:space="preserve">
          <source>The error message indicates that the cause of the error is that you &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt;, because you tried to assign a second value to the immutable &lt;code&gt;x&lt;/code&gt; variable.</source>
          <target state="translated">该错误消息表明，错误的原因是您 &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt; ，因为您试图为不可变 &lt;code&gt;x&lt;/code&gt; 变量分配第二个值。</target>
        </trans-unit>
        <trans-unit id="1acd99d552c691a91137d21fedf0cc394ac8a4d0" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value is moved into the closure and then captured when we call &lt;code&gt;lock&lt;/code&gt;. That description sounds like what we wanted, but it&amp;rsquo;s not allowed!</source>
          <target state="translated">错误消息指出，将 &lt;code&gt;counter&lt;/code&gt; 值移入闭包，然后在调用 &lt;code&gt;lock&lt;/code&gt; 时捕获。该描述听起来像我们想要的，但它是不允许的！</target>
        </trans-unit>
        <trans-unit id="5bb7a0ad71457e0f1d6ce226ce7b55ec5697ceba" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value was moved in the previous iteration of the loop. So Rust is telling us that we can&amp;rsquo;t move the ownership of lock &lt;code&gt;counter&lt;/code&gt; into multiple threads. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">该错误消息指出 &lt;code&gt;counter&lt;/code&gt; 值在循环的上一迭代中已移动。因此Rust告诉我们，我们不能将锁 &lt;code&gt;counter&lt;/code&gt; 的所有权移到多个线程中。让我们使用第15章中讨论的多所有权方法修复编译器错误。</target>
        </trans-unit>
        <trans-unit id="6326b5d7f5ddab487c6090e5e84a18d25a0a3db6" translate="yes" xml:space="preserve">
          <source>The error messages say that module &lt;code&gt;hosting&lt;/code&gt; is private. In other words, we have the correct paths for the &lt;code&gt;hosting&lt;/code&gt; module and the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, but Rust won&amp;rsquo;t let us use them because it doesn&amp;rsquo;t have access to the private sections.</source>
          <target state="translated">错误消息表明模块 &lt;code&gt;hosting&lt;/code&gt; 是私有的。换句话说，我们为 &lt;code&gt;hosting&lt;/code&gt; 模块和 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数提供了正确的路径，但是Rust无法访问它们，因为它无法访问私有部分。</target>
        </trans-unit>
        <trans-unit id="8eb6e3e38ad85be87f507639136fdec21b108288" translate="yes" xml:space="preserve">
          <source>The error occurs because &lt;code&gt;foo&lt;/code&gt; accepts a closure that takes an &lt;code&gt;i32&lt;/code&gt; argument, but in &lt;code&gt;main&lt;/code&gt;, it is passed a closure with a &lt;code&gt;&amp;amp;str&lt;/code&gt; argument.</source>
          <target state="translated">发生错误是因为 &lt;code&gt;foo&lt;/code&gt; 接受带有 &lt;code&gt;i32&lt;/code&gt; 参数的闭包，但是在 &lt;code&gt;main&lt;/code&gt; 中，它传递了带有 &lt;code&gt;&amp;amp;str&lt;/code&gt; 参数的闭包。</target>
        </trans-unit>
        <trans-unit id="4df536d23e48c26eec2d844083fbc5169ab15de6" translate="yes" xml:space="preserve">
          <source>The error occurs because keyword &lt;code&gt;yield&lt;/code&gt; can only be used inside the generator literal. This can be fixed by constructing the generator correctly.</source>
          <target state="translated">发生错误是因为关键字 &lt;code&gt;yield&lt;/code&gt; 只能在生成器文字内部使用。可以通过正确构造生成器来解决此问题。</target>
        </trans-unit>
        <trans-unit id="5bce45a967fbcca42003bd3fc6c351711632526a" translate="yes" xml:space="preserve">
          <source>The error references the &lt;code&gt;Sized&lt;/code&gt; trait again! Rust doesn&amp;rsquo;t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</source>
          <target state="translated">该错误再次引用了 &lt;code&gt;Sized&lt;/code&gt; 特征！Rust不知道存储封闭件需要多少空间。我们之前已经看到了解决该问题的方法。我们可以使用特征对象：</target>
        </trans-unit>
        <trans-unit id="687172b839a6f9ace430c7922b4119fecbbc273c" translate="yes" xml:space="preserve">
          <source>The error says we&amp;rsquo;re not allowed to mutate a variable&amp;rsquo;s type:</source>
          <target state="translated">该错误表明我们不允许更改变量的类型：</target>
        </trans-unit>
        <trans-unit id="4c799801c95c3499262c7f795808c56dd04d3f03" translate="yes" xml:space="preserve">
          <source>The error shows that for &lt;code&gt;result&lt;/code&gt; to be valid for the &lt;code&gt;println!&lt;/code&gt; statement, &lt;code&gt;string2&lt;/code&gt; would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">该错误表明 &lt;code&gt;result&lt;/code&gt; 对于 &lt;code&gt;println!&lt;/code&gt; 有效！语句， &lt;code&gt;string2&lt;/code&gt; 将一直有效，直到外部作用域结束。Rust之所以知道这一点，是因为我们使用相同的生命周期参数 &lt;code&gt;'a&lt;/code&gt; 注释了函数参数的生命周期和返回值。</target>
        </trans-unit>
        <trans-unit id="81dd6345e63f7b9b970ec324dc927c2a78ce87e8" translate="yes" xml:space="preserve">
          <source>The error shows that you can&amp;rsquo;t use the keyword &lt;code&gt;match&lt;/code&gt; as the function identifier. To use &lt;code&gt;match&lt;/code&gt; as a function name, you need to use the raw identifier syntax, like this:</source>
          <target state="translated">该错误表明您不能将关键字 &lt;code&gt;match&lt;/code&gt; 用作功能标识符。要将 &lt;code&gt;match&lt;/code&gt; 用作函数名称，您需要使用原始标识符语法，如下所示：</target>
        </trans-unit>
        <trans-unit id="17031b6288809d4b66c77a71348fe05200b2e1e5" translate="yes" xml:space="preserve">
          <source>The error shows this type &amp;ldquo;has infinite size.&amp;rdquo; The reason is that we&amp;rsquo;ve defined &lt;code&gt;List&lt;/code&gt; with a variant that is recursive: it holds another value of itself directly. As a result, Rust can&amp;rsquo;t figure out how much space it needs to store a &lt;code&gt;List&lt;/code&gt; value. Let&amp;rsquo;s break down why we get this error a bit. First, let&amp;rsquo;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</source>
          <target state="translated">错误显示此类型&amp;ldquo;具有无限大小&amp;rdquo;。原因是我们为 &lt;code&gt;List&lt;/code&gt; 定义了一个递归的变量：它直接拥有自身的另一个值。结果，Rust无法确定存储 &lt;code&gt;List&lt;/code&gt; 值需要多少空间。让我们细分一下为什么会出现此错误。首先，让我们看一下Rust如何决定存储非递归类型的值需要多少空间。</target>
        </trans-unit>
        <trans-unit id="ddd69ec9cc85fcc63997c43bed364cf16ee6b3f9" translate="yes" xml:space="preserve">
          <source>The error tells us we can&amp;rsquo;t call &lt;code&gt;join&lt;/code&gt; because we only have a mutable borrow of each &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; takes ownership of its argument. To solve this issue, we need to move the thread out of the &lt;code&gt;Worker&lt;/code&gt; instance that owns &lt;code&gt;thread&lt;/code&gt; so &lt;code&gt;join&lt;/code&gt; can consume the thread. We did this in Listing 17-15: if &lt;code&gt;Worker&lt;/code&gt; holds an &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; instead, we can call the &lt;code&gt;take&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; to move the value out of the &lt;code&gt;Some&lt;/code&gt; variant and leave a &lt;code&gt;None&lt;/code&gt; variant in its place. In other words, a &lt;code&gt;Worker&lt;/code&gt; that is running will have a &lt;code&gt;Some&lt;/code&gt; variant in &lt;code&gt;thread&lt;/code&gt;, and when we want to clean up a &lt;code&gt;Worker&lt;/code&gt;, we&amp;rsquo;ll replace &lt;code&gt;Some&lt;/code&gt; with &lt;code&gt;None&lt;/code&gt; so the &lt;code&gt;Worker&lt;/code&gt; doesn&amp;rsquo;t have a thread to run.</source>
          <target state="translated">该错误告诉我们不能调用 &lt;code&gt;join&lt;/code&gt; ,因为我们只有每个 &lt;code&gt;worker&lt;/code&gt; 的可变借项，而 &lt;code&gt;join&lt;/code&gt; 拥有其参数的所有权。要解决此问题，我们需要将线程移出拥有 &lt;code&gt;thread&lt;/code&gt; 的 &lt;code&gt;Worker&lt;/code&gt; 实例，以便 &lt;code&gt;join&lt;/code&gt; 可以使用该线程。我们在清单17-15中进行了此操作：如果 &lt;code&gt;Worker&lt;/code&gt; 持有 &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; ，则可以在 &lt;code&gt;Option&lt;/code&gt; 上调用 &lt;code&gt;take&lt;/code&gt; 方法将值移出 &lt;code&gt;Some&lt;/code&gt; 变量，并在其中保留 &lt;code&gt;None&lt;/code&gt; 变量。它的位置。换句话说，一个 &lt;code&gt;Worker&lt;/code&gt; 正在运行的 &lt;code&gt;thread&lt;/code&gt; 中将具有 &lt;code&gt;Some&lt;/code&gt; 变体，当我们要清理 &lt;code&gt;Worker&lt;/code&gt; 时，我们将 &lt;code&gt;Some&lt;/code&gt; 替换为 &lt;code&gt;None&lt;/code&gt; ,以便 &lt;code&gt;Worker&lt;/code&gt; 没有线程要运行。</target>
        </trans-unit>
        <trans-unit id="58b8d8f068cf467e7f55c896bbdf137f3a755bf5" translate="yes" xml:space="preserve">
          <source>The error type for &lt;code&gt;try_reserve&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;try_reserve&lt;/code&gt; 方法的错误类型。</target>
        </trans-unit>
        <trans-unit id="458fb320b83d2d5563146d6c64a5e9086c1cdbe5" translate="yes" xml:space="preserve">
          <source>The error type for I/O operations of the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt;, and associated traits.</source>
          <target state="translated">&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;和关联特征的I / O操作的错误类型。</target>
        </trans-unit>
        <trans-unit id="3e8c3a7432541c640c48492379ea610ecb40f6ae" translate="yes" xml:space="preserve">
          <source>The error type for errors that can never happen.</source>
          <target state="translated">永远不会发生的错误的错误类型。</target>
        </trans-unit>
        <trans-unit id="fdb319ec59d1f1964ec642ac851b7301cdf60e57" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与环境变量进行交互的操作的错误类型。可能是从&lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var()&lt;/code&gt; &lt;/a&gt;返回的。</target>
        </trans-unit>
        <trans-unit id="751842d7baf0779231030e01a15db69a4f03c6bc" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from the &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">与环境变量进行交互的操作的错误类型。可能是从&lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var&lt;/code&gt; &lt;/a&gt;函数返回的。</target>
        </trans-unit>
        <trans-unit id="11ea1ae6c021101c095eab4ba4b755be8b16c063" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对 &lt;code&gt;PATH&lt;/code&gt; 变量进行操作的错误类型。可能是从&lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths()&lt;/code&gt; &lt;/a&gt;返回的。</target>
        </trans-unit>
        <trans-unit id="04e8342895bd312f045a40780238aabb9ef5de36" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from the &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">对 &lt;code&gt;PATH&lt;/code&gt; 变量进行操作的错误类型。可能是从&lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths&lt;/code&gt; &lt;/a&gt;函数返回的。</target>
        </trans-unit>
        <trans-unit id="92c7e92ce900890826a3bdc04f0bdb6f93a2ae4e" translate="yes" xml:space="preserve">
          <source>The error type returned when a checked integral type conversion fails.</source>
          <target state="translated">当检查积分类型转换失败时返回的错误类型。</target>
        </trans-unit>
        <trans-unit id="7c03030b0922657a2b23ad871594bf872bfa86e8" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from a slice to an array fails.</source>
          <target state="translated">从分片转换为数组失败时返回的错误类型。</target>
        </trans-unit>
        <trans-unit id="5bd755e234651b9d8db0dad82d899820eb73c1c6" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from u32 to char fails.</source>
          <target state="translated">当从u32转换为char失败时返回的错误类型。</target>
        </trans-unit>
        <trans-unit id="74bd671788812266d70e1e6379cd71d68b83bdd8" translate="yes" xml:space="preserve">
          <source>The error type that results from applying the try operator (&lt;code&gt;?&lt;/code&gt;) to a &lt;code&gt;None&lt;/code&gt; value. If you wish to allow &lt;code&gt;x?&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;) to be converted into your error type, you can implement &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; for &lt;code&gt;YourErrorType&lt;/code&gt;. In that case, &lt;code&gt;x?&lt;/code&gt; within a function that returns &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; will translate a &lt;code&gt;None&lt;/code&gt; value into an &lt;code&gt;Err&lt;/code&gt; result.</source>
          <target state="translated">将try运算符（ &lt;code&gt;?&lt;/code&gt; ）应用于 &lt;code&gt;None&lt;/code&gt; 值所导致的错误类型。如果您希望允许 &lt;code&gt;x?&lt;/code&gt; （其中 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ）（要转换为您的错误类型），可以为 &lt;code&gt;YourErrorType&lt;/code&gt; 实现 &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; 。在那种情况下， &lt;code&gt;x?&lt;/code&gt; 在返回 &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; 的函数中，YourErrorType&amp;gt;会将 &lt;code&gt;None&lt;/code&gt; 值转换为 &lt;code&gt;Err&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="620e9e66f647e7af133c1492023ad78f941762d1" translate="yes" xml:space="preserve">
          <source>The error type which is returned from formatting a message into a stream.</source>
          <target state="translated">将消息格式化为流后返回的错误类型。</target>
        </trans-unit>
        <trans-unit id="de3d4a50ecffe879839aa645e297acf63f3f41e3" translate="yes" xml:space="preserve">
          <source>The error type which is returned from parsing the type a control message.</source>
          <target state="translated">解析控制信息类型后返回的错误类型。</target>
        </trans-unit>
        <trans-unit id="d4672a685f085da2d7d7f62486ff4649fbce70a5" translate="yes" xml:space="preserve">
          <source>The errors in Listing 7-6 say that the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.</source>
          <target state="translated">清单7-6中的错误表明 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数是私有的。隐私规则适用于结构，枚举，函数，方法以及模块。</target>
        </trans-unit>
        <trans-unit id="5c9b02894ffaf56c3eee190bd9f4d3e5a18ff962" translate="yes" xml:space="preserve">
          <source>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</source>
          <target state="translated">在已经拥有锁的线程中锁定mutex的具体行为没有说明。但是,这个函数不会在第二次调用时返回(例如,它可能会恐慌或死锁)。</target>
        </trans-unit>
        <trans-unit id="ec573024d9a369fea8772d4967a09d1e972fae0a" translate="yes" xml:space="preserve">
          <source>The exact character(s)</source>
          <target state="translated">准确的字符</target>
        </trans-unit>
        <trans-unit id="df2f57248767dbedd045941faa73ddbe53944b27" translate="yes" xml:space="preserve">
          <source>The exact order may be useful for tracking external state, like an index.</source>
          <target state="translated">准确的顺序可能对跟踪外部状态很有用,比如索引。</target>
        </trans-unit>
        <trans-unit id="8fe495e6414bd43e7bea5f0003cca50741a5b59b" translate="yes" xml:space="preserve">
          <source>The exact output printed by this macro should not be relied upon and is subject to future changes.</source>
          <target state="translated">此宏打印的确切输出不应依赖,将来可能会有变化。</target>
        </trans-unit>
        <trans-unit id="469498f0144088c9a82cccca15de67704811a8dd" translate="yes" xml:space="preserve">
          <source>The exact text, of course, depends on what files you have in &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">当然，确切的文本取决于您所拥有的文件 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="395c851d3758c4daf594b9f6b458c5ca4cd7434f" translate="yes" xml:space="preserve">
          <source>The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the &lt;code&gt;for&lt;/code&gt; loop. The iterator is stored in the &lt;code&gt;v1_iter&lt;/code&gt; variable, and no iteration takes place at that time. When the &lt;code&gt;for&lt;/code&gt; loop is called using the iterator in &lt;code&gt;v1_iter&lt;/code&gt;, each element in the iterator is used in one iteration of the loop, which prints out each value.</source>
          <target state="translated">清单13-14中的示例将迭代器的创建与 &lt;code&gt;for&lt;/code&gt; 循环中迭代器的使用分开。迭代器存储在 &lt;code&gt;v1_iter&lt;/code&gt; 变量中，那时没有迭代发生。当使用 &lt;code&gt;v1_iter&lt;/code&gt; 中的迭代器调用 &lt;code&gt;for&lt;/code&gt; 循环时，迭代器中的每个元素都将在循环的一次迭代中使用，该循环将打印出每个值。</target>
        </trans-unit>
        <trans-unit id="e88d69a7ee7e1056409be12e179c7703287290b1" translate="yes" xml:space="preserve">
          <source>The exception to this idiom is if we&amp;rsquo;re bringing two items with the same name into scope with &lt;code&gt;use&lt;/code&gt; statements, because Rust doesn&amp;rsquo;t allow that. Listing 7-15 shows how to bring two &lt;code&gt;Result&lt;/code&gt; types into scope that have the same name but different parent modules and how to refer to them.</source>
          <target state="translated">这个习惯用法的例外是，如果我们将两个具有相同名称的项目放入 &lt;code&gt;use&lt;/code&gt; 语句的作用域中，因为Rust不允许这样做。清单7-15显示了如何将两个名称相同但父模块不同的 &lt;code&gt;Result&lt;/code&gt; 类型引入作用域，以及如何引用它们。</target>
        </trans-unit>
        <trans-unit id="f9ff06ceaf161b4f26d0944c142b9739231935eb" translate="yes" xml:space="preserve">
          <source>The exception to this is the unit tuple (&lt;code&gt;()&lt;/code&gt;) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</source>
          <target state="translated">例外情况是单位元组（ &lt;code&gt;()&lt;/code&gt; ），它被保证为零大小类型，其大小为0，对齐方式为1。</target>
        </trans-unit>
        <trans-unit id="3dc57cf649d183700b8e68c720c692cad27e1162" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;, and the returned file is not the invocation of the &lt;code&gt;file!&lt;/code&gt; macro itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;file!&lt;/code&gt; macro.</source>
          <target state="translated">扩展表达式的类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; ，返回的文件不是该文件的调用 &lt;code&gt;file!&lt;/code&gt; 宏本身，而是导致 &lt;code&gt;file!&lt;/code&gt; 调用的第一个宏调用！宏。</target>
        </trans-unit>
        <trans-unit id="2027bedff965dc7817b0dd952d1fc211920c5f6d" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first column in each line evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned column is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;column!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;column!&lt;/code&gt; macro.</source>
          <target state="translated">扩展表达式的类型为 &lt;code&gt;u32&lt;/code&gt; ，基于1，因此每行的第一列的值为1，第二列的值为2，依此类推。这与常见编译器或常用编辑器的错误消息一致。返回的列&lt;em&gt;不一定&lt;/em&gt;是该 &lt;code&gt;column!&lt;/code&gt; 的行！本身，而是第一个宏调用导致 &lt;code&gt;column!&lt;/code&gt; 的调用！宏。</target>
        </trans-unit>
        <trans-unit id="b0b06f58ec99c372d86a17a34c7166fa5de08c27" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first line in each file evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned line is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;line!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;line!&lt;/code&gt; macro.</source>
          <target state="translated">扩展表达式的类型为 &lt;code&gt;u32&lt;/code&gt; ，基于1，因此每个文件的第一行求值为1，第二行求值为2，依此类推。这与常见编译器或常用编辑器的错误消息一致。返回的行&lt;em&gt;不一定是&lt;/em&gt;该行的 &lt;code&gt;line!&lt;/code&gt; 调用本身，而是导致该 &lt;code&gt;line!&lt;/code&gt; 调用的第一个宏调用！宏。</target>
        </trans-unit>
        <trans-unit id="6dec360ada9c00c421ed26b5b352f032e17122ed" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is &lt;em&gt;O&lt;/em&gt;(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 的预期成本是&lt;em&gt;O&lt;/em&gt;（1），它在被推入元素的每个可能的排序上以及在足够大的推入次数上平均。这是最有意义的成本度量推动那些元素时，&lt;em&gt;不&lt;/em&gt;已经在任何排序方式。</target>
        </trans-unit>
        <trans-unit id="606b0f6565bb5e33a7e793c7978e5b02d8b8d28b" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is O(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 的预期成本是O（1），在推入的元素的每个可能的排序上以及在足够大的推入次数上平均。这是最有意义的成本度量推动那些元素时，&lt;em&gt;不&lt;/em&gt;已经在任何排序方式。</target>
        </trans-unit>
        <trans-unit id="a72ec7eef34f0a8ffd7d99e9cfce2da0536188e2" translate="yes" xml:space="preserve">
          <source>The expression above creates a value of type &lt;code&gt;MyUnion&lt;/code&gt; and initializes the storage using field &lt;code&gt;f1&lt;/code&gt;. The union can be accessed using the same syntax as struct fields:</source>
          <target state="translated">上面的表达式创建一个 &lt;code&gt;MyUnion&lt;/code&gt; 类型的值，并使用字段 &lt;code&gt;f1&lt;/code&gt; 初始化存储。可以使用与struct字段相同的语法访问联合：</target>
        </trans-unit>
        <trans-unit id="b5fa765f11cc060019641c8e75e38c695bdb1bda" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:</source>
          <target state="translated">该表达式不能是&lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;惰性布尔运算符&lt;/a&gt;。懒惰布尔运算符的使用与语言的计划功能更改（if-let链的实现-参见&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;）模棱两可。当需要惰性布尔运算符表达式时，可以通过如下使用括号来实现：</target>
        </trans-unit>
        <trans-unit id="a608f321648c235bb5c3f09a506a153d6d9a7fa1" translate="yes" xml:space="preserve">
          <source>The expression for a match arm.</source>
          <target state="translated">匹配臂的表达方式。</target>
        </trans-unit>
        <trans-unit id="edc402eeeb9a7639cb3c026b59f168e6cd732965" translate="yes" xml:space="preserve">
          <source>The expression immediately following &lt;code&gt;in&lt;/code&gt; must implement the &lt;a href=&quot;../book/ch13-04-performance&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">表达紧跟 &lt;code&gt;in&lt;/code&gt; 必须实现&lt;a href=&quot;../book/ch13-04-performance&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;特质。</target>
        </trans-unit>
        <trans-unit id="64c3c13114c938924165b32b931fcfa0929a3dad" translate="yes" xml:space="preserve">
          <source>The expression in the &lt;code&gt;if&lt;/code&gt; block evaluates to an integer, and the expression in the &lt;code&gt;else&lt;/code&gt; block evaluates to a string. This won&amp;rsquo;t work because variables must have a single type. Rust needs to know at compile time what type the &lt;code&gt;number&lt;/code&gt; variable is, definitively, so it can verify at compile time that its type is valid everywhere we use &lt;code&gt;number&lt;/code&gt;. Rust wouldn&amp;rsquo;t be able to do that if the type of &lt;code&gt;number&lt;/code&gt; was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 块中的表达式计算为整数， &lt;code&gt;else&lt;/code&gt; 块中的表达式计算为字符串。这将不起作用，因为变量必须具有单一类型。 Rust需要在编译时确切地知道 &lt;code&gt;number&lt;/code&gt; 变量的类型，因此Rust 可以在编译时验证在我们使用 &lt;code&gt;number&lt;/code&gt; 的任何地方其类型都是有效的。如果仅在运行时确定 &lt;code&gt;number&lt;/code&gt; 的类型，Rust将无法做到这一点。如果编译器必须跟踪任何变量的多个假设类型，则编译器将更加复杂并且对代码的保证更少。</target>
        </trans-unit>
        <trans-unit id="7947155b0fa5fdbbf2d84b0fb9bff1298adf4bf1" translate="yes" xml:space="preserve">
          <source>The extension is:</source>
          <target state="translated">延伸是:</target>
        </trans-unit>
        <trans-unit id="ea39e7727f6084ef5165d4f9b888542528c3cc1d" translate="yes" xml:space="preserve">
          <source>The external crate is resolved to a specific &lt;code&gt;soname&lt;/code&gt; at compile time, and a runtime linkage requirement to that &lt;code&gt;soname&lt;/code&gt; is passed to the linker for loading at runtime. The &lt;code&gt;soname&lt;/code&gt; is resolved at compile time by scanning the compiler's library path and matching the optional &lt;code&gt;crateid&lt;/code&gt; provided against the &lt;code&gt;crateid&lt;/code&gt; attributes that were declared on the external crate when it was compiled. If no &lt;code&gt;crateid&lt;/code&gt; is provided, a default &lt;code&gt;name&lt;/code&gt; attribute is assumed, equal to the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; given in the &lt;code&gt;extern crate&lt;/code&gt; declaration.</source>
          <target state="translated">在编译时，将外部包装箱解析为特定的 &lt;code&gt;soname&lt;/code&gt; ，并将对该 &lt;code&gt;soname&lt;/code&gt; 的运行时链接要求传递给链接器，以在运行时进行加载。该 &lt;code&gt;soname&lt;/code&gt; 通过扫描编译器的库路径和配套可选在编译时解析 &lt;code&gt;crateid&lt;/code&gt; 对提供 &lt;code&gt;crateid&lt;/code&gt; 被宣布在外部箱，当它被编译属性。如果未提供 &lt;code&gt;crateid&lt;/code&gt; ，则采用默认 &lt;code&gt;name&lt;/code&gt; 属性，该属性等于 &lt;code&gt;extern crate&lt;/code&gt; 声明中给出的&lt;a href=&quot;../identifiers&quot;&gt;标识符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d4ff9b9a673e6ef5c73fd0d74de95c1584abb9d" translate="yes" xml:space="preserve">
          <source>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt;. The panic message that we did get in this case was &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Now we can start figuring out where our bug is!</source>
          <target state="translated">失败消息指示该测试确实确实像我们期望的那样发生了紧急情况，但是该紧急情况消息未包含预期的字符串 &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt; 。在这种情况下，我们确实得到的恐慌消息是 &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; 现在我们可以开始弄清楚我们的错误在哪里！</target>
        </trans-unit>
        <trans-unit id="1264d4255ef5d1877747639a91dce97d95706422" translate="yes" xml:space="preserve">
          <source>The family of the operating system. Example value is &lt;code&gt;unix&lt;/code&gt;.</source>
          <target state="translated">操作系统家族。示例值为 &lt;code&gt;unix&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f19a750b2fcc57343d113fae5c2d35cbbeabd61" translate="yes" xml:space="preserve">
          <source>The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</source>
          <target state="translated">字段名可以是十进制整数值,用于指定构造元组结构的索引。这可以和基础结构一起使用,以填充未指定的剩余指数。</target>
        </trans-unit>
        <trans-unit id="0bbc5c6747805ec7b206ff1d7bd4fc19a67e98d4" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; are dropped in declaration order.</source>
          <target state="translated">&lt;a href=&quot;types/struct&quot;&gt;结构&lt;/a&gt;的字段按声明顺序删除。</target>
        </trans-unit>
        <trans-unit id="c1e05fef4f32d53e63c8251d9d852a226e0b9d94" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order. *</source>
          <target state="translated">&lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;，&lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt;或&lt;a href=&quot;types/enum&quot;&gt;enum变体&lt;/a&gt;的字段按声明顺序删除。*</target>
        </trans-unit>
        <trans-unit id="ad3f74fe8b6e787f7b7254796fcea650c623bbf0" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; are dropped in order.</source>
          <target state="translated">&lt;a href=&quot;types/tuple&quot;&gt;元组&lt;/a&gt;的字段按顺序删除。</target>
        </trans-unit>
        <trans-unit id="985befbf65bb726fbdc7e8fa5788956f4d2e4bf1" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;code&gt;struct&lt;/code&gt; may be qualified by &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibility modifiers&lt;/a&gt;, to allow access to data in a struct outside a module.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 的字段可以由&lt;a href=&quot;../visibility-and-privacy&quot;&gt;可见性修饰符&lt;/a&gt;限定，以允许访问模块外部结构中的数据。</target>
        </trans-unit>
        <trans-unit id="d44253ff03665f86e16760d6d12a49f11125c4e2" translate="yes" xml:space="preserve">
          <source>The fields of the active &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order.</source>
          <target state="translated">活动&lt;a href=&quot;types/enum&quot;&gt;枚举变量&lt;/a&gt;的字段按声明顺序删除。</target>
        </trans-unit>
        <trans-unit id="40ccc036f7a6ce305846dd9b315fdf1f96b15a3b" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">该结构的字段表明，我们解析的Rust代码是一个单元结构，具有 &lt;code&gt;Pancakes&lt;/code&gt; 的 &lt;code&gt;ident&lt;/code&gt; （标识符，即名称）。此结构上还有更多字段用于描述各种Rust代码。检查&lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt;的文档 &lt;code&gt;DeriveInput&lt;/code&gt; 以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="b0794c80e766c7ef30098e79990a99a126d86062" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">该结构的字段表明，我们解析的Rust代码是一个单元结构，具有 &lt;code&gt;Pancakes&lt;/code&gt; 的 &lt;code&gt;ident&lt;/code&gt; （标识符，即名称）。此结构上还有更多字段用于描述各种Rust代码。检查&lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt;的文档 &lt;code&gt;DeriveInput&lt;/code&gt; 以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="41f21e4814cce1d92447f83c7dd9a65499d60626" translate="yes" xml:space="preserve">
          <source>The file doesn't exist.</source>
          <target state="translated">该文件不存在。</target>
        </trans-unit>
        <trans-unit id="c618b2bfdd921c07e86f2a30b8c3ccd4f98ae789" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found).</source>
          <target state="translated">该文件相对于当前文件的位置(类似于模块的查找方式)。</target>
        </trans-unit>
        <trans-unit id="0630128fbb4da19cb239333b356fc43bbab7e18f" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found). The provided path is interpreted in a platform-specific way at compile time. So, for instance, an invocation with a Windows path containing backslashes &lt;code&gt;\&lt;/code&gt; would not compile correctly on Unix.</source>
          <target state="translated">该文件相对于当前文件位于（类似于查找模块的方式）。提供的路径在编译时以特定于平台的方式进行解释。因此，例如，使用Windows路径包含反斜杠 &lt;code&gt;\&lt;/code&gt; 的调用在Unix上无法正确编译。</target>
        </trans-unit>
        <trans-unit id="a1df7519bc8cdda06f6336bd152ecc0e5b1b6c7c" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file. (similarly to how modules are found)</source>
          <target state="translated">文件的位置是相对于当前文件而言的。(类似于模块的查找方式)</target>
        </trans-unit>
        <trans-unit id="d6c5af6a5c60f4fa56d05a0fa81955ff57e694aa" translate="yes" xml:space="preserve">
          <source>The file must be opened with write access for truncate to work.</source>
          <target state="translated">该文件必须在有写权限的情况下打开,以便截断工作。</target>
        </trans-unit>
        <trans-unit id="b64dc47988604588017060c77446efa88568cbbc" translate="yes" xml:space="preserve">
          <source>The file must be opened with write or append access in order to create a new file.</source>
          <target state="translated">打开文件时必须有写或追加权限,才能创建新文件。</target>
        </trans-unit>
        <trans-unit id="55a4d79c2d543091872b4da347b5d4b201da5902" translate="yes" xml:space="preserve">
          <source>The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.</source>
          <target state="translated">文件的光标不会改变。特别是,如果光标在末尾,而使用此操作缩小文件,现在光标将超过末尾。</target>
        </trans-unit>
        <trans-unit id="6c8ba754d920c70b815c96a59ae89e2ab19e9615" translate="yes" xml:space="preserve">
          <source>The fill character is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. The extra characters are specified by &lt;code&gt;fill&lt;/code&gt;, and the alignment can be one of the following options:</source>
          <target state="translated">通常与&lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt;参数一起提供填充字符。这表示如果要格式化的值小于 &lt;code&gt;width&lt;/code&gt; 则会在其周围打印一些额外的字符。多余的字符由 &lt;code&gt;fill&lt;/code&gt; 指定，并且对齐方式可以是以下选项之一：</target>
        </trans-unit>
        <trans-unit id="85f2c169cb253978c0bcbcb827b4f9bdee23de08" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is accessing fields of a &lt;em&gt;union&lt;/em&gt;. A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">只有与工作的最后行动 &lt;code&gt;unsafe&lt;/code&gt; 正在访问的领域&lt;em&gt;工会&lt;/em&gt;。一个 &lt;code&gt;union&lt;/code&gt; 是类似 &lt;code&gt;struct&lt;/code&gt; ，但只有一个声明字段在特定的情况下在同一时间使用。联合主要用于与C代码中的联合接口。访问联合字段是不安全的，因为Rust无法保证当前存储在联合实例中的数据的类型。您可以在&lt;a href=&quot;../reference/items/unions&quot;&gt;参考资料中&lt;/a&gt;了解有关联合的更多信息。</target>
        </trans-unit>
        <trans-unit id="93dbdf12316da4d04bf621e9eb356e67a9dd2780" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">仅对 &lt;code&gt;unsafe&lt;/code&gt; 行为起作用的最后操作是实现不安全特征。当特征的至少一种方法具有一些编译器无法验证的不变式时，它是不安全的。我们可以声明一个特点是 &lt;code&gt;unsafe&lt;/code&gt; 通过添加 &lt;code&gt;unsafe&lt;/code&gt; 之前关键字 &lt;code&gt;trait&lt;/code&gt; 和标记性状为实施 &lt;code&gt;unsafe&lt;/code&gt; 太，如清单19-11英寸</target>
        </trans-unit>
        <trans-unit id="49a4f7cf0e0e66e3c555d75f0978be5130fe5dec" translate="yes" xml:space="preserve">
          <source>The final expression of any extending &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;.</source>
          <target state="translated">任何扩展&lt;a href=&quot;expressions/block-expr&quot;&gt;块表达式&lt;/a&gt;的最终表达式。</target>
        </trans-unit>
        <trans-unit id="5d305704a4fbc5372e6355348bdb324639855c0b" translate="yes" xml:space="preserve">
          <source>The final line ending is optional.</source>
          <target state="translated">最后一行结尾是可选的。</target>
        </trans-unit>
        <trans-unit id="7bcad5659fa398bc4723e1a1e4ec534359f32934" translate="yes" xml:space="preserve">
          <source>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</source>
          <target state="translated">最后一行结尾是可选的。以最后一行结尾的字符串将返回与没有最后一行结尾的字符串相同的行数。</target>
        </trans-unit>
        <trans-unit id="d405e4ac4031d3643938bc829210c93b1a171c2a" translate="yes" xml:space="preserve">
          <source>The final line ending isn't required:</source>
          <target state="translated">最后一行结尾不需要。</target>
        </trans-unit>
        <trans-unit id="c5271e27e91796af655967c8ffbfa429a17a75cb" translate="yes" xml:space="preserve">
          <source>The final result could be determined just by looking at the code at compile time, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt; might turn the whole block into a simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt;.</source>
          <target state="translated">最终结果可以仅通过在编译时查看代码来确定，因此&lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;不断折叠&lt;/a&gt;可能会将整个块变成简单的 &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e59d9d4ed7f661f21e1daf6cf7e1143fd8d7bfa" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Cons&lt;/code&gt; value holds &lt;code&gt;1&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is another &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;2&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is one more &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;3&lt;/code&gt; and a &lt;code&gt;List&lt;/code&gt; value, which is finally &lt;code&gt;Nil&lt;/code&gt;, the non-recursive variant that signals the end of the list.</source>
          <target state="translated">第一个 &lt;code&gt;Cons&lt;/code&gt; 值包含 &lt;code&gt;1&lt;/code&gt; ，另一个 &lt;code&gt;List&lt;/code&gt; 值。此 &lt;code&gt;List&lt;/code&gt; 值是另一个 &lt;code&gt;Cons&lt;/code&gt; 值，包含 &lt;code&gt;2&lt;/code&gt; 和另一个 &lt;code&gt;List&lt;/code&gt; 值。该 &lt;code&gt;List&lt;/code&gt; 值是另一个 &lt;code&gt;Cons&lt;/code&gt; 值，它包含 &lt;code&gt;3&lt;/code&gt; 和一个 &lt;code&gt;List&lt;/code&gt; 值，该值最后是 &lt;code&gt;Nil&lt;/code&gt; ，这是表示列表结束的非递归变量。</target>
        </trans-unit>
        <trans-unit id="b8427aa75fccc52f421b7262b47d3cb66ca8ba99" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;length&lt;/code&gt; bytes at &lt;code&gt;buf&lt;/code&gt; need to be valid UTF-8.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 的第一个 &lt;code&gt;length&lt;/code&gt; 字节必须是有效的UTF-8。</target>
        </trans-unit>
        <trans-unit id="b2f6ee38297963ecf451ec169c5ecff0bb88450f" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;format!&lt;/code&gt; receives is a format string. This must be a string literal. The power of the formatting string is in the &lt;code&gt;{}&lt;/code&gt;s contained.</source>
          <target state="translated">第一个参数 &lt;code&gt;format!&lt;/code&gt; receive是一个格式字符串。这必须是字符串文字。格式字符串的作用是包含在 &lt;code&gt;{}&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="172d64775742c02b6a5a5317561d4368b0242e63" translate="yes" xml:space="preserve">
          <source>The first argument we gave to the &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt;, is equal to the result of calling &lt;code&gt;add_two(2)&lt;/code&gt;. The line for this test is &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt;, and the &lt;code&gt;ok&lt;/code&gt; text indicates that our test passed!</source>
          <target state="translated">我们给 &lt;code&gt;assert_eq!&lt;/code&gt; 的第一个参数！宏 &lt;code&gt;4&lt;/code&gt; 等于调用 &lt;code&gt;add_two(2)&lt;/code&gt; 的结果。该测试的行是 &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt; ， &lt;code&gt;ok&lt;/code&gt; 文本表明我们的测试通过了！</target>
        </trans-unit>
        <trans-unit id="3de15e9c98b000a8208779afdf2f678b58acd245" translate="yes" xml:space="preserve">
          <source>The first arm will match any point that lies on the &lt;code&gt;x&lt;/code&gt; axis by specifying that the &lt;code&gt;y&lt;/code&gt; field matches if its value matches the literal &lt;code&gt;0&lt;/code&gt;. The pattern still creates an &lt;code&gt;x&lt;/code&gt; variable that we can use in the code for this arm.</source>
          <target state="translated">第一条手臂将通过指定 &lt;code&gt;y&lt;/code&gt; 字段（如果其值与文字 &lt;code&gt;0&lt;/code&gt; 匹配）匹配来匹配 &lt;code&gt;x&lt;/code&gt; 轴上的任何点。该模式仍然会创建一个 &lt;code&gt;x&lt;/code&gt; 变量，我们可以在此手臂的代码中使用它。</target>
        </trans-unit>
        <trans-unit id="0d5278ef07d533df9f2058795a528bf65f8762b5" translate="yes" xml:space="preserve">
          <source>The first character is &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">第一个字符是 &lt;code&gt;_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6995348ce355253fb2b3997cb5b666e8341177e1" translate="yes" xml:space="preserve">
          <source>The first character is a letter.</source>
          <target state="translated">第一个字符是一个字母。</target>
        </trans-unit>
        <trans-unit id="a8c76b012fc5c6ec5d1d2757128af41ec43b821f" translate="yes" xml:space="preserve">
          <source>The first collection type we&amp;rsquo;ll look at is &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, also known as a &lt;em&gt;vector&lt;/em&gt;. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</source>
          <target state="translated">我们将要研究的第一个集合类型是 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，也称为&lt;em&gt;vector&lt;/em&gt;。向量使您可以在单个数据结构中存储多个值，该结构将所有值彼此相邻放置在内存中。向量只能存储相同类型的值。当您具有项目列表时，例如文件中的文本行或购物车中项目的价格时，它们很有用。</target>
        </trans-unit>
        <trans-unit id="428cb6a8ac810de3963e02d4205a82867bb3d81a" translate="yes" xml:space="preserve">
          <source>The first command creates a new directory called &lt;em&gt;hello_cargo&lt;/em&gt;. We&amp;rsquo;ve named our project &lt;em&gt;hello_cargo&lt;/em&gt;, and Cargo creates its files in a directory of the same name.</source>
          <target state="translated">第一个命令创建一个名为&lt;em&gt;hello_cargo&lt;/em&gt;的新目录。我们已将项目命名为&lt;em&gt;hello_cargo&lt;/em&gt;，并且Cargo在同名目录中创建其文件。</target>
        </trans-unit>
        <trans-unit id="63eaa7d21eca5ee74b5e72e48aed31081f441d50" translate="yes" xml:space="preserve">
          <source>The first command, &lt;code&gt;cargo new&lt;/code&gt;, takes the name of the project (&lt;code&gt;guessing_game&lt;/code&gt;) as the first argument. The second command changes to the new project&amp;rsquo;s directory.</source>
          <target state="translated">第一个命令 &lt;code&gt;cargo new&lt;/code&gt; ，将项目名称（ &lt;code&gt;guessing_game&lt;/code&gt; ）作为第一个参数。第二条命令更改为新项目的目录。</target>
        </trans-unit>
        <trans-unit id="0041dd0d29e2c266e11aba3af3bc7df1a46ad21b" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.</source>
          <target state="translated">第一个元素传统上是可执行文件的路径,但它可以被设置为任意文本,甚至可能不存在,所以为了安全起见,不应依赖这个属性。</target>
        </trans-unit>
        <trans-unit id="d1fd88a9bd4f9b97a6544f441d40f72dd7a6a337" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist. This means this property should not be relied upon for security purposes.</source>
          <target state="translated">第一个元素传统上是可执行文件的路径,但它可以被设置为任意文本,甚至可能不存在。这意味着不应为了安全目的而依赖这一属性。</target>
        </trans-unit>
        <trans-unit id="57c13dc1f835e54c634e0d373f7f324807f9c426" translate="yes" xml:space="preserve">
          <source>The first element was moved out of the array, but this is not possible because &lt;code&gt;NonCopy&lt;/code&gt; does not implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">第一个元素被移出了数组，但这是不可能的，因为 &lt;code&gt;NonCopy&lt;/code&gt; 没有实现 &lt;code&gt;Copy&lt;/code&gt; 特征。</target>
        </trans-unit>
        <trans-unit id="7e08bb0a99fdc3cd6e428394eb70ec134e104b16" translate="yes" xml:space="preserve">
          <source>The first enum shown is the usual kind of enum you'd find in a C-style language. The second shows off a hypothetical example of something storing location data, with &lt;code&gt;Coord&lt;/code&gt; being any other type that's needed, for example a struct. The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.</source>
          <target state="translated">显示的第一个枚举是在C风格语言中常见的一种枚举。第二个示例展示了一个存储位置数据的假设示例，其中 &lt;code&gt;Coord&lt;/code&gt; 是需要的任何其他类型，例如结构。第三个示例演示了变体可以存储的数据类型，范围从一无所有到元组再到匿名结构。</target>
        </trans-unit>
        <trans-unit id="356931433c23df443c1df1a79c8ba26a23e35bf5" translate="yes" xml:space="preserve">
          <source>The first error is in our &lt;code&gt;Drop&lt;/code&gt; implementation. We mentioned earlier that we intended to call &lt;code&gt;take&lt;/code&gt; on the &lt;code&gt;Option&lt;/code&gt; value to move &lt;code&gt;thread&lt;/code&gt; out of &lt;code&gt;worker&lt;/code&gt;. The following changes will do so:</source>
          <target state="translated">第一个错误是在我们的 &lt;code&gt;Drop&lt;/code&gt; 实施中。前面我们提到，我们打算呼吁 &lt;code&gt;take&lt;/code&gt; 对 &lt;code&gt;Option&lt;/code&gt; 价值的移动 &lt;code&gt;thread&lt;/code&gt; 出来 &lt;code&gt;worker&lt;/code&gt; 。进行以下更改即可：</target>
        </trans-unit>
        <trans-unit id="65b1330f4d7e9b563ff90a9ab4bea0daa6bb9857" translate="yes" xml:space="preserve">
          <source>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where &lt;code&gt;... tt&lt;/code&gt; ends and &lt;code&gt;uu ...&lt;/code&gt; begins, even as new syntactic forms are added to the language.</source>
          <target state="translated">第一个不变式表示，匹配器之后的任何实际令牌（如果有）必须位于预定跟随集中的某个位置。这样可确保即使将新的语法形式添加到语言中，合法的宏定义也将继续分配关于 &lt;code&gt;... tt&lt;/code&gt; 结束和 &lt;code&gt;uu ...&lt;/code&gt; 的位置的相同确定。</target>
        </trans-unit>
        <trans-unit id="5f19def176a50d6a90af45519ada69ee7f97eb7e" translate="yes" xml:space="preserve">
          <source>The first is that it is how much memory must be allocated to store that value.</source>
          <target state="translated">第一,它是必须分配多少内存来存储这个值。</target>
        </trans-unit>
        <trans-unit id="beaa6fcb1bf59defe3de830f4f2763f9980dd889" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporaries&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">首先是回答一个特定的问题。如果您知道哪一章回答了该问题，则可以跳到目录中的该章。否则，您可以按 &lt;code&gt;s&lt;/code&gt; 或单击顶部栏上的放大镜以搜索与您的问题相关的关键字。例如，假设您想知道何时删除在let语句中创建的临时值。如果您还不知道在&lt;a href=&quot;expressions&quot;&gt;表达式一章中&lt;/a&gt;定义&lt;a href=&quot;expressions#temporaries&quot;&gt;了临时生存期，&lt;/a&gt;则可以搜索&amp;ldquo; temporary let&amp;rdquo;，并且第一个搜索结果将带您到该部分。</target>
        </trans-unit>
        <trans-unit id="6fc0f539a4da8814ced28ee34b9432e35dbaf3f6" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">首先是回答一个特定的问题。如果知道哪一章回答了该问题，则可以跳到目录中的该章。否则，您可以按 &lt;code&gt;s&lt;/code&gt; 或单击顶部栏上的放大镜以搜索与您的问题相关的关键字。例如，假设您想知道何时删除let语句中创建的临时值。如果您还不知道在&lt;a href=&quot;expressions&quot;&gt;表达式一章中&lt;/a&gt;定义&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;了临时生存期，&lt;/a&gt;则可以搜索&amp;ldquo; temporary let&amp;rdquo;，并且第一个搜索结果将带您到该部分。</target>
        </trans-unit>
        <trans-unit id="9d5da3096efb5359ed9929a25c1646ef8f4d3a16" translate="yes" xml:space="preserve">
          <source>The first line is a &lt;em&gt;status line&lt;/em&gt; that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</source>
          <target state="translated">第一行是一个&lt;em&gt;状态行&lt;/em&gt;，其中包含响应中使用的HTTP版本，一个数字状态代码（用于汇总请求的结果）以及原因短语，用于提供状态代码的文本描述。CRLF序列之后是任何标头，另一个CRLF序列以及响应的正文。</target>
        </trans-unit>
        <trans-unit id="f9ee7ff7ce4ca8fcacdd1bbbd80ae645db3e5b9c" translate="yes" xml:space="preserve">
          <source>The first line is the &lt;em&gt;request line&lt;/em&gt; that holds information about what the client is requesting. The first part of the request line indicates the &lt;em&gt;method&lt;/em&gt; being used, such as &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt;, which describes how the client is making this request. Our client used a &lt;code&gt;GET&lt;/code&gt; request.</source>
          <target state="translated">第一行是&lt;em&gt;请求行&lt;/em&gt;，其中包含有关客户端正在请求的信息。请求行的第一部分指示正在使用的&lt;em&gt;方法&lt;/em&gt;，例如 &lt;code&gt;GET&lt;/code&gt; 或 &lt;code&gt;POST&lt;/code&gt; ，它描述了客户端如何发出此请求。我们的客户使用了 &lt;code&gt;GET&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="81a313a5dc649f34279e079a51051be71d71d911" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called.</source>
          <target state="translated">第一行显示函数定义，第二行显示完全注释的闭包定义。第三行从闭包定义中删除类型注释，第四行从括号中删除，这是可选的，因为闭包主体只有一个表达式。这些都是有效的定义，在调用它们时会产生相同的行为。</target>
        </trans-unit>
        <trans-unit id="ee8e9ca51bced15f598c9116a158790ff9d282d7" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called. Calling the closures is required for &lt;code&gt;add_one_v3&lt;/code&gt; and &lt;code&gt;add_one_v4&lt;/code&gt; to be able to compile because the types will be inferred from their usage.</source>
          <target state="translated">第一行显示函数定义，第二行显示完全注释的闭包定义。第三行从闭包定义中删除类型注释，第四行从括号中删除，这是可选的，因为闭包主体只有一个表达式。这些都是有效的定义，在调用它们时会产生相同的行为。调用闭包是 &lt;code&gt;add_one_v3&lt;/code&gt; 和 &lt;code&gt;add_one_v4&lt;/code&gt; 能够编译的要求，因为将从类型的使用中推断出这些类型。</target>
        </trans-unit>
        <trans-unit id="98148895ad25eccad7c245ba3595f3571d1d992c" translate="yes" xml:space="preserve">
          <source>The first line, &lt;code&gt;[package]&lt;/code&gt;, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we&amp;rsquo;ll add other sections.</source>
          <target state="translated">第一行 &lt;code&gt;[package]&lt;/code&gt; 是节标题，指示以下语句正在配置程序包。当我们向该文件添加更多信息时，我们将添加其他部分。</target>
        </trans-unit>
        <trans-unit id="b65c034b9a1653c1664e07497c1d14736ba472ab" translate="yes" xml:space="preserve">
          <source>The first mismatching element defines which sequence is lexicographically less or greater than the other.</source>
          <target state="translated">第一个错配元素定义了哪个序列在词法上小于或大于另一个序列。</target>
        </trans-unit>
        <trans-unit id="8b310676b3019d119c9c467f577a365e7a655455" translate="yes" xml:space="preserve">
          <source>The first new bit here is another &lt;code&gt;use&lt;/code&gt; statement, bringing a type called &lt;code&gt;std::cmp::Ordering&lt;/code&gt; into scope from the standard library. Like &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Ordering&lt;/code&gt; is another enum, but the variants for &lt;code&gt;Ordering&lt;/code&gt; are &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Greater&lt;/code&gt;, and &lt;code&gt;Equal&lt;/code&gt;. These are the three outcomes that are possible when you compare two values.</source>
          <target state="translated">这里的第一个新内容是另一个 &lt;code&gt;use&lt;/code&gt; 语句，它将标准库中的类型 &lt;code&gt;std::cmp::Ordering&lt;/code&gt; 带入范围。像 &lt;code&gt;Result&lt;/code&gt; 一样， &lt;code&gt;Ordering&lt;/code&gt; 是另一个枚举，但是 &lt;code&gt;Ordering&lt;/code&gt; 的变体是 &lt;code&gt;Less&lt;/code&gt; ， &lt;code&gt;Greater&lt;/code&gt; 和 &lt;code&gt;Equal&lt;/code&gt; 。当您比较两个值时，这是可能的三个结果。</target>
        </trans-unit>
        <trans-unit id="cc86c6e2624cc3af0cff65094ba89e9de1e68ebb" translate="yes" xml:space="preserve">
          <source>The first new line defines the &lt;code&gt;response&lt;/code&gt; variable that holds the success message&amp;rsquo;s data. Then we call &lt;code&gt;as_bytes&lt;/code&gt; on our &lt;code&gt;response&lt;/code&gt; to convert the string data to bytes. The &lt;code&gt;write&lt;/code&gt; method on &lt;code&gt;stream&lt;/code&gt; takes a &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; and sends those bytes directly down the connection.</source>
          <target state="translated">新的第一行定义了保存成功消息数据的 &lt;code&gt;response&lt;/code&gt; 变量。然后，在 &lt;code&gt;response&lt;/code&gt; 调用 &lt;code&gt;as_bytes&lt;/code&gt; ，将字符串数据转换为字节。 &lt;code&gt;stream&lt;/code&gt; 上的 &lt;code&gt;write&lt;/code&gt; 方法采用 &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; 并将这些字节直接沿连接发送。</target>
        </trans-unit>
        <trans-unit id="155e4331405457b07f19de5018b6f05e551344c8" translate="yes" xml:space="preserve">
          <source>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver&amp;mdash;the type of &lt;code&gt;self&lt;/code&gt;. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&lt;code&gt;&amp;amp;self&lt;/code&gt;), mutating (&lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or consuming (&lt;code&gt;self&lt;/code&gt;). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</source>
          <target state="translated">第一个看起来更干净。这种自动引用行为之所以有效，是因为方法具有明确的接收者（ &lt;code&gt;self&lt;/code&gt; 的类型）。给定方法的接收者和名称，Rust可以明确地确定该方法是读取（ &lt;code&gt;&amp;amp;self&lt;/code&gt; ），变异（ &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ）还是使用（ &lt;code&gt;self&lt;/code&gt; ）。在实践中，Rust使方法接收者隐含借贷这一事实是使所有权符合人体工程学的重要组成部分。</target>
        </trans-unit>
        <trans-unit id="69774098a6b4b7c12621ff37f51e96103a8b7208" translate="yes" xml:space="preserve">
          <source>The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we&amp;rsquo;ll allow the player to input a guess. Enter the code in Listing 2-1 into &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">猜谜游戏程序的第一部分将要求用户输入，处理该输入并检查输入是否符合预期形式。首先，我们将允许玩家输入一个猜测。将清单2-1中的代码输入到&lt;em&gt;src / main.rs中&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2750d61c6d5f6fdb7cf8539aba812571a959c619" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt; section). A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">我们将介绍的模块系统的第一部分是包装和包装箱。板条箱是二进制文件或库文件。该&lt;em&gt;箱根&lt;/em&gt;是源文件是生锈编译器开始，让你的箱子的根模块（我们将在解释深度模块&lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;定义模块来控制范围和隐私&amp;rdquo;&lt;/a&gt;一节）。甲&lt;em&gt;包&lt;/em&gt;是一个或多个板条箱，其提供一组功能。一个软件包包含一个&lt;em&gt;Cargo.toml&lt;/em&gt;文件，该文件描述了如何构建这些包装箱。</target>
        </trans-unit>
        <trans-unit id="84c014079631c14ba610d8bbfcba357c51089179" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt;) section. A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">我们将介绍的模块系统的第一部分是包装和包装箱。条板箱是二进制文件或库。该&lt;em&gt;箱根&lt;/em&gt;是源文件是生锈编译器开始，让你的箱子的根模块（我们将解释在深度模块的&lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;定义模块来控制范围和保密性&amp;rdquo;&lt;/a&gt;）部分。甲&lt;em&gt;包&lt;/em&gt;是一个或多个板条箱，其提供一组功能。一个软件包包含一个&lt;em&gt;Cargo.toml&lt;/em&gt;文件，该文件描述了如何构建这些包装箱。</target>
        </trans-unit>
        <trans-unit id="af7ae34fc30a5ff985eeb202b31d100b9995dad4" translate="yes" xml:space="preserve">
          <source>The first problem is that a &lt;code&gt;Cacher&lt;/code&gt; instance assumes it will always get the same value for the parameter &lt;code&gt;arg&lt;/code&gt; to the &lt;code&gt;value&lt;/code&gt; method. That is, this test of &lt;code&gt;Cacher&lt;/code&gt; will fail:</source>
          <target state="translated">第一个问题是 &lt;code&gt;Cacher&lt;/code&gt; 实例假定它将始终为 &lt;code&gt;value&lt;/code&gt; 方法的参数 &lt;code&gt;arg&lt;/code&gt; 获得相同的值。也就是说，对 &lt;code&gt;Cacher&lt;/code&gt; 的测试将失败：</target>
        </trans-unit>
        <trans-unit id="dafa36fcdade4f5ce81d7dee337248690a10ae6d" translate="yes" xml:space="preserve">
          <source>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</source>
          <target state="translated">第一个目的与第二个目的类似,但是相反:如果你想给现有的trait添加一个类型参数,你可以给它一个默认值,以允许扩展trait的功能,而不破坏现有的实现代码。</target>
        </trans-unit>
        <trans-unit id="5f5a900754c112ed82386f584763afdd02db421d" translate="yes" xml:space="preserve">
          <source>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt;; a function with two parameters gets two separate lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt;; and so on.</source>
          <target state="translated">第一条规则是作为引用的每个参数都有其自己的生命周期参数。换句话说，具有一个参数的函数将获得一个生命周期参数： &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt; ;具有两个参数的函数将获得两个单独的生命周期参数： &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt; ;等等。</target>
        </trans-unit>
        <trans-unit id="d13f338beec8e6c884aee47f7c30a9f0bc21c5c9" translate="yes" xml:space="preserve">
          <source>The first section of the output shows that the &lt;code&gt;it_works&lt;/code&gt; test in the &lt;code&gt;add-one&lt;/code&gt; crate passed. The next section shows that zero tests were found in the &lt;code&gt;adder&lt;/code&gt; crate, and then the last section shows zero documentation tests were found in the &lt;code&gt;add-one&lt;/code&gt; crate. Running &lt;code&gt;cargo test&lt;/code&gt; in a workspace structured like this one will run the tests for all the crates in the workspace.</source>
          <target state="translated">输出的第一部分显示在 &lt;code&gt;add-one&lt;/code&gt; 包装箱中的 &lt;code&gt;it_works&lt;/code&gt; 测试已通过。接下来的部分显示了零次测试中发现的 &lt;code&gt;adder&lt;/code&gt; 箱子，然后在发现最后一节显示零个文档测试 &lt;code&gt;add-one&lt;/code&gt; 箱子。在具有这种结构的工作区中运行 &lt;code&gt;cargo test&lt;/code&gt; 将对工作区中的所有板条箱运行测试。</target>
        </trans-unit>
        <trans-unit id="1aa6d921fdf65cd84a902ac9021b32a10817790a" translate="yes" xml:space="preserve">
          <source>The first step is to build a list of candidate receiver types. Obtain these by repeatedly &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; the receiver expression's type, adding each type encountered to the list, then finally attempting an &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;unsized coercion&lt;/a&gt; at the end, and adding the result type if that is successful. Then, for each candidate &lt;code&gt;T&lt;/code&gt;, add &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to the list immediately after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">第一步是建立候选接收器类型的列表。通过重复&lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;引用&lt;/a&gt;接收方表达式的类型，将遇到的每种类型添加到列表中，然后最后尝试在结尾处尝试&lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;不定大小的强制&lt;/a&gt;，并在成功的情况下添加结果类型，来获取这些内容。然后，对每个候选 &lt;code&gt;T&lt;/code&gt; ，添加 &lt;code&gt;&amp;amp;T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 后立即给列表 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7046b8e80cd49555b791ba84b08e3a496f0ebd34" translate="yes" xml:space="preserve">
          <source>The first step is to install Rust. We&amp;rsquo;ll download Rust through &lt;code&gt;rustup&lt;/code&gt;, a command line tool for managing Rust versions and associated tools. You&amp;rsquo;ll need an internet connection for the download.</source>
          <target state="translated">第一步是安装Rust。我们将通过 &lt;code&gt;rustup&lt;/code&gt; （一个用于管理Rust版本和相关工具的命令行工具）下载Rust 。您需要互联网连接才能下载。</target>
        </trans-unit>
        <trans-unit id="50ad5f65969d8efb886424560b9363334f047aa4" translate="yes" xml:space="preserve">
          <source>The first store to &lt;code&gt;C&lt;/code&gt; might be moved before the store to &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;em&gt;as if&lt;/em&gt; we had written &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt;.</source>
          <target state="translated">第一商店 &lt;code&gt;C&lt;/code&gt; 可能商店之前被移动 &lt;code&gt;A&lt;/code&gt; 或 &lt;code&gt;B&lt;/code&gt; ，&lt;em&gt;仿佛&lt;/em&gt;我们已经写入 &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a6ba14d6296fbc087c2dbd538a2ed25e14b36c1" translate="yes" xml:space="preserve">
          <source>The first task is to make &lt;code&gt;minigrep&lt;/code&gt; accept its two command line arguments: the filename and a string to search for. That is, we want to be able to run our program with &lt;code&gt;cargo run&lt;/code&gt;, a string to search for, and a path to a file to search in, like so:</source>
          <target state="translated">第一个任务是使 &lt;code&gt;minigrep&lt;/code&gt; 接受其两个命令行参数：文件名和要搜索的字符串。也就是说，我们希望能够使用 &lt;code&gt;cargo run&lt;/code&gt; ，要搜索的字符串和要搜索的文件的路径来运行程序，如下所示：</target>
        </trans-unit>
        <trans-unit id="31729bd9aa0c04461ab01bb63b4c75c53baddad1" translate="yes" xml:space="preserve">
          <source>The first time we call &lt;code&gt;example_closure&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt; value, the compiler infers the type of &lt;code&gt;x&lt;/code&gt; and the return type of the closure to be &lt;code&gt;String&lt;/code&gt;. Those types are then locked in to the closure in &lt;code&gt;example_closure&lt;/code&gt;, and we get a type error if we try to use a different type with the same closure.</source>
          <target state="translated">首次使用 &lt;code&gt;String&lt;/code&gt; 值调用 &lt;code&gt;example_closure&lt;/code&gt; 时，编译器会推断 &lt;code&gt;x&lt;/code&gt; 的类型以及闭包的返回类型为 &lt;code&gt;String&lt;/code&gt; 。然后将这些类型锁定在 &lt;code&gt;example_closure&lt;/code&gt; 中的闭包中，如果尝试对同一闭包使用其他类型，则会收到类型错误。</target>
        </trans-unit>
        <trans-unit id="bd2776b4ba26113bcf03f01d82d4cc2a793fc112" translate="yes" xml:space="preserve">
          <source>The first time we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use an absolute path. The &lt;code&gt;add_to_waitlist&lt;/code&gt; function is defined in the same crate as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, which means we can use the &lt;code&gt;crate&lt;/code&gt; keyword to start an absolute path.</source>
          <target state="translated">第一次在 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数时，我们使用绝对路径。该 &lt;code&gt;add_to_waitlist&lt;/code&gt; 功能在相同的箱所限定 &lt;code&gt;eat_at_restaurant&lt;/code&gt; ，这意味着我们可以使用 &lt;code&gt;crate&lt;/code&gt; 关键字开始的绝对路径。</target>
        </trans-unit>
        <trans-unit id="fcbd8f43979f6a3f91b2e8d0489ac836799ae483" translate="yes" xml:space="preserve">
          <source>The first two cases are the same except for mutability. The first case states that if you have a &lt;code&gt;&amp;amp;T&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; to some type &lt;code&gt;U&lt;/code&gt;, you can get a &lt;code&gt;&amp;amp;U&lt;/code&gt; transparently. The second case states that the same deref coercion happens for mutable references.</source>
          <target state="translated">除可变性外，前两种情况相同。第一种情况表明，如果您具有 &lt;code&gt;&amp;amp;T&lt;/code&gt; ，并且 &lt;code&gt;T&lt;/code&gt; 将 &lt;code&gt;Deref&lt;/code&gt; 实现为某些类型 &lt;code&gt;U&lt;/code&gt; ，则可以透明地获得 &lt;code&gt;&amp;amp;U&lt;/code&gt; 。第二种情况指出，对于可变引用，会发生相同的反引用强制。</target>
        </trans-unit>
        <trans-unit id="286885295f7366f4af40320e50ad88bb3b1732e7" translate="yes" xml:space="preserve">
          <source>The first version of the prelude of The Rust Standard Library.</source>
          <target state="translated">锈标库》的第一版序曲。</target>
        </trans-unit>
        <trans-unit id="2833ddd57d8c251f327110ae65b75e17455b9bb3" translate="yes" xml:space="preserve">
          <source>The first will contain all indices from &lt;code&gt;[0, mid)&lt;/code&gt; (excluding the index &lt;code&gt;mid&lt;/code&gt; itself) and the second will contain all indices from &lt;code&gt;[mid, len)&lt;/code&gt; (excluding the index &lt;code&gt;len&lt;/code&gt; itself).</source>
          <target state="translated">第一个将包含来自 &lt;code&gt;[0, mid)&lt;/code&gt; 所有索引（不包括索引 &lt;code&gt;mid&lt;/code&gt; 本身），第二个将包含来自 &lt;code&gt;[mid, len)&lt;/code&gt; 所有索引（不包括索引 &lt;code&gt;len&lt;/code&gt; 本身）。</target>
        </trans-unit>
        <trans-unit id="d13813ed09799c4deb40bb4b4bb042ae0365adde" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; affect compile-time limits.</source>
          <target state="translated">以下&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;影响编译时限制。</target>
        </trans-unit>
        <trans-unit id="1c0907607a038e19917ef67594e99ddd26567897" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for changing how a type can be used.</source>
          <target state="translated">以下&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;用于更改类型的使用方式。</target>
        </trans-unit>
        <trans-unit id="53b431e371001b409fc98d06f983cdb135709c0f" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling code generation.</source>
          <target state="translated">以下&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;用于控制代码生成。</target>
        </trans-unit>
        <trans-unit id="26da618b938f5c0f34421c8ac509923a988969a6" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling or generating diagnostic messages during compilation.</source>
          <target state="translated">以下&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;用于在编译期间控制或生成诊断消息。</target>
        </trans-unit>
        <trans-unit id="a094c614790975d250927975ec0fe6928fcd7c3a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for specifying functions for performing tests. Compiling a crate in &quot;test&quot; mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the &lt;a href=&quot;../conditional-compilation#test&quot;&gt;&lt;code&gt;test&lt;/code&gt; conditional compilation option&lt;/a&gt;.</source>
          <target state="translated">以下&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;用于指定执行测试的功能。在&amp;ldquo;测试&amp;rdquo;模式下编译包装箱可以构建测试功能以及用于执行测试的测试工具。启用测试模式还会启用&lt;a href=&quot;../conditional-compilation#test&quot;&gt; &lt;code&gt;test&lt;/code&gt; 条件编译选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6bd6f609f21755a5a941e395bd92f148b7a32a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; control the behavior of external blocks.</source>
          <target state="translated">以下&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;控制外部块的行为。</target>
        </trans-unit>
        <trans-unit id="e4c3204613b4a8b1aeaa7e0d193d03d0b636c5e8" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;join_slices&lt;/code&gt; function is &lt;strong&gt;unsound&lt;/strong&gt; ⚠️</source>
          <target state="translated">以下 &lt;code&gt;join_slices&lt;/code&gt; 函数&lt;strong&gt;不健全&lt;/strong&gt;⚠️</target>
        </trans-unit>
        <trans-unit id="34e28a9dda5b8f30dd258681b177c05e512cb9ec" translate="yes" xml:space="preserve">
          <source>The following are examples of struct expressions:</source>
          <target state="translated">以下是结构表达式的例子。</target>
        </trans-unit>
        <trans-unit id="0cfa813f73eeb4b3df6024040cdcdc9bf704edb3" translate="yes" xml:space="preserve">
          <source>The following code tries to return a closure directly, but it won&amp;rsquo;t compile:</source>
          <target state="translated">以下代码尝试直接返回闭包，但不会编译：</target>
        </trans-unit>
        <trans-unit id="9fdd790090c328b0bac332ac3bf94fd48a22d310" translate="yes" xml:space="preserve">
          <source>The following coercions are called &lt;code&gt;unsized coercions&lt;/code&gt;, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</source>
          <target state="translated">下列强制称为 &lt;code&gt;unsized coercions&lt;/code&gt; 大小转换，因为它们与将大小类型转换为未大小类型有关，如上所述，在少数情况下，其他强制类型不允许使用。它们仍然可以发生在可能发生强制的其他任何地方。</target>
        </trans-unit>
        <trans-unit id="5faa68338d0213add2f9ec4c067dc00f82eb825f" translate="yes" xml:space="preserve">
          <source>The following contexts are &lt;em&gt;place expression&lt;/em&gt; contexts:</source>
          <target state="translated">以下上下文是&lt;em&gt;场所表达&lt;/em&gt;上下文：</target>
        </trans-unit>
        <trans-unit id="a03f434198c8f12dc538595d512c2779094f1534" translate="yes" xml:space="preserve">
          <source>The following example contains a circular dependency between two traits:</source>
          <target state="translated">下面的例子包含了两个特征之间的循环依赖关系。</target>
        </trans-unit>
        <trans-unit id="19cc88ac0ce4f5388077204fb21e73c4ffb89f2d" translate="yes" xml:space="preserve">
          <source>The following example implements &lt;code&gt;Index&lt;/code&gt; on a read-only &lt;code&gt;NucleotideCount&lt;/code&gt; container, enabling individual counts to be retrieved with index syntax.</source>
          <target state="translated">以下示例在只读 &lt;code&gt;NucleotideCount&lt;/code&gt; 容器上实现 &lt;code&gt;Index&lt;/code&gt; ，从而可以使用index语法检索单个计数。</target>
        </trans-unit>
        <trans-unit id="1e6d78aaf2b8415e3caf24e2fa8603dbd9c8a54c" translate="yes" xml:space="preserve">
          <source>The following example showcases the fact that exclusive access to an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; implies exclusive access to its &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">下面的示例展示了一个事实，即对 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 独占访问意味着对其 &lt;code&gt;T&lt;/code&gt; 的独占访问：</target>
        </trans-unit>
        <trans-unit id="b79316b13dbff6d7faf92f7fbb6c36c3b4504a1c" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create an optional box of &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. Notice that in order to use the inner &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; value first, the &lt;code&gt;check_optional&lt;/code&gt; function needs to use pattern matching to determine whether the box has a value (i.e., it is &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(...)&lt;/code&gt;&lt;/a&gt;) or not (&lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">以下示例使用&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;创建&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;的可选框。请注意，为了首先使用内部&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;值， &lt;code&gt;check_optional&lt;/code&gt; 函数需要使用模式匹配来确定该框是否具有值（即，它是&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(...)&lt;/code&gt; &lt;/a&gt;）或没有（&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0098b757352995332c14af09f0677dc80f9a0b00" translate="yes" xml:space="preserve">
          <source>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any &lt;a href=&quot;destructors&quot;&gt;&lt;code&gt;Drop::drop&lt;/code&gt;&lt;/a&gt; calls to be run.</source>
          <target state="translated">以下表达式是常量表达式，只要任何操作数也是常量表达式且不会导致任何&lt;a href=&quot;destructors&quot;&gt; &lt;code&gt;Drop::drop&lt;/code&gt; &lt;/a&gt;调用运行即可。</target>
        </trans-unit>
        <trans-unit id="a4fd2c18c35c909a948ecc39653105d7e64c5323" translate="yes" xml:space="preserve">
          <source>The following expressions are equivalent.</source>
          <target state="translated">以下表达式是等价的。</target>
        </trans-unit>
        <trans-unit id="f79e25578dbebf348320c4abf5b91615c4d5d3bd" translate="yes" xml:space="preserve">
          <source>The following expressions can be mutable place expression contexts:</source>
          <target state="translated">以下表达式可以是可变位的表达式上下文。</target>
        </trans-unit>
        <trans-unit id="0e8e60bb585909210311dad5aced6fb1ca9a2411" translate="yes" xml:space="preserve">
          <source>The following illustrates how tokens can be directly matched after matching a &lt;code&gt;tt&lt;/code&gt; fragment:</source>
          <target state="translated">下面说明了在匹配 &lt;code&gt;tt&lt;/code&gt; 片段后如何直接匹配令牌：</target>
        </trans-unit>
        <trans-unit id="4cba4cc8b1a51987e47e31e5a3e9298ced934caa" translate="yes" xml:space="preserve">
          <source>The following is a list of the available feature names.</source>
          <target state="translated">以下是可用的特征名称列表。</target>
        </trans-unit>
        <trans-unit id="7bfbc404b57ece9100ac4d9b168ae9cc179de313" translate="yes" xml:space="preserve">
          <source>The following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">下面是一个派生宏的示例。它没有对输入做任何有用的事情，只是附加了一个功能 &lt;code&gt;answer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb90a0db80f40417302eef01e3aacf14fbc10a30" translate="yes" xml:space="preserve">
          <source>The following is an example of declaring &lt;code&gt;Shape&lt;/code&gt; to be a supertrait of &lt;code&gt;Circle&lt;/code&gt;.</source>
          <target state="translated">以下是将 &lt;code&gt;Shape&lt;/code&gt; 声明为 &lt;code&gt;Circle&lt;/code&gt; 的一个特征的示例。</target>
        </trans-unit>
        <trans-unit id="0bc86808e703044cc02c714fea381b5d6b4eb104" translate="yes" xml:space="preserve">
          <source>The following is an index of all built-in attributes.</source>
          <target state="translated">以下是所有内置属性的索引。</target>
        </trans-unit>
        <trans-unit id="7cc1fc6a380ba45eaa1f4f2110280733486f387c" translate="yes" xml:space="preserve">
          <source>The following is an overview of the available synchronization objects:</source>
          <target state="translated">以下是可用的同步对象的概述。</target>
        </trans-unit>
        <trans-unit id="e77d4cd3fb5ca40ba38b2400787449b1eb8f401a" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved beginning in the 2018 edition.</source>
          <target state="translated">以下关键词从2018年版开始保留。</target>
        </trans-unit>
        <trans-unit id="88a73d4d23e456f05faa46221aa0e7b9298c7349" translate="yes" xml:space="preserve">
          <source>The following keywords currently have the functionality described.</source>
          <target state="translated">以下关键词目前具有所述功能。</target>
        </trans-unit>
        <trans-unit id="b5d973323cad12bb72185383671304dcd5ab9469" translate="yes" xml:space="preserve">
          <source>The following keywords do not have any functionality but are reserved by Rust for potential future use.</source>
          <target state="translated">以下关键词没有任何功能,但Rust保留了这些功能,以备将来使用。</target>
        </trans-unit>
        <trans-unit id="e441a28a0807978c7d9ce6b3cf8c4bd39296d4e8" translate="yes" xml:space="preserve">
          <source>The following keywords were added beginning in the 2018 edition.</source>
          <target state="translated">从2018年版开始,增加了以下关键词。</target>
        </trans-unit>
        <trans-unit id="7de22ffd047d06a2d94087f0583e69c5de3c8513" translate="yes" xml:space="preserve">
          <source>The following language level features cannot be used in the safe subset of Rust:</source>
          <target state="translated">以下语言级别的功能不能在Rust的安全子集中使用。</target>
        </trans-unit>
        <trans-unit id="fa4bbe49e1fb3a478a935beaddada675b665b643" translate="yes" xml:space="preserve">
          <source>The following list contains all non-letters that don&amp;rsquo;t function as operators; that is, they don&amp;rsquo;t behave like a function or method call.</source>
          <target state="translated">以下列表包含所有不充当运算符的非字母；也就是说，它们的行为不像函数或方法调用。</target>
        </trans-unit>
        <trans-unit id="35b04ccb391eee75aac9df7cb7f1bfc81254ebee" translate="yes" xml:space="preserve">
          <source>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we&amp;rsquo;ll discuss in the &amp;ldquo;&lt;a href=&quot;#raw-identifiers&quot;&gt;Raw Identifiers&lt;/a&gt;&amp;rdquo; section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</source>
          <target state="translated">以下列表包含保留给Rust语言当前或将来使用的关键字。因此，它们不能用作标识符（我们将在&amp;ldquo; &lt;a href=&quot;#raw-identifiers&quot;&gt;原始标识符&lt;/a&gt; &amp;rdquo;部分中讨论的原始标识符除外），包括函数名称，变量，参数，结构字段，模块，板条箱，常量，宏，静态值，属性，类型，特征或生存期。</target>
        </trans-unit>
        <trans-unit id="92af89abc5b10810cac2bde7c4403090edbb5361" translate="yes" xml:space="preserve">
          <source>The following notations are used by the &lt;em&gt;Lexer&lt;/em&gt; and &lt;em&gt;Syntax&lt;/em&gt; grammar snippets:</source>
          <target state="translated">&lt;em&gt;Lexer&lt;/em&gt;和&lt;em&gt;Syntax&lt;/em&gt;语法摘要使用以下符号：</target>
        </trans-unit>
        <trans-unit id="6c611de22c83326f1c10498c47d838ad78c2827b" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">以下返回&lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1c03f7174ac895e9b31fae2f8cfc928f6b6b192e" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">以下返回&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="452576d6c51a73e57d8181671d67361d1616b8f6" translate="yes" xml:space="preserve">
          <source>The following return false:</source>
          <target state="translated">以下返回假。</target>
        </trans-unit>
        <trans-unit id="b857efb8bb558af5cdfcfd53ef42f4d49fe84301" translate="yes" xml:space="preserve">
          <source>The following rewritten version of &lt;code&gt;another_function&lt;/code&gt; shows what parameters look like in Rust:</source>
          <target state="translated">以下重写的 &lt;code&gt;another_function&lt;/code&gt; 版本显示了Rust中的参数：</target>
        </trans-unit>
        <trans-unit id="7befecdaf697f20709a802fcb20813e2f422fba6" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material you may find useful in your Rust journey.</source>
          <target state="translated">以下部分包含您在 Rust 旅程中可能会发现有用的参考材料。</target>
        </trans-unit>
        <trans-unit id="5d4dd709d05236da16b69a96983ce9c67ce45124" translate="yes" xml:space="preserve">
          <source>The following steps install the latest stable version of the Rust compiler. Rust&amp;rsquo;s stability guarantees ensure that all the examples in the book that compile will continue to compile with newer Rust versions. The output might differ slightly between versions, because Rust often improves error messages and warnings. In other words, any newer, stable version of Rust you install using these steps should work as expected with the content of this book.</source>
          <target state="translated">以下步骤将安装Rust编译器的最新稳定版本。Rust的稳定性保证可确保本书中所有编译的示例将继续使用较新的Rust版本进行编译。不同版本之间的输出可能会略有不同，因为Rust经常会改进错误消息和警告。换句话说，使用这些步骤安装的任何较新的稳定版本的Rust都应该可以按本书的预期工作。</target>
        </trans-unit>
        <trans-unit id="d23c37bf8f18aef980fb1fbefe90db0a500a0719" translate="yes" xml:space="preserve">
          <source>The following table gives the size for primitives.</source>
          <target state="translated">下表给出了基元的尺寸。</target>
        </trans-unit>
        <trans-unit id="3bc9c0126109b1bad1345c2a1d2c68127ed67d67" translate="yes" xml:space="preserve">
          <source>The following traits are implemented for all &lt;code&gt;&amp;amp;T&lt;/code&gt;, regardless of the type of its referent:</source>
          <target state="translated">所有 &lt;code&gt;&amp;amp;T&lt;/code&gt; 都实现了以下特征，无论其引用的类型如何：</target>
        </trans-unit>
        <trans-unit id="3e9fcf457a5e9ecd7495ab63bfd0f41db2476290" translate="yes" xml:space="preserve">
          <source>The following traits are implemented on &lt;code&gt;&amp;amp;T&lt;/code&gt; references if the underlying &lt;code&gt;T&lt;/code&gt; also implements that trait:</source>
          <target state="translated">如果基础 &lt;code&gt;T&lt;/code&gt; 也实现了以下特征，则在 &lt;code&gt;&amp;amp;T&lt;/code&gt; 引用上实现以下特征：</target>
        </trans-unit>
        <trans-unit id="be48c1df52265e0b68ec35bc1f2481219af6ad7a" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Custom panic hook&quot;:</source>
          <target state="translated">下面将打印 &quot;自定义恐慌钩&quot;。</target>
        </trans-unit>
        <trans-unit id="882019462e8fd74a5df1bf54582eb004918743ba" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Normal panic&quot;:</source>
          <target state="translated">下面将打印 &quot;正常恐慌&quot;。</target>
        </trans-unit>
        <trans-unit id="7ed71896f2a34a4014ac80c7f9efbde1c744961e" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(..)&lt;/code&gt; with a single &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; is a special form that does not require a comma, and matches a tuple of any size.</source>
          <target state="translated">具有单个&lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt;的形式 &lt;code&gt;(..)&lt;/code&gt; 是一种特殊形式，不需要逗号，并且可以匹配任何大小的元组。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a310cc6ed2f47da18129871732d4b9900992d6f" translate="yes" xml:space="preserve">
          <source>The formal way of describing this behavior is that expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type. We&amp;rsquo;re allowed to end this &lt;code&gt;match&lt;/code&gt; arm with &lt;code&gt;continue&lt;/code&gt; because &lt;code&gt;continue&lt;/code&gt; doesn&amp;rsquo;t return a value; instead, it moves control back to the top of the loop, so in the &lt;code&gt;Err&lt;/code&gt; case, we never assign a value to &lt;code&gt;guess&lt;/code&gt;.</source>
          <target state="translated">描述此行为的正式方式是type表达式 &lt;code&gt;!&lt;/code&gt; 可以强制为任何其他类型。我们被允许以&amp;ldquo; &lt;code&gt;continue&lt;/code&gt; &amp;rdquo;结束 &lt;code&gt;match&lt;/code&gt; ，因为&amp;ldquo; &lt;code&gt;continue&lt;/code&gt; &amp;rdquo;不返回任何值。相反，它将控制移回循环的顶部，因此在 &lt;code&gt;Err&lt;/code&gt; 的情况下，我们永远不会为 &lt;code&gt;guess&lt;/code&gt; 指定值。</target>
        </trans-unit>
        <trans-unit id="99bcb45d13b51e9ae5259463fdd2a32bb1c9a90e" translate="yes" xml:space="preserve">
          <source>The full circle constant (&amp;tau;)</source>
          <target state="translated">整圈常数（&amp;tau;）</target>
        </trans-unit>
        <trans-unit id="cd8574fedd8387c0dcc9c1aeee32062dd23e8095" translate="yes" xml:space="preserve">
          <source>The full path is created by joining the original path to &lt;code&gt;read_dir&lt;/code&gt; with the filename of this entry.</source>
          <target state="translated">完整路径是通过将 &lt;code&gt;read_dir&lt;/code&gt; 的原始路径与该条目的文件名连接起来而创建的。</target>
        </trans-unit>
        <trans-unit id="32f32b59c17ac39e46a137b79b14f93e65ff40c1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">函数 &lt;code&gt;inner_drop&lt;/code&gt; 具有&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;&lt;em&gt;应该&lt;/em&gt;具有的类型，因此确保您不会以与固定冲突的方式意外使用 &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41bd7d7e62e02a905d152c2bd99a0375a7ed8226" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;code&gt;drop&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">函数 &lt;code&gt;inner_drop&lt;/code&gt; 具有 &lt;code&gt;drop&lt;/code&gt; &lt;em&gt;应该&lt;/em&gt;具有的类型，因此确保您不会以与固定冲突的方式意外使用 &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf14d5d5cd860e1137527a26dcf1970a6fdcd6cb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;add&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 是不安全的，因为它采用了原始指针，并且必须相信该指针是有效的。原始指针上的 &lt;code&gt;add&lt;/code&gt; 方法也不安全，因为它必须相信偏移量位置也是有效的指针。因此，我们必须在对 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 调用周围放置一个 &lt;code&gt;unsafe&lt;/code&gt; 块，并 &lt;code&gt;add&lt;/code&gt; 以进行调用。通过查看代码并添加断言 &lt;code&gt;mid&lt;/code&gt; 必须小于或等于 &lt;code&gt;len&lt;/code&gt; 的断言，我们可以知道 &lt;code&gt;unsafe&lt;/code&gt; 块内使用的所有原始指针将是指向切片内数据的有效指针。这是 &lt;code&gt;unsafe&lt;/code&gt; 的可接受且适当的用法。</target>
        </trans-unit>
        <trans-unit id="bcc8f276c3240e55b6476f93fee8521728c232e7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;offset&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 是不安全的，因为它采用了原始指针，并且必须相信该指针是有效的。原始指针的 &lt;code&gt;offset&lt;/code&gt; 方法也不安全，因为它必须相信offset位置也是有效的指针。因此，我们必须在对 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 和 &lt;code&gt;offset&lt;/code&gt; 的调用周围放置一个 &lt;code&gt;unsafe&lt;/code&gt; 块，以便可以对其进行调用。通过查看代码并添加断言 &lt;code&gt;mid&lt;/code&gt; 必须小于或等于 &lt;code&gt;len&lt;/code&gt; 的断言，我们可以知道 &lt;code&gt;unsafe&lt;/code&gt; 块中使用的所有原始指针将是指向切片内数据的有效指针。这是可接受且适当的用法 &lt;code&gt;unsafe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e2ea4196275fb1f06fa7661da10e384c365aa9f" translate="yes" xml:space="preserve">
          <source>The function body block is contained within the scope of the entire function.</source>
          <target state="translated">函数体块包含在整个函数的范围内。</target>
        </trans-unit>
        <trans-unit id="2cd654b546be7671958f348149444656b0175877" translate="yes" xml:space="preserve">
          <source>The function body uses the &lt;code&gt;assert_eq!&lt;/code&gt; macro to assert that 2 + 2 equals 4. This assertion serves as an example of the format for a typical test. Let&amp;rsquo;s run it to see that this test passes.</source>
          <target state="translated">函数体使用 &lt;code&gt;assert_eq!&lt;/code&gt; 宏，以断言2 + 2等于4。此断言用作典型测试格式的示例。让我们运行它以查看此测试是否通过。</target>
        </trans-unit>
        <trans-unit id="fce36fec5fc1977be02dde267db493eca3e79d7a" translate="yes" xml:space="preserve">
          <source>The function must be called with valid byte array &lt;code&gt;buf&lt;/code&gt; of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</source>
          <target state="translated">必须使用足够大的有效字节数组 &lt;code&gt;buf&lt;/code&gt; 调用该函数，以容纳消息字节。如果消息太长而无法容纳在提供的缓冲区中，则多余的字节可能会被丢弃。</target>
        </trans-unit>
        <trans-unit id="e529ccf733a9b5ef8b1c476a20d42d70328c6fe4" translate="yes" xml:space="preserve">
          <source>The function panics if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">如果 &lt;code&gt;align&lt;/code&gt; 不是2的幂，函数会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="b268ef11b8c08ae232cf81ee855904ac47e81a51" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if there was enough space in the buffer. If there was not enough space then no credentials was appended. Technically, that means this operation adds a control message with the level &lt;code&gt;SOL_SOCKET&lt;/code&gt; and type &lt;code&gt;SCM_CREDENTIALS&lt;/code&gt; or &lt;code&gt;SCM_CREDS&lt;/code&gt;.</source>
          <target state="translated">如果缓冲区中有足够的空间，则该函数返回 &lt;code&gt;true&lt;/code&gt; 。如果没有足够的空间，则不会附加凭据。从技术上讲，这意味着此操作将添加级别为 &lt;code&gt;SOL_SOCKET&lt;/code&gt; 且类型为 &lt;code&gt;SCM_CREDENTIALS&lt;/code&gt; 或 &lt;code&gt;SCM_CREDS&lt;/code&gt; 的控制消息。</target>
        </trans-unit>
        <trans-unit id="571e08cd267873dac614b1a31157ac35e6c1e16a" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if there was enough space in the buffer. If there was not enough space then no file descriptors was appended. Technically, that means this operation adds a control message with the level &lt;code&gt;SOL_SOCKET&lt;/code&gt; and type &lt;code&gt;SCM_RIGHTS&lt;/code&gt;.</source>
          <target state="translated">如果缓冲区中有足够的空间，则该函数返回 &lt;code&gt;true&lt;/code&gt; 。如果没有足够的空间，则不会附加文件描述符。从技术上讲，这意味着此操作将添加级别为 &lt;code&gt;SOL_SOCKET&lt;/code&gt; 且类型为 &lt;code&gt;SCM_RIGHTS&lt;/code&gt; 的控制消息。</target>
        </trans-unit>
        <trans-unit id="3c4c57538d04834ae5173c38a3f23dea7037d387" translate="yes" xml:space="preserve">
          <source>The function signature now tells Rust that for some lifetime &lt;code&gt;'a&lt;/code&gt;, the function takes two parameters, both of which are string slices that live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. In practice, it means that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we&amp;rsquo;re not changing the lifetimes of any values passed in or returned. Rather, we&amp;rsquo;re specifying that the borrow checker should reject any values that don&amp;rsquo;t adhere to these constraints. Note that the &lt;code&gt;longest&lt;/code&gt; function doesn&amp;rsquo;t need to know exactly how long &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will live, only that some scope can be substituted for &lt;code&gt;'a&lt;/code&gt; that will satisfy this signature.</source>
          <target state="translated">现在，函数签名告诉Rust，对于某个生命周期 &lt;code&gt;'a&lt;/code&gt; ，该函数采用两个参数，这两个参数都是寿命至少与生命周期 &lt;code&gt;'a&lt;/code&gt; 一样长的字符串切片。该函数签名还告诉Rust，从该函数返回的字符串切片的生存时间至少与生命周期 &lt;code&gt;'a&lt;/code&gt; 一样长。实际上，这意味着引用的生命周期 &lt;code&gt;longest&lt;/code&gt; 函数与传入的引用的生存期较小者相同。这些约束是我们希望Rust强制执行的约束。请记住，当我们在此函数签名中指定生命周期参数时，我们不会更改任何传入或返回的值的生命周期。相反，我们指定借用检查器应拒绝任何不符合这些约束的值。请注意， &lt;code&gt;longest&lt;/code&gt; 函数不需要确切知道 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的生存期，只需将某个范围替换为满足该签名的 &lt;code&gt;'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdcb7a1c11baa13711e61ba40d7e28572f624f97" translate="yes" xml:space="preserve">
          <source>The function that defines a procedural macro takes a &lt;code&gt;TokenStream&lt;/code&gt; as an input and produces a &lt;code&gt;TokenStream&lt;/code&gt; as an output. The &lt;code&gt;TokenStream&lt;/code&gt; type is defined by the &lt;code&gt;proc_macro&lt;/code&gt; crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input &lt;code&gt;TokenStream&lt;/code&gt;, and the code the macro produces is the output &lt;code&gt;TokenStream&lt;/code&gt;. The function also has an attribute attached to it that specifies which kind of procedural macro we&amp;rsquo;re creating. We can have multiple kinds of procedural macros in the same crate.</source>
          <target state="translated">定义过程宏的函数将 &lt;code&gt;TokenStream&lt;/code&gt; 作为输入，并产生 &lt;code&gt;TokenStream&lt;/code&gt; 作为输出。所述 &lt;code&gt;TokenStream&lt;/code&gt; 类型由定义 &lt;code&gt;proc_macro&lt;/code&gt; 附带锈病和表示标记序列板条箱。这是宏的核心：宏正在操作的源代码组成了输入 &lt;code&gt;TokenStream&lt;/code&gt; ，宏生成的代码是输出 &lt;code&gt;TokenStream&lt;/code&gt; 。该函数还具有附加的属性，该属性指定我们要创建哪种程序宏。同一条板箱中可以有多种程序宏。</target>
        </trans-unit>
        <trans-unit id="bf36f24b39c35b8342b2a6251cb9fb9f153537b5" translate="yes" xml:space="preserve">
          <source>The function will never return and will immediately terminate the current process in a platform specific &quot;abnormal&quot; manner.</source>
          <target state="translated">该函数永远不会返回,并将以平台特有的 &quot;异常 &quot;方式立即终止当前进程。</target>
        </trans-unit>
        <trans-unit id="0c78d2fcec6d6debbe4ef0124bd9c3f517852fce" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs (struct-like enum variants don't qualify, for example). To fix the previous code, rewrite the expression without functional record update syntax:</source>
          <target state="translated">功能性记录更新语法只允许用于结构体(比如类似结构体的枚举变体就不符合条件)。为了修正前面的代码,重写没有功能记录更新语法的表达式。</target>
        </trans-unit>
        <trans-unit id="4265d286c4ebab2fa68494c58f7e5472bec6ff8e" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</source>
          <target state="translated">功能记录更新语法只允许用于结构。(例如,类似结构的枚举变体就不符合条件。)</target>
        </trans-unit>
        <trans-unit id="771371fc3674c285662522a3ce8c91121a8eb8d5" translate="yes" xml:space="preserve">
          <source>The functional record update syntax was used on something other than a struct.</source>
          <target state="translated">功能性记录更新语法被用在了结构体以外的其他地方。</target>
        </trans-unit>
        <trans-unit id="3064e7a399dc1562d735ddcb75b4d1c141aa6d18" translate="yes" xml:space="preserve">
          <source>The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax:&lt;code&gt;some_extension!(...)&lt;/code&gt;.</source>
          <target state="translated">可以使用称为宏的自定义定义扩展Rust的功能和语法。它们被赋予名称，并通过一致的语法调用： &lt;code&gt;some_extension!(...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90f6e5d380880e28cc22176bc452d0a2cfb51f5f" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">仅&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;实现内部在正确构造的&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;对象的 &lt;code&gt;data&lt;/code&gt; 指针上调用此结构内部的函数。使用任何其他 &lt;code&gt;data&lt;/code&gt; 指针调用其中一个包含的函数将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="5d3fe931a60678fe761ffe2bfb5b03361ca50257" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended to be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">仅&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;实现内部在正确构造的&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;对象的 &lt;code&gt;data&lt;/code&gt; 指针上调用此结构内部的函数。使用任何其他 &lt;code&gt;data&lt;/code&gt; 指针调用其中一个包含的函数将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="df0966ed788f9044d3bbbf28ed214b74382d234e" translate="yes" xml:space="preserve">
          <source>The general case</source>
          <target state="translated">一般情况</target>
        </trans-unit>
        <trans-unit id="44389c2bb8540f5071dbf79b16d89782c82ab1a7" translate="yes" xml:space="preserve">
          <source>The general categories for numbers (&lt;code&gt;Nd&lt;/code&gt; for decimal digits, &lt;code&gt;Nl&lt;/code&gt; for letter-like numeric characters, and &lt;code&gt;No&lt;/code&gt; for other numeric characters) are specified in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode字符数据库&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; &lt;/a&gt;中指定了数字的常规类别（ &lt;code&gt;Nd&lt;/code&gt; 代表十进制数字， &lt;code&gt;Nl&lt;/code&gt; 代表类似字母的数字字符， &lt;code&gt;No&lt;/code&gt; 代表其他数字字符）。</target>
        </trans-unit>
        <trans-unit id="3a1ceefd46a3c1a3651802a4204c4c589bc3c7f6" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;PartialEq&lt;/code&gt; is equivalent to</source>
          <target state="translated">为 &lt;code&gt;PartialEq&lt;/code&gt; 生成的 &lt;code&gt;impl&lt;/code&gt; 等效于</target>
        </trans-unit>
        <trans-unit id="b683f5ed135731413c6d034116ca989acf594401" translate="yes" xml:space="preserve">
          <source>The generator completed with a return value.</source>
          <target state="translated">生成器完成了一个返回值。</target>
        </trans-unit>
        <trans-unit id="156bc757a593c6f0753b493e20c7157ef75917ae" translate="yes" xml:space="preserve">
          <source>The generator suspended with a value.</source>
          <target state="translated">悬浮的发电机与值。</target>
        </trans-unit>
        <trans-unit id="cd45c192be4dc3d892b1ef2f0b632aaff12d6653" translate="yes" xml:space="preserve">
          <source>The generic type &lt;code&gt;T&lt;/code&gt; specified as the type of the &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; parameters constrains the function such that the concrete type of the value passed as an argument for &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; must be the same.</source>
          <target state="translated">指定为 &lt;code&gt;item1&lt;/code&gt; 和 &lt;code&gt;item2&lt;/code&gt; 参数类型的通用类型 &lt;code&gt;T&lt;/code&gt; 约束了函数，使得作为 &lt;code&gt;item1&lt;/code&gt; 和 &lt;code&gt;item2&lt;/code&gt; 的参数传递的值的具体类型必须相同。</target>
        </trans-unit>
        <trans-unit id="1bc01fb3a417f3ff749e03a42ff1490b6833bd43" translate="yes" xml:space="preserve">
          <source>The generic type has to be a SIMD type. Example:</source>
          <target state="translated">通用类型必须是SIMD类型。例如:</target>
        </trans-unit>
        <trans-unit id="e58faf99c3204433210564e65725762b8514494f" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else.</source>
          <target state="translated">给定的&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;&lt;strong&gt;必须&lt;/strong&gt;有一个nul字节作为其最后一个元素。这意味着它不能为空，也不能在其他任何地方有任何其他nul字节。</target>
        </trans-unit>
        <trans-unit id="b25fdf4b8d15b07b7d25cece8768d803831d5b3d" translate="yes" xml:space="preserve">
          <source>The given block must have been produced by this allocator, and must be suitable for storing a &lt;code&gt;T&lt;/code&gt; (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</source>
          <target state="translated">给定的块必须由该分配器产生，并且必须适合于存储 &lt;code&gt;T&lt;/code&gt; （就对齐方式以及最小和最大大小而言）；否则会产生不确定的行为。</target>
        </trans-unit>
        <trans-unit id="3ef7afeafd2e9737676d96a4cbd3c7dc2e9ffdbc" translate="yes" xml:space="preserve">
          <source>The glob operator is often used when testing to bring everything under test into the &lt;code&gt;tests&lt;/code&gt; module; we&amp;rsquo;ll talk about that in the &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;How to Write Tests&amp;rdquo;&lt;/a&gt; section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;the standard library documentation&lt;/a&gt; for more information on that pattern.</source>
          <target state="translated">测试时通常使用glob运算符将要测试的所有内容带入 &lt;code&gt;tests&lt;/code&gt; 模块；我们将在第11章的&lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;如何编写测试&amp;rdquo;&lt;/a&gt;部分中对此进行讨论。glob运算符有时也用作前奏模式的一部分：有关该模式的更多信息，请参见&lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;标准库文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edae830710bf3e8598def4042b918afe98bc10c2" translate="yes" xml:space="preserve">
          <source>The global memory allocator.</source>
          <target state="translated">全局内存分配器。</target>
        </trans-unit>
        <trans-unit id="ec4646ba1a1fdd24f47203209a1bde5837e4ed73" translate="yes" xml:space="preserve">
          <source>The good news is that if the structure &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; convenient for others to use from another library, you don&amp;rsquo;t have to rearrange your internal organization: instead, you can re-export items to make a public structure that&amp;rsquo;s different from your private structure by using &lt;code&gt;pub use&lt;/code&gt;. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</source>
          <target state="translated">好消息是，如果该结构&lt;em&gt;不&lt;/em&gt;便于其他库中的其他人使用，则不必重新安排内部组织：相反，您可以重新导出项目以形成与私有结构不同的公共结构通过使用 &lt;code&gt;pub use&lt;/code&gt; 。重新导出将一个公共项目带到一个位置，然后在另一个位置将其公开，就好像它是在另一个位置定义的一样。</target>
        </trans-unit>
        <trans-unit id="9e529cd967841dc9eed1fc815f3a4e6b886e5b38" translate="yes" xml:space="preserve">
          <source>The grammar and lexical structure is in blockquotes with either &quot;Lexer&quot; or &quot;Syntax&quot; in &lt;sup&gt;&lt;strong&gt;bold superscript&lt;/strong&gt;&lt;/sup&gt; as the first line.</source>
          <target state="translated">语法和词法结构用大括号括起来，第一行用&lt;sup&gt;&lt;strong&gt;粗体上标&lt;/strong&gt;&lt;/sup&gt; &amp;ldquo; Lexer&amp;rdquo;或&amp;ldquo; Syntax&amp;rdquo; &lt;sup&gt;&lt;strong&gt;表示&lt;/strong&gt;&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="1f36df1235888018fbfcd5153ebfed60de89aef3" translate="yes" xml:space="preserve">
          <source>The grammar production for reference patterns has to match the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to match a reference to a reference because it is a token by itself, not two &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</source>
          <target state="translated">参考模式的语法产生必须匹配标记 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 才能将参考与参考匹配，因为它本身就是一个标记，而不是两个 &lt;code&gt;&amp;amp;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="ecdb2fc042ccb9955819301d5b939d1fbe330ddf" translate="yes" xml:space="preserve">
          <source>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</source>
          <target state="translated">绿色线程M:N模型需要更大的语言运行时来管理线程。因此,Rust标准库只提供了1:1线程的实现。由于Rust是一种低级语言,如果你宁愿用开销来换取一些方面,比如对哪些线程何时运行有更多的控制权,降低上下文切换的成本,那么就会有实现M:N线程的crates。</target>
        </trans-unit>
        <trans-unit id="ebee4d45f3971e13391e35d52c5a14b0340c1efd" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured.</source>
          <target state="translated">读取子代标准误差(stderr)的句柄,如果它已经被捕获。</target>
        </trans-unit>
        <trans-unit id="71a4cc891c9774ed993ea2778e2ec4e78d46aa4f" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured. You might find it helpful to do</source>
          <target state="translated">用于读取子代标准误差(stderr)的句柄,如果它已经被捕获。你可能会发现这样做很有帮助</target>
        </trans-unit>
        <trans-unit id="fbdaac9b24bb1d15aadc721c15a3031cb1337d9a" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured.</source>
          <target state="translated">从子代的标准输出(stdout)中读取的句柄,如果它已经被捕获。</target>
        </trans-unit>
        <trans-unit id="5b65d5fd43c0bfac48d483d2399323a0f40fd595" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured. You might find it helpful to do</source>
          <target state="translated">从子系统的标准输出(stdout)中读取的句柄,如果它已经被捕获。你可能会发现这样做很有帮助</target>
        </trans-unit>
        <trans-unit id="d208573c971bb153ba34475100ea53bd4242537e" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured.</source>
          <target state="translated">写入子代标准输入(stdin)的句柄,如果它已经被捕获。</target>
        </trans-unit>
        <trans-unit id="1008f723c1fd717a94e8a77d7bc5c5ff92ef4700" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured. To avoid partially moving the &lt;code&gt;child&lt;/code&gt; and thus blocking yourself from calling functions on &lt;code&gt;child&lt;/code&gt; while using &lt;code&gt;stdin&lt;/code&gt;, you might find it helpful:</source>
          <target state="translated">写入儿童标准输入（stdin）的句柄（如果已捕获）。为了避免部分移动 &lt;code&gt;child&lt;/code&gt; ，从而避免自己在使用 &lt;code&gt;stdin&lt;/code&gt; 时调用 &lt;code&gt;child&lt;/code&gt; 上的函数，您可能会发现它很有用：</target>
        </trans-unit>
        <trans-unit id="a9febcaaba526b722c76a7ab2b805ffd862b6652" translate="yes" xml:space="preserve">
          <source>The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">哈希图的初始创建容量为0,所以在第一次插入之前不会分配。</target>
        </trans-unit>
        <trans-unit id="ee8ffcf3c4827d14350f3675ea8e7360ee55ee19" translate="yes" xml:space="preserve">
          <source>The hash map will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash map will not allocate.</source>
          <target state="translated">哈希映射将能够至少 &lt;code&gt;capacity&lt;/code&gt; 元素而无需重新分配。如果 &lt;code&gt;capacity&lt;/code&gt; 为0，则不会分配哈希映射。</target>
        </trans-unit>
        <trans-unit id="0b56c1bdca2b1b95316afe0ecdd6afdabfe66713" translate="yes" xml:space="preserve">
          <source>The hash set is also created with the default initial capacity.</source>
          <target state="translated">哈希集也是以默认的初始容量创建的。</target>
        </trans-unit>
        <trans-unit id="b637bd7a31fb790788f10cfb96ebb867cfd6151d" translate="yes" xml:space="preserve">
          <source>The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">哈希集的初始创建容量为0,所以在首次插入之前不会分配。</target>
        </trans-unit>
        <trans-unit id="7b099ba43b1ded8417cfcd0145835bc5cf64881f" translate="yes" xml:space="preserve">
          <source>The hash set will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash set will not allocate.</source>
          <target state="translated">哈希集将能够至少 &lt;code&gt;capacity&lt;/code&gt; 元素而无需重新分配。如果 &lt;code&gt;capacity&lt;/code&gt; 为0，则不会分配哈希集。</target>
        </trans-unit>
        <trans-unit id="d8a4e0ea14c5f027cfeb61abdb7d26fe519f8ab6" translate="yes" xml:space="preserve">
          <source>The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;. The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.</source>
          <target state="translated">哈希表实现是Google的&lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;的Rust端口。可以在&lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;此处&lt;/a&gt;找到SwissTable的原始C ++版本，该&lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon演讲&lt;/a&gt;概述了该算法的工作原理。</target>
        </trans-unit>
        <trans-unit id="415bb7e03ead8b051422fe277c860425b7ebbf61" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">可以使用&lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt;方法在每个 &lt;code&gt;HashMap&lt;/code&gt; 的基础上替换哈希算法。crates.io上有许多替代算法，例如&lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; crate。</target>
        </trans-unit>
        <trans-unit id="142488b9261462c1e559bf3f2ad49337e31e2ac1" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">可以使用&lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt;方法在每个 &lt;code&gt;HashMap&lt;/code&gt; 的基础上替换哈希算法。crates.io上有许多替代算法，例如&lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; crate。</target>
        </trans-unit>
        <trans-unit id="abc423f45ad76627b7f09d1c195dab7e2c377478" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt;方法在每个 &lt;code&gt;HashMap&lt;/code&gt; 的基础上替换哈希算法。&lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;在crates.io上&lt;/a&gt;有许多可用的哈希算法。</target>
        </trans-unit>
        <trans-unit id="d12087b42b0b99fc1565d3b697e609feca661351" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hash_map/struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;hash_map/struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;hash_map/struct.hashmap#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;hash_map/struct.hashmap#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt;方法在每个 &lt;code&gt;HashMap&lt;/code&gt; 的基础上替换哈希算法。&lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;在crates.io上&lt;/a&gt;有许多可用的哈希算法。</target>
        </trans-unit>
        <trans-unit id="417d67f06aec820d5f0416a0fabba770f0ab5392" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">可以使用&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt;方法在每个 &lt;code&gt;HashMap&lt;/code&gt; 的基础上替换哈希算法。crates.io上有许多替代算法，例如&lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; crate。</target>
        </trans-unit>
        <trans-unit id="36e2055f1b7671fa46f87316bf9cf49547025536" translate="yes" xml:space="preserve">
          <source>The heart and soul of this module is the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait. The core of &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; looks like this:</source>
          <target state="translated">此模块的核心和灵魂是&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;特性。&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的核心如下所示：</target>
        </trans-unit>
        <trans-unit id="f7cf9da11ff393d577012f24f0fd7f9d800c440a" translate="yes" xml:space="preserve">
          <source>The heart of the change is that where &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; used to default to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt;, it now defaults to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (here, &lt;code&gt;SomeTrait&lt;/code&gt; is the name of some trait type). Note that the only types which are affected are references to boxes, like &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt;. More common types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; are unaffected.</source>
          <target state="translated">更改的核心是 &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; 曾经默认为 &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt; ，现在它默认为 &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; （此处， &lt;code&gt;SomeTrait&lt;/code&gt; 是一些特征类型）。请注意，唯一受影响的类型是对框的引用，例如 &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt; 。 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 或 &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; 等更常见的类型不受影响。</target>
        </trans-unit>
        <trans-unit id="8b80292943879aaefba4fcd89176f25fb4fe681b" translate="yes" xml:space="preserve">
          <source>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&amp;rsquo;t tell whether the reference being returned refers to &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Actually, we don&amp;rsquo;t know either, because the &lt;code&gt;if&lt;/code&gt; block in the body of this function returns a reference to &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;else&lt;/code&gt; block returns a reference to &lt;code&gt;y&lt;/code&gt;!</source>
          <target state="translated">帮助文本显示返回类型上需要一个通用生命周期参数，因为Rust无法分辨返回的引用是 &lt;code&gt;x&lt;/code&gt; 还是 &lt;code&gt;y&lt;/code&gt; 。其实，我们也不知道，因为 &lt;code&gt;if&lt;/code&gt; 块在这个函数返回的身体参考 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块返回到基准 &lt;code&gt;y&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="d58a9f4bf1938432cc316db1e69ad2bfca3de5d4" translate="yes" xml:space="preserve">
          <source>The highest valid code point a &lt;code&gt;char&lt;/code&gt; can have.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 可以具有的最高有效代码点。</target>
        </trans-unit>
        <trans-unit id="2c0d414ff9adc0b33c0f3d50d800e4ef1b9ec6d2" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;Layout&lt;/code&gt; struct which contains information about the allocation that failed.</source>
          <target state="translated">该挂钩提供了一个 &lt;code&gt;Layout&lt;/code&gt; 结构，该结构包含有关失败分配的信息。</target>
        </trans-unit>
        <trans-unit id="c05a8db594383eaa649c0ea9f1230d31e2d9d207" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;PanicInfo&lt;/code&gt; struct which contains information about the origin of the panic, including the payload passed to &lt;code&gt;panic!&lt;/code&gt; and the source code location from which the panic originated.</source>
          <target state="translated">挂钩提供了 &lt;code&gt;PanicInfo&lt;/code&gt; 结构，该结构包含有关紧急情况起源的信息，包括传递给 &lt;code&gt;panic!&lt;/code&gt; 的有效负载！以及发生恐慌的源代码位置。</target>
        </trans-unit>
        <trans-unit id="c5e73d7bf13606a783c42b98ca4eecc2c703d2de" translate="yes" xml:space="preserve">
          <source>The identifier is more than one character. &lt;code&gt;_&lt;/code&gt; alone is not an identifier.</source>
          <target state="translated">标识符超过一个字符。 &lt;code&gt;_&lt;/code&gt; 本身不是标识符。</target>
        </trans-unit>
        <trans-unit id="714243f838efe98c2e10bdbb7f1411daa3ecd7a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</source>
          <target state="translated">标识符是路径中使用的常量的名称。类型是定义必须实现的类型。</target>
        </trans-unit>
        <trans-unit id="3a2c9033b8c31ad61606f019cbc00c4420b891b9" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias.</source>
          <target state="translated">标识符是声明的类型别名的名称。可选的特征界限必须由类型别名的实现来实现。</target>
        </trans-unit>
        <trans-unit id="1c83f053af5e622145b3145a7189cafa0c9167a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.</source>
          <target state="translated">标识符是函数的名称。相关函数的属名、参数列表、返回类型和where子句必须与相关函数的声明相同。</target>
        </trans-unit>
        <trans-unit id="c54b94a826db4a7c6ce8d411476041b69555f1aa" translate="yes" xml:space="preserve">
          <source>The identity function.</source>
          <target state="translated">身份功能。</target>
        </trans-unit>
        <trans-unit id="a0f93995f216b848984f480fd53d07ae2b2c30e6" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop instead:</source>
          <target state="translated">针对其副作用编写&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;的惯用方式是使用 &lt;code&gt;for&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="20b4ace5ebaf142e4e8addc0656248d8010dca32" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop or call the &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">针对其副作用编写&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;的惯用方式是使用 &lt;code&gt;for&lt;/code&gt; 循环或调用&lt;a href=&quot;trait.iterator#method.for_each&quot;&gt; &lt;code&gt;for_each&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="1dc3122c538d92098d293869587f4b3a0100941a" translate="yes" xml:space="preserve">
          <source>The implementation ensures that the iterator will return exactly &lt;code&gt;len()&lt;/code&gt; more times a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; value, before returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">该实现可确保迭代器在返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;之前，将精确返回 &lt;code&gt;len()&lt;/code&gt; 多次&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; 的&lt;/a&gt;值。此方法具有默认实现，因此通常不应直接实现它。但是，如果您可以提供更有效的实现，则可以这样做。请参阅&lt;a href=&quot;trait.exactsizeiterator&quot;&gt;特征级&lt;/a&gt;文档以获取示例。</target>
        </trans-unit>
        <trans-unit id="a17be86477c61cc7613b2ed105a5af337a27c206" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;Display&lt;/code&gt; uses &lt;code&gt;self.0&lt;/code&gt; to access the inner &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because &lt;code&gt;Wrapper&lt;/code&gt; is a tuple struct and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is the item at index 0 in the tuple. Then we can use the functionality of the &lt;code&gt;Display&lt;/code&gt; type on &lt;code&gt;Wrapper&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Display&lt;/code&gt; 的实现使用 &lt;code&gt;self.0&lt;/code&gt; 访问内部 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，因为 &lt;code&gt;Wrapper&lt;/code&gt; 是一个元组结构，而 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 是该元组中索引0的项。然后，我们可以在 &lt;code&gt;Wrapper&lt;/code&gt; 上使用 &lt;code&gt;Display&lt;/code&gt; 类型的功能。</target>
        </trans-unit>
        <trans-unit id="64d2ca9bc84ea7c438a453f8d81beffdb2cea48b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;get&lt;/code&gt; relies in particular on identical implementations of &lt;code&gt;Hash&lt;/code&gt; by determining the key&amp;rsquo;s hash bucket by calling &lt;code&gt;Hash::hash&lt;/code&gt; on the &lt;code&gt;Q&lt;/code&gt; value even though it inserted the key based on the hash value calculated from the &lt;code&gt;K&lt;/code&gt; value.</source>
          <target state="translated">通过在 &lt;code&gt;Q&lt;/code&gt; 值上调用 &lt;code&gt;Hash::hash&lt;/code&gt; 来确定键的哈希存储桶， &lt;code&gt;get&lt;/code&gt; 的实现尤其依赖于 &lt;code&gt;Hash&lt;/code&gt; 的相同实现，即使它基于从 &lt;code&gt;K&lt;/code&gt; 值计算得出的哈希值插入了键。</target>
        </trans-unit>
        <trans-unit id="9ddcc339944cbb72b0b66f63ad73cbbefd5f13bf" translate="yes" xml:space="preserve">
          <source>The implementation of this function must make sure to release any resources that are associated with this instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task.</source>
          <target state="translated">此功能的实现必须确保释放与此&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;实例和关联任务相关联的所有资源。</target>
        </trans-unit>
        <trans-unit id="b2b66f02783344ac4bc18a2fce3954484c2ba8e0" translate="yes" xml:space="preserve">
          <source>The implementation of this function must retain all resources that are required for this additional instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task. Calling &lt;code&gt;wake&lt;/code&gt; on the resulting &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; should result in a wakeup of the same task that would have been awoken by the original &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此功能的实现必须保留此&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;附加实例和关联任务所需的所有资源。调用 &lt;code&gt;wake&lt;/code&gt; 对所得到的&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;应导致将被惊醒由原始的相同任务的唤醒&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="497d98f3948b6fc88a56b8970a7685389e682fb3" translate="yes" xml:space="preserve">
          <source>The implementation of waking a task on an executor.</source>
          <target state="translated">在执行者身上实现任务的唤醒。</target>
        </trans-unit>
        <trans-unit id="d439e7f4f40d7bfe18d46ea25d8affbdc7117648" translate="yes" xml:space="preserve">
          <source>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</source>
          <target state="translated">使用状态模式的实现很容易扩展以增加更多的功能。要想了解使用状态模式的代码维护的简单性,请尝试以下几个建议。</target>
        </trans-unit>
        <trans-unit id="57e5372af92c8ddd71806b33dbda4afe86f48e3e" translate="yes" xml:space="preserve">
          <source>The implementing type within a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block, or the current type within a type definition.</source>
          <target state="translated">&lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt;块内的实现类型，或类型定义内的当前类型。</target>
        </trans-unit>
        <trans-unit id="9972687dbff5abd8f4ecb962303ef66ce3678542" translate="yes" xml:space="preserve">
          <source>The index ranges returned by this trait are not required to exactly match those of the forward search in reverse.</source>
          <target state="translated">该特征返回的索引范围不需要与正向反向搜索的索引范围完全一致。</target>
        </trans-unit>
        <trans-unit id="fb8e7f22599fed31a57edfd5bc4f1d4fe1de7766" translate="yes" xml:space="preserve">
          <source>The indexed operand of an array indexing expression.</source>
          <target state="translated">数组索引表达式的索引操作数。</target>
        </trans-unit>
        <trans-unit id="8a276159145a3d291ba8902040d397309a6a3910" translate="yes" xml:space="preserve">
          <source>The inferred type asks the compiler to infer the type if possible based on the surrounding information available. It cannot be used in item signatures. It is often used in generic arguments:</source>
          <target state="translated">推断类型要求编译器根据周围可用的信息尽可能地推断类型。它不能用于项目签名中。它经常被用于通用参数中。</target>
        </trans-unit>
        <trans-unit id="1b63924c7210ee52ef50642e7b6012f573489c1d" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rc&lt;/code&gt; 的固有方法都是关联的函数，这意味着您必须以&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;value.get_mut()&lt;/code&gt; 调用它们，而不是value.get_mut（）。这避免了与内部类型 &lt;code&gt;T&lt;/code&gt; 的方法的冲突。</target>
        </trans-unit>
        <trans-unit id="cdd48be31dd031602338fabd7f9987080846befd" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;struct.rc#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rc&lt;/code&gt; 的固有方法都是关联的函数，这意味着您必须以&lt;a href=&quot;struct.rc#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;value.get_mut()&lt;/code&gt; 调用它们，而不是value.get_mut（）。这避免了与内部类型 &lt;code&gt;T&lt;/code&gt; 的方法的冲突。</target>
        </trans-unit>
        <trans-unit id="e9a135c5b11a6bdd25cebdf7bee36ffe6f4a888e" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call.</source>
          <target state="translated">初始值是累加器在第一次调用时的值。</target>
        </trans-unit>
        <trans-unit id="05cd051eb5f45770d700d15bc2c291712fe7349d" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, &lt;code&gt;try_fold()&lt;/code&gt; returns the final accumulator as success.</source>
          <target state="translated">初始值是累加器在第一次调用时将具有的值。如果对迭代器的每个元素成功应用闭包，则 &lt;code&gt;try_fold()&lt;/code&gt; 返回最终累加器为成功。</target>
        </trans-unit>
        <trans-unit id="3215ce085488e89e5b23ed55a5028caf27292850" translate="yes" xml:space="preserve">
          <source>The initializer expression.</source>
          <target state="translated">初始化表达式。</target>
        </trans-unit>
        <trans-unit id="005959a16886789f6cb716c2b5dc5bbb0daa12f9" translate="yes" xml:space="preserve">
          <source>The initializer of</source>
          <target state="translated">的初始化器</target>
        </trans-unit>
        <trans-unit id="37009e2d28047124f91d44e005708dbff225d4db" translate="yes" xml:space="preserve">
          <source>The initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;let statement&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;statements#let-statements&quot;&gt;let语句&lt;/a&gt;的初始化程序。</target>
        </trans-unit>
        <trans-unit id="b9db1fa1a8ca22dc3f22f48be8f2cc5fef02b51c" translate="yes" xml:space="preserve">
          <source>The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the token stream of the item that has the &lt;code&gt;derive&lt;/code&gt; attribute on it. The output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; must be a set of items that are then appended to the &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt; that the item from the input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">输入&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;是具有项的令牌流 &lt;code&gt;derive&lt;/code&gt; 上它属性。输出&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;必须是一组项目，然后将这些项目附加到输入&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;中的项目所在的&lt;a href=&quot;items/modules&quot;&gt;模块&lt;/a&gt;或&lt;a href=&quot;expressions/block-expr&quot;&gt;块&lt;/a&gt;中。</target>
        </trans-unit>
        <trans-unit id="3584f2f431d39b47066e06bb0ba2d085c77c3d1e" translate="yes" xml:space="preserve">
          <source>The input iterator &lt;code&gt;replace_with&lt;/code&gt; is only consumed when the &lt;code&gt;Splice&lt;/code&gt; value is dropped.</source>
          <target state="translated">仅在删除 &lt;code&gt;Splice&lt;/code&gt; 值时才使用输入迭代器 &lt;code&gt;replace_with&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b45dbdf7cc3adb9c8ff29ad732df76183eebf5c" translate="yes" xml:space="preserve">
          <source>The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">Rust的安装还包括本地文档的副本，因此您可以脱机阅读。运行 &lt;code&gt;rustup doc&lt;/code&gt; 在浏览器中打开本地文档。</target>
        </trans-unit>
        <trans-unit id="c198c64d60547785c3da652e9852896f77fa00d7" translate="yes" xml:space="preserve">
          <source>The installation script automatically adds Rust to your system PATH after your next login. If you want to start using Rust right away instead of restarting your terminal, run the following command in your shell to add Rust to your system PATH manually:</source>
          <target state="translated">安装脚本会在您下次登录后自动将 Rust 添加到您的系统 PATH 中。如果您想立即开始使用 Rust,而不是重新启动终端,请在 shell 中运行以下命令,手动将 Rust 添加到系统 PATH 中。</target>
        </trans-unit>
        <trans-unit id="a382c15195dddde8bba4823548e75c4adc802c3c" translate="yes" xml:space="preserve">
          <source>The installer also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">安装程序还包括本地文档的副本，因此您可以脱机阅读。运行 &lt;code&gt;rustup doc&lt;/code&gt; 在浏览器中打开本地文档。</target>
        </trans-unit>
        <trans-unit id="eb4481a6d93414e0e2ed7586ff1e0910b51585be" translate="yes" xml:space="preserve">
          <source>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, &lt;code&gt;i32::wrapping_add&lt;/code&gt; provides two's complement, wrapping addition.</source>
          <target state="translated">整数类型提供了固有的方法，以允许程序员显式执行包装算法。例如， &lt;code&gt;i32::wrapping_add&lt;/code&gt; 提供二进制补码，包装加法。</target>
        </trans-unit>
        <trans-unit id="a2f153ef163d784268a26bcb041875def3bd700b" translate="yes" xml:space="preserve">
          <source>The integration tests section starts with the line &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (the hash at the end of your output will be different). Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the &lt;code&gt;Doc-tests adder&lt;/code&gt; section starts.</source>
          <target state="translated">集成测试部分从 &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; （输出末尾的哈希将不同）。接下来，在 &lt;code&gt;Doc-tests adder&lt;/code&gt; 部分开始之前，该集成测试中的每个测试功能都有一行，而集成测试的结果则有一个摘要行。</target>
        </trans-unit>
        <trans-unit id="9c8b39dac0f0603ab0205cf2bfd1df712c7506c4" translate="yes" xml:space="preserve">
          <source>The intention is that the underlying data is only valid for the lifetime &lt;code&gt;'a&lt;/code&gt;, so &lt;code&gt;Slice&lt;/code&gt; should not outlive &lt;code&gt;'a&lt;/code&gt;. However, this intent is not expressed in the code, since there are no uses of the lifetime &lt;code&gt;'a&lt;/code&gt; and hence it is not clear what data it applies to. We can correct this by telling the compiler to act &lt;em&gt;as if&lt;/em&gt; the &lt;code&gt;Slice&lt;/code&gt; struct contained a reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">目的是使基础数据仅在生存期 &lt;code&gt;'a&lt;/code&gt; 内有效，因此 &lt;code&gt;Slice&lt;/code&gt; 不应超过 &lt;code&gt;'a&lt;/code&gt; 。但是，此意图未在代码中表达，因为没有使用生存期 &lt;code&gt;'a&lt;/code&gt; ，因此尚不清楚它适用于什么数据。我们可以告诉编译器采取行动纠正这种&lt;em&gt;仿佛&lt;/em&gt;在 &lt;code&gt;Slice&lt;/code&gt; 结构中提 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c6ec3ee71b429b0c861d2949630c53c1d4103ef2" translate="yes" xml:space="preserve">
          <source>The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.</source>
          <target state="translated">内部算法没有指定,所以它和它的哈希值不应该依靠于发布。</target>
        </trans-unit>
        <trans-unit id="c411eb080c209397146b14ba5a4bb34e75cec138" translate="yes" xml:space="preserve">
          <source>The internal buffer is written out before returning the writer.</source>
          <target state="translated">在返回写入器之前,内部缓冲区会被写出来。</target>
        </trans-unit>
        <trans-unit id="06716cd4a735b362271ebfeb2853eaa89b39ee1b" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.</source>
          <target state="translated">在看到第一个 &lt;code&gt;{}&lt;/code&gt; 时，尚未对参数进行内部迭代，因此它将打印第一个参数。然后，在到达第二个 &lt;code&gt;{}&lt;/code&gt; 时，迭代器前进到第二个参数。本质上，在位置说明符方面，明确命名其参数的参数不会影响未命名参数的参数。</target>
        </trans-unit>
        <trans-unit id="ce78ff22afeda7a6f00a6ca8444175752d52c4ff" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.</source>
          <target state="translated">在看到第一个 &lt;code&gt;{}&lt;/code&gt; 时，尚未对参数进行内部迭代，因此它将打印第一个参数。然后，在到达第二个 &lt;code&gt;{}&lt;/code&gt; 时，迭代器前进到第二个参数。本质上，显式命名其参数的参数不会影响在位置说明符方面未命名参数的参数。</target>
        </trans-unit>
        <trans-unit id="2c46dda1624f616f75baf2894d6d6e54ab12f317" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法的反函数是&lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dbc762f2fb2ae9279c20887c42fbcb66ef8ed68d" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法的逆是&lt;a href=&quot;struct.string#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ef5a2c8bf418a538796f28bdc7b3ed8b4214bec" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法的反函数是&lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00033d91f205bb0450cf7878d82bad2da288007b" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法的反函数为&lt;a href=&quot;struct.string#method.into_bytes&quot;&gt; &lt;code&gt;into_bytes&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d5754a49ec3bccb9874e0108120d01b2fee9ec9" translate="yes" xml:space="preserve">
          <source>The issue can be resolved by changing the associated type:</source>
          <target state="translated">这个问题可以通过改变相关类型来解决。</target>
        </trans-unit>
        <trans-unit id="2057c4ad17ebd71c1902c8394bd83a7474bbd6d5" translate="yes" xml:space="preserve">
          <source>The issue in this case is that &lt;code&gt;foo&lt;/code&gt; is defined as accepting a &lt;code&gt;Fn&lt;/code&gt; with one argument of type &lt;code&gt;String&lt;/code&gt;, but the closure we attempted to pass to it requires one arguments of type &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，问题是 &lt;code&gt;foo&lt;/code&gt; 被定义为接受一个带 &lt;code&gt;String&lt;/code&gt; 类型参数的 &lt;code&gt;Fn&lt;/code&gt; ，但是我们试图传递给它的闭包需要一个 &lt;code&gt;usize&lt;/code&gt; 类型的参数。</target>
        </trans-unit>
        <trans-unit id="c02789dc84a563007f1b001c6388d43c1756fd64" translate="yes" xml:space="preserve">
          <source>The issue with the tuple code in Listing 4-5 is that we have to return the &lt;code&gt;String&lt;/code&gt; to the calling function so we can still use the &lt;code&gt;String&lt;/code&gt; after the call to &lt;code&gt;calculate_length&lt;/code&gt;, because the &lt;code&gt;String&lt;/code&gt; was moved into &lt;code&gt;calculate_length&lt;/code&gt;.</source>
          <target state="translated">清单4-5中的元组代码的问题在于，我们必须将 &lt;code&gt;String&lt;/code&gt; 返回给调用函数，因此，在调用 &lt;code&gt;calculate_length&lt;/code&gt; 之后，我们仍然可以使用 &lt;code&gt;String&lt;/code&gt; ，因为将 &lt;code&gt;String&lt;/code&gt; 移到了 &lt;code&gt;calculate_length&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="1013a496d8eb9ca295e23a82f7ffaec17e1ba13a" translate="yes" xml:space="preserve">
          <source>The issue with this code is evident in the signature of &lt;code&gt;area&lt;/code&gt;:</source>
          <target state="translated">此代码的问题在 &lt;code&gt;area&lt;/code&gt; 的签名中显而易见：</target>
        </trans-unit>
        <trans-unit id="e382444929f7f8a00ff868439efd08f11891e2df" translate="yes" xml:space="preserve">
          <source>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</source>
          <target state="translated">标记性状的项目不能被覆盖,所以当它们无论如何不能按类型改变时,没有必要拥有它们。如果你出于人机工程学的原因想要它们,可以考虑做一个扩展性状来代替。</target>
        </trans-unit>
        <trans-unit id="5e506ce8ee681f90bb70782d8bb4d2dad5bd0685" translate="yes" xml:space="preserve">
          <source>The iterator element type is &lt;a href=&quot;../path/struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">迭代器元素的类型为&lt;a href=&quot;../path/struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6824e2e2ab7393d35f45cbd58638289d41c35be1" translate="yes" xml:space="preserve">
          <source>The iterator must produce exactly the number of elements it reported or diverge before reaching the end.</source>
          <target state="translated">迭代器必须准确地产生它所报告的元素数量,否则在到达终点之前就会出现分歧。</target>
        </trans-unit>
        <trans-unit id="857086b346b7dd5e8adf55ad86cbe1dbbf8cbe54" translate="yes" xml:space="preserve">
          <source>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don&amp;rsquo;t have to reimplement that logic yourself.</source>
          <target state="translated">迭代器模式允许您依次对一系列项目执行某些任务。迭代器负责对每个项目进行迭代并确定序列何时完成的逻辑。使用迭代器时，您不必自己重新实现该逻辑。</target>
        </trans-unit>
        <trans-unit id="6db07328b493618fb3fe592624d4f327dc32ce7b" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">迭代器报告一个大小提示，该提示是精确的（下限等于上限），或者上限是&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果实际迭代器的长度大于&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;则上限必须为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。在这种情况下，下限必须为&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;，导致&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;(usize::MAX, None)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="761f99bb11c75b1d69af8441ba4ad3812f9ffc53" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">迭代器报告一个大小提示，该提示是精确的（下限等于上限），或者上限是&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果实际迭代器的长度大于&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;则上限必须为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。在这种情况下，下限必须是&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;，从而导致&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint()&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;(usize::MAX, None)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5b68d7a8101dc216e0d59f65c1ebaa471e720b2" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will return instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each vector returned will &lt;em&gt;not&lt;/em&gt; have the delimiter byte at the end.</source>
          <target state="translated">从这个函数返回的迭代器将返回的情况下，&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;&amp;gt;&lt;/code&gt; 返回的每个向量在末尾都&lt;em&gt;没有&lt;/em&gt;定界符字节。</target>
        </trans-unit>
        <trans-unit id="43d518530c9a6385f97f5ea0cf3b95e6447ddfae" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</source>
          <target state="translated">从此函数返回的迭代器将产生&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。返回的每个字符串末尾都&lt;em&gt;没有&lt;/em&gt;换行符（0xA字节）或CRLF（0xD，0xA字节）。</target>
        </trans-unit>
        <trans-unit id="11be39dc954e81f8e71f68fa0b756ad22ee17df7" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the &lt;code&gt;0xA&lt;/code&gt; byte) or &lt;code&gt;CRLF&lt;/code&gt; (&lt;code&gt;0xD&lt;/code&gt;, &lt;code&gt;0xA&lt;/code&gt; bytes) at the end.</source>
          <target state="translated">从此函数返回的迭代器将产生&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。返回的每个字符串末尾都&lt;em&gt;不会&lt;/em&gt;包含换行符（ &lt;code&gt;0xA&lt;/code&gt; 字节）或 &lt;code&gt;CRLF&lt;/code&gt; （ &lt;code&gt;0xD&lt;/code&gt; ， &lt;code&gt;0xA&lt;/code&gt; 字节）。</target>
        </trans-unit>
        <trans-unit id="d98222c90db1c99a084846a0ad925665e5230738" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</source>
          <target state="translated">返回的迭代器将返回原始字符串分片的子分片,由任意数量的ASCII空格分隔。</target>
        </trans-unit>
        <trans-unit id="406100c150ec04008e29a14c30e99aed0f63af21" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</source>
          <target state="translated">返回的迭代器将返回原始字符串分片的子分片,用任意数量的空格分隔。</target>
        </trans-unit>
        <trans-unit id="4221546e7793ded4aa41dc1718c0ee56c99339b5" translate="yes" xml:space="preserve">
          <source>The iterator returned yields pairs &lt;code&gt;(i, val)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the current index of iteration and &lt;code&gt;val&lt;/code&gt; is the value returned by the iterator.</source>
          <target state="translated">返回的迭代器产生对 &lt;code&gt;(i, val)&lt;/code&gt; ，其中 &lt;code&gt;i&lt;/code&gt; 是当前迭代索引，而 &lt;code&gt;val&lt;/code&gt; 是迭代器返回的值。</target>
        </trans-unit>
        <trans-unit id="0d65a2fef7d4c6664fcfb9659495ac349d06a758" translate="yes" xml:space="preserve">
          <source>The iterator starts with the given first item (if any) and calls the given &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; closure to compute each item&amp;rsquo;s successor.</source>
          <target state="translated">迭代器从给定的第一个项目（如果有）开始，并调用给定的 &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; 闭包以计算每个项目的后继对象。</target>
        </trans-unit>
        <trans-unit id="fe7ef8d083d96a8372351bad5e0da1e04819839b" translate="yes" xml:space="preserve">
          <source>The iterator version was slightly faster! We won&amp;rsquo;t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</source>
          <target state="translated">迭代器版本稍微快一点！我们不在这里解释基准代码，因为重点不是要证明这两个版本是等效的，而是要获得这两种实现方式在性能方面的比较的一般含义。</target>
        </trans-unit>
        <trans-unit id="40a9eac2c27490989d9bce69b525d51e8393ef6d" translate="yes" xml:space="preserve">
          <source>The iterator will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;struct.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">迭代器永远不会返回&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，也不会产生对等方的&lt;a href=&quot;struct.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="1eb81e5b136891ec83f03fa70901b0982c774c3e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">迭代器将产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。最初构造迭代器后，可能会遇到新的错误。</target>
        </trans-unit>
        <trans-unit id="fea22bab4e7d7d638613556e79b891a323ca2ee5" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">迭代器将产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;fs::DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。最初构造迭代器后，可能会遇到新的错误。</target>
        </trans-unit>
        <trans-unit id="54667f9a5f59c23223b23e9276c48f67c43aae4e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">迭代器将产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。最初构造迭代器后，可能会遇到新的错误。</target>
        </trans-unit>
        <trans-unit id="6720eac87f145ca4ebd08c14afcbc3e18eb5bc63" translate="yes" xml:space="preserve">
          <source>The iterator will yield the &lt;code&gt;Path&lt;/code&gt; that is returned if the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method is used zero or more times. That means, the iterator will yield &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; and so on. If the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will do likewise. The iterator will always yield at least one value, namely &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt;方法使用零次或多次，则迭代器将产生返回的 &lt;code&gt;Path&lt;/code&gt; 。这意味着，迭代器将产生 &lt;code&gt;&amp;amp;self&lt;/code&gt; ， &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt; ， &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; 等等。如果&lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt;方法返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则迭代器也将这样做。迭代器将始终产生至少一个值，即 &lt;code&gt;&amp;amp;self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ed296a3da7075e704c60a55541d4eefcc61a2e" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;，则迭代器产生一个值，否则为null。</target>
        </trans-unit>
        <trans-unit id="33a7221657feedb4eb9bdbc29b15b1cfdbff0941" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果结果为&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，则迭代器将产生一个值，否则将没有值。</target>
        </trans-unit>
        <trans-unit id="98fcd488b58bec9ba13c409525786e8e34d2f3d0" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果结果为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，则迭代器将产生一个值，否则将没有值。</target>
        </trans-unit>
        <trans-unit id="908b09e4328c560c75c00a1be9bba8fa3c1792fa" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果结果为&lt;a href=&quot;enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，则迭代器将产生一个值，否则将没有值。</target>
        </trans-unit>
        <trans-unit id="8fd298b9ad5df85747acb6e44bba1366e3481860" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果结果为&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;，则迭代器产生一个值，否则为0。</target>
        </trans-unit>
        <trans-unit id="41c263ba9c3e1377bcbb306e69ddac6adfb8f150" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果结果为&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，则迭代器将产生一个值，否则将没有值。</target>
        </trans-unit>
        <trans-unit id="b80110840b4186388c3ebdd6fff4960efb23a3ca" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">迭代器产生元组。位置是第一，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是第二。</target>
        </trans-unit>
        <trans-unit id="6ec1542f766c1ecbdef3897acebe4cebd30ca6ee" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">迭代器产生元组。位置是第一，&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是第二。</target>
        </trans-unit>
        <trans-unit id="787f68c0ad38019edb27d78451a4d5831f65e4ab" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">迭代器产生元组。位置是第一，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是第二。</target>
        </trans-unit>
        <trans-unit id="10db2a64e13645a875ad4c150b72d85dec4465d0" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">迭代器产生元组。位置是第一，&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是第二。</target>
        </trans-unit>
        <trans-unit id="6814fb791ef3836a2e395759e70c2ff3a369ee11" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;read_line&lt;/code&gt; is to take whatever the user types into standard input and place that into a string, so it takes that string as an argument. The string argument needs to be mutable so the method can change the string&amp;rsquo;s content by adding the user input.</source>
          <target state="translated">&lt;code&gt;read_line&lt;/code&gt; 的工作是将用户键入的任何内容输入标准输入并将其放入字符串，因此它将该字符串作为参数。字符串参数必须是可变的，因此该方法可以通过添加用户输入来更改字符串的内容。</target>
        </trans-unit>
        <trans-unit id="41c36730094f242762fc2db352770667844d977d" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">联接句柄在删除后将隐式&lt;em&gt;分离&lt;/em&gt;子线程。在这种情况下，子线程可能会超过父线程（除非父线程是主线程；整个过程在主线程完成时终止）。此外，连接手柄提供了一个&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;方法，其可用于连接子线程。如果子线程出现紧急情况，&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt;其中包含给&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;的参数！。</target>
        </trans-unit>
        <trans-unit id="cc7b114b0c6414134b72184594654a5acaffb577" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">联接句柄在删除后将隐式&lt;em&gt;分离&lt;/em&gt;子线程。在这种情况下，子线程可能会超过父线程（除非父线程是主线程；整个过程在主线程完成时终止）。此外，连接手柄提供了一个&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;方法，其可用于连接子线程。如果子线程出现紧急情况，&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt;其中包含提供给&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt;的参数。</target>
        </trans-unit>
        <trans-unit id="099a2e1e2bdb72897b42735f9f375efdb1e2c049" translate="yes" xml:space="preserve">
          <source>The key line in this error is &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt;. With our non-generic versions of the &lt;code&gt;largest&lt;/code&gt; function, we were only trying to find the largest &lt;code&gt;i32&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. As discussed in the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4, types like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; that have a known size can be stored on the stack, so they implement the &lt;code&gt;Copy&lt;/code&gt; trait. But when we made the &lt;code&gt;largest&lt;/code&gt; function generic, it became possible for the &lt;code&gt;list&lt;/code&gt; parameter to have types in it that don&amp;rsquo;t implement the &lt;code&gt;Copy&lt;/code&gt; trait. Consequently, we wouldn&amp;rsquo;t be able to move the value out of &lt;code&gt;list[0]&lt;/code&gt; and into the &lt;code&gt;largest&lt;/code&gt; variable, resulting in this error.</source>
          <target state="translated">此错误中的关键行 &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt; 。对于 &lt;code&gt;largest&lt;/code&gt; 函数的非泛型版本，我们只是试图找到最大的 &lt;code&gt;i32&lt;/code&gt; 或 &lt;code&gt;char&lt;/code&gt; 。如第4章&lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;仅堆栈数据：复制&amp;rdquo;&lt;/a&gt;部分所述，具有已知大小的类型（如 &lt;code&gt;i32&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; )可以存储在堆栈中，因此它们实现了 &lt;code&gt;Copy&lt;/code&gt; 特征。但是当我们使 &lt;code&gt;largest&lt;/code&gt; 函数通用时， &lt;code&gt;list&lt;/code&gt; 参数就有可能在其中实现不实现 &lt;code&gt;Copy&lt;/code&gt; 的类型。特征。因此，我们将无法将值移出 &lt;code&gt;list[0]&lt;/code&gt; 并移至 &lt;code&gt;largest&lt;/code&gt; 变量，从而导致此错误。</target>
        </trans-unit>
        <trans-unit id="bceeadadeee15f4a164537fd341fe02f08db51ce" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">密钥可以是地图密钥类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与密钥类型的匹配。</target>
        </trans-unit>
        <trans-unit id="1967c0afcde1ba185b21a2a66c76557126c2a896" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">密钥可以是地图密钥类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与密钥类型的匹配。</target>
        </trans-unit>
        <trans-unit id="25f3fabcbbf37a65231d46a27fb9b7a82a76e913" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">密钥可以是地图密钥类型的任何借用形式，但是借用形式上的顺序&lt;em&gt;必须&lt;/em&gt;与密钥类型上的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="5794a7e2452d7c2d7acdcd9ca75f9f681dde7e71" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">联合体的关键属性是联合体中的所有字段共享共同的存储空间,因此对联合体中一个字段的写入可以覆盖其他字段,联合体的大小由其最大字段的大小决定。因此,对一个联合体的一个字段的写入可以覆盖它的其他字段,一个联合体的大小是由它的最大字段的大小决定的。</target>
        </trans-unit>
        <trans-unit id="af36c49ed669c54fb87fd9d4d2b45f5df4d5de97" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">联合体的关键属性是联合体中的所有字段共享共同的存储。因此,对一个联合体的一个字段的写入可以覆盖它的其他字段,一个联合体的大小是由它的最大字段的大小决定的。</target>
        </trans-unit>
        <trans-unit id="730d38429c1bd8714c2ac7995eb67557271f3b30" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;pub&lt;/code&gt; makes any module, function, or data structure accessible from inside of external modules. The &lt;code&gt;pub&lt;/code&gt; keyword may also be used in a &lt;code&gt;use&lt;/code&gt; declaration to re-export an identifier from a namespace.</source>
          <target state="translated">关键字 &lt;code&gt;pub&lt;/code&gt; 可从外部模块内部访问任何模块，功能或数据结构。在 &lt;code&gt;pub&lt;/code&gt; 的关键字，也可以在使用的 &lt;code&gt;use&lt;/code&gt; 声明从一个命名空间来重新导出的标识符。</target>
        </trans-unit>
        <trans-unit id="6097954d2b4ff2c7af7f3ee3f3f7074587267681" translate="yes" xml:space="preserve">
          <source>The kinds of patterns for parameters is limited to one of the following:</source>
          <target state="translated">参数模式的种类仅限于以下一种。</target>
        </trans-unit>
        <trans-unit id="9150d911250adb9488a9891d8d1a7dd89c179545" translate="yes" xml:space="preserve">
          <source>The lack of infinite output indicates that this code didn&amp;rsquo;t create a reference cycle. We can also tell this by looking at the values we get from calling &lt;code&gt;Rc::strong_count&lt;/code&gt; and &lt;code&gt;Rc::weak_count&lt;/code&gt;.</source>
          <target state="translated">缺少无限的输出表明该代码未创建参考循环。我们还可以通过查看从调用 &lt;code&gt;Rc::strong_count&lt;/code&gt; 和 &lt;code&gt;Rc::weak_count&lt;/code&gt; 得到的值来说明这一点。</target>
        </trans-unit>
        <trans-unit id="4f0cd1d95a878dd3fb3eb033669531c63a686db3" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice).</source>
          <target state="translated">lang属性用于标记Rust内置的特殊项目。这包括影响编译器行为的特殊特征（如 &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Sized&lt;/code&gt; ），以及可以自动调用的特殊功能（例如，对切片进行索引时进行越界访问的处理程序）。</target>
        </trans-unit>
        <trans-unit id="60e53524d7493db6ac00628d4141587167732e22" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</source>
          <target state="translated">lang属性用于标记Rust内置的特殊项目。这包括影响编译器行为的特殊特征（如 &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Sized&lt;/code&gt; ），以及可以自动调用的特殊功能（例如，对切片进行索引时进行越界访问的处理程序）。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="080a1610af4bccfcd8725cb110cddf449fbd60f7" translate="yes" xml:space="preserve">
          <source>The lang attribute was used in an invalid context.</source>
          <target state="translated">lang属性在无效的情况下被使用。</target>
        </trans-unit>
        <trans-unit id="d001aa0e948f210ef67db3ed9f1079f66965d658" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type.</source>
          <target state="translated">这个整数类型所能代表的最大值。</target>
        </trans-unit>
        <trans-unit id="55a17e21fb4394b20facf75f686648a8590b11f1" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt;&lt;code&gt;i128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt; &lt;code&gt;i128::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b73325de7bc5986e41ec8d92ed9701ddacd280f3" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt;&lt;code&gt;i16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt; &lt;code&gt;i16::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7bb87b47e7f2c22de123ec199f4be989c0dcaf2" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf18dde926e284162a660a1b1a2a30b118d1c49a" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt;&lt;code&gt;i64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt; &lt;code&gt;i64::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b22c4dd542e2ceff2527d706e65d0c5acc6f4d52" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt;&lt;code&gt;i8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt; &lt;code&gt;i8::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a2e67766c1f950d1a3f862bddde0bc78e36aacd" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt;&lt;code&gt;isize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。使用&lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt; &lt;code&gt;isize::MAX&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="697ca9e8dc5fcb1feb5a529df70222ec030c2428" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt;&lt;code&gt;u128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt; &lt;code&gt;u128::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23128039031afffa375e1d18e6f18c10d1470457" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt;&lt;code&gt;u16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt; &lt;code&gt;u16::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cead8aa8b3423346a603591b8a3bb3bb38de07d" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt;&lt;code&gt;u32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt; &lt;code&gt;u32::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfdca1f692589c69870c6eba29a4be248c639ebc" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt;&lt;code&gt;u64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt; &lt;code&gt;u64::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de1cfd44e67cca085f5a9478c1e9579b369e52ad" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt;&lt;code&gt;u8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt; &lt;code&gt;u8::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c52af57b6ca83f430b64beb1abd9c9176989341" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最大值。请改用&lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5bab83aeec1382113d53e6e7d14863dd49ec843d" translate="yes" xml:space="preserve">
          <source>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call &lt;code&gt;borrow&lt;/code&gt; on the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; to get an immutable reference to the vector.</source>
          <target state="translated">我们必须做的最后一个更改是在断言中：要查看内部向量中有多少项，我们对 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 调用 &lt;code&gt;borrow&lt;/code&gt; 以获取对该向量的不变引用。</target>
        </trans-unit>
        <trans-unit id="b92b068be4c2b594134000422ae50b8df0c8bac3" translate="yes" xml:space="preserve">
          <source>The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</source>
          <target state="translated">最后一个区别是,常量只能设置为一个常量表达式,而不能设置为一个函数调用的结果或任何其他只能在运行时计算的值。</target>
        </trans-unit>
        <trans-unit id="293474ffe041aff8a994854d8cad3ac993cf31b4" translate="yes" xml:space="preserve">
          <source>The last element returned, if any, will contain the remainder of the slice.</source>
          <target state="translated">返回的最后一个元素(如果有的话)将包含分片的剩余部分。</target>
        </trans-unit>
        <trans-unit id="8d491eebdf550e16362be621e1476cb5ece9206f" translate="yes" xml:space="preserve">
          <source>The last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">的最后一个字段 &lt;code&gt;Foo&lt;/code&gt; 有一个类型涉及 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf70627b4e81c57a3ddc9f76311bc0b01f381dcd" translate="yes" xml:space="preserve">
          <source>The last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">输出的最后一行显示已安装二进制文件的位置和名称，在 &lt;code&gt;ripgrep&lt;/code&gt; 的情况下为 &lt;code&gt;rg&lt;/code&gt; 。只要安装目录位于 &lt;code&gt;$PATH&lt;/code&gt; ，如前所述，您就可以运行 &lt;code&gt;rg --help&lt;/code&gt; 并开始使用一个更快，更可靠的工具搜索文件！</target>
        </trans-unit>
        <trans-unit id="3dc7b6a27a6191be06711a90615e83b643711efc" translate="yes" xml:space="preserve">
          <source>The last line shows that &lt;code&gt;&amp;amp;bar&lt;/code&gt; is not a function pointer either. Rather, it is a reference to the function-specific ZST. &lt;code&gt;&amp;amp;bar&lt;/code&gt; is basically never what you want when &lt;code&gt;bar&lt;/code&gt; is a function.</source>
          <target state="translated">最后一行显示 &lt;code&gt;&amp;amp;bar&lt;/code&gt; 也不是函数指针。相反，它是对特定于功能的ZST的引用。当 &lt;code&gt;bar&lt;/code&gt; 是一个函数时， &lt;code&gt;&amp;amp;bar&lt;/code&gt; 根本就不是您想要的。</target>
        </trans-unit>
        <trans-unit id="982060970609630bdcfd3dbdc543a9a98b2de24a" translate="yes" xml:space="preserve">
          <source>The last line, &lt;code&gt;[dependencies]&lt;/code&gt;, is the start of a section for you to list any of your project&amp;rsquo;s dependencies. In Rust, packages of code are referred to as &lt;em&gt;crates&lt;/em&gt;. We won&amp;rsquo;t need any other crates for this project, but we will in the first project in Chapter 2, so we&amp;rsquo;ll use this dependencies section then.</source>
          <target state="translated">最后一行 &lt;code&gt;[dependencies]&lt;/code&gt; 是本节的开头，您可以列出任何项目的依赖项。在Rust中，代码包称为&lt;em&gt;板条箱&lt;/em&gt;。对于该项目，我们不需要任何其他包装，但是在第2章的第一个项目中，我们将使用此依赖项部分。</target>
        </trans-unit>
        <trans-unit id="c8d286da9b3987ef73f4d9e79523c9888a168257" translate="yes" xml:space="preserve">
          <source>The last of our common collections is the &lt;em&gt;hash map&lt;/em&gt;. The type &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; stores a mapping of keys of type &lt;code&gt;K&lt;/code&gt; to values of type &lt;code&gt;V&lt;/code&gt;. It does this via a &lt;em&gt;hashing function&lt;/em&gt;, which determines how it places these keys and values into memory. Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, dictionary, or associative array, just to name a few.</source>
          <target state="translated">我们最常用的集合是&lt;em&gt;哈希图&lt;/em&gt;。类型 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 存储类型的键的映射 &lt;code&gt;K&lt;/code&gt; 到类型的值 &lt;code&gt;V&lt;/code&gt; 。它通过&lt;em&gt;散列函数&lt;/em&gt;执行此操作，该&lt;em&gt;函数&lt;/em&gt;确定如何将这些键和值放入内存中。许多编程语言都支持这种数据结构，但是它们经常使用不同的名称，例如哈希，地图，对象，哈希表，字典或关联数组，仅举几例。</target>
        </trans-unit>
        <trans-unit id="e50377e1cc3271006121b6b6e503348b95075085" translate="yes" xml:space="preserve">
          <source>The last part is the HTTP version the client uses, and then the request line ends in a &lt;em&gt;CRLF sequence&lt;/em&gt;. (CRLF stands for &lt;em&gt;carriage return&lt;/em&gt; and &lt;em&gt;line feed&lt;/em&gt;, which are terms from the typewriter days!) The CRLF sequence can also be written as &lt;code&gt;\r\n&lt;/code&gt;, where &lt;code&gt;\r&lt;/code&gt; is a carriage return and &lt;code&gt;\n&lt;/code&gt; is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">最后一部分是客户端使用的HTTP版本，然后请求行以&lt;em&gt;CRLF序列&lt;/em&gt;结束。（CRLF代表&lt;em&gt;回车&lt;/em&gt;和&lt;em&gt;换行&lt;/em&gt;，这是打字机时代的术语！）CRLF序列也可以写为 &lt;code&gt;\r\n&lt;/code&gt; ，其中 &lt;code&gt;\r&lt;/code&gt; 是回车，而 &lt;code&gt;\n&lt;/code&gt; 是换行。CRLF序列将请求行与其余请求数据分开。请注意，在打印CRLF时，我们看到的是新行开头，而不是 &lt;code&gt;\r\n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7f87628bb5e91d33e6ee47cc631179039d310fa" translate="yes" xml:space="preserve">
          <source>The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</source>
          <target state="translated">类型的布局是指它的大小、对齐方式以及它的字段的相对偏移。对于enums,如何布局和解释判别符也是类型布局的一部分。</target>
        </trans-unit>
        <trans-unit id="bb7242c48b73507f4d4792c2cb29fe84ab3a4519" translate="yes" xml:space="preserve">
          <source>The layout of allocation request that failed</source>
          <target state="translated">分配请求失败的布局</target>
        </trans-unit>
        <trans-unit id="d81ce81ead59e71cfd072129a8c87907148c562c" translate="yes" xml:space="preserve">
          <source>The left operand of an &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;assignment&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;赋值&lt;/a&gt;或&lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;复合赋值&lt;/a&gt;表达式的左操作数。</target>
        </trans-unit>
        <trans-unit id="1c0d113ddd28e543817cdc902e3988c72a15e13a" translate="yes" xml:space="preserve">
          <source>The left shift assignment operator &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">左移赋值运算符 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="553d8d3f55b49cb8907e0699dd0a3d9c13298c80" translate="yes" xml:space="preserve">
          <source>The left shift operator &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; and &lt;code&gt;a.shl(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">左移位运算符 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 。请注意，由于此特征是针对具有多个右侧类型的所有整数类型实现的，因此Rust的类型检查器对 &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt; 进行了特殊处理，将整数运算的结果类型设置为左侧操作数的类型。这意味着尽管 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 和 &lt;code&gt;a.shl(b)&lt;/code&gt; 从求值的角度来看是相同的，但是在类型推断方面它们是不同的。</target>
        </trans-unit>
        <trans-unit id="abb83d0dbf2481e1c0cc0aff75ee4837acd9c8fb" translate="yes" xml:space="preserve">
          <source>The left-hand side of a compound assignment expression must be a place expression. A place expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</source>
          <target state="translated">复合赋值表达式的左侧必须是一个位置表达式。场所表达式代表一个内存位置,包括项目路径(即命名空间变量)、取消引用、索引表达式和字段引用。</target>
        </trans-unit>
        <trans-unit id="9df6999a3c0f46759818b5fb8abefef29f79e559" translate="yes" xml:space="preserve">
          <source>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</source>
          <target state="translated">赋值操作符的左侧必须是一个位置表达式。位置表达式代表一个内存位置,可以是一个变量(可选择命名间距)、一个取消引用、一个索引表达式或一个字段引用。</target>
        </trans-unit>
        <trans-unit id="e2c37a7f1d5752be8f4a3cd4c10444c370f709c8" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">长度是 &lt;code&gt;String&lt;/code&gt; 当前正在使用的内容的内存量（以字节为单位）。容量是 &lt;code&gt;String&lt;/code&gt; 从分配器接收的总内存量（以字节为单位）。长度和容量之间的差异很重要，但在这种情况下并不重要，因此，暂时忽略容量是可以的。</target>
        </trans-unit>
        <trans-unit id="583ea3cae577825fe984e0b2dabdc2098e762a9c" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the operating system. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">长度是 &lt;code&gt;String&lt;/code&gt; 当前正在使用的内容的内存量（以字节为单位）。容量是 &lt;code&gt;String&lt;/code&gt; 从操作系统接收的内存总量（以字节为单位）。长度和容量之间的差异很重要，但在这种情况下并不重要，因此，现在可以忽略容量。</target>
        </trans-unit>
        <trans-unit id="bec01c75ecf9080484e0035ecb4817690e9d17fa" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;other&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 的长度必须与 &lt;code&gt;self&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1d3c6c04d874a34e3f73cf44da542c5ee7d39510" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;src&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 的长度必须与 &lt;code&gt;self&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f5ae40e336b72c0149684750f73301547acc7603" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified.</source>
          <target state="translated">未指定平台固有函数 &lt;code&gt;simd_shuffle&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="65b0bfaafe677ff19be99641d06a9d0388b357ef" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified. Erroneous code example:</source>
          <target state="translated">未指定平台固有函数 &lt;code&gt;simd_shuffle&lt;/code&gt; 的长度。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="2e4dc711d20d353ed60fc2eb7d0105870f230a29" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;. As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">返回的长度是 &lt;code&gt;OsStr&lt;/code&gt; 使用的基础存储的长度。如&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;简介中所述，&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;OsStr&lt;/code&gt; 以最适合于本机平台和Rust字符串形式之间的廉价相互转换的形式存储字符串，这两种形式在存储大小和编码方面可能存在很大差异。</target>
        </trans-unit>
        <trans-unit id="2fe8cad4da628228b8d9a6730b144662e5d5b147" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;; As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">返回的长度是 &lt;code&gt;OsStr&lt;/code&gt; 使用的基础存储的长度；如&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;简介中所述，&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;OsStr&lt;/code&gt; 以最适合于本机平台和Rust字符串形式之间的廉价相互转换的形式存储字符串，这两种形式在存储大小和编码方面可能存在很大差异。</target>
        </trans-unit>
        <trans-unit id="f60b6a38bf38c34c5675869a8bbe49e47496b10f" translate="yes" xml:space="preserve">
          <source>The level is equal to &lt;code&gt;SOL_SOCKET&lt;/code&gt; and the type is equal to &lt;code&gt;SCM_CREDENTIALS&lt;/code&gt; or &lt;code&gt;SCM_CREDS&lt;/code&gt;.</source>
          <target state="translated">级别等于 &lt;code&gt;SOL_SOCKET&lt;/code&gt; ，类型等于 &lt;code&gt;SCM_CREDENTIALS&lt;/code&gt; 或 &lt;code&gt;SCM_CREDS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3be4076f729c77100ef1624a826253f7fce0e4b7" translate="yes" xml:space="preserve">
          <source>The level is equal to &lt;code&gt;SOL_SOCKET&lt;/code&gt; and the type is equal to &lt;code&gt;SCM_RIGHTS&lt;/code&gt;.</source>
          <target state="translated">级别等于 &lt;code&gt;SOL_SOCKET&lt;/code&gt; ，类型等于 &lt;code&gt;SCM_RIGHTS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99a0d51daa7130da604f883d5259ae5835cb10c2" translate="yes" xml:space="preserve">
          <source>The lifetime bound for this object type cannot be deduced from context and must be specified.</source>
          <target state="translated">该对象类型的寿命约束不能从上下文中推导出来,必须指定。</target>
        </trans-unit>
        <trans-unit id="71866b1db7de253967c22f08d6dc545dfcd4182b" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for &lt;code&gt;bar()&lt;/code&gt; implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">寿命约束 &lt;code&gt;'b&lt;/code&gt; 为 &lt;code&gt;bar()&lt;/code&gt; 实现不匹配特征声明。确保生存期声明在特征声明和实现中完全匹配。例子：</target>
        </trans-unit>
        <trans-unit id="30238ceba60deefc79cfa25b4649d1a595edd0d8" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">bar（）实现的生存期约束 &lt;code&gt;'b&lt;/code&gt; 与特征声明不匹配。确保生命周期声明在特征声明和实现中完全匹配。例：</target>
        </trans-unit>
        <trans-unit id="61076c57b01b556a6cbf075ae8202a67124b97eb" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have</source>
          <target state="translated">寿命省略规则要求任何具有省略输出寿命的函数签名必须具有以下两种情况之一</target>
        </trans-unit>
        <trans-unit id="15fb2549a777717fb62ea70833166d18eb32b15d" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have:</source>
          <target state="translated">寿命洗脱规则要求任何具有洗脱输出寿命的函数签名都必须具有:</target>
        </trans-unit>
        <trans-unit id="7914129f994f43353c3efa7974019d9a960355fb" translate="yes" xml:space="preserve">
          <source>The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context, such as by providing a helper function taking the lifetime of a host value for the slice, or by explicit annotation.</source>
          <target state="translated">返回的分片的寿命是根据其使用情况推断出来的。为了防止意外的滥用,建议将寿命与上下文中任何一个源的寿命联系起来,比如提供一个辅助函数,为分片取一个主机值的寿命,或者通过显式注释。</target>
        </trans-unit>
        <trans-unit id="af0f1e1de97ff5087fa423eab95c1e381b7b3ee8" translate="yes" xml:space="preserve">
          <source>The lifetime of the returned &lt;code&gt;Cursor&lt;/code&gt; is bound to that of the &lt;code&gt;CursorMut&lt;/code&gt;, which means it cannot outlive the &lt;code&gt;CursorMut&lt;/code&gt; and that the &lt;code&gt;CursorMut&lt;/code&gt; is frozen for the lifetime of the &lt;code&gt;Cursor&lt;/code&gt;.</source>
          <target state="translated">返回的 &lt;code&gt;Cursor&lt;/code&gt; 的生存期与 &lt;code&gt;CursorMut&lt;/code&gt; 的生存期绑定在一起，这意味着它不能超过 &lt;code&gt;CursorMut&lt;/code&gt; 的生存期，并且 &lt;code&gt;CursorMut&lt;/code&gt; 在 &lt;code&gt;Cursor&lt;/code&gt; 的生存期内被冻结。</target>
        </trans-unit>
        <trans-unit id="57046a8e7fbf89990ae303fb2235f525d1c99061" translate="yes" xml:space="preserve">
          <source>The lifetime parameter declaration after &lt;code&gt;impl&lt;/code&gt; and its use after the type name are required, but we&amp;rsquo;re not required to annotate the lifetime of the reference to &lt;code&gt;self&lt;/code&gt; because of the first elision rule.</source>
          <target state="translated">必需在 &lt;code&gt;impl&lt;/code&gt; 之后声明生命周期参数，并在类型名称后使用它，但是由于第一个省略规则，我们不需要注释对 &lt;code&gt;self&lt;/code&gt; 的引用的生命周期。</target>
        </trans-unit>
        <trans-unit id="37f7629efc4022ff5cf0b561478f77607b602987" translate="yes" xml:space="preserve">
          <source>The lifetime parameters of the method do not match the trait declaration.</source>
          <target state="translated">方法的寿命参数与特质声明不匹配。</target>
        </trans-unit>
        <trans-unit id="14f07422d02861a626046c58ce643a2a52da0ac8" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; is an error message intended for programmers. It won&amp;rsquo;t help our end users understand what happened and what they should do instead. Let&amp;rsquo;s fix that now.</source>
          <target state="translated">行 &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; 是一条针对程序员的错误消息。它不会帮助我们的最终用户了解发生了什么以及应该怎么做。让我们现在修复它。</target>
        </trans-unit>
        <trans-unit id="5a0147b8f24f32bab15f7fb8959607d1c4391ac2" translate="yes" xml:space="preserve">
          <source>The line is:</source>
          <target state="translated">这条线是:</target>
        </trans-unit>
        <trans-unit id="de1c3b88f137cbbbccea4f427174e92d6650dd55" translate="yes" xml:space="preserve">
          <source>The lines execute in the order in which they appear in the &lt;code&gt;main&lt;/code&gt; function. First, the &amp;ldquo;Hello, world!&amp;rdquo; message prints, and then &lt;code&gt;another_function&lt;/code&gt; is called and its message is printed.</source>
          <target state="translated">这些行以它们在 &lt;code&gt;main&lt;/code&gt; 功能中出现的顺序执行。首先，&amp;ldquo;你好，世界！&amp;rdquo; 消息打印，然后调用 &lt;code&gt;another_function&lt;/code&gt; 并打印其消息。</target>
        </trans-unit>
        <trans-unit id="a2f50a40f788fe52620261459fe43b43f06256a8" translate="yes" xml:space="preserve">
          <source>The linkage of the C runtime is configured to respect the &lt;code&gt;crt-static&lt;/code&gt; target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</source>
          <target state="translated">C运行时的链接配置为尊重 &lt;code&gt;crt-static&lt;/code&gt; 目标功能。这些目标功能通常是从命令行通过标志配置到编译器本身的。例如，要启用静态运行时，可以执行：</target>
        </trans-unit>
        <trans-unit id="efca89d0995e1ff0c39cef27089410685b77deb1" translate="yes" xml:space="preserve">
          <source>The list of derivable traits provided in this appendix is not comprehensive: libraries can implement &lt;code&gt;derive&lt;/code&gt; for their own traits, making the list of traits you can use &lt;code&gt;derive&lt;/code&gt; with truly open-ended. Implementing &lt;code&gt;derive&lt;/code&gt; involves using a procedural macro, which is covered in the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section of Chapter 19.</source>
          <target state="translated">本附录中提供的衍生性状的名单并不全面：库可以实现 &lt;code&gt;derive&lt;/code&gt; 为自己的特质，使得性状的列表，你可以使用 &lt;code&gt;derive&lt;/code&gt; 与真正开放的。实现 &lt;code&gt;derive&lt;/code&gt; 涉及使用过程宏，该&lt;a href=&quot;ch19-06-macros#macros&quot;&gt;宏&lt;/a&gt;在第19章的&amp;ldquo;宏&amp;rdquo;部分中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="e9a2965c85bdbd082d28a62c5ab1cef15f730b46" translate="yes" xml:space="preserve">
          <source>The list of types is:</source>
          <target state="translated">类型清单是:</target>
        </trans-unit>
        <trans-unit id="91f214c30e2ceb29652b72be6f5c77765c1026b7" translate="yes" xml:space="preserve">
          <source>The literal characters &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; may be included in a string by preceding them with the same character. For example, the &lt;code&gt;{&lt;/code&gt; character is escaped with &lt;code&gt;{{&lt;/code&gt; and the &lt;code&gt;}&lt;/code&gt; character is escaped with &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">文字字符 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 可以包含在字符串中，方法是在它们前面加上相同的字符。例如， &lt;code&gt;{&lt;/code&gt; 字符逃脱 &lt;code&gt;{{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 字符与转义 &lt;code&gt;}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5be7b0512e1a505e9266eb524c4b5165ed24536" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired at this time because the operation would otherwise block.</source>
          <target state="translated">此时不能获取锁,因为否则操作会被阻止。</target>
        </trans-unit>
        <trans-unit id="ca27685a95f0186521159c6d95fa9cb158ac3333" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired because another thread failed while holding the lock.</source>
          <target state="translated">由于另一个线程在持有锁时失败,所以无法获得锁。</target>
        </trans-unit>
        <trans-unit id="e835ab2030797bd0af68c5e546090096d0ef15ed" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits for accessing the underlying data.</source>
          <target state="translated">当返回的锁超出范围时，将释放该锁。返回的防护还实现了&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt;特性以访问基础数据。</target>
        </trans-unit>
        <trans-unit id="ca99507e16c078ed3bf090ad447532972842294c" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait for writing data.</source>
          <target state="translated">当返回的锁超出范围时，将释放该锁。返回的防护还实现了用于写入数据的&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;特质。</target>
        </trans-unit>
        <trans-unit id="95f3d5bdf30a84c247ddb912c9e27503ec850ddb" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;code&gt;Write&lt;/code&gt; trait for writing data.</source>
          <target state="translated">当返回的锁超出范围时，将释放该锁。返回的防护还实现了用于写入数据的 &lt;code&gt;Write&lt;/code&gt; 特质。</target>
        </trans-unit>
        <trans-unit id="9fbc8134425c3ce849c012cee6ed6bdb948d21a6" translate="yes" xml:space="preserve">
          <source>The logic around the &lt;code&gt;value&lt;/code&gt; field we&amp;rsquo;ve just described is defined in Listing 13-10.</source>
          <target state="translated">清单13-10中定义了我们刚刚描述的围绕 &lt;code&gt;value&lt;/code&gt; 字段的逻辑。</target>
        </trans-unit>
        <trans-unit id="f2cf3737106dde9e749616b8670f272a444680a9" translate="yes" xml:space="preserve">
          <source>The lower bound of the range (inclusive).</source>
          <target state="translated">幅度的下限(含)。</target>
        </trans-unit>
        <trans-unit id="0766d14228f909fbfdac3f3dca197e2a666359ec" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any.</source>
          <target state="translated">导致该错误的低级原因(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="4b8803f6ab5b8d7b772e6a580f89ee4b72aef2f4" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">导致此错误的底层原因（如果有）。&lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5980cf0091c024091baef1d2b8180b13d7e8fb92" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">导致此错误的底层原因（如果有）。&lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f757a43bf56678673d64a896a7ea59d83e9d1668" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">导致此错误的底层原因（如果有）。&lt;a href=&quot;error/trait.error#method.cause&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828185ce8f6bedf0299995b3c4e9cb20b7a41ecd" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any.</source>
          <target state="translated">此错误的低级来源(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="ea0a6930dc7de4d466ce55f6448d31ae162ca38c" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此错误的下级来源（如果有）。&lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb0a1822fe706b0e16bb4cab78928338d81339e3" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此错误的下级来源（如果有）。&lt;a href=&quot;../error/trait.error#method.source&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccd557ca491cf82db4f740ce89716ec64f4fabf" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此错误的下级来源（如果有）。&lt;a href=&quot;error/trait.error#method.source&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6b9226fd8ae01998a5ebc10002aa19b3691743f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parameterized).</source>
          <target state="translated">本机代码 &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; ， &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; ， &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; ，或任何其它类型的取代基是不同的。因此，编译器按需生成实现。如果使用 &lt;code&gt;bool&lt;/code&gt; 参数调用 &lt;code&gt;foo()&lt;/code&gt; ，则编译器将仅为 &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; 生成代码。当我们有其他类型参数时，编译器生成的单态化实现的数量不会急剧增加，因为只有在使用未经参数化的替换调用函数时（即没有参数化任何替换类型本身的替换时），编译器才会生成一个实现。 。</target>
        </trans-unit>
        <trans-unit id="9e0846c263b7366386582dfe4d412a3ad4ba7b9f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</source>
          <target state="translated">本机代码 &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; ， &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; ， &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; ，或任何其它类型的取代基是不同的。因此，编译器按需生成实现。如果使用 &lt;code&gt;bool&lt;/code&gt; 参数调用 &lt;code&gt;foo()&lt;/code&gt; ，则编译器将仅为 &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; 生成代码。当我们有其他类型参数时，编译器生成的单态化实现的数量不会急剧增加，因为只有在使用未经参数化的替换调用函数时（即，没有任何替换类型本身都被参数化的替换），编译器才会生成一个实现。 。</target>
        </trans-unit>
        <trans-unit id="ec5d54a07ee0f8ac568e82f61b376d035a168bca" translate="yes" xml:space="preserve">
          <source>The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">宏本身将决定如何解释这样的标记以及是否产生错误。</target>
        </trans-unit>
        <trans-unit id="8db5958c7dabf9cedcc4db6e6fa16a59d45c2565" translate="yes" xml:space="preserve">
          <source>The macro works by using the &lt;code&gt;Debug&lt;/code&gt; implementation of the type of the given expression to print the value to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; along with the source location of the macro invocation as well as the source code of the expression.</source>
          <target state="translated">宏通过使用给定表达式类型的 &lt;code&gt;Debug&lt;/code&gt; 实现来工作，以将值以及宏调用的源位置以及表达式的源代码打印到&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9498e8eb390e83cb5dbd448b585676f4b5c37123" translate="yes" xml:space="preserve">
          <source>The macro wraps any number of static declarations and makes them thread local. Publicity and attributes for each static are allowed. Example:</source>
          <target state="translated">该宏封装了任意数量的静态声明,并使其成为线程本地。允许每个静态的公共性和属性。例如</target>
        </trans-unit>
        <trans-unit id="2eb59c956ec6e4722a7e8cfdea3a410b913da22e" translate="yes" xml:space="preserve">
          <source>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it&amp;rsquo;s intended to reference. Consider the program in Listing 10-17, which has an outer scope and an inner scope.</source>
          <target state="translated">生存期的主要目的是防止悬而未决的引用，这些引用使程序引用的不是其要引用的数据。考虑清单10-17中的程序，它具有一个外部作用域和一个内部作用域。</target>
        </trans-unit>
        <trans-unit id="c087688652f35bf8ea7f8323996c74d4edfcf197" translate="yes" xml:space="preserve">
          <source>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of &lt;code&gt;self&lt;/code&gt; in every method&amp;rsquo;s signature, is for organization. We&amp;rsquo;ve put all the things we can do with an instance of a type in one &lt;code&gt;impl&lt;/code&gt; block rather than making future users of our code search for capabilities of &lt;code&gt;Rectangle&lt;/code&gt; in various places in the library we provide.</source>
          <target state="translated">除了使用方法语法而且不必在每个方法的签名中重复使用 &lt;code&gt;self&lt;/code&gt; 的类型之外，使用方法代替函数的主要好处是对于组织。我们将类型实例的所有功能都放在一个 &lt;code&gt;impl&lt;/code&gt; 块中，而不是让我们的代码的未来用户在我们提供的库中的各个位置搜索 &lt;code&gt;Rectangle&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="8008407990a4be341211e8be036085a004b45e43" translate="yes" xml:space="preserve">
          <source>The main error message, &amp;ldquo;mismatched types,&amp;rdquo; reveals the core issue with this code. The definition of the function &lt;code&gt;plus_one&lt;/code&gt; says that it will return an &lt;code&gt;i32&lt;/code&gt;, but statements don&amp;rsquo;t evaluate to a value, which is expressed by &lt;code&gt;()&lt;/code&gt;, an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.</source>
          <target state="translated">主要错误消息&amp;ldquo;类型不匹配&amp;rdquo;揭示了此代码的核心问题。函数 &lt;code&gt;plus_one&lt;/code&gt; 的定义说它将返回一个 &lt;code&gt;i32&lt;/code&gt; ，但是语句的值不等于一个由空元组 &lt;code&gt;()&lt;/code&gt; 表示的值。因此，不会返回任何内容，这与函数定义相矛盾并导致错误。在此输出中，Rust提供了一条消息，可能有助于纠正此问题：建议删除分号，以解决错误。</target>
        </trans-unit>
        <trans-unit id="573ea76510aaa810e82bed4691dcc0e4c2771be9" translate="yes" xml:space="preserve">
          <source>The main place you'll see &lt;code&gt;!&lt;/code&gt; used explicitly is in generic code. Consider the &lt;a href=&quot;str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">您将看到的主要地方 &lt;code&gt;!&lt;/code&gt; 显式使用的是通用代码。考虑&lt;a href=&quot;str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;特性：</target>
        </trans-unit>
        <trans-unit id="3347fce894ee36b7a76776d17f6b05d7ee4e0c6f" translate="yes" xml:space="preserve">
          <source>The main thread will wait for the spawned thread to finish and then run its &lt;code&gt;for&lt;/code&gt; loop, so the output won&amp;rsquo;t be interleaved anymore, as shown here:</source>
          <target state="translated">主线程将等待生成的线程完成，然后运行其 &lt;code&gt;for&lt;/code&gt; 循环，因此输出将不再被交错，如下所示：</target>
        </trans-unit>
        <trans-unit id="d7af4b9befadab1a133dab8d7948b44dbc8d708d" translate="yes" xml:space="preserve">
          <source>The main thread will wait with a timeout on the condvar and then leave once the boolean has been updated and notified.</source>
          <target state="translated">主线程会在condvar上超时等待,一旦布尔值被更新并通知,就会离开。</target>
        </trans-unit>
        <trans-unit id="2f4d9785a094ac7050147e12df1b0f82f8cae6fe" translate="yes" xml:space="preserve">
          <source>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</source>
          <target state="translated">类型同义词的主要用例是减少重复。例如,我们可能有一个很长的类型,比如这样。</target>
        </trans-unit>
        <trans-unit id="e1aa73c2c8bcfa6f25fb308f2154aee4987ca459" translate="yes" xml:space="preserve">
          <source>The main way to use Boolean values is through conditionals, such as an &lt;code&gt;if&lt;/code&gt; expression. We&amp;rsquo;ll cover how &lt;code&gt;if&lt;/code&gt; expressions work in Rust in the &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;Control Flow&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">使用布尔值的主要方法是通过条件，例如 &lt;code&gt;if&lt;/code&gt; 表达式。我们将介绍如何 &lt;code&gt;if&lt;/code&gt; 表达式鲁斯特的工作&lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;控制流&amp;rdquo;&lt;/a&gt;一节。</target>
        </trans-unit>
        <trans-unit id="67f97a592dc5c37dc58d2c3fd741d8753b33f60e" translate="yes" xml:space="preserve">
          <source>The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">到&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt;的映射不是该功能的兼容性合同的一部分，尤其是在将来，&lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt;类型可能会更改为更特定的类型。</target>
        </trans-unit>
        <trans-unit id="f8fda3a6ce0d45625dd9cd044a1a98a742c97014" translate="yes" xml:space="preserve">
          <source>The match condition states that the arm only matches if the value of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, or &lt;code&gt;6&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; if &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. When this code runs, the pattern of the first arm matches because &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;, but the match guard &lt;code&gt;if y&lt;/code&gt; is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints &lt;code&gt;no&lt;/code&gt;. The reason is that the &lt;code&gt;if&lt;/code&gt; condition applies to the whole pattern &lt;code&gt;4 | 5 | 6&lt;/code&gt;, not only to the last value &lt;code&gt;6&lt;/code&gt;. In other words, the precedence of a match guard in relation to a pattern behaves like this:</source>
          <target state="translated">匹配条件的状态，如果值的臂只匹配 &lt;code&gt;x&lt;/code&gt; 等于 &lt;code&gt;4&lt;/code&gt; ， &lt;code&gt;5&lt;/code&gt; ，或 &lt;code&gt;6&lt;/code&gt; &lt;em&gt;和&lt;/em&gt;如果 &lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。运行此代码时，由于 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;4&lt;/code&gt; ，因此第一臂的模式匹配，但是 &lt;code&gt;if y&lt;/code&gt; 为false 则匹配保护，因此不会选择第一臂。代码移至确实匹配的第二臂，该程序打印 &lt;code&gt;no&lt;/code&gt; 。原因是 &lt;code&gt;if&lt;/code&gt; 条件适用于整个模式 &lt;code&gt;4 | 5 | 6&lt;/code&gt; ，不仅是最后一个值 &lt;code&gt;6&lt;/code&gt; 。换句话说，匹配保护相对于模式的优先级表现如下：</target>
        </trans-unit>
        <trans-unit id="6477b3c15cf1efd2f96aba3a277d7e0dd00d128c" translate="yes" xml:space="preserve">
          <source>The match guard &lt;code&gt;if n == y&lt;/code&gt; is not a pattern and therefore doesn&amp;rsquo;t introduce new variables. This &lt;code&gt;y&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; the outer &lt;code&gt;y&lt;/code&gt; rather than a new shadowed &lt;code&gt;y&lt;/code&gt;, and we can look for a value that has the same value as the outer &lt;code&gt;y&lt;/code&gt; by comparing &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if n == y&lt;/code&gt; 则匹配防护不是模式，因此不会引入新的变量。这个 &lt;code&gt;y&lt;/code&gt; &lt;em&gt;是&lt;/em&gt;外部 &lt;code&gt;y&lt;/code&gt; 而不是一个新的阴影 &lt;code&gt;y&lt;/code&gt; ，我们可以通过将 &lt;code&gt;n&lt;/code&gt; 与 &lt;code&gt;y&lt;/code&gt; 进行比较来寻找与外部 &lt;code&gt;y&lt;/code&gt; 具有相同值的值。</target>
        </trans-unit>
        <trans-unit id="0a68bad7489889370013d2c1b380ae26eafd0a34" translate="yes" xml:space="preserve">
          <source>The matched value was assigned in a match guard.</source>
          <target state="translated">匹配的值被分配到一个匹配卫士中。</target>
        </trans-unit>
        <trans-unit id="da4a7cee97aca95b9c65ea2bcda5404ae104d4f6" translate="yes" xml:space="preserve">
          <source>The maximum duration.</source>
          <target state="translated">最大持续时间。</target>
        </trans-unit>
        <trans-unit id="639334ee92fbc7d55384c7ec82527ac8487a080f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value.</source>
          <target state="translated">达到了一个枚举的最大值,所以不能在下一个枚举值中自动设置。</target>
        </trans-unit>
        <trans-unit id="444f3162cb088de418eba38f4a421be7235eea6f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</source>
          <target state="translated">达到了一个枚举的最大值,所以不能在下一个枚举值中自动设置。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="69d28668979329993270aea55163f780c2136684" translate="yes" xml:space="preserve">
          <source>The memory allocator returned an error</source>
          <target state="translated">内存分配器返回一个错误</target>
        </trans-unit>
        <trans-unit id="f691ffd885b1cdd7c3aced4e660ea6b5f2bc5114" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;buf&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 处的内存必须事先由标准库使用的同一分配器分配，并且必须对齐为1。</target>
        </trans-unit>
        <trans-unit id="297bebe1d80f3b348c7c8e6094a67afc0f518766" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;ptr&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 处的内存需要事先由标准库使用的同一分配器分配。</target>
        </trans-unit>
        <trans-unit id="533d683a4cce37c267e983c916aea2694b115c42" translate="yes" xml:space="preserve">
          <source>The memory block will contain the following contents after a successful call to &lt;code&gt;grow_zeroed&lt;/code&gt;:</source>
          <target state="translated">成功调用 &lt;code&gt;grow_zeroed&lt;/code&gt; 之后，内存块将包含以下内容：</target>
        </trans-unit>
        <trans-unit id="9f4c6be6867180c56169b0ceb625f117dffee9cb" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;struct&lt;/code&gt; is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;. In either case, fields may be given in any order in a corresponding struct &lt;em&gt;expression&lt;/em&gt;; the resulting &lt;code&gt;struct&lt;/code&gt; value will always have the same memory layout.</source>
          <target state="translated">默认情况下，未定义 &lt;code&gt;struct&lt;/code&gt; 的内存布局，以允许编译器优化（如字段重新排序），但可以使用&lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; 属性&lt;/a&gt;将其固定。无论哪种情况，都可以在相应的struct &lt;em&gt;表达式中&lt;/em&gt;以任何顺序指定字段；结果 &lt;code&gt;struct&lt;/code&gt; 值将始终具有相同的内存布局。</target>
        </trans-unit>
        <trans-unit id="613a15d193cb4b5b9d7d2448a0d26f441bad60d3" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;union&lt;/code&gt; is undefined by default, but the &lt;code&gt;#[repr(...)]&lt;/code&gt; attribute can be used to fix a layout.</source>
          <target state="translated">一个的存储器布局 &lt;code&gt;union&lt;/code&gt; 被默认未定义，但 &lt;code&gt;#[repr(...)]&lt;/code&gt; 属性可用于固定的布局。</target>
        </trans-unit>
        <trans-unit id="62988640c5b4ea3199910497b4399a06d9aa4bb8" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the memory allocator at runtime.</source>
          <target state="translated">必须在运行时向内存分配器申请内存。</target>
        </trans-unit>
        <trans-unit id="5158117ae58dde222908d602ad3b6cfbc19fbd1b" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the operating system at runtime.</source>
          <target state="translated">必须在运行时向操作系统申请内存。</target>
        </trans-unit>
        <trans-unit id="5fb7e987a9654eee8114bb60b92e8b3cf5d47151" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be accessed through any other pointer (not derived from the return value) for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;. Both read and write accesses are forbidden.</source>
          <target state="translated">在生命周期 &lt;code&gt;'a&lt;/code&gt; 的持续时间内，不得通过任何其他指针（不是从返回值派生）访问返回的切片所引用的内存。读取和写入访问均被禁止。</target>
        </trans-unit>
        <trans-unit id="ff115e1f60568ae547418e535b08f2a38631c573" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be mutated for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;, except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">返回的片段所引用的内存在生命周期 &lt;code&gt;'a&lt;/code&gt; 期间不得 &lt;code&gt;UnsafeCell&lt;/code&gt; ，除非在UnsafeCell内部。</target>
        </trans-unit>
        <trans-unit id="6139b94477b7472bd857c001d753b72d8df9f27e" translate="yes" xml:space="preserve">
          <source>The message can be of any (&lt;code&gt;Any + Send&lt;/code&gt;) type, not just strings.</source>
          <target state="translated">该消息可以是任何（ &lt;code&gt;Any + Send&lt;/code&gt; ）类型，而不仅仅是字符串。</target>
        </trans-unit>
        <trans-unit id="3d782721b766f719dd5b6d817f0d6bb437eb7d6a" translate="yes" xml:space="preserve">
          <source>The message is wrapped in a &lt;code&gt;Box&amp;lt;'static + Any + Send&amp;gt;&lt;/code&gt;, which can be accessed later using &lt;a href=&quot;struct.panicinfo#method.payload&quot;&gt;&lt;code&gt;PanicInfo::payload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">消息被包装在 &lt;code&gt;Box&amp;lt;'static + Any + Send&amp;gt;&lt;/code&gt; ，以后可以使用&lt;a href=&quot;struct.panicinfo#method.payload&quot;&gt; &lt;code&gt;PanicInfo::payload&lt;/code&gt; &lt;/a&gt;访问该消息。</target>
        </trans-unit>
        <trans-unit id="c86a2a43ba3e98f03e1d643c5eb2cb7bce34d7c4" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so counting elements of an iterator with more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">该方法无法防止溢出，因此对迭代器的元素进行计数（其数量超过&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;元素）会产生错误的结果或引起恐慌。如果启用了调试断言，则可以保证出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="177a5c2ea6344ea77e9ae3a6db8fc74469cc253c" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">该方法无法防止溢出，因此枚举多于&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;元素会产生错误的结果或引起恐慌。如果启用了调试断言，则可以保证出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="3a1826392947e9b9a700c20663562183cfe20bf1" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;code&gt;usize::MAX&lt;/code&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">该方法无法防止溢出，因此枚举多于 &lt;code&gt;usize::MAX&lt;/code&gt; 元素会产生错误的结果或引起恐慌。如果启用了调试断言，则可以保证出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="19d8816b84fe470f79cf77755eeb8ee64e555da5" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so if there are more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">该方法无法防止溢出，因此，如果存在不超过&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;不匹配的元素，则它会产生错误的结果或引起恐慌。如果启用了调试断言，则可以保证出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="1be550addda456adee08f228dc9b4f31db12dda4" translate="yes" xml:space="preserve">
          <source>The method will panic if the given step is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果给定步骤为 &lt;code&gt;0&lt;/code&gt; ,则该方法将出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="18a6ab41791924ffc3860ab7c005689a5ace692a" translate="yes" xml:space="preserve">
          <source>The minimum alignment of a type.</source>
          <target state="translated">一种类型的最小对齐方式。</target>
        </trans-unit>
        <trans-unit id="d61a28fc808f2bb8277ab6d2dda14e2b5dc3214d" translate="yes" xml:space="preserve">
          <source>The minimum byte alignment for a memory block of this layout.</source>
          <target state="translated">该布局的内存块的最小字节对齐方式。</target>
        </trans-unit>
        <trans-unit id="e621ea6ab30e14c7bfa77e4fee05fb852bfe464d" translate="yes" xml:space="preserve">
          <source>The minimum duration.</source>
          <target state="translated">最短期限;</target>
        </trans-unit>
        <trans-unit id="5b04e5eee8d92581fabe61b454bd932d16d3b4ee" translate="yes" xml:space="preserve">
          <source>The minimum size in bytes for a memory block of this layout.</source>
          <target state="translated">此布局的内存块的最小尺寸,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="4650b1470ff8fe4b9a6a554cb10a84ba4229b041" translate="yes" xml:space="preserve">
          <source>The mirror use case of FFI is also done via the &lt;code&gt;extern&lt;/code&gt; keyword:</source>
          <target state="translated">FFI的镜像用例也通过 &lt;code&gt;extern&lt;/code&gt; 关键字完成：</target>
        </trans-unit>
        <trans-unit id="a82559d5a04edc93a72fe140de851778ee358fc2" translate="yes" xml:space="preserve">
          <source>The module tree might remind you of the filesystem&amp;rsquo;s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.</source>
          <target state="translated">模块树可能会让您想起计算机上文件系统的目录树。这是一个非常恰当的比较！就像文件系统中的目录一样，您可以使用模块来组织代码。就像目录中的文件一样，我们需要一种找到模块的方法。</target>
        </trans-unit>
        <trans-unit id="ea4c9b3e2b6f858a3799aa18909b3e42f1061d3e" translate="yes" xml:space="preserve">
          <source>The module tree remains the same, and the function calls in &lt;code&gt;eat_at_restaurant&lt;/code&gt; will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.</source>
          <target state="translated">模块树保持不变，即使定义位于不同的文件中， &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中的函数调用也无需任何修改即可工作。这种技术使您可以随着模块大小的增加而将其移动到新文件中。</target>
        </trans-unit>
        <trans-unit id="fb5cf295cab45b30e8f8d196e49ec369e86db99a" translate="yes" xml:space="preserve">
          <source>The monomorphized version of the code looks like the following. The generic &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is replaced with the specific definitions created by the compiler:</source>
          <target state="translated">该代码的单一版本如下所示。通用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 替换为编译器创建的特定定义：</target>
        </trans-unit>
        <trans-unit id="75cf509b67ca81925881254de671f6530c684e13" translate="yes" xml:space="preserve">
          <source>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even &lt;em&gt;must&lt;/em&gt; be used, e.g.</source>
          <target state="translated">一种更常见的继承变异性（必须具有对变量的唯一访问权）是使Rust能够强烈地推理指针别名，静态地防止崩溃错误的关键语言元素之一。因此，首选继承的可变性，而内部可变性是不得已的方法。由于细胞类型可以实现原本不允许的突变，因此有时可能适合内部变异，甚至&lt;em&gt;必须&lt;/em&gt;使用内部变异，例如</target>
        </trans-unit>
        <trans-unit id="22b87181f4af9bcd4494ede540e86fdd7af786b7" translate="yes" xml:space="preserve">
          <source>The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one collection into another. You take a collection, call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it, do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.</source>
          <target state="translated">使用 &lt;code&gt;collect()&lt;/code&gt; 的最基本模式是将一个集合转换为另一个集合。你把一个集合，呼吁&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;就可以了，做了一堆的变换，然后 &lt;code&gt;collect()&lt;/code&gt; 在最后。</target>
        </trans-unit>
        <trans-unit id="8acfa5660545764d445a8a9080882c9972414cad" translate="yes" xml:space="preserve">
          <source>The most basic usage of the keyword is &lt;code&gt;use path::to::item;&lt;/code&gt;, though a number of convenient shortcuts are supported:</source>
          <target state="translated">关键字最基本的用法是 &lt;code&gt;use path::to::item;&lt;/code&gt; ，尽管支持许多便捷的快捷方式：</target>
        </trans-unit>
        <trans-unit id="524cfe2dc48693915271c90c3e4b7d15d2163d53" translate="yes" xml:space="preserve">
          <source>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</source>
          <target state="translated">这个错误最可能的来源是使用角括号符号而没有将函数参数类型包装成元组,例如。</target>
        </trans-unit>
        <trans-unit id="f1fae4bef53f01c296ad8cf52cd2f776bcb2545a" translate="yes" xml:space="preserve">
          <source>The most straightforward smart pointer is a &lt;em&gt;box&lt;/em&gt;, whose type is written &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</source>
          <target state="translated">最简单的智能指针是一个&lt;em&gt;框&lt;/em&gt;，其类型为 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 。框允许您将数据存储在堆而不是堆栈上。堆栈上剩下的是指向堆数据的指针。请参考第4章以查看堆栈和堆之间的区别。</target>
        </trans-unit>
        <trans-unit id="c84503d5e594d47f23b7b930df844dc25ee59200" translate="yes" xml:space="preserve">
          <source>The most surprising behavior occurs when &quot;the same&quot; file is reachable via multiple paths in the module system (usually using the &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; attribute or similar), which can cause what appears to be identical code to return differing values from this function.</source>
          <target state="translated">当可通过模块系统中的多个路径访问&amp;ldquo;相同&amp;rdquo;文件时（通常使用 &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; 属性或类似属性），会发生最令人惊讶的行为，这可能会导致返回看起来相同的代码此函数的值不同。</target>
        </trans-unit>
        <trans-unit id="224b0446b4293b35c3feb8b386382ff2882bd862" translate="yes" xml:space="preserve">
          <source>The most widely used form of macros in Rust is &lt;em&gt;declarative macros&lt;/em&gt;. These are also sometimes referred to as &amp;ldquo;macros by example,&amp;rdquo; &amp;ldquo;&lt;code&gt;macro_rules!&lt;/code&gt; macros,&amp;rdquo; or just plain &amp;ldquo;macros.&amp;rdquo; At their core, declarative macros allow you to write something similar to a Rust &lt;code&gt;match&lt;/code&gt; expression. As discussed in Chapter 6, &lt;code&gt;match&lt;/code&gt; expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</source>
          <target state="translated">Rust中使用最广泛的宏形式是&lt;em&gt;声明性宏&lt;/em&gt;。这些有时也被称为&amp;ldquo;示例宏&amp;rdquo;，&amp;ldquo; &lt;code&gt;macro_rules!&lt;/code&gt; 宏&amp;rdquo;或简单的&amp;ldquo;宏&amp;rdquo;。声明性宏的核心是，您可以编写类似于Rust &lt;code&gt;match&lt;/code&gt; 表达式的内容。如在第6章，讨论 &lt;code&gt;match&lt;/code&gt; 表达式是一种控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式相关联的代码。宏还将值与与特定代码关联的模式进行比较：在这种情况下，该值是传递给宏的文字Rust源代码；将模式与该源代码的结构进行比较；并且与每个模式相关联的代码在匹配时将替换传递给宏的代码。这一切都是在编译过程中发生的。</target>
        </trans-unit>
        <trans-unit id="5c8119cbdd49364e9c5037e1b8a03abc1bccdb46" translate="yes" xml:space="preserve">
          <source>The motivation for this design is twofold:</source>
          <target state="translated">这种设计的动机有两个。</target>
        </trans-unit>
        <trans-unit id="6fd4e131dbce656fa77aa6dbacb12fee04853072" translate="yes" xml:space="preserve">
          <source>The multi-argument form of this macro panics with a string and has the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax for building a string.</source>
          <target state="translated">此宏的多参数形式恐慌，带有字符串，并且&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;用于构建字符串的语法。</target>
        </trans-unit>
        <trans-unit id="ff7a3f839c4dac34de65c2bfcbc13d6c2f460e6c" translate="yes" xml:space="preserve">
          <source>The multiplication assignment operator &lt;code&gt;*=&lt;/code&gt;.</source>
          <target state="translated">乘法赋值运算符 &lt;code&gt;*=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="945e202ccc3f817f464a16a52710aeff055613cc" translate="yes" xml:space="preserve">
          <source>The multiplication operator &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">乘法运算符 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="395bf55779b3f4b37031c67eb2f13567f6e766a4" translate="yes" xml:space="preserve">
          <source>The mutability of a pointer does not change its size. As such, &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; have the same size. Likewise for &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">指针的可变性不会改变其大小。因此， &lt;code&gt;&amp;amp;T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 具有相同的大小。对于 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="f42a8b27f0c72155ef0f3b14d7be6cafaaf62841" translate="yes" xml:space="preserve">
          <source>The mutable slice yields mutable references to the elements:</source>
          <target state="translated">可变的分片产生可变的元素引用。</target>
        </trans-unit>
        <trans-unit id="3c3cbd1ab17a10688ead5cf4d56f2dfc9e512608" translate="yes" xml:space="preserve">
          <source>The mutexes in this module implement a strategy called &quot;poisoning&quot; where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).</source>
          <target state="translated">本模块中的mutexes实现了一种叫做 &quot;中毒 &quot;的策略,只要有线程在持有mutex时发生恐慌,就认为mutex中毒了。一旦一个mutex中毒,所有其他线程都无法默认访问数据,因为数据很可能被污染了(某个不变性没有被维护)。</target>
        </trans-unit>
        <trans-unit id="d8b50303b0747d7e3abc95898503b5bde7711980" translate="yes" xml:space="preserve">
          <source>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</source>
          <target state="translated">为一个外部箱子选择的名称与另一个已经导入到当前模块的外部箱子相冲突。</target>
        </trans-unit>
        <trans-unit id="d94375d609f70bc0ddb2da1f070fd5b681c30cc1" translate="yes" xml:space="preserve">
          <source>The name for an item declaration conflicts with an external crate's name.</source>
          <target state="translated">项目声明的名称与外部箱子的名称冲突。</target>
        </trans-unit>
        <trans-unit id="286d59804da04e407ec36eb2be39e9e0c7ff3343" translate="yes" xml:space="preserve">
          <source>The name must not contain null bytes (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="translated">该名称不得包含空字节（ &lt;code&gt;\0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6584162ced4a99e7d4548e6dfca0a1b5adbdbd8e" translate="yes" xml:space="preserve">
          <source>The need for synchronization</source>
          <target state="translated">同步化的必要性</target>
        </trans-unit>
        <trans-unit id="9491a60a88ee503552e1418886a35e38dd1f594f" translate="yes" xml:space="preserve">
          <source>The need for this type arises from the fact that:</source>
          <target state="translated">之所以需要这种类型,是因为:</target>
        </trans-unit>
        <trans-unit id="3e795b9b16f895fca00c98b1df11fc0d63c7301f" translate="yes" xml:space="preserve">
          <source>The network operation failed because it was not connected yet.</source>
          <target state="translated">因尚未连接,网络操作失败。</target>
        </trans-unit>
        <trans-unit id="7c5a2cc50c7976456054417007ed08f73bfd9e80" translate="yes" xml:space="preserve">
          <source>The never type &lt;code&gt;!&lt;/code&gt; is a type with no values, representing the result of computations that never complete. Expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type.</source>
          <target state="translated">从不输入 &lt;code&gt;!&lt;/code&gt; 是没有值的类型，表示永远不会完成的计算结果。类型的表达式 &lt;code&gt;!&lt;/code&gt; 可以强制为任何其他类型。</target>
        </trans-unit>
        <trans-unit id="2876200ee40ea0a4251130e3bb42070db01f59e5" translate="yes" xml:space="preserve">
          <source>The never type is useful with the &lt;code&gt;panic!&lt;/code&gt; macro as well. Remember the &lt;code&gt;unwrap&lt;/code&gt; function that we call on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; values to produce a value or panic? Here is its definition:</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; ，永不使用类型！宏也是如此。还记得我们在 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 值上调用的 &lt;code&gt;unwrap&lt;/code&gt; 函数来产生值或发生恐慌吗？这是它的定义：</target>
        </trans-unit>
        <trans-unit id="56b6326e5da7a2c1bad08c52fe9675cb30d6fc5f" translate="yes" xml:space="preserve">
          <source>The new test for the case-&lt;em&gt;insensitive&lt;/em&gt; search uses &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; as its query. In the &lt;code&gt;search_case_insensitive&lt;/code&gt; function we&amp;rsquo;re about to add, the query &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; should match the line containing &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; with a capital R and match the line &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven&amp;rsquo;t yet defined the &lt;code&gt;search_case_insensitive&lt;/code&gt; function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the &lt;code&gt;search&lt;/code&gt; function in Listing 12-16 to see the test compile and fail.</source>
          <target state="translated">&lt;em&gt;不区分大小写&lt;/em&gt;搜索的新测试使用 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; 作为查询。在我们要添加的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数中，查询 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; 应将包含 &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; 与大写R匹配，并与 &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; 行匹配。即使两者的查询大小写不同。这是我们的测试失败，并且由于我们尚未定义 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数，因此将无法编译。随意添加一个总是返回一个空向量的框架实现，类似于清单12-16中的 &lt;code&gt;search&lt;/code&gt; 功能可以看到测试编译和失败的方式。</target>
        </trans-unit>
        <trans-unit id="9a3696a40107bd6d0870f3607ce5d6e5073b6d6b" translate="yes" xml:space="preserve">
          <source>The newtype pattern is useful for tasks beyond those we&amp;rsquo;ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 19-15: recall that the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structs wrapped &lt;code&gt;u32&lt;/code&gt; values in a newtype. If we wrote a function with a parameter of type &lt;code&gt;Millimeters&lt;/code&gt;, we couldn&amp;rsquo;t compile a program that accidentally tried to call that function with a value of type &lt;code&gt;Meters&lt;/code&gt; or a plain &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">新类型模式对到目前为止我们已经讨论过的任务非常有用，包括静态强制值永不混淆以及指示值的单位。您在清单19-15中看到了一个使用新类型表示单位的示例：回想一下， &lt;code&gt;Millimeters&lt;/code&gt; 和 &lt;code&gt;Meters&lt;/code&gt; 结构将 &lt;code&gt;u32&lt;/code&gt; 值包装成新类型。如果我们编写的函数的参数类型为 &lt;code&gt;Millimeters&lt;/code&gt; ，那么我们将无法编译一个程序，意外地尝试使用 &lt;code&gt;Meters&lt;/code&gt; 或普通 &lt;code&gt;u32&lt;/code&gt; 类型的值来调用该函数。</target>
        </trans-unit>
        <trans-unit id="b591edfc8b3d018e277499297a4856c76a36dc2a" translate="yes" xml:space="preserve">
          <source>The next four lines set the configuration information Cargo needs to compile your program: the name, the version, who wrote it, and the edition of Rust to use. Cargo gets your name and email information from your environment, so if that information is not correct, fix the information now and then save the file. We&amp;rsquo;ll talk about the &lt;code&gt;edition&lt;/code&gt; key in Appendix E.</source>
          <target state="translated">接下来的四行设置了Cargo编译程序所需的配置信息：名称，版本，编写者以及要使用的Rust版本。货运从您的环境中获取您的姓名和电子邮件信息，因此，如果该信息不正确，请立即修复该信息，然后保存文件。我们将在附录E中讨论 &lt;code&gt;edition&lt;/code&gt; 密钥。</target>
        </trans-unit>
        <trans-unit id="6a7a2603b03740bcea191aea3d000fd9f48ffbb9" translate="yes" xml:space="preserve">
          <source>The next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-28 or the version using iterators in Listing 13-29. Most Rust programmers prefer to use the iterator style. It&amp;rsquo;s a bit tougher to get the hang of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it&amp;rsquo;s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.</source>
          <target state="translated">下一个逻辑问题是您应该在自己的代码中选择哪种样式以及为什么选择：清单13-28中的原始实现或清单13-29中使用迭代器的版本。大多数Rust程序员更喜欢使用迭代器样式。首先要掌握一点困难，但是一旦您了解了各种迭代器适配器及其作用，就可以更容易地理解迭代器。该代码没有摆弄循环的各个部分并构建新的向量，而是专注于循环的高级目标。这样可以抽象一些常用的代码，因此更容易看到此代码特有的概念，例如迭代器中每个元素必须通过的过滤条件。</target>
        </trans-unit>
        <trans-unit id="57f6548988daa34617ffdf2e9ca86d7e443df79f" translate="yes" xml:space="preserve">
          <source>The next note line tells us that we can set the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to get a backtrace of exactly what happened to cause the error. A &lt;em&gt;backtrace&lt;/em&gt; is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. That&amp;rsquo;s the spot where the problem originated. The lines above the lines mentioning your files are code that your code called; the lines below are code that called your code. These lines might include core Rust code, standard library code, or crates that you&amp;rsquo;re using. Let&amp;rsquo;s try getting a backtrace by setting the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to any value except 0. Listing 9-2 shows output similar to what you&amp;rsquo;ll see.</source>
          <target state="translated">下一条注释行告诉我们，我们可以设置 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 环境变量来获得对引起错误的确切原因的追溯。一个&lt;em&gt;回溯&lt;/em&gt;是已经叫了这一点的所有功能的列表。 Rust中的回溯与其他语言一样工作：读取回溯的关键是从顶部开始并进行读取，直到看到写入的文件为止。那就是问题起源的地方。上面提到文件的那行是您的代码所调用的代码；下面的行是称为您的代码的代码。这些行可能包括核心Rust代码，标准库代码或您正在使用的板条箱。让我们尝试通过设置 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 获得回溯 环境变量为除0以外的任何值。清单9-2显示的输出与您将看到的类似。</target>
        </trans-unit>
        <trans-unit id="771993487043dfd3c7aa5a2390e7d9f0063dbedb" translate="yes" xml:space="preserve">
          <source>The next part of the code, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt;, calls the &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method on the standard input handle to get input from the user. We&amp;rsquo;re also passing one argument to &lt;code&gt;read_line&lt;/code&gt;: &lt;code&gt;&amp;amp;mut guess&lt;/code&gt;.</source>
          <target state="translated">代码的下一部分 &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt; 调用标准输入句柄上的&lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt; &lt;code&gt;read_line&lt;/code&gt; &lt;/a&gt;方法以从用户获取输入。我们还将一个参数传递给 &lt;code&gt;read_line&lt;/code&gt; ： &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f3a0383282eca508bd91153f03681dc6f1973f4" translate="yes" xml:space="preserve">
          <source>The next part of the request line is &lt;em&gt;/&lt;/em&gt;, which indicates the &lt;em&gt;Uniform Resource Identifier&lt;/em&gt;&lt;em&gt;(URI)&lt;/em&gt; the client is requesting: a URI is almost, but not quite, the same as a &lt;em&gt;Uniform Resource Locator&lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt;. The difference between URIs and URLs isn&amp;rsquo;t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.</source>
          <target state="translated">请求行的下一部分是&lt;em&gt;/&lt;/em&gt;，它指示客户&lt;em&gt;端正&lt;/em&gt;在请求的&lt;em&gt;统一资源标识符&lt;/em&gt;&lt;em&gt;（URI）&lt;/em&gt;：URI与&lt;em&gt;统一资源定位符&lt;/em&gt;&lt;em&gt;（URL）&lt;/em&gt;几乎相同，但并不完全相同。在本章中，URI和URL之间的区别对于我们的目的并不重要，但是HTTP规范使用术语URI，因此在这里我们可以在心理上用URL代替URI。</target>
        </trans-unit>
        <trans-unit id="504232041214e8dae75346e3d17c4c0bf4814b9b" translate="yes" xml:space="preserve">
          <source>The next part of the test output, which starts with &lt;code&gt;Doc-tests adder&lt;/code&gt;, is for the results of any documentation tests. We don&amp;rsquo;t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps us keep our docs and our code in sync! We&amp;rsquo;ll discuss how to write documentation tests in the &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;Documentation Comments as Tests&amp;rdquo;&lt;/a&gt; section of Chapter 14. For now, we&amp;rsquo;ll ignore the &lt;code&gt;Doc-tests&lt;/code&gt; output.</source>
          <target state="translated">测试输出的下一部分以 &lt;code&gt;Doc-tests adder&lt;/code&gt; 开头，用于任何文档测试的结果。我们还没有任何文档测试，但是Rust可以编译API文档中出现的任何代码示例。此功能可帮助我们使文档和代码保持同步！我们将在第14章的&lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;将文档注释作为测试&amp;rdquo;&lt;/a&gt;部分中讨论如何编写文档测试。现在，我们将忽略 &lt;code&gt;Doc-tests&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="1ac4585430b879637fa9bf73df289a63ff5c8c8c" translate="yes" xml:space="preserve">
          <source>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named &lt;code&gt;foo&lt;/code&gt;, a custom derive procedural macro crate is called &lt;code&gt;foo_derive&lt;/code&gt;. Let&amp;rsquo;s start a new crate called &lt;code&gt;hello_macro_derive&lt;/code&gt; inside our &lt;code&gt;hello_macro&lt;/code&gt; project:</source>
          <target state="translated">下一步是定义过程宏。在撰写本文时，过程宏必须放在自己的箱子里。最终，这一限制可能会解除。用于构造包装箱和宏包装箱的约定如下：对于名为 &lt;code&gt;foo&lt;/code&gt; 的包装箱，自定义派生过程宏包装箱称为 &lt;code&gt;foo_derive&lt;/code&gt; 。让我们在 &lt;code&gt;hello_macro&lt;/code&gt; 项目中启动一个名为 &lt;code&gt;hello_macro_derive&lt;/code&gt; 的新板条箱：</target>
        </trans-unit>
        <trans-unit id="86c376c4d2f9126074dd6023a007174609449704" translate="yes" xml:space="preserve">
          <source>The next time you run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will update the registry of crates available and reevaluate your &lt;code&gt;rand&lt;/code&gt; requirements according to the new version you have specified.</source>
          <target state="translated">下次您运行 &lt;code&gt;cargo build&lt;/code&gt; ，Cargo将更新可用包装箱的注册表，并根据您指定的新版本重新评估您的 &lt;code&gt;rand&lt;/code&gt; 要求。</target>
        </trans-unit>
        <trans-unit id="14f1a8115e3ecc473c296ccb90a19424fd7f3781" translate="yes" xml:space="preserve">
          <source>The nightly feature &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;Arbitrary self types&lt;/a&gt; extends the accepted set of receiver types to also include any type that can dereference to &lt;code&gt;Self&lt;/code&gt;:</source>
          <target state="translated">夜间功能&lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;任意自我类型&lt;/a&gt;扩展了可接受的接收器类型集，还包括可以取消引用 &lt;code&gt;Self&lt;/code&gt; 任何类型：</target>
        </trans-unit>
        <trans-unit id="b3e15e37e03d384e681f27ce15aeb9d3bb4095a8" translate="yes" xml:space="preserve">
          <source>The node that was removed is returned as a new &lt;code&gt;LinkedList&lt;/code&gt; containing only this node. The cursor is moved to point to the next element in the current &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">被删除的节点作为仅包含该节点的新 &lt;code&gt;LinkedList&lt;/code&gt; 返回。光标将移至当前 &lt;code&gt;LinkedList&lt;/code&gt; 中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="145ccdcfae9c0bd6f7e5de42ea443500c786c639" translate="yes" xml:space="preserve">
          <source>The nominal type is called the &lt;em&gt;implementing type&lt;/em&gt; and the associable items are the &lt;em&gt;associated items&lt;/em&gt; to the implementing type.</source>
          <target state="translated">名义类型称为&lt;em&gt;实施类型&lt;/em&gt;，而&lt;em&gt;相关项目&lt;/em&gt;是与实施类型&lt;em&gt;相关的项目&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a450d39487d717bce9613fc2953a92eb80b07994" translate="yes" xml:space="preserve">
          <source>The note mentions &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, which is a &lt;em&gt;trait&lt;/em&gt;. We&amp;rsquo;ll talk about traits in the next section. For now, this error states that the body of &lt;code&gt;largest&lt;/code&gt; won&amp;rsquo;t work for all possible types that &lt;code&gt;T&lt;/code&gt; could be. Because we want to compare values of type &lt;code&gt;T&lt;/code&gt; in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; trait that you can implement on types (see Appendix C for more on this trait). You&amp;rsquo;ll learn how to specify that a generic type has a particular trait in the &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;Traits as Parameters&amp;rdquo;&lt;/a&gt; section, but let&amp;rsquo;s first explore other ways of using generic type parameters.</source>
          <target state="translated">注释中提到了 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; ，这是一个&lt;em&gt;特征&lt;/em&gt;。我们将在下一节中讨论特征。目前，此错误表明， &lt;code&gt;largest&lt;/code&gt; 的主体对 &lt;code&gt;T&lt;/code&gt; 可能适用的所有类型都不起作用。因为我们要比较主体中 &lt;code&gt;T&lt;/code&gt; 类型的值，所以我们只能使用其值可以排序的类型。为了启用比较，标准库具有 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; 特性，您可以在类型上实现（有关此特性的更多信息，请参见附录C）。您将在&lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;特性作为参数&amp;rdquo;&lt;/a&gt;部分中学习如何指定泛型类型具有特定特征，但让我们首先探讨使用泛型类型参数的其他方法。</target>
        </trans-unit>
        <trans-unit id="39a86e3fff1f9b2a932559db164eca88c47636bb" translate="yes" xml:space="preserve">
          <source>The number of arguments passed to a function must match the number of arguments specified in the function signature.</source>
          <target state="translated">传递给函数的参数数必须与函数签名中指定的参数数一致。</target>
        </trans-unit>
        <trans-unit id="1499b95664ab693551effdfbf1800a214feda909" translate="yes" xml:space="preserve">
          <source>The number of elements determines the arity of the tuple. A tuple with &lt;code&gt;n&lt;/code&gt; elements is called an &lt;code&gt;n-ary tuple&lt;/code&gt;. For example, a tuple with 2 elements is a 2-ary tuple.</source>
          <target state="translated">元素的数量决定了元组的奇数。具有 &lt;code&gt;n&lt;/code&gt; 个元素 &lt;code&gt;n-ary tuple&lt;/code&gt; 称为n元元组。例如，具有2个元素的元组是2元元组。</target>
        </trans-unit>
        <trans-unit id="29c5008d92a3f283390aac2066e3363b4399cff1" translate="yes" xml:space="preserve">
          <source>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</source>
          <target state="translated">数组或切片模式中的元素数量与被匹配数组中的元素数量不同。</target>
        </trans-unit>
        <trans-unit id="110544a8e2a789b8a0779516d37df0cd0dba8ad5" translate="yes" xml:space="preserve">
          <source>The number of operands is the arity of the constructed tuple. Tuple expressions without operands produce the unit tuple. For other tuple expressions, the first written operand initializes the 0th element and subsequent operands initializes the next highest element. For example, in the tuple expression &lt;code&gt;('a', 'b', 'c')&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; initializes the value of the 0th element, &lt;code&gt;'b'&lt;/code&gt; the 1st, and &lt;code&gt;'c'&lt;/code&gt; the 2nd.</source>
          <target state="translated">操作数的数量是所构造的元组的总和。没有操作数的元组表达式产生单位元组。对于其他元组表达式，第一个写入的操作数初始化第0个元素，随后的操作数初始化下一个最高的元素。例如，在元组表达式 &lt;code&gt;('a', 'b', 'c')&lt;/code&gt; ， &lt;code&gt;'a'&lt;/code&gt; 初始化第0个元素的值， &lt;code&gt;'b'&lt;/code&gt; 初始化第一个，而 &lt;code&gt;'c'&lt;/code&gt; 初始化第二个。</target>
        </trans-unit>
        <trans-unit id="7202e21ed0c94540f8855e2b43b5089a13dd9685" translate="yes" xml:space="preserve">
          <source>The number of supplied arguments must exactly match the number of defined type parameters.</source>
          <target state="translated">提供的参数数量必须与定义的类型参数数量完全一致。</target>
        </trans-unit>
        <trans-unit id="1505278c99d9fb45d4f4157fc24b25e9be942498" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">偏移量是有界的，不能依赖&amp;ldquo;环绕&amp;rdquo;地址空间。也就是说，无限精度之和必须适合 &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb0b1c110f4f91ff6afa42a1772303d08fd7f686" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a usize.</source>
          <target state="translated">偏移量在界内,不能依靠 &quot;绕过 &quot;地址空间。也就是说,无限精度的和必须适合一个usize。</target>
        </trans-unit>
        <trans-unit id="dec85f2a58c1002de0f34de579c15b9ae5dcc5c3" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum, &lt;strong&gt;in bytes&lt;/strong&gt; must fit in a usize.</source>
          <target state="translated">偏移量是有界的，不能依赖&amp;ldquo;环绕&amp;rdquo;地址空间。也就是说，&lt;strong&gt;以字节为单位&lt;/strong&gt;的无限精度总和必须适合usize。</target>
        </trans-unit>
        <trans-unit id="b405bb6eb2033937b629bd683503a6e77a48009c" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;offset_to&lt;/code&gt; methods.</source>
          <target state="translated">偏移量以 &lt;code&gt;T&lt;/code&gt; 元素的数量表示，而不是以字节表示。返回的值可以与 &lt;code&gt;offset&lt;/code&gt; 或 &lt;code&gt;offset_to&lt;/code&gt; 方法一起使用。</target>
        </trans-unit>
        <trans-unit id="85ba9b2d34ef606ffd767c5e393592519fd3aa95" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;wrapping_add&lt;/code&gt; method.</source>
          <target state="translated">偏移量以 &lt;code&gt;T&lt;/code&gt; 元素的数量表示，而不是以字节表示。返回的值可以与 &lt;code&gt;wrapping_add&lt;/code&gt; 方法一起使用。</target>
        </trans-unit>
        <trans-unit id="1be821c2089924c0d18d107c2c27f16675f5ac1c" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor.</source>
          <target state="translated">这个偏移量是相对于文件的开始而言的,因此与当前光标无关。</target>
        </trans-unit>
        <trans-unit id="084e82e27a45f945c98a971924845d2bbfc865a4" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the read.</source>
          <target state="translated">偏移量相对于文件的开头，因此独立于当前光标。当前光标&lt;strong&gt;是&lt;/strong&gt;这个函数的影响，它被设定为读出结束。</target>
        </trans-unit>
        <trans-unit id="caf802013d8abd4267e3b977c2a718d4ec2a76b7" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the write.</source>
          <target state="translated">偏移量相对于文件的开头，因此独立于当前光标。当前光标&lt;strong&gt;是&lt;/strong&gt;这个函数的影响，它被设置在写结束。</target>
        </trans-unit>
        <trans-unit id="e661f5d3042445d2052a045a18f9872b66b5bc29" translate="yes" xml:space="preserve">
          <source>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</source>
          <target state="translated">旧的借款检查器存在已知的健全性问题,基本无法修复。新的基于NLL的借款检查器就是解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="ff9f5d5ca24724dc4d44a56e5f4a630aa34c4326" translate="yes" xml:space="preserve">
          <source>The one exception is the implicit &lt;code&gt;Self&lt;/code&gt; type of a trait. A trait does not have an implicit &lt;code&gt;Sized&lt;/code&gt; bound as this is incompatible with &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.</source>
          <target state="translated">一个例外是特征的隐式 &lt;code&gt;Self&lt;/code&gt; 类型。特质没有隐式的 &lt;code&gt;Sized&lt;/code&gt; 限制，因为它与&lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;特质对象&lt;/a&gt;不兼容，根据定义，特质对象需要与所有可能的实现者一起使用，因此可以是任意大小。</target>
        </trans-unit>
        <trans-unit id="251eb8c6b3ec1dc5000df1aa3f1d9769e8fc67e3" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one divides &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">可能发生这种换行的唯一情况是将 &lt;code&gt;MIN / -1&lt;/code&gt; 除以有符号类型（其中 &lt;code&gt;MIN&lt;/code&gt; 是该类型的负最小值）；这等效于 &lt;code&gt;-MIN&lt;/code&gt; ，它是一个太大的正值，无法在类型中表示。在这种情况下，此函数将自身返回 &lt;code&gt;MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76c053c143fda09cee97a50ed7a5afba7b9b021c" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one negates &lt;code&gt;MIN&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">可能发生这样的包装的唯一情况是当一个否定 &lt;code&gt;MIN&lt;/code&gt; 上的签名的类型（其中， &lt;code&gt;MIN&lt;/code&gt; 是该类型的负最小值）; 这是一个太大的值，无法在类型中表示。在这种情况下，此函数将自身返回 &lt;code&gt;MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f6de3ab26de46b22b8646658bc86041ba8f3d5e" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">可能发生这种换行的唯一情况是，当某类型取负的最小值为该类型的绝对值时，该正值太大而无法在该类型中表示。在这种情况下，此函数将自身返回 &lt;code&gt;MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45d6aabe4740755ea8f6332847150daa44a43b07" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type; this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">可能发生此类换行的唯一情况是，当类型取负的最小值的绝对值时；这是一个太大的正值，无法在类型中表示。在这种情况下，此函数将自身返回 &lt;code&gt;MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63e8e964be307b9ddc1a920575e78207b9d44077" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to a copied value of &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">清单15-7和清单15-6之间的唯一区别是，在这里我们将 &lt;code&gt;y&lt;/code&gt; 设置为指向 &lt;code&gt;x&lt;/code&gt; 的复制值的盒子的实例，而不是指向 &lt;code&gt;x&lt;/code&gt; 的值的引用。在最后一个断言中，我们可以使用dereference运算符以与 &lt;code&gt;y&lt;/code&gt; 为引用时相同的方式跟踪框的指针。接下来，我们将探索 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 特殊之处，它使我们能够通过定义自己的Box类型来使用解引用运算符。</target>
        </trans-unit>
        <trans-unit id="51b5a7f2069f2def348d2148cbc38445c3e27f4c" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to the value in &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">清单15-7和清单15-6之间的唯一区别是，此处我们将 &lt;code&gt;y&lt;/code&gt; 设置为指向 &lt;code&gt;x&lt;/code&gt; 中的值的盒子的实例，而不是指向 &lt;code&gt;x&lt;/code&gt; 的值的引用。在最后一个断言中，我们可以使用dereference运算符以与 &lt;code&gt;y&lt;/code&gt; 为引用时相同的方式跟踪框的指针。接下来，我们将探索 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 特殊之处，它使我们能够通过定义自己的box类型来使用解引用运算符。</target>
        </trans-unit>
        <trans-unit id="f7b8368bfb1b8c79cdb7d78152517d184d409bdd" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors.</source>
          <target state="translated">可以在静态或常量表达式中调用的唯一函数是 &lt;code&gt;const&lt;/code&gt; 函数和struct / enum构造函数。</target>
        </trans-unit>
        <trans-unit id="aa7a3f715132d2845165ebc499ef1753bb78d047" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors. &lt;code&gt;const&lt;/code&gt; functions are only available on a nightly compiler. Rust currently does not support more general compile-time function execution.</source>
          <target state="translated">可以在静态或常量表达式中调用的唯一函数是 &lt;code&gt;const&lt;/code&gt; 函数和struct / enum构造函数。 &lt;code&gt;const&lt;/code&gt; 函数仅在夜间编译器上可用。Rust目前不支持更常规的编译时函数执行。</target>
        </trans-unit>
        <trans-unit id="f7c42c506a124c9ffe70241d1844e481774b0efe" translate="yes" xml:space="preserve">
          <source>The only lifetime allowed in a constant is &lt;code&gt;'static&lt;/code&gt;, which is the lifetime that encompasses all others in a Rust program. For example, if you wanted to define a constant string, it would look like this:</source>
          <target state="translated">常量中唯一允许的生存期是 &lt;code&gt;'static&lt;/code&gt; ，这是Rust程序中包含所有其他生存期的生存期。例如，如果您想定义一个常量字符串，它将看起来像这样：</target>
        </trans-unit>
        <trans-unit id="c90e7627a1475de1daf664c395cb8fc220c2a179" translate="yes" xml:space="preserve">
          <source>The operand of a field expression.</source>
          <target state="translated">字段表达式的操作数。</target>
        </trans-unit>
        <trans-unit id="c815094584bba28655815f7e3484796d5b4ac295" translate="yes" xml:space="preserve">
          <source>The operand of a unary &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference&lt;/a&gt; operator.</source>
          <target state="translated">一元&lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;借用&lt;/a&gt;或&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;取消引用&lt;/a&gt;运算符的操作数。</target>
        </trans-unit>
        <trans-unit id="cfdf71c707b06cc703ce65b9173f06d5346346a9" translate="yes" xml:space="preserve">
          <source>The operand of an extending &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow expression&lt;/a&gt;.</source>
          <target state="translated">扩展&lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;借位表达式&lt;/a&gt;的操作数。</target>
        </trans-unit>
        <trans-unit id="93f114bcdcaebb0db94cec84309f6c6e9289e758" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">任何&lt;a href=&quot;#implicit-borrows&quot;&gt;隐式借用&lt;/a&gt;的操作数。</target>
        </trans-unit>
        <trans-unit id="8300616806da6883f068d3a939bb5817283d75af" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">任何&lt;a href=&quot;expressions#implicit-borrows&quot;&gt;隐式借用&lt;/a&gt;的操作数。</target>
        </trans-unit>
        <trans-unit id="13205f7dcdf1bb624db42e4217ccc5c5fe9a6c93" translate="yes" xml:space="preserve">
          <source>The operand of any extending borrow expression has its temporary scope extended.</source>
          <target state="translated">任何扩展的借用表达式的操作数都会扩展它的临时范围。</target>
        </trans-unit>
        <trans-unit id="0018d918b5db8fa5a5c40594da4082243e89b941" translate="yes" xml:space="preserve">
          <source>The operand(s) of an extending &lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;cast&lt;/a&gt;, &lt;a href=&quot;expressions/struct-expr&quot;&gt;braced struct&lt;/a&gt;, or &lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;tuple&lt;/a&gt; expression.</source>
          <target state="translated">扩展&lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;数组&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;cast&lt;/a&gt;，大&lt;a href=&quot;expressions/struct-expr&quot;&gt;括号struct&lt;/a&gt;或&lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;tuple&lt;/a&gt;表达式的操作数。</target>
        </trans-unit>
        <trans-unit id="02413f33b0997a467453e2cc175754042613115c" translate="yes" xml:space="preserve">
          <source>The operation failed because a pipe was closed.</source>
          <target state="translated">操作失败的原因是管道被关闭。</target>
        </trans-unit>
        <trans-unit id="e0b6b6bb05edcbe700535a8a02fd6257faeb1085" translate="yes" xml:space="preserve">
          <source>The operation lacked the necessary privileges to complete.</source>
          <target state="translated">该操作缺乏必要的权限,无法完成。</target>
        </trans-unit>
        <trans-unit id="d56bd5ac430688946f617fddd5ff8737ea77aabc" translate="yes" xml:space="preserve">
          <source>The operation needs to block to complete, but the blocking operation was requested to not occur.</source>
          <target state="translated">操作需要阻断才能完成,但要求不发生阻断操作。</target>
        </trans-unit>
        <trans-unit id="554600e43876fa49fe1808261768a1599008a1a5" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; may be applied to operands of boolean type. The &lt;code&gt;||&lt;/code&gt; operator denotes logical 'or', and the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator denotes logical 'and'. They differ from &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, &lt;code&gt;||&lt;/code&gt; only evaluates its right-hand operand when the left-hand operand evaluates to &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; only when it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">运营商 &lt;code&gt;||&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 可以应用于布尔类型的操作数。该 &lt;code&gt;||&lt;/code&gt; 运算符表示逻辑&amp;ldquo;或&amp;rdquo;， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符表示逻辑&amp;ldquo;和&amp;rdquo;。它们与 &lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 中，当左边的操作数尚不确定表达式的结果的右边的操作数仅被评估。也就是说， &lt;code&gt;||&lt;/code&gt; 仅当左侧操作数的结果为 &lt;code&gt;false&lt;/code&gt; 时，才评估其右侧操作数；仅当 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 的结果为 &lt;code&gt;true&lt;/code&gt; 时，才评估其右操作数。</target>
        </trans-unit>
        <trans-unit id="94a90205d7a5e5f5664d5fdcbd09052010d467f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8 byte order mark&lt;/em&gt;&lt;/a&gt; (UTF8BOM production) indicates that the file is encoded in UTF8. It can only occur at the beginning of the file and is ignored by the compiler.</source>
          <target state="translated">可选的&lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8字节顺序标记&lt;/em&gt;&lt;/a&gt;（UTF8BOM产生）指示文件以UTF8编码。它只能出现在文件的开头，并且被编译器忽略。</target>
        </trans-unit>
        <trans-unit id="22d7081f01819ecc0a53443b4c5e3e1a4e2c048a" translate="yes" xml:space="preserve">
          <source>The optional fill character and alignment is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. It must be defined before &lt;code&gt;width&lt;/code&gt;, right after the &lt;code&gt;:&lt;/code&gt;. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. Filling comes in the following variants for different alignments:</source>
          <target state="translated">可选的填充字符和对齐方式通常与&lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt;参数一起提供。必须在 &lt;code&gt;width&lt;/code&gt; 之前，在 &lt;code&gt;:&lt;/code&gt; 之后定义。这表示如果要格式化的值小于 &lt;code&gt;width&lt;/code&gt; 则会在其周围打印一些额外的字符。填充具有以下针对不同对齐方式的变体：</target>
        </trans-unit>
        <trans-unit id="1ef92817d2fa5638a8f8e4bfed63d30ce997249b" translate="yes" xml:space="preserve">
          <source>The order in which this iterator returns entries is platform and filesystem dependent.</source>
          <target state="translated">这个迭代器返回条目的顺序取决于平台和文件系统。</target>
        </trans-unit>
        <trans-unit id="60297fe01f4f2a21350a894e6ee139ac8e93f1b8" translate="yes" xml:space="preserve">
          <source>The order in which to evaluate the sub-expressions</source>
          <target state="translated">评估子表达式的顺序。</target>
        </trans-unit>
        <trans-unit id="61bedc7c16635e05c26ee08451d7e761461ef5bb" translate="yes" xml:space="preserve">
          <source>The organizational problem of allocating responsibility for multiple tasks to the &lt;code&gt;main&lt;/code&gt; function is common to many binary projects. As a result, the Rust community has developed a process to use as a guideline for splitting the separate concerns of a binary program when &lt;code&gt;main&lt;/code&gt; starts getting large. The process has the following steps:</source>
          <target state="translated">将多个任务的责任分配给 &lt;code&gt;main&lt;/code&gt; 功能的组织问题在许多二进制项目中很常见。结果，Rust社区开发了一种流程，当 &lt;code&gt;main&lt;/code&gt; 开始变大时，将其用作拆分二进制程序的单独问题的指南。该过程包括以下步骤：</target>
        </trans-unit>
        <trans-unit id="41be0c260fec224b2719e05df384f73991bede1b" translate="yes" xml:space="preserve">
          <source>The other arm of the &lt;code&gt;match&lt;/code&gt; handles the case where we get an &lt;code&gt;Err&lt;/code&gt; value from &lt;code&gt;File::open&lt;/code&gt;. In this example, we&amp;rsquo;ve chosen to call the &lt;code&gt;panic!&lt;/code&gt; macro. If there&amp;rsquo;s no file named &lt;em&gt;hello.txt&lt;/em&gt; in our current directory and we run this code, we&amp;rsquo;ll see the following output from the &lt;code&gt;panic!&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 的另一部分处理从 &lt;code&gt;File::open&lt;/code&gt; 获得 &lt;code&gt;Err&lt;/code&gt; 值的情况。在这个例子中，我们选择了 &lt;code&gt;panic!&lt;/code&gt; 宏。如果当前目录中没有名为&lt;em&gt;hello.txt&lt;/em&gt;的文件，并且运行此代码，我们将看到 &lt;code&gt;panic!&lt;/code&gt; 的以下输出！巨集：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7bf4938ef9d644fa6590a14199d49f21d906882" translate="yes" xml:space="preserve">
          <source>The other difference between &lt;code&gt;mut&lt;/code&gt; and shadowing is that because we&amp;rsquo;re effectively creating a new variable when we use the &lt;code&gt;let&lt;/code&gt; keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 和shadowing 之间的另一个区别是，因为当我们再次使用 &lt;code&gt;let&lt;/code&gt; 关键字时，我们正在有效地创建一个新变量，因此我们可以更改值的类型，但可以重用相同的名称。例如，假设我们的程序要求用户通过输入空格字符来显示他们想要在某些文本之间有多少空格，但是我们确实希望将该输入存储为数字：</target>
        </trans-unit>
        <trans-unit id="df7669a1bf85d9740015e4131e57d2cd1eb9d9d3" translate="yes" xml:space="preserve">
          <source>The other main use of the &lt;code&gt;const&lt;/code&gt; keyword is in &lt;code&gt;const fn&lt;/code&gt;. This marks a function as being callable in the body of a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; item and in array initializers (commonly called &quot;const contexts&quot;). &lt;code&gt;const fn&lt;/code&gt; are restricted in the set of operations they can perform, to ensure that they can be evaluated at compile-time. See the &lt;a href=&quot;../reference/const_eval&quot;&gt;Reference&lt;/a&gt; for more detail.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 关键字的另一个主要用途是在 &lt;code&gt;const fn&lt;/code&gt; 中。这将一个函数标记为可在 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 项目的主体中以及在数组初始化程序（通常称为&amp;ldquo; const上下文&amp;rdquo;）中调用。 &lt;code&gt;const fn&lt;/code&gt; 在它们可以执行的操作集中受到限制，以确保可以在编译时对其进行评估。有关更多详细信息，请参见&lt;a href=&quot;../reference/const_eval&quot;&gt;参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a27877809931e30e4d816c929aaf44550dc13948" translate="yes" xml:space="preserve">
          <source>The other option is to decide that pinning is &quot;structural&quot; for &lt;code&gt;field&lt;/code&gt;, meaning that if the struct is pinned then so is the field.</source>
          <target state="translated">另一种选择是确定钉住 &lt;code&gt;field&lt;/code&gt; 是&amp;ldquo;结构&amp;rdquo; ，这意味着如果钉住结构，则字段也钉住。</target>
        </trans-unit>
        <trans-unit id="0642ecd58583a2694ae6dacfe0a415f63c694440" translate="yes" xml:space="preserve">
          <source>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called &lt;em&gt;polymorphism&lt;/em&gt;, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</source>
          <target state="translated">使用继承的另一个原因与类型系统有关：允许子类型在与父类型相同的位置使用。这也称为&lt;em&gt;多态&lt;/em&gt;，这意味着如果它们共享某些特征，则可以在运行时将它们彼此替换。</target>
        </trans-unit>
        <trans-unit id="89dc389d4ca8b1b17999395cda6f46045ddfd179" translate="yes" xml:space="preserve">
          <source>The other use of the &lt;code&gt;impl&lt;/code&gt; keyword is in &lt;code&gt;impl Trait&lt;/code&gt; syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 关键字的另一种用法是 &lt;code&gt;impl Trait&lt;/code&gt; 语法，可以将其视为&amp;ldquo;实现此特征的具体类型&amp;rdquo;的简写。它的主要用途是与闭包一起使用，闭包具有在编译时生成的类型定义，不能简单地将其键入。</target>
        </trans-unit>
        <trans-unit id="5fa7bdd2f67d8992d16557677350c79fe148aa6f" translate="yes" xml:space="preserve">
          <source>The other way to solve this error is to make the private type public. Example:</source>
          <target state="translated">解决这个错误的另一个方法是把私有类型变成公共类型。例子:</target>
        </trans-unit>
        <trans-unit id="69b16008db0e7fefb3576376fa59c7cdb24bc4ca" translate="yes" xml:space="preserve">
          <source>The outer scope declares a variable named &lt;code&gt;r&lt;/code&gt; with no initial value, and the inner scope declares a variable named &lt;code&gt;x&lt;/code&gt; with the initial value of 5. Inside the inner scope, we attempt to set the value of &lt;code&gt;r&lt;/code&gt; as a reference to &lt;code&gt;x&lt;/code&gt;. Then the inner scope ends, and we attempt to print the value in &lt;code&gt;r&lt;/code&gt;. This code won&amp;rsquo;t compile because the value &lt;code&gt;r&lt;/code&gt; is referring to has gone out of scope before we try to use it. Here is the error message:</source>
          <target state="translated">外部作用域声明一个没有初始值的名为 &lt;code&gt;r&lt;/code&gt; 的变量，而内部作用域声明一个初始值为5的名为 &lt;code&gt;x&lt;/code&gt; 的变量。在内部作用域内，我们尝试将 &lt;code&gt;r&lt;/code&gt; 的值设置为对 &lt;code&gt;x&lt;/code&gt; 的引用。然后内部作用域结束，我们尝试在 &lt;code&gt;r&lt;/code&gt; 中打印该值。这段代码不会编译，因为在我们尝试使用 &lt;code&gt;r&lt;/code&gt; 之前，它所引用的值已经超出范围。这是错误消息：</target>
        </trans-unit>
        <trans-unit id="ee4813584901b6edf7255c9100533eb924eb1e04" translate="yes" xml:space="preserve">
          <source>The output of a finished process.</source>
          <target state="translated">完成过程的输出。</target>
        </trans-unit>
        <trans-unit id="7091d6ad7f032d028b64c465cb0226168ae0e89e" translate="yes" xml:space="preserve">
          <source>The output of this function should not be used in anything that might have security implications. For example:</source>
          <target state="translated">这个函数的输出不应该用于任何可能有安全影响的事情。例如:</target>
        </trans-unit>
        <trans-unit id="c978821bc364ab92333f8a77fd4cf50814193dc4" translate="yes" xml:space="preserve">
          <source>The output that the future will produce on completion.</source>
          <target state="translated">未来完成后的产出。</target>
        </trans-unit>
        <trans-unit id="4e5a226f1cb2eaa0ff96072c4caeb2fee856332d" translate="yes" xml:space="preserve">
          <source>The output type returned by methods.</source>
          <target state="translated">方法返回的输出类型。</target>
        </trans-unit>
        <trans-unit id="b3fedfd8280044a357b6d9f266e6194249a97d9a" translate="yes" xml:space="preserve">
          <source>The output will be the recommended workout plan. Listing 13-2 shows the &lt;code&gt;main&lt;/code&gt; function we&amp;rsquo;ll use.</source>
          <target state="translated">输出将是建议的锻炼计划。清单13-2显示了我们将使用的 &lt;code&gt;main&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="884c1b47c0faf2e5f38e29c6c1a9622d7629d70c" translate="yes" xml:space="preserve">
          <source>The overall goal of these requirements is to let the consumer of a pipeline use</source>
          <target state="translated">这些要求的总体目标是让管道的消费者使用。</target>
        </trans-unit>
        <trans-unit id="c750221db5bde24f0432e5395fa0e7d6b2249e8f" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;buf&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 的所有权有效地转移到 &lt;code&gt;String&lt;/code&gt; ，然后可以随意分配，重新分配或更改指针所指向的内存的内容。调用此函数后，请确保没有其他任何东西使用指针。</target>
        </trans-unit>
        <trans-unit id="b39c88ef6b933b61e4ea4a039f34870326ac716b" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">将 &lt;code&gt;ptr&lt;/code&gt; 的所有权有效地转移到 &lt;code&gt;String&lt;/code&gt; ，然后可以随意分配，重新分配或更改指针所指向的内存内容。调用此函数后，请确保没有其他东西使用指针。</target>
        </trans-unit>
        <trans-unit id="0c5ac2aeb05d71a34b822c034365a66e97f5d90e" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 的所有权有效地转移到 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，然后Vec &amp;lt;T&amp;gt;可以随意取消分配，重新分配或更改指针所指向的内存内容。调用此函数后，请确保没有其他东西使用指针。</target>
        </trans-unit>
        <trans-unit id="459d615a7b443b2b18398d7b4e4094d21aa9904a" translate="yes" xml:space="preserve">
          <source>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by &lt;code&gt;drop&lt;/code&gt; unless the data has been moved to be owned by another variable.</source>
          <target state="translated">变量的所有权每次都遵循相同的模式：将值分配给另一个变量将其移动。当包含堆中数据的变量超出范围时，将 &lt;code&gt;drop&lt;/code&gt; 该值，除非该数据已被移交给另一个变量拥有。</target>
        </trans-unit>
        <trans-unit id="8158170312c35ad0b4ff632e830474174c9789f6" translate="yes" xml:space="preserve">
          <source>The ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let&amp;rsquo;s do an experiment to show how channels and ownership work together to prevent problems: we&amp;rsquo;ll try to use a &lt;code&gt;val&lt;/code&gt; value in the spawned thread &lt;em&gt;after&lt;/em&gt; we&amp;rsquo;ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn&amp;rsquo;t allowed:</source>
          <target state="translated">所有权规则在消息发送中起着至关重要的作用，因为它们可以帮助您编写安全的并发代码。防止并发编程出错是考虑整个Rust程序所有权的好处。让我们做一个实验，展示通道和所有权如何一起工作以防止问题：在将其发送到通道&lt;em&gt;之后，&lt;/em&gt;我们将尝试在生成的线程中使用 &lt;code&gt;val&lt;/code&gt; 值。尝试编译清单16-9中的代码，以查看为什么不允许使用此代码：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58f56a016b810f8287c744364955b1ffc32f9240" translate="yes" xml:space="preserve">
          <source>The panic hook is a global resource.</source>
          <target state="translated">慌钩是一种全球资源。</target>
        </trans-unit>
        <trans-unit id="684aef30b999855f4bf1399a43d22fd82b7e6c9d" translate="yes" xml:space="preserve">
          <source>The panic hook is invoked when a thread panics, but before the panic runtime is invoked. As such, the hook will run with both the aborting and unwinding runtimes. The default hook prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the &lt;code&gt;set_hook&lt;/code&gt; and &lt;a href=&quot;fn.take_hook&quot;&gt;&lt;code&gt;take_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">当线程出现紧急情况时，将在调用紧急情况运行时之前调用紧急情况钩子。因此，该挂钩将与中止和展开运行时一起运行。默认钩子将消息打印到标准错误，并在请求时生成回溯，但是可以使用 &lt;code&gt;set_hook&lt;/code&gt; 和&lt;a href=&quot;fn.take_hook&quot;&gt; &lt;code&gt;take_hook&lt;/code&gt; &lt;/a&gt;函数自定义此行为。</target>
        </trans-unit>
        <trans-unit id="563c97e45aeee516b45222324d4cc368e8c084ba" translate="yes" xml:space="preserve">
          <source>The parameters given to &lt;code&gt;Layout::from_size_align&lt;/code&gt; or some other &lt;code&gt;Layout&lt;/code&gt; constructor do not satisfy its documented constraints.</source>
          <target state="translated">给 &lt;code&gt;Layout::from_size_align&lt;/code&gt; 或其他一些 &lt;code&gt;Layout&lt;/code&gt; 构造函数提供的参数不满足其记录的约束。</target>
        </trans-unit>
        <trans-unit id="3c2a54faaf19386dc2b06158bf3003e146fc0f45" translate="yes" xml:space="preserve">
          <source>The parameters of any trait method must match between a trait implementation and the trait definition.</source>
          <target state="translated">任何特质方法的参数必须在特质实现和特质定义之间匹配。</target>
        </trans-unit>
        <trans-unit id="df3b8f99f35d92ad550b740bf7dc9171d35b97ed" translate="yes" xml:space="preserve">
          <source>The parent of a statement scope is the scope of the block that contains the statement.</source>
          <target state="translated">语句作用域的父级是包含该语句的块的作用域。</target>
        </trans-unit>
        <trans-unit id="c46091b9f972d668faf65caa23b2e09a8a170568" translate="yes" xml:space="preserve">
          <source>The parent of all other scopes is the scope of the immediately enclosing expression.</source>
          <target state="translated">所有其他作用域的父级是紧随其后的表达式的作用域。</target>
        </trans-unit>
        <trans-unit id="e04065a98d4b38354b6e3e4d4abb130f6c621783" translate="yes" xml:space="preserve">
          <source>The parent of the arm scope is the scope of the &lt;code&gt;match&lt;/code&gt; expression that it belongs to.</source>
          <target state="translated">arm范围的父级是它所属的 &lt;code&gt;match&lt;/code&gt; 表达式的范围。</target>
        </trans-unit>
        <trans-unit id="09a327800a21f08b5d4e1948e88aac172c2121be" translate="yes" xml:space="preserve">
          <source>The parent of the current &lt;a href=&quot;../reference/items/modules&quot;&gt;module&lt;/a&gt;.</source>
          <target state="translated">当前&lt;a href=&quot;../reference/items/modules&quot;&gt;模块&lt;/a&gt;的父级。</target>
        </trans-unit>
        <trans-unit id="529eb4e30d49293a9076afc4b5e1cde599b49562" translate="yes" xml:space="preserve">
          <source>The parent of the expression after the &lt;code&gt;=&amp;gt;&lt;/code&gt; in a &lt;code&gt;match&lt;/code&gt; expression is the scope of the arm that it's in.</source>
          <target state="translated">后表达的父 &lt;code&gt;=&amp;gt;&lt;/code&gt; 在一个 &lt;code&gt;match&lt;/code&gt; 表达式是臂，它在的范围。</target>
        </trans-unit>
        <trans-unit id="7bf69b726f2264b18f25a14f0c4351943f8d4d50" translate="yes" xml:space="preserve">
          <source>The parent of the expression for a &lt;code&gt;match&lt;/code&gt; guard is the scope of the arm that the guard is for.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 防护的表达式的父级是该防护所针对的分支范围。</target>
        </trans-unit>
        <trans-unit id="10e7154b1118c2abd23aedcc36e2f4febf44487b" translate="yes" xml:space="preserve">
          <source>The parent of the expression in an expression statement is the scope of the statement.</source>
          <target state="translated">表达式语句中表达式的父级是语句的范围。</target>
        </trans-unit>
        <trans-unit id="bf1edfebb91e8c5be33d3f8d00037717971d53a2" translate="yes" xml:space="preserve">
          <source>The parent of the initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt; is the &lt;code&gt;let&lt;/code&gt; statement's scope.</source>
          <target state="translated">&lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 语句&lt;/a&gt;的初始化程序的父级是 &lt;code&gt;let&lt;/code&gt; 语句的作用域。</target>
        </trans-unit>
        <trans-unit id="f7896dc490ba78587890c7c602aaea52ff1e61a5" translate="yes" xml:space="preserve">
          <source>The parent thread can also wait on the completion of the child thread; a call to &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; produces a &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, which provides a &lt;code&gt;join&lt;/code&gt; method for waiting:</source>
          <target state="translated">父线程也可以等待子线程的完成。对&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;的调用将产生&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt;，该JoinHandle提供了用于等待的 &lt;code&gt;join&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="46e80e0e5a125dc6b093687f5b3dfa680a2d94d7" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;inline&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">带括号的 &lt;code&gt;inline&lt;/code&gt; 属性需要指定参数：</target>
        </trans-unit>
        <trans-unit id="15c1964228f17e3bf48dc3c0a27f630dfed2aef1" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;instruction_set&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">带括号的 &lt;code&gt;instruction_set&lt;/code&gt; 属性需要指定参数：</target>
        </trans-unit>
        <trans-unit id="d2172d9db47abf995cf78b6d1056e43a62f663b4" translate="yes" xml:space="preserve">
          <source>The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language. In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</source>
          <target state="translated">宏系统使用的解析器功能相当强大,但为了防止当前或未来版本的语言出现歧义,它受到了限制。特别是,除了关于模棱两可的扩展的规则外,一个元变量匹配的非终端后面必须跟上一个已经决定可以安全使用的标记。</target>
        </trans-unit>
        <trans-unit id="72524139620fe5680057ec138f1bc4009c442555" translate="yes" xml:space="preserve">
          <source>The path prefix for modules is the canonical path to that module. For bare implementations, it is the canonical path of the item being implemented surrounded by angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets. For &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt;, it is the canonical path of the item being implemented followed by &lt;code&gt;as&lt;/code&gt; followed by the canonical path to the trait all surrounded in angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets.</source>
          <target state="translated">模块的路径前缀是该模块的规范路径。对于裸露的实现，这是被尖括号（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）包围的要实现的项目的规范路径。对于&lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;性状的实现&lt;/a&gt;，这是该项目的规范的路径被实现的，接着 &lt;code&gt;as&lt;/code&gt; 随后规范路径到性状的角度（所有包围 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）括号。</target>
        </trans-unit>
        <trans-unit id="c6a4fb9e71adbfcd1bb4598c90adf218d993dcba" translate="yes" xml:space="preserve">
          <source>The path to the associated items is &lt;code&gt;&amp;lt;&lt;/code&gt; followed by a path to the implementing type followed by &lt;code&gt;as&lt;/code&gt; followed by a path to the trait followed by &lt;code&gt;&amp;gt;&lt;/code&gt; as a path component followed by the associated item's path component.</source>
          <target state="translated">关联项目的路径是 &lt;code&gt;&amp;lt;&lt;/code&gt; ,后面是实现类型的路径，接着是 &lt;code&gt;as&lt;/code&gt; 然后是特征的路径，然后是 &lt;code&gt;&amp;gt;&lt;/code&gt; 作为路径组成部分，然后是关联项目的路径组成部分。</target>
        </trans-unit>
        <trans-unit id="e791bfe4c14128fe94a9448b536323c040235679" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="9b997b2f72267455f266b90593be72c411299620" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="d7a545179141a5b3642800fa8e44597af1f79a17" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="eab1bd44108e3c6ec8d1d8c6acc9fac3b5f45a9e" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="b3313c804137756973c3dae6df1f5d957a288624" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="bfcc6e07c89f929bc9a9b9157ac58712686768e0" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">模式可以是实现模式特征的任何类型。值得注意的示例是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;和确定拆分的闭包。</target>
        </trans-unit>
        <trans-unit id="eb766e07c7ab39fe3b62bc217205480afe2f8cd2" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">模式可以是实现模式特征的任何类型。值得注意的示例是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;和确定拆分的闭包。其他库可能会提供更复杂的模式，例如正则表达式。</target>
        </trans-unit>
        <trans-unit id="53665fb10463c2a5a8c8a6c23b4c3d2013b572a7" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">模式可以是实现模式特征的任何类型。值得注意的示例是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;和确定拆分的闭包。</target>
        </trans-unit>
        <trans-unit id="8059c918e0a15a39f2f09be5faf1d4cb011e74e6" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">模式可以是实现模式特征的任何类型。值得注意的示例是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;和确定拆分的闭包。其他库可能会提供更复杂的模式，例如正则表达式。</target>
        </trans-unit>
        <trans-unit id="70fe7a4be65487325b69a6e9166bdb513323e0b5" translate="yes" xml:space="preserve">
          <source>The pattern in the following example does four things:</source>
          <target state="translated">下面例子中的模式做了四件事。</target>
        </trans-unit>
        <trans-unit id="5a181811e45dbf2fc9dddcbe8e2017ec7127d78e" translate="yes" xml:space="preserve">
          <source>The pattern in the second match arm introduces a new variable named &lt;code&gt;y&lt;/code&gt; that will match any value inside a &lt;code&gt;Some&lt;/code&gt; value. Because we&amp;rsquo;re in a new scope inside the &lt;code&gt;match&lt;/code&gt; expression, this is a new &lt;code&gt;y&lt;/code&gt; variable, not the &lt;code&gt;y&lt;/code&gt; we declared at the beginning with the value 10. This new &lt;code&gt;y&lt;/code&gt; binding will match any value inside a &lt;code&gt;Some&lt;/code&gt;, which is what we have in &lt;code&gt;x&lt;/code&gt;. Therefore, this new &lt;code&gt;y&lt;/code&gt; binds to the inner value of the &lt;code&gt;Some&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. That value is &lt;code&gt;5&lt;/code&gt;, so the expression for that arm executes and prints &lt;code&gt;Matched, y = 5&lt;/code&gt;.</source>
          <target state="translated">第二个匹配臂中的模式引入了一个名为 &lt;code&gt;y&lt;/code&gt; 的新变量，它将匹配 &lt;code&gt;Some&lt;/code&gt; 值内的任何值。因为我们位于 &lt;code&gt;match&lt;/code&gt; 表达式内的新作用域中，所以这是一个新的 &lt;code&gt;y&lt;/code&gt; 变量，而不是我们在开始时以值10声明的 &lt;code&gt;y&lt;/code&gt; 。此新 &lt;code&gt;y&lt;/code&gt; 绑定将匹配 &lt;code&gt;Some&lt;/code&gt; 中的任何值，这就是我们拥有的在 &lt;code&gt;x&lt;/code&gt; 中。因此，这种新 &lt;code&gt;y&lt;/code&gt; 结合到的内部值 &lt;code&gt;Some&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt; 。该值为 &lt;code&gt;5&lt;/code&gt; ，因此该手臂的表达式将执行并打印 &lt;code&gt;Matched, y = 5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd1b310fb5c60706a33dc63407dcff2f0de81ecd" translate="yes" xml:space="preserve">
          <source>The pattern is most commonly a single variable, which means no pattern matching is done and the expression given is bound to the variable. Apart from that, patterns used in &lt;code&gt;let&lt;/code&gt; bindings can be as complicated as needed, given that the pattern is exhaustive. See the &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust book&lt;/a&gt; for more information on pattern matching. The type of the pattern is optionally given afterwards, but if left blank is automatically inferred by the compiler if possible.</source>
          <target state="translated">模式通常是单个变量，这意味着不进行模式匹配，并且给定的表达式绑定到该变量。除此之外，考虑到该模式是穷举性的， &lt;code&gt;let&lt;/code&gt; 绑定中使用的模式可以根据需要复杂。有关模式匹配的更多信息，请参见&lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust书&lt;/a&gt;。模式的类型在以后可以选择给出，但是如果可能，编译器会自动推断出是否为空白。</target>
        </trans-unit>
        <trans-unit id="c2459ac3b35f7ffa8e048896d3c16ca10cfe1608" translate="yes" xml:space="preserve">
          <source>The pattern of the first arm in the &lt;code&gt;match&lt;/code&gt; expression matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant that contains a &lt;code&gt;Color::Rgb&lt;/code&gt; variant; then the pattern binds to the three inner &lt;code&gt;i32&lt;/code&gt; values. The pattern of the second arm also matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant, but the inner enum matches the &lt;code&gt;Color::Hsv&lt;/code&gt; variant instead. We can specify these complex conditions in one &lt;code&gt;match&lt;/code&gt; expression, even though two enums are involved.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 表达式中第一条手臂的模式与 &lt;code&gt;Message::ChangeColor&lt;/code&gt; 枚举变量匹配，该变量包含 &lt;code&gt;Color::Rgb&lt;/code&gt; 变量；然后该模式将绑定到三个内部 &lt;code&gt;i32&lt;/code&gt; 值。第二个 &lt;code&gt;Color::Hsv&lt;/code&gt; 的模式也与 &lt;code&gt;Message::ChangeColor&lt;/code&gt; 枚举变量匹配，但是内部枚举与Color :: Hsv变量匹配。即使涉及两个枚举，我们也可以在一个 &lt;code&gt;match&lt;/code&gt; 表达式中指定这些复杂条件。</target>
        </trans-unit>
        <trans-unit id="a42d62f0f2bbc370e10f35406b8b10d13fb51143" translate="yes" xml:space="preserve">
          <source>The patterns programmed into Rust&amp;rsquo;s analysis of references are called the &lt;em&gt;lifetime elision rules&lt;/em&gt;. These aren&amp;rsquo;t rules for programmers to follow; they&amp;rsquo;re a set of particular cases that the compiler will consider, and if your code fits these cases, you don&amp;rsquo;t need to write the lifetimes explicitly.</source>
          <target state="translated">编入Rust的参考分析中的模式称为&lt;em&gt;寿命省略规则&lt;/em&gt;。这些不是程序员要遵循的规则。它们是编译器将考虑的一组特殊情况，如果您的代码适合这些情况，则无需显式编写生存期。</target>
        </trans-unit>
        <trans-unit id="012a0566d4550e7174697625c83965140d98cc31" translate="yes" xml:space="preserve">
          <source>The peer address may be set by the &lt;code&gt;connect&lt;/code&gt; method, and this method will return an error if the socket has not already been connected.</source>
          <target state="translated">可以通过 &lt;code&gt;connect&lt;/code&gt; 方法设置对等地址，如果尚未连接套接字，则此方法将返回错误。</target>
        </trans-unit>
        <trans-unit id="c7338ebe0eb2e257ec72f81d23df2b1d8ecc7ce7" translate="yes" xml:space="preserve">
          <source>The performance of these two features (Spoiler alert: they&amp;rsquo;re faster than you might think!)</source>
          <target state="translated">这两个功能的性能（剧透警报：它们比您想象的要快！）</target>
        </trans-unit>
        <trans-unit id="b42828007b197505190540700b376ffcea8793e7" translate="yes" xml:space="preserve">
          <source>The pointer is valid only if there are some strong references. The pointer may be dangling, unaligned or even &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">仅当有一些强引用时，该指针才有效。指针可能是悬空的，未对齐的，否则可能为&lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c13daf063b9e605b83028dc0feae2167ff80511" translate="yes" xml:space="preserve">
          <source>The pointer may be &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or be dangling in case the object has already been destroyed.</source>
          <target state="translated">如果对象已被破坏，则指针可以为&lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt;或悬空。</target>
        </trans-unit>
        <trans-unit id="c51f7cfe5691f3edc0397a76000e0e31815c58dc" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">该指针对于 &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 许多字节的读取和写入必须&lt;a href=&quot;index#safety&quot;&gt;有效&lt;/a&gt;，并且必须正确对齐。这尤其意味着：</target>
        </trans-unit>
        <trans-unit id="2d6cc95e7b609b2c158e2115aa97ef7549141c5d" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">该指针必须对许多字节的 &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 读取&lt;a href=&quot;index#safety&quot;&gt;有效&lt;/a&gt;，并且必须正确对齐。这尤其意味着：</target>
        </trans-unit>
        <trans-unit id="eab75a519555d7d953b751dc8250587661100bb4" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">该指针对于 &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 许多字节的读取和写入必须&lt;a href=&quot;ptr/index#safety&quot;&gt;有效&lt;/a&gt;，并且必须正确对齐。这尤其意味着：</target>
        </trans-unit>
        <trans-unit id="032bd62f596d84915c186de815c7e316435955e0" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">该指针必须对许多字节的 &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 读取&lt;a href=&quot;ptr/index#safety&quot;&gt;有效&lt;/a&gt;，并且必须正确对齐。这尤其意味着：</target>
        </trans-unit>
        <trans-unit id="ada677800eded9f5bb09a12d4c9272e1a48a79a4" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">即使对于零长度的切片，指针也必须对齐。这样做的一个原因是，枚举布局优化可能依赖于对齐的引用（包括任何长度的切片）并且不为空，以将其与其他数据区分开。您可以使用&lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling()&lt;/code&gt; &lt;/a&gt;获得可用作零长度切片 &lt;code&gt;data&lt;/code&gt; 的指针。</target>
        </trans-unit>
        <trans-unit id="5f6efbb545be55e13f893ac7dc6eaebbf999874a" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">即使对于零长度的切片，指针也必须对齐。这样做的一个原因是，枚举布局优化可能依赖于对齐的引用（包括任何长度的切片）并且不为空，以将其与其他数据区分开。您可以使用&lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling()&lt;/code&gt; &lt;/a&gt;获得可用作零长度切片 &lt;code&gt;data&lt;/code&gt; 的指针。</target>
        </trans-unit>
        <trans-unit id="7882f94a6f87dc84506e67cf6e6f86cd53b02982" translate="yes" xml:space="preserve">
          <source>The pointer must be properly aligned.</source>
          <target state="translated">指针必须正确对齐。</target>
        </trans-unit>
        <trans-unit id="e3de011a05d32ff014b1d75b10f32cd8a5ceea0c" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) for the duration of this method.</source>
          <target state="translated">在此方法的持续时间内，必须已通过 &lt;code&gt;Arc::into_raw&lt;/code&gt; 获得了指针，并且关联的 &lt;code&gt;Arc&lt;/code&gt; 实例必须有效（即，强计数必须至少为1）。</target>
        </trans-unit>
        <trans-unit id="d97c31e45ac08eaf340466af2855c1d69a8c822f" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) when invoking this method. This method can be used to release the final &lt;code&gt;Arc&lt;/code&gt; and backing storage, but &lt;strong&gt;should not&lt;/strong&gt; be called after the final &lt;code&gt;Arc&lt;/code&gt; has been released.</source>
          <target state="translated">调用此方法时，必须已通过 &lt;code&gt;Arc::into_raw&lt;/code&gt; 获得了指针，并且关联的 &lt;code&gt;Arc&lt;/code&gt; 实例必须有效（即，强计数必须至少为1）。此方法可用于释放最终的 &lt;code&gt;Arc&lt;/code&gt; 和后备存储，但是在释放最终的 &lt;code&gt;Arc&lt;/code&gt; 之后&lt;strong&gt;不应&lt;/strong&gt;调用此方法。</target>
        </trans-unit>
        <trans-unit id="15b7d63adfc51a7db20582294688b5c6c47a0e5f" translate="yes" xml:space="preserve">
          <source>The pointer must have originated from the &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; and must still own its potential weak reference.</source>
          <target state="translated">该指针必须源自&lt;a href=&quot;struct.weak#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt;并且仍必须拥有其潜在的弱引用。</target>
        </trans-unit>
        <trans-unit id="561496e3426c59f66cb3091efa83ade648ff436f" translate="yes" xml:space="preserve">
          <source>The pointer must point to an initialized instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">指针必须指向 &lt;code&gt;T&lt;/code&gt; 的初始化实例。</target>
        </trans-unit>
        <trans-unit id="d562cc44e11330190c6c67edae5c28019986b445" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">该指针必须代表一个有效的弱计数。换句话说，它必须指向 &lt;code&gt;T&lt;/code&gt; 是或者&lt;em&gt;是&lt;/em&gt;由管理&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;和，弱计数&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;不能达到0.这是允许的强烈计数为0。</target>
        </trans-unit>
        <trans-unit id="20794b93602408cab637197663bf6c675231f221" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">该指针必须代表一个有效的弱计数。换句话说，它必须指向 &lt;code&gt;T&lt;/code&gt; 其是或&lt;em&gt;被&lt;/em&gt;由管理&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;和的，弱计数&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;不能达到0。允许为强计数为0。</target>
        </trans-unit>
        <trans-unit id="d6200eb92cc97fc1d9fec6dde1612acc6fca320f" translate="yes" xml:space="preserve">
          <source>The pointer passed to all functions inside the vtable is the &lt;code&gt;data&lt;/code&gt; pointer from the enclosing &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">传递给vtable内部所有函数的指针是来自封闭的&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;对象的 &lt;code&gt;data&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="1edb65c05d4061d65ef7c599b48750ef7ff50704" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">此函数返回的指针必须返回到Rust，并使用&lt;a href=&quot;#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt;进行重构以正确释放。具体地，应该&lt;em&gt;不&lt;/em&gt;使用标准C &lt;code&gt;free()&lt;/code&gt; 的函数来解除分配此字符串。</target>
        </trans-unit>
        <trans-unit id="80c5d8a7d931f08c90875d736c69378d02a8b64f" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">该函数返回的指针必须返回到Rust并使用&lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt;进行重构，以正确释放。具体地，应该&lt;em&gt;不&lt;/em&gt;使用标准C &lt;code&gt;free()&lt;/code&gt; 的函数来解除分配此字符串。</target>
        </trans-unit>
        <trans-unit id="33be8edf304b61e5005625c2c6aab855fc0ce0b3" translate="yes" xml:space="preserve">
          <source>The pointer will be properly aligned and non-null.</source>
          <target state="translated">指针将被正确对齐且非空。</target>
        </trans-unit>
        <trans-unit id="0c49a977fe21d66debc9a4c8b7d4cbbf312c9ff9" translate="yes" xml:space="preserve">
          <source>The pointer-sized signed integer type.</source>
          <target state="translated">指针大小的有符号整数类型。</target>
        </trans-unit>
        <trans-unit id="aebc6996cd3e6c3ef507e0e5f263e13ad4dcb04b" translate="yes" xml:space="preserve">
          <source>The pointer-sized unsigned integer type.</source>
          <target state="translated">指针大小的无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="589a00e779c762d350b4058d583ec6c935c455c7" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">&lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(_)&lt;/code&gt; 用于查找的位置是如果 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 没有内部缓冲区则基础阅读器所处的位置。</target>
        </trans-unit>
        <trans-unit id="4aef48aecfebe1bd9e6f96a0939bb1d8fec84054" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">&lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; 用于查找的位置是如果 &lt;code&gt;BufReader&lt;/code&gt; 没有内部缓冲区，则底层阅读器将位于的位置。</target>
        </trans-unit>
        <trans-unit id="6f1678b0e093177e7620807a9112f4ef7365e563" translate="yes" xml:space="preserve">
          <source>The positive difference of two numbers.</source>
          <target state="translated">两个数的正差。</target>
        </trans-unit>
        <trans-unit id="e0a83025808dfefbef9f39106ce5fafd89bb2f1c" translate="yes" xml:space="preserve">
          <source>The practical use cases for &lt;code&gt;forget&lt;/code&gt; are rather specialized and mainly come up in unsafe or FFI code.</source>
          <target state="translated">&lt;code&gt;forget&lt;/code&gt; 的实际用例相当专业，主要用不安全或FFI代码编写。</target>
        </trans-unit>
        <trans-unit id="fb2efbc552f75b7ae8fe422ecdae2c87a030f044" translate="yes" xml:space="preserve">
          <source>The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</source>
          <target state="translated">Rust运算符和表达式的优先级排序如下,从强到弱。同一优先级的二元运算符按其关联性给出的顺序分组。</target>
        </trans-unit>
        <trans-unit id="5ed57a298428ca0f7395d0616c5eb17f0804c549" translate="yes" xml:space="preserve">
          <source>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</source>
          <target state="translated">精确的Rust别名规则有些变化,但要点没有争议。</target>
        </trans-unit>
        <trans-unit id="b19f5cee233892caf5ddceb163f25862486da448" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">确切的定义是：当且仅当 &lt;code&gt;&amp;amp;T&lt;/code&gt; 为&lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 时,&lt;/a&gt;类型 &lt;code&gt;T&lt;/code&gt; 为&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;。换句话说，在线程之间传递 &lt;code&gt;&amp;amp;T&lt;/code&gt; 引用时，如果没有&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义行为&lt;/a&gt;（包括数据争用）的可能性。</target>
        </trans-unit>
        <trans-unit id="d40bd8a03d88e20d491263cadc1752cd72c99258" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">确切的定义是：当且仅当 &lt;code&gt;&amp;amp;T&lt;/code&gt; 为&lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 时,&lt;/a&gt;类型 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;Sync&lt;/code&gt; 。换句话说，在线程之间传递 &lt;code&gt;&amp;amp;T&lt;/code&gt; 引用时，如果不可能发生&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;不确定的行为&lt;/a&gt;（包括数据争用）。</target>
        </trans-unit>
        <trans-unit id="f47fdb8c6eff67732e48f22a8373d2422de700a9" translate="yes" xml:space="preserve">
          <source>The precise memory layout of a struct is not specified. One can specify a particular layout using the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">没有指定结构的精确内存布局。可以使用&lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; 属性&lt;/a&gt;指定一种特定的布局。</target>
        </trans-unit>
        <trans-unit id="18073d476ac74d19109a41401163857e8cd5056d" translate="yes" xml:space="preserve">
          <source>The precise rules for validity are not determined yet. The guarantees that are provided at this point are very minimal:</source>
          <target state="translated">有效性的确切规则尚未确定。目前提供的保障是非常少的。</target>
        </trans-unit>
        <trans-unit id="4933f50236b0c7e48edc0beedb70199f13c5e285" translate="yes" xml:space="preserve">
          <source>The predicate passed to &lt;code&gt;partition()&lt;/code&gt; can return &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;partition()&lt;/code&gt; returns a pair, all of the elements for which it returned &lt;code&gt;true&lt;/code&gt;, and all of the elements for which it returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;partition()&lt;/code&gt; 的谓词可以返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;partition()&lt;/code&gt; 返回一对，返回其所有元素为 &lt;code&gt;true&lt;/code&gt; ，返回所有元素为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fb4a93626b0bdb54fdbc20512bf4f76ed5cc7cd" translate="yes" xml:space="preserve">
          <source>The preferred alignment of a type.</source>
          <target state="translated">一种类型的首选排列。</target>
        </trans-unit>
        <trans-unit id="dbc19e95dcebc744b29e267ad8d2ebfde2e212c0" translate="yes" xml:space="preserve">
          <source>The prelude can be changed to the &lt;em&gt;core prelude&lt;/em&gt; by using the &lt;code&gt;no_std&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; on the root crate module. The linked crate is &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt;&lt;code&gt;core&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt;&lt;code&gt;core::prelude::v1&lt;/code&gt;&lt;/a&gt;. Using the core prelude over the standard prelude is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. &lt;code&gt;Box&lt;/code&gt; and &lt;code&gt;Vec&lt;/code&gt;) and file and network capabilities (e.g. &lt;code&gt;std::fs&lt;/code&gt; and &lt;code&gt;std::io&lt;/code&gt;).</source>
          <target state="translated">通过使用根板条箱模块上的 &lt;code&gt;no_std&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;，可以将前奏更改为&lt;em&gt;核心前奏&lt;/em&gt;。链接的板条箱是&lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt; &lt;code&gt;core&lt;/code&gt; &lt;/a&gt;，而prelude模块是&lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt; &lt;code&gt;core::prelude::v1&lt;/code&gt; &lt;/a&gt;。当板条箱针对不支持标准库的平台或有目的地不使用标准库的功能的平台时，在标准前奏中使用核心前奏很有用。这些功能主要是动态内存分配（例如 &lt;code&gt;Box&lt;/code&gt; 和 &lt;code&gt;Vec&lt;/code&gt; ）以及文件和网络功能（例如 &lt;code&gt;std::fs&lt;/code&gt; 和 &lt;code&gt;std::io&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="97af9d37776d235cea4e5a19d84cc2b3492bd088" translate="yes" xml:space="preserve">
          <source>The previous Appendix D, &amp;ldquo;Macros,&amp;rdquo; has been expanded to include procedural macros and was moved to the &amp;ldquo;Macros&amp;rdquo; section in Chapter 19.</source>
          <target state="translated">先前的附录D&amp;ldquo;宏&amp;rdquo;已扩展为包括过程宏，并移至第19章的&amp;ldquo;宏&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="757bcf5f0a1b2e7c263eb1294cae88079f56068e" translate="yes" xml:space="preserve">
          <source>The previous code example fixed:</source>
          <target state="translated">前面的代码示例固定。</target>
        </trans-unit>
        <trans-unit id="3f0414a5a5139b7f4e08b6a8b19dea661159e39f" translate="yes" xml:space="preserve">
          <source>The previous example contains a circular dependency between two traits: &lt;code&gt;FirstTrait&lt;/code&gt; depends on &lt;code&gt;SecondTrait&lt;/code&gt; which itself depends on &lt;code&gt;FirstTrait&lt;/code&gt;.</source>
          <target state="translated">前面的示例包含两个特征之间的循环依赖关系： &lt;code&gt;FirstTrait&lt;/code&gt; 依赖于 &lt;code&gt;SecondTrait&lt;/code&gt; ，而SecondTrait本身依赖 &lt;code&gt;FirstTrait&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74a02be48083e6dc1dccc9a7d07cadacc4a53e7c" translate="yes" xml:space="preserve">
          <source>The previously duplicated code is now outside the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks and uses the &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-8.</source>
          <target state="translated">现在，以前复制的代码位于 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块之外，并使用 &lt;code&gt;status_line&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 变量。这使得比较容易看出这两种情况之间的区别，这意味着如果我们想更改文件读取和响应写入的工作方式，则只有一个地方可以更新代码。清单20-9中的代码的行为与清单20-8中的代码相同。</target>
        </trans-unit>
        <trans-unit id="3c5b34498a69e2cebc3edcacf3022a159fa0d3cf" translate="yes" xml:space="preserve">
          <source>The primary separator of path components for the current platform.</source>
          <target state="translated">当前平台的路径组件的主要分离器。</target>
        </trans-unit>
        <trans-unit id="d6d94c1dd4c2a4fb7b30d949d7313e70926e43b0" translate="yes" xml:space="preserve">
          <source>The primary use for the &lt;code&gt;let&lt;/code&gt; keyword is in &lt;code&gt;let&lt;/code&gt; statements, which are used to introduce a new set of variables into the current scope, as given by a pattern.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 关键字的主要用途是在 &lt;code&gt;let&lt;/code&gt; 语句中，该语句用于将一组新变量引入当前作用域，如模式所示。</target>
        </trans-unit>
        <trans-unit id="14d97c2e9b793134fb211ba0f8484d81636a707d" translate="yes" xml:space="preserve">
          <source>The primary use of the &lt;code&gt;crate&lt;/code&gt; keyword is as a part of &lt;code&gt;extern crate&lt;/code&gt; declarations, which are used to specify a dependency on a crate external to the one it's declared in. Crates are the fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can be read about crates in the &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; 关键字的主要用途是 &lt;code&gt;extern crate&lt;/code&gt; 声明的一部分，extern crate声明用于指定对其声明的外部外部条件箱的依赖性。条板箱是Rust代码的基本编译单元，可以看作是库。或项目。在&lt;a href=&quot;../reference/items/extern-crates&quot;&gt;参考资料中&lt;/a&gt;可以找到有关板条箱的更多信息。</target>
        </trans-unit>
        <trans-unit id="229057a153cb547539a5140063be86de4fd5f109" translate="yes" xml:space="preserve">
          <source>The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.</source>
          <target state="translated">锁的优先级策略取决于底层操作系统的实现,这种类型不保证会使用任何特定的策略。</target>
        </trans-unit>
        <trans-unit id="aa4bf60f4fab6128150a2cced20eb507a73f2223" translate="yes" xml:space="preserve">
          <source>The private address ranges are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; and include:</source>
          <target state="translated">专用地址范围在&lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt;中定义，包括：</target>
        </trans-unit>
        <trans-unit id="66e536d148965eb5f5f66293b59e6e08d6c64117" translate="yes" xml:space="preserve">
          <source>The problem above can be solved by using the &lt;code&gt;ref&lt;/code&gt; keyword.</source>
          <target state="translated">上面的问题可以通过使用 &lt;code&gt;ref&lt;/code&gt; 关键字解决。</target>
        </trans-unit>
        <trans-unit id="a6b09f11dabd510af2bfd7f547ade1211b4999bd" translate="yes" xml:space="preserve">
          <source>The problem here is that foo is defined as accepting a parameter of type &lt;code&gt;Fn&lt;/code&gt;. Closures passed into foo will thus be inferred to be of type &lt;code&gt;Fn&lt;/code&gt;, meaning that they capture their context immutably.</source>
          <target state="translated">这里的问题是foo被定义为接受 &lt;code&gt;Fn&lt;/code&gt; 类型的参数。因此，传递给foo的闭包将被推断为 &lt;code&gt;Fn&lt;/code&gt; 类型，这意味着它们不可变地捕获其上下文。</target>
        </trans-unit>
        <trans-unit id="31cdd55efce31c6be1cacdfc4b62449817b4add1" translate="yes" xml:space="preserve">
          <source>The problem here is that if the given type or one of its fields implements the &lt;code&gt;Drop&lt;/code&gt; trait, this &lt;code&gt;Drop&lt;/code&gt; implementation cannot be called within a const context since it may run arbitrary, non-const-checked code. To prevent this issue, ensure all values with custom a custom &lt;code&gt;Drop&lt;/code&gt; implementation escape the initializer.</source>
          <target state="translated">这里的问题是，如果给定类型或其字段之一实现了 &lt;code&gt;Drop&lt;/code&gt; 特性，则此 &lt;code&gt;Drop&lt;/code&gt; 实现不能在const上下文中调用，因为它可以运行任意的，未经const检查的代码。为防止出现此问题，请确保所有带有自定义自定义 &lt;code&gt;Drop&lt;/code&gt; 实现的值都退出初始化程序。</target>
        </trans-unit>
        <trans-unit id="2c0a1b6d65ca057a3fdc49e919abfbdd1b60d9bd" translate="yes" xml:space="preserve">
          <source>The problem here is that the lifetime isn't contrained by any of the arguments, making it impossible to determine how long it's supposed to live.</source>
          <target state="translated">这里的问题是,寿命并没有受到任何论证的约束,使得它无法确定应该活多久。</target>
        </trans-unit>
        <trans-unit id="fe892e0206a6e32b9668f223826cd09ae2236ca9" translate="yes" xml:space="preserve">
          <source>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</source>
          <target state="translated">这里的问题是,我们正试图从 MyTrait 中获取 X 的类型。不幸的是,X 的类型并没有被定义,因为它只在 trait 的实现中被具体化。这个代码的工作版本可能是这样的。</target>
        </trans-unit>
        <trans-unit id="e5cbbff1b6bec23be456b36b8e81795c5a5d74a0" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;result&lt;/code&gt; goes out of scope and gets cleaned up at the end of the &lt;code&gt;longest&lt;/code&gt; function. We&amp;rsquo;re also trying to return a reference to &lt;code&gt;result&lt;/code&gt; from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won&amp;rsquo;t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</source>
          <target state="translated">问题是 &lt;code&gt;result&lt;/code&gt; 超出了范围，并在 &lt;code&gt;longest&lt;/code&gt; 函数结束时被清除。我们还试图返回对该函数 &lt;code&gt;result&lt;/code&gt; 的引用。我们无法指定将更改悬空参考的生命周期参数，Rust不允许我们创建悬空参考。在这种情况下，最好的解决办法是返回一个拥有的数据类型，而不是返回一个引用，因此调用函数负责清理该值。</target>
        </trans-unit>
        <trans-unit id="967a587dbf080c4427ca5b25acc74fdfbb85e443" translate="yes" xml:space="preserve">
          <source>The problem is that the first time we called &lt;code&gt;c.value&lt;/code&gt; with 1, the &lt;code&gt;Cacher&lt;/code&gt; instance saved &lt;code&gt;Some(1)&lt;/code&gt; in &lt;code&gt;self.value&lt;/code&gt;. Thereafter, no matter what we pass in to the &lt;code&gt;value&lt;/code&gt; method, it will always return 1.</source>
          <target state="translated">问题在于，我们第一次使用1 调用 &lt;code&gt;c.value&lt;/code&gt; 时， &lt;code&gt;Cacher&lt;/code&gt; 实例将 &lt;code&gt;Some(1)&lt;/code&gt; 保存在 &lt;code&gt;self.value&lt;/code&gt; 中。此后，无论我们传递给 &lt;code&gt;value&lt;/code&gt; 方法什么，它将始终返回1。</target>
        </trans-unit>
        <trans-unit id="833738d2692abe453105a9ed609d8a8bc820fa2a" translate="yes" xml:space="preserve">
          <source>The problem is that the parameter &lt;code&gt;T&lt;/code&gt; does not appear in the implementing type (&lt;code&gt;Foo&lt;/code&gt;) of the impl. In this case, we can fix the error by moving the type parameter from the &lt;code&gt;impl&lt;/code&gt; to the method &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">问题是参数 &lt;code&gt;T&lt;/code&gt; 不会出现在impl 的实现类型（ &lt;code&gt;Foo&lt;/code&gt; ）中。在这种情况下，我们可以通过将类型参数从 &lt;code&gt;impl&lt;/code&gt; 移到 &lt;code&gt;get&lt;/code&gt; 方法来解决错误：</target>
        </trans-unit>
        <trans-unit id="457d0fe3119f86c660d95b413dfdd79fba1ea792" translate="yes" xml:space="preserve">
          <source>The problem isn&amp;rsquo;t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, and it is &lt;a href=&quot;../std/option/enum.option&quot;&gt;defined by the standard library&lt;/a&gt; as follows:</source>
          <target state="translated">问题不在于概念，而在于特定的实现。这样，Rust没有空值，但是它确实有一个枚举，该枚举可以编码存在或不存在的值的概念。该枚举是 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ，&lt;a href=&quot;../std/option/enum.option&quot;&gt;由标准库&lt;/a&gt;定义如下：</target>
        </trans-unit>
        <trans-unit id="11afe9c5b7d3b341c43395982cbb657bcfedf0f3" translate="yes" xml:space="preserve">
          <source>The problem with null values is that if you try to use a null value as a not-null value, you&amp;rsquo;ll get an error of some kind. Because this null or not-null property is pervasive, it&amp;rsquo;s extremely easy to make this kind of error.</source>
          <target state="translated">空值的问题在于，如果您尝试将空值用作非空值，则会出现某种错误。由于此null或not-null属性无处不在，因此很容易产生这种错误。</target>
        </trans-unit>
        <trans-unit id="c7ffb82b1f0d51caf9c86374d324e2fb9ccac1dd" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the contents.</source>
          <target state="translated">该进程缺乏查看内容的权限。</target>
        </trans-unit>
        <trans-unit id="475777e2dbe3eb987a1fdf9f7258e8744d697a33" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the number of hardware threads available.</source>
          <target state="translated">进程缺乏查看可用硬件线程数的权限。</target>
        </trans-unit>
        <trans-unit id="d5a1f341aa82ec15ad62b2ae6744edcef123d4a7" translate="yes" xml:space="preserve">
          <source>The process may be in a &quot;broken state&quot; if this function returns in error. For example the working directory, environment variables, signal handling settings, various user/group information, or aspects of stdio file descriptors may have changed. If a &quot;transactional spawn&quot; is required to gracefully handle errors it is recommended to use the cross-platform &lt;code&gt;spawn&lt;/code&gt; instead.</source>
          <target state="translated">如果此函数错误返回，则该过程可能处于&amp;ldquo;中断状态&amp;rdquo;。例如，工作目录，环境变量，信号处理设置，各种用户/组信息或stdio文件描述符的各个方面可能已更改。如果需要&amp;ldquo;事务生成&amp;rdquo;来妥善处理错误，建议改用跨平台 &lt;code&gt;spawn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68c2b04d8256c338d13f147c4eb19b87b45d4040" translate="yes" xml:space="preserve">
          <source>The programs we&amp;rsquo;ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we&amp;rsquo;ll cover in the &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;Cargo Workspaces&amp;rdquo;&lt;/a&gt; section in Chapter 14.</source>
          <target state="translated">到目前为止，我们编写的程序都在一个模块中的一个文件中。随着项目的发展，您可以通过将代码分成多个模块然后分成多个文件来组织代码。一个包可以包含多个二进制板条箱，也可以包含一个库板条箱。随着软件包的增长，您可以将零件提取到单独的板条箱中，这些板条箱成为外部依赖项。本章涵盖所有这些技术。对于一起发展的一组相互关联的程序包的大型项目，Cargo提供了工作区，我们将在第14章的&lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;货物工作区&amp;rdquo;&lt;/a&gt;一节中介绍这些工作区。</target>
        </trans-unit>
        <trans-unit id="5cc2497d5ed1d06060f022ff65bd8b3ff66c60a9" translate="yes" xml:space="preserve">
          <source>The provided &lt;a href=&quot;struct.layout#method.size&quot;&gt;&lt;code&gt;layout.size()&lt;/code&gt;&lt;/a&gt; must fall in the range &lt;code&gt;min ..= max&lt;/code&gt;, where:</source>
          <target state="translated">提供的&lt;a href=&quot;struct.layout#method.size&quot;&gt; &lt;code&gt;layout.size()&lt;/code&gt; &lt;/a&gt;必须在 &lt;code&gt;min ..= max&lt;/code&gt; 范围内，其中：</target>
        </trans-unit>
        <trans-unit id="be1cd28ce339784f890d38adb07a623811959d09" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;path&lt;/code&gt; doesn't exist.</source>
          <target state="translated">提供的 &lt;code&gt;path&lt;/code&gt; 不存在。</target>
        </trans-unit>
        <trans-unit id="a99e10f876c8ad74bd47e22ac1f9e01fe1760d28" translate="yes" xml:space="preserve">
          <source>The public methods &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; are the only ways to access or modify data in an instance of &lt;code&gt;AveragedCollection&lt;/code&gt;. When an item is added to &lt;code&gt;list&lt;/code&gt; using the &lt;code&gt;add&lt;/code&gt; method or removed using the &lt;code&gt;remove&lt;/code&gt; method, the implementations of each call the private &lt;code&gt;update_average&lt;/code&gt; method that handles updating the &lt;code&gt;average&lt;/code&gt; field as well.</source>
          <target state="translated">公共方法 &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;remove&lt;/code&gt; 和 &lt;code&gt;average&lt;/code&gt; 是在 &lt;code&gt;AveragedCollection&lt;/code&gt; 实例中访问或修改数据的唯一方法。当使用 &lt;code&gt;add&lt;/code&gt; 方法将项目添加到 &lt;code&gt;list&lt;/code&gt; 或使用 &lt;code&gt;remove&lt;/code&gt; 方法将项目删除时，每个项目的实现都调用私有的 &lt;code&gt;update_average&lt;/code&gt; 方法，该方法也处理 &lt;code&gt;average&lt;/code&gt; 字段的更新。</target>
        </trans-unit>
        <trans-unit id="c64a2ba34c09d4f2e756bf0b0db2bf928ce82f04" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is called&lt;/em&gt;. Only once &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; returns or panics, the memory may be reused.</source>
          <target state="translated">固定的目的是能够依靠某些数据在内存中的放置。为了使这项工作有效，不仅限制了移动数据，还限制了数据的传输。限制用于存储数据的内存的重新分配，重新使用或以其他方式无效。具体来说，对于固定的数据，您必须保持不变，即&lt;em&gt;从固定数据到调用&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;，&lt;em&gt;其内存都不会失效或重新利用&lt;/em&gt;。仅当&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;返回或出现紧急情况时，该内存才可以重用。</target>
        </trans-unit>
        <trans-unit id="4a93f31254516d6844f82cc6e94b5893fc7d6231" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;code&gt;drop&lt;/code&gt; is called&lt;/em&gt;. Memory can be invalidated by deallocation, but also by replacing a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, or calling &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt;&lt;code&gt;Vec::set_len&lt;/code&gt;&lt;/a&gt; to &quot;kill&quot; some elements off of a vector. It can be repurposed by using &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;ptr::write&lt;/code&gt;&lt;/a&gt; to overwrite it without calling the destructor first.</source>
          <target state="translated">固定的目的是能够依靠某些数据在内存中的放置。为了使这项工作有效，不仅限制了移动数据，还限制了数据的传输。限制用于存储数据的内存的重新分配，重新利用或以其他方式使之无效。具体来说，对于固定的数据，您必须保持不变，即&lt;em&gt;从固定数据直到调用 &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt;，&lt;em&gt;其内存都不会失效或重新利用&lt;/em&gt;。存储器可以由解除分配被无效，而且通过更换&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt;由&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，或调用&lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt; &lt;code&gt;Vec::set_len&lt;/code&gt; &lt;/a&gt; &amp;ldquo;杀死&amp;rdquo;一些元件断开的载体。可以通过使用&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;ptr::write&lt;/code&gt; &lt;/a&gt;来重新设置它的用途，而无需先调用析构函数。</target>
        </trans-unit>
        <trans-unit id="dadde1acddaa4f2663e0f0f8fe2f53b8bd256d16" translate="yes" xml:space="preserve">
          <source>The purpose of these &lt;code&gt;Result&lt;/code&gt; types is to encode error-handling information. Values of the &lt;code&gt;Result&lt;/code&gt; type, like values of any type, have methods defined on them. An instance of &lt;code&gt;io::Result&lt;/code&gt; has an &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; method&lt;/a&gt; that you can call. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Err&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will cause the program to crash and display the message that you passed as an argument to &lt;code&gt;expect&lt;/code&gt;. If the &lt;code&gt;read_line&lt;/code&gt; method returns an &lt;code&gt;Err&lt;/code&gt;, it would likely be the result of an error coming from the underlying operating system. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will take the return value that &lt;code&gt;Ok&lt;/code&gt; is holding and return just that value to you so you can use it. In this case, that value is the number of bytes in what the user entered into standard input.</source>
          <target state="translated">这些 &lt;code&gt;Result&lt;/code&gt; 类型的目的是对错误处理信息进行编码。的值 &lt;code&gt;Result&lt;/code&gt; 类型，像任何类型的值，都方法对它们限定。 &lt;code&gt;io::Result&lt;/code&gt; 的实例具有您可以调用的&lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt; &lt;code&gt;expect&lt;/code&gt; 方法&lt;/a&gt;。如果这种情况下 &lt;code&gt;io::Result&lt;/code&gt; 是 &lt;code&gt;Err&lt;/code&gt; 值， &lt;code&gt;expect&lt;/code&gt; 将导致程序崩溃，并显示您作为参数传递给传递的消息 &lt;code&gt;expect&lt;/code&gt; 。如果 &lt;code&gt;read_line&lt;/code&gt; 方法返回 &lt;code&gt;Err&lt;/code&gt; ，则可能是来自底层操作系统的错误的结果。如果此 &lt;code&gt;io::Result&lt;/code&gt; 实例是一个 &lt;code&gt;Ok&lt;/code&gt; 值， &lt;code&gt;expect&lt;/code&gt; 将取 &lt;code&gt;Ok&lt;/code&gt; 持有的返回值，并将该值仅返回给您，以便您可以使用它。在这种情况下，该值是用户输入到标准输入中的字节数。</target>
        </trans-unit>
        <trans-unit id="17a957e4dd15537d9df26e9cd567ee8ac4ab9c24" translate="yes" xml:space="preserve">
          <source>The purpose of this example is to demonstrate a situation in which some generic parameters are declared with &lt;code&gt;impl&lt;/code&gt; and some are declared with the method definition. Here, the generic parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are declared after &lt;code&gt;impl&lt;/code&gt;, because they go with the struct definition. The generic parameters &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; are declared after &lt;code&gt;fn mixup&lt;/code&gt;, because they&amp;rsquo;re only relevant to the method.</source>
          <target state="translated">本示例的目的是演示一种情况，其中某些通用参数用 &lt;code&gt;impl&lt;/code&gt; 声明，而某些则用方法定义声明。此处，通用参数 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 在 &lt;code&gt;impl&lt;/code&gt; 之后声明，因为它们与struct定义一起使用。通用参数 &lt;code&gt;V&lt;/code&gt; 和 &lt;code&gt;W&lt;/code&gt; 在 &lt;code&gt;fn mixup&lt;/code&gt; 之后声明，因为它们仅与方法有关。</target>
        </trans-unit>
        <trans-unit id="83464f6d897f3cf3890af3a243744932372ed118" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to alleviate imports of many common I/O traits by adding a glob import to the top of I/O heavy modules:</source>
          <target state="translated">这个模块的目的是通过在I/O重度模块的顶部增加一个glob导入,来缓解很多常见的I/O特性的导入。</target>
        </trans-unit>
        <trans-unit id="c5176304cb4e1480563977bff5f9fc8f29f52bf7" translate="yes" xml:space="preserve">
          <source>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis.</source>
          <target state="translated">特质对象的目的是允许方法的 &quot;后期绑定&quot;。调用特质对象上的方法会在运行时导致虚拟调度:即从特质对象vtable中加载一个函数指针并间接调用。每个vtable条目的实际实现可以因对象而异。</target>
        </trans-unit>
        <trans-unit id="f15fea39e76fdfafefd43bfce074d20361154e36" translate="yes" xml:space="preserve">
          <source>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn&amp;rsquo;t working as expected. You&amp;rsquo;ll put unit tests in the &lt;em&gt;src&lt;/em&gt; directory in each file with the code that they&amp;rsquo;re testing. The convention is to create a module named &lt;code&gt;tests&lt;/code&gt; in each file to contain the test functions and to annotate the module with &lt;code&gt;cfg(test)&lt;/code&gt;.</source>
          <target state="translated">单元测试的目的是与其余代码隔离地测试每个代码单元，以快速查明代码在哪里正常工作和不正常工作。您将使用它们正在测试的代码将单元测试放在每个文件的&lt;em&gt;src&lt;/em&gt;目录中。约定是在每个文件中创建一个名为 &lt;code&gt;tests&lt;/code&gt; 的模块以包含测试功能，并使用 &lt;code&gt;cfg(test)&lt;/code&gt; 对该模块进行注释。</target>
        </trans-unit>
        <trans-unit id="60cba1f37e61726b832a14d7f1500e4426e9a5cc" translate="yes" xml:space="preserve">
          <source>The question mark operator</source>
          <target state="translated">问号运算符</target>
        </trans-unit>
        <trans-unit id="018537889ded2ab112f094946b8612c9a86b99ba" translate="yes" xml:space="preserve">
          <source>The question mark operator (&lt;code&gt;?&lt;/code&gt;) unwraps valid values or returns erroneous values, propagating them to the calling function. It is a unary postfix operator that can only be applied to the types &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">问号运算符（ &lt;code&gt;?&lt;/code&gt; ）取消包装有效值或返回错误值，将其传播到调用函数。它是一元后缀运算符，只能应用于 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ea5d63d0d5a319dd6d9072a4460aea03a494584" translate="yes" xml:space="preserve">
          <source>The question mark operator, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">问号运算符， &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61208bdae8b221a09aba4f839d74c11c2925c51c" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f32&lt;/code&gt; 内部表示形式的基数或基数。</target>
        </trans-unit>
        <trans-unit id="ea313a35fa236b37b46428fb2657491b2e33dea3" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f32::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;f32&lt;/code&gt; 的内部表示形式的基数或基数。使用&lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt; &lt;code&gt;f32::RADIX&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="fc170d8fddda3392ca3bbfeb02d09cfb7f6a80ce" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; 内部表示形式的基数或基数。</target>
        </trans-unit>
        <trans-unit id="eb77af93de4b13de0ebcbd9266a033e54a3960fe" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f64::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; 内部表示形式的基数或基数。使用&lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt; &lt;code&gt;f64::RADIX&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="0b9457bd197a286afc52dbcebb942e61605b222d" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;start &amp;lt;= x &amp;lt; end&lt;/code&gt;. It is empty if &lt;code&gt;start &amp;gt;= end&lt;/code&gt;.</source>
          <target state="translated">范围 &lt;code&gt;start..end&lt;/code&gt; 包含所有 &lt;code&gt;start &amp;lt;= x &amp;lt; end&lt;/code&gt; 。如果 &lt;code&gt;start &amp;gt;= end&lt;/code&gt; ，则为空。</target>
        </trans-unit>
        <trans-unit id="510a943d569cb4f1080072d01ababcb91699bcc6" translate="yes" xml:space="preserve">
          <source>The range is empty if either side is incomparable:</source>
          <target state="translated">如果任何一方不可比拟,则该范围为空。</target>
        </trans-unit>
        <trans-unit id="a7d43b8cf204eefd21645fceff96d69cfb297982" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="translated">原始指针必须事先已通过调用&lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;U&lt;/code&gt; 必须具有与 &lt;code&gt;T&lt;/code&gt; 相同的大小和对齐方式。如果 &lt;code&gt;U&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; ,这确实是正确的。请注意，如果 &lt;code&gt;U&lt;/code&gt; 不是 &lt;code&gt;T&lt;/code&gt; ,但具有相同的大小和对齐方式，则基本上就像改变类型的引用一样。有关此情况下适用的限制的更多信息，请参见&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;mem::transmute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a2067413bc1879d44bf7542436c24e1555ca1bc" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="translated">原始指针必须事先已通过调用&lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;U&lt;/code&gt; 必须具有与 &lt;code&gt;T&lt;/code&gt; 相同的大小和对齐方式。如果 &lt;code&gt;U&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; ,这确实是正确的。请注意，如果 &lt;code&gt;U&lt;/code&gt; 不是 &lt;code&gt;T&lt;/code&gt; ,但具有相同的大小和对齐方式，则基本上就像改变类型的引用一样。有关此情况下适用的限制的更多信息，请参见&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;mem::transmute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cc134868dea70688318900dea4fb56c096c2fce" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">原始指针必须事先已通过调用&lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc::into_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb442a6e9f4c3ea3ad88f7d20cbb90e50f086583" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">原始指针必须事先已通过调用&lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc::into_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61edb86c6e775bcbcc090bf0b2354d8086752aee" translate="yes" xml:space="preserve">
          <source>The re-ordering prevented by the different ordering semantics are:</source>
          <target state="translated">不同的排序语义所阻止的重新排序是:。</target>
        </trans-unit>
        <trans-unit id="db75fd7d163698847a2930407a821664ef9dc7a1" translate="yes" xml:space="preserve">
          <source>The reading portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;的读取部分应关闭。</target>
        </trans-unit>
        <trans-unit id="bb2e18a8faa1f91810d19956a7143af41d8b7e9f" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">弃用的原因是该函数基本上不能正确使用：&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;Rust编译器假定&lt;/a&gt;值已正确初始化。结果，调用例如 &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; 会导致立即不确定的行为，以返回肯定不是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的 &lt;code&gt;bool&lt;/code&gt; 。更糟糕的是，真正的未初始化内存（如此处返回的内存）的特殊之处在于，编译器知道它没有固定的值。这使在变量中具有未初始化的数据成为不确定的行为，即使该变量具有整数类型也是如此。 （请注意，关于未初始化整数的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。）</target>
        </trans-unit>
        <trans-unit id="0a840dd2de2cd2ee34a26f979453151250b4e843" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: it has the same effect as &lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt;&lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt;&lt;/a&gt;. As the &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt; documentation&lt;/a&gt; explains, &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">弃用的原因是该函数基本上不能正确使用：它具有与&lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt; &lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt; &lt;/a&gt;相同的作用。正如&lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; 文档&lt;/a&gt;解释的那样，&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;Rust编译器假定&lt;/a&gt;值已正确初始化。结果，调用例如 &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; 会导致立即不确定的行为，以返回肯定不是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的 &lt;code&gt;bool&lt;/code&gt; 。更糟糕的是，真正的未初始化内存（如此处返回的内存）的特殊之处在于，编译器知道它没有固定的值。这使得在变量中具有未初始化的数据成为不确定的行为，即使该变量具有整数类型也是如此。 （请注意，关于未初始化整数的规则尚未最终确定，但建议在未完成之前避免使用它们。）</target>
        </trans-unit>
        <trans-unit id="d5d0c9e3177e947296d0e4cad464419f6391db88" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;rlib&lt;/code&gt; files do not contain any of their upstream dependencies. It wouldn't be very efficient for all &lt;code&gt;rlib&lt;/code&gt; files to contain a copy of &lt;code&gt;libstd.rlib&lt;/code&gt;!</source>
          <target state="translated">原因是 &lt;code&gt;rlib&lt;/code&gt; 文件不包含任何上游依赖项。所有 &lt;code&gt;rlib&lt;/code&gt; 文件都包含 &lt;code&gt;libstd.rlib&lt;/code&gt; 的副本并不是非常有效！</target>
        </trans-unit>
        <trans-unit id="f95aa7105ee4000143fc92462b837053383a52a0" translate="yes" xml:space="preserve">
          <source>The reason for this is that there are two appearances of type parameter &lt;code&gt;T&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; header, both as parameters for &lt;code&gt;ForeignTrait2&lt;/code&gt;. The first appearance is uncovered, and so runs afoul of the orphan rule.</source>
          <target state="translated">这是因为在 &lt;code&gt;impl&lt;/code&gt; 标头中出现了两种类型的参数 &lt;code&gt;T&lt;/code&gt; ，它们都是 &lt;code&gt;ForeignTrait2&lt;/code&gt; 的参数。首次露面是未发现的，因此与孤立规则不符。</target>
        </trans-unit>
        <trans-unit id="ef37c27a4f0dd2645ce86c85a75eac6a77fa29d9" translate="yes" xml:space="preserve">
          <source>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there&amp;rsquo;s no reason we would want to prevent &lt;code&gt;x&lt;/code&gt; from being valid after we create the variable &lt;code&gt;y&lt;/code&gt;. In other words, there&amp;rsquo;s no difference between deep and shallow copying here, so calling &lt;code&gt;clone&lt;/code&gt; wouldn&amp;rsquo;t do anything different from the usual shallow copying and we can leave it out.</source>
          <target state="translated">原因是诸如在编译时具有已知大小的整数之类的类型完全存储在堆栈中，因此可以快速创建实际值的副本。这意味着在创建变量 &lt;code&gt;y&lt;/code&gt; 之后我们没有理由要阻止 &lt;code&gt;x&lt;/code&gt; 有效。换句话说，这里的深层复制和浅层复制没有区别，因此调用 &lt;code&gt;clone&lt;/code&gt; 与通常的浅层复制没有什么不同，我们可以省去它。</target>
        </trans-unit>
        <trans-unit id="5c1ca57165d895e7b5a9a07fb8f81dd8e653560f" translate="yes" xml:space="preserve">
          <source>The reason is that you&amp;rsquo;re missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. To rectify this error, you need to include this information in the &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">原因是您缺少一些关键信息：需要描述和许可证，以便人们知道您的板条箱做什么以及可以使用哪些条款。要纠正此错误，您需要在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中包括此信息。</target>
        </trans-unit>
        <trans-unit id="87dec969a1d8a7fd52229930c681793b58499b7c" translate="yes" xml:space="preserve">
          <source>The reason is that, in the first example, there are many possible types that &lt;code&gt;!&lt;/code&gt; could coerce to, because many types implement &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt;. However, in the second example, the &lt;code&gt;else&lt;/code&gt; branch returns a &lt;code&gt;0&lt;/code&gt;, which the compiler infers from the return type to be of type &lt;code&gt;u32&lt;/code&gt;. Since &lt;code&gt;u32&lt;/code&gt; is a concrete type, &lt;code&gt;!&lt;/code&gt; can and will be coerced to it. See issue &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;#36375&lt;/a&gt; for more information on this quirk of &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">原因是，在第一个示例中，有许多可能的类型 &lt;code&gt;!&lt;/code&gt; 可能会强制执行，因为许多类型都实现了 &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt; 。但是，在第二个示例中， &lt;code&gt;else&lt;/code&gt; 分支返回 &lt;code&gt;0&lt;/code&gt; ，编译器从返回类型推断出该类型为 &lt;code&gt;u32&lt;/code&gt; 类型。由于 &lt;code&gt;u32&lt;/code&gt; 是具体类型，所以 &lt;code&gt;!&lt;/code&gt; 可以而且将会被强迫。有关此怪癖的更多信息，请参见问题&lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;＃36375 &lt;/a&gt; &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="725753993f38910ecfb713203cf3afe96ff590f2" translate="yes" xml:space="preserve">
          <source>The reason that this matter is that the type &lt;code&gt;fn(S)&lt;/code&gt; is not specific to any particular function: it's a function &lt;em&gt;pointer&lt;/em&gt;. So calling &lt;code&gt;x()&lt;/code&gt; results in a virtual call, whereas &lt;code&gt;foo()&lt;/code&gt; is statically dispatched, because the type of &lt;code&gt;foo&lt;/code&gt; tells us precisely what function is being called.</source>
          <target state="translated">之所以如此，是因为 &lt;code&gt;fn(S)&lt;/code&gt; 类型不是特定于任何特定函数的：它是一个函数&lt;em&gt;指针&lt;/em&gt;。因此，调用 &lt;code&gt;x()&lt;/code&gt; 会导致虚拟调用，而 &lt;code&gt;foo()&lt;/code&gt; 是静态调度的，因为 &lt;code&gt;foo&lt;/code&gt; 的类型精确地告诉我们正在调用什么函数。</target>
        </trans-unit>
        <trans-unit id="2f71ddaa6e32a7d6efaff9da8a4ddd4766615cbe" translate="yes" xml:space="preserve">
          <source>The reason the &lt;code&gt;deref&lt;/code&gt; method returns a reference to a value, and that the plain dereference outside the parentheses in &lt;code&gt;*(y.deref())&lt;/code&gt; is still necessary, is the ownership system. If the &lt;code&gt;deref&lt;/code&gt; method returned the value directly instead of a reference to the value, the value would be moved out of &lt;code&gt;self&lt;/code&gt;. We don&amp;rsquo;t want to take ownership of the inner value inside &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in this case or in most cases where we use the dereference operator.</source>
          <target state="translated">所有权制度是 &lt;code&gt;deref&lt;/code&gt; 方法返回对值的引用，并且仍需要在 &lt;code&gt;*(y.deref())&lt;/code&gt; 括号外进行普通取消引用的原因。如果 &lt;code&gt;deref&lt;/code&gt; 方法直接返回该值而不是对该值的引用，则该值将移出 &lt;code&gt;self&lt;/code&gt; 。在这种情况下，或者在大多数情况下，我们使用解引用运算符时，我们都不希望拥有 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 中内部值的所有权。</target>
        </trans-unit>
        <trans-unit id="1d62bb1a32655921533dae07c7931836afe25a19" translate="yes" xml:space="preserve">
          <source>The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn&amp;rsquo;t have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:</source>
          <target state="translated">此函数在没有生命周期注释的情况下进行编译的原因是历史悠久的：在Rust的早期版本（1.0之前的版本）中，由于每个引用都需要明确的生命周期，因此不会编译该代码。那时，函数签名应如下所示：</target>
        </trans-unit>
        <trans-unit id="bedb5e3116e5d92919b43a452878e5db1b96099b" translate="yes" xml:space="preserve">
          <source>The reason we&amp;rsquo;re able to use &lt;code&gt;&amp;amp;s2&lt;/code&gt; in the call to &lt;code&gt;add&lt;/code&gt; is that the compiler can &lt;em&gt;coerce&lt;/em&gt; the &lt;code&gt;&amp;amp;String&lt;/code&gt; argument into a &lt;code&gt;&amp;amp;str&lt;/code&gt;. When we call the &lt;code&gt;add&lt;/code&gt; method, Rust uses a &lt;em&gt;deref coercion&lt;/em&gt;, which here turns &lt;code&gt;&amp;amp;s2&lt;/code&gt; into &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt;. We&amp;rsquo;ll discuss deref coercion in more depth in Chapter 15. Because &lt;code&gt;add&lt;/code&gt; does not take ownership of the &lt;code&gt;s&lt;/code&gt; parameter, &lt;code&gt;s2&lt;/code&gt; will still be a valid &lt;code&gt;String&lt;/code&gt; after this operation.</source>
          <target state="translated">我们能够在 &lt;code&gt;add&lt;/code&gt; 调用中使用 &lt;code&gt;&amp;amp;s2&lt;/code&gt; 的原因是，编译器可以将 &lt;code&gt;&amp;amp;String&lt;/code&gt; 参数&lt;em&gt;强制&lt;/em&gt;转换为 &lt;code&gt;&amp;amp;str&lt;/code&gt; 。当我们调用 &lt;code&gt;add&lt;/code&gt; 方法时，Rust使用了&lt;em&gt;deref强制&lt;/em&gt;，这会将 &lt;code&gt;&amp;amp;s2&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt; 。我们将在第15章中更深入地讨论deref强制。由于 &lt;code&gt;add&lt;/code&gt; 不拥有 &lt;code&gt;s&lt;/code&gt; 参数的所有权，因此 &lt;code&gt;s2&lt;/code&gt; 在此操作之后仍将是有效的 &lt;code&gt;String&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f3cfdfa90a10325648e4c2eb952b413419929140" translate="yes" xml:space="preserve">
          <source>The receiver of a method, or the current module.</source>
          <target state="translated">方法的接受者,或当前模块。</target>
        </trans-unit>
        <trans-unit id="d73164a885c270ed79f7ee9c783984160bde564d" translate="yes" xml:space="preserve">
          <source>The receiving end of a channel has two useful methods: &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;try_recv&lt;/code&gt;. We&amp;rsquo;re using &lt;code&gt;recv&lt;/code&gt;, short for &lt;em&gt;receive&lt;/em&gt;, which will block the main thread&amp;rsquo;s execution and wait until a value is sent down the channel. Once a value is sent, &lt;code&gt;recv&lt;/code&gt; will return it in a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When the sending end of the channel closes, &lt;code&gt;recv&lt;/code&gt; will return an error to signal that no more values will be coming.</source>
          <target state="translated">通道的接收端有两个有用的方法： &lt;code&gt;recv&lt;/code&gt; 和 &lt;code&gt;try_recv&lt;/code&gt; 。我们正在使用 &lt;code&gt;recv&lt;/code&gt; ，它是&lt;em&gt;receive的&lt;/em&gt;缩写，它将阻塞主线程的执行，并等待一个值从通道发送出去。发送值后， &lt;code&gt;recv&lt;/code&gt; 将在 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 返回它。当通道的发送端关闭时， &lt;code&gt;recv&lt;/code&gt; 将返回一个错误，表示将不再有任何值。</target>
        </trans-unit>
        <trans-unit id="bb4caae3b66529c5330d18c3a08329f2bc2f3deb" translate="yes" xml:space="preserve">
          <source>The receiving half of Rust's &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) type. This half can only be owned by one thread.</source>
          <target state="translated">Rust的&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;（或&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;）类型的接收一半。这一半只能由一个线程拥有。</target>
        </trans-unit>
        <trans-unit id="6ebe525b659c768099f112d22bb95117877daf2e" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust drops the variable &lt;code&gt;b&lt;/code&gt;, which decreases the reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance from 2 to 1. The memory that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped at this point, because its reference count is 1, not 0. Then Rust drops &lt;code&gt;a&lt;/code&gt;, which decreases the reference count of the &lt;code&gt;a&lt;/code&gt;&lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance from 2 to 1 as well. This instance's memory can&amp;rsquo;t be dropped either, because the other &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance still refers to it. The memory allocated to the list will remain uncollected forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">所述的引用计数 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在这两种情况下 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是2后，我们在改变列表 &lt;code&gt;a&lt;/code&gt; 至点 &lt;code&gt;b&lt;/code&gt; 。在 &lt;code&gt;main&lt;/code&gt; 的末尾，Rust删除了变量 &lt;code&gt;b&lt;/code&gt; ，这将 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 实例的引用计数从2减少到 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在堆上的内存此时将不会被删除，因为它的引用计数是1，而不是0。然后Rust删除 &lt;code&gt;a&lt;/code&gt; ，这也会 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 实例的引用计数也从2减少到1。该实例的内存也不能被删除，因为另一个 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 实例仍然引用它。分配给列表的内存将永远保持未收集状态。为了可视化此参考周期，我们在图15-4中创建了一个图表。</target>
        </trans-unit>
        <trans-unit id="8b2bfb185407e4c60c25d227a4ff77b2cda29f86" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust will try to drop &lt;code&gt;b&lt;/code&gt; first, which will decrease the count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance in &lt;code&gt;b&lt;/code&gt; by 1.</source>
          <target state="translated">所述的引用计数 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在这两种情况下 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是2后，我们在改变列表 &lt;code&gt;a&lt;/code&gt; 至点 &lt;code&gt;b&lt;/code&gt; 。在年底 &lt;code&gt;main&lt;/code&gt; ，锈病将尝试下降 &lt;code&gt;b&lt;/code&gt; 第一，这将减少的计数 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 例如在 &lt;code&gt;b&lt;/code&gt; 1。</target>
        </trans-unit>
        <trans-unit id="ae6db410fc6a6a00a988df7e277d31526670b6dd" translate="yes" xml:space="preserve">
          <source>The reference to the moved key is provided so that cloning or copying the key is unnecessary, unlike with &lt;code&gt;.or_insert_with(|| ... )&lt;/code&gt;.</source>
          <target state="translated">提供对已移动密钥的引用，因此不需要克隆或复制密钥，这与 &lt;code&gt;.or_insert_with(|| ... )&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0309be91bd54044d4044342a0389163de0a934e4" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;src&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;dst&lt;/code&gt; with the same size.</source>
          <target state="translated">以 &lt;code&gt;src&lt;/code&gt; 开始且大小为 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 个字节的内存区域&lt;em&gt;不得&lt;/em&gt;与以 &lt;code&gt;dst&lt;/code&gt; 开始且大小相同的内存区域重叠。</target>
        </trans-unit>
        <trans-unit id="5dcc17f2dc1b8084d38071ff6ddcb2865d4ada36" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;x&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;y&lt;/code&gt; with the same size.</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 开始的内存区域，其大小为 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 个字节，&lt;em&gt;不得&lt;/em&gt;与从 &lt;code&gt;y&lt;/code&gt; 开始且大小相同的内存区域重叠。</target>
        </trans-unit>
        <trans-unit id="6e24cbd3ed4b7a19863f8c010bc7cecf513544b8" translate="yes" xml:space="preserve">
          <source>The relative order of partitioned items is not maintained.</source>
          <target state="translated">分割项的相对顺序不被保留。</target>
        </trans-unit>
        <trans-unit id="27d262cc92a6d55445ae1cc06ba8d24d6a4bfc8a" translate="yes" xml:space="preserve">
          <source>The relevant &lt;code&gt;use&lt;/code&gt; statements</source>
          <target state="translated">相关 &lt;code&gt;use&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="92055677c3977ae45c2e91b99d3cb2b7bc2e7a00" translate="yes" xml:space="preserve">
          <source>The remainder assignment operator &lt;code&gt;%=&lt;/code&gt;.</source>
          <target state="translated">其余的赋值运算符 &lt;code&gt;%=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e1e6181542061352f1920b8d99d81207a670f7f" translate="yes" xml:space="preserve">
          <source>The remainder from the division of two floats.</source>
          <target state="translated">两次浮动的除法所产生的余数。</target>
        </trans-unit>
        <trans-unit id="054039eee5819e5face98778f38bf1e0291c343e" translate="yes" xml:space="preserve">
          <source>The remainder has the same sign as the dividend and is computed as: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt;.</source>
          <target state="translated">余数与除数具有相同的符号，并计算为： &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5654d619adf6380504b572e1ea12d7691a4525f9" translate="yes" xml:space="preserve">
          <source>The remainder operator &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">余数运算符 &lt;code&gt;%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b313ceee14929f12b1b754da920f2c480594a9a" translate="yes" xml:space="preserve">
          <source>The remaining characters are alphanumeric or &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">其余字符为字母数字或 &lt;code&gt;_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db31fc17b3b16891bdde4b2e11c17a8b55001a20" translate="yes" xml:space="preserve">
          <source>The removed element is replaced by the last element of the vector.</source>
          <target state="translated">移除的元素被替换为向量的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="bdcb1bbcfc5506185f4dcdac6bb92b93d0ea27b3" translate="yes" xml:space="preserve">
          <source>The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the &lt;code&gt;$( $i:ident ),*&lt;/code&gt; example above matches &lt;code&gt;$i&lt;/code&gt; to all of the identifiers in the list.</source>
          <target state="translated">重复的片段会匹配并转录为指定数量的片段，并由分隔符分隔。元变量与其对应片段的每次重复都匹配。例如，上面的 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 示例将 &lt;code&gt;$i&lt;/code&gt; 与列表中的所有标识符匹配。</target>
        </trans-unit>
        <trans-unit id="12103d0e7fb92d8d3b9ddae239cdf39dea7eeb65" translate="yes" xml:space="preserve">
          <source>The repetition operators are:</source>
          <target state="translated">重复运算符是:</target>
        </trans-unit>
        <trans-unit id="bfcbf2851f89edd4f300f9b36ba95aadb203f98e" translate="yes" xml:space="preserve">
          <source>The representation does &lt;em&gt;not&lt;/em&gt; look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation &lt;code&gt;s2 = s1&lt;/code&gt; could be very expensive in terms of runtime performance if the data on the heap were large.</source>
          <target state="translated">表示不会&lt;em&gt;不会&lt;/em&gt;看起来像图4-3，这是记忆是什么样子，如果锈复制而不是堆的数据也是如此。如果Rust这样做，则如果堆上的数据很大，则操作 &lt;code&gt;s2 = s1&lt;/code&gt; 就运行时性能而言可能会非常昂贵。</target>
        </trans-unit>
        <trans-unit id="0b1df299f3611946c8ad866e3a9d4772fabb543c" translate="yes" xml:space="preserve">
          <source>The representation of a &lt;code&gt;repr(C)&lt;/code&gt; enum with fields is a &lt;code&gt;repr(C)&lt;/code&gt; struct with two fields, also called a &quot;tagged union&quot; in C:</source>
          <target state="translated">具有字段的 &lt;code&gt;repr(C)&lt;/code&gt; 枚举的表示形式是具有两个字段的 &lt;code&gt;repr(C)&lt;/code&gt; 结构，在C中也称为&amp;ldquo;标记联合&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="a3948c1d71b2273d20d352ff100e99a529e9f18b" translate="yes" xml:space="preserve">
          <source>The representation of a primitive representation enum is a &lt;code&gt;repr(C)&lt;/code&gt; union of &lt;code&gt;repr(C)&lt;/code&gt; structs for each variant with a field. The first field of each struct in the union is the primitive representation version of the enum with all fields removed (&quot;the tag&quot;) and the remaining fields are the fields of that variant.</source>
          <target state="translated">基本表示枚举的表示形式是具有字段的每个变量的 &lt;code&gt;repr(C)&lt;/code&gt; 结构的 &lt;code&gt;repr(C)&lt;/code&gt; 联合。联合中每个结构的第一个字段是枚举的原始表示形式，其中所有字段都已删除（&amp;ldquo;标记&amp;rdquo;），其余字段是该变体的字段。</target>
        </trans-unit>
        <trans-unit id="ef3b4092c2efea2b55e7548a736c3333a566aec1" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 这样的特征对象的表示形式。</target>
        </trans-unit>
        <trans-unit id="4110c125de481ad527206c93b01dbedc11c02bc7" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt;.</source>
          <target state="translated">诸如 &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; 之类的特征对象的表示形式。</target>
        </trans-unit>
        <trans-unit id="84fd9c512efc7dcedf9b018795fbba5c08fc5ad5" translate="yes" xml:space="preserve">
          <source>The representation of a type can be changed by applying the &lt;code&gt;repr&lt;/code&gt; attribute to it. The following example shows a struct with a &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">可以通过将 &lt;code&gt;repr&lt;/code&gt; 属性应用于类型来更改类型的表示形式。以下示例显示具有 &lt;code&gt;C&lt;/code&gt; 表示形式的结构。</target>
        </trans-unit>
        <trans-unit id="5a8aa6aa295a219e257360fdb9ca2113bb7bc323" translate="yes" xml:space="preserve">
          <source>The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a &lt;code&gt;C&lt;/code&gt; representation that contains a struct &lt;code&gt;Inner&lt;/code&gt; with the default representation will not change the layout of &lt;code&gt;Inner&lt;/code&gt;.</source>
          <target state="translated">类型的表示形式可以更改字段之间的填充，但不能更改字段本身的布局。例如，具有 &lt;code&gt;C&lt;/code&gt; 表示形式的结构包含具有默认表示形式的结构 &lt;code&gt;Inner&lt;/code&gt; 的结构不会更改 &lt;code&gt;Inner&lt;/code&gt; 的布局。</target>
        </trans-unit>
        <trans-unit id="8de668564b1808c69c7a252869635782239a849b" translate="yes" xml:space="preserve">
          <source>The representation semantics of floating-point numbers are described in &lt;a href=&quot;types/numeric&quot;&gt;&quot;Machine Types&quot;&lt;/a&gt;.</source>
          <target state="translated">浮点数的表示语义在&lt;a href=&quot;types/numeric&quot;&gt;&amp;ldquo;机器类型&amp;rdquo;中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="568b4d39b3d684710e1069cdb58107435b4ee105" translate="yes" xml:space="preserve">
          <source>The requested ABI is unsupported by the current target.</source>
          <target state="translated">请求的ABI不受当前目标的支持。</target>
        </trans-unit>
        <trans-unit id="6079a0a7d416189b9655a6ad531ff1787c361185" translate="yes" xml:space="preserve">
          <source>The required alignment of the referenced value.</source>
          <target state="translated">引用值的必要对齐方式。</target>
        </trans-unit>
        <trans-unit id="48f41ba31da382f1ab342b312f6ebecf708e0a4f" translate="yes" xml:space="preserve">
          <source>The required inputs are these:</source>
          <target state="translated">所需的投入是:</target>
        </trans-unit>
        <trans-unit id="f6ffffcc1dc56ad2b07c96ba04b8dfcf628fd050" translate="yes" xml:space="preserve">
          <source>The requirements for this program haven&amp;rsquo;t been agreed upon yet, and we&amp;rsquo;re pretty sure the &lt;code&gt;Hello&lt;/code&gt; text at the beginning of the greeting will change. We decided we don&amp;rsquo;t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the &lt;code&gt;greeting&lt;/code&gt; function, we&amp;rsquo;ll just assert that the output contains the text of the input parameter.</source>
          <target state="translated">该程序的要求尚未达成共识，我们非常确定问候语开头的 &lt;code&gt;Hello&lt;/code&gt; 文本会更改。我们决定不需要更改需求时就更新测试，因此，我们只断言输出包含输入参数的文本，而不是检查与 &lt;code&gt;greeting&lt;/code&gt; 函数返回的值是否完全相同。</target>
        </trans-unit>
        <trans-unit id="0cbf837e1937a12c606036644e82391851dc8756" translate="yes" xml:space="preserve">
          <source>The responsibilities that remain in the &lt;code&gt;main&lt;/code&gt; function after this process should be limited to the following:</source>
          <target state="translated">在此过程之后，保留在 &lt;code&gt;main&lt;/code&gt; 职能中的职责应限于以下各项：</target>
        </trans-unit>
        <trans-unit id="fb88378aaf4cdd384feeec625a8c476a227f1fe6" translate="yes" xml:space="preserve">
          <source>The rest of the traits defined in the standard library can&amp;rsquo;t be implemented on your types using &lt;code&gt;derive&lt;/code&gt;. These traits don&amp;rsquo;t have sensible default behavior, so it&amp;rsquo;s up to you to implement them in the way that makes sense for what you&amp;rsquo;re trying to accomplish.</source>
          <target state="translated">标准库中定义的其余特征不能使用 &lt;code&gt;derive&lt;/code&gt; 在您的类型上实现。这些特征没有明智的默认行为，因此取决于您要实现的目标，取决于您如何实施它们。</target>
        </trans-unit>
        <trans-unit id="3a3c86e891d6ad8a6d17dd1936fd9bfccb1b62f4" translate="yes" xml:space="preserve">
          <source>The rest of this book uses commands that work in both &lt;em&gt;cmd.exe&lt;/em&gt; and PowerShell. If there are specific differences, we&amp;rsquo;ll explain which to use.</source>
          <target state="translated">本书的其余部分使用在&lt;em&gt;cmd.exe&lt;/em&gt;和PowerShell 中均可使用的命令。如果有特定差异，我们将说明使用哪个。</target>
        </trans-unit>
        <trans-unit id="00dd9e9169ec993decc3de54bbe98c364e0e7806" translate="yes" xml:space="preserve">
          <source>The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.</source>
          <target state="translated">这个箱子文档的其余部分专门指出了Rust标准库的显著特征。</target>
        </trans-unit>
        <trans-unit id="ac1c550b13307d7f1181fa4746cc5e5943901d94" translate="yes" xml:space="preserve">
          <source>The rest pattern is always irrefutable.</source>
          <target state="translated">休息模式总是无可辩驳的。</target>
        </trans-unit>
        <trans-unit id="b0cd0ab16fb284f9bcdd09aeae886a98592a2f2d" translate="yes" xml:space="preserve">
          <source>The result can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;.</source>
          <target state="translated">结果可以转换为任何类型的指针。强制转换为 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 时，确保访问是唯一的（无活动引用，是否可变），并确保转换为 &lt;code&gt;&amp;amp;T&lt;/code&gt; 时不存在任何突变或可变别名。</target>
        </trans-unit>
        <trans-unit id="c54e546283bfd6f5bb35e08c8e91500e43fa3efb" translate="yes" xml:space="preserve">
          <source>The result is allocated on the heap.</source>
          <target state="translated">结果被分配到堆上。</target>
        </trans-unit>
        <trans-unit id="9f60835a1f670fd1068b73e7310483f7414303f8" translate="yes" xml:space="preserve">
          <source>The result may not be correctly rounded owing to implementation details; &lt;code&gt;self.log2()&lt;/code&gt; can produce more accurate results for base 2, and &lt;code&gt;self.log10()&lt;/code&gt; can produce more accurate results for base 10.</source>
          <target state="translated">由于实施细节，结果可能无法正确舍入； &lt;code&gt;self.log2()&lt;/code&gt; 可以为基数2产生更准确的结果， &lt;code&gt;self.log10()&lt;/code&gt; 可以为基数10产生更准确的结果。</target>
        </trans-unit>
        <trans-unit id="c4dbebfb961a1bddcfad953b06a027b749fbba28" translate="yes" xml:space="preserve">
          <source>The result of &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; an expression with type &lt;a href=&quot;../std/boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and that can also be moved out of.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;取消引用&lt;/a&gt;类型为&lt;a href=&quot;../std/boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;的表达式的结果，也可以将其移出。</target>
        </trans-unit>
        <trans-unit id="fe2526308745be82b19ed557143eb06c9172e9c2" translate="yes" xml:space="preserve">
          <source>The result of a generator resumption.</source>
          <target state="translated">发电机复产的结果。</target>
        </trans-unit>
        <trans-unit id="d471d20c06ef14c004fab8262f7528514deaa1c4" translate="yes" xml:space="preserve">
          <source>The result of casting a reference to a pointer is valid for as long as the underlying object is live and no reference (just raw pointers) is used to access the same memory.</source>
          <target state="translated">只要底层对象是活的,并且没有使用任何引用(只是原始指针)来访问相同的内存,那么对指针的引用的铸造结果就有效。</target>
        </trans-unit>
        <trans-unit id="ac56fae426229e4d543dba38661557fbee8bb52d" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing with formatting strings.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;的结果！宏是&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;类型的值。然后可以将此结构传递给该模块内部的&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;函数，以便处理格式字符串。该宏的目标是在处理格式化字符串时甚至进一步防止中间分配。</target>
        </trans-unit>
        <trans-unit id="31cd246d6c4827dc128a4e9ac189ceccd07f4e85" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;的结果！宏是&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;类型的值。然后可以将此结构传递给该模块内部的&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;函数，以便处理格式字符串。该宏的目标是在处理格式字符串时甚至进一步防止中间分配。</target>
        </trans-unit>
        <trans-unit id="1c32345d3d6f612f235d03a8cd84044465cbfeea" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt;.</source>
          <target state="translated">结果将代表IP地址 &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99c7c63b15fc6ea4f165265a5fd114fc5db86d31" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;b&lt;/code&gt;.&lt;code&gt;c&lt;/code&gt;.&lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">结果将代表IP地址 &lt;code&gt;a&lt;/code&gt; 。 &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;c&lt;/code&gt; 。 &lt;code&gt;d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7373e6f7caa0a9dff8d78cf60558cf221157bd80" translate="yes" xml:space="preserve">
          <source>The resulting layout will be the same as that of a C struct containing two fields with the layouts of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in that order.</source>
          <target state="translated">生成的布局将与包含两个字段的C结构相同，该两个字段具有 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 的布局。</target>
        </trans-unit>
        <trans-unit id="99a0997f56bdadd8bd20428a4a2ef3bbae789fac" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">最终的生命周期与自我绑定，因此它的行为&amp;ldquo;好像&amp;rdquo;实际上是被借用的T的实例。如果需要更长的时间（未绑定），请使用 &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f78e2e736259493757a0ced96e6b992b486267c6" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">最终的生命周期与自我绑定，因此它的行为&amp;ldquo;好像&amp;rdquo;实际上是被借用的T的实例。如果需要更长的（未绑定）生存期，请使用 &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9220ca335fae6d1972b4901944a1126d0f38ae8e" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;).</source>
          <target state="translated">生成的指针不必在范围之内，但是取消引用有潜在的危险（这需要 &lt;code&gt;unsafe&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="81b4f59283eb3ce773831a86dd58d26e19da85b4" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;). In particular, the resulting pointer may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object than the one &lt;code&gt;self&lt;/code&gt; points to. In other words, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">生成的指针不必在范围之内，但是取消引用有潜在的危险（这需要 &lt;code&gt;unsafe&lt;/code&gt; ）。特别是，所得的指针可能&lt;em&gt;无法&lt;/em&gt;用于访问一个 &lt;code&gt;self&lt;/code&gt; 指向的不同的已分配对象。换句话说， &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;一样 &lt;code&gt;y&lt;/code&gt; ，和解除引用它是未定义的行为，除非 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 点到同一分配对象。</target>
        </trans-unit>
        <trans-unit id="52dcba8fc55d983793d49be111c09fcb50eb3b76" translate="yes" xml:space="preserve">
          <source>The resulting pointer will have provenance of &lt;code&gt;val&lt;/code&gt;, i.e., for a fat pointer, this operation is semantically the same as creating a new fat pointer with the data pointer value of &lt;code&gt;val&lt;/code&gt; but the metadata of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">所得的指针将具有 &lt;code&gt;val&lt;/code&gt; 的出处，即对于胖指针，此操作在语义上与使用 &lt;code&gt;val&lt;/code&gt; 的数据指针值但 &lt;code&gt;self&lt;/code&gt; 的元数据创建新的胖指针相同。</target>
        </trans-unit>
        <trans-unit id="277fa9ca5234a7d85c4310d360b586b5679536d7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;!&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;!&lt;/code&gt; 之后的结果类型 操作员。</target>
        </trans-unit>
        <trans-unit id="e0fff7e85f4e0422c5e3edd89994815fd0fa33fe" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;%&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="bb2df529c05fcb3e3ae1db4ab5bf5c9f054fbf92" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="36522abccd158f4a83c30f6cbe7b1f733a467a76" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="1fe31e03010cc02b7a70dec74838acc1bf92f653" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 操作符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="49f0b7e4d4d9571dc029b144b407d2d00db70bde" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;*&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;*&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="5440b4202f92f92a6ad5f44ab02bb1836dc990f2" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;+&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="4a8bf360ec637ebc225332beb0f574739bca97a7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;-&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;-&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="541f705e1fd40afef0d79bd7f0f4268fa7398a27" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;/&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;/&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="5fff5e225b75cdf382af9bb7542d50be9c4363ed" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;^&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;^&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="fee8ba95ad793c2c7dda2e8911dcb02800ab8ed4" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;|&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;|&lt;/code&gt; 后的结果类型 操作员。</target>
        </trans-unit>
        <trans-unit id="0473503cf115b2a975e15da3f35244db7bce3d66" translate="yes" xml:space="preserve">
          <source>The resulting type after concatenation</source>
          <target state="translated">连接后的类型</target>
        </trans-unit>
        <trans-unit id="dbf5bd29abfe066aae072317675dfaca543c15fe" translate="yes" xml:space="preserve">
          <source>The resulting type after dereferencing.</source>
          <target state="translated">解除引用后的结果类型。</target>
        </trans-unit>
        <trans-unit id="76a4c8bb9eba17c026c554fa00db407a4ed92a09" translate="yes" xml:space="preserve">
          <source>The resulting type after obtaining ownership.</source>
          <target state="translated">获得所有权后产生的类型。</target>
        </trans-unit>
        <trans-unit id="04c53e531d342d2fc7cb2f6812bb0980d9b695cc" translate="yes" xml:space="preserve">
          <source>The resulting vector can be converted back into a box via &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;'s &lt;code&gt;into_boxed_slice&lt;/code&gt; method.</source>
          <target state="translated">可以通过 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的 &lt;code&gt;into_boxed_slice&lt;/code&gt; 方法将生成的向量转换回盒子。</target>
        </trans-unit>
        <trans-unit id="c631dfaa5b94e5b7afa0d3baba880ecf32c3c788" translate="yes" xml:space="preserve">
          <source>The return type in the desugaring is assumed to capture all lifetime parameters from the &lt;code&gt;async fn&lt;/code&gt; declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">假定在废止中的返回类型是从 &lt;code&gt;async fn&lt;/code&gt; 声明中捕获所有生存期参数。这可以在上面经过反复讨论的示例中看到，该示例显式地超过了生存期，因此捕获了 &lt;code&gt;'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b3c91f66fb428df18fd8a3b968cf270fb22e4f6" translate="yes" xml:space="preserve">
          <source>The return type isn&amp;rsquo;t &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">返回类型不是 &lt;code&gt;Self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87f17fcd6dd95b0936e246de85107f7f76aa4067" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt;&lt;code&gt;str::escape_debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt; &lt;code&gt;str::escape_debug&lt;/code&gt; &lt;/a&gt;的返回类型。</target>
        </trans-unit>
        <trans-unit id="db39743b7e18afb4b0cbc402d05c64c31d6c2284" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt;&lt;code&gt;str::escape_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt; &lt;code&gt;str::escape_default&lt;/code&gt; &lt;/a&gt;的返回类型。</target>
        </trans-unit>
        <trans-unit id="0d7f1d5c28f55e7c46b28c80bf7c947a04177ba0" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt;&lt;code&gt;str::escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt; &lt;code&gt;str::escape_unicode&lt;/code&gt; &lt;/a&gt;的返回类型。</target>
        </trans-unit>
        <trans-unit id="46984a9d3d93237d6af0b4171b9091187f1fd40f" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;read_input()&lt;/code&gt;, &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt;&lt;/a&gt;, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">的返回类型 &lt;code&gt;read_input()&lt;/code&gt; ，&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt; &lt;/a&gt;，是它没有一个&amp;ldquo;真实&amp;rdquo;的返回值，但又希望，如果他们碰巧返回错误的函数的很常见的类型。在这种情况下，此函数的唯一目的是读取并打印该行，因此我们使用 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc8688a274902ed01a0ecc5033bf35069d5bb391" translate="yes" xml:space="preserve">
          <source>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">返回值是指示是否写入了新值并包含先前值的结果。成功时，保证该值等于 &lt;code&gt;current&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b1ea39b856b2d5fee30e6b97044d7752b536c14" translate="yes" xml:space="preserve">
          <source>The return value is always the previous value. If it is equal to &lt;code&gt;current&lt;/code&gt;, then the value was updated.</source>
          <target state="translated">返回值始终是先前的值。如果等于 &lt;code&gt;current&lt;/code&gt; ，那么值已更新。</target>
        </trans-unit>
        <trans-unit id="fc0a38af017feefeb9d3ecc2b64620f7588f7e32" translate="yes" xml:space="preserve">
          <source>The return value may change depending on the compiler version and unsafe code may not rely on the result of this function for soundness. It is suggested to only use this function for performance optimizations where spurious &lt;code&gt;false&lt;/code&gt; return values by this function do not affect the outcome, but just the performance. The consequences of using this method to make runtime and compile-time code behave differently have not been explored. This method should not be used to introduce such differences, and it should also not be stabilized before we have a better understanding of this issue.</source>
          <target state="translated">返回值可能会有所不同，具体取决于编译器版本，并且不安全的代码可能不依赖于此函数的结果是否健全。建议仅将此函数用于性能优化，在此情况下，此函数的虚假 &lt;code&gt;false&lt;/code&gt; 返回值不会影响结果，而只会影响性能。尚未探讨使用此方法使运行时和编译时代码表现不同的后果。不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使该方法变得稳定。</target>
        </trans-unit>
        <trans-unit id="8bec0cf03017a322224afce0dc723c8da3b1c3f8" translate="yes" xml:space="preserve">
          <source>The return value of this function has no meaning if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">如果 &lt;code&gt;align&lt;/code&gt; 不是2的幂，则此函数的返回值没有意义。</target>
        </trans-unit>
        <trans-unit id="60b397a9e27c756600834e9e8bc999da0f2e38e6" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">返回的64位值等效于&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt;结构，该结构表示自1601年1月1日（UTC）起100纳秒间隔的数量。该结构会自动转换为 &lt;code&gt;u64&lt;/code&gt; 值，因为这是使用它的推荐方法。</target>
        </trans-unit>
        <trans-unit id="9b9e4888166c03a2354c980d922cf25c13eb44d0" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">返回的64位值等效于&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt;结构，该结构表示自1601年1月1日（UTC）起100纳秒间隔的数量。该结构会自动转换为 &lt;code&gt;u64&lt;/code&gt; 值，因为这是使用它的推荐方法。</target>
        </trans-unit>
        <trans-unit id="f17e579c0925b04170923132b19bbc2e328718e7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is safe to pass to &lt;a href=&quot;../primitive.slice#method.get_unchecked&quot;&gt;&lt;code&gt;slice::get_unchecked&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.slice#method.get_unchecked_mut&quot;&gt;&lt;code&gt;slice::get_unchecked_mut&lt;/code&gt;&lt;/a&gt; for slices of the given length.</source>
          <target state="translated">对于给定长度的切片，返回的&lt;a href=&quot;struct.range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;可以安全地传递给&lt;a href=&quot;../primitive.slice#method.get_unchecked&quot;&gt; &lt;code&gt;slice::get_unchecked&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.slice#method.get_unchecked_mut&quot;&gt; &lt;code&gt;slice::get_unchecked_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e9caf07f01ab2822f3d6ed99758b9360c5c26af" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">返回的&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;是对该对象引用的同一套接字的引用。两个句柄均可用于接受传入连接，并且在一个侦听器上设置的选项将影响另一个。</target>
        </trans-unit>
        <trans-unit id="ded74a0ee30df2ab90178bc7d8c79f6560c92452" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed without the condition being met.</source>
          <target state="translated">返回的&lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt;值指示是否已知超时没有满足条件。</target>
        </trans-unit>
        <trans-unit id="38736111afdf682fcdb07c273e755038e1599f59" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed.</source>
          <target state="translated">返回的&lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt;值指示是否已知超时。</target>
        </trans-unit>
        <trans-unit id="a4d3afc22fc51194d42ebf97c4d4c71d6cf8d193" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Read&lt;/code&gt; instance will first read all bytes from this object until EOF is encountered. Afterwards the output is equivalent to the output of &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">返回的 &lt;code&gt;Read&lt;/code&gt; 实例将首先从该对象读取所有字节，直到遇到EOF。之后的输出等于 &lt;code&gt;next&lt;/code&gt; 的输出。</target>
        </trans-unit>
        <trans-unit id="c46cae45e911aa3ffb2e82c2b8df4d3f09691f8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TcpStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">返回的 &lt;code&gt;TcpStream&lt;/code&gt; 是对该对象引用的同一流的引用。两个句柄将读取和写入相同的数据流，并且在一个流上设置的选项将传播到另一流。</target>
        </trans-unit>
        <trans-unit id="f1bab9e66e16ee3bc6f8eaaaaca9a4320b7da4d4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UdpSocket&lt;/code&gt; is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other.</source>
          <target state="translated">返回的 &lt;code&gt;UdpSocket&lt;/code&gt; 是对该对象引用的同一套接字的引用。两个句柄将读取和写入相同的端口，并且在一个套接字上设置的选项将传播到另一个套接字。</target>
        </trans-unit>
        <trans-unit id="c1a563924be47f2135363b13913bddb8d81845c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixDatagram&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one side will affect the other.</source>
          <target state="translated">返回的 &lt;code&gt;UnixDatagram&lt;/code&gt; 是对该对象引用的同一套接字的引用。两个句柄均可用于接受传入的连接，并且一侧设置的选项会影响另一侧。</target>
        </trans-unit>
        <trans-unit id="3a69722b38c150ace8c17a0ad6c7500758c624a4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixListener&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">返回的 &lt;code&gt;UnixListener&lt;/code&gt; 是对该对象引用的同一套接字的引用。两个句柄均可用于接受传入连接，并且在一个侦听器上设置的选项将影响另一个。</target>
        </trans-unit>
        <trans-unit id="144b7ef360f6249426bb7be199321625b6985707" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">返回的 &lt;code&gt;UnixStream&lt;/code&gt; 是对该对象引用的同一流的引用。两个句柄将读取和写入相同的数据流，并且在一个流上设置的选项将传播到另一流。</target>
        </trans-unit>
        <trans-unit id="cb880b11df63d1e3077076bea22bb8b51ec8054d" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;AllocRef&lt;/code&gt; and will simply borrow this.</source>
          <target state="translated">返回的适配器也实现 &lt;code&gt;AllocRef&lt;/code&gt; ,并且将简单地借用它。</target>
        </trans-unit>
        <trans-unit id="4ae8d8d70f6a5dbf383ce8f90712add3666ba1c3" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Allocator&lt;/code&gt; and will simply borrow this.</source>
          <target state="translated">返回的适配器还实现了 &lt;code&gt;Allocator&lt;/code&gt; ,并且将简单地借用该适配器。</target>
        </trans-unit>
        <trans-unit id="e3560a746a4c0e2ffb1141c7abaa941ae137d7b4" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Read&lt;/code&gt; and will simply borrow this current reader.</source>
          <target state="translated">返回的适配器还实现了 &lt;code&gt;Read&lt;/code&gt; 并将仅借用此当前的Reader。</target>
        </trans-unit>
        <trans-unit id="facac298df7b4792f8b8fe4cbcbc0a4967c70852" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Write&lt;/code&gt; and will simply borrow this current writer.</source>
          <target state="translated">返回的适配器还实现了 &lt;code&gt;Write&lt;/code&gt; ，并将仅借用此当前的writer。</target>
        </trans-unit>
        <trans-unit id="e389b4884c363b3fc760ebd7d93cdcb95de946c0" translate="yes" xml:space="preserve">
          <source>The returned block is suitable for passing to the &lt;code&gt;alloc&lt;/code&gt;/&lt;code&gt;realloc&lt;/code&gt; methods of this allocator.</source>
          <target state="translated">返回的块适合传递给此分配器的 &lt;code&gt;alloc&lt;/code&gt; / &lt;code&gt;realloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c91d87a8c74843f84b212121082c194e485a54b8" translate="yes" xml:space="preserve">
          <source>The returned block may have a larger size than specified by &lt;code&gt;layout.size()&lt;/code&gt;, and may or may not have its contents initialized.</source>
          <target state="translated">返回的块的大小可能大于 &lt;code&gt;layout.size()&lt;/code&gt; 指定的大小，并且可能已初始化或未初始化其内容。</target>
        </trans-unit>
        <trans-unit id="b4d367aab1faeec6de58c9c9955a240781bdbe40" translate="yes" xml:space="preserve">
          <source>The returned block of storage may or may not have its contents initialized. (Extension subtraits might restrict this behavior, e.g., to ensure initialization to particular sets of bit patterns.)</source>
          <target state="translated">返回的存储块可能有也可能没有初始化其内容。(扩展子集可能会限制这种行为,例如,为了确保初始化到特定的比特模式集。)</target>
        </trans-unit>
        <trans-unit id="ba2ebcfc4f605284f02edd68881e9753988594f5" translate="yes" xml:space="preserve">
          <source>The returned boolean is &lt;code&gt;false&lt;/code&gt; only if the timeout is known to have elapsed.</source>
          <target state="translated">仅当已知超时已过去时，返回的布尔值才为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef190a0092cd801a89bd32ca6438155668c7c711" translate="yes" xml:space="preserve">
          <source>The returned buffer does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.</source>
          <target state="translated">返回的缓冲区并&lt;strong&gt;没有&lt;/strong&gt;包含尾随NUL终止，并且可以保证它不会有任何内部NUL字节。</target>
        </trans-unit>
        <trans-unit id="c21f9df3ca074ffdfcc498df18bd9b3644edeb21" translate="yes" xml:space="preserve">
          <source>The returned iterator contains a snapshot of the process's environment variables at the time of this invocation. Modifications to environment variables afterwards will not be reflected in the returned iterator.</source>
          <target state="translated">返回的迭代器包含了这次调用时进程的环境变量的快照。之后对环境变量的修改不会反映在返回的迭代器中。</target>
        </trans-unit>
        <trans-unit id="94742684e4e1a0a940d70b49afd50e4db443fbed" translate="yes" xml:space="preserve">
          <source>The returned iterator may not actually yield any values depending on the outcome of any resolution performed.</source>
          <target state="translated">返回的迭代器实际上可能不会产生任何值,这取决于任何执行的解析结果。</target>
        </trans-unit>
        <trans-unit id="2aad97e80249c67281fd50b9abdb7bf4c0bc39de" translate="yes" xml:space="preserve">
          <source>The returned iterator might panic if the to-be-returned index would overflow a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要返回的索引会使&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;溢出，则返回的迭代器可能会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="3f6e0a2276ef2ac22ba60fa606f31e8d0538ab17" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">返回的迭代器要求该模式支持反向搜索，如果正向/反向搜索产生相同的元素，则它将为&lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="212e83558d8f38fe873f76d6ab8c409b36c6c1ca" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">返回的迭代器要求该模式支持反向搜索，如果正向/反向搜索产生相同的元素，则它将为&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a192fbaedef699058263c6cf3d017b9555c1581" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</source>
          <target state="translated">返回的迭代器要求模式支持逆向搜索,如果正向/逆向搜索得到的元素相同,则会被双结束。</target>
        </trans-unit>
        <trans-unit id="31cf06022e130c2b8e694b6f17ab8cbe9626501c" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">如果模式允许反向搜索并且正向/反向搜索产生相同的元素，则返回的迭代器将为&lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。这对于例如&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是正确的，但对于 &lt;code&gt;&amp;amp;str&lt;/code&gt; 则不是。</target>
        </trans-unit>
        <trans-unit id="4543e6c97747a65b55c800608ca5f7c928ee84b5" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">如果模式允许反向搜索并且正向/反向搜索产生相同的元素，则返回的迭代器将为&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。这对于例如&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是正确的，但对于 &lt;code&gt;&amp;amp;str&lt;/code&gt; 则不是。</target>
        </trans-unit>
        <trans-unit id="fcd14ee368ff1244ad97f001dc72e74042b0095f" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">如果模式允许反向搜索并且正向/反向搜索产生相同的元素，则返回的迭代器将为&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。这对于例如&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是正确的，但对于 &lt;code&gt;&amp;amp;str&lt;/code&gt; 则不是。</target>
        </trans-unit>
        <trans-unit id="fb1179f626056fe35d781c0e7e7072fe8a2697c8" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">如果模式允许反向搜索并且正向/反向搜索产生相同的元素，则返回的迭代器将为&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。这对于例如&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是正确的，但对于 &lt;code&gt;&amp;amp;str&lt;/code&gt; 则不是。</target>
        </trans-unit>
        <trans-unit id="45e7ec844babb660dc32f9f713ab552f258e8f9a" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">返回的迭代器将永远不会返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，也不会产生对等方的&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;结构。对其进行迭代等效于在循环中调用&lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40daaaf435dcc6bfd52a2f60c0016a88fb0c4d52" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;TcpListener::accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">返回的迭代器永远不会返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，也不会产生对等方的&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;结构。对其进行迭代等效于在循环中调用&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;TcpListener::accept&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cacc276ab85a92453bcb875fe7d5c79fd6233ed" translate="yes" xml:space="preserve">
          <source>The returned iterator will not be double ended, because it is not efficient to support.</source>
          <target state="translated">返回的迭代器不会是双结尾的,因为支持双结尾是没有效率的。</target>
        </trans-unit>
        <trans-unit id="6626efd84bc65ae6d8cabe4bc5b2e309e23cd9ee" translate="yes" xml:space="preserve">
          <source>The returned iterator will panic during iteration if any argument to the process is not valid unicode. If this is not desired, use the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;args_os&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">如果该进程的任何参数不是有效的unicode，则返回的迭代器将在迭代过程中发生混乱。如果不希望这样做，请改用&lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;args_os&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="48642a85c9b9785eaffc2d69f306f5a44a684795" translate="yes" xml:space="preserve">
          <source>The returned iterator yields only the &lt;code&gt;value&lt;/code&gt;s for which the supplied closure returns &lt;code&gt;Some(value)&lt;/code&gt;.</source>
          <target state="translated">返回的迭代器仅产生 &lt;code&gt;value&lt;/code&gt; s，所提供的闭包为其返回 &lt;code&gt;Some(value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c4abf6a88076e830a1096ad48a0fcbdcd010f5d" translate="yes" xml:space="preserve">
          <source>The returned lifetime is not guaranteed to be the actual lifetime of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">返回的生命周期不能保证是 &lt;code&gt;ptr&lt;/code&gt; 的实际生命周期。</target>
        </trans-unit>
        <trans-unit id="dd646ddea405b753233bb6eb50b8340613c5b51f" translate="yes" xml:space="preserve">
          <source>The returned listener is ready for accepting connections.</source>
          <target state="translated">返回的监听器已经准备好接受连接。</target>
        </trans-unit>
        <trans-unit id="32a2e5d176a9d291f17213749b86ae928f9a79fd" translate="yes" xml:space="preserve">
          <source>The returned name refers to a source path on the compiling system, but it isn't valid to represent this directly as a &lt;code&gt;&amp;amp;Path&lt;/code&gt;. The compiled code may run on a different system with a different &lt;code&gt;Path&lt;/code&gt; implementation than the system providing the contents and this library does not currently have a different &quot;host path&quot; type.</source>
          <target state="translated">返回的名称指向编译系统上的源路径，但是将其直接表示为 &lt;code&gt;&amp;amp;Path&lt;/code&gt; 是无效的。与提供内容的系统相比，编译后的代码可以在具有不同 &lt;code&gt;Path&lt;/code&gt; 实现的不同系统上运行，并且此库当前没有不同的&amp;ldquo;主机路径&amp;rdquo;类型。</target>
        </trans-unit>
        <trans-unit id="bd3776d88d1ca8845ec6b1038a3cef52ddd6c1ee" translate="yes" xml:space="preserve">
          <source>The returned object can be used for error recovery, such as re-inspecting the buffer.</source>
          <target state="translated">返回的对象可用于错误恢复,如重新检查缓冲区。</target>
        </trans-unit>
        <trans-unit id="d094ca8efdcd1c477cd38db568c96ab96a8083f1" translate="yes" xml:space="preserve">
          <source>The returned pointer is read-only; writing to it (including passing it to C code that writes to it) causes undefined behavior.</source>
          <target state="translated">返回的指针是只读的;对它进行写入(包括传递给写入它的C代码)会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="9b9b68320305244b712b6eba3fb78b4a32d8f345" translate="yes" xml:space="preserve">
          <source>The returned pointer will be valid for as long as &lt;code&gt;self&lt;/code&gt; is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.</source>
          <target state="translated">返回的指针将一直有效，直到 &lt;code&gt;self&lt;/code&gt; 为止，并指向以0字节结尾的连续区域，以表示字符串的结尾。</target>
        </trans-unit>
        <trans-unit id="d1d3044eae78ae415d38e3ebb8ef901b44a28df4" translate="yes" xml:space="preserve">
          <source>The returned range is half-open, which means that the end pointer points &lt;em&gt;one past&lt;/em&gt; the last element of the slice. This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.</source>
          <target state="translated">返回的范围是半开的，这意味着该端指针指向&lt;em&gt;一个过去的&lt;/em&gt;切片的最后一个元素。这样，空切片由两个相等的指针表示，两个指针之间的差表示切片的大小。</target>
        </trans-unit>
        <trans-unit id="1c27af8743c2ff7ed690feb622313cb681b2d0e2" translate="yes" xml:space="preserve">
          <source>The returned slice can be used to fill the vector with data (e.g. by reading from a file) before marking the data as initialized using the &lt;a href=&quot;struct.vec#method.set_len&quot;&gt;&lt;code&gt;set_len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">返回的切片可用于在将数据标记为使用&lt;a href=&quot;struct.vec#method.set_len&quot;&gt; &lt;code&gt;set_len&lt;/code&gt; &lt;/a&gt;方法初始化的数据之前（例如，通过从文件读取）将数据填充到向量中。</target>
        </trans-unit>
        <trans-unit id="bf0c4a80af7569dc2827892f37e1cf7abb925f27" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">返回片并&lt;strong&gt;没有&lt;/strong&gt;包含尾随NUL终止，并且可以保证它不会有任何内部NUL字节。如果需要nul终止符，请改用&lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a368474e9b2e8c2f52646dd2d7918f986464f59" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">返回片并&lt;strong&gt;没有&lt;/strong&gt;包含尾随NUL终止，并且可以保证它不会有任何内部NUL字节。如果需要nul终止符，请改用&lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23c2a4410e35e072d95d91733db13ddd5bf58ad1" translate="yes" xml:space="preserve">
          <source>The returned slice will &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator that this C string has.</source>
          <target state="translated">返回的片将&lt;strong&gt;不&lt;/strong&gt;包含此C字符串具有的尾随nul终止符。</target>
        </trans-unit>
        <trans-unit id="a46b9c2f552385dbbfeb1cece6cdbcca5271f43e" translate="yes" xml:space="preserve">
          <source>The returned string must not be considered to be a unique identifier of a type as multiple types may map to the same type name. Similarly, there is no guarantee that all parts of a type will appear in the returned string: for example, lifetime specifiers are currently not included. In addition, the output may change between versions of the compiler.</source>
          <target state="translated">返回的字符串不能被认为是一个类型的唯一标识符,因为多个类型可能映射到同一个类型名称。同样,也不能保证类型的所有部分都会出现在返回的字符串中:例如,目前还没有包含寿命说明符。此外,输出可能会在不同版本的编译器之间发生变化。</target>
        </trans-unit>
        <trans-unit id="ca6695d62fb3138a05ebea6941a15916ea38fd70" translate="yes" xml:space="preserve">
          <source>The returned type after indexing.</source>
          <target state="translated">索引后返回的类型。</target>
        </trans-unit>
        <trans-unit id="323e9e5f7457b4d404421a53102d137f9784ffb2" translate="yes" xml:space="preserve">
          <source>The returned type after the call operator is used.</source>
          <target state="translated">使用调用操作符后返回的类型。</target>
        </trans-unit>
        <trans-unit id="2d5978ed3eb5e45dd0ed7362549dedf897ab386a" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">返回的类型实现&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;Item&lt;/code&gt; 为&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 。如果成功读取了一个字节，则产生的项目为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; ,&lt;/a&gt;否则为&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。EOF映射为从此迭代器返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94490bb5f034be81aa72ad51da07b198637a8c28" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">返回的类型实现&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;Item&lt;/code&gt; 为&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 。如果成功读取了一个字节，则产生的项目为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; ,&lt;/a&gt;否则为&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。EOF映射为从此迭代器返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a0b4fa361f895a3f7a940a0df4cc75d5065e98e6" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;atime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastAccessTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">返回的值对应于Unix平台上的 &lt;code&gt;stat&lt;/code&gt; 的 &lt;code&gt;atime&lt;/code&gt; 字段和Windows平台上的 &lt;code&gt;ftLastAccessTime&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ab7615b505b03838f921f8936a1701e974958831" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">返回的值对应于 &lt;code&gt;birthtime&lt;/code&gt; 的领域 &lt;code&gt;stat&lt;/code&gt; 在Unix平台和 &lt;code&gt;ftCreationTime&lt;/code&gt; 在Windows平台领域。</target>
        </trans-unit>
        <trans-unit id="2eef349b822dea9863943a97049788d8df72cce1" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;btime&lt;/code&gt; field of &lt;code&gt;statx&lt;/code&gt; on Linux kernel starting from to 4.11, the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on other Unix platforms, and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">返回的值对应于 &lt;code&gt;btime&lt;/code&gt; 领域 &lt;code&gt;statx&lt;/code&gt; Linux内核从4.11，起始 &lt;code&gt;birthtime&lt;/code&gt; 领域 &lt;code&gt;stat&lt;/code&gt; 上其他Unix平台和 &lt;code&gt;ftCreationTime&lt;/code&gt; 在Windows平台领域。</target>
        </trans-unit>
        <trans-unit id="c5896159de75927b2d1b622cfd587f254e9fed43" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;mtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastWriteTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">返回的值对应于Unix平台上 &lt;code&gt;stat&lt;/code&gt; 的 &lt;code&gt;mtime&lt;/code&gt; 字段和Windows平台上的 &lt;code&gt;ftLastWriteTime&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="a0ea9c14c32dc6d6e0d323b13279abc6935b1d15" translate="yes" xml:space="preserve">
          <source>The returned value does include the fractional (nanosecond) part of the duration.</source>
          <target state="translated">返回的值确实包括持续时间的分数(纳秒)部分。</target>
        </trans-unit>
        <trans-unit id="ff15d0950ff1afde3f0762acc64a9f002a6a04c1" translate="yes" xml:space="preserve">
          <source>The returned value does not have meaning for directories.</source>
          <target state="translated">返回的值对目录没有意义。</target>
        </trans-unit>
        <trans-unit id="e8c08d63d79b2a138a0f12bb7a91ea3ec23dcec7" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的值不包括持续时间的小数（纳秒）部分，可以使用&lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt;获得。</target>
        </trans-unit>
        <trans-unit id="1bfa4d7247e116de4261b1e09435dc9dcadacc45" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的值不包括持续时间的小数（纳秒）部分，可以使用&lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt;获得。</target>
        </trans-unit>
        <trans-unit id="1e5135e5751b93b5d235f37608301c3018208e63" translate="yes" xml:space="preserve">
          <source>The returned value is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">返回的值是&lt;strong&gt;元素&lt;/strong&gt;数，而不是字节数。</target>
        </trans-unit>
        <trans-unit id="70d2d5505f46c3741e892512e8371427a53745d7" translate="yes" xml:space="preserve">
          <source>The right shift assignment operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">右移赋值运算符 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e00fa6358174afd137529285f589695abe7555ab" translate="yes" xml:space="preserve">
          <source>The right shift operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; and &lt;code&gt;a.shr(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">右移运算符 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 。请注意，由于此特征是针对具有多个右侧类型的所有整数类型实现的，因此Rust的类型检查器对 &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt; 特殊处理，将整数运算的结果类型设置为左侧操作数的类型。这意味着尽管 &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 和 &lt;code&gt;a.shr(b)&lt;/code&gt; 从求值的角度来看是相同的，但是在类型推断方面它们是不同的。</target>
        </trans-unit>
        <trans-unit id="4bed85e5cf48df182fbdc5f50e1999ffc9d50cbb" translate="yes" xml:space="preserve">
          <source>The right way to suppress the warning is to actually write error handling, but because you just want to crash this program when a problem occurs, you can use &lt;code&gt;expect&lt;/code&gt;. You&amp;rsquo;ll learn about recovering from errors in Chapter 9.</source>
          <target state="translated">抑制警告的正确方法是实际编写错误处理程序，但是由于您只想在发生问题时使该程序崩溃，因此可以使用 &lt;code&gt;expect&lt;/code&gt; 。您将在第9章中学习如何从错误中恢复。</target>
        </trans-unit>
        <trans-unit id="93b14b29a7aed966fc23a390a9832d3b882cc69b" translate="yes" xml:space="preserve">
          <source>The root directory component, appears after any prefix and before anything else.</source>
          <target state="translated">根目录组件,出现在任何前缀之后,其他任何东西之前。</target>
        </trans-unit>
        <trans-unit id="a168d72d668df499616b725b5ca80c1ff007a04a" translate="yes" xml:space="preserve">
          <source>The rules for &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; match those for normal struct types, while &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; behave as if &lt;a href=&quot;../attributes/derive&quot;&gt;derived&lt;/a&gt;. For &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, the order of cloning of the captured variables is left unspecified.</source>
          <target state="translated">&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;的规则与普通结构类型的规则匹配，而&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;行为就像&lt;a href=&quot;../attributes/derive&quot;&gt;派生的那样&lt;/a&gt;。对于&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，捕获变量的克隆顺序未指定。</target>
        </trans-unit>
        <trans-unit id="3563595879dbbd21c6c2906f7bd54a9b3679529d" translate="yes" xml:space="preserve">
          <source>The rust compiler cannot link to an external library if you don't give it its name. Example:</source>
          <target state="translated">如果你不给外部库命名,rust编译器就不能链接到它。例如</target>
        </trans-unit>
        <trans-unit id="54065002f88e1cb544dc442e2b3686e62225bf94" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">rust 编译器为每个目标维护一个在该目标上不支持的 ABI 的黑名单,如果一个 ABI 出现在这样的列表中,通常意味着该目标/ABI 组合目前不被 llvm 支持。如果一个 ABI 出现在这样的列表中,这通常意味着目标/ABI 组合目前不被 llvm 支持。</target>
        </trans-unit>
        <trans-unit id="e602506551cf00543c3919704a07e8c114c13f33" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a list of unsupported ABIs on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">rust 编译器为每个目标维护了一个该目标上不支持的 ABI 的列表,如果一个 ABI 出现在这样的列表中,通常意味着该目标/ABI 组合目前不受 llvm 支持。如果一个 ABI 出现在这样的列表中,这通常意味着目标/ABI 组合目前不受 llvm 支持。</target>
        </trans-unit>
        <trans-unit id="d8dcfff8659995d9c806c4ff5bfe72343be6d124" translate="yes" xml:space="preserve">
          <source>The rustfix tool is included with Rust installations and can automatically fix some compiler warnings. If you&amp;rsquo;ve written code in Rust, you&amp;rsquo;ve probably seen compiler warnings. For example, consider this code:</source>
          <target state="translated">rustfix工具包含在Rust安装中，可以自动修复一些编译器警告。如果您是用Rust编写代码的，则可能会看到编译器警告。例如，考虑以下代码：</target>
        </trans-unit>
        <trans-unit id="d95e676c8653714db7acc846f5781f129f187994" translate="yes" xml:space="preserve">
          <source>The safety and conciseness of &lt;code&gt;for&lt;/code&gt; loops make them the most commonly used loop construct in Rust. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a &lt;code&gt;while&lt;/code&gt; loop in Listing 3-3, most Rustaceans would use a &lt;code&gt;for&lt;/code&gt; loop. The way to do that would be to use a &lt;code&gt;Range&lt;/code&gt;, which is a type provided by the standard library that generates all numbers in sequence starting from one number and ending before another number.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 循环的安全性和简洁性使其成为Rust中最常用的循环构造。即使在您想要运行某些代码一定次数的情况下（例如清单3-3 中使用 &lt;code&gt;while&lt;/code&gt; 循环的倒计时示例），大多数Rustaceans也会使用 &lt;code&gt;for&lt;/code&gt; 循环。做到这一点的方法是使用 &lt;code&gt;Range&lt;/code&gt; ，它是标准库提供的一种类型，它按顺序生成所有数字，从一个数字开始到另一个数字之前结束。</target>
        </trans-unit>
        <trans-unit id="8de5417b2f4455bae199197d09ad86c5d8b15755" translate="yes" xml:space="preserve">
          <source>The safety conditions are described in the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; section.</source>
          <target state="translated">安全条件在&lt;a href=&quot;index#memory-layout&quot;&gt;内存布局&lt;/a&gt;部分中描述。</target>
        </trans-unit>
        <trans-unit id="34c5f02c44747e09b58d1ec500165079e9867619" translate="yes" xml:space="preserve">
          <source>The same applies to transmutes to &lt;code&gt;*mut fn()&lt;/code&gt;, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just &lt;code&gt;fn()&lt;/code&gt; alone suffices for that. &lt;code&gt;*mut fn()&lt;/code&gt; is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</source>
          <target state="translated">在实践中观察到的 &lt;code&gt;*mut fn()&lt;/code&gt; 的变形也是如此。注意，尽管这种类型的使用通常是不正确的。目的通常是描述一个函数指针，但是仅使用 &lt;code&gt;fn()&lt;/code&gt; 就可以满足要求。 &lt;code&gt;*mut fn()&lt;/code&gt; 是指向fn指针的指针。（由于这些值通常只是传递给C代码，因此，在实践中几乎没有什么不同。）</target>
        </trans-unit>
        <trans-unit id="a7f4b342720ddcec9a49dfb2ca6daf016843320d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">与&lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，但使用迭代器中的第一个元素作为初始值，将每个后续元素折叠到其中。如果迭代器为空，则返回&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;；否则，返回折叠的结果。&lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c676ce454b9f3ef8b4d42559af1943bf2b7913d9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">与&lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，但使用迭代器中的第一个元素作为初始值，将每个后续元素折叠到其中。如果迭代器为空，则返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;；否则，返回折叠的结果。&lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb7e4f0db03c726bc5bd7452fa0f56591b66e33d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">与&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，但使用迭代器中的第一个元素作为初始值，将每个后续元素折叠到其中。如果迭代器为空，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;；否则，返回折叠的结果。&lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcf7a6ad9f8fb40e4ba7caca628efe6809216b4f" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">与&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，但使用迭代器中的第一个元素作为初始值，将每个后续元素折叠到其中。如果迭代器为空，则返回&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;；否则，返回折叠的结果。&lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1ae9b3d116905ba91635f77fa80dd3badbdd424" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">与&lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，但使用迭代器中的第一个元素作为初始值，将每个后续元素折叠到其中。如果迭代器为空，则返回&lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;；否则，返回折叠的结果。&lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f595892b4fea20450f05cddbe7763f0e003caa0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold.</source>
          <target state="translated">与&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，但使用迭代器中的第一个元素作为初始值，将每个后续元素折叠到其中。如果迭代器为空，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;；否则，返回折叠的结果。</target>
        </trans-unit>
        <trans-unit id="f5b129096713d6e93f0f6771f5a02e553c2efcf3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">与&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，但使用迭代器中的第一个元素作为初始值，将每个后续元素折叠到其中。如果迭代器为空，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;；否则，返回折叠的结果。&lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="902a2b25118315948a58ef98f0d17bd457899153" translate="yes" xml:space="preserve">
          <source>The same goes for doc comments:</source>
          <target state="translated">文档评论也是如此。</target>
        </trans-unit>
        <trans-unit id="2e8159833047b3772ef09e1ff09bc6721b1345cc" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">与使用&lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt;一样，访问指针目标的限制也适用。</target>
        </trans-unit>
        <trans-unit id="2bc57fcef5c1050ba1f9373a34844306a6911e2e" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_raw&quot;&gt;&lt;code&gt;as_raw&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">与&lt;a href=&quot;struct.weak#method.as_raw&quot;&gt; &lt;code&gt;as_raw&lt;/code&gt; &lt;/a&gt;一样，访问指针目标的限制也适用。</target>
        </trans-unit>
        <trans-unit id="e53c2cdb1077121198b1a8746e267d3b3a805b0e" translate="yes" xml:space="preserve">
          <source>The scope in which the variable &lt;code&gt;s&lt;/code&gt; is valid is the same as any function parameter&amp;rsquo;s scope, but we don&amp;rsquo;t drop what the reference points to when it goes out of scope because we don&amp;rsquo;t have ownership. When functions have references as parameters instead of the actual values, we won&amp;rsquo;t need to return the values in order to give back ownership, because we never had ownership.</source>
          <target state="translated">变量 &lt;code&gt;s&lt;/code&gt; 有效的作用域与任何函数参数的作用域相同，但是当它超出作用域时，由于没有所有权，我们不会删除引用指向的内容。当函数将引用作为参数而不是实际值作为参数时，我们将不需要返回这些值以归还所有权，因为我们从未拥有过所有权。</target>
        </trans-unit>
        <trans-unit id="2c0f9db762db77543e23786689d772ed7e180cf6" translate="yes" xml:space="preserve">
          <source>The scopes of the immutable references &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; end after the &lt;code&gt;println!&lt;/code&gt; where they are last used, which is before the mutable reference &lt;code&gt;r3&lt;/code&gt; is created. These scopes don&amp;rsquo;t overlap, so this code is allowed.</source>
          <target state="translated">不变引用 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 的作用域在 &lt;code&gt;println!&lt;/code&gt; 之后结束。在创建可变引用 &lt;code&gt;r3&lt;/code&gt; 之前，在最后一次使用它们的位置。这些范围不重叠，因此允许使用此代码。</target>
        </trans-unit>
        <trans-unit id="547c47e37f57601f738482d42256219a9633dd7e" translate="yes" xml:space="preserve">
          <source>The search path to be used may be controlled by setting the &lt;code&gt;PATH&lt;/code&gt; environment variable on the Command, but this has some implementation limitations on Windows (see issue #37519).</source>
          <target state="translated">可以通过在Command上设置 &lt;code&gt;PATH&lt;/code&gt; 环境变量来控制要使用的搜索路径，但这在Windows上具有一些实现限制（请参见问题＃37519）。</target>
        </trans-unit>
        <trans-unit id="3a555019f8dcc01c39b7fc4a4df1fa78e901c698" translate="yes" xml:space="preserve">
          <source>The second case example is a bit particular: the main function must always have this definition:</source>
          <target state="translated">第二个案例的例子有点特殊:主函数必须始终有这个定义。</target>
        </trans-unit>
        <trans-unit id="02a1a4dab2732977e1598d466f79a0132530331a" translate="yes" xml:space="preserve">
          <source>The second form of macros is &lt;em&gt;procedural macros&lt;/em&gt;, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</source>
          <target state="translated">宏的第二种形式是&lt;em&gt;过程宏&lt;/em&gt;，它的作用类似于函数（并且是过程的一种）。程序宏接受某些代码作为输入，对该代码进行操作，并生成一些代码作为输出，而不是像声明式宏那样与模式匹配并将其替换为其他代码。</target>
        </trans-unit>
        <trans-unit id="014f5e70707fe70de5f920ceaf6bbf6f00b7acd7" translate="yes" xml:space="preserve">
          <source>The second half of the tuple that is returned is an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. A &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; here means that either there is no known upper bound, or the upper bound is larger than &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的元组的后半部分是&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 。这里的&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;表示没有已知上限，或者该上限大于&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4961749eb1f24345f8436cc7b35d0ebccb81384a" translate="yes" xml:space="preserve">
          <source>The second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of &lt;code&gt;tt ...&lt;/code&gt;'s, even as new syntactic forms are added to the language.</source>
          <target state="translated">第二个不变式说，一个分离的复数NT必须使用一个分隔符，它是NT内部内容的预定跟随集的一部分。这确保了合法的宏定义将继续将输入片段解析为 &lt;code&gt;tt ...&lt;/code&gt; 的相同定界序列，即使将新的语法形式添加到该语言中也是如此。</target>
        </trans-unit>
        <trans-unit id="3069a4f51af6a3b6633b4d681ece722a85d63fa2" translate="yes" xml:space="preserve">
          <source>The second is mutable references. They can be created from &lt;code&gt;mut&lt;/code&gt; variables and must be unique: no other variables can have a mutable reference, nor a shared reference.</source>
          <target state="translated">第二个是可变引用。它们可以从 &lt;code&gt;mut&lt;/code&gt; 变量创建，并且必须唯一：其他变量不能具有可变引用，也不能具有共享引用。</target>
        </trans-unit>
        <trans-unit id="3f2dca747a6f3fa79f2291ae843df5963e36bbc5" translate="yes" xml:space="preserve">
          <source>The second is that it is the offset in bytes between successive elements in an array with that item type.</source>
          <target state="translated">第二个是它是一个数组中该项目类型的连续元素之间的偏移量,单位是字节。</target>
        </trans-unit>
        <trans-unit id="a1e02e9dcee081f5b8c19c27d767e65c0ff37f76" translate="yes" xml:space="preserve">
          <source>The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section.</source>
          <target state="translated">第二种是普遍提高自己对语言的某一方面的知识。在这种情况下,只需浏览目录,直到你看到你想了解更多的东西,然后就开始阅读。如果一个链接看起来很有趣,就点击它,然后阅读有关该部分的内容。</target>
        </trans-unit>
        <trans-unit id="df5949936d6a2cd7eaf61fe27eb1fac54cf960fb" translate="yes" xml:space="preserve">
          <source>The second line that we added to the middle of the code prints the secret number. This is useful while we&amp;rsquo;re developing the program to be able to test it, but we&amp;rsquo;ll delete it from the final version. It&amp;rsquo;s not much of a game if the program prints the answer as soon as it starts!</source>
          <target state="translated">我们添加到代码中间的第二行将显示密码。在我们开发程序以对其进行测试时，这很有用，但是将从最终版本中删除它。如果程序一开始就打印答案，那将不是什么游戏！</target>
        </trans-unit>
        <trans-unit id="c1f82d829df68033c418a80c29f6453df31bb3f7" translate="yes" xml:space="preserve">
          <source>The second operand of a &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean expression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;惰性布尔表达式&lt;/a&gt;的第二个操作数。</target>
        </trans-unit>
        <trans-unit id="57bb822113e197cd1e10145a43fbd748bc848a6a" translate="yes" xml:space="preserve">
          <source>The second problem with the current &lt;code&gt;Cacher&lt;/code&gt; implementation is that it only accepts closures that take one parameter of type &lt;code&gt;u32&lt;/code&gt; and return a &lt;code&gt;u32&lt;/code&gt;. We might want to cache the results of closures that take a string slice and return &lt;code&gt;usize&lt;/code&gt; values, for example. To fix this issue, try introducing more generic parameters to increase the flexibility of the &lt;code&gt;Cacher&lt;/code&gt; functionality.</source>
          <target state="translated">当前 &lt;code&gt;Cacher&lt;/code&gt; 实现的第二个问题是它只接受采用 &lt;code&gt;u32&lt;/code&gt; 类型的一个参数并返回 &lt;code&gt;u32&lt;/code&gt; 的闭包。例如，我们可能想要缓存采用字符串切片并返回 &lt;code&gt;usize&lt;/code&gt; 值的闭包结果。要解决此问题，请尝试引入更多通用参数以增加 &lt;code&gt;Cacher&lt;/code&gt; 功能的灵活性。</target>
        </trans-unit>
        <trans-unit id="92462e612674a20cc7e3c63f701740ce5bea5c75" translate="yes" xml:space="preserve">
          <source>The second rule applies because there is exactly one input lifetime. The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</source>
          <target state="translated">第二条规则适用,因为正好有一个输入寿命。第二条规则规定,一个输入参数的寿命被分配给输出寿命,所以现在的签名是这样的。</target>
        </trans-unit>
        <trans-unit id="66815e0776a29457690bd505c60d2e19937fa654" translate="yes" xml:space="preserve">
          <source>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt;.</source>
          <target state="translated">第二条规则是，如果仅存在一个输入生存期参数，则将生存期分配给所有输出生存期参数： &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aedd96f8435bb44ce30001804fbe27f5473ed0ee" translate="yes" xml:space="preserve">
          <source>The second time we call &lt;code&gt;add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use a relative path. The path starts with &lt;code&gt;front_of_house&lt;/code&gt;, the name of the module defined at the same level of the module tree as &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Here the filesystem equivalent would be using the path &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt;. Starting with a name means that the path is relative.</source>
          <target state="translated">第二次在 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 时，我们使用相对路径。路径以 &lt;code&gt;front_of_house&lt;/code&gt; 开始，front_of_house是在模块树的同一级别与eat_at_restaurant定义的模块 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。在这里，等效文件系统将使用路径 &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt; 。以名称开头表示路径是相对的。</target>
        </trans-unit>
        <trans-unit id="6719785aa3871b4c2a2d425aeb686279358fe018" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; customizes &lt;code&gt;Drop&lt;/code&gt; to deallocate the space on the heap that the box points to.</source>
          <target state="translated">智能指针模式的第二个重要特征是 &lt;code&gt;Drop&lt;/code&gt; ，它使您可以自定义值将超出范围时发生的情况。您可以提供任何类型的 &lt;code&gt;Drop&lt;/code&gt; 特性的实现，并且您指定的代码可用于释放资源，例如文件或网络连接。我们在智能指针的上下文中引入 &lt;code&gt;Drop&lt;/code&gt; ，因为在实现智能指针时几乎总是使用 &lt;code&gt;Drop&lt;/code&gt; 特性的功能。例如， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 自定义 &lt;code&gt;Drop&lt;/code&gt; 来取消分配Box指向的堆上的空间。</target>
        </trans-unit>
        <trans-unit id="445effcb8001016422ef7635d91738ff3683b61e" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, when a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is dropped it will deallocate the space on the heap that the box points to.</source>
          <target state="translated">智能指针模式的第二个重要特征是 &lt;code&gt;Drop&lt;/code&gt; ，它使您可以自定义值将超出范围时发生的情况。您可以提供任何类型的 &lt;code&gt;Drop&lt;/code&gt; 特性的实现，并且您指定的代码可用于释放资源，例如文件或网络连接。我们在智能指针的上下文中引入 &lt;code&gt;Drop&lt;/code&gt; ，因为在实现智能指针时几乎总是使用 &lt;code&gt;Drop&lt;/code&gt; 特性的功能。例如，当删除 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ，它将在该Box指向的堆上重新分配空间。</target>
        </trans-unit>
        <trans-unit id="b9253951b95bdbecdb3d6ee784fab1524db5c9af" translate="yes" xml:space="preserve">
          <source>The second type of operation that requires an unsafe block is calls to unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra &lt;code&gt;unsafe&lt;/code&gt; before the rest of the definition. The &lt;code&gt;unsafe&lt;/code&gt; keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can&amp;rsquo;t guarantee we&amp;rsquo;ve met these requirements. By calling an unsafe function within an &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;re saying that we&amp;rsquo;ve read this function&amp;rsquo;s documentation and take responsibility for upholding the function&amp;rsquo;s contracts.</source>
          <target state="translated">需要不安全块的第二种操作类型是对不安全功能的调用。不安全的函数和方法看起来与常规函数和方法完全一样，但是在定义其余部分之前，它们还有一个额外的 &lt;code&gt;unsafe&lt;/code&gt; 之处。在 &lt;code&gt;unsafe&lt;/code&gt; 在这方面的关键字表示该功能具有我们需要的时候，我们调用这个函数来维护要求，因为铁锈能不能保证我们已经满足了这些要求。通过在 &lt;code&gt;unsafe&lt;/code&gt; 块中调用不安全的函数，我们是说已经阅读了该函数的文档，并负责维护该函数的合同。</target>
        </trans-unit>
        <trans-unit id="3b5790cbd3c99b8bfcd34f57b9dbfe5e2b8bc741" translate="yes" xml:space="preserve">
          <source>The second-to-last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">输出的倒数第二行显示已安装二进制文件的位置和名称，在 &lt;code&gt;ripgrep&lt;/code&gt; 的情况下为 &lt;code&gt;rg&lt;/code&gt; 。只要安装目录位于 &lt;code&gt;$PATH&lt;/code&gt; ，如前所述，您就可以运行 &lt;code&gt;rg --help&lt;/code&gt; 并开始使用一个更快，更可靠的工具来搜索文件！</target>
        </trans-unit>
        <trans-unit id="599ddbb55a436b4b2320e8d917bb378c0d788288" translate="yes" xml:space="preserve">
          <source>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</source>
          <target state="translated">向函数传递值的语义与向变量赋值的语义相似。向函数传递变量会像赋值一样,移动或复制变量。清单4-3中有一个例子,其中有一些注释显示了变量进入和退出作用域的位置。</target>
        </trans-unit>
        <trans-unit id="0ebf78e0ec598941096cd9f3613dea835a20177d" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">该函数的语义等同于&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; ,&lt;/a&gt;不同之处在于线程被阻塞的时间大约不超过 &lt;code&gt;dur&lt;/code&gt; 。由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确 &lt;code&gt;dur&lt;/code&gt; 因此该方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="9f8ab2e3b0b43343b07ba616db0d9b83ddc1ec9a" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">此函数的语义等同于&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;只是线程将被阻塞的时间大约不超过 &lt;code&gt;ms&lt;/code&gt; 毫秒。由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确为 &lt;code&gt;ms&lt;/code&gt; ,因此该方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="10369644dc806ec3584f4bc1cd00c1b37924dd8f" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">此函数的语义与&lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;/a&gt;等效，除了线程被阻塞的时间大致不超过 &lt;code&gt;dur&lt;/code&gt; 之外。由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确 &lt;code&gt;dur&lt;/code&gt; 因此该方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="599bdbbdba24d3dd39b2e820e78610be901175cf" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt; long.</source>
          <target state="translated">此函数的语义与&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;等效，除了线程被阻塞的时间不超过 &lt;code&gt;dur&lt;/code&gt; 之外。该方法不应当被用于精确的定时由于异常，如，可能不会导致最大的时间量等待为精确抢占或平台差异 &lt;code&gt;dur&lt;/code&gt; 长。</target>
        </trans-unit>
        <trans-unit id="9563714599dd3161cea050e5c59d88f3adc62446" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt; long.</source>
          <target state="translated">此函数的语义与&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;等效，除了线程被阻塞的时间不超过 &lt;code&gt;dur&lt;/code&gt; 之外。由于诸如抢占或平台差异之类的异常可能不会导致最长的等待时间恰好为 &lt;code&gt;ms&lt;/code&gt; 毫秒,因此该方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="8ace657d10944a484e642331ec94fc1a6e6161be" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">此函数的语义等同于&lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; ,&lt;/a&gt;不同之处在于，线程被阻塞的时间大约不超过 &lt;code&gt;dur&lt;/code&gt; 。该方法不应当被用于精确的定时由于异常，如，可能不会引起的最大时间量抢占或平台差异等着被精确 &lt;code&gt;dur&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3371efd221cedf557721fc9ee15bda8759a39a9" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">此函数的语义等同于&lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;只是线程将被阻塞的时间大约不超过 &lt;code&gt;ms&lt;/code&gt; 毫秒。由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确为 &lt;code&gt;ms&lt;/code&gt; ,因此此方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="6e595d1de9f2e3618f10b608ff234b6ad2944f66" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">此函数的语义与&lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt; &lt;code&gt;wait_while&lt;/code&gt; &lt;/a&gt;等效，除了线程被阻塞的时间大致不超过 &lt;code&gt;dur&lt;/code&gt; 之外。该方法不应当被用于精确的定时由于异常，如，可能不会引起的最大时间量抢占或平台差异等着被精确 &lt;code&gt;dur&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ce3d66bfcd3164df001d8c8d3ea53b374782f46" translate="yes" xml:space="preserve">
          <source>The semicolon &lt;code&gt;;&lt;/code&gt; can be used to discard the result of an expression at the end of a block, making the expression (and thus the block) evaluate to &lt;code&gt;()&lt;/code&gt;. For example,</source>
          <target state="translated">分号 &lt;code&gt;;&lt;/code&gt; 可以用于在一个块的末尾丢弃表达式的结果，使表达式（以及该块）的求值为 &lt;code&gt;()&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="bb5601bddd79e71c2b7b66e9a5ead92eff60bcdd" translate="yes" xml:space="preserve">
          <source>The send and receive operations on channels will all return a &lt;a href=&quot;../../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having &quot;hung up&quot; by being dropped in its corresponding thread.</source>
          <target state="translated">通道上的发送和接收操作都将返回&lt;a href=&quot;../../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;指示操作是否成功。不成功的操作通常表示通道的另一半已通过掉入其相应的线程而&amp;ldquo;挂起&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ea8d26ff0d36fb568a938927807eafbc1ae6f29d" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's asynchronous &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; type. This half can only be owned by one thread, but it can be cloned to send to other threads.</source>
          <target state="translated">Rust异步&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;类型的发送一半。这一半只能由一个线程拥有，但可以克隆以发送给其他线程。</target>
        </trans-unit>
        <trans-unit id="52ce535fefd9bc68502a1a5978b6409a82fd1bcb" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's synchronous &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Rust的同步&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;类型的发送一半。</target>
        </trans-unit>
        <trans-unit id="937e495e6de5b225295fc788a2b8a9723c5d12e3" translate="yes" xml:space="preserve">
          <source>The sequential nature of the tuple applies to its implementations of various traits. For example, in &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Ord&lt;/code&gt;, the elements are compared sequentially until the first non-equal set is found.</source>
          <target state="translated">元组的顺序性质适用于其各种特征的实现。例如，在 &lt;code&gt;PartialOrd&lt;/code&gt; 和 &lt;code&gt;Ord&lt;/code&gt; 中，将顺序比较元素，直到找到第一个不相等的集合。</target>
        </trans-unit>
        <trans-unit id="faf864ad82a0182728e07d76ebfb5f1fdf6dc8f4" translate="yes" xml:space="preserve">
          <source>The signed two's complement integer types consist of:</source>
          <target state="translated">有符号的二的补码整数类型包括。</target>
        </trans-unit>
        <trans-unit id="0a593fcbffb90fbe9434a8bd0cd231a38381ce34" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the &amp;ldquo;Hello, world!&amp;rdquo; project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">像我们到目前为止编写的那样，最简单的Rust程序没有任何依赖关系。因此，如果我们建立了&amp;ldquo;你好，世界！&amp;rdquo; 在Cargo项目中，它将仅使用Cargo负责构建代码的部分。在编写更复杂的Rust程序时，您将添加依赖项，并且如果使用Cargo启动项目，则添加依赖项将变得更加容易。</target>
        </trans-unit>
        <trans-unit id="0dca1ad1ce59bbb51cae453b849e2d3bd139c7cf" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the Hello, world! project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">像我们到目前为止编写的那样，最简单的Rust程序没有任何依赖关系。因此，如果我们建立了Hello，世界！在Cargo项目中，它将仅使用Cargo处理代码的部分。在编写更复杂的Rust程序时，您将添加依赖项，并且如果使用Cargo启动项目，则添加依赖项将更加容易。</target>
        </trans-unit>
        <trans-unit id="cc9fb663ff26b10b3b0480942ea72891d7b9e8a8" translate="yes" xml:space="preserve">
          <source>The single-address property of statics is required.</source>
          <target state="translated">静态的单地址属性是必须的。</target>
        </trans-unit>
        <trans-unit id="019cb91a15aad53bc6628eee08e1df33b769b170" translate="yes" xml:space="preserve">
          <source>The size and offset of fields is determined by the following algorithm.</source>
          <target state="translated">字段的大小和偏移量由以下算法决定。</target>
        </trans-unit>
        <trans-unit id="cd076db2ed4f4f71100b51cbd80768553b1f9904" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddr&lt;/code&gt; 实例的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="36d5ae29044e3939345f3681fd2eee4951ec1d94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV4&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV4&lt;/code&gt; 结构的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="aa0a80c41eafe63e764438582cea6579e34fa99a" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV6&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV6&lt;/code&gt; 结构的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="e8de810002bae6a69cc3fd5fc7b805d907b3e5fa" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SystemTime&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SystemTime&lt;/code&gt; 结构的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="5b0dd86b903ec8c3b54b21a61cbefcfccd34c7a3" translate="yes" xml:space="preserve">
          <source>The size of a recursive type must be finite; in other words the recursive fields of the type must be &lt;a href=&quot;types/pointer&quot;&gt;pointer types&lt;/a&gt;.</source>
          <target state="translated">递归类型的大小必须是有限的。换句话说，该类型的递归字段必须是&lt;a href=&quot;types/pointer&quot;&gt;指针类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c26f5c42f6a164861e02ed67750e160fcf8f0712" translate="yes" xml:space="preserve">
          <source>The size of a symbolic link is the length of the pathname it contains, without a terminating null byte.</source>
          <target state="translated">符号链接的大小是它所包含的路径名的长度,不含终止的空字节。</target>
        </trans-unit>
        <trans-unit id="e1eaacf69ef80cbba3a3f01cf2e10bd4a9a5fca5" translate="yes" xml:space="preserve">
          <source>The size of a type in bytes.</source>
          <target state="translated">类型的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="96cd8943bd738b362434700faacd7dc900194564" translate="yes" xml:space="preserve">
          <source>The size of a union is the size of its largest field.</source>
          <target state="translated">联合体的大小是指其最大领域的大小。</target>
        </trans-unit>
        <trans-unit id="b7e7e7e0bae0750a49867bf9a72696378b080c09" translate="yes" xml:space="preserve">
          <source>The size of a value has two definitions.</source>
          <target state="translated">一个值的大小有两个定义。</target>
        </trans-unit>
        <trans-unit id="5e402a67efb4a62fa553a5f1394c869ac08acac0" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Instant&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Instant&lt;/code&gt; 结构的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="ba89d7b73eb9567f0b0c3196e6cf2e84c9f4c35c" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;IpAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;IpAddr&lt;/code&gt; 实例的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="64ef5aa718e0f2a4fb9998a036169d75f54db6df" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv4Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv4Addr&lt;/code&gt; 结构的大小可能会有所不同，具体取决于目标操作系统。</target>
        </trans-unit>
        <trans-unit id="b28d6468d140c4a12bab4e35b4415d244e5f859a" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv6Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv6Addr&lt;/code&gt; 结构的大小可能会有所不同，具体取决于目标操作系统。</target>
        </trans-unit>
        <trans-unit id="a01d57dab257711e2df9579c72d88d59028c40dc" translate="yes" xml:space="preserve">
          <source>The size of most primitives is given in this table.</source>
          <target state="translated">本表给出了大多数基元的尺寸。</target>
        </trans-unit>
        <trans-unit id="5a098a792b06569a6bb6f2b7d98cf8797dcd4ec6" translate="yes" xml:space="preserve">
          <source>The size of the referenced value in bytes.</source>
          <target state="translated">参考值的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="62333b23a5b2b89de3b055144daa334820b9c575" translate="yes" xml:space="preserve">
          <source>The size of this integer type in bits.</source>
          <target state="translated">这个整数类型的大小,以比特为单位。</target>
        </trans-unit>
        <trans-unit id="7c1fbeb1b5be430f1bc9e3a92e1dadba4b4fdb71" translate="yes" xml:space="preserve">
          <source>The size of this primitive is how many bytes it takes to reference any location in memory. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</source>
          <target state="translated">此基元的大小是指引用内存中任何位置所需的字节数。例如,在 32 位目标上,这是 4 个字节,在 64 位目标上,这是 8 个字节。</target>
        </trans-unit>
        <trans-unit id="eaea58fd5debec4469854dd4c0d7e96ee309fa5f" translate="yes" xml:space="preserve">
          <source>The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).</source>
          <target state="translated">分片被假定为根据给定的谓词进行分割。这意味着,所有谓词返回真值的元素都在分片的开始,所有谓词返回假值的元素都在分片的最后。例如,[7,15,3,5,4,12,6]是根据谓词x % 2 !=0进行的分割(所有奇数在开始,所有偶数在结束)。</target>
        </trans-unit>
        <trans-unit id="8e51743ff7cd79535af677e289113dcff07dbe9c" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte at the end of the slice.</source>
          <target state="translated">用于创建&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;的切片在切片末尾必须只有一个nul字节。</target>
        </trans-unit>
        <trans-unit id="06c3ab06faa47dfc08256f59e9e6b62a827af728" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="translated">用于创建&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;的片必须位于末尾且只有一个nul字节。</target>
        </trans-unit>
        <trans-unit id="ad56ccc65a97d6c0192795237bde8dc8a187bcc7" translate="yes" xml:space="preserve">
          <source>The slices implement &lt;code&gt;IntoIterator&lt;/code&gt;. The iterator yields references to the slice elements.</source>
          <target state="translated">切片实现 &lt;code&gt;IntoIterator&lt;/code&gt; 。迭代器产生对slice元素的引用。</target>
        </trans-unit>
        <trans-unit id="4d54f29cfdc5fb0b14c6bc3d825908235a2d1e62" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type.</source>
          <target state="translated">这个整数类型所能代表的最小值。</target>
        </trans-unit>
        <trans-unit id="2ed21758c259b01204be09a1e5a970a7587f0275" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt;&lt;code&gt;i128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt; &lt;code&gt;i128::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5a50b28fc392edeb96ae6e8bbc1f3f65f1879e9" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt;&lt;code&gt;i16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt; &lt;code&gt;i16::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fab5eaa27a5d1f357d4d2bc91b9af02383caede4" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt;&lt;code&gt;i32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt; &lt;code&gt;i32::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc283863a8f984dedbdb2f90ee6338a2b682ff86" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt;&lt;code&gt;i64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt; &lt;code&gt;i64::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da8fcd8d47309d686d033e491c707f9a8e4582c1" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt;&lt;code&gt;i8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt; &lt;code&gt;i8::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="124d5af779df7e9ad406378d4ae95baeff0f8e12" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt;&lt;code&gt;isize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。使用&lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt; &lt;code&gt;isize::MIN&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="d7283dc0e8aef63acf9dd8ecc15410819b62a917" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt;&lt;code&gt;u128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt; &lt;code&gt;u128::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e1d26d88d80abad9936f065a519a8e6dae555c2" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt;&lt;code&gt;u16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt; &lt;code&gt;u16::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c5170dcabff61b3cd439cd574c1475742baecf6" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt;&lt;code&gt;u32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt; &lt;code&gt;u32::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0709e957f7976c853e280aae68478111e39066d5" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt;&lt;code&gt;u64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt; &lt;code&gt;u64::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa14915f9b53a3b041d9be135f24e5f469a12ccc" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt;&lt;code&gt;u8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt; &lt;code&gt;u8::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="275bb49ca6506b300934116c83ccd1ff11d81477" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt;&lt;code&gt;usize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此整数类型可以表示的最小值。请改用&lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt; &lt;code&gt;usize::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c371b87930b46855075594aef0b191a2dcbb6afc" translate="yes" xml:space="preserve">
          <source>The smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is also not &lt;code&gt;Sync&lt;/code&gt; for the same reasons that it&amp;rsquo;s not &lt;code&gt;Send&lt;/code&gt;. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type (which we talked about in Chapter 15) and the family of related &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; types are not &lt;code&gt;Sync&lt;/code&gt;. The implementation of borrow checking that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does at runtime is not thread-safe. The smart pointer &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; and can be used to share access with multiple threads as you saw in the &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo;Sharing a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; Between Multiple Threads&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">智能指针 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 也不 &lt;code&gt;Sync&lt;/code&gt; ，原因与未 &lt;code&gt;Send&lt;/code&gt; 。所述 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; （我们将在第15章讲到）类型和相关的家族 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 类型不 &lt;code&gt;Sync&lt;/code&gt; 。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 在运行时执行的借位检查的实现不是线程安全的。智能指针 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 是 &lt;code&gt;Sync&lt;/code&gt; ，可以用来与多个线程共享访问，如&lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo; 在多个线程之间共享 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &amp;rdquo;&lt;/a&gt;部分中所看到的。</target>
        </trans-unit>
        <trans-unit id="348ea7c78b50388dc12ad8afa807cfbceb141e14" translate="yes" xml:space="preserve">
          <source>The socket will be closed when the value is dropped.</source>
          <target state="translated">当数值下降时,插座将被关闭。</target>
        </trans-unit>
        <trans-unit id="26c3406d4e79e978c77c7f71fb4706519f7ecd96" translate="yes" xml:space="preserve">
          <source>The solution here is to return the &lt;code&gt;String&lt;/code&gt; directly:</source>
          <target state="translated">解决方案是直接返回 &lt;code&gt;String&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b153caaa35f5e55b36f6162bb71df5061ac16716" translate="yes" xml:space="preserve">
          <source>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</source>
          <target state="translated">解决方法是选择一个不同的名称,不与任何导入到当前模块的外部箱子冲突。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
