<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d0129491a9c802e31402a256b2ed3248526999bd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u8&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; 与 &lt;code&gt;u8&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="444ef8a1b6149aa40edb45ac918d2fcc6dd0e6a5" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; 与 &lt;code&gt;usize&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="05b9c29faea2a683215e0b23ceda6c29cb84253c" translate="yes" xml:space="preserve">
          <source>This enum can contain either an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, see their respective documentation for more details.</source>
          <target state="translated">该枚举可以包含&lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;Ipv4Addr&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;Ipv6Addr&lt;/code&gt; &lt;/a&gt;，有关更多详细信息，请参见其各自的文档。</target>
        </trans-unit>
        <trans-unit id="760b8f1ec007bba813777fc9f56dd941c92b8841" translate="yes" xml:space="preserve">
          <source>This enum has four variants with different types:</source>
          <target state="translated">这个枚举有四个不同类型的变体。</target>
        </trans-unit>
        <trans-unit id="ced6caa3ad1703b55bcd5c2e59bf560b6691cb01" translate="yes" xml:space="preserve">
          <source>This enum has the same role as &lt;a href=&quot;../primitive.never&quot;&gt;the &lt;code&gt;!&lt;/code&gt; &amp;ldquo;never&amp;rdquo; type&lt;/a&gt;, which is unstable in this version of Rust. When &lt;code&gt;!&lt;/code&gt; is stabilized, we plan to make &lt;code&gt;Infallible&lt;/code&gt; a type alias to it:</source>
          <target state="translated">该枚举&lt;a href=&quot;../primitive.never&quot;&gt;与 &lt;code&gt;!&lt;/code&gt; 的&lt;/a&gt;作用相同。&amp;ldquo;从不&amp;rdquo;类型，在此版本的Rust中不稳定。什么时候 &lt;code&gt;!&lt;/code&gt; 稳定之后，我们计划将 &lt;code&gt;Infallible&lt;/code&gt; 设为它的类型别名：</target>
        </trans-unit>
        <trans-unit id="6ee104c9c1676af30fcb1ff39c18e2ed9e455f59" translate="yes" xml:space="preserve">
          <source>This enum is returned from the &lt;code&gt;Generator::resume&lt;/code&gt; method and indicates the possible return values of a generator. Currently this corresponds to either a suspension point (&lt;code&gt;Yielded&lt;/code&gt;) or a termination point (&lt;code&gt;Complete&lt;/code&gt;).</source>
          <target state="translated">该枚举从 &lt;code&gt;Generator::resume&lt;/code&gt; 方法返回，并指示生成器的可能返回值。当前，它对应于一个悬挂点（ &lt;code&gt;Yielded&lt;/code&gt; ）或一个终止点（ &lt;code&gt;Complete&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b0fad9f14978736d5cc5f3492964033b9a38fd54" translate="yes" xml:space="preserve">
          <source>This enum represent one control message of variable type.</source>
          <target state="translated">这个枚举代表一个变量类型的控制信息。</target>
        </trans-unit>
        <trans-unit id="1703fcf1fccea6643fefc20e49e4c80e84f95499" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of possible errors that made &lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt;&lt;code&gt;recv_timeout&lt;/code&gt;&lt;/a&gt; unable to return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此枚举是导致&lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt; &lt;code&gt;recv_timeout&lt;/code&gt; &lt;/a&gt;在调用时无法返回数据的可能错误的列表。这可能同时发生在&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; 上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbe05c4f5a229c7e20d58b03f49460f0df3da02f" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible error outcomes for the &lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt;&lt;code&gt;try_send&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">此枚举是&lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt; &lt;code&gt;try_send&lt;/code&gt; &lt;/a&gt;方法的可能错误结果列表。</target>
        </trans-unit>
        <trans-unit id="6dc63139830daa8f080f2bf636d153d6ed98ad21" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible reasons that &lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt;&lt;code&gt;try_recv&lt;/code&gt;&lt;/a&gt; could not return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此枚举是&lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt; &lt;code&gt;try_recv&lt;/code&gt; &lt;/a&gt;在调用时无法返回数据的可能原因的列表。这可能同时发生在&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; 上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1093396faf4de8ad558d41dcf5187f56b3280a8" translate="yes" xml:space="preserve">
          <source>This error also frequently arises with iteration:</source>
          <target state="translated">迭代时也经常出现这种错误。</target>
        </trans-unit>
        <trans-unit id="94b9a993ad00befb67d90a954bbd93d2df863b1b" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces contain an identifier which doesn't match with any of the type parameters or the string &lt;code&gt;Self&lt;/code&gt;. This might happen if you misspelled a type parameter, or if you intended to use literal curly braces. If it is the latter, escape the curly braces with a second curly brace of the same type; e.g., a literal &lt;code&gt;{&lt;/code&gt; is &lt;code&gt;{{&lt;/code&gt;.</source>
          <target state="translated">当花括号包含与任何类型参数或字符串 &lt;code&gt;Self&lt;/code&gt; 不匹配的标识符时，将出现此错误。如果您拼写了一个类型参数，或者打算使用文字花括号，则可能会发生这种情况。如果是后者，则用另一个相同类型的花括号将花括号转义；例如，文字 &lt;code&gt;{&lt;/code&gt; 是 &lt;code&gt;{{&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="584182c12fbcdc7236283566d4fe892f8514a84a" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces do not contain an identifier. Please add one of the same name as a type parameter. If you intended to use literal braces, use &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; to escape them.</source>
          <target state="translated">当花括号不包含标识符时，会出现此错误。请添加一个与类型参数相同的名称。如果打算使用文字大括号，请使用 &lt;code&gt;{{&lt;/code&gt; 和 &lt;code&gt;}}&lt;/code&gt; 对其进行转义。</target>
        </trans-unit>
        <trans-unit id="0250b09263b0cf211b3144438a4935e1e43d799a" translate="yes" xml:space="preserve">
          <source>This error can be fixed by changing &lt;code&gt;demo&lt;/code&gt; so that the destructor does not run while the string-data is borrowed; for example by taking &lt;code&gt;S&lt;/code&gt; by reference:</source>
          <target state="translated">可以通过更改 &lt;code&gt;demo&lt;/code&gt; 来解决此错误，以使借用字符串数据时析构函数不会运行。例如，以 &lt;code&gt;S&lt;/code&gt; 为参考：</target>
        </trans-unit>
        <trans-unit id="cf00137495add2df4af51c96509efb72f8de11bd" translate="yes" xml:space="preserve">
          <source>This error can be fixed by creating a reference to the fields of a struct, enum, or tuple using the &lt;code&gt;ref&lt;/code&gt; keyword:</source>
          <target state="translated">可以通过使用 &lt;code&gt;ref&lt;/code&gt; 关键字创建对struct，enum或tuple的字段的引用来解决此错误：</target>
        </trans-unit>
        <trans-unit id="0dff7bc132443224671e948d9ffe4c7e1624395f" translate="yes" xml:space="preserve">
          <source>This error can be fixed by fully reinitializing the structure in question:</source>
          <target state="translated">这个错误可以通过完全重新初始化相关结构来解决。</target>
        </trans-unit>
        <trans-unit id="9c719c44866ac61477960cb8b276b7f76f8c6533" translate="yes" xml:space="preserve">
          <source>This error can be fixed by making the container mutable:</source>
          <target state="translated">这个错误可以通过使容器可突变来解决。</target>
        </trans-unit>
        <trans-unit id="413b5d16e5f0759b900c5fe5dc8c6c4f80d50366" translate="yes" xml:space="preserve">
          <source>This error can be solved by adding type annotations that provide the missing information to the compiler. In this case, the solution is to use a concrete type:</source>
          <target state="translated">这个错误可以通过添加类型注释来解决,这些类型注释可以向编译器提供缺失的信息。在这种情况下,解决办法是使用具体类型。</target>
        </trans-unit>
        <trans-unit id="2f0e10eb9c6b47c452a0e1f4fb8a082452a2d703" translate="yes" xml:space="preserve">
          <source>This error code indicates a mismatch between the lifetimes appearing in the function signature (i.e., the parameter types and the return type) and the data-flow found in the function body.</source>
          <target state="translated">这个错误代码表示函数签名中出现的寿命(即参数类型和返回类型)与函数主体中的数据流不匹配。</target>
        </trans-unit>
        <trans-unit id="21caa47590bc7c04cd88dfba7269f8c13368e7a3" translate="yes" xml:space="preserve">
          <source>This error generally appears when two items with the same name are imported into a module. Here, the &lt;code&gt;foo&lt;/code&gt; functions are imported and reexported from the &lt;code&gt;collider&lt;/code&gt; module and therefore, when we're using &lt;code&gt;collider::foo()&lt;/code&gt;, both functions collide.</source>
          <target state="translated">当两个具有相同名称的项目导入模块时，通常会出现此错误。在这里， &lt;code&gt;foo&lt;/code&gt; 函数是从 &lt;code&gt;collider&lt;/code&gt; 模块导入和重新导出的，因此，当我们使用 &lt;code&gt;collider::foo()&lt;/code&gt; ，两个函数都会碰撞。</target>
        </trans-unit>
        <trans-unit id="3dfae522bf711393bcf17e2c72e0d218bd40909c" translate="yes" xml:space="preserve">
          <source>This error indicates a type mismatch in closure arguments.</source>
          <target state="translated">该错误表明闭合参数的类型不匹配。</target>
        </trans-unit>
        <trans-unit id="1f7e9e73655654d551ddbe67dfdca41396aade3d" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type.</source>
          <target state="translated">这个错误表明违反了Rust对trait实现的一个孤儿规则。该规则涉及到在实现一个外来特质(在另一个箱子中定义的特质)时使用类型参数,并指出类型参数必须由本地类型 &quot;覆盖&quot;。</target>
        </trans-unit>
        <trans-unit id="5926fa6825473ce8b14051d29bff524913459d93" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type. To understand what this means, it is perhaps easiest to consider a few examples.</source>
          <target state="translated">这个错误表明违反了Rust对trait实现的一个孤儿规则。这条规则涉及到在一个外来trait(在另一个箱子中定义的trait)的实现中使用类型参数,并指出类型参数必须由本地类型 &quot;覆盖&quot;。要理解这意味着什么,也许最简单的方法就是看几个例子。</target>
        </trans-unit>
        <trans-unit id="62c66f8f6d53d3993670c86c1f09308676282e5b" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait (a trait defined in another crate) where</source>
          <target state="translated">这个错误表明违反了Rust对trait实现的一个孤儿规则。该规则禁止在以下情况下实现外来特质(在另一个箱子中定义的特质)。</target>
        </trans-unit>
        <trans-unit id="447a5e9fa4c8cf25c5cd5302f4311b3fbd33ec5e" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong type of item.</source>
          <target state="translated">此错误表明在错误的项目类型上放置了一个 &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="04b6c6e07e059a0181ccbe377eeeabdfa436d081" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[non_exhaustive]&lt;/code&gt; attribute was incorrectly placed on something other than a struct or enum.</source>
          <target state="translated">该错误表明 &lt;code&gt;#[non_exhaustive]&lt;/code&gt; 属性被错误地放置在struct或enum以外的其他对象上。</target>
        </trans-unit>
        <trans-unit id="7022f431bbd32573cf9101aaa229f54136c6e815" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="translated">此错误表明 &lt;code&gt;#[repr(..)]&lt;/code&gt; 属性被放置在不受支持的项目上。</target>
        </trans-unit>
        <trans-unit id="ca9d1588d95295137d9296e3cc73990ee881720a" translate="yes" xml:space="preserve">
          <source>This error indicates that a binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it. For example:</source>
          <target state="translated">此错误表明，将二进制赋值运算符（例如 &lt;code&gt;+=&lt;/code&gt; 或 &lt;code&gt;^=&lt;/code&gt; ）应用于了不支持它的类型。例如：</target>
        </trans-unit>
        <trans-unit id="942586ad68f246da14ea422c40de5e3f0b9face6" translate="yes" xml:space="preserve">
          <source>This error indicates that a incorrect visibility restriction was specified.</source>
          <target state="translated">该错误表明指定的可见性限制不正确。</target>
        </trans-unit>
        <trans-unit id="0ed5220e5bb81a5a254920c1211412f9ef92a217" translate="yes" xml:space="preserve">
          <source>This error indicates that a lifetime is missing from a type. If it is an error inside a function signature, the problem may be with failing to adhere to the lifetime elision rules (see below).</source>
          <target state="translated">该错误表明,类型中缺少了一个生命周期,如果是函数签名中的错误,那么问题可能是没有遵守生命周期的删除规则(见下文)。如果是函数签名中的错误,问题可能是没有遵守生命周期的删除规则(见下文)。</target>
        </trans-unit>
        <trans-unit id="163c07e3082230bfd9dd310e7a36d455707b90b1" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is being used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available for use until the closure goes out of scope.</source>
          <target state="translated">这个错误表明,当一个可变的变量仍被闭包捕获时,它正在被使用。因为闭包已经借用了这个变量,所以在闭包退出范围之前,这个变量是不能使用的。</target>
        </trans-unit>
        <trans-unit id="5f5aeaeedbb41e69e7d361beb7e7f664611c650d" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available until the closure goes out of scope.</source>
          <target state="translated">这个错误表明,当一个可变的变量仍被闭包捕获时,它被使用了。因为闭包已经借用了这个变量,所以在闭包退出作用域之前,这个变量是不可用的。</target>
        </trans-unit>
        <trans-unit id="f276e617d109dc1e2831917bc3e9ec17e8a46ef1" translate="yes" xml:space="preserve">
          <source>This error indicates that a pattern for a struct fails to specify a sub-pattern for every one of the struct's fields. Ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields.</source>
          <target state="translated">此错误表明结构的模式无法为该结构的每个字段指定子模式。确保模式中提到结构定义中的每个字段，或使用 &lt;code&gt;..&lt;/code&gt; 忽略不需要的字段。</target>
        </trans-unit>
        <trans-unit id="cf2673db078cb233aef2cf4d975d04209851d888" translate="yes" xml:space="preserve">
          <source>This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">这个错误表明指向trait类型的指针不能被模式隐式地导出引用。每个trait都定义了一个类型,但由于trait实现者的大小并不固定,这个类型没有编译时的大小。因此,所有对trait类型的访问都必须通过指针。如果遇到这个错误,你应该尽量避免去引用指针。</target>
        </trans-unit>
        <trans-unit id="828017bc333a648d7ba2ba05b6d8defb66538498" translate="yes" xml:space="preserve">
          <source>This error indicates that a struct pattern attempted to extract a non-existent field from a struct. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">此错误表明结构模式试图从结构中提取不存在的字段。结构字段由冒号之前使用的名称标识 &lt;code&gt;:&lt;/code&gt; 因此结构模式应类似于所匹配结构类型的声明。</target>
        </trans-unit>
        <trans-unit id="8fe4ff510197fbaaaaa06c8b33b203c1e4dc7f1a" translate="yes" xml:space="preserve">
          <source>This error indicates that a temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">该错误表明,当借款仍在使用中时,一个临时值正在被删除。</target>
        </trans-unit>
        <trans-unit id="29f636e2d8527491e9c968890f3142a6d2d79a49" translate="yes" xml:space="preserve">
          <source>This error indicates that a type or lifetime parameter has been declared but not actually used. Here is an example that demonstrates the error:</source>
          <target state="translated">这个错误表明类型或寿命参数已经声明,但没有实际使用。下面是一个证明该错误的例子。</target>
        </trans-unit>
        <trans-unit id="021899c7481112f5b1115194dfebb6c6433d75e6" translate="yes" xml:space="preserve">
          <source>This error indicates that a variable usage inside an inner function is invalid because the variable comes from a dynamic environment. Inner functions do not have access to their containing environment.</source>
          <target state="translated">该错误表明内部函数中的变量使用无效,因为该变量来自动态环境。内部函数不能访问其包含的环境。</target>
        </trans-unit>
        <trans-unit id="ee2b7895f62fe245340d50c3f8c134d38d139ea0" translate="yes" xml:space="preserve">
          <source>This error indicates that an &lt;code&gt;#[inline(..)]&lt;/code&gt; attribute was incorrectly placed on something other than a function or method.</source>
          <target state="translated">此错误表明 &lt;code&gt;#[inline(..)]&lt;/code&gt; 属性被错误地放置在函数或方法以外的其他东西上。</target>
        </trans-unit>
        <trans-unit id="b354ce81cf352c1f70206a250c5709ec2f51795d" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of function parameters.</source>
          <target state="translated">该错误表明,一个特质方法的尝试实现有错误的函数参数数量。</target>
        </trans-unit>
        <trans-unit id="e0c31ba5c6bda555cd8ea81a836bf176c496c77b" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of type or const parameters.</source>
          <target state="translated">该错误表明,试图实现的特质方法的类型或const参数数量错误。</target>
        </trans-unit>
        <trans-unit id="b75e5fdc31d31d1c4e71b1b39da466c4c14335c3" translate="yes" xml:space="preserve">
          <source>This error indicates that an empty match expression is invalid because the type it is matching on is non-empty (there exist values of this type). In safe code it is impossible to create an instance of an empty type, so empty match expressions are almost never desired. This error is typically fixed by adding one or more cases to the match expression.</source>
          <target state="translated">这个错误表明空匹配表达式无效,因为它所匹配的类型是非空的(存在该类型的值)。在安全代码中,不可能创建一个空类型的实例,所以几乎不希望使用空匹配表达式。这个错误通常通过在匹配表达式中添加一个或多个情况来解决。</target>
        </trans-unit>
        <trans-unit id="aa5d0ed3544dd02116d741311bf5dc31cbf1e877" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was not provided. Erroneous code example:</source>
          <target state="translated">该错误表明,在尝试构建一个结构或类似结构的枚举变体时,其中一个字段没有提供。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="4fe613edd2e0d9ed1781cdd172cb95fcc86dda95" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Each field should be specified exactly one time. Example:</source>
          <target state="translated">该错误表明,在试图构建一个结构或类似结构的枚举变体时,其中一个字段被指定了一次以上。每个字段应该只指定一次。例子:</target>
        </trans-unit>
        <trans-unit id="3e8ed17cc79bcd070351fc2c779882f025c94d0d" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Erroneous code example:</source>
          <target state="translated">该错误表明,在尝试构建结构或类结构枚举变体的过程中,其中一个字段被指定了一次以上。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="184a0c9f21c2159367397ab03b1af11810a4b7a9" translate="yes" xml:space="preserve">
          <source>This error indicates that next we need to create an associated function named &lt;code&gt;new&lt;/code&gt; for &lt;code&gt;ThreadPool&lt;/code&gt;. We also know that &lt;code&gt;new&lt;/code&gt; needs to have one parameter that can accept &lt;code&gt;4&lt;/code&gt; as an argument and should return a &lt;code&gt;ThreadPool&lt;/code&gt; instance. Let&amp;rsquo;s implement the simplest &lt;code&gt;new&lt;/code&gt; function that will have those characteristics:</source>
          <target state="translated">此错误表明，接下来我们需要为 &lt;code&gt;ThreadPool&lt;/code&gt; 创建一个名为 &lt;code&gt;new&lt;/code&gt; 的关联函数。我们也知道， &lt;code&gt;new&lt;/code&gt; 需要有一个可以接受 &lt;code&gt;4&lt;/code&gt; 作为参数的参数，并且应该返回 &lt;code&gt;ThreadPool&lt;/code&gt; 实例。让我们实现具有这些特征的最简单的 &lt;code&gt;new&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="2dad13e650883f25d2104ae52eca1fef407497bf" translate="yes" xml:space="preserve">
          <source>This error indicates that not enough type parameters were found in a type or trait.</source>
          <target state="translated">该错误表明在类型或特征中没有找到足够的类型参数。</target>
        </trans-unit>
        <trans-unit id="ca21a72c98d3df2023442d374a3dadbb098c691b" translate="yes" xml:space="preserve">
          <source>This error indicates that some types or traits depend on each other and therefore cannot be constructed.</source>
          <target state="translated">该错误表明,一些类型或特征相互依赖,因此无法构建。</target>
        </trans-unit>
        <trans-unit id="04671a501f0a2d188e9fcc11f1a02fbc634b9fe6" translate="yes" xml:space="preserve">
          <source>This error indicates that the bindings in a match arm would require a value to be moved into more than one location, thus violating unique ownership. Code like the following is invalid as it requires the entire &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; to be moved into a variable called &lt;code&gt;op_string&lt;/code&gt; while simultaneously requiring the inner &lt;code&gt;String&lt;/code&gt; to be moved into a variable called &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">此错误表明匹配臂中的绑定需要将值移到多个位置，从而违反了唯一所有权。如下所示的代码无效，因为它要求将整个 &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; 移入名为 &lt;code&gt;op_string&lt;/code&gt; 的变量，同时要求将内部 &lt;code&gt;String&lt;/code&gt; 移入名为 &lt;code&gt;s&lt;/code&gt; 的变量。</target>
        </trans-unit>
        <trans-unit id="0593569b391769294fc0cbd6c435421f4f05566e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution.</source>
          <target state="translated">该错误表明编译器无法保证匹配表达式的一个或多个可能输入的匹配模式。为了给匹配表达式赋值,或者确定执行流程,需要保证匹配。</target>
        </trans-unit>
        <trans-unit id="e6ec80fb058ca19fb5e7892d541e007d08b04d8f" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution. Erroneous code example:</source>
          <target state="translated">该错误表明编译器无法保证匹配表达式的一个或多个可能输入的匹配模式。为了给匹配表达式赋值,或者确定执行流程,需要保证匹配。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="561856cda5e25152013aec070f3d54bab7aa1df8" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[main]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="translated">该错误表明编译器使用 &lt;code&gt;#[main]&lt;/code&gt; 属性找到了多个函数。这是一个错误，因为在Rust程序中必须有一个唯一的入口点。例：</target>
        </trans-unit>
        <trans-unit id="5bea3375dcc80f531e3766516bd9f6d7115c2ccf" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[start]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="translated">该错误表明编译器使用 &lt;code&gt;#[start]&lt;/code&gt; 属性找到了多个函数。这是一个错误，因为在Rust程序中必须有一个唯一的入口点。例：</target>
        </trans-unit>
        <trans-unit id="8f30ae6ab3b3757a6fafd59d7ba821bfd1db82b1" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate a constant expression that had to be evaluated. Attempting to divide by 0 or causing an integer overflow are two ways to induce this error.</source>
          <target state="translated">这个错误表明编译器无法合理地评估一个必须要评估的常量表达式。试图除以0或导致整数溢出是引起该错误的两种方式。</target>
        </trans-unit>
        <trans-unit id="f36d8b8d1d8446198729b807cb2a4a2419af004e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate an constant expression that had to be evaluated. Attempting to divide by 0 or causing integer overflow are two ways to induce this error. For example:</source>
          <target state="translated">这个错误表明编译器无法合理地评估一个必须要评估的常量表达式。试图除以0或导致整数溢出是诱发此错误的两种方式。例如</target>
        </trans-unit>
        <trans-unit id="6a1e2255560b86b2d9499ff55662d827b519b332" translate="yes" xml:space="preserve">
          <source>This error indicates that the numeric value for the method being passed exists but the type of the numeric value or binding could not be identified.</source>
          <target state="translated">该错误表明,被传递的方法的数值存在,但无法识别数值或绑定的类型。</target>
        </trans-unit>
        <trans-unit id="148347b598d68fa69c31f92c37c1da55d76c0063" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant cannot be instantiated from outside of the defining crate as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt; and as such more fields/variants may be added in future that could cause adverse side effects for this code.</source>
          <target state="translated">此错误表明struct，enum或enum变体无法从定义的板条箱外部实例化，因为它已被标记 &lt;code&gt;non_exhaustive&lt;/code&gt; ，因此将来可能会添加更多字段/变体，可能对此代码产生不利的副作用。</target>
        </trans-unit>
        <trans-unit id="fcad2c51ea5b37a57bae2601eed616fe3e726b2e" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant must be matched non-exhaustively as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt;.</source>
          <target state="translated">此错误表明struct，enum或enum变体必须完全穷尽地匹配，因为它已被标记为 &lt;code&gt;non_exhaustive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37c7a2a28ca533246457e808e16c999f3f050492" translate="yes" xml:space="preserve">
          <source>This error indicates that there is a mismatch between generic parameters and impl Trait parameters in a trait declaration versus its impl.</source>
          <target state="translated">该错误表明,在trait声明中的通用参数和 impl Trait参数与其 impl之间不匹配。</target>
        </trans-unit>
        <trans-unit id="51a28020fb3170ca33d27d23beb6ff4c2ae9ce5c" translate="yes" xml:space="preserve">
          <source>This error indicates that too many type parameters were found in a type or trait.</source>
          <target state="translated">该错误表明,在类型或性状中发现了太多的类型参数。</target>
        </trans-unit>
        <trans-unit id="52a40c02e70b32e434b6bbe135867f805601219b" translate="yes" xml:space="preserve">
          <source>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</source>
          <target state="translated">这个错误表明,类型推理没有得出一个唯一的可能类型,需要额外的信息。在大多数情况下,这可以通过添加类型注释来提供。有时您需要手动指定一个通用类型参数。</target>
        </trans-unit>
        <trans-unit id="4c3b94702358e1162bf8effa04b8b4b7e098714c" translate="yes" xml:space="preserve">
          <source>This error indicates that you are trying to borrow a variable as mutable when it has already been borrowed as immutable.</source>
          <target state="translated">这个错误表明,你正试图将一个变量借用为可变型,而它已经被借用为不可变型。</target>
        </trans-unit>
        <trans-unit id="5d266dd2a168d28b90102ea5f40d828bae3909b4" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) inside a closure but outside of any loop. Erroneous code example:</source>
          <target state="translated">此错误表示在闭包内但在任何循环外都使用了循环关键字（ &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; ）。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="a14d78d3da966b89fe122674705e062ddb4c4c41" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) outside of a loop. Without a loop to break out of or continue in, no sensible action can be taken. Erroneous code example:</source>
          <target state="translated">此错误表示在循环外使用了循环关键字（ &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; ）。没有循环来突破或继续前进，就不会采取明智的行动。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="50520313e8b1d1b1c6569c98ff40cb57f7812069" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;CStr::from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="translated">此错误是由&lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt; &lt;code&gt;CStr::from_bytes_with_nul&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1b9e91e9541342a47e9d0b1ac521444fa8e68a88" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此错误是由&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt; &lt;code&gt;from_bytes_with_nul&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="bbb5b15b9e8658856b49fb418cbe7dfc72c8452a" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstring#method.from_vec_with_nul&quot;&gt;&lt;code&gt;CString::from_vec_with_nul&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="translated">此错误是由&lt;a href=&quot;struct.cstring#method.from_vec_with_nul&quot;&gt; &lt;code&gt;CString::from_vec_with_nul&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7f88231c82f77383d008a182af5374b0e8d20578" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此错误是由&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e66887716e5bc2fbc972f3ffc3450120cd6c7b7e" translate="yes" xml:space="preserve">
          <source>This error is fairly cryptic because the problem is fairly cryptic. To call a &lt;code&gt;FnOnce&lt;/code&gt; closure that is stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (which is what our &lt;code&gt;Job&lt;/code&gt; type alias is), the closure needs to move itself &lt;em&gt;out&lt;/em&gt; of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because the closure takes ownership of &lt;code&gt;self&lt;/code&gt; when we call it. In general, Rust doesn&amp;rsquo;t allow us to move a value out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because Rust doesn&amp;rsquo;t know how big the value inside the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will be: recall in Chapter 15 that we used &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; precisely because we had something of an unknown size that we wanted to store in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to get a value of a known size.</source>
          <target state="translated">此错误相当隐蔽，因为问题相当隐秘。要调用存储在 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 的 &lt;code&gt;FnOnce&lt;/code&gt; 闭包（这是我们的 &lt;code&gt;Job&lt;/code&gt; 类型别名），闭包需要将自身&lt;em&gt;从&lt;/em&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;em&gt;移出&lt;/em&gt;，因为在我们调用闭包时，它会获取 &lt;code&gt;self&lt;/code&gt; 所有权。通常，Rust不允许我们将值从 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 移出，因为Rust不知道 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 内部的值会有多大：在第15章中我们曾使用 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 正是因为我们有一个未知大小的东西想要存储在 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 以获得已知大小的值。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac1c7bfe67c403881a0d5e5220daf766f18ab15b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该错误用作&lt;a href=&quot;../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;实现的错误类型。</target>
        </trans-unit>
        <trans-unit id="a413bd30b0780353f6f0cb9ec7112a60510b4c1b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;enum.ipaddr&quot;&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此错误用作&lt;a href=&quot;enum.ipaddr&quot;&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;Ipv4Addr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;Ipv6Addr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;实现的错误类型。</target>
        </trans-unit>
        <trans-unit id="dbd5a817ebd0158354fc9b6704f3a0f2b0fc517f" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;code&gt;from_str_radix()&lt;/code&gt; functions on the primitive integer types, such as &lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt;&lt;code&gt;i8::from_str_radix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此错误用作原始整数类型（例如&lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt; &lt;code&gt;i8::from_str_radix&lt;/code&gt; &lt;/a&gt; &lt;code&gt;from_str_radix()&lt;/code&gt; 上from_str_radix（）函数的错误类型。</target>
        </trans-unit>
        <trans-unit id="022d759f57798a79780636ae9f03f6fedf32312c" translate="yes" xml:space="preserve">
          <source>This error lets us know that either we&amp;rsquo;re passing something to &lt;code&gt;Screen&lt;/code&gt; we didn&amp;rsquo;t mean to pass and we should pass a different type or we should implement &lt;code&gt;Draw&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; so that &lt;code&gt;Screen&lt;/code&gt; is able to call &lt;code&gt;draw&lt;/code&gt; on it.</source>
          <target state="translated">这个错误让我们知道，要么是我们向 &lt;code&gt;Screen&lt;/code&gt; 传递了我们本不希望传递的东西，而我们应该传递不同的类型，要么应该实现 &lt;code&gt;Draw&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; ,以便 &lt;code&gt;Screen&lt;/code&gt; 能够在其上调用 &lt;code&gt;draw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7089a49860a1eeefd308980067bc3b5e6f3e5841" translate="yes" xml:space="preserve">
          <source>This error lets you know that Rust has this constant defined more precisely and that your program would be more correct if you used the constant instead. You would then change your code to use the &lt;code&gt;PI&lt;/code&gt; constant. The following code doesn&amp;rsquo;t result in any errors or warnings from Clippy:</source>
          <target state="translated">该错误使您知道Rust具有更精确的定义此常数，并且如果改用该常数，则程序将更正确。然后，您将更改代码以使用 &lt;code&gt;PI&lt;/code&gt; 常量。以下代码不会导致Clippy出现任何错误或警告：</target>
        </trans-unit>
        <trans-unit id="7527f99b3dbab9d3281da26cc0de240205ca3ed7" translate="yes" xml:space="preserve">
          <source>This error may also commonly be found when working with unsafe code. For example, when using raw pointers one may wish to specify the lifetime for which the pointed-at data is valid. An initial attempt (below) causes this error:</source>
          <target state="translated">当使用不安全的代码时,也会经常发现这个错误。例如,当使用原始指针时,人们可能希望指定指向数据的有效期。最初的尝试(如下)会导致这个错误。</target>
        </trans-unit>
        <trans-unit id="1e7204b5ea49e32896ab0ba12a29a6e3937bc0f3" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match a struct type enum variant as a non-struct type:</source>
          <target state="translated">该错误意味着试图将结构类型枚举变体匹配为非结构类型。</target>
        </trans-unit>
        <trans-unit id="76d97f884e0ba6f5c3488397207d55a3b212ce21" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match something which is neither a tuple struct nor a tuple variant. Only these two elements are allowed as a pattern:</source>
          <target state="translated">这个错误意味着试图匹配既不是元组结构也不是元组变体的东西。只有这两个元素被允许作为模式。</target>
        </trans-unit>
        <trans-unit id="c1988ee636e2a4d68092372fb6c89de2473339d3" translate="yes" xml:space="preserve">
          <source>This error means that an incorrect number of generic arguments were provided:</source>
          <target state="translated">该错误意味着提供的通用参数数量不正确。</target>
        </trans-unit>
        <trans-unit id="368e8d1bf22974707354d4d21e3f6ab34ed1757e" translate="yes" xml:space="preserve">
          <source>This error means you can&amp;rsquo;t use this trait as a trait object in this way. If you&amp;rsquo;re interested in more details on object safety, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255&lt;/a&gt;.</source>
          <target state="translated">此错误意味着您不能以这种方式将此特征用作特征对象。如果您对对象安全性的更多详细信息感兴趣，请参阅&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="027a2fdf6a3f9948a9c92b0f1c99c26f859c6929" translate="yes" xml:space="preserve">
          <source>This error message refers to a feature we haven&amp;rsquo;t covered yet: lifetimes. We&amp;rsquo;ll discuss lifetimes in detail in Chapter 10. But, if you disregard the parts about lifetimes, the message does contain the key to why this code is a problem:</source>
          <target state="translated">此错误消息引用的是我们尚未涵盖的功能：生存期。我们将在第10章中详细讨论生命周期。但是，如果您忽略有关生命周期的部分，则消息的确包含了导致此代码出现问题的关键：</target>
        </trans-unit>
        <trans-unit id="b934f7e266f094b4b999e8bf2f04c71dea6d6829" translate="yes" xml:space="preserve">
          <source>This error message states that we&amp;rsquo;re not allowed to explicitly call &lt;code&gt;drop&lt;/code&gt;. The error message uses the term &lt;em&gt;destructor&lt;/em&gt;, which is the general programming term for a function that cleans up an instance. A &lt;em&gt;destructor&lt;/em&gt; is analogous to a &lt;em&gt;constructor&lt;/em&gt;, which creates an instance. The &lt;code&gt;drop&lt;/code&gt; function in Rust is one particular destructor.</source>
          <target state="translated">此错误消息指出，我们不允许显式调用 &lt;code&gt;drop&lt;/code&gt; 。错误消息使用术语&lt;em&gt;destructor&lt;/em&gt;，这是清理实例的函数的通用编程术语。甲&lt;em&gt;析构函数&lt;/em&gt;类似于一个&lt;em&gt;构造函数&lt;/em&gt;，它创建一个实例。Rust中的 &lt;code&gt;drop&lt;/code&gt; 函数是一种特定的析构函数。</target>
        </trans-unit>
        <trans-unit id="2c2b32b5586db42f3b0dff4da46b1782d86e698e" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow in a generator persists across a yield point.</source>
          <target state="translated">发生这种错误的原因是生成器中的借贷持续跨越一个收益点。</target>
        </trans-unit>
        <trans-unit id="1e6bf835d8f1dd37c8b25ebb4f51cc6621c79aa9" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">发生这个错误的原因是,在一个函数中借用了一个线程局部变量,而这个变量超过了函数的寿命。</target>
        </trans-unit>
        <trans-unit id="249f7bc8f6d82a80564f1c3f396aa42dbc6e451f" translate="yes" xml:space="preserve">
          <source>This error occurs because a value was dropped while it was still borrowed</source>
          <target state="translated">发生这个错误的原因是,当一个值还在被借用的时候,它就被丢弃了。</target>
        </trans-unit>
        <trans-unit id="074bebec9bc1d161aacdccb6e09fa091949d4c0d" translate="yes" xml:space="preserve">
          <source>This error occurs because you tried to mutably borrow a non-mutable variable.</source>
          <target state="translated">发生这个错误的原因是你试图以突变方式借用一个不可变的变量。</target>
        </trans-unit>
        <trans-unit id="1c3db0f8ef7d737dfd4c2dc90ac02bc9a5c77f3f" translate="yes" xml:space="preserve">
          <source>This error occurs when a bound in an implementation of a trait does not match the bounds specified in the original trait. For example:</source>
          <target state="translated">当一个特质实现中的边界与原始特质中指定的边界不匹配时,就会发生这个错误。例如:</target>
        </trans-unit>
        <trans-unit id="093dfc68eae74dcc328a7c8a1a3d68f0b36d7fb4" translate="yes" xml:space="preserve">
          <source>This error occurs when a method is used on a type which doesn't implement it:</source>
          <target state="translated">当一个方法被用于一个没有实现它的类型时,就会发生这个错误。</target>
        </trans-unit>
        <trans-unit id="da941b6947e460e43f6112767122feb782f16207" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected, for example a &lt;code&gt;let&lt;/code&gt; expression:</source>
          <target state="translated">当在期望除 &lt;code&gt;()&lt;/code&gt; 以外的类型的上下文中使用不带 &lt;code&gt;else&lt;/code&gt; 块的 &lt;code&gt;if&lt;/code&gt; 表达式时，会发生此错误，例如 &lt;code&gt;let&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="5a28a2c48baba84d59c80917ee2d999515b5d378" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected. In the previous code example, the &lt;code&gt;let&lt;/code&gt; expression was expecting a value but since there was no &lt;code&gt;else&lt;/code&gt;, no value was returned.</source>
          <target state="translated">当在预期不是 &lt;code&gt;()&lt;/code&gt; 的类型的上下文中使用不带 &lt;code&gt;else&lt;/code&gt; 块的 &lt;code&gt;if&lt;/code&gt; 表达式时，将发生此错误。在前面的代码示例中， &lt;code&gt;let&lt;/code&gt; 表达式期望一个值，但是由于没有 &lt;code&gt;else&lt;/code&gt; 值，因此不会返回任何值。</target>
        </trans-unit>
        <trans-unit id="d0370ddda8b1bb558216506bbbbafb414b273904" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to assign to a borrowed value.</source>
          <target state="translated">当试图分配给一个借来的值时,会发生这个错误。</target>
        </trans-unit>
        <trans-unit id="81568110c66c811e652efe84f4e84d35ccd0ca5f" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to borrow state past the end of the lifetime of a type that implements the &lt;code&gt;Drop&lt;/code&gt; trait.</source>
          <target state="translated">当尝试借用实现 &lt;code&gt;Drop&lt;/code&gt; 特性的类型的生命周期结束时的状态时，会发生此错误。</target>
        </trans-unit>
        <trans-unit id="552e357ec5f4118a4e87577f4bd866d88ddeba4b" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to move a borrowed variable into a closure.</source>
          <target state="translated">当试图将一个借来的变量移动到一个闭包中时,会发生这个错误。</target>
        </trans-unit>
        <trans-unit id="08dbd4d1c622d91c2a3b2e7680f087d95c0c0ad4" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to move out of a value whose type implements the &lt;code&gt;Drop&lt;/code&gt; trait.</source>
          <target state="translated">尝试移出其类型实现了 &lt;code&gt;Drop&lt;/code&gt; 特性的值时，会发生此错误。</target>
        </trans-unit>
        <trans-unit id="a382ee4f257c1e4d223e9634a0678761229064a5" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably.</source>
          <target state="translated">当试图变异或变异引用闭包已捕获的不变数据时,会发生此错误。</target>
        </trans-unit>
        <trans-unit id="b0cd32a89f254835e1067e05e21bdf36f5041728" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably. Examples of this error are shown below:</source>
          <target state="translated">当试图变异或变异地引用闭包已不可变异地捕获的数据时,就会发生此错误。这种错误的例子如下所示。</target>
        </trans-unit>
        <trans-unit id="6dbb4812461df19f2be9097a66c157fbdbf8c85f" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate the target of a mutable reference stored inside an immutable container.</source>
          <target state="translated">当试图突变存储在不可变容器中的可变引用的目标时,会发生此错误。</target>
        </trans-unit>
        <trans-unit id="e494d266acb1b46fd28c9cc0c8ca718e819da16c" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to partially reinitialize a structure that is currently uninitialized.</source>
          <target state="translated">当试图对当前未初始化的结构进行部分重新初始化时,会发生该错误。</target>
        </trans-unit>
        <trans-unit id="8feee21757ea4763c54c8d19077d7ff7e0dd5208" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to reassign an immutable variable. For example:</source>
          <target state="translated">当试图重新赋值一个不可变的变量时,会发生这个错误。例如:</target>
        </trans-unit>
        <trans-unit id="b105f193c377f1f9fe2f520a0094f3220a7d20d3" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use a variable after its contents have been moved elsewhere. For example:</source>
          <target state="translated">当一个变量的内容被移到其他地方后,试图使用该变量时,会发生该错误。例如:</target>
        </trans-unit>
        <trans-unit id="7658c866cb10684f9a43de713daa72ba91346907" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure as shown in the previous code example.</source>
          <target state="translated">当试图使用一个闭包捕获的数据时,当该数据可能不再存在时,就会发生这个错误。最常见的情况是在试图返回一个闭包时,如前面的代码示例所示。</target>
        </trans-unit>
        <trans-unit id="47a25aa9b1a97609269b45b233bf81af91519446" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure:</source>
          <target state="translated">当试图使用闭包捕获的数据时,会发生该错误,而该数据可能已不存在。最常见的是在试图返回一个闭包时。</target>
        </trans-unit>
        <trans-unit id="25b45e0aeb2d0b344f458087fd222c2b9143243a" translate="yes" xml:space="preserve">
          <source>This error occurs when an expression was used in a place where the compiler expected an expression of a different type. It can occur in several cases, the most common being when calling a function and passing an argument which has a different type than the matching type in the function declaration.</source>
          <target state="translated">当一个表达式被用于编译器期望的不同类型的表达式的地方时,就会发生这种错误。它可能发生在几种情况下,最常见的是当调用一个函数并传递一个与函数声明中匹配类型不同的参数时。</target>
        </trans-unit>
        <trans-unit id="fa2c4bec036eb23e59f4739f281ec16e241dd98a" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler doesn't have enough information to unambiguously choose an implementation.</source>
          <target state="translated">当编译器没有足够的信息来毫不含糊地选择一个实现时,就会出现这个错误。</target>
        </trans-unit>
        <trans-unit id="b03f07ba71f847bb7aaff9d23af91941f61b2264" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler is unable to infer the concrete type of a variable. It can occur in several cases, the most common being a mismatch between two types: the type the author explicitly assigned, and the type the compiler inferred.</source>
          <target state="translated">当编译器无法推断出一个变量的具体类型时,就会出现这个错误。有几种情况,最常见的是两种类型不匹配:作者明确指定的类型和编译器推断的类型。</target>
        </trans-unit>
        <trans-unit id="f68d6da4cba1c2fe73a0bdd6ed998a8c685d2f7a" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler is unable to unambiguously infer the return type of a function or method which is generic on return type, such as the &lt;code&gt;collect&lt;/code&gt; method for &lt;code&gt;Iterator&lt;/code&gt;s.</source>
          <target state="translated">当编译器无法明确推断出返回类型通用的函数或方法的返回类型（例如 &lt;code&gt;Iterator&lt;/code&gt; 的 &lt;code&gt;collect&lt;/code&gt; 方法）时，将发生此错误。</target>
        </trans-unit>
        <trans-unit id="f8852702dc84baa326e19b865b76e83190126314" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler was unable to infer the concrete type of a variable. It can occur for several cases, the most common of which is a mismatch in the expected type that the compiler inferred for a variable's initializing expression, and the actual type explicitly assigned to the variable.</source>
          <target state="translated">当编译器无法推断出一个变量的具体类型时,就会出现这个错误,它可能发生在几种情况下,最常见的是编译器为一个变量的初始化表达式推断的预期类型和明确分配给变量的实际类型不匹配。它可能发生在几种情况下,最常见的是编译器推断的变量初始化表达式的预期类型和实际类型不匹配。</target>
        </trans-unit>
        <trans-unit id="40572c6042150247d80f8e73ff85712050d543de" translate="yes" xml:space="preserve">
          <source>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. Often this means that there is unbounded recursion in resolving some type bounds.</source>
          <target state="translated">当有一个递归特质要求在被评估之前就已经溢出时,就会发生这个错误。通常这意味着在解析某些类型界限时存在无界递归。</target>
        </trans-unit>
        <trans-unit id="4c98fdf7c35ee8cb8fdd6e9ff309c4211fcf94cf" translate="yes" xml:space="preserve">
          <source>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. This often means that there is an unbounded recursion in resolving some type bounds.</source>
          <target state="translated">当有一个递归特性要求在被评估之前就已经溢出时,就会出现这个错误。这通常意味着在解析某些类型界限时存在无界递归。</target>
        </trans-unit>
        <trans-unit id="7b6569d564fb77649858b1d55f9d8b2a0efd5a34" translate="yes" xml:space="preserve">
          <source>This error occurs when you defined methods or associated functions with same name.</source>
          <target state="translated">当你定义的方法或关联函数名称相同时,会出现这个错误。</target>
        </trans-unit>
        <trans-unit id="31aab3dcb3c76822f5a50ebdbab3c624e3384795" translate="yes" xml:space="preserve">
          <source>This error points at a file we didn&amp;rsquo;t write, &lt;em&gt;libcore/slice/mod.rs&lt;/em&gt;. That&amp;rsquo;s the implementation of &lt;code&gt;slice&lt;/code&gt; in the Rust source code. The code that gets run when we use &lt;code&gt;[]&lt;/code&gt; on our vector &lt;code&gt;v&lt;/code&gt; is in &lt;em&gt;libcore/slice/mod.rs&lt;/em&gt;, and that is where the &lt;code&gt;panic!&lt;/code&gt; is actually happening.</source>
          <target state="translated">在文件此错误点，我们没有写，&lt;em&gt;libcore /片/ mod.rs&lt;/em&gt;。那就是Rust源代码中 &lt;code&gt;slice&lt;/code&gt; 的实现。在向量 &lt;code&gt;v&lt;/code&gt; 上使用 &lt;code&gt;[]&lt;/code&gt; 时运行的代码在&lt;em&gt;libcore / slice / mod.rs中&lt;/em&gt;，这就是 &lt;code&gt;panic!&lt;/code&gt; 实际上正在发生。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="daff356f50087f066d8d7f295e45f7db503c47eb" translate="yes" xml:space="preserve">
          <source>This error points out that we&amp;rsquo;re only allowed to use the &lt;code&gt;?&lt;/code&gt; operator in a function that returns &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When you&amp;rsquo;re writing code in a function that doesn&amp;rsquo;t return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, and you want to use &lt;code&gt;?&lt;/code&gt; when you call other functions that return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, you have two choices to fix this problem. One technique is to change the return type of your function to be &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; if you have no restrictions preventing that. The other technique is to use a &lt;code&gt;match&lt;/code&gt; or one of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; methods to handle the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in whatever way is appropriate.</source>
          <target state="translated">这个错误指出我们只允许使用 &lt;code&gt;?&lt;/code&gt; 返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 的函数中的运算符。在不返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 的函数中编写代码时，您想使用 &lt;code&gt;?&lt;/code&gt; 当您调用其他返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 函数时，有两种选择可以解决此问题。一种技术是在没有限制的情况下将函数的返回类型更改为 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 。另一种技术是使用 &lt;code&gt;match&lt;/code&gt; 或 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 方法之一来以适当的方式处理 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef0f484866e508390ede392520c4e2f457d726bf" translate="yes" xml:space="preserve">
          <source>This error points out that we&amp;rsquo;re only allowed to use the &lt;code&gt;?&lt;/code&gt; operator in a function that returns &lt;code&gt;Result&lt;/code&gt; or &lt;code&gt;Option&lt;/code&gt; or another type that implements &lt;code&gt;std::ops::Try&lt;/code&gt;. When you&amp;rsquo;re writing code in a function that doesn&amp;rsquo;t return one of these types, and you want to use &lt;code&gt;?&lt;/code&gt; when you call other functions that return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, you have two choices to fix this problem. One technique is to change the return type of your function to be &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; if you have no restrictions preventing that. The other technique is to use a &lt;code&gt;match&lt;/code&gt; or one of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; methods to handle the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in whatever way is appropriate.</source>
          <target state="translated">这个错误指出我们只允许使用 &lt;code&gt;?&lt;/code&gt; 返回 &lt;code&gt;Result&lt;/code&gt; 或 &lt;code&gt;Option&lt;/code&gt; 或实现 &lt;code&gt;std::ops::Try&lt;/code&gt; 其他类型的函数中的运算符。当您在不返回这些类型之一的函数中编写代码时，要使用 &lt;code&gt;?&lt;/code&gt; 当您调用返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 其他函数时，有两种选择可以解决此问题。一种技术是在没有限制的情况下将函数的返回类型更改为 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 。另一种技术是使用 &lt;code&gt;match&lt;/code&gt; 或 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 方法之一来处理 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 以任何合适的方式。</target>
        </trans-unit>
        <trans-unit id="f5d927c97470a6bdf532b94621efe13e0092f99e" translate="yes" xml:space="preserve">
          <source>This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression being matched, one of the preceding patterns will match.</source>
          <target state="translated">该错误表明,与所指出的模式相对应的表达式臂将永远不会达到,因为对于正在匹配的表达式的所有可能的值,前面的模式之一将匹配。</target>
        </trans-unit>
        <trans-unit id="f4cd2a99a6de016ca859c1b751566814099aa1c3" translate="yes" xml:space="preserve">
          <source>This error type&amp;rsquo;s methods can be used to create functionality similar to &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; without allocating heap memory:</source>
          <target state="translated">此错误类型的方法可用于创建类似于 &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; 功能，而无需分配堆内存：</target>
        </trans-unit>
        <trans-unit id="fb422fab14fffbfe5c78207ee2ae02a65418bd40" translate="yes" xml:space="preserve">
          <source>This error usually happens when trying to pass in a value to an input inline assembly operand that is actually a pair of values. In particular, this can happen when trying to pass in a slice, for instance a &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Rust, these values are represented internally as a pair of values, the pointer and its length. When passed as an input operand, this pair of values can not be coerced into a register and thus we must fail with an error.</source>
          <target state="translated">尝试将值传递给实际上是一对值的输入内联程序集操作数时，通常会发生此错误。特别是在尝试传递切片时，例如 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，可能会发生这种情况。在Rust中，这些值在内部表示为一对值，指针及其长度。当将这对值作为输入操作数传递时，不能将其强制转换为寄存器，因此我们必须因错误而失败。</target>
        </trans-unit>
        <trans-unit id="46906d1c89db9bd7d3aa62947de98893bb4109ab" translate="yes" xml:space="preserve">
          <source>This error was returned when attempting to write the internal buffer.</source>
          <target state="translated">当尝试写入内部缓冲区时,返回该错误。</target>
        </trans-unit>
        <trans-unit id="3d919bd775721ac4d8e4678ab5d56f5c5d828138" translate="yes" xml:space="preserve">
          <source>This error will be emitted by the compiler when using an invalid receiver type, like in the following example:</source>
          <target state="translated">当使用无效的接收器类型时,编译器会发出这个错误,就像下面的例子。</target>
        </trans-unit>
        <trans-unit id="6f5335a8d7c6f37faeab381d52fe1092a252bd8d" translate="yes" xml:space="preserve">
          <source>This example also shows how to use &lt;code&gt;move&lt;/code&gt;, in order to give ownership of values to a thread.</source>
          <target state="translated">此示例还显示了如何使用 &lt;code&gt;move&lt;/code&gt; ，以便将值的所有权授予线程。</target>
        </trans-unit>
        <trans-unit id="175716bea92c9d941f0898dc29c4ed209e64c353" translate="yes" xml:space="preserve">
          <source>This example builds a string, starting with an initial value and continuing with each element from the back until the front:</source>
          <target state="translated">这个例子建立了一个字符串,从一个初始值开始,从后面一直到前面的每个元素。</target>
        </trans-unit>
        <trans-unit id="4d013525fa73f401dcf7648ce7d8e69f8100f085" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements &lt;a href=&quot;trait.add&quot;&gt;&lt;code&gt;Add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.sub&quot;&gt;&lt;code&gt;Sub&lt;/code&gt;&lt;/a&gt;, and then demonstrates adding and subtracting two &lt;code&gt;Point&lt;/code&gt;s.</source>
          <target state="translated">本示例创建一个实现&lt;a href=&quot;trait.add&quot;&gt; &lt;code&gt;Add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.sub&quot;&gt; &lt;code&gt;Sub&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;Point&lt;/code&gt; 结构，然后演示添加和减去两个 &lt;code&gt;Point&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="612bd6352093018ae655e26b99b1150fb9f0d9dc" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements the &lt;code&gt;AddAssign&lt;/code&gt; trait, and then demonstrates add-assigning to a mutable &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="translated">本示例创建一个实现 &lt;code&gt;AddAssign&lt;/code&gt; 特性的 &lt;code&gt;Point&lt;/code&gt; 结构，然后演示对可变 &lt;code&gt;Point&lt;/code&gt; 的添加分配。</target>
        </trans-unit>
        <trans-unit id="84b61046cfa323fa19b23ac20e12034ef787e01b" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements the &lt;code&gt;SubAssign&lt;/code&gt; trait, and then demonstrates sub-assigning to a mutable &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="translated">本示例创建一个实现 &lt;code&gt;SubAssign&lt;/code&gt; 特性的 &lt;code&gt;Point&lt;/code&gt; 结构，然后演示向可变 &lt;code&gt;Point&lt;/code&gt; 的子分配。</target>
        </trans-unit>
        <trans-unit id="979ade7fbba01641154de5a065a6e6890cf54db4" translate="yes" xml:space="preserve">
          <source>This example creates a function with two parameters, both of which are &lt;code&gt;i32&lt;/code&gt; types. The function then prints the values in both of its parameters. Note that function parameters don&amp;rsquo;t all need to be the same type, they just happen to be in this example.</source>
          <target state="translated">本示例创建一个具有两个参数的函数，这两个参数均为 &lt;code&gt;i32&lt;/code&gt; 类型。然后，该函数在其两个参数中打印值。请注意，函数参数并不需要全部都是相同的类型，而在本示例中它们恰好是相同的。</target>
        </trans-unit>
        <trans-unit id="701db2e46c2038eecc101dd4ef0779ff5ad8d4cc" translate="yes" xml:space="preserve">
          <source>This example implements &lt;code&gt;Rem&lt;/code&gt; on a &lt;code&gt;SplitSlice&lt;/code&gt; object. After &lt;code&gt;Rem&lt;/code&gt; is implemented, one can use the &lt;code&gt;%&lt;/code&gt; operator to find out what the remaining elements of the slice would be after splitting it into equal slices of a given length.</source>
          <target state="translated">本示例在 &lt;code&gt;SplitSlice&lt;/code&gt; 对象上实现 &lt;code&gt;Rem&lt;/code&gt; 。实施 &lt;code&gt;Rem&lt;/code&gt; 后，可以使用 &lt;code&gt;%&lt;/code&gt; 运算符将切片拆分为给定长度的相等切片后，找出切片的其余元素。</target>
        </trans-unit>
        <trans-unit id="3d81c01c409b8ce1936b460c9219c2266b9648d9" translate="yes" xml:space="preserve">
          <source>This example prints 3, 2, and then 1. The &lt;code&gt;pop&lt;/code&gt; method takes the last element out of the vector and returns &lt;code&gt;Some(value)&lt;/code&gt;. If the vector is empty, &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;while&lt;/code&gt; loop continues running the code in its block as long as &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;Some&lt;/code&gt;. When &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, the loop stops. We can use &lt;code&gt;while let&lt;/code&gt; to pop every element off our stack.</source>
          <target state="translated">本示例打印3、2，然后打印 &lt;code&gt;pop&lt;/code&gt; 方法将最后一个元素从向量中取出，并返回 &lt;code&gt;Some(value)&lt;/code&gt; 。如果向量为空，则 &lt;code&gt;pop&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; 。只要 &lt;code&gt;pop&lt;/code&gt; 返回 &lt;code&gt;Some&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 循环就会继续在其块中运行代码。当 &lt;code&gt;pop&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; 时，循环停止。我们可以在使用 &lt;code&gt;while let&lt;/code&gt; 将每个元素弹出堆栈。</target>
        </trans-unit>
        <trans-unit id="1f29d652e237479a6c170562a3189e4859a56b5e" translate="yes" xml:space="preserve">
          <source>This example shows an inner attribute on a function. The function is documented with just the word &quot;Example&quot;.</source>
          <target state="translated">这个例子展示了一个函数的内部属性。这个函数只用 &quot;Example &quot;一词来记录。</target>
        </trans-unit>
        <trans-unit id="33bd3bf0b7b00466cfe4514bc631cc4d45b75356" translate="yes" xml:space="preserve">
          <source>This example shows an inner attribute on a function. The function will only be available while running tests.</source>
          <target state="translated">这个例子显示了一个函数的内部属性。该函数只有在运行测试时才能使用。</target>
        </trans-unit>
        <trans-unit id="02dcd48945408a840f3079c83663da1b30b196c7" translate="yes" xml:space="preserve">
          <source>This example shows how one can use &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;warn&lt;/code&gt; to toggle a particular check on and off:</source>
          <target state="translated">此示例显示了如何使用 &lt;code&gt;allow&lt;/code&gt; 和 &lt;code&gt;warn&lt;/code&gt; 来启用和禁用特定检查：</target>
        </trans-unit>
        <trans-unit id="b51a82804a004969c18f750e315e49a925f322a3" translate="yes" xml:space="preserve">
          <source>This example shows how one can use &lt;code&gt;forbid&lt;/code&gt; to disallow uses of &lt;code&gt;allow&lt;/code&gt; for that lint check:</source>
          <target state="translated">这个例子显示了一个如何使用 &lt;code&gt;forbid&lt;/code&gt; 来的不允许使用 &lt;code&gt;allow&lt;/code&gt; 的皮棉检查：</target>
        </trans-unit>
        <trans-unit id="20dcd5999998e80d936e0fa700c4a9a09932a423" translate="yes" xml:space="preserve">
          <source>This example shows how the compiler helps you find errors in your programs. Even though compiler errors can be frustrating, they only mean your program isn&amp;rsquo;t safely doing what you want it to do yet; they do &lt;em&gt;not&lt;/em&gt; mean that you&amp;rsquo;re not a good programmer! Experienced Rustaceans still get compiler errors.</source>
          <target state="translated">此示例说明了编译器如何帮助您发现程序中的错误。即使编译器错误令人沮丧，它们仅表示您的程序尚未安全地执行您想要的操作；它们&lt;em&gt;并不&lt;/em&gt;意味着您不是一个好的程序员！有经验的Rustaceans仍然会遇到编译器错误。</target>
        </trans-unit>
        <trans-unit id="2cb4570e4e31d810429621e0a69fd89abfdb2ea3" translate="yes" xml:space="preserve">
          <source>This example shows using a custom derive attribute to modify the meaning of a generic parameter.</source>
          <target state="translated">这个例子展示了使用自定义派生属性来修改通用参数的含义。</target>
        </trans-unit>
        <trans-unit id="e1b71afb4f7ccdfd339dd3d129a43084a3b35c6b" translate="yes" xml:space="preserve">
          <source>This example spawns a thread which will update the boolean value and then wait 100 milliseconds before notifying the condvar.</source>
          <target state="translated">这个例子产生了一个线程,这个线程将更新布尔值,然后在通知condvar之前等待100毫秒。</target>
        </trans-unit>
        <trans-unit id="b7617cea2234e7524bc25112d50668635c06f962" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;Found an id in range: 5&lt;/code&gt;. By specifying &lt;code&gt;id_variable @&lt;/code&gt; before the range &lt;code&gt;3...7&lt;/code&gt;, we&amp;rsquo;re capturing whatever value matched the range while also testing that the value matched the range pattern.</source>
          <target state="translated">本示例将打印 &lt;code&gt;Found an id in range: 5&lt;/code&gt; 。通过在范围 &lt;code&gt;3...7&lt;/code&gt; 之前指定 &lt;code&gt;id_variable @&lt;/code&gt; ，我们可以捕获与范围匹配的任何值，同时还要测试该值是否与范围模式匹配。</target>
        </trans-unit>
        <trans-unit id="6bcb3e1c80011a7567e2eb18a8ff65f6e860aa55" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;Found an id in range: 5&lt;/code&gt;. By specifying &lt;code&gt;id_variable @&lt;/code&gt; before the range &lt;code&gt;3..=7&lt;/code&gt;, we&amp;rsquo;re capturing whatever value matched the range while also testing that the value matched the range pattern.</source>
          <target state="translated">本示例将打印 &lt;code&gt;Found an id in range: 5&lt;/code&gt; 。通过在范围 &lt;code&gt;3..=7&lt;/code&gt; 之前指定 &lt;code&gt;id_variable @&lt;/code&gt; ，我们捕获了与范围匹配的任何值，同时还测试了该值是否与范围模式匹配。</target>
        </trans-unit>
        <trans-unit id="0792a7553f859fe5307a072fac84a140057b4ecf" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;less than five: 4&lt;/code&gt;. When &lt;code&gt;num&lt;/code&gt; is compared to the pattern in the first arm, it matches, because &lt;code&gt;Some(4)&lt;/code&gt; matches &lt;code&gt;Some(x)&lt;/code&gt;. Then the match guard checks whether the value in &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;5&lt;/code&gt;, and because it is, the first arm is selected.</source>
          <target state="translated">此示例将打印 &lt;code&gt;less than five: 4&lt;/code&gt; 。将 &lt;code&gt;num&lt;/code&gt; 与第一个手臂中的模式进行比较时，它会匹配，因为 &lt;code&gt;Some(4)&lt;/code&gt; 匹配 &lt;code&gt;Some(x)&lt;/code&gt; 。然后，比赛防护器检查 &lt;code&gt;x&lt;/code&gt; 中的值是否小于 &lt;code&gt;5&lt;/code&gt; ，并且因为是，所以选择了第一个手臂。</target>
        </trans-unit>
        <trans-unit id="e9c51ef5db1956234586460cd5d4e3f2d56f3c15" translate="yes" xml:space="preserve">
          <source>This exists solely for &lt;a href=&quot;../mem/fn.forget_unsized&quot;&gt;&lt;code&gt;mem::forget_unsized&lt;/code&gt;&lt;/a&gt;; normal &lt;code&gt;forget&lt;/code&gt; uses &lt;code&gt;ManuallyDrop&lt;/code&gt; instead.</source>
          <target state="translated">仅存在于&lt;a href=&quot;../mem/fn.forget_unsized&quot;&gt; &lt;code&gt;mem::forget_unsized&lt;/code&gt; &lt;/a&gt; ; 通常 &lt;code&gt;forget&lt;/code&gt; 使用 &lt;code&gt;ManuallyDrop&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="13f35b34cb9f0940df9ede968c0941933fe5a63e" translate="yes" xml:space="preserve">
          <source>This explicitly states that you expect the trait object &lt;code&gt;SomeTrait&lt;/code&gt; to contain references (with a maximum lifetime of &lt;code&gt;'a&lt;/code&gt;).</source>
          <target state="translated">这明确表明您希望特征对象 &lt;code&gt;SomeTrait&lt;/code&gt; 包含引用（最大生存期为 &lt;code&gt;'a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="55550702354f0f532a45a47534287ba31230892e" translate="yes" xml:space="preserve">
          <source>This expression:</source>
          <target state="translated">这种说法。</target>
        </trans-unit>
        <trans-unit id="d4d243a04a2e7c3baa5aaa70386526d20f9c61fb" translate="yes" xml:space="preserve">
          <source>This fails because &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is not &lt;code&gt;Copy&lt;/code&gt;, even when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt; (this differs from the behavior for &lt;code&gt;&amp;amp;T&lt;/code&gt;, which is always &lt;code&gt;Copy&lt;/code&gt;).</source>
          <target state="translated">这失败是因为 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 不是 &lt;code&gt;Copy&lt;/code&gt; ，即使 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;Copy&lt;/code&gt; （这与 &lt;code&gt;&amp;amp;T&lt;/code&gt; 的行为（始终为 &lt;code&gt;Copy&lt;/code&gt; ）不同）。</target>
        </trans-unit>
        <trans-unit id="96a49ec58cf9d3de1eca61f7643ce5de9d8c4e5e" translate="yes" xml:space="preserve">
          <source>This fails because &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt; for any &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">之所以失败，是因为 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 没有为任何 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77c78e0cdd88af63c9805574659b7e0844c8f178" translate="yes" xml:space="preserve">
          <source>This fails to compile because &lt;code&gt;T&lt;/code&gt; does not appear in the trait or in the implementing type.</source>
          <target state="translated">由于 &lt;code&gt;T&lt;/code&gt; 没有出现在特征或实现类型中，因此无法编译。</target>
        </trans-unit>
        <trans-unit id="586c08bc607fd5a338c048e0f30142b22328caf5" translate="yes" xml:space="preserve">
          <source>This field contains the file system attribute information for a file or directory. For possible values and their descriptions, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants&quot;&gt;File Attribute Constants&lt;/a&gt; in the Windows Dev Center.</source>
          <target state="translated">该字段包含文件或目录的文件系统属性信息。有关可能的值及其说明，请参见Windows Dev Center中的&amp;ldquo;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants&quot;&gt;文件属性常数&lt;/a&gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0c5af671ad45076c8c92a16a6b71ec7dd6cf3c8d" translate="yes" xml:space="preserve">
          <source>This field contains the file system attribute information for a file or directory. For possible values and their descriptions, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;File Attribute Constants&lt;/a&gt; in the Windows Dev Center.</source>
          <target state="translated">该字段包含文件或目录的文件系统属性信息。有关可能的值及其说明，请参见Windows Dev Center中的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;文件属性常量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a06da2f86acca1e87efa6c64e9e56d6bba45e46d" translate="yes" xml:space="preserve">
          <source>This field may not be available on all platforms, and will return an &lt;code&gt;Err&lt;/code&gt; on platforms or filesystems where it is not available.</source>
          <target state="translated">此字段可能并非在所有平台上都可用，并且会在不可用的平台或文件系统上返回 &lt;code&gt;Err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fed8ac050f10d4961483960b90a8bb5fa116bf7c" translate="yes" xml:space="preserve">
          <source>This field may not be available on all platforms, and will return an &lt;code&gt;Err&lt;/code&gt; on platforms where it is not available.</source>
          <target state="translated">此字段可能并非在所有平台上都可用，并且会在不可用的平台上返回 &lt;code&gt;Err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5368359fd79a3572b28925e44099327d749ce6f1" translate="yes" xml:space="preserve">
          <source>This file is in the &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;Tom&amp;rsquo;s Obvious, Minimal Language&lt;/em&gt;) format, which is Cargo&amp;rsquo;s configuration format.</source>
          <target state="translated">该文件采用&lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt;（&lt;em&gt;汤姆的最小语言&lt;/em&gt;）格式，这是Cargo的配置格式。</target>
        </trans-unit>
        <trans-unit id="403b498b0ea95a8401971fc9fa18c953b57bf6c7" translate="yes" xml:space="preserve">
          <source>This file is in the &lt;a href=&quot;https://toml.io&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;Tom&amp;rsquo;s Obvious, Minimal Language&lt;/em&gt;) format, which is Cargo&amp;rsquo;s configuration format.</source>
          <target state="translated">该文件为&lt;a href=&quot;https://toml.io&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt;（&lt;em&gt;汤姆的通俗易懂的最小语言&lt;/em&gt;）格式，这是Cargo的配置格式。</target>
        </trans-unit>
        <trans-unit id="f0537f20b3c4c0b16d4802ffcd175906f9816b83" translate="yes" xml:space="preserve">
          <source>This following example shows the stringified &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;s&lt;/a&gt; that the attribute macros see. The output will show in the output of the compiler. The output is shown in the comments after the function prefixed with &quot;out:&quot;.</source>
          <target state="translated">这下面的示例演示将字符串&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; 小号&lt;/a&gt;的属性宏见。输出将显示在编译器的输出中。在以&amp;ldquo; out：&amp;rdquo;为前缀的函数之后，输出显示在注释中。</target>
        </trans-unit>
        <trans-unit id="a9c265b88652152ca2b28f53cb136d7ff3a25c8d" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;consumes ownership&lt;/strong&gt; of the specified file descriptor. The returned object will take responsibility for closing it when the object goes out of scope.</source>
          <target state="translated">此函数&lt;strong&gt;消耗&lt;/strong&gt;指定文件描述符的&lt;strong&gt;所有权&lt;/strong&gt;。当对象超出范围时，返回的对象将负责关闭它。</target>
        </trans-unit>
        <trans-unit id="7770f6814daf86198289168c0cb8b4e0eaa39b97" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying file descriptor to the caller. Callers are then the unique owners of the file descriptor and must close the descriptor once it's no longer needed.</source>
          <target state="translated">此函数&lt;strong&gt;将&lt;/strong&gt;基础文件描述符的&lt;strong&gt;所有权转移&lt;/strong&gt;给调用方。这样，调用者便是文件描述符的唯一所有者，一旦不再需要描述符，必须将其关闭。</target>
        </trans-unit>
        <trans-unit id="9e16870fdc5324388fb513d47d710cb2a9d23e70" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying handle to the caller. Callers are then the unique owners of the handle and must close it once it's no longer needed.</source>
          <target state="translated">此函数&lt;strong&gt;将&lt;/strong&gt;基础句柄的&lt;strong&gt;所有权转移&lt;/strong&gt;给调用方。这样，调用方便是该句柄的唯一所有者，一旦不再需要它就必须关闭它。</target>
        </trans-unit>
        <trans-unit id="90c9a08f16b0c10b615b5b0843cebfac39017e99" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying pthread_t to the caller. Callers are then the unique owners of the pthread_t and must either detach or join the pthread_t once it's no longer needed.</source>
          <target state="translated">此函数&lt;strong&gt;将&lt;/strong&gt;基础pthread_t的&lt;strong&gt;所有权转让&lt;/strong&gt;给调用方。这样，调用方便是pthread_t的唯一所有者，一旦不再需要，则必须分离或加入pthread_t。</target>
        </trans-unit>
        <trans-unit id="06669b18e93261495eb1fcf2252cb895da69c39a" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying socket to the caller. Callers are then the unique owners of the socket and must close it once it's no longer needed.</source>
          <target state="translated">此函数&lt;strong&gt;将&lt;/strong&gt;基础套接字的&lt;strong&gt;所有权转移&lt;/strong&gt;给调用方。这样，调用方便是套接字的唯一所有者，并且在不再需要套接字时必须将其关闭。</target>
        </trans-unit>
        <trans-unit id="3028ce76268abc4493b0febc5668a0c85baa5e06" translate="yes" xml:space="preserve">
          <source>This function accepts strings such as</source>
          <target state="translated">该函数接受的字符串包括</target>
        </trans-unit>
        <trans-unit id="3b6b07c29d146488fec502f1e37e5fcc2f92d5fd" translate="yes" xml:space="preserve">
          <source>This function allows inspecting the location, in code, of where an error happened. The returned &lt;code&gt;Backtrace&lt;/code&gt; contains information about the stack trace of the OS thread of execution of where the error originated from.</source>
          <target state="translated">此功能允许在代码中检查发生错误的位置。返回的 &lt;code&gt;Backtrace&lt;/code&gt; 包含有关执行错误来源的OS线程的堆栈跟踪的信息。</target>
        </trans-unit>
        <trans-unit id="dcca4cdb6fc324905436b470716282df197ae1a7" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;code&gt;capture&lt;/code&gt; except that it ignores the values of the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; and &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; environment variables, always capturing a backtrace.</source>
          <target state="translated">该函数的行为与 &lt;code&gt;capture&lt;/code&gt; 相同，只是它忽略 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 和 &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; 环境变量的值，始终捕获回溯。</target>
        </trans-unit>
        <trans-unit id="e1eb2ceefa3b664d9a9270981fa8cbdd469bffdd" translate="yes" xml:space="preserve">
          <source>This function can be used for control flow based on &lt;code&gt;Result&lt;/code&gt; values.</source>
          <target state="translated">此功能可用于基于&amp;ldquo; &lt;code&gt;Result&lt;/code&gt; 值的控制流。</target>
        </trans-unit>
        <trans-unit id="069d719c6868f05d1ad9a84a0abe1540eb6a83ca" translate="yes" xml:space="preserve">
          <source>This function can be used for control flow based on result values.</source>
          <target state="translated">该功能可用于基于结果值的控制流。</target>
        </trans-unit>
        <trans-unit id="1f2e8570607d30aa900e189937d7916fe8ed3230" translate="yes" xml:space="preserve">
          <source>This function can be used to compose the results of two functions.</source>
          <target state="translated">这个函数可以用来合成两个函数的结果。</target>
        </trans-unit>
        <trans-unit id="890b1ba5d17963460809400c8357e2da154ed2a6" translate="yes" xml:space="preserve">
          <source>This function can be used to pass through a successful result while handling an error.</source>
          <target state="translated">这个函数可以用来在处理错误时传递成功的结果。</target>
        </trans-unit>
        <trans-unit id="f898974fbfac52e97eb29d82afb416cf7dbf9a7a" translate="yes" xml:space="preserve">
          <source>This function can be used to unpack a successful result while handling an error.</source>
          <target state="translated">这个函数可以用来在处理错误的同时解开一个成功的结果。</target>
        </trans-unit>
        <trans-unit id="663e29d3010e4fe834fdfef457c75d87463c66ed" translate="yes" xml:space="preserve">
          <source>This function can be written in a much shorter way, but we&amp;rsquo;re going to start by doing a lot of it manually in order to explore error handling; at the end, we&amp;rsquo;ll show the shorter way. Let&amp;rsquo;s look at the return type of the function first: &lt;code&gt;Result&amp;lt;String, io::Error&amp;gt;&lt;/code&gt;. This means the function is returning a value of the type &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; where the generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in with the concrete type &lt;code&gt;String&lt;/code&gt; and the generic type &lt;code&gt;E&lt;/code&gt; has been filled in with the concrete type &lt;code&gt;io::Error&lt;/code&gt;. If this function succeeds without any problems, the code that calls this function will receive an &lt;code&gt;Ok&lt;/code&gt; value that holds a &lt;code&gt;String&lt;/code&gt;&amp;mdash;the username that this function read from the file. If this function encounters any problems, the code that calls this function will receive an &lt;code&gt;Err&lt;/code&gt; value that holds an instance of &lt;code&gt;io::Error&lt;/code&gt; that contains more information about what the problems were. We chose &lt;code&gt;io::Error&lt;/code&gt; as the return type of this function because that happens to be the type of the error value returned from both of the operations we&amp;rsquo;re calling in this function&amp;rsquo;s body that might fail: the &lt;code&gt;File::open&lt;/code&gt; function and the &lt;code&gt;read_to_string&lt;/code&gt; method.</source>
          <target state="translated">可以用更短的方式编写此函数，但是为了探索错误处理，我们将首先手动进行很多操作。最后，我们将展示较短的方法。首先让我们看一下函数的返回类型： &lt;code&gt;Result&amp;lt;String, io::Error&amp;gt;&lt;/code&gt; 。这意味着函数将返回类型 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 的值，其中通用参数 &lt;code&gt;T&lt;/code&gt; 已用具体类型 &lt;code&gt;String&lt;/code&gt; 填充，而通用类型 &lt;code&gt;E&lt;/code&gt; 已用具体类型 &lt;code&gt;io::Error&lt;/code&gt; 填充。如果此函数成功执行而没有任何问题，则调用此函数的代码将收到一个包含 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;Ok&lt;/code&gt; 值。&amp;mdash;此函数从文件读取的用户名。如果此函数遇到任何问题，则调用此函数的代码将收到一个 &lt;code&gt;Err&lt;/code&gt; 值，其中包含 &lt;code&gt;io::Error&lt;/code&gt; 实例，该实例包含有关问题所在的更多信息。我们选择 &lt;code&gt;io::Error&lt;/code&gt; 作为此函数的返回类型，因为这恰好是我们在函数体内调用的两个操作可能返回的错误值的类型： &lt;code&gt;File::open&lt;/code&gt; 函数和 &lt;code&gt;read_to_string&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="cb45099429d3a43cd1fd9c5de5abe0335d7b7e9d" translate="yes" xml:space="preserve">
          <source>This function corresponds to &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;std::mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数对应于&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;std::mem::replace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc55369db6754d8ec7579c34bfc5b97438f6a7f6" translate="yes" xml:space="preserve">
          <source>This function corresponds to &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;std::mem::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数对应于&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;std::mem::swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac167c5922dc46db61626cca7bc837d30e8e8d77" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt; functions on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt;, &lt;code&gt;GetFileAttributesEx&lt;/code&gt;, &lt;code&gt;DeleteFile&lt;/code&gt;, and &lt;code&gt;RemoveDirectory&lt;/code&gt; functions on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">此函数当前对应于Unix上的 &lt;code&gt;opendir&lt;/code&gt; ， &lt;code&gt;lstat&lt;/code&gt; ， &lt;code&gt;rm&lt;/code&gt; 和 &lt;code&gt;rmdir&lt;/code&gt; 函数，以及Windows 上的 &lt;code&gt;FindFirstFile&lt;/code&gt; ， &lt;code&gt;GetFileAttributesEx&lt;/code&gt; ， &lt;code&gt;DeleteFile&lt;/code&gt; 和 &lt;code&gt;RemoveDirectory&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bea785a55c87ae52504d49f8f95ea16d8aa3ce9e" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;chmod&lt;/code&gt; function on Unix and the &lt;code&gt;SetFileAttributes&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;chmod&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;SetFileAttributes&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04e383479b2228c3ffffa98975698e9dda256dbb" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;fchmod&lt;/code&gt; function on Unix and the &lt;code&gt;SetFileInformationByHandle&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该功能目前对应于 &lt;code&gt;fchmod&lt;/code&gt; 在Unix功能和 &lt;code&gt;SetFileInformationByHandle&lt;/code&gt; 在Windows功能。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0176ddcd073fa8b60d6460114db8d5951e367349" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;link&lt;/code&gt; function on Unix and the &lt;code&gt;CreateHardLink&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;link&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;CreateHardLink&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21169ffe61676853807722591cc30f485744220c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;linkat&lt;/code&gt; function with no flags on Unix and the &lt;code&gt;CreateHardLink&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该功能目前对应于 &lt;code&gt;linkat&lt;/code&gt; 用在Unix上没有任何标志和功能 &lt;code&gt;CreateHardLink&lt;/code&gt; 在Windows功能。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01e2694d82da90e8f24cd10e750a58377e07410c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;lstat&lt;/code&gt; function on Unix and the &lt;code&gt;GetFileAttributesEx&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;lstat&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;GetFileAttributesEx&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3537e3f2c9af1f7a17489b68fe05b364816b75fc" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;mkdir&lt;/code&gt; function on Unix and the &lt;code&gt;CreateDirectory&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;mkdir&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;CreateDirectory&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ffbba2d718a3b3920d07fee5dfb64d2a84ce583" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;open&lt;/code&gt; function in Unix with &lt;code&gt;O_RDONLY&lt;/code&gt; for &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;O_WRONLY&lt;/code&gt;, &lt;code&gt;O_CREAT&lt;/code&gt;, and &lt;code&gt;O_TRUNC&lt;/code&gt; for &lt;code&gt;to&lt;/code&gt;. &lt;code&gt;O_CLOEXEC&lt;/code&gt; is set for returned file descriptors. On Windows, this function currently corresponds to &lt;code&gt;CopyFileEx&lt;/code&gt;. Alternate NTFS streams are copied but only the size of the main stream is returned by this function. On MacOS, this function corresponds to &lt;code&gt;fclonefileat&lt;/code&gt; and &lt;code&gt;fcopyfile&lt;/code&gt;. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该功能目前对应于 &lt;code&gt;open&lt;/code&gt; 的Unix的功能与 &lt;code&gt;O_RDONLY&lt;/code&gt; 用于 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;O_WRONLY&lt;/code&gt; ， &lt;code&gt;O_CREAT&lt;/code&gt; 和 &lt;code&gt;O_TRUNC&lt;/code&gt; 为 &lt;code&gt;to&lt;/code&gt; 。为返回的文件描述符设置 &lt;code&gt;O_CLOEXEC&lt;/code&gt; 。在Windows上，此功能当前对应于 &lt;code&gt;CopyFileEx&lt;/code&gt; 。复制备用NTFS流，但此函数仅返回主流的大小。在MacOS上，此功能对应于 &lt;code&gt;fclonefileat&lt;/code&gt; 和 &lt;code&gt;fcopyfile&lt;/code&gt; 。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69a3d5683d593b686853078a406cbc99ddb7840f" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;opendir&lt;/code&gt; function on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt; function on Windows. Advancing the iterator currently corresponds to &lt;code&gt;readdir&lt;/code&gt; on Unix and &lt;code&gt;FindNextFile&lt;/code&gt; on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix上的 &lt;code&gt;opendir&lt;/code&gt; 函数和Windows上的 &lt;code&gt;FindFirstFile&lt;/code&gt; 函数。推进迭代器当前对应于Unix上的 &lt;code&gt;readdir&lt;/code&gt; 和Windows上的 &lt;code&gt;FindNextFile&lt;/code&gt; 。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85bdcb1c22d0b90cfc515b44a49195abde2937e0" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;opendir&lt;/code&gt; function on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;opendir&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;FindFirstFile&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6d0089b9c1b95a34e4ecb4a009ec095c9db172d" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;readlink&lt;/code&gt; function on Unix and the &lt;code&gt;CreateFile&lt;/code&gt; function with &lt;code&gt;FILE_FLAG_OPEN_REPARSE_POINT&lt;/code&gt; and &lt;code&gt;FILE_FLAG_BACKUP_SEMANTICS&lt;/code&gt; flags on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;readlink&lt;/code&gt; 函数以及Windows上带有 &lt;code&gt;FILE_FLAG_OPEN_REPARSE_POINT&lt;/code&gt; 和 &lt;code&gt;FILE_FLAG_BACKUP_SEMANTICS&lt;/code&gt; 标志的 &lt;code&gt;CreateFile&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83d811fb4fcc08f1492a059a3536fbb7a2a90ca2" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;realpath&lt;/code&gt; function on Unix and the &lt;code&gt;CreateFile&lt;/code&gt; and &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; functions on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;realpath&lt;/code&gt; 函数以及Windows上的 &lt;code&gt;CreateFile&lt;/code&gt; 和 &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8892007c2c9e02432f47cff4848a4e40ebbc10c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;rename&lt;/code&gt; function on Unix and the &lt;code&gt;MoveFileEx&lt;/code&gt; function with the &lt;code&gt;MOVEFILE_REPLACE_EXISTING&lt;/code&gt; flag on Windows.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;rename&lt;/code&gt; 函数和Windows上带有 &lt;code&gt;MOVEFILE_REPLACE_EXISTING&lt;/code&gt; 标志的 &lt;code&gt;MoveFileEx&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="8dd8f559f50531dc710476fe85e80e2f8d9753bd" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;rmdir&lt;/code&gt; function on Unix and the &lt;code&gt;RemoveDirectory&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;rmdir&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;RemoveDirectory&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b504889b373cb94fdb7ee56e28d937c2f36d6f0b" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;stat&lt;/code&gt; function on Unix and the &lt;code&gt;GetFileAttributesEx&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;stat&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;GetFileAttributesEx&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6672293739936665c26201ef3156432a0e98fd87" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;unlink&lt;/code&gt; function on Unix and the &lt;code&gt;DeleteFile&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;unlink&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;DeleteFile&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c94bdac48da7a0fc40fd1e5a086497b625f64825" translate="yes" xml:space="preserve">
          <source>This function does &lt;strong&gt;not&lt;/strong&gt; follow symbolic links and it will simply remove the symbolic link itself.</source>
          <target state="translated">此功能&lt;strong&gt;不&lt;/strong&gt;遵循符号链接，它会直接删除符号链接本身。</target>
        </trans-unit>
        <trans-unit id="977a8c203f0461d37e9d1afc3c85702bdcf54979" translate="yes" xml:space="preserve">
          <source>This function does not block.</source>
          <target state="translated">此功能不阻塞。</target>
        </trans-unit>
        <trans-unit id="99013d0e9f610e4b4ac531acb8d3cae6c5f35caf" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read and cannot, it will typically signal this via an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="translated">该函数不提供有关是否阻塞等待数据的任何保证，但是如果对象需要阻塞而无法读取，则通常会通过&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;返回值来发出信号。</target>
        </trans-unit>
        <trans-unit id="6f6f2506f47f0d38fd935eda8f1d3f32af31d36c" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="translated">该函数不提供有关是否阻塞等待数据的任何保证，但是如果对象需要阻塞以进行读取，但通常不能通过&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;返回值来发信号通知此对象。</target>
        </trans-unit>
        <trans-unit id="c9eb6fee31ded1ada354009451436d0884930106" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">该功能并不保证有争议的读者或作者是否会先获得锁的顺序。</target>
        </trans-unit>
        <trans-unit id="710d2720b9947751fee0e57d2b8d496c47712e72" translate="yes" xml:space="preserve">
          <source>This function does not resolve trait objects, meaning that &lt;code&gt;type_name_of_val(&amp;amp;7u32 as &amp;amp;dyn Debug)&lt;/code&gt; may return &lt;code&gt;&quot;dyn Debug&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;u32&quot;&lt;/code&gt;.</source>
          <target state="translated">此函数不会解析特征对象，这意味着 &lt;code&gt;type_name_of_val(&amp;amp;7u32 as &amp;amp;dyn Debug)&lt;/code&gt; 可能返回 &lt;code&gt;&quot;dyn Debug&quot;&lt;/code&gt; ，而不是 &lt;code&gt;&quot;u32&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4305826482cc10423eedc0c48122ffd5b51fb63b" translate="yes" xml:space="preserve">
          <source>This function doesn't create the file if it doesn't exist. Use the &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt; method to do so.</source>
          <target state="translated">如果该文件不存在，则该函数不会创建该文件。使用&lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;create&lt;/code&gt; &lt;/a&gt;方法这样做。</target>
        </trans-unit>
        <trans-unit id="33592db8fb3f9eb9295ccd92b371a923eae06e5a" translate="yes" xml:space="preserve">
          <source>This function doesn't create the file if it doesn't exist. Use the &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;OpenOptions::create&lt;/code&gt;&lt;/a&gt; method to do so.</source>
          <target state="translated">如果该文件不存在，则该函数不会创建该文件。使用&lt;a href=&quot;struct.openoptions#method.create&quot;&gt; &lt;code&gt;OpenOptions::create&lt;/code&gt; &lt;/a&gt;方法来执行此操作。</target>
        </trans-unit>
        <trans-unit id="c2ecd58992bf3950332fa012ed014d7ac0b8bc7f" translate="yes" xml:space="preserve">
          <source>This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it&amp;rsquo;s less than or equal to the length. The assertion means that if we pass an index that is greater than the index to split the slice at, the function will panic before it attempts to use that index.</source>
          <target state="translated">此函数首先获取切片的总长度。然后，通过检查其长度是否小于或等于该长度，断言作为参数给出的索引在切片内。该断言意味着，如果我们传递一个大于索引的索引来分割切片，该函数将在尝试使用该索引之前发生恐慌。</target>
        </trans-unit>
        <trans-unit id="ef704585a456099301abe7c7cdfceffbef996018" translate="yes" xml:space="preserve">
          <source>This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it&amp;rsquo;s less than or equal to the length. The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.</source>
          <target state="translated">此函数首先获取切片的总长度。然后，通过检查其长度是否小于或等于该长度，断言作为参数给出的索引在切片内。该断言意味着，如果我们传递的索引大于分割切片的长度，则该函数将在尝试使用该索引之前发生恐慌。</target>
        </trans-unit>
        <trans-unit id="457e092a949142d636a9e03fab0c159238f5daa4" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;&lt;code&gt;GlobalAlloc::alloc_zeroed&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此函数将调用转发到已使用 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性注册的分配器的&lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt; &lt;code&gt;GlobalAlloc::alloc_zeroed&lt;/code&gt; &lt;/a&gt;方法（如果存在的话），或将其作为 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值。</target>
        </trans-unit>
        <trans-unit id="dac6968f4833b95b4cfc0a37edb3317e41dafb8d" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#method.realloc&quot;&gt;&lt;code&gt;GlobalAlloc::realloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此函数将调用转发到已使用 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性注册的分配器的&lt;a href=&quot;trait.globalalloc#method.realloc&quot;&gt; &lt;code&gt;GlobalAlloc::realloc&lt;/code&gt; &lt;/a&gt;方法（如果存在的话），或者是 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值。</target>
        </trans-unit>
        <trans-unit id="0ee226de8b2847b4bcaa66f0141bab39ef9c2e4e" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;&lt;code&gt;GlobalAlloc::alloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此函数将调用转发到已使用 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性注册的分配器的&lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt; &lt;code&gt;GlobalAlloc::alloc&lt;/code&gt; &lt;/a&gt;方法（如果存在的话），或将其作为 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值。</target>
        </trans-unit>
        <trans-unit id="43408a3e60cf657f5104a853eae37001a5663e2b" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#tymethod.dealloc&quot;&gt;&lt;code&gt;GlobalAlloc::dealloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此函数将调用转发到已使用 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性注册的分配器的&lt;a href=&quot;trait.globalalloc#tymethod.dealloc&quot;&gt; &lt;code&gt;GlobalAlloc::dealloc&lt;/code&gt; &lt;/a&gt;方法（如果存在的话），或将其作为 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值。</target>
        </trans-unit>
        <trans-unit id="438ebff47f84838c22c79fbc8bfdda182cd513dc" translate="yes" xml:space="preserve">
          <source>This function gets called when a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; gets dropped.</source>
          <target state="translated">删除&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;时将调用此函数。</target>
        </trans-unit>
        <trans-unit id="13819f0b7aa144e5ea6bcb9cc9f9a6808e198851" translate="yes" xml:space="preserve">
          <source>This function has the same error semantics as &lt;a href=&quot;#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; and will also return an error if the read bytes are not valid UTF-8. If an I/O error is encountered then &lt;code&gt;buf&lt;/code&gt; may contain some bytes already read in the event that all data read so far was valid UTF-8.</source>
          <target state="translated">该函数具有与&lt;a href=&quot;#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt;相同的错误语义，并且如果读取的字节无效的UTF-8，还将返回错误。如果遇到I / O错误，则 &lt;code&gt;buf&lt;/code&gt; 可能包含一些字节，如果到目前为止已读取的所有数据均为有效UTF-8，则该字节已被读取。</target>
        </trans-unit>
        <trans-unit id="2b30023fb932961fde08dc32d5756888772fda90" translate="yes" xml:space="preserve">
          <source>This function has the same error semantics as &lt;a href=&quot;trait.bufread#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; and will also return an error if the read bytes are not valid UTF-8. If an I/O error is encountered then &lt;code&gt;buf&lt;/code&gt; may contain some bytes already read in the event that all data read so far was valid UTF-8.</source>
          <target state="translated">该函数具有与&lt;a href=&quot;trait.bufread#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt;相同的错误语义，并且如果读取的字节无效的UTF-8，还将返回错误。如果遇到I / O错误，则 &lt;code&gt;buf&lt;/code&gt; 可能包含一些字节，如果到目前为止已读取的所有数据均为有效UTF-8，则该字节已被读取。</target>
        </trans-unit>
        <trans-unit id="f52e89cf7de02d11dddd72bc5753735b903e55b9" translate="yes" xml:space="preserve">
          <source>This function has the same safety guarantees as the &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">该函数与&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt;函数具有相同的安全保证。</target>
        </trans-unit>
        <trans-unit id="adea46a33368b546562d3adbbc93c24db07769c5" translate="yes" xml:space="preserve">
          <source>This function has the same safety guarantees as the &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">此函数与&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt;函数具有相同的安全保证。</target>
        </trans-unit>
        <trans-unit id="1b144c49949055dde44dc3050173804acf39c11f" translate="yes" xml:space="preserve">
          <source>This function internally uses the &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; method on this trait and hence will continuously write data so long as no errors are received. This also means that partial writes are not indicated in this signature.</source>
          <target state="translated">此函数在内部使用此特征上的&lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;方法，因此只要没有收到错误，就将连续写入数据。这也意味着此签名中未指示部分写入。</target>
        </trans-unit>
        <trans-unit id="66530779d87bba553e9df64d147255f7af9fe886" translate="yes" xml:space="preserve">
          <source>This function internally uses the &lt;a href=&quot;trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; method on this trait and hence will continuously write data so long as no errors are received. This also means that partial writes are not indicated in this signature.</source>
          <target state="translated">此函数在内部使用此特征上的&lt;a href=&quot;trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;方法，因此只要没有收到错误，就将连续写入数据。这也意味着此签名中未指示部分写入。</target>
        </trans-unit>
        <trans-unit id="1f9b7d260474b82b56786f2b96849de01b420191" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; method to function properly. When calling this method, none of the contents will be &quot;read&quot; in the sense that later calling &lt;code&gt;read&lt;/code&gt; may return the same contents. As such, &lt;a href=&quot;#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; must be called with the number of bytes that are consumed from this buffer to ensure that the bytes are never returned twice.</source>
          <target state="translated">此函数是较低级别的调用。它需要与&lt;a href=&quot;#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt;方法配对才能正常运行。调用此方法时，任何内容都不会被&amp;ldquo;读取&amp;rdquo;，因为稍后调用 &lt;code&gt;read&lt;/code&gt; 可能会返回相同的内容。因此，&lt;a href=&quot;#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt;必须与从该缓冲器消耗，确保字节再也没有回过两次的字节数被调用。</target>
        </trans-unit>
        <trans-unit id="1da3425b653a05b924f0c013401f366dcdf5aa2c" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; method to function properly. This function does not perform any I/O, it simply informs this object that some amount of its buffer, returned from &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, has been consumed and should no longer be returned. As such, this function may do odd things if &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; isn't called before calling it.</source>
          <target state="translated">此函数是较低级别的调用。它需要与&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;方法配对才能正常运行。该函数不执行任何I / O，它只是通知该对象从&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;返回的一定数量的缓冲区已被消耗，不应再返回。因此，如果未在调用&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;之前调用该函数，则该函数可能会做奇怪的事情。</target>
        </trans-unit>
        <trans-unit id="854ee5963ab7cb501fb556356449a0a75bec7aa8" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; method to function properly. When calling this method, none of the contents will be &quot;read&quot; in the sense that later calling &lt;code&gt;read&lt;/code&gt; may return the same contents. As such, &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; must be called with the number of bytes that are consumed from this buffer to ensure that the bytes are never returned twice.</source>
          <target state="translated">此函数是较低级别的调用。它需要与&lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt;方法配对才能正常运行。当调用此方法时，任何内容都不会被&amp;ldquo;读取&amp;rdquo;，因为稍后调用 &lt;code&gt;read&lt;/code&gt; 可能会返回相同的内容。因此，&lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt;必须与从该缓冲器消耗，确保字节再也没有回过两次的字节数被调用。</target>
        </trans-unit>
        <trans-unit id="579c281433d14ce69320e4d857132a7a2c6352d3" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; method to function properly. This function does not perform any I/O, it simply informs this object that some amount of its buffer, returned from &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, has been consumed and should no longer be returned. As such, this function may do odd things if &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; isn't called before calling it.</source>
          <target state="translated">此函数是较低级别的调用。它需要与&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;方法配对才能正常运行。该函数不执行任何I / O，只是通知该对象从&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;返回的一定数量的缓冲区已被消耗，不应再返回。因此，如果未在调用&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;之前调用该函数，则该函数可能会做一些奇怪的事情。</target>
        </trans-unit>
        <trans-unit id="415a263593c43f00d8f5a632e9e771b274ca8329" translate="yes" xml:space="preserve">
          <source>This function is a no-op, and does not even read from &lt;code&gt;dummy&lt;/code&gt;.</source>
          <target state="translated">此功能为空操作，甚至不会从 &lt;code&gt;dummy&lt;/code&gt; 读取。</target>
        </trans-unit>
        <trans-unit id="04e44698b394de41883f1cf69eb125285be21b0e" translate="yes" xml:space="preserve">
          <source>This function is also unsafe as the primitives currently returned have the contract that they are the sole owner of the file descriptor they are wrapping. Usage of this function could accidentally allow violating this contract which can cause memory unsafety in code that relies on it being true.</source>
          <target state="translated">这个函数也是不安全的,因为当前返回的基元有一个合同,即它们是它们所封装的文件描述符的唯一所有者。使用此函数可能会意外地允许违反此合同,这可能会在依赖该合同为真的代码中导致内存不安全。</target>
        </trans-unit>
        <trans-unit id="f34531fffd31ebc3903cc0f2c5f5bc232a9d53da" translate="yes" xml:space="preserve">
          <source>This function is blocking and should be used carefully: it is possible for an attacker to continuously send bytes without ever sending a newline or EOF.</source>
          <target state="translated">这个功能是阻塞的,应该小心使用:攻击者有可能在不发送换行或EOF的情况下连续发送字节。</target>
        </trans-unit>
        <trans-unit id="767fc2a16ab91407b9680a74099aea95b9c90341" translate="yes" xml:space="preserve">
          <source>This function is blocking and should be used carefully: it is possible for an attacker to continuously send bytes without ever sending the delimiter or EOF.</source>
          <target state="translated">这个功能是阻塞的,应该小心使用:攻击者有可能在不发送定界符或EOF的情况下连续发送字节。</target>
        </trans-unit>
        <trans-unit id="e4f07981812bfb90d5d613f3cd12334bfad99018" translate="yes" xml:space="preserve">
          <source>This function is blocking, and should not be used in &lt;code&gt;async&lt;/code&gt; functions.</source>
          <target state="translated">该函数正在阻止，因此不应在 &lt;code&gt;async&lt;/code&gt; 函数中使用。</target>
        </trans-unit>
        <trans-unit id="2491a3d7b07b5d574df89b38429aea33453977ac" translate="yes" xml:space="preserve">
          <source>This function is different from &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop_hint&lt;/code&gt; does not interact with the operating system.</source>
          <target state="translated">此函数不同于&lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;，后者直接屈服于系统的调度程序，而 &lt;code&gt;spin_loop_hint&lt;/code&gt; 不与操作系统交互。</target>
        </trans-unit>
        <trans-unit id="98d00324eb55b3a641f30a2bb642d7084ef611a4" translate="yes" xml:space="preserve">
          <source>This function is different from &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop&lt;/code&gt; does not interact with the operating system.</source>
          <target state="translated">此函数不同于&lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;thread::yield_now&lt;/code&gt; &lt;/a&gt;，后者直接屈服于系统的调度程序，而 &lt;code&gt;spin_loop&lt;/code&gt; 不与操作系统交互。</target>
        </trans-unit>
        <trans-unit id="2844b634a91113f81bf8561b54a56d96807ba95f" translate="yes" xml:space="preserve">
          <source>This function is different than &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop_hint&lt;/code&gt; only signals the processor that it is entering a busy-wait spin-loop without yielding control to the system's scheduler.</source>
          <target state="translated">此函数不同于&lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;，后者直接屈服于系统的调度程序，而 &lt;code&gt;spin_loop_hint&lt;/code&gt; 仅向处理器发出信号，表明它正在进入忙碌的自旋循环，而不向系统的调度程序产生控制权。</target>
        </trans-unit>
        <trans-unit id="98f804e178831934e2704907d9977fcb07b49649" translate="yes" xml:space="preserve">
          <source>This function is different than &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop&lt;/code&gt; only signals the processor that it is entering a busy-wait spin-loop without yielding control to the system's scheduler.</source>
          <target state="translated">此函数不同于&lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;，后者直接屈服于系统的调度程序，而 &lt;code&gt;spin_loop&lt;/code&gt; 仅向处理器发出信号，表明它正在进入繁忙的自旋循环，而没有向系统的调度程序产生控制权。</target>
        </trans-unit>
        <trans-unit id="41b9515d2076760cfa3f4b5d6d17d095ddb905fd" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of &lt;a href=&quot;../../hint/fn.spin_loop&quot;&gt;&lt;code&gt;hint::spin_loop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不建议使用该函数，而建议使用&lt;a href=&quot;../../hint/fn.spin_loop&quot;&gt; &lt;code&gt;hint::spin_loop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="467a74dd68a231eab8ded24aa170197676eb9466" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当 &lt;code&gt;alloc&lt;/code&gt; 和&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性变得稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的alloc方法。</target>
        </trans-unit>
        <trans-unit id="b99b444be238e8b895735ba0a1305ae0f8a074c7" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocator&quot;&gt;&lt;code&gt;Allocator&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.allocator&quot;&gt; &lt;code&gt;Allocator&lt;/code&gt; &lt;/a&gt;特性稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;alloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="af165703deff9d928fee107e2b077ae27c60ea8e" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; &lt;/a&gt;特性稳定时，将不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;alloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6654c3116763d1cd428eebcad450e10896b561da" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性变得稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;alloc_zeroed&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c7978c6c99bcb0bfa61713bb6f008fffa8ca6068" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocator&quot;&gt;&lt;code&gt;Allocator&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当此函数和&lt;a href=&quot;trait.allocator&quot;&gt; &lt;code&gt;Allocator&lt;/code&gt; &lt;/a&gt;特性稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;alloc_zeroed&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="bcbf3e248baf2acbd0ca22a0a9243de796c9b484" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当函数和&lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; &lt;/a&gt;特征稳定时，建议使用不推荐使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;alloc_zeroed&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="0400d9b530af2cdc75200e564b1d3df4717e5b0d" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当函数和&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性变得稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;dealloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a8b61d41d166bb1c78751280bc5439d73580399f" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocator&quot;&gt;&lt;code&gt;Allocator&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当此函数和&lt;a href=&quot;trait.allocator&quot;&gt; &lt;code&gt;Allocator&lt;/code&gt; &lt;/a&gt;特性稳定时，将不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;dealloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="9ed58253cb2bb6abe90cf553f72f373e1d0723cc" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; &lt;/a&gt;特征稳定时，将不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;dealloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="9c9fc6e063817eb54b121ff88e105f246093f7ff" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性变得稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;realloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="15aa09ac5eb8ebd0a5e1dff85588ffec210b0c21" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocator&quot;&gt;&lt;code&gt;Allocator&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.allocator&quot;&gt; &lt;code&gt;Allocator&lt;/code&gt; &lt;/a&gt;特性稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;realloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="fa62f51911ddb19be8f5aa47587e29e20dee089f" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; &lt;/a&gt;特征稳定时，将不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;realloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="5b11361fb076bd1f28fd827ccd142c64af2b467e" translate="yes" xml:space="preserve">
          <source>This function is just a shim intended to be removed when the &lt;code&gt;unsized_locals&lt;/code&gt; feature gets stabilized.</source>
          <target state="translated">此功能只是打算在 &lt;code&gt;unsized_locals&lt;/code&gt; 功能稳定后删除的垫片。</target>
        </trans-unit>
        <trans-unit id="bc7e9741757bc42e41e144d227e772dfb6ad20fc" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak.</source>
          <target state="translated">这个函数主要是对程序剩余寿命的数据有用。丢弃返回的引用将导致内存泄漏。</target>
        </trans-unit>
        <trans-unit id="177431c922c0d0a7a204582e17b86736e812c93b" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak. If this is not acceptable, the reference should first be wrapped with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function producing a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; can then be dropped which will properly destroy &lt;code&gt;T&lt;/code&gt; and release the allocated memory.</source>
          <target state="translated">此功能主要用于在程序的剩余生命期内保留的数据。删除返回的引用将导致内存泄漏。如果这是不可接受的，则应首先使用&lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt;函数将引用包装起来，产生 &lt;code&gt;Box&lt;/code&gt; 。然后可以放下此 &lt;code&gt;Box&lt;/code&gt; ，这将适当地破坏 &lt;code&gt;T&lt;/code&gt; 并释放分配的内存。</target>
        </trans-unit>
        <trans-unit id="59cb1896e3dcd115f785bf2479cb4580b1b9722d" translate="yes" xml:space="preserve">
          <source>This function is not magic; it is literally defined as</source>
          <target state="translated">这个功能并不神奇,它的字面定义为</target>
        </trans-unit>
        <trans-unit id="cc2ffe8b61942162bfcfde0b12c33ce86e8880cb" translate="yes" xml:space="preserve">
          <source>This function is only safe to call if the following conditions hold:</source>
          <target state="translated">只有在以下条件成立的情况下,调用该函数才是安全的。</target>
        </trans-unit>
        <trans-unit id="eeccb3e706f48a212133104a654e31843b7b7b92" translate="yes" xml:space="preserve">
          <source>This function is primarily used for optimization purposes.</source>
          <target state="translated">该功能主要用于优化目的。</target>
        </trans-unit>
        <trans-unit id="93c7910f6179639ce884370e8d94a5595d080311" translate="yes" xml:space="preserve">
          <source>This function is primarily useful for allowing byte-wise pointer arithmetic on potentially fat pointers:</source>
          <target state="translated">这个函数主要用于允许对潜在的胖指针进行字节式指针运算。</target>
        </trans-unit>
        <trans-unit id="1cd0464bff7e9c8dd1499717db18b2f31952ba8c" translate="yes" xml:space="preserve">
          <source>This function is safe, but actually using the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="translated">此函数是安全的，但实际上使用返回值是不安全的。有关切片安全性要求，请参见&lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt; &lt;code&gt;slice::from_raw_parts&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="47c5699202ba358abe356e82ca7c6c5715bfdeae" translate="yes" xml:space="preserve">
          <source>This function is safe, but actually using the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts_mut&quot;&gt;&lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="translated">此函数是安全的，但实际上使用返回值是不安全的。有关切片安全性要求，请参见&lt;a href=&quot;../slice/fn.from_raw_parts_mut&quot;&gt; &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="451ae39575c352f08886704c7ffa48d2181b8a99" translate="yes" xml:space="preserve">
          <source>This function is safe, but dereferencing the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="translated">此函数是安全的，但是取消引用返回值是不安全的。有关切片安全性要求，请参见&lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt; &lt;code&gt;slice::from_raw_parts&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="1a4d03cae95a52ccbe2043ee8d63640e5a40a11f" translate="yes" xml:space="preserve">
          <source>This function is safe, even when the non-null raw slice cannot be dereferenced to a slice because the pointer does not have a valid address.</source>
          <target state="translated">这个函数是安全的,即使是非空的原始分片因为指针没有有效的地址而不能去引用一个分片。</target>
        </trans-unit>
        <trans-unit id="f368bea1b2408b163770a1c33d9edf8ea07be6d6" translate="yes" xml:space="preserve">
          <source>This function is safe, even when the raw slice cannot be cast to a slice reference because the pointer is null or unaligned.</source>
          <target state="translated">这个函数是安全的,即使当原始切片因为指针为空或未对齐而不能投向切片引用时,也是安全的。</target>
        </trans-unit>
        <trans-unit id="9a9053fe38824d2de0054cbaba771d8a6b62c54f" translate="yes" xml:space="preserve">
          <source>This function is semantically equivalent to &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt; except that it operates on raw pointers instead of references. When references are available, &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt; should be preferred.</source>
          <target state="translated">此函数在语义上等效于&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;但它对原始指针（而不是引用）进行操作。当引用可用时，应首选&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bc2ee69e11ff49cf8f44aa7be972ea956317ef2" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;, except that it may not synchronize file metadata to the filesystem.</source>
          <target state="translated">该函数类似于&lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt;，除了它可能不将文件元数据同步到文件系统。</target>
        </trans-unit>
        <trans-unit id="c9cbe9f2a91fb1ea199b620a6bb920ab34b40788" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;wake&lt;/code&gt;, but must not consume the provided data pointer.</source>
          <target state="translated">此函数类似于 &lt;code&gt;wake&lt;/code&gt; ，但一定不能使用提供的数据指针。</target>
        </trans-unit>
        <trans-unit id="3817c9c59ae829a4e4b6db71acecc27e54fc335a" translate="yes" xml:space="preserve">
          <source>This function is similar to the &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;leak&lt;/code&gt;&lt;/a&gt; function on &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt; except that there is no way to recover the leaked memory.</source>
          <target state="translated">此功能类似于&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;leak&lt;/code&gt; &lt;/a&gt;功能，不同之处在于无法恢复泄漏的内存。</target>
        </trans-unit>
        <trans-unit id="a4ebf22d46bf6517393acc377fdd446867946954" translate="yes" xml:space="preserve">
          <source>This function is similar to the &lt;code&gt;leak&lt;/code&gt; function on &lt;code&gt;Box&lt;/code&gt;.</source>
          <target state="translated">此功能类似于 &lt;code&gt;Box&lt;/code&gt; 上的 &lt;code&gt;leak&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="b2a62d49d2d0f2fe0fb6a0071ccf5e43d3885dc1" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;#method.to_bytes&quot;&gt;&lt;code&gt;to_bytes&lt;/code&gt;&lt;/a&gt; except that it will retain the trailing nul terminator instead of chopping it off.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;#method.to_bytes&quot;&gt; &lt;code&gt;to_bytes&lt;/code&gt; ,&lt;/a&gt;除了它将保留尾随的nul终止符而不是将其切掉。</target>
        </trans-unit>
        <trans-unit id="aa81adf357f1575ab28bd1d9c5804caf46b4ba04" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;struct.cstr#method.to_bytes&quot;&gt;&lt;code&gt;CStr::to_bytes&lt;/code&gt;&lt;/a&gt; except that it will retain the trailing nul terminator instead of chopping it off.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;struct.cstr#method.to_bytes&quot;&gt; &lt;code&gt;CStr::to_bytes&lt;/code&gt; &lt;/a&gt;除了它将保留尾随的nul终止符而不是将其截断。</target>
        </trans-unit>
        <trans-unit id="bbca71aedd00db40d26ceff11e63bc8c656a9f3e" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;a href=&quot;#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数是&lt;a href=&quot;#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;的反函数。</target>
        </trans-unit>
        <trans-unit id="60af8a75ca29fd4b9524979a42c65b475dac17ca" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;a href=&quot;#method.offset-1&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数是&lt;a href=&quot;#method.offset-1&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;的反函数。</target>
        </trans-unit>
        <trans-unit id="a968e659e413eae940af237b572b89fdec65a1f7" translate="yes" xml:space="preserve">
          <source>This function is the mirror of &lt;a href=&quot;#method.guaranteed_eq&quot;&gt;&lt;code&gt;guaranteed_eq&lt;/code&gt;&lt;/a&gt;, but not its inverse. There are pointer comparisons for which both functions return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此函数是&lt;a href=&quot;#method.guaranteed_eq&quot;&gt; &lt;code&gt;guaranteed_eq&lt;/code&gt; &lt;/a&gt;的镜像，但不是其反函数。有两个函数都返回 &lt;code&gt;false&lt;/code&gt; 的指针比较。</target>
        </trans-unit>
        <trans-unit id="df5c6e62763bfc43519897ed41868fc1d62d6938" translate="yes" xml:space="preserve">
          <source>This function is the mirror of &lt;a href=&quot;#method.guaranteed_ne&quot;&gt;&lt;code&gt;guaranteed_ne&lt;/code&gt;&lt;/a&gt;, but not its inverse. There are pointer comparisons for which both functions return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此函数是&lt;a href=&quot;#method.guaranteed_ne&quot;&gt; &lt;code&gt;guaranteed_ne&lt;/code&gt; &lt;/a&gt;的镜像，但不是其反函数。有两个函数都返回 &lt;code&gt;false&lt;/code&gt; 的指针比较。</target>
        </trans-unit>
        <trans-unit id="f4e91aa4b5730d86849f9ad126912325901a438a" translate="yes" xml:space="preserve">
          <source>This function is unsafe as it does not verify the preconditions from &lt;a href=&quot;#method.from_size_align&quot;&gt;&lt;code&gt;Layout::from_size_align&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数不安全，因为它不验证&lt;a href=&quot;#method.from_size_align&quot;&gt; &lt;code&gt;Layout::from_size_align&lt;/code&gt; &lt;/a&gt;的前提条件。</target>
        </trans-unit>
        <trans-unit id="8570a34fff9bbf02e64d50247313e6b25b11941e" translate="yes" xml:space="preserve">
          <source>This function is unsafe as it does not verify the preconditions from &lt;a href=&quot;struct.layout#method.from_size_align&quot;&gt;&lt;code&gt;Layout::from_size_align&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数不安全，因为它不验证&lt;a href=&quot;struct.layout#method.from_size_align&quot;&gt; &lt;code&gt;Layout::from_size_align&lt;/code&gt; &lt;/a&gt;的前提条件。</target>
        </trans-unit>
        <trans-unit id="c0adf1d1fbca05371274b33d836dbb8ba3b0da96" translate="yes" xml:space="preserve">
          <source>This function is unsafe as there is no guarantee that the given pointer is valid for &lt;code&gt;len&lt;/code&gt; elements, nor whether the lifetime inferred is a suitable lifetime for the returned slice.</source>
          <target state="translated">此函数不安全，因为不能保证给定的指针对 &lt;code&gt;len&lt;/code&gt; 元素有效，也不能保证推断的生存期是否适合返回的片。</target>
        </trans-unit>
        <trans-unit id="ead8661237451bd45c2559207ff2f0d2dcefd5f7" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory problems. For example, a double-free may occur if the function is called twice on the same raw pointer.</source>
          <target state="translated">这个函数是不安全的,因为使用不当可能会导致内存问题。例如,如果在同一个原始指针上调用该函数两次,可能会出现双免。</target>
        </trans-unit>
        <trans-unit id="35f3e90c9d123dc330088febbcb755f29e299a96" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory unsafety, even if the returned &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; is never accessed.</source>
          <target state="translated">此函数是不安全的，因为不当使用该操作可能会导致内存不安全，即使从未访问返回的 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="e8bd102f6698ee49286a5c128925e7efc3ca2420" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory unsafety, even if the returned &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is never accessed.</source>
          <target state="translated">此功能不安全，因为不当使用该操作可能会导致内存不安全，即使从未访问返回的 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f0606f18b84a9d14096f66fc981df0b42c6d0bf" translate="yes" xml:space="preserve">
          <source>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the &lt;code&gt;String&lt;/code&gt;, as the rest of the standard library assumes that &lt;code&gt;String&lt;/code&gt;s are valid UTF-8.</source>
          <target state="translated">此函数不安全，因为它不检查传递给它的字节是否为有效的UTF-8。如果违反了此约束，则将来的 &lt;code&gt;String&lt;/code&gt; 用户可能会导致内存不安全问题，因为标准库的其余部分都假定 &lt;code&gt;String&lt;/code&gt; 是有效的UTF-8。</target>
        </trans-unit>
        <trans-unit id="36c2b1be1ffd545e988489f24fde5b599256ff94" translate="yes" xml:space="preserve">
          <source>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, undefined behavior results, as the rest of Rust assumes that &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s are valid UTF-8.</source>
          <target state="translated">此函数不安全，因为它不检查传递给它的字节是否为有效的UTF-8。如果违反了此约束，则将导致未定义的行为，因为Rust的其余部分都假定&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;是有效的UTF-8。</target>
        </trans-unit>
        <trans-unit id="d26d0eb0451d8006697165ba21e7f4a6d2affd96" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</source>
          <target state="translated">这个函数是不安全的,因为如果调用者没有确保以下所有条件,就会产生未定义的行为。</target>
        </trans-unit>
        <trans-unit id="42a04935e77664a45c1ca55344796f0f9622e5b5" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure both:</source>
          <target state="translated">这个函数是不安全的,因为如果调用者不确保这两点,可能会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="b81cd2be550f8d99eeb1700fa914c58868e2867c" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure that &lt;code&gt;layout&lt;/code&gt; has non-zero size.</source>
          <target state="translated">此函数是不安全的，因为如果调用者不确保 &lt;code&gt;layout&lt;/code&gt; 大小为非零，则可能导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="454ec0a5acadcaac0aa85170f5ed93cb46c13302" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons as &lt;a href=&quot;fn.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt;, as well as not being able to provide a non-aliasing guarantee of the returned mutable slice. &lt;code&gt;data&lt;/code&gt; must be non-null and aligned even for zero-length slices as with &lt;a href=&quot;fn.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt;. The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory.</source>
          <target state="translated">出于与&lt;a href=&quot;fn.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt;相同的原因，该函数是不安全的，并且不能为返回的可变切片提供非别名保证。 &lt;code&gt;data&lt;/code&gt; 必须是非null的，并且即使对于零长度的切片也必须与&lt;a href=&quot;fn.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; 对齐&lt;/a&gt;。切片的总大小不得大于内存中的 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;字节&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="eecdc0e72496ca31779009b14276f9c964f0fc63" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;alloc&lt;/code&gt; is.</source>
          <target state="translated">出于与 &lt;code&gt;alloc&lt;/code&gt; 相同的原因，此函数不安全。</target>
        </trans-unit>
        <trans-unit id="f46ccfd28f902efc152ad3d0bc725d272999fa8f" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;alloc&lt;/code&gt; is. However the allocated block of memory is guaranteed to be initialized.</source>
          <target state="translated">出于与 &lt;code&gt;alloc&lt;/code&gt; 相同的原因，此函数不安全。但是，保证已分配的内存块将被初始化。</target>
        </trans-unit>
        <trans-unit id="c8935ef267a58bf14edf52661928291938f416d8" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;realloc&lt;/code&gt; is.</source>
          <target state="translated">出于与 &lt;code&gt;realloc&lt;/code&gt; 相同的原因，此函数不安全。</target>
        </trans-unit>
        <trans-unit id="010c54d09909e31d21b794c4e10275c4b255b332" translate="yes" xml:space="preserve">
          <source>This function is unsafe, as it may construct invalid &lt;code&gt;char&lt;/code&gt; values.</source>
          <target state="translated">此函数不安全，因为它可能构造无效的 &lt;code&gt;char&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="71a1e970e4af15e1e28b626518e246fe2beaa9ff" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that the data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function.</source>
          <target state="translated">这个函数是不安全的。你必须保证你返回的数据不会移动,只要参数值不移动(例如,因为它是该值的其中一个字段),也必须保证你接收到的参数不会移出内部函数。</target>
        </trans-unit>
        <trans-unit id="39a3dbf4634bdba5a0505dade8771f96ac64c22f" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that you will continue to treat the pointer &lt;code&gt;P&lt;/code&gt; as pinned after you call this function, so that the invariants on the &lt;code&gt;Pin&lt;/code&gt; type can be upheld. If the code using the resulting &lt;code&gt;P&lt;/code&gt; does not continue to maintain the pinning invariants that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.</source>
          <target state="translated">此功能不安全。您必须保证调用此函数后，将继续将指针 &lt;code&gt;P&lt;/code&gt; 视为固定的，以便可以保留 &lt;code&gt;Pin&lt;/code&gt; 类型的不变性。如果使用结果 &lt;code&gt;P&lt;/code&gt; 的代码不能继续维护固定不变，这违反了API约定，并且可能在以后的（安全）操作中导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="6c0c82733953c468905548df35ad6822c84f6c7f" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that you will never move the data out of the mutable reference you receive when you call this function, so that the invariants on the &lt;code&gt;Pin&lt;/code&gt; type can be upheld.</source>
          <target state="translated">此功能不安全。您必须保证在调用此函数时永远不会将数据移出接收到的可变引用中，以便可以保留 &lt;code&gt;Pin&lt;/code&gt; 类型的不变性。</target>
        </trans-unit>
        <trans-unit id="a2e566f884f51c3384b3aa58f5bde7f2e2df2f79" translate="yes" xml:space="preserve">
          <source>This function is used to generically create I/O errors which do not originate from the OS itself. The &lt;code&gt;error&lt;/code&gt; argument is an arbitrary payload which will be contained in this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数通常用于创建并非源于OS本身的I / O错误。该 &lt;code&gt;error&lt;/code&gt; 参数是将被包含在该任意的有效载荷&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94b97e70917e2ec0dff12c2bd6e40f05c9be7d64" translate="yes" xml:space="preserve">
          <source>This function is used to generically create I/O errors which do not originate from the OS itself. The &lt;code&gt;error&lt;/code&gt; argument is an arbitrary payload which will be contained in this &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">此功能通常用于创建并非源于OS本身的I / O错误。该 &lt;code&gt;error&lt;/code&gt; 参数是将被包含在该任意的有效载荷 &lt;code&gt;Error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5970a37a4fd89e4e4191139591e16ccec329bf2a" translate="yes" xml:space="preserve">
          <source>This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory, as is common in C++.</source>
          <target state="translated">这个函数对于与使用两个指针来引用内存中一系列元素的外来接口进行交互非常有用,就像在C++中常见的那样。</target>
        </trans-unit>
        <trans-unit id="0bf849f4d8fe700d85a6260475a19ac69c25acf8" translate="yes" xml:space="preserve">
          <source>This function is very easy to write, thanks to &lt;code&gt;match&lt;/code&gt;, and will look like Listing 6-5.</source>
          <target state="translated">借助 &lt;code&gt;match&lt;/code&gt; ，此函数非常易于编写，类似于清单6-5。</target>
        </trans-unit>
        <trans-unit id="19c2bab36fa633ea4bf26b73afdd5bd0e16edc9a" translate="yes" xml:space="preserve">
          <source>This function is, in some sense, the opposite of &lt;a href=&quot;#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在某种意义上，该功能与&lt;a href=&quot;#method.zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="a37c6f8dc5c32c647225cb24a1c4f508d03c0fdf" translate="yes" xml:space="preserve">
          <source>This function is, in some sense, the opposite of &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从某种意义上说，该功能与&lt;a href=&quot;trait.iterator#method.zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="2ee7b59ee419592da35ea7242eb2e8123baaf3cf" translate="yes" xml:space="preserve">
          <source>This function may &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if it is used with more than one mutex over time.</source>
          <target state="translated">此功能可能会出现问题&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;如果一段时间后它与多个互斥体一起使用。</target>
        </trans-unit>
        <trans-unit id="f705e261edec6d4798f68322cebb8b5768877e5d" translate="yes" xml:space="preserve">
          <source>This function may fail as the underlying system clock is susceptible to drift and updates (e.g., the system clock could go backwards), so this function may not always succeed. If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from this time measurement to the current time.</source>
          <target state="translated">由于基础系统时钟易于漂移和更新（例如，系统时钟可能倒退），因此此功能可能会失败，因此此功能可能并不总是成功。如果成功，则返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; ，其中持续时间表示从该时间测量到当前时间所经过的时间。</target>
        </trans-unit>
        <trans-unit id="a43d8a17e850a82c732c367bf89a844d3d96e4fe" translate="yes" xml:space="preserve">
          <source>This function may fail because measurements taken earlier are not guaranteed to always be before later measurements (due to anomalies such as the system clock being adjusted either forwards or backwards).</source>
          <target state="translated">该功能可能会失效,因为不能保证之前的测量值总是在后面的测量值之前(由于异常情况,如系统时钟被向前或向后调整)。</target>
        </trans-unit>
        <trans-unit id="8dd49c0cb240e2dbb52b64ec4b25e571052a70a5" translate="yes" xml:space="preserve">
          <source>This function may fail because measurements taken earlier are not guaranteed to always be before later measurements (due to anomalies such as the system clock being adjusted either forwards or backwards). &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; can be used to measure elapsed time without this risk of failure.</source>
          <target state="translated">此功能可能会失败，因为不能保证较早进行的测量总是在较晚进行的测量之前（由于异常，例如向前或向后调整系统时钟）。&lt;a href=&quot;struct.instant&quot;&gt; &lt;code&gt;Instant&lt;/code&gt; &lt;/a&gt;可以用来测量经过的时间，而不会出现失败的风险。</target>
        </trans-unit>
        <trans-unit id="5904fd4e8b5ae82205f779a00c5c8f588077b44a" translate="yes" xml:space="preserve">
          <source>This function may panic if &lt;code&gt;key&lt;/code&gt; is empty, contains an ASCII equals sign &lt;code&gt;'='&lt;/code&gt; or the NUL character &lt;code&gt;'\0'&lt;/code&gt;, or when the value contains the NUL character.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 为空，包含ASCII等于符号 &lt;code&gt;'='&lt;/code&gt; 或NUL字符 &lt;code&gt;'\0'&lt;/code&gt; 或值包含NUL字符，则此函数可能会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="9a0dc67c9d122eb74decfcdabf36a2e9b439b108" translate="yes" xml:space="preserve">
          <source>This function may panic if it is called after the &lt;code&gt;Complete&lt;/code&gt; variant has been returned previously. While generator literals in the language are guaranteed to panic on resuming after &lt;code&gt;Complete&lt;/code&gt;, this is not guaranteed for all implementations of the &lt;code&gt;Generator&lt;/code&gt; trait.</source>
          <target state="translated">如果在先前返回 &lt;code&gt;Complete&lt;/code&gt; 变体之后调用此函数，则可能会感到恐慌。尽管可以保证在 &lt;code&gt;Complete&lt;/code&gt; 语言后继续使用该语言的生成器文字会感到恐慌，但这并不能保证所有 &lt;code&gt;Generator&lt;/code&gt; 特征的实现都可以保证。</target>
        </trans-unit>
        <trans-unit id="22c11ebcd140410550c98ffdd0ada9fb8238ab32" translate="yes" xml:space="preserve">
          <source>This function may panic if the current time is earlier than this instant, which is something that can happen if an &lt;code&gt;Instant&lt;/code&gt; is produced synthetically.</source>
          <target state="translated">如果当前时间早于此瞬间，则此功能可能会出现紧急情况；如果综合生产 &lt;code&gt;Instant&lt;/code&gt; ,则可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="24a0a37cf3864874d04875e7b90815fd8bf61604" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt;&lt;code&gt;Instant::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。请参见&lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt; &lt;code&gt;Instant::checked_add&lt;/code&gt; &lt;/a&gt;以获取没有崩溃的版本。</target>
        </trans-unit>
        <trans-unit id="8aed85a838914397cfff90a6f158e84b7b3b4829" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。参见&lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; ,&lt;/a&gt;了解没有出现紧急情况的版本。</target>
        </trans-unit>
        <trans-unit id="9bc75e1d489664d08b58daa300cbacf1f7764cb4" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;SystemTime::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。请参见&lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;SystemTime::checked_add&lt;/code&gt; &lt;/a&gt;以获取没有崩溃的版本。</target>
        </trans-unit>
        <trans-unit id="366269740ca74a1798b4e975775caf12fd1ce852" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。参见&lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; ,&lt;/a&gt;了解没有出现紧急情况的版本。</target>
        </trans-unit>
        <trans-unit id="401bf91c85ca55e966355c7f85b21d7639dab4cd" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt;&lt;code&gt;Instant::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。请参见&lt;a href=&quot;struct.instant#method.checked_add&quot;&gt; &lt;code&gt;Instant::checked_add&lt;/code&gt; &lt;/a&gt;以获取没有崩溃的版本。</target>
        </trans-unit>
        <trans-unit id="2f02bfc3fdf0149848c26b5693e3c3c2e193c842" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。参见&lt;a href=&quot;struct.instant#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; ,&lt;/a&gt;了解没有出现紧急情况的版本。</target>
        </trans-unit>
        <trans-unit id="6625bc40abfc907779e7819cb337a56bc6be6b98" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;SystemTime::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。请参见&lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;SystemTime::checked_add&lt;/code&gt; &lt;/a&gt;以获取没有崩溃的版本。</target>
        </trans-unit>
        <trans-unit id="df93ffa2c06e7d9c793296fff9096b1f4a09746a" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。参见&lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; ,&lt;/a&gt;了解没有出现紧急情况的版本。</target>
        </trans-unit>
        <trans-unit id="f047ee1947a40935115c87e9ff5da84ba7c716fb" translate="yes" xml:space="preserve">
          <source>This function may panic on some platforms if a thread attempts to join itself or otherwise may create a deadlock with joining threads.</source>
          <target state="translated">如果一个线程试图加入自己,这个函数在某些平台上可能会恐慌,否则可能会造成加入线程的死锁。</target>
        </trans-unit>
        <trans-unit id="2aa9c9fbe6e7d8e79dbcc09f82ff622cc49e7e8c" translate="yes" xml:space="preserve">
          <source>This function might panic if the iterator has more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">如果迭代器具有超过&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;元素，则此函数可能会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="d1fc6a40a80536289c51eca2e61adf3162489e6d" translate="yes" xml:space="preserve">
          <source>This function might panic if the iterator has more than &lt;code&gt;usize::MAX&lt;/code&gt; non-matching elements.</source>
          <target state="translated">如果迭代器具有超过 &lt;code&gt;usize::MAX&lt;/code&gt; 不匹配元素，则此函数可能会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="e85b3c94c6e63ddd25298570364b3a6122b73135" translate="yes" xml:space="preserve">
          <source>This function might panic when called if the lock is already held by the current thread.</source>
          <target state="translated">如果锁已经被当前线程持有,这个函数在调用时可能会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="b3552c30ec404d25019fce8d0e95a821dc885077" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;T&lt;/code&gt; is a Zero-Sized Type (&quot;ZST&quot;).</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是零尺寸类型（&amp;ldquo; ZST&amp;rdquo;），则此函数会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="101814bfeeecf8436008ed4880368756ae5c8d29" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;T&lt;/code&gt; is a zero-sized type.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是零大小的类型，则此函数会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="9eaa9b63e5ef7b899f75363fe8681ac3e3da2fd4" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;radix&lt;/code&gt; is not in the range from 2 to 36.</source>
          <target state="translated">如果 &lt;code&gt;radix&lt;/code&gt; 不在2到36范围内，则此功能会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="f62c2a73ad1ab98a4ef40a980a80cd47e78cfc5e" translate="yes" xml:space="preserve">
          <source>This function reads as many bytes as necessary to completely fill the specified buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">该函数读取所需的字节数以完全填充指定的缓冲区 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c39eec7f7794b4915b46c58cff436d679c91fcab" translate="yes" xml:space="preserve">
          <source>This function reads the value of &lt;code&gt;errno&lt;/code&gt; for the target platform (e.g. &lt;code&gt;GetLastError&lt;/code&gt; on Windows) and will return a corresponding instance of &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; for the error code.</source>
          <target state="translated">此函数读取目标平台的 &lt;code&gt;errno&lt;/code&gt; 值（例如Windows上的 &lt;code&gt;GetLastError&lt;/code&gt; ），并将为错误代码返回相应的&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="32152f76d2e83d5c89836d9aa45ce33c14bc03d9" translate="yes" xml:space="preserve">
          <source>This function reads the value of &lt;code&gt;errno&lt;/code&gt; for the target platform (e.g. &lt;code&gt;GetLastError&lt;/code&gt; on Windows) and will return a corresponding instance of &lt;code&gt;Error&lt;/code&gt; for the error code.</source>
          <target state="translated">此函数读取目标平台的 &lt;code&gt;errno&lt;/code&gt; 值（例如Windows上的 &lt;code&gt;GetLastError&lt;/code&gt; ），并将为错误代码返回相应的 &lt;code&gt;Error&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="1cc405a72fa71224d4a044b7593cdccf93a633ec" translate="yes" xml:space="preserve">
          <source>This function returning &lt;code&gt;false&lt;/code&gt; does not mean that &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; has not been executed. For example, it may have been executed in the time between when &lt;code&gt;is_completed&lt;/code&gt; starts executing and when it returns, in which case the &lt;code&gt;false&lt;/code&gt; return value would be stale (but still permissible).</source>
          <target state="translated">这个函数返回 &lt;code&gt;false&lt;/code&gt; 并不意味着&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;还没有被执行。例如，它可能已在 &lt;code&gt;is_completed&lt;/code&gt; 开始执行与返回之间的时间内执行，在这种情况下， &lt;code&gt;false&lt;/code&gt; 返回值将是陈旧的（但仍是允许的）。</target>
        </trans-unit>
        <trans-unit id="05ed95f7312c1878141bc36d8d210b9fa11581c5" translate="yes" xml:space="preserve">
          <source>This function returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;. If our byte slice is invalid UTF-8, then we need to insert the replacement characters, which will change the size of the string, and hence, require a &lt;code&gt;String&lt;/code&gt;. But if it's already valid UTF-8, we don't need a new allocation. This return type allows us to handle both cases.</source>
          <target state="translated">此函数返回&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt;。如果字节片无效的UTF-8，则需要插入替换字符，这将改变字符串的大小，因此需要 &lt;code&gt;String&lt;/code&gt; 。但是，如果它已经是有效的UTF-8，则不需要新的分配。这种返回类型使我们能够处理两种情况。</target>
        </trans-unit>
        <trans-unit id="12ee7d651a482e6bf7ef02b5e21ea7e98deba17a" translate="yes" xml:space="preserve">
          <source>This function returns a new OpenOptions object that you can use to open or create a file with specific options if &lt;code&gt;open()&lt;/code&gt; or &lt;code&gt;create()&lt;/code&gt; are not appropriate.</source>
          <target state="translated">如果不适合使用 &lt;code&gt;open()&lt;/code&gt; 或 &lt;code&gt;create()&lt;/code&gt; ,则此函数返回一个新的OpenOptions对象，您可以使用该对象打开或创建具有特定选项的文件。</target>
        </trans-unit>
        <trans-unit id="6f72ba6fb91e1ce3e00f9d70494a4d758f1ff97b" translate="yes" xml:space="preserve">
          <source>This function returns a new instance of &lt;code&gt;Read&lt;/code&gt; which will read at most &lt;code&gt;limit&lt;/code&gt; bytes, after which it will always return EOF (&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;). Any read errors will not count towards the number of bytes read and future calls to &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; may succeed.</source>
          <target state="translated">此函数返回 &lt;code&gt;Read&lt;/code&gt; 的新实例，该实例最多将读取 &lt;code&gt;limit&lt;/code&gt; 字节，此后它将始终返回EOF（&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;）。任何读取错误都不会计入读取的字节数，将来对&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; 的&lt;/a&gt;调用可能会成功。</target>
        </trans-unit>
        <trans-unit id="ef0ad46bb886f62fbf2201ba9b9f859d8daf73a5" translate="yes" xml:space="preserve">
          <source>This function returns:</source>
          <target state="translated">该函数返回:</target>
        </trans-unit>
        <trans-unit id="e286b47aa27a1649f35422e9cb038c26279f95e3" translate="yes" xml:space="preserve">
          <source>This function runs the destructor of the contained value and thus the wrapped value now represents uninitialized data. It is up to the user of this method to ensure the uninitialized data is not actually used.</source>
          <target state="translated">这个函数运行了包含值的析构器,因此现在被包装的值代表未初始化的数据。该方法的使用者要确保未初始化的数据没有被实际使用。</target>
        </trans-unit>
        <trans-unit id="d626c9a67f6c1bb6dde6295b947e23c4df085081" translate="yes" xml:space="preserve">
          <source>This function runs the destructor of the contained value. Other than changes made by the destructor itself, the memory is left unchanged, and so as far as the compiler is concerned still holds a bit-pattern which is valid for the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">此函数运行包含值的析构函数。除了析构函数本身所做的更改之外，内存保持不变，因此就编译器而言，仍保留一个对 &lt;code&gt;T&lt;/code&gt; 类型有效的位模式。</target>
        </trans-unit>
        <trans-unit id="7791922c183e6e6d1b0127e9349abae66c275dd6" translate="yes" xml:space="preserve">
          <source>This function semantically moves out the contained value without preventing further usage, leaving the state of this container unchanged. It is your responsibility to ensure that this &lt;code&gt;ManuallyDrop&lt;/code&gt; is not used again.</source>
          <target state="translated">此函数从语义上移出包含的值，而不会阻止进一步使用，从而使此容器的状态保持不变。您有责任确保不再使用此 &lt;code&gt;ManuallyDrop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e07f846f13b5b07afd4d29501d5ea48bcae4f64b" translate="yes" xml:space="preserve">
          <source>This function semantically moves out the contained value without preventing further usage. It is up to the user of this method to ensure that this container is not used again.</source>
          <target state="translated">这个函数在语义上将包含的值移出,而不阻止继续使用。本方法的使用者要确保这个容器不会被再次使用。</target>
        </trans-unit>
        <trans-unit id="b73fe46d5d15372cef97957fc6bcb2aba3a35b19" translate="yes" xml:space="preserve">
          <source>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and &lt;code&gt;interface&lt;/code&gt; is the address of the local interface with which the system should join the multicast group. If it's equal to &lt;code&gt;INADDR_ANY&lt;/code&gt; then an appropriate interface is chosen by the system.</source>
          <target state="translated">此函数为此套接字指定一个新的多播组。该地址必须是有效的多播地址，而 &lt;code&gt;interface&lt;/code&gt; 是系统应加入多播组的本地接口的地址。如果等于 &lt;code&gt;INADDR_ANY&lt;/code&gt; ,则系统选择适当的接口。</target>
        </trans-unit>
        <trans-unit id="1f12ea05478bb3baf501603f551862b3ebf72f88" translate="yes" xml:space="preserve">
          <source>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and &lt;code&gt;interface&lt;/code&gt; is the index of the interface to join/leave (or 0 to indicate any interface).</source>
          <target state="translated">此函数为此套接字指定一个新的多播组。该地址必须是有效的多播地址，而 &lt;code&gt;interface&lt;/code&gt; 是要加入/离开的接口的索引（或0表示任何接口）。</target>
        </trans-unit>
        <trans-unit id="24119e41ff16fdb059a46c613efe17ad7fc57293" translate="yes" xml:space="preserve">
          <source>This function takes a string slice and emits it to the internal buffer after applying the relevant formatting flags specified. The flags recognized for generic strings are:</source>
          <target state="translated">该函数接收一个字符串片断,并在应用相关的格式化标志后将其输出到内部缓冲区。对于通用字符串来说,识别的标志有:1:</target>
        </trans-unit>
        <trans-unit id="5aebd3cecb06bef11683a2b627652c498c3d60b0" translate="yes" xml:space="preserve">
          <source>This function will &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if it is used with more than one mutex over time. Each condition variable is dynamically bound to exactly one mutex to ensure defined behavior across platforms. If this functionality is not desired, then unsafe primitives in &lt;code&gt;sys&lt;/code&gt; are provided.</source>
          <target state="translated">此功能会&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;如果一段时间内它与多个互斥体一起使用。每个条件变量都动态地绑定到一个互斥体上，以确保跨平台定义行为。如果不需要此功能，则在 &lt;code&gt;sys&lt;/code&gt; 中提供不安全的原语。</target>
        </trans-unit>
        <trans-unit id="78327b333ccf6b689aaecb9ee26d119fa6c5777a" translate="yes" xml:space="preserve">
          <source>This function will &lt;code&gt;panic!()&lt;/code&gt; if the key currently has its destructor running, and it &lt;strong&gt;may&lt;/strong&gt; panic if the destructor has previously been run for this thread.</source>
          <target state="translated">如果该键当前正在运行其析构函数，则此函数将出现 &lt;code&gt;panic!()&lt;/code&gt; ;如果先前已为此线程运行了析构函数，则该函数&lt;strong&gt;可能会&lt;/strong&gt;处于恐慌状态。</target>
        </trans-unit>
        <trans-unit id="de2e867f0f0c2461353251de2093fad37d9de75b" translate="yes" xml:space="preserve">
          <source>This function will &lt;em&gt;block&lt;/em&gt; until space in the internal buffer becomes available or a receiver is available to hand off the message to.</source>
          <target state="translated">该功能将一直&lt;em&gt;阻塞，&lt;/em&gt;直到内部缓冲区中的空间可用或接收者可以将消息传递给它为止。</target>
        </trans-unit>
        <trans-unit id="aa7ba2de98a6c309498a7c489e34ef4ae855d255" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;consume ownership&lt;/strong&gt; of the handle given, passing responsibility for closing the handle to the returned object.</source>
          <target state="translated">该函数将&lt;strong&gt;消耗&lt;/strong&gt;给定句柄的&lt;strong&gt;所有权&lt;/strong&gt;，将关闭句柄的责任传递给返回的对象。</target>
        </trans-unit>
        <trans-unit id="b6de52c208f12c4efe8542e2cc11b06fa42d2cf9" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;consume ownership&lt;/strong&gt; of the socket provided and it will be closed when the returned object goes out of scope.</source>
          <target state="translated">此函数将&lt;strong&gt;使用&lt;/strong&gt;提供的套接字的&lt;strong&gt;所有权&lt;/strong&gt;，并且在返回的对象超出范围时将关闭它。</target>
        </trans-unit>
        <trans-unit id="34a9593fc439cb6bab67a9e273e42357e335b574" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;overwrite&lt;/strong&gt; the contents of &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">此函数将&lt;strong&gt;覆盖&lt;/strong&gt; &lt;code&gt;to&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="b50d15cbddd54c77fb77c9639aae5bb9352e901e" translate="yes" xml:space="preserve">
          <source>This function will always block the current thread if there is no data available and it's possible for more data to be sent. Once a message is sent to the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt;), then this receiver will wake up and return that message.</source>
          <target state="translated">如果没有可用数据，并且有可能发送更多数据，则此函数将始终阻止当前线程。将消息发送到相应的&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;（或&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt;）后，此接收器将唤醒并返回该消息。</target>
        </trans-unit>
        <trans-unit id="2f7bc7c7785b26db5d2ba1d43d57ec9e10153387" translate="yes" xml:space="preserve">
          <source>This function will atomically unlock the mutex specified (represented by &lt;code&gt;guard&lt;/code&gt;) and block the current thread. This means that any calls to &lt;a href=&quot;#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt; which happen logically after the mutex is unlocked are candidates to wake this thread up. When this function call returns, the lock specified will have been re-acquired.</source>
          <target state="translated">此函数将自动解锁指定的互斥锁（由 &lt;code&gt;guard&lt;/code&gt; 表示）并阻塞当前线程。这意味着在互斥锁解锁后逻辑上发生的对&lt;a href=&quot;#method.notify_one&quot;&gt; &lt;code&gt;notify_one&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.notify_all&quot;&gt; &lt;code&gt;notify_all&lt;/code&gt; 的&lt;/a&gt;任何调用都是唤醒此线程的候选对象。当此函数调用返回时，将重新获得指定的锁。</target>
        </trans-unit>
        <trans-unit id="07010b30f6fb56afc898bded5d3cc83a49e39776" translate="yes" xml:space="preserve">
          <source>This function will atomically unlock the mutex specified (represented by &lt;code&gt;guard&lt;/code&gt;) and block the current thread. This means that any calls to &lt;a href=&quot;struct.condvar#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt; which happen logically after the mutex is unlocked are candidates to wake this thread up. When this function call returns, the lock specified will have been re-acquired.</source>
          <target state="translated">此函数将自动解锁指定的互斥锁（由 &lt;code&gt;guard&lt;/code&gt; 表示）并阻止当前线程。这意味着在互斥锁解锁后逻辑上发生的对&lt;a href=&quot;struct.condvar#method.notify_one&quot;&gt; &lt;code&gt;notify_one&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.condvar#method.notify_all&quot;&gt; &lt;code&gt;notify_all&lt;/code&gt; 的&lt;/a&gt;任何调用都是唤醒该线程的候选对象。当此函数调用返回时，将重新获得指定的锁。</target>
        </trans-unit>
        <trans-unit id="d633c453ad140c0449c1db8cbeeaa851bc2659b6" translate="yes" xml:space="preserve">
          <source>This function will attempt to ensure that all in-memory data reaches the filesystem before returning.</source>
          <target state="translated">该函数将尝试确保所有内存中的数据在返回之前到达文件系统。</target>
        </trans-unit>
        <trans-unit id="3cdc162bace3b7e0f3af0944a143fb84bab4d03d" translate="yes" xml:space="preserve">
          <source>This function will attempt to write the entire contents of &lt;code&gt;buf&lt;/code&gt;, but the entire write may not succeed, or the write may also generate an error. A call to &lt;code&gt;write&lt;/code&gt; represents &lt;em&gt;at most one&lt;/em&gt; attempt to write to any wrapped object.</source>
          <target state="translated">该函数将尝试写入 &lt;code&gt;buf&lt;/code&gt; 的全部内容，但是整个写入可能不会成功，或者写入可能还会生成错误。 &lt;code&gt;write&lt;/code&gt; 调用&lt;em&gt;最多&lt;/em&gt;表示一次写入任何包装对象的尝试。</target>
        </trans-unit>
        <trans-unit id="41d06b3c8e4189760b322760b47992d4717d7848" translate="yes" xml:space="preserve">
          <source>This function will be a noop if the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; backtrace variables are both not set. If either environment variable is set and enabled then this function will actually capture a backtrace. Capturing a backtrace can be both memory intensive and slow, so these environment variables allow liberally using &lt;code&gt;Backtrace::capture&lt;/code&gt; and only incurring a slowdown when the environment variables are set.</source>
          <target state="translated">如果未同时设置 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 或 &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; 回溯变量，则此函数为noop 。如果设置并启用了任何一个环境变量，则此函数实际上将捕获回溯。捕获回溯可能会占用大量内存，而且速度很慢，因此这些环境变量允许自由地使用 &lt;code&gt;Backtrace::capture&lt;/code&gt; 并且仅在设置环境变量时才会导致速度下降。</target>
        </trans-unit>
        <trans-unit id="d59143ff7e9860f113062c67363bd75c2092c35a" translate="yes" xml:space="preserve">
          <source>This function will be called when &lt;code&gt;wake&lt;/code&gt; is called on the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. It must wake up the task associated with this &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;上调用 &lt;code&gt;wake&lt;/code&gt; 时，将调用此函数。它必须唤醒与此&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;关联的任务。</target>
        </trans-unit>
        <trans-unit id="12cb59dc2a2a1b37303ef992097df532faaa8b94" translate="yes" xml:space="preserve">
          <source>This function will be called when &lt;code&gt;wake_by_ref&lt;/code&gt; is called on the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. It must wake up the task associated with this &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;上调用 &lt;code&gt;wake_by_ref&lt;/code&gt; 时，将调用此函数。它必须唤醒与此&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;关联的任务。</target>
        </trans-unit>
        <trans-unit id="76c72888278b0a8cb4941353a709e0ecd237c2c8" translate="yes" xml:space="preserve">
          <source>This function will be called when the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; gets cloned, e.g. when the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; in which the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; is stored gets cloned.</source>
          <target state="translated">当该功能将被称为&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;被克隆，例如，当&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;在其中&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;存储被克隆。</target>
        </trans-unit>
        <trans-unit id="83e27c1cac935244e1d8ce7e9b3bc5a49eb326cd" translate="yes" xml:space="preserve">
          <source>This function will block the calling thread until a new TCP connection is established. When established, the corresponding &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; and the remote peer's address will be returned.</source>
          <target state="translated">该函数将阻塞调用线程，直到建立新的TCP连接为止。建立后，将返回相应的&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;和远程对等方的地址。</target>
        </trans-unit>
        <trans-unit id="b771e75bfd99083821bb9279c74d5a51cd594b6a" translate="yes" xml:space="preserve">
          <source>This function will block the calling thread until a new Unix connection is established. When established, the corresponding &lt;a href=&quot;struct.unixstream&quot;&gt;&lt;code&gt;UnixStream&lt;/code&gt;&lt;/a&gt; and the remote peer's address will be returned.</source>
          <target state="translated">该函数将阻塞调用线程，直到建立新的Unix连接为止。建立后，将返回相应的&lt;a href=&quot;struct.unixstream&quot;&gt; &lt;code&gt;UnixStream&lt;/code&gt; &lt;/a&gt;和远程对等方的地址。</target>
        </trans-unit>
        <trans-unit id="4d1cb142862a95e8531c0e6c5eeff4f29562add6" translate="yes" xml:space="preserve">
          <source>This function will block the local thread until it is available to acquire the mutex. Upon returning, the thread is the only thread with the lock held. An RAII guard is returned to allow scoped unlock of the lock. When the guard goes out of scope, the mutex will be unlocked.</source>
          <target state="translated">该函数将阻塞本地线程,直到它可以获取mutex。返回后,该线程是唯一一个拥有锁的线程。返回一个RAII守卫,允许在范围内解锁。当守护超出范围时,mutex将被解锁。</target>
        </trans-unit>
        <trans-unit id="1061d2d5e43718addf8cd833a952b821898f457c" translate="yes" xml:space="preserve">
          <source>This function will capture a stack backtrace of the current OS thread of execution, returning a &lt;code&gt;Backtrace&lt;/code&gt; type which can be later used to print the entire stack trace or render it to a string.</source>
          <target state="translated">此函数将捕获当前执行的OS线程的堆栈回溯，并返回一个 &lt;code&gt;Backtrace&lt;/code&gt; 类型，该类型以后可用于打印整个堆栈跟踪或将其呈现为字符串。</target>
        </trans-unit>
        <trans-unit id="e63b5a3d38dde4813e2c02e7906910d9bbecad76" translate="yes" xml:space="preserve">
          <source>This function will cast the provided &lt;code&gt;bytes&lt;/code&gt; to a &lt;code&gt;CStr&lt;/code&gt; wrapper after ensuring that the byte slice is nul-terminated and does not contain any interior nul bytes.</source>
          <target state="translated">在确保字节片以nul终止并且不包含任何内部nul字节之后，此函数会将提供的 &lt;code&gt;bytes&lt;/code&gt; 转换为 &lt;code&gt;CStr&lt;/code&gt; 包装器。</target>
        </trans-unit>
        <trans-unit id="8c3891c10a9a0ae62223a6915ab48a717d1803e4" translate="yes" xml:space="preserve">
          <source>This function will cast the provided &lt;code&gt;bytes&lt;/code&gt; to a &lt;code&gt;CStr&lt;/code&gt; wrapper without performing any sanity checks. The provided slice &lt;strong&gt;must&lt;/strong&gt; be nul-terminated and not contain any interior nul bytes.</source>
          <target state="translated">此函数会将提供的 &lt;code&gt;bytes&lt;/code&gt; 转换为 &lt;code&gt;CStr&lt;/code&gt; 包装器，而不执行任何健全性检查。提供的片&lt;strong&gt;必须&lt;/strong&gt;以nul结尾，并且不包含任何内部nul字节。</target>
        </trans-unit>
        <trans-unit id="8f259ce0614bcf2d0063ac4400649f231860a760" translate="yes" xml:space="preserve">
          <source>This function will cause all pending and future I/O calls on the specified portions to immediately return with an appropriate value (see the documentation of &lt;a href=&quot;../../../net/enum.shutdown&quot;&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此函数将导致指定部分上的所有未决和将来的I / O调用立即以适当的值返回（请参见&lt;a href=&quot;../../../net/enum.shutdown&quot;&gt; &lt;code&gt;Shutdown&lt;/code&gt; &lt;/a&gt;的文档）。</target>
        </trans-unit>
        <trans-unit id="f2081c3bcdd573e767785b3929fff378af8293c8" translate="yes" xml:space="preserve">
          <source>This function will cause all pending and future I/O on the specified portions to return immediately with an appropriate value (see the documentation of &lt;a href=&quot;enum.shutdown&quot;&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此功能将导致指定部分上的所有未决和将来的I / O立即以适当的值返回（请参见&lt;a href=&quot;enum.shutdown&quot;&gt; &lt;code&gt;Shutdown&lt;/code&gt; &lt;/a&gt;的文档）。</target>
        </trans-unit>
        <trans-unit id="e9782cf601eece8d5d886326b28d5030905f50d6" translate="yes" xml:space="preserve">
          <source>This function will consume the provided data and use the underlying bytes to construct a new string, ensuring that there is a trailing 0 byte. This trailing 0 byte will be appended by this function; the provided data should &lt;em&gt;not&lt;/em&gt; contain any 0 bytes in it.</source>
          <target state="translated">此函数将使用提供的数据，并使用基础字节构造新的字符串，从而确保尾随0字节。这个尾随的0字节将被此函数附加；所提供的数据应&lt;em&gt;不&lt;/em&gt;包含在其中的任何0字节。</target>
        </trans-unit>
        <trans-unit id="4a81f58ae0af06c0e29ed9547bff428e9a075df5" translate="yes" xml:space="preserve">
          <source>This function will continuously read data from &lt;code&gt;reader&lt;/code&gt; and then write it into &lt;code&gt;writer&lt;/code&gt; in a streaming fashion until &lt;code&gt;reader&lt;/code&gt; returns EOF.</source>
          <target state="translated">该功能将不断读取数据 &lt;code&gt;reader&lt;/code&gt; ，然后将其写入 &lt;code&gt;writer&lt;/code&gt; 以流方式，直到 &lt;code&gt;reader&lt;/code&gt; 返回EOF。</target>
        </trans-unit>
        <trans-unit id="74b77ba5c4f9d07323cf0380138b2c4acac538aa" translate="yes" xml:space="preserve">
          <source>This function will correctly account for the flags provided as well as the minimum width. It will not take precision into account.</source>
          <target state="translated">该函数将正确地考虑所提供的标志以及最小宽度。它不会考虑精度。</target>
        </trans-unit>
        <trans-unit id="0e2de984561c8e2a215768e0c15afc535bb75bf0" translate="yes" xml:space="preserve">
          <source>This function will create a file if it does not exist, and will entirely replace its contents if it does.</source>
          <target state="translated">如果文件不存在,该函数将创建一个文件,如果存在,将完全替换其内容。</target>
        </trans-unit>
        <trans-unit id="f65976cf8345e044488976485c5a6e346af5a578" translate="yes" xml:space="preserve">
          <source>This function will create a file if it does not exist, and will truncate it if it does.</source>
          <target state="translated">如果文件不存在,该函数将创建一个文件,如果存在,该函数将截断它。</target>
        </trans-unit>
        <trans-unit id="0e1b8893ba63c7e2758784f05b5644780ac55d15" translate="yes" xml:space="preserve">
          <source>This function will ignore all instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; and will otherwise return any errors returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数将忽略&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;所有实例，否则将返回&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;返回的所有错误。</target>
        </trans-unit>
        <trans-unit id="a56b9fb350dbbed0024c336c03c94d6b856e68cd" translate="yes" xml:space="preserve">
          <source>This function will ignore all instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; and will otherwise return any errors returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数将忽略&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;所有实例，否则将返回&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;返回的所有错误。</target>
        </trans-unit>
        <trans-unit id="326c8120454de566fb3a6866a530ebb7b6b992dc" translate="yes" xml:space="preserve">
          <source>This function will never panic, but it may return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; has disconnected and is no longer able to receive information.</source>
          <target state="translated">此函数将永远不会崩溃，但是如果&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;断开连接并且不再能够接收信息，则它可能会返回&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9fc6b983aea89da54a39cad92dbfed108559d536" translate="yes" xml:space="preserve">
          <source>This function will never return and will immediately terminate the current process. The exit code is passed through to the underlying OS and will be available for consumption by another process.</source>
          <target state="translated">这个函数永远不会返回,并将立即终止当前进程。退出代码会传递给底层操作系统,并供另一个进程使用。</target>
        </trans-unit>
        <trans-unit id="c4fd0f129a9f8ea495fd3f5d41ad244c1f805fd1" translate="yes" xml:space="preserve">
          <source>This function will not block the calling thread and will only check to see if the child process has exited or not. If the child has exited then on Unix the process ID is reaped. This function is guaranteed to repeatedly return a successful exit status so long as the child has already exited.</source>
          <target state="translated">这个函数不会阻塞调用线程,只会检查子进程是否已经退出。如果子进程已经退出,那么在Unix上就会收获进程ID。只要子进程已经退出,这个函数就能保证反复返回成功退出状态。</target>
        </trans-unit>
        <trans-unit id="db8a9f6074ffbe2434b96b3349b436c824d317bf" translate="yes" xml:space="preserve">
          <source>This function will not return while other writers or other readers currently have access to the lock.</source>
          <target state="translated">当其他写手或其他读者当前有访问锁的权限时,该函数不会返回。</target>
        </trans-unit>
        <trans-unit id="f40a0312ebfb2b0e54e13329e7ace227d51b5cf1" translate="yes" xml:space="preserve">
          <source>This function will not traverse symlinks if this entry points at a symlink.</source>
          <target state="translated">如果该条目指向一个符号链接,该函数将不会遍历符号链接。</target>
        </trans-unit>
        <trans-unit id="30de93c6705afd606c5b68502e92fede48ab8cb8" translate="yes" xml:space="preserve">
          <source>This function will not traverse symlinks if this entry points at a symlink. To traverse symlinks use &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.file#method.metadata&quot;&gt;&lt;code&gt;fs::File::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该条目指向符号链接，则该功能将不会遍历符号链接。要遍历符号链接，请使用&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.file#method.metadata&quot;&gt; &lt;code&gt;fs::File::metadata&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c834f424a9053dbdf6234c9da264d70e8ba7b880" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;earlier&lt;/code&gt; is later than &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;earlier&lt;/code&gt; 于 &lt;code&gt;self&lt;/code&gt; ,则此功能会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="255f788a8373ceb0a89289a41ca323624e5b7999" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;k&lt;/code&gt; is greater than the length of the slice. Note that &lt;code&gt;k == self.len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">如果 &lt;code&gt;k&lt;/code&gt; 大于切片的长度，则此函数将出现紧急情况。需要注意的是 &lt;code&gt;k == self.len()&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，是一种无操作旋转。</target>
        </trans-unit>
        <trans-unit id="95270b721e4d05b72ba071aee1067eda4042613d" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;mid&lt;/code&gt; is greater than the length of the slice. Note that &lt;code&gt;mid == self.len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">如果 &lt;code&gt;mid&lt;/code&gt; 大于切片的长度，则此功能将出现紧急情况。需要注意的是 &lt;code&gt;mid == self.len()&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，是一种无操作旋转。</target>
        </trans-unit>
        <trans-unit id="e717b0d6a1e36e01967338ee832d65ba4d48839e" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;rhs&lt;/code&gt; is 0 or the division results in overflow.</source>
          <target state="translated">如果 &lt;code&gt;rhs&lt;/code&gt; 为0或除法导致溢出，则此函数将出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="46e96193daf65415936b126b06264ed8418f5b5e" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;rhs&lt;/code&gt; is 0.</source>
          <target state="translated">如果 &lt;code&gt;rhs&lt;/code&gt; 为0，则此功能会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="d72d270dceb6908b40e770de6a7cca4ee6d954fb" translate="yes" xml:space="preserve">
          <source>This function will panic if either range exceeds the end of the slice, or if the end of &lt;code&gt;src&lt;/code&gt; is before the start.</source>
          <target state="translated">如果范围超出切片的末尾，或者 &lt;code&gt;src&lt;/code&gt; 的末尾早于开始，则此函数将出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="ffa5cde970751a9af3f3c95b9bc636f122bbdd4f" translate="yes" xml:space="preserve">
          <source>This function will panic if the capacity would overflow.</source>
          <target state="translated">如果容量溢出,该功能将恐慌。</target>
        </trans-unit>
        <trans-unit id="157be01a917f2466c041055463b9f02120a94753" translate="yes" xml:space="preserve">
          <source>This function will panic if the position of the inner reader is smaller than the amount of buffered data. That can happen if the inner reader has an incorrect implementation of &lt;a href=&quot;trait.seek#method.stream_position&quot;&gt;&lt;code&gt;Seek::stream_position&lt;/code&gt;&lt;/a&gt;, or if the position has gone out of sync due to calling &lt;a href=&quot;trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;Seek::seek&lt;/code&gt;&lt;/a&gt; directly on the underlying reader.</source>
          <target state="translated">如果内部读取器的位置小于缓冲的数据量，则此功能将出现紧急情况。如果内部阅读器的&lt;a href=&quot;trait.seek#method.stream_position&quot;&gt; &lt;code&gt;Seek::stream_position&lt;/code&gt; &lt;/a&gt;实现不正确，或者由于直接在基础阅读器上调用&lt;a href=&quot;trait.seek#tymethod.seek&quot;&gt; &lt;code&gt;Seek::seek&lt;/code&gt; &lt;/a&gt;而导致位置不同步，则可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="000897a350419f9fea274e80815181a20fc49025" translate="yes" xml:space="preserve">
          <source>This function will panic if the two slices have different lengths, or if the implementation of &lt;code&gt;Clone&lt;/code&gt; panics.</source>
          <target state="translated">如果两个切片的长度不同，或者实现了 &lt;code&gt;Clone&lt;/code&gt; 恐慌，则此函数将恐慌。</target>
        </trans-unit>
        <trans-unit id="b80c161450352b3f264fa270e71aafac41ce5a3b" translate="yes" xml:space="preserve">
          <source>This function will panic if the two slices have different lengths.</source>
          <target state="translated">如果两个片子的长度不一样,这个功能就会恐慌。</target>
        </trans-unit>
        <trans-unit id="f9a04d3eaea11b5bf70c2b1e292fe13090c46ff0" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the delimiter or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">此函数将从底层流读取字节，直到找到定界符或EOF。找到后，直到定界符（包括定界符）的所有字节（如果找到）都将附加到 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dad503d6df9a455b05b17e9982a9b93c55eab53" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">该函数将从底层流中读取字节，直到找到换行符（0xA字节）或EOF。找到后，直到定界符（包括定界符）的所有字节（如果找到）都将附加到 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4641b6a37e2fa63178c9c82e80780dcf197015e4" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the newline delimiter (the &lt;code&gt;0xA&lt;/code&gt; byte) or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">该函数将从底层流中读取字节，直到找到换行符（ &lt;code&gt;0xA&lt;/code&gt; 字节）或EOF。找到后，直到定界符（包括定界符）（包括找到）的所有字节都将附加到 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5509bdb3a49d4f3afca9be3c4e49fc0d8f43d023" translate="yes" xml:space="preserve">
          <source>This function will resume execution of the generator or start execution if it hasn't already. This call will return back into the generator's last suspension point, resuming execution from the latest &lt;code&gt;yield&lt;/code&gt;. The generator will continue executing until it either yields or returns, at which point this function will return.</source>
          <target state="translated">此函数将恢复生成器的执行，如果尚未执行，则开始执行。该调用将返回到生成器的最后一个挂起点，从最新 &lt;code&gt;yield&lt;/code&gt; 继续执行。生成器将继续执行，直到它屈服或返回为止，然后该函数将返回。</target>
        </trans-unit>
        <trans-unit id="379fb0237a1103a33f0bdfcecfb22299eb043557" translate="yes" xml:space="preserve">
          <source>This function will return &lt;code&gt;Ok&lt;/code&gt; with the closure's result if the closure does not panic, and will return &lt;code&gt;Err(cause)&lt;/code&gt; if the closure panics. The &lt;code&gt;cause&lt;/code&gt; returned is the object with which panic was originally invoked.</source>
          <target state="translated">如果关闭不紧急，此函数将返回 &lt;code&gt;Ok&lt;/code&gt; 并返回关闭的结果；如果关闭紧急，此函数将返回 &lt;code&gt;Err(cause)&lt;/code&gt; 。返回的 &lt;code&gt;cause&lt;/code&gt; 是最初调用panic的对象。</target>
        </trans-unit>
        <trans-unit id="d89140f93781fe909c3c1a3e0e29b63c7e369dd7" translate="yes" xml:space="preserve">
          <source>This function will return an I/O error if the underlying reader was read, but returned an error.</source>
          <target state="translated">如果底层读卡器被读取,但返回错误,该函数将返回一个I/O错误。</target>
        </trans-unit>
        <trans-unit id="53872c0f37fe2cee76394788d7b1f123503054e5" translate="yes" xml:space="preserve">
          <source>This function will return an error if &lt;code&gt;path&lt;/code&gt; does not already exist. Other errors may also be returned according to &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 尚不存在，则此函数将返回错误。其他错误也可能根据&lt;a href=&quot;struct.openoptions#method.open&quot;&gt; &lt;code&gt;OpenOptions::open&lt;/code&gt; &lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="89c6971a5e8debeb3922f37bf3a67af3e6b7d708" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. An error will be returned when the lock is acquired.</source>
          <target state="translated">如果RwLock中毒,这个函数将返回一个错误。每当写入者在持有独占锁时感到恐慌时,RwLock就会中毒。当锁被获取时,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="dd9f12f8f4834cac09e7d8702d9c30c5d7a3ff26" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. An error will only be returned if the lock would have otherwise been acquired.</source>
          <target state="translated">如果RwLock中毒,这个函数将返回一个错误。每当写入者在持有独占锁时感到恐慌时,RwLock就会中毒。只有当锁在其他情况下被获取时,才会返回错误。</target>
        </trans-unit>
        <trans-unit id="853f4abcb0adc2f4d392d459e3d4bcbfc1ffde02" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. The failure will occur immediately after the lock has been acquired.</source>
          <target state="translated">如果RwLock中毒,这个函数将返回一个错误。每当写入者在持有独占锁时惊慌失措时,RwLock就会中毒。失败将在锁被获取后立即发生。</target>
        </trans-unit>
        <trans-unit id="08332f9ce278762f6fd52afefe704489d0688f37" translate="yes" xml:space="preserve">
          <source>This function will return an error if the file is not opened for writing.</source>
          <target state="translated">如果文件没有被打开写入,该函数将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="cdbfb4a0b16adba4591761f7aedf5e4a9ea34196" translate="yes" xml:space="preserve">
          <source>This function will return an error if the file is not opened for writing. Also, std::io::ErrorKind::InvalidInput will be returned if the desired length would cause an overflow due to the implementation specifics.</source>
          <target state="translated">如果文件没有被打开写入,这个函数将返回一个错误。同时,如果所需的长度会因为实现的特殊性而导致溢出,那么std::io::ErrorKind::InvalidInput将被返回。</target>
        </trans-unit>
        <trans-unit id="b6cdf441223c3eb9f4334399883d69c73ecd1bf4" translate="yes" xml:space="preserve">
          <source>This function will return an error if the mutex being waited on is poisoned when this thread re-acquires the lock. For more information, see information about &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning&lt;/a&gt; on the &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">如果正在等待等待的互斥锁在此线程重新获取锁时中毒，则此函数将返回错误。欲了解更多信息，请参阅有关信息&lt;a href=&quot;struct.mutex#poisoning&quot;&gt;毒害&lt;/a&gt;的&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="27a931587ff628dc51ea9585254e81a44150f056" translate="yes" xml:space="preserve">
          <source>This function will return an error if the supplied bytes contain an internal 0 byte. The &lt;a href=&quot;struct.nulerror&quot;&gt;&lt;code&gt;NulError&lt;/code&gt;&lt;/a&gt; returned will contain the bytes as well as the position of the nul byte.</source>
          <target state="translated">如果提供的字节包含内部0字节，则此函数将返回错误。返回的&lt;a href=&quot;struct.nulerror&quot;&gt; &lt;code&gt;NulError&lt;/code&gt; &lt;/a&gt;将包含字节以及nul字节的位置。</target>
        </trans-unit>
        <trans-unit id="dbf84289e9d9e4926b496bd897b3083ec6312b71" translate="yes" xml:space="preserve">
          <source>This function will return an error if the user lacks permission change attributes on the underlying file. It may also return an error in other os-specific unspecified cases.</source>
          <target state="translated">如果用户在底层文件上缺乏权限更改属性,这个函数将返回一个错误。在其他os特有的未指定的情况下,它也可能返回一个错误。</target>
        </trans-unit>
        <trans-unit id="5d42b76127c0c24013b14924e889090949109ff6" translate="yes" xml:space="preserve">
          <source>This function will return an error immediately if any call to &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns an error. All instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; are handled by this function and the underlying operation is retried.</source>
          <target state="translated">如果任何&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用返回错误，则此函数将立即返回错误。此函数处理&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;所有实例，并重试基础操作。</target>
        </trans-unit>
        <trans-unit id="6020fefae74dafb3cbf7677aedde54d28946007d" translate="yes" xml:space="preserve">
          <source>This function will return an error immediately if any call to &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; returns an error. All instances of &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; are handled by this function and the underlying operation is retried.</source>
          <target state="translated">如果任何 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 调用返回错误，则此函数将立即返回错误。此函数处理 &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; 所有实例，并重试基础操作。</target>
        </trans-unit>
        <trans-unit id="789ed5daa8073ac179354d082eb69d8ff28cdee6" translate="yes" xml:space="preserve">
          <source>This function will return an error in the following situations, but is not limited to just these cases:</source>
          <target state="translated">该函数将在以下情况下返回错误,但不限于这些情况。</target>
        </trans-unit>
        <trans-unit id="6c2926688126ed0bb4700cfc41330adcd34075d1" translate="yes" xml:space="preserve">
          <source>This function will return an error under a number of different circumstances. Some of these error conditions are listed here, together with their &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;. The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;code&gt;Other&lt;/code&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">在许多不同的情况下，此函数将返回错误。这里列出了其中一些错误条件，以及它们的&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt;。到&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt;的映射不是该功能的兼容性合同的一部分，尤其是将来 &lt;code&gt;Other&lt;/code&gt; 类型可能会更改为更特定的类型。</target>
        </trans-unit>
        <trans-unit id="dbf346cba719ecc4a64a28fdc51747223ea1ead1" translate="yes" xml:space="preserve">
          <source>This function will return an error under a number of different circumstances. Some of these error conditions are listed here, together with their &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;io::ErrorKind&lt;/code&gt;&lt;/a&gt;. The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;io::ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">在许多不同的情况下，此函数将返回错误。这里列出了其中一些错误条件，以及它们的&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;io::ErrorKind&lt;/code&gt; &lt;/a&gt;。到&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;io::ErrorKind&lt;/code&gt; &lt;/a&gt;的映射不是该功能的兼容性合同的一部分，尤其是将来&lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt;类型可能会更改为更特定的类型。</target>
        </trans-unit>
        <trans-unit id="b6a8bd83b584fa0f13cb1bcd08f12c3e0060dff9" translate="yes" xml:space="preserve">
          <source>This function will return an instance of &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; on error.</source>
          <target state="translated">此函数将在错误时返回一个&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="6fae4edeb2bc2b830762c223977c0f9e31e7f71d" translate="yes" xml:space="preserve">
          <source>This function will return any I/O error reported while formatting.</source>
          <target state="translated">该函数将返回格式化时报告的任何I/O错误。</target>
        </trans-unit>
        <trans-unit id="82d9dcac7df30707ace2de701aba5471ae21281c" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">该函数将返回非的第一个错误&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;那种&lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt;回报。</target>
        </trans-unit>
        <trans-unit id="cbfac2234e26fd5ad38b1fb7d157edb650781848" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">该函数将返回非的第一个错误&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;那种&lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt;回报。</target>
        </trans-unit>
        <trans-unit id="e505864f4a28d60809a69e771d2b212f82c7410c" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">此函数将返回&lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;返回的非&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误。</target>
        </trans-unit>
        <trans-unit id="e4e34f750f27d3b0d205fe34d5653142bb6c6abe" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">该函数将返回&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;返回的非&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误。</target>
        </trans-unit>
        <trans-unit id="749cf49b6adfac5a93f23dcbbade901579686611" translate="yes" xml:space="preserve">
          <source>This function will still &lt;code&gt;panic!()&lt;/code&gt; if the key is uninitialized and the key's initializer panics.</source>
          <target state="translated">如果该键未初始化并且该键的初始化程序出现紧急情况，则此函数仍然会 &lt;code&gt;panic!()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa2dcaf81660e38d976b3c073799f64e35c409b8" translate="yes" xml:space="preserve">
          <source>This function will traverse symbolic links to query information about the destination file.</source>
          <target state="translated">该函数将遍历符号链接,查询目标文件的信息。</target>
        </trans-unit>
        <trans-unit id="7a60f9a71c97e3c48d6ddbb61757095cfb7454e6" translate="yes" xml:space="preserve">
          <source>This function will traverse symbolic links to query information about the destination file. In case of broken symbolic links this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此函数将遍历符号链接以查询有关目标文件的信息。如果符号链接断开，则将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e9a4f19c05867342225932a802795ba8df8be2" translate="yes" xml:space="preserve">
          <source>This function will unsafely assume the pointer &lt;code&gt;src&lt;/code&gt; is valid for &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes by transmuting &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; and then reading the &lt;code&gt;&amp;amp;U&lt;/code&gt; (except that this is done in a way that is correct even when &lt;code&gt;&amp;amp;U&lt;/code&gt; makes stricter alignment requirements than &lt;code&gt;&amp;amp;T&lt;/code&gt;). It will also unsafely create a copy of the contained value instead of moving out of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">此功能将不安全假设指针 &lt;code&gt;src&lt;/code&gt; 是有效的&lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;通过嬗变字节 &lt;code&gt;&amp;amp;T&lt;/code&gt; 到 &lt;code&gt;&amp;amp;U&lt;/code&gt; ，然后读取 &lt;code&gt;&amp;amp;U&lt;/code&gt; （不同之处在于，这是在一种方式，是正确的，即使当完成 &lt;code&gt;&amp;amp;U&lt;/code&gt; 使得更严格的对准要求比 &lt;code&gt;&amp;amp;T&lt;/code&gt; ） 。它还将不安全地创建包含值的副本，而不是移出 &lt;code&gt;src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2144ac018e241484dd88280c401709723264165b" translate="yes" xml:space="preserve">
          <source>This function will unsafely assume the pointer &lt;code&gt;src&lt;/code&gt; is valid for &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes by transmuting &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; and then reading the &lt;code&gt;&amp;amp;U&lt;/code&gt;. It will also unsafely create a copy of the contained value instead of moving out of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">此功能将不安全假设指针 &lt;code&gt;src&lt;/code&gt; 是有效的&lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;通过嬗变字节 &lt;code&gt;&amp;amp;T&lt;/code&gt; 到 &lt;code&gt;&amp;amp;U&lt;/code&gt; ，然后读取 &lt;code&gt;&amp;amp;U&lt;/code&gt; 。它还将不安全地创建包含值的副本，而不是移出 &lt;code&gt;src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be98532def31c781d65ddc0b9dc20df02eb564e6" translate="yes" xml:space="preserve">
          <source>This function will wrap the provided &lt;code&gt;ptr&lt;/code&gt; with a &lt;code&gt;CStr&lt;/code&gt; wrapper, which allows inspection and interoperation of non-owned C strings. The total size of the raw C string must be smaller than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory due to calling the &lt;code&gt;slice::from_raw_parts&lt;/code&gt; function. This method is unsafe for a number of reasons:</source>
          <target state="translated">此函数将使用 &lt;code&gt;CStr&lt;/code&gt; 包装器包装提供的 &lt;code&gt;ptr&lt;/code&gt; ，该包装器允许检查和互斥非拥有的C字符串。由于调用 &lt;code&gt;slice::from_raw_parts&lt;/code&gt; 函数，原始C字符串的总大小必须小于内存中的 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;字节&lt;/strong&gt;。由于多种原因，此方法不安全：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5bb3f5f774e85331b120930c24070df4dbb7ef1" translate="yes" xml:space="preserve">
          <source>This function will wrap the provided &lt;code&gt;ptr&lt;/code&gt; with a &lt;code&gt;CStr&lt;/code&gt; wrapper, which allows inspection and interoperation of non-owned C strings. This method is unsafe for a number of reasons:</source>
          <target state="translated">此函数将使用 &lt;code&gt;CStr&lt;/code&gt; 包装器包装提供的 &lt;code&gt;ptr&lt;/code&gt; ，该包装器允许检查和互斥非拥有的C字符串。由于多种原因，此方法不安全：</target>
        </trans-unit>
        <trans-unit id="eb6de22f90abba9d8b2e22f07508357043cd45b1" translate="yes" xml:space="preserve">
          <source>This function will yield errors whenever &lt;a href=&quot;#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; would have also yielded an error.</source>
          <target state="translated">只要&lt;a href=&quot;#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt;也产生错误，此函数就会产生错误。</target>
        </trans-unit>
        <trans-unit id="0ec10f22723b4146e4ed97d9a1ccb195f6666569" translate="yes" xml:space="preserve">
          <source>This function will yield errors whenever &lt;a href=&quot;trait.bufread#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; would have also yielded an error.</source>
          <target state="translated">只要&lt;a href=&quot;trait.bufread#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt;也产生错误，此函数就会产生错误。</target>
        </trans-unit>
        <trans-unit id="761c3823fedfe961f64b60f5bbf8dadb1c015978" translate="yes" xml:space="preserve">
          <source>This function works on a best-effort basis, and may return false even when the &lt;code&gt;Waker&lt;/code&gt;s would awaken the same task. However, if this function returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that the &lt;code&gt;Waker&lt;/code&gt;s will awaken the same task.</source>
          <target state="translated">此函数尽力而为，即使 &lt;code&gt;Waker&lt;/code&gt; 唤醒了同一任务，它也可能返回false 。但是，如果此函数返回 &lt;code&gt;true&lt;/code&gt; ，则可以确保 &lt;code&gt;Waker&lt;/code&gt; 可以唤醒同一任务。</target>
        </trans-unit>
        <trans-unit id="0fef1eb994767850b63d5d3191f1364d1d996711" translate="yes" xml:space="preserve">
          <source>This function works similar to &lt;a href=&quot;../iter/trait.iterator#method.filter&quot;&gt;&lt;code&gt;Iterator::filter()&lt;/code&gt;&lt;/a&gt;. You can imagine the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; being an iterator over one or zero elements. &lt;code&gt;filter()&lt;/code&gt; lets you decide which elements to keep.</source>
          <target state="translated">该函数的工作原理类似于&lt;a href=&quot;../iter/trait.iterator#method.filter&quot;&gt; &lt;code&gt;Iterator::filter()&lt;/code&gt; &lt;/a&gt;。您可以想象 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 是一个或零个元素的迭代器。 &lt;code&gt;filter()&lt;/code&gt; 使您可以决定保留哪些元素。</target>
        </trans-unit>
        <trans-unit id="7ae0840523d6333733f66bb75a006add83e1ec36" translate="yes" xml:space="preserve">
          <source>This function works similar to &lt;code&gt;Iterator::filter()&lt;/code&gt;. You can imagine the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; being an iterator over one or zero elements. &lt;code&gt;filter()&lt;/code&gt; lets you decide which elements to keep.</source>
          <target state="translated">该函数的工作原理类似于 &lt;code&gt;Iterator::filter()&lt;/code&gt; 。您可以想象 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 是一个或零个元素的迭代器。 &lt;code&gt;filter()&lt;/code&gt; 使您可以决定保留哪些元素。</target>
        </trans-unit>
        <trans-unit id="113d936138ddc7ae4f63a1a50d8105ac5a7add0d" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s signature is less cluttered: the function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</source>
          <target state="translated">该函数的签名不太混乱：函数名称，参数列表和返回类型紧密靠近，类似于没有很多特征界限的函数。</target>
        </trans-unit>
        <trans-unit id="23da01dd3aa4ebf7371ab6dbecf83fca400f0b49" translate="yes" xml:space="preserve">
          <source>This function's behavior is unexpected and probably not what you want. Consider using a crate from crates.io instead.</source>
          <target state="translated">这个函数的行为是出乎意料的,可能不是你想要的。可以考虑使用 crates.io 的 crate 来代替。</target>
        </trans-unit>
        <trans-unit id="59db1f1ce2d556d00a44653625d9c4310aa82a71" translate="yes" xml:space="preserve">
          <source>This function, &lt;code&gt;first_word&lt;/code&gt;, has a &lt;code&gt;&amp;amp;String&lt;/code&gt; as a parameter. We don&amp;rsquo;t want ownership, so this is fine. But what should we return? We don&amp;rsquo;t really have a way to talk about &lt;em&gt;part&lt;/em&gt; of a string. However, we could return the index of the end of the word. Let&amp;rsquo;s try that, as shown in Listing 4-7.</source>
          <target state="translated">此函数 &lt;code&gt;first_word&lt;/code&gt; 具有 &lt;code&gt;&amp;amp;String&lt;/code&gt; 作为参数。我们不需要所有权，所以很好。但是，我们应该返回什么呢？我们真的没有办法谈论字符串的&lt;em&gt;一部分&lt;/em&gt;。但是，我们可以返回单词结尾的索引。让我们尝试一下，如清单4-7所示。</target>
        </trans-unit>
        <trans-unit id="c0b65dd63b8d87baa6cb2781b4c83fe9b710f211" translate="yes" xml:space="preserve">
          <source>This function, unlike &lt;code&gt;spawn&lt;/code&gt;, will &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;fork&lt;/code&gt; the process to create a new child. Like spawn, however, the default behavior for the stdio descriptors will be to inherited from the current process.</source>
          <target state="translated">与 &lt;code&gt;spawn&lt;/code&gt; 不同，此功能&lt;strong&gt;不会&lt;/strong&gt; &lt;code&gt;fork&lt;/code&gt; 创建新子进程。但是，像spawn一样，stdio描述符的默认行为将从当前进程继承。</target>
        </trans-unit>
        <trans-unit id="a7e07fc3dba284598652a13174e554562e5525f8" translate="yes" xml:space="preserve">
          <source>This handle encapsulates a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; instance, which defines the executor-specific wakeup behavior.</source>
          <target state="translated">该句柄封装了&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;实例，该实例定义了特定于执行者的唤醒行为。</target>
        </trans-unit>
        <trans-unit id="d605d26d55dc2758f0b6de9e17a49a349f074534" translate="yes" xml:space="preserve">
          <source>This handle implements both the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits, and is constructed via the &lt;a href=&quot;struct.stdin#method.lock&quot;&gt;&lt;code&gt;Stdin::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该句柄同时实现&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt;特性，并通过&lt;a href=&quot;struct.stdin#method.lock&quot;&gt; &lt;code&gt;Stdin::lock&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="f7258bae2e88ec63ae3dd338b65d64451a9b331b" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait, and is constructed via the &lt;a href=&quot;struct.stdout#method.lock&quot;&gt;&lt;code&gt;Stdout::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该句柄实现&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;特性，并通过&lt;a href=&quot;struct.stdout#method.lock&quot;&gt; &lt;code&gt;Stdout::lock&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="d288bcdc54960c2a1210bed705519ebb1c8b509b" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;code&gt;Read&lt;/code&gt; trait, but beware that concurrent reads of &lt;code&gt;Stdin&lt;/code&gt; must be executed with care.</source>
          <target state="translated">该句柄实现了 &lt;code&gt;Read&lt;/code&gt; 特质，但请注意必须同时执行对 &lt;code&gt;Stdin&lt;/code&gt; 的并发读取。</target>
        </trans-unit>
        <trans-unit id="01441d3c1d26b75fb46c2c721477af0652ee7979" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;code&gt;Write&lt;/code&gt; trait and is constructed via the &lt;a href=&quot;struct.stderr#method.lock&quot;&gt;&lt;code&gt;Stderr::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该句柄实现 &lt;code&gt;Write&lt;/code&gt; 特性，并通过&lt;a href=&quot;struct.stderr#method.lock&quot;&gt; &lt;code&gt;Stderr::lock&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="2708f4eb8582ea4d70309feff62a1d2748e13184" translate="yes" xml:space="preserve">
          <source>This handle is not buffered.</source>
          <target state="translated">这个句柄是没有缓冲的。</target>
        </trans-unit>
        <trans-unit id="6c48d5f61a1b6b181a01656b1e94697dc7bb9249" translate="yes" xml:space="preserve">
          <source>This happens because the pointer returned by &lt;code&gt;as_ptr&lt;/code&gt; does not carry any lifetime information and the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; is deallocated immediately after the &lt;code&gt;CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr()&lt;/code&gt; expression is evaluated. To fix the problem, bind the &lt;code&gt;CString&lt;/code&gt; to a local variable:</source>
          <target state="translated">这是因为通过返回的指针 &lt;code&gt;as_ptr&lt;/code&gt; 不携带任何寿命信息和&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; 的&lt;/a&gt;是后立即释放 &lt;code&gt;CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr()&lt;/code&gt; 表达式。要解决此问题，请将 &lt;code&gt;CString&lt;/code&gt; 绑定到本地变量：</target>
        </trans-unit>
        <trans-unit id="6047b82331195849fba72da79674452a117df64d" translate="yes" xml:space="preserve">
          <source>This happens when a trait has a method like the following:</source>
          <target state="translated">当一个特质有一个类似下面的方法时,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="863bad715d4f6d1bd75efa3884a2cc5b250ca381" translate="yes" xml:space="preserve">
          <source>This has the same behavior as the &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这具有与&lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt;方法相同的行为。</target>
        </trans-unit>
        <trans-unit id="6a3c452ab4ee63f33d895b0f991faaa23887feb8" translate="yes" xml:space="preserve">
          <source>This has the same behavior as the &lt;a href=&quot;struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这具有与&lt;a href=&quot;struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt;方法相同的行为。</target>
        </trans-unit>
        <trans-unit id="b58a8c2add590746e5048b4f132cbbc19047500f" translate="yes" xml:space="preserve">
          <source>This has the same effect as &lt;a href=&quot;union.maybeuninit#method.zeroed&quot;&gt;&lt;code&gt;MaybeUninit::zeroed().assume_init()&lt;/code&gt;&lt;/a&gt;. It is useful for FFI sometimes, but should generally be avoided.</source>
          <target state="translated">这与&lt;a href=&quot;union.maybeuninit#method.zeroed&quot;&gt; &lt;code&gt;MaybeUninit::zeroed().assume_init()&lt;/code&gt; &lt;/a&gt;。assume_init（）具有相同的效果。有时对FFI很有用，但通常应避免使用。</target>
        </trans-unit>
        <trans-unit id="c7eb4340faf9e85d2da20b4776ce2bebbe29c12a" translate="yes" xml:space="preserve">
          <source>This has the same lifetime as the original slice, and so the iterator can continue to be used while this exists.</source>
          <target state="translated">这和原来的分片有相同的寿命,所以在这个存在的时候,迭代器可以继续使用。</target>
        </trans-unit>
        <trans-unit id="65d35375dd8acb85bc9eba434584e8313fb0a245" translate="yes" xml:space="preserve">
          <source>This hasher is not guaranteed to be the same as all other &lt;code&gt;DefaultHasher&lt;/code&gt; instances, but is the same as all other &lt;code&gt;DefaultHasher&lt;/code&gt; instances created through &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">不保证此哈希器与所有其他 &lt;code&gt;DefaultHasher&lt;/code&gt; 实例相同，但与通过 &lt;code&gt;new&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 创建的所有其他 &lt;code&gt;DefaultHasher&lt;/code&gt; 实例相同。</target>
        </trans-unit>
        <trans-unit id="90feee4915436dfe2be982f4c15a9da7834c5004" translate="yes" xml:space="preserve">
          <source>This implementation is specialized for slice iterators, where it uses &lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt; to append the entire slice at once.</source>
          <target state="translated">此实现专用于切片迭代器，它使用&lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt;一次附加整个切片。</target>
        </trans-unit>
        <trans-unit id="0b6b99c1c8632506c647afb83336adc1ee13b73f" translate="yes" xml:space="preserve">
          <source>This information corresponds to the &lt;code&gt;sin6_flowinfo&lt;/code&gt; field in C's &lt;code&gt;netinet/in.h&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;. It combines information about the flow label and the traffic class as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2460&quot;&gt;IETF RFC 2460&lt;/a&gt;, respectively &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-6&quot;&gt;Section 6&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">此信息对应于&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553第3.3节中&lt;/a&gt;指定的C的 &lt;code&gt;netinet/in.h&lt;/code&gt; 中的 &lt;code&gt;sin6_flowinfo&lt;/code&gt; 字段。它根据&lt;a href=&quot;https://tools.ietf.org/html/rfc2460&quot;&gt;IETF RFC 2460的&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-6&quot;&gt;第6 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-7&quot;&gt;节&lt;/a&gt;和第7节分别结合了有关流标签和流量类的信息。</target>
        </trans-unit>
        <trans-unit id="3af31b70c11ef4a3b608a04beaf7ba9284e068c3" translate="yes" xml:space="preserve">
          <source>This information corresponds to the &lt;code&gt;sin6_scope_id&lt;/code&gt; field in C's &lt;code&gt;netinet/in.h&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;.</source>
          <target state="translated">此信息对应于&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553第3.3节中&lt;/a&gt;指定的C的 &lt;code&gt;netinet/in.h&lt;/code&gt; 中的 &lt;code&gt;sin6_scope_id&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ec67651ac375d4791b71fe8abc3629f814f16ccf" translate="yes" xml:space="preserve">
          <source>This information is a hint and implementations are not required to preserve it.</source>
          <target state="translated">这些信息是一种提示,实施者不需要保存这些信息。</target>
        </trans-unit>
        <trans-unit id="63ed31757d724807cc9238c95c5432cd39c9735a" translate="yes" xml:space="preserve">
          <source>This instance may reach &lt;code&gt;EOF&lt;/code&gt; after reading fewer bytes than indicated by this method if the underlying &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; instance reaches EOF.</source>
          <target state="translated">这种情况下可能达到 &lt;code&gt;EOF&lt;/code&gt; 读取比通过该方法表明，如果基础更少的字节后&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;实例达到EOF。</target>
        </trans-unit>
        <trans-unit id="3e890a8fb1ba0d0cd9928016f0c75ede3fcfd9a0" translate="yes" xml:space="preserve">
          <source>This intrinsic does not have a stable counterpart.</source>
          <target state="translated">这种内在并没有稳定的对应关系。</target>
        </trans-unit>
        <trans-unit id="b4ee533fa428c42a5629056a56b7692fc9445d45" translate="yes" xml:space="preserve">
          <source>This intrinsic should not be used outside of the compiler.</source>
          <target state="translated">在编译器之外,不应使用这个固有的。</target>
        </trans-unit>
        <trans-unit id="1fa64cf4a4634521305dce783239fdfdeec13027" translate="yes" xml:space="preserve">
          <source>This is a &quot;helper marker trait&quot; used to provide impl blocks for the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait, for more information see that documentation.</source>
          <target state="translated">这是一个&amp;ldquo;帮助标记特征&amp;rdquo;，用于为&lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;特征提供impl块，有关更多信息，请参阅该文档。</target>
        </trans-unit>
        <trans-unit id="dca2a0780f1a583478627dae521a3cd19fa18332" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.create&quot;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; with fewer imports.</source>
          <target state="translated">这是使用&lt;a href=&quot;struct.file#method.create&quot;&gt; &lt;code&gt;File::create&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;且导入次数较少的便捷功能。</target>
        </trans-unit>
        <trans-unit id="8a3e47d631d6356541264338a28634452afdd7c3" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a vector created with &lt;a href=&quot;../vec/struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是使用&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt; &lt;code&gt;read_to_end&lt;/code&gt; &lt;/a&gt;且导入次数较少且没有中间变量的便捷功能。它会根据文件大小（如果有）预先分配一个缓冲区，因此通常比读入&lt;a href=&quot;../vec/struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new()&lt;/code&gt; &lt;/a&gt;创建的向量要快。</target>
        </trans-unit>
        <trans-unit id="187131cff0eb9e697908b49a26f702ec337c3799" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a vector created with &lt;code&gt;Vec::new()&lt;/code&gt;.</source>
          <target state="translated">这是使用&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt; &lt;code&gt;read_to_end&lt;/code&gt; &lt;/a&gt;且导入次数较少且没有中间变量的便捷功能。它会根据文件大小（如果有）预先分配一个缓冲区，因此通常比读入 &lt;code&gt;Vec::new()&lt;/code&gt; 创建的向量要快。</target>
        </trans-unit>
        <trans-unit id="4ad096cd1a7e9fdbf72506102cbfdd2fbcf9b981" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt;&lt;code&gt;read_to_string&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a string created with &lt;a href=&quot;../string/struct.string#method.new&quot;&gt;&lt;code&gt;String::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是使用&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt; &lt;code&gt;read_to_string&lt;/code&gt; &lt;/a&gt;且导入次数较少且没有中间变量的便捷功能。它会根据文件大小（如果有）预先分配一个缓冲区，因此通常比读取用&lt;a href=&quot;../string/struct.string#method.new&quot;&gt; &lt;code&gt;String::new()&lt;/code&gt; &lt;/a&gt;创建的字符串要快。</target>
        </trans-unit>
        <trans-unit id="9c7392177420bfa03e5c328d086366669dabd90c" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt;&lt;code&gt;read_to_string&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a string created with &lt;code&gt;String::new()&lt;/code&gt;.</source>
          <target state="translated">这是使用&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt; &lt;code&gt;read_to_string&lt;/code&gt; &lt;/a&gt;且导入次数较少且没有中间变量的便捷功能。它会根据文件大小（如果有）预先分配一个缓冲区，因此通常比读取用 &lt;code&gt;String::new()&lt;/code&gt; 创建的字符串更快。</target>
        </trans-unit>
        <trans-unit id="6368465bb72af615f875d8e839f3e68ea414aaaa" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; and handle its &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;&lt;code&gt;fs::Metadata::is_dir&lt;/code&gt;&lt;/a&gt; if it was &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个便利功能，可将错误强制为false。如果要检查错误，请调用&lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;并处理其&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;。然后调用&lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt; &lt;code&gt;fs::Metadata::is_dir&lt;/code&gt; &lt;/a&gt;如果它是&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ec158d2dde1ce8ee75d1772394d851e65f39fd6" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; and handle its &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;&lt;code&gt;fs::Metadata::is_file&lt;/code&gt;&lt;/a&gt; if it was &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个便利功能，可将错误强制为false。如果要检查错误，请调用&lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;并处理其&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;。然后调用&lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt; &lt;code&gt;fs::Metadata::is_file&lt;/code&gt; &lt;/a&gt;如果它是&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f680ca8918b755dd586b16c26d23dbb3dd42957" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个便利功能，可将错误强制为false。如果要检查错误，请致电&lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dac9be08ca6ab3c0d6956dc411e028285b59848d" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt; and handle its Result. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;fs::Metadata::is_dir&lt;/a&gt; if it was Ok.</source>
          <target state="translated">这是一种便利功能，可将错误强制为false。如果要检查错误，请调用&lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata&lt;/a&gt;并处理其结果。如果还可以，则调用&lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;fs :: Metadata :: is_dir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78d539aab76737f8cf396eefb6d1ce6f5b6f255b" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt; and handle its Result. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;fs::Metadata::is_file&lt;/a&gt; if it was Ok.</source>
          <target state="translated">这是一种便利功能，可将错误强制为false。如果要检查错误，请调用&lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata&lt;/a&gt;并处理其结果。如果还可以，则调用&lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;fs :: Metadata :: is_file&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63bfc9edacf3bb27391de3d729c554b4c3c2df6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt;.</source>
          <target state="translated">这是一种便利功能，可将错误强制为false。如果要检查错误，请致电&lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="748753921bdcefd01924d5e43ae2dad4f042e3b3" translate="yes" xml:space="preserve">
          <source>This is a cost-free conversion.</source>
          <target state="translated">这是一种无成本的转换。</target>
        </trans-unit>
        <trans-unit id="0bed32ad8a4ac210351c4fe08ac569f4ede1369a" translate="yes" xml:space="preserve">
          <source>This is a curious macro used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:</source>
          <target state="translated">这是一个奇特的宏,用于安全地传递一个描述格式字符串的不透明对象。这个对象不需要任何堆分配来创建,它只引用栈上的信息。在下面,所有相关的宏都是用这个来实现的。首先,一些使用实例是。</target>
        </trans-unit>
        <trans-unit id="29fa7c971247c161eeccc64d10b730dfdf57cf6f" translate="yes" xml:space="preserve">
          <source>This is a curious macro which is used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:</source>
          <target state="translated">这是一个奇特的宏,用于安全地传递一个描述格式字符串的不透明对象。这个对象不需要任何堆分配来创建,它只引用栈上的信息。在下面,所有相关的宏都是用这个来实现的。首先,一些使用实例是。</target>
        </trans-unit>
        <trans-unit id="a5cb34f6e2e869f23ba4b01f87c2789e85bd0de1" translate="yes" xml:space="preserve">
          <source>This is a generic method to go from &lt;code&gt;&amp;amp;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;. It is safe because, as part of the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, the pointee cannot move after &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; got created. &quot;Malicious&quot; implementations of &lt;code&gt;Pointer::Deref&lt;/code&gt; are likewise ruled out by the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;.</source>
          <target state="translated">这是从 &lt;code&gt;&amp;amp;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 到 &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 的通用方法。这是安全的，因为作为 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 合同的一部分，在创建 &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 后，承办人无法移动。同样， &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 的合同也排除了 &lt;code&gt;Pointer::Deref&lt;/code&gt; &amp;ldquo;恶意&amp;rdquo;实现。</target>
        </trans-unit>
        <trans-unit id="56c4f5951c7828ae5ee50cc814a919ce365cfc61" translate="yes" xml:space="preserve">
          <source>This is a generic method to go from &lt;code&gt;&amp;amp;mut Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;. It is safe because, as part of the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, the pointee cannot move after &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; got created. &quot;Malicious&quot; implementations of &lt;code&gt;Pointer::DerefMut&lt;/code&gt; are likewise ruled out by the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;.</source>
          <target state="translated">这是从 &lt;code&gt;&amp;amp;mut Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 到 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 的通用方法。这是安全的，因为作为 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 合同的一部分，在创建 &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 后，承办人无法移动。同样， &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 的合同也排除了 &lt;code&gt;Pointer::DerefMut&lt;/code&gt; &amp;ldquo;恶意&amp;rdquo;实现。</target>
        </trans-unit>
        <trans-unit id="89763ee5b7958c417ffa6362fe62836bd12504df" translate="yes" xml:space="preserve">
          <source>This is a great time to build a more substantial program to get used to reading and writing Rust code. So, in Chapter 2, we&amp;rsquo;ll build a guessing game program. If you would rather start by learning how common programming concepts work in Rust, see Chapter 3 and then return to Chapter 2.</source>
          <target state="translated">这是构建更强大的程序以习惯于阅读和编写Rust代码的好时机。因此，在第二章中，我们将构建一个猜测游戏程序。如果您想开始学习Rust中常见的编程概念的工作原理，请参阅第3章，然后返回第2章。</target>
        </trans-unit>
        <trans-unit id="bafda2af6137ec515a17c15aeff3f2735f4091da" translate="yes" xml:space="preserve">
          <source>This is a hack to work around a limitation in our type system.</source>
          <target state="translated">这是为解决我们的类型系统中的一个限制而做的一个黑客。</target>
        </trans-unit>
        <trans-unit id="b462da8b85a8420993ace33b35e2459c3b0f94de" translate="yes" xml:space="preserve">
          <source>This is a hack to workaround a limitation in our type-system.</source>
          <target state="translated">这是为解决我们类型系统中的一个限制而进行的黑客攻击。</target>
        </trans-unit>
        <trans-unit id="88ca2eb8b4f8037d6f9bc35aac9a7c204a66255a" translate="yes" xml:space="preserve">
          <source>This is a larger example that implements &lt;a href=&quot;http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra's algorithm&lt;/a&gt; to solve the &lt;a href=&quot;http://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;shortest path problem&lt;/a&gt; on a &lt;a href=&quot;http://en.wikipedia.org/wiki/Directed_graph&quot;&gt;directed graph&lt;/a&gt;. It shows how to use &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; with custom types.</source>
          <target state="translated">这是一个较大的示例，该示例实现了&lt;a href=&quot;http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra的算法&lt;/a&gt;来解决有&lt;a href=&quot;http://en.wikipedia.org/wiki/Directed_graph&quot;&gt;向图&lt;/a&gt;上的&lt;a href=&quot;http://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;最短路径问题&lt;/a&gt;。它显示了如何将&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;与自定义类型一起使用。</target>
        </trans-unit>
        <trans-unit id="0ce22a5b8db2ccd4642599318fe60aee2faa03ed" translate="yes" xml:space="preserve">
          <source>This is a larger example that implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra's algorithm&lt;/a&gt; to solve the &lt;a href=&quot;https://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;shortest path problem&lt;/a&gt; on a &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_graph&quot;&gt;directed graph&lt;/a&gt;. It shows how to use &lt;a href=&quot;../struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; with custom types.</source>
          <target state="translated">这是一个较大的示例，实现了&lt;a href=&quot;https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra的算法&lt;/a&gt;来解决有&lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_graph&quot;&gt;向图&lt;/a&gt;上的&lt;a href=&quot;https://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;最短路径问题&lt;/a&gt;。它显示了如何将&lt;a href=&quot;../struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;与自定义类型一起使用。</target>
        </trans-unit>
        <trans-unit id="26c511330b7bfd645fe1ae62ba92f808907b836b" translate="yes" xml:space="preserve">
          <source>This is a low-level operation that maintains none of the normal invariants of the type. Normally changing the length of a vector is done using one of the safe operations instead, such as &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.extend-1&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个低级操作，不保留该类型的任何普通不变式。通常，向量的长度更改是使用安全操作之一来完成的，例如&lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;truncate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#method.extend-1&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f83da737778161016a797e059513bd95b7a1b562" translate="yes" xml:space="preserve">
          <source>This is a low-level operation that maintains none of the normal invariants of the type. Normally changing the length of a vector is done using one of the safe operations instead, such as &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../iter/trait.extend#tymethod.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个低级操作，不保留该类型的任何普通不变式。通常，向量的长度更改是使用安全操作之一来完成的，例如&lt;a href=&quot;struct.vec#method.truncate&quot;&gt; &lt;code&gt;truncate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.vec#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../iter/trait.extend#tymethod.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.vec#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5a83358209b9d321dd626221b446c20e90a835f" translate="yes" xml:space="preserve">
          <source>This is a lower-level version of &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;的较低版本。</target>
        </trans-unit>
        <trans-unit id="d779513c1e09f65a072541be686df3371c86d19d" translate="yes" xml:space="preserve">
          <source>This is a minimal HTML5 document with a heading and some text. To return this from the server when a request is received, we&amp;rsquo;ll modify &lt;code&gt;handle_connection&lt;/code&gt; as shown in Listing 20-5 to read the HTML file, add it to the response as a body, and send it.</source>
          <target state="translated">这是一个带有标题和一些文本的最小HTML5文档。为了在收到请求时从服务器返回此消息，我们将如清单20-5所示修改 &lt;code&gt;handle_connection&lt;/code&gt; ，以读取HTML文件，将其作为正文添加到响应中，然后发送它。</target>
        </trans-unit>
        <trans-unit id="b1799e7b3d355702a52652e9f785dc24c41920f9" translate="yes" xml:space="preserve">
          <source>This is a parameter for the &quot;minimum width&quot; that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space (see below).</source>
          <target state="translated">这是一个参数,用于表示格式应该占用的 &quot;最小宽度&quot;。如果值的字符串没有填满这个字符,那么将使用fill/alignment指定的padding来占用所需空间(见下文)。</target>
        </trans-unit>
        <trans-unit id="3a7bcaac4b774ad822d1d354cccc21a6015fca6e" translate="yes" xml:space="preserve">
          <source>This is a parameter for the &quot;minimum width&quot; that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space.</source>
          <target state="translated">这是格式应占用的 &quot;最小宽度 &quot;的参数,如果值的字符串没有填满这么多字符,那么将使用fill/alignment指定的padding来占用所需空间。如果值的字符串没有填满这个字符,那么将使用fill/alignment指定的padding来占用所需空间。</target>
        </trans-unit>
        <trans-unit id="b084ef158428b63f0e7eeac68dee8b3d095bdb3c" translate="yes" xml:space="preserve">
          <source>This is a situation in which interior mutability can help! We&amp;rsquo;ll store the &lt;code&gt;sent_messages&lt;/code&gt; within a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, and then the &lt;code&gt;send&lt;/code&gt; message will be able to modify &lt;code&gt;sent_messages&lt;/code&gt; to store the messages we&amp;rsquo;ve seen. Listing 15-22 shows what that looks like:</source>
          <target state="translated">在这种情况下，内部可变性可以提供帮助！我们将 &lt;code&gt;sent_messages&lt;/code&gt; 存储在 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，然后 &lt;code&gt;send&lt;/code&gt; 消息将能够修改 &lt;code&gt;sent_messages&lt;/code&gt; 以存储我们已经看到的消息。清单15-22显示了如下内容：</target>
        </trans-unit>
        <trans-unit id="871d091695de2003c7e2185527248e9604155d93" translate="yes" xml:space="preserve">
          <source>This is a syntax error at the level of attribute declarations. The proper syntax for &lt;code&gt;align&lt;/code&gt; representation hint is the following:</source>
          <target state="translated">这是属性声明级别的语法错误。 &lt;code&gt;align&lt;/code&gt; 表示提示的正确语法如下：</target>
        </trans-unit>
        <trans-unit id="e698a362ad50285269b0f450993154391ed3fb9c" translate="yes" xml:space="preserve">
          <source>This is a syntax error at the level of attribute declarations. The proper syntax for macro imports is the following:</source>
          <target state="translated">这是一个属性声明层面的语法错误。宏导入的正确语法如下:</target>
        </trans-unit>
        <trans-unit id="7207d1f263b95ee330100ad60d168c6bbd00e341" translate="yes" xml:space="preserve">
          <source>This is a very simple case, of course. In more complex cases, we may wish to have more than one reference to the value that was borrowed -- in those cases, something like the &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt; types may be useful.</source>
          <target state="translated">当然，这是一个非常简单的情况。在更复杂的情况下，我们可能希望引用多个借用的值-在这种情况下，类似于 &lt;code&gt;Rc&lt;/code&gt; 或 &lt;code&gt;Arc&lt;/code&gt; 类型可能有用。</target>
        </trans-unit>
        <trans-unit id="795aa426a1aadc3299f800d117f15424e179c91c" translate="yes" xml:space="preserve">
          <source>This is a wrapper around a kind of pointer which makes that pointer &quot;pin&quot; its value in place, preventing the value referenced by that pointer from being moved unless it implements &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一种指针的包装，该指针使该指针&amp;ldquo;固定&amp;rdquo;在适当的位置，除非该指针实现&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; ,&lt;/a&gt;否则防止该指针引用的值移动。</target>
        </trans-unit>
        <trans-unit id="40cc1dd050d81853f1d6473844a8f5105ed4ba71" translate="yes" xml:space="preserve">
          <source>This is also available via &lt;a href=&quot;../convert/trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">也可以通过&lt;a href=&quot;../convert/trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; 获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69c7de76e4d6cac4ead699615a01132090109223" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation as it requires copying every element in the buffer.</source>
          <target state="translated">这是 &lt;code&gt;O(n)&lt;/code&gt; 操作，因为它需要复制缓冲区中的每个元素。</target>
        </trans-unit>
        <trans-unit id="7714852846e41026b7148ab604a67c761a44e811" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation, as it requires copying every element in the buffer.</source>
          <target state="translated">这是一个 &lt;code&gt;O(n)&lt;/code&gt; 操作，因为它需要复制缓冲区中的每个元素。</target>
        </trans-unit>
        <trans-unit id="0851cea6a2c1ead7bc3e7afcac1e76a989dd5af9" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) operation as it requires copying every element in the buffer.</source>
          <target state="translated">这是&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）操作，因为它需要复制缓冲区中的每个元素。</target>
        </trans-unit>
        <trans-unit id="ebfdb05e0c25e262e85513236d16ce28096eaa2c" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) operation, as it requires copying every element in the buffer.</source>
          <target state="translated">这是一个&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）操作，因为它需要复制缓冲区中的每个元素。</target>
        </trans-unit>
        <trans-unit id="e7773930b7607b5b74b44eb47accc2cfca7d33e4" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;unsized&lt;/em&gt; type, meaning that it must always be used behind a pointer like &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;. For an owned version of this type, see &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个&lt;em&gt;无大小的&lt;/em&gt;类型，这意味着必须始终在 &lt;code&gt;&amp;amp;&lt;/code&gt; 或&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; 之&lt;/a&gt;类的指针后面使用它。有关此类型的拥有版本，请参见&lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae5b715f0a76526280a5abae050e91bd520680ba" translate="yes" xml:space="preserve">
          <source>This is an absolute path starting with &lt;code&gt;std&lt;/code&gt;, the name of the standard library crate.</source>
          <target state="translated">这是一个以 &lt;code&gt;std&lt;/code&gt; 开头的绝对路径，std是标准库箱的名称。</target>
        </trans-unit>
        <trans-unit id="fb3851cbc0fb3af560d20b0226cbd7a0adc72483" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;fs::canonicalize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;fs::canonicalize&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="ccff757092656f4cd5645f893d07b3a2270144b9" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="fe9cf4a133a88b8bc470c4394f4eb8cf3b306e68" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_dir&quot;&gt;&lt;code&gt;fs::read_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.read_dir&quot;&gt; &lt;code&gt;fs::read_dir&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="f461dafd60906d9babd38850b381951321bafa0a" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_link&quot;&gt;&lt;code&gt;fs::read_link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.read_link&quot;&gt; &lt;code&gt;fs::read_link&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="8a772f821d093dc45f53501fe5deb3218dd74356" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="d34ac7564172d2ff8117857aff9df3320c42fae5" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::clone(...)&lt;/code&gt;. A &lt;code&gt;Clone&lt;/code&gt; implementation or a method would interfere with the widespread use of &lt;code&gt;r.borrow().clone()&lt;/code&gt; to clone the contents of a &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="translated">这是一个相关函数，需要用作 &lt;code&gt;Ref::clone(...)&lt;/code&gt; 。一个 &lt;code&gt;Clone&lt;/code&gt; 的实现或方法将与广泛使用的干扰 &lt;code&gt;r.borrow().clone()&lt;/code&gt; 克隆的内容 &lt;code&gt;RefCell&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de597cdfc25d4b695eb376a8a0838157803d015" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个关联函数，需要用作 &lt;code&gt;Ref::leak(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f83e3e547dadb3f845f93bfeaf6231ee030e91c8" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个关联函数，需要用作 &lt;code&gt;Ref::map(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f18aedd0b02030c35b1012078adf973833d874e" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个关联函数，需要用作 &lt;code&gt;Ref::map_split(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9124c09eb61044a9051beed91e77bd6ffcbf176" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个相关函数，需要用作 &lt;code&gt;RefMut::leak(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14ab5139ea01a60d2224bebc358fd7f5a09aee7b" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个相关函数，需要用作 &lt;code&gt;RefMut::map(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="202f23e551bc61ba34f51a486b60ddfce30150ab" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">这是一个相关函数，需要用作 &lt;code&gt;RefMut::map_split(...)&lt;/code&gt; 。一种方法，将与上一个的内容相同的名称的方法干扰 &lt;code&gt;RefCell&lt;/code&gt; 通过使用 &lt;code&gt;Deref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb3bd037be08bb82591900e7ddf468637a2b8c80" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; from.</source>
          <target state="translated">这适用于初始化未初始化的内存，或覆盖先前已&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;内存。</target>
        </trans-unit>
        <trans-unit id="856709efbf0ee049257184bc9760c0b3d18a43eb" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read with &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这适用于初始化未初始化的内存，或覆盖以前使用&lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt;读取的内存。</target>
        </trans-unit>
        <trans-unit id="9049d14f9f0cb6f47694e4f8dd6256baa32e595c" translate="yes" xml:space="preserve">
          <source>This is based on &lt;code&gt;malloc&lt;/code&gt; on Unix platforms and &lt;code&gt;HeapAlloc&lt;/code&gt; on Windows, plus related functions.</source>
          <target state="translated">它基于Unix平台上的 &lt;code&gt;malloc&lt;/code&gt; 和Windows 上的 &lt;code&gt;HeapAlloc&lt;/code&gt; ，以及相关功能。</target>
        </trans-unit>
        <trans-unit id="d9e17b1971fcc8ebac923ca9bdcdbe86fd7ccc27" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;AddAssign&lt;/code&gt; is not automatically implemented, so you need to manually implement it for your type.</source>
          <target state="translated">这是因为 &lt;code&gt;AddAssign&lt;/code&gt; 不会自动实现，因此您需要为您的类型手动实现它。</target>
        </trans-unit>
        <trans-unit id="5c0cfc8e697e9e04f2ac8988522860bd36ed371a" translate="yes" xml:space="preserve">
          <source>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</source>
          <target state="translated">这是因为单元格类型做的操作不是线程安全的。由于这个原因,它们没有实现同步,因此不能放在静态中。</target>
        </trans-unit>
        <trans-unit id="43247ccf0e7189f6826d62c195b63176c827f652" translate="yes" xml:space="preserve">
          <source>This is because of a type mismatch between the associated type of some trait (e.g., &lt;code&gt;T::Bar&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt;) and another type &lt;code&gt;U&lt;/code&gt; that is required to be equal to &lt;code&gt;T::Bar&lt;/code&gt;, but is not. Examples follow.</source>
          <target state="translated">这是因为相关联的一些类型的性状（例如，之间的类型不匹配的 &lt;code&gt;T::Bar&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 器具 &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt; ）和另一种类型的 &lt;code&gt;U&lt;/code&gt; 所需等于 &lt;code&gt;T::Bar&lt;/code&gt; ，但不是。示例如下。</target>
        </trans-unit>
        <trans-unit id="0e543293d9c4cb900df2afb34a1c801950192149" translate="yes" xml:space="preserve">
          <source>This is because there could exist &lt;code&gt;V&lt;/code&gt; types with multiple &lt;code&gt;Borrow&amp;lt;[_]&amp;gt;&lt;/code&gt; impls, such that multiple &lt;code&gt;T&lt;/code&gt; types would apply:</source>
          <target state="translated">这是因为可能存在具有多个 &lt;code&gt;Borrow&amp;lt;[_]&amp;gt;&lt;/code&gt; impls的 &lt;code&gt;V&lt;/code&gt; 类型，因此将应用多个 &lt;code&gt;T&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="a641717e833808f9f0bc4f5f362a54b6a1faff5b" translate="yes" xml:space="preserve">
          <source>This is borrow-generalized version of &lt;code&gt;Clone::clone_from&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;Clone::clone_from&lt;/code&gt; 借用概括版本。</target>
        </trans-unit>
        <trans-unit id="834216017331c86ca1e125eb990783c9079a99f6" translate="yes" xml:space="preserve">
          <source>This is called the &amp;ldquo;train model&amp;rdquo; because every six weeks, a release &amp;ldquo;leaves the station&amp;rdquo;, but still has to take a journey through the beta channel before it arrives as a stable release.</source>
          <target state="translated">之所以称其为&amp;ldquo;培训模型&amp;rdquo;，是因为每六周，一个发行版会&amp;ldquo;离开站点&amp;rdquo;，但是在它作为稳定发行版发布之前，仍然必须经过Beta通道。</target>
        </trans-unit>
        <trans-unit id="d83e7e82097d376958eb95d5e51d98e6719f2542" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">这是灾难性的，这意味着我们可以先固定&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;的内容（使用 &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ），然后使用稍后获得的可变引用移动该内容。</target>
        </trans-unit>
        <trans-unit id="a9e339d64ba30c9973394f6282049233c7be4f71" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">这是灾难性的，这意味着我们可以先固定 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 的内容（使用 &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ），然后使用稍后获得的可变引用移动该内容。</target>
        </trans-unit>
        <trans-unit id="9ed19556018375489742916bfb6ea73b08918fbf" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">这通常用于使单个值生成器适应其他类型的迭代的&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain()&lt;/code&gt; &lt;/a&gt;。也许您有一个涵盖几乎所有内容的迭代器，但是您需要一个额外的特殊情况。也许您有一个适用于迭代器的函数，但只需要处理一个值即可。</target>
        </trans-unit>
        <trans-unit id="67913f9219472099fcca84773f5f227006ffbcce" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">这通常用于使单个值生成器适应其他类型的迭代&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt;。也许您有一个涵盖几乎所有内容的迭代器，但是您需要一个额外的特殊情况。也许您有一个适用于迭代器的函数，但只需要处理一个值即可。</target>
        </trans-unit>
        <trans-unit id="507d399d0caa748ec0f687d63827f62d38ea93b1" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">这通常用于将单个值适配到其他类型的迭代的&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain()&lt;/code&gt; &lt;/a&gt;中。也许您有一个涵盖几乎所有内容的迭代器，但是您需要一个额外的特殊情况。也许您有一个适用于迭代器的函数，但只需要处理一个值即可。</target>
        </trans-unit>
        <trans-unit id="764e0240ad7ec9a9585ed8305ceb8e8099f2723d" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">这通常用于使单个值适应其他类型的迭代&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt;。也许您有一个涵盖几乎所有内容的迭代器，但是您需要一个额外的特殊情况。也许您有一个适用于迭代器的函数，但只需要处理一个值即可。</target>
        </trans-unit>
        <trans-unit id="f239b530d28c30ec1070f1658b16620a287e3251" translate="yes" xml:space="preserve">
          <source>This is correct (explicit):</source>
          <target state="translated">这是正确的(明确)。</target>
        </trans-unit>
        <trans-unit id="7d6342cfa6f9200a801992dcf925b5cee5be4a5b" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">当前，这在所有平台上都与 &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a48f92d085d1c5423be432a065e6504acd5a4a36" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">当前 &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; 在所有平台上都与transmute :: &amp;lt;f64，u64&amp;gt;（self）相同。</target>
        </trans-unit>
        <trans-unit id="918c5990ef12f35794f26c0b83e42a5d2ef0c694" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">当前，这在所有平台上均与 &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; 。事实证明，它具有极好的可移植性，原因有两个：</target>
        </trans-unit>
        <trans-unit id="00309d71e504692e129d008c7a1eff96961c44fc" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">当前 &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; 在所有平台上都与transmute :: &amp;lt;u64，f64&amp;gt;（v）相同。事实证明，它具有极好的可移植性，原因有两个：</target>
        </trans-unit>
        <trans-unit id="de7179edea4813efbd79fdfefd23f0fcc07d0700" translate="yes" xml:space="preserve">
          <source>This is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt;:</source>
          <target state="translated">这在&lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737中&lt;/a&gt;定义：</target>
        </trans-unit>
        <trans-unit id="59a6ad6e6ae513088e0c1bb8ed9888b474a9dbba" translate="yes" xml:space="preserve">
          <source>This is designed to be used in conjunction with &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; to, for example, carry a panic across a layer of C code.</source>
          <target state="translated">它被设计为与&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt;结合使用，例如，在C代码层上引起恐慌。</target>
        </trans-unit>
        <trans-unit id="5fdeff8202418046160b5ede029f4ae17e4cb706" translate="yes" xml:space="preserve">
          <source>This is different than the &lt;code&gt;C&lt;/code&gt; representation because a struct with the &lt;code&gt;C&lt;/code&gt; representation will always have the ABI of a &lt;code&gt;C&lt;/code&gt;&lt;code&gt;struct&lt;/code&gt; while, for example, a struct with the &lt;code&gt;transparent&lt;/code&gt; representation with a primitive field will have the ABI of the primitive field.</source>
          <target state="translated">这比不同 &lt;code&gt;C&lt;/code&gt; 表示，因为与一个结构 &lt;code&gt;C&lt;/code&gt; 表示将始终具有一个的ABI &lt;code&gt;C&lt;/code&gt; &lt;code&gt;struct&lt;/code&gt; 而，例如，与一个结构 &lt;code&gt;transparent&lt;/code&gt; 与原始场表示将具有原始字段的ABI。</target>
        </trans-unit>
        <trans-unit id="f40a48629593c80076df828df6524a31bbb5832c" translate="yes" xml:space="preserve">
          <source>This is done as if by the Euclidean division algorithm -- given &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt;, &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt;.</source>
          <target state="translated">就像通过欧几里德除法算法一样-给定 &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt; ， &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt; ，并且 &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="261341fb7dbde0853cc1e229f30dada63a712ac0" translate="yes" xml:space="preserve">
          <source>This is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.</source>
          <target state="translated">这是由Rust编译器执行的。但是,在有些情况下,这个规则不够灵活。有时需要对一个对象有多个引用,但又要对它进行突变。</target>
        </trans-unit>
        <trans-unit id="1a48a3285621637ef35ee331d4de4979ad866379" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea3c08c47d3f2c239e1b0612d35fd093489ce76f" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a97a7d1bcb8cd7cc77582edff43cedf5b5f9e7ec" translate="yes" xml:space="preserve">
          <source>This is equivalent to adding the result of &lt;code&gt;padding_needed_for&lt;/code&gt; to the layout's current size.</source>
          <target state="translated">这等效于将 &lt;code&gt;padding_needed_for&lt;/code&gt; 的结果添加到布局的当前大小。</target>
        </trans-unit>
        <trans-unit id="cd40c4706f12ddab3deeab19ddffb1056c56c24a" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*const T&lt;/code&gt;, but more type-safe.</source>
          <target state="translated">这等效于将 &lt;code&gt;self&lt;/code&gt; 强制转换为 &lt;code&gt;*const T&lt;/code&gt; ，但是类型安全性更高。</target>
        </trans-unit>
        <trans-unit id="b1cc6c65ebdd0a382483c4dc8c7f13d29cc10dc3" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*mut T&lt;/code&gt;, but more type-safe.</source>
          <target state="translated">这等效于将 &lt;code&gt;self&lt;/code&gt; 强制转换为 &lt;code&gt;*mut T&lt;/code&gt; ，但是类型安全性更高。</target>
        </trans-unit>
        <trans-unit id="f6cc1d085b275d07a515f10b6c1293ccce68e246" translate="yes" xml:space="preserve">
          <source>This is equivalent to sending a SIGKILL on Unix platforms.</source>
          <target state="translated">这相当于在Unix平台上发送一个SIGKILL。</target>
        </trans-unit>
        <trans-unit id="f985a290d8b35439e1509532b1f307ab14186afb" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;Deref&lt;/code&gt; impl, but is explicit.</source>
          <target state="translated">这等效于 &lt;code&gt;Deref&lt;/code&gt; impl，但是显式的。</target>
        </trans-unit>
        <trans-unit id="dbb80b753a6a285f62ca3be46d0ca7ebb71f7211" translate="yes" xml:space="preserve">
          <source>This is equivalent to using a &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop on the iterator, although &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are not possible from a closure. It's generally more idiomatic to use a &lt;code&gt;for&lt;/code&gt; loop, but &lt;code&gt;for_each&lt;/code&gt; may be more legible when processing items at the end of longer iterator chains. In some cases &lt;code&gt;for_each&lt;/code&gt; may also be faster than a loop, because it will use internal iteration on adaptors like &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">这等效于在迭代器上使用&lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;循环，尽管无法通过闭包进行 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 。通常，使用 &lt;code&gt;for&lt;/code&gt; 循环更为习惯，但是在较长的迭代器链的末尾处理项目时， &lt;code&gt;for_each&lt;/code&gt; 可能更容易理解。在某些情况下， &lt;code&gt;for_each&lt;/code&gt; 也可能比循环快，因为它会在 &lt;code&gt;Chain&lt;/code&gt; 之类的适配器上使用内部迭代。</target>
        </trans-unit>
        <trans-unit id="85aa708c3c4c286a53847d7118e6789eccd018b1" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;Iterator::nth()&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value from the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">这本质上是&lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;Iterator::nth()&lt;/code&gt; &lt;/a&gt;的反向版​​本。尽管像大多数索引操作一样，计数从零开始，所以 &lt;code&gt;nth_back(0)&lt;/code&gt; 从末尾返回第一个值， &lt;code&gt;nth_back(1)&lt;/code&gt; 从第二个返回，依此类推。</target>
        </trans-unit>
        <trans-unit id="0d5fc7a87669eb5a575d2a14569feb14339d998c" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;nth&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value fro the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">这本质上是&lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;nth&lt;/code&gt; &lt;/a&gt;的反向版​​本。尽管像大多数索引操作一样，计数从零开始，所以 &lt;code&gt;nth_back(0)&lt;/code&gt; 返回最后一个值， &lt;code&gt;nth_back(1)&lt;/code&gt; 返回第二个值，依此类推。</target>
        </trans-unit>
        <trans-unit id="da357ed847b3be924604524d54de90650dc840c5" translate="yes" xml:space="preserve">
          <source>This is exactly the kind of guarantee that the intrusive linked list from the previous section needs to function correctly.</source>
          <target state="translated">这正是上一节的侵入式链接列表正常运行所需要的保证。</target>
        </trans-unit>
        <trans-unit id="bb45c58beba541079b29f983c2bd8c56db26b71e" translate="yes" xml:space="preserve">
          <source>This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing &lt;code&gt;enum&lt;/code&gt; layout.</source>
          <target state="translated">编译器将其用于各种优化，例如取消运行时检查和优化 &lt;code&gt;enum&lt;/code&gt; 布局。</target>
        </trans-unit>
        <trans-unit id="2800cba431c3f0317ff7290328c22feda7e8a245" translate="yes" xml:space="preserve">
          <source>This is fixed by declaring the impl block like this:</source>
          <target state="translated">通过像这样声明 impl 块来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="7800b5b60ece10a2bb3977b34790a457f9ba1d9b" translate="yes" xml:space="preserve">
          <source>This is generally created by methods like &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;RwLock::read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常由&lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;Mutex::lock&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;RwLock::read&lt;/code&gt; &lt;/a&gt;类的方法创建。</target>
        </trans-unit>
        <trans-unit id="d04e3acde7f8ef92dfb6b7b52b3e3c3811cad1e0" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常不建议这样做，请谨慎使用！有关安全的替代方法，请参阅&lt;a href=&quot;#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bd5c92d6bc3bc69b3d544b464184377050cce05" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常不建议这样做，请谨慎使用！有关安全的选择，请参见&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1be3a48c43f2cbe9f66bb8b317aa83c1345f1b36" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常不建议这样做，请谨慎使用！有关安全的选择，请参见&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60f2e569769a80d9853e1327c13dd3289346f0be" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常不建议这样做，请谨慎使用！有关安全的选择，请参见&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5835397a3648f1790072b1697b1686de073dd8a5" translate="yes" xml:space="preserve">
          <source>This is highly unsafe, due to the number of invariants that aren't checked:</source>
          <target state="translated">这是很不安全的,由于没有检查的不变量太多。</target>
        </trans-unit>
        <trans-unit id="75907ab0f8297b43f4704528d57293015e32b770" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.</source>
          <target state="translated">这是作为一个固有的功能来实现的,以避免向整数转换和从整数转换,因为转换会抑制某些优化。</target>
        </trans-unit>
        <trans-unit id="11f5a22e0c8092b2e830a298d3f000dd528e1ac9" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.</source>
          <target state="translated">这是作为一个固有的功能来实现的,以避免向整数转换和从整数转换,因为转换会丢掉别名信息。</target>
        </trans-unit>
        <trans-unit id="0d148f9608c961194f7d8d82b9462e528bb48245" translate="yes" xml:space="preserve">
          <source>This is in contrast to the default behaviour of &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; which unwinds the current thread's stack and calls all destructors. When &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; is set, either as an argument to &lt;code&gt;rustc&lt;/code&gt; or in a crate's Cargo.toml, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;abort&lt;/code&gt; are similar. However, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will still call the &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;panic hook&lt;/a&gt; while &lt;code&gt;abort&lt;/code&gt; will not.</source>
          <target state="translated">这与&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;的默认行为相反！它展开当前线程的堆栈并调用所有析构函数。当 &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; 设置，无论是作为参数传递给 &lt;code&gt;rustc&lt;/code&gt; 或一箱的Cargo.toml，&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;abort&lt;/code&gt; 相似。但是，&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;仍然会调用&lt;a href=&quot;../panic/fn.set_hook&quot;&gt;紧急钩子，&lt;/a&gt;而 &lt;code&gt;abort&lt;/code&gt; 则不会。</target>
        </trans-unit>
        <trans-unit id="4ae8371c0715e2fc1f945296e51fa6a1f4eac55c" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string are not specified, other than being a best-effort description of the type. For example, &lt;code&gt;type_name_of_val::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;(None)&lt;/code&gt; could return &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. In addition, the output may change between versions of the compiler.</source>
          <target state="translated">这旨在用于诊断。除了作为该类型的尽力描述之外，未指定字符串的确切内容和格式。例如， &lt;code&gt;type_name_of_val::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;(None)&lt;/code&gt; 可能返回 &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt; ，但不会返回 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 。此外，输出可能会在编译器的版本之间改变。</target>
        </trans-unit>
        <trans-unit id="f8ec787ed30362b911645f3b84c9e12d95cf9472" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string returned are not specified, other than being a best-effort description of the type. For example, amongst the strings that &lt;code&gt;type_name::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;()&lt;/code&gt; might return are &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">这旨在用于诊断。除了作为尽力而为的类型描述之外，未指定返回的字符串的确切内容和格式。例如，在 &lt;code&gt;type_name::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;()&lt;/code&gt; 可能返回的字符串中，有 &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abc319fa8d54bb7f30ec3fbd3c75a33f269dda0d" translate="yes" xml:space="preserve">
          <source>This is intended for use cases that must synchronize content, but don't need the metadata on disk. The goal of this method is to reduce disk operations.</source>
          <target state="translated">这是为必须同步内容,但不需要磁盘上的元数据的用例准备的。这种方法的目标是减少磁盘操作。</target>
        </trans-unit>
        <trans-unit id="b4baa659f5df3a480bf1bbe9b4f50e4e5030b61c" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;OsStrExt::encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">这是无损的：在结果字符串上调用&lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;OsStrExt::encode_wide&lt;/code&gt; &lt;/a&gt;将始终返回原始代码单元。</target>
        </trans-unit>
        <trans-unit id="8a817bf3dc422e9202ff238105af54d744a0e12d" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">这是无损的：在结果字符串上调用&lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt;将始终返回原始代码单元。</target>
        </trans-unit>
        <trans-unit id="628dc171fde34c2da2657493d9e0d1f50a03e413" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsString::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">这是无损：调用&lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsString::from_wide&lt;/code&gt; &lt;/a&gt;然后 &lt;code&gt;encode_wide&lt;/code&gt; 的结果将产生原始代码单元。请注意，编码不会添加最终的空终止符。</target>
        </trans-unit>
        <trans-unit id="77e982184c9ea4360d1954dd63bc884090bdd324" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsStringExt::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">这是无损的：调用&lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsStringExt::from_wide&lt;/code&gt; &lt;/a&gt;然后对结果进行 &lt;code&gt;encode_wide&lt;/code&gt; 将产生原始代码单元。请注意，编码不会添加最终的空终止符。</target>
        </trans-unit>
        <trans-unit id="0151e5762979bf36757d9fa68f187e7676c048da" translate="yes" xml:space="preserve">
          <source>This is more useful when combined with higher-level abstractions, like collecting to a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; where you only care about errors:</source>
          <target state="translated">与更高级别的抽象结合使用时，此功能尤其有用，例如收集到只关心错误的 &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="10329d9d786a635bdda96b8986fb374a569f8990" translate="yes" xml:space="preserve">
          <source>This is normally only useful in macro generated code.</source>
          <target state="translated">这通常只在宏生成的代码中有用。</target>
        </trans-unit>
        <trans-unit id="e2fe1510c25bad6c81eb0b6402e2bd1a4066b7f9" translate="yes" xml:space="preserve">
          <source>This is not currently supported: &lt;code&gt;v&lt;/code&gt; should be defined as &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt;. Parentheses are currently only used with generic types when defining parameters for &lt;code&gt;Fn&lt;/code&gt;-family traits.</source>
          <target state="translated">当前不支持此功能： &lt;code&gt;v&lt;/code&gt; 应该定义为 &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt; 。当前，在定义 &lt;code&gt;Fn&lt;/code&gt; 系列特征的参数时，括号仅与泛型类型一起使用。</target>
        </trans-unit>
        <trans-unit id="711ce4ce5401a3c09d45281217695490f1c55a87" translate="yes" xml:space="preserve">
          <source>This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties. If you're not sure if you should use &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;, just use &lt;code&gt;*mut T&lt;/code&gt;!</source>
          <target state="translated">在使用原始指针构建数据结构时，这通常是正确的选择，但由于其附加属性，最终使用起来更加危险。如果不确定是否应使用 &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; ，请使用 &lt;code&gt;*mut T&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="fa820eea81b725c2fa4febe2a3901035a1fc9e49" translate="yes" xml:space="preserve">
          <source>This is one of the reasons Rust projects that provide a binary have a straightforward &lt;em&gt;src/main.rs&lt;/em&gt; file that calls logic that lives in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. Using that structure, integration tests &lt;em&gt;can&lt;/em&gt; test the library crate with &lt;code&gt;use&lt;/code&gt; to make the important functionality available. If the important functionality works, the small amount of code in the &lt;em&gt;src/main.rs&lt;/em&gt; file will work as well, and that small amount of code doesn&amp;rsquo;t need to be tested.</source>
          <target state="translated">这其中的原因锈提供二进制有一个简单的项目之一&lt;em&gt;的src / main.rs&lt;/em&gt;文件调用逻辑生活在&lt;em&gt;SRC / lib.rs&lt;/em&gt;文件。使用该结构，集成测试&lt;em&gt;可以&lt;/em&gt;测试库箱的 &lt;code&gt;use&lt;/code&gt; 以使重要功能可用。如果重要的功能起作用，那么&lt;em&gt;src / main.rs&lt;/em&gt;文件中的少量代码也将起作用，并且不需要测试少量的代码。</target>
        </trans-unit>
        <trans-unit id="73e2aa9ae5cc887b643d8522a473733b99e09722" translate="yes" xml:space="preserve">
          <source>This is only available on unix platforms and must be imported in order to call the method. Windows platforms have a corresponding &lt;code&gt;AsRawHandle&lt;/code&gt; and &lt;code&gt;AsRawSocket&lt;/code&gt; set of traits.</source>
          <target state="translated">仅在unix平台上可用，并且必须将其导入才能调用该方法。Windows平台具有一组相应的 &lt;code&gt;AsRawHandle&lt;/code&gt; 和 &lt;code&gt;AsRawSocket&lt;/code&gt; 特征集。</target>
        </trans-unit>
        <trans-unit id="b95758d57810f70a3e0dda910c113e0c41898398" translate="yes" xml:space="preserve">
          <source>This is only possible if the iterator has an end, so &lt;code&gt;rev()&lt;/code&gt; only works on &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">仅当迭代器具有结束&lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;才有可能，因此 &lt;code&gt;rev()&lt;/code&gt; 仅适用于DoubleEndedIterator。</target>
        </trans-unit>
        <trans-unit id="3a074412ade07f77d614925409e4080a4208783e" translate="yes" xml:space="preserve">
          <source>This is optimal if:</source>
          <target state="translated">这是最理想的,如果:</target>
        </trans-unit>
        <trans-unit id="37e51cab1c9ec8f6780dbae6b990b1f230875324" translate="yes" xml:space="preserve">
          <source>This is primarily due to ABI incompatibilities between the two attributes. See &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt; for details on this and other limitations.</source>
          <target state="translated">这主要是由于两个属性之间的ABI不兼容。有关此限制和其他限制的详细信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d34b82a0a85b619783fe065420d506ce185b6196" translate="yes" xml:space="preserve">
          <source>This is purely an optimization hint, and may be implemented conservatively: it may return &lt;code&gt;true&lt;/code&gt; for types that don't actually need to be dropped. As such always returning &lt;code&gt;true&lt;/code&gt; would be a valid implementation of this function. However if this function actually returns &lt;code&gt;false&lt;/code&gt;, then you can be certain dropping &lt;code&gt;T&lt;/code&gt; has no side effect.</source>
          <target state="translated">这纯粹是一个优化提示，可以保守地实现：对于实际上不需要删除的类型，它可能返回 &lt;code&gt;true&lt;/code&gt; 。因此，始终返回 &lt;code&gt;true&lt;/code&gt; 将是此函数的有效实现。但是，如果此函数实际上返回 &lt;code&gt;false&lt;/code&gt; ，则可以确定删除 &lt;code&gt;T&lt;/code&gt; 没有副作用。</target>
        </trans-unit>
        <trans-unit id="5e7810a8956ac37cd206f449b307f75cea11f52b" translate="yes" xml:space="preserve">
          <source>This is returned in a Result by either the &lt;a href=&quot;struct.command#method.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt;&lt;code&gt;wait_with_output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">这是通过&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.command#method.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt;方法或&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt;进程的&lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt; &lt;code&gt;wait_with_output&lt;/code&gt; &lt;/a&gt;方法在Result中返回的。</target>
        </trans-unit>
        <trans-unit id="b6ad57d3243660eeae5c83dc6d6e37580997866e" translate="yes" xml:space="preserve">
          <source>This is safe because it is not possible to move out of a shared reference. It may seem like there is an issue here with interior mutability: in fact, it &lt;em&gt;is&lt;/em&gt; possible to move a &lt;code&gt;T&lt;/code&gt; out of a &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. However, this is not a problem as long as there does not also exist a &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; pointing to the same data, and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does not let you create a pinned reference to its contents. See the discussion on &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;pinning projections&quot;&lt;/a&gt; for further details.</source>
          <target state="translated">这是安全的，因为不可能移出共享参考。它可能看起来像有一个问题在这里与室内的可变性：实际上，它&lt;em&gt;是&lt;/em&gt;可以移动一个 &lt;code&gt;T&lt;/code&gt; 出的 &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 。但是，只要不存在指向相同数据的 &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 不允许您创建对其内容的固定引用，这就不成问题。有关更多详细信息，请参见有关&lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&amp;ldquo;固定预测&amp;rdquo;&lt;/a&gt;的讨论。</target>
        </trans-unit>
        <trans-unit id="559d85299736482aa3edc92867921c11931dac34" translate="yes" xml:space="preserve">
          <source>This is safe because passing &lt;code&gt;self&lt;/code&gt; by value guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">这是安全的，因为按值传递 &lt;code&gt;self&lt;/code&gt; 可以确保没有其他线程同时访问原子数据。</target>
        </trans-unit>
        <trans-unit id="fdcd86e75de03ac238cab2145da08762d1c1fa0e" translate="yes" xml:space="preserve">
          <source>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">这样做是安全的,因为可变引用保证没有其他线程并发访问原子数据。</target>
        </trans-unit>
        <trans-unit id="a603b8208d8f49fcc985893385a8e118d832cdea" translate="yes" xml:space="preserve">
          <source>This is safe, because &lt;code&gt;T&lt;/code&gt; is borrowed for the &lt;code&gt;'static&lt;/code&gt; lifetime, which never ends.</source>
          <target state="translated">这是安全的，因为 &lt;code&gt;T&lt;/code&gt; 借用了 &lt;code&gt;'static&lt;/code&gt; 永无止境的静态寿命&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="62f1c9ceb59d3f4f94d3d3fedf2ebcb7110ae8d6" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">从语义上讲，这等效于调用&lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt;并丢弃结果，但具有以下优点：</target>
        </trans-unit>
        <trans-unit id="f8249e0d4f2746bf5b8aa8a678e0e1e5a321179d" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">从语义上讲，这等效于调用&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt;并丢弃结果，但具有以下优点：</target>
        </trans-unit>
        <trans-unit id="3f02e339323ce653dbff1ca427dde093c5fbdbad" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;../primitive.slice#method.clone_from_slice&quot;&gt;&lt;code&gt;slice::clone_from_slice&lt;/code&gt;&lt;/a&gt; but does not drop existing elements.</source>
          <target state="translated">这类似于&lt;a href=&quot;../primitive.slice#method.clone_from_slice&quot;&gt; &lt;code&gt;slice::clone_from_slice&lt;/code&gt; &lt;/a&gt;但不会删除现有元素。</target>
        </trans-unit>
        <trans-unit id="358e0f225467b03900d6e8992dde5d0b7bc40738" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt;&lt;code&gt;slice::copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这类似于&lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt; &lt;code&gt;slice::copy_from_slice&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb69e9b77c8f67d2dd23964f55732bc6174eb1f3" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning with mutexes&lt;/a&gt;.</source>
          <target state="translated">这类似于&lt;a href=&quot;struct.mutex#poisoning&quot;&gt;使用互斥锁中毒&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="323433898b799fb03eed09fdd2d727e9828c9a3d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;wake&lt;/code&gt;, but may be slightly less efficient in the case where an owned &lt;code&gt;Waker&lt;/code&gt; is available. This method should be preferred to calling &lt;code&gt;waker.clone().wake()&lt;/code&gt;.</source>
          <target state="translated">这类似于 &lt;code&gt;wake&lt;/code&gt; ，但是在拥有自己的 &lt;code&gt;Waker&lt;/code&gt; 的情况下，效率可能稍低。此方法应该比调用 &lt;code&gt;waker.clone().wake()&lt;/code&gt; 更可取。</target>
        </trans-unit>
        <trans-unit id="67ff9ed313be1a208e09d5213c1e87906d1b8ae8" translate="yes" xml:space="preserve">
          <source>This is similar to taking a reference to the whole &lt;code&gt;String&lt;/code&gt; but with the extra &lt;code&gt;[0..5]&lt;/code&gt; bit. Rather than a reference to the entire &lt;code&gt;String&lt;/code&gt;, it&amp;rsquo;s a reference to a portion of the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">这类似于引用整个 &lt;code&gt;String&lt;/code&gt; ,但带有额外的 &lt;code&gt;[0..5]&lt;/code&gt; 位。而不是对整个参考 &lt;code&gt;String&lt;/code&gt; ，它是向的一部分的参考 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e7a7ddaef0be30145306f6816d2b3ff35a14d32" translate="yes" xml:space="preserve">
          <source>This is similar to the second sub-error, but subtler. It happens in situations like the following:</source>
          <target state="translated">这与第二个子错误类似,但更小。它发生在以下情况。</target>
        </trans-unit>
        <trans-unit id="7512abd4f4f8baf21d2fa3f6cea905e84ac77b34" translate="yes" xml:space="preserve">
          <source>This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The &lt;code&gt;clone&lt;/code&gt; method is expected to not change the source value, and is declared to take &lt;code&gt;&amp;amp;self&lt;/code&gt;, not &lt;code&gt;&amp;amp;mut self&lt;/code&gt;. Therefore, any mutation that happens in the &lt;code&gt;clone&lt;/code&gt; method must use cell types. For example, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; maintains its reference counts within a &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这只是前一种情况的一种特殊情况-但很常见-这种情况：对于看起来是不可变的操作隐藏了可变性。该 &lt;code&gt;clone&lt;/code&gt; 方法，预计不会改变源值，并宣布采取 &lt;code&gt;&amp;amp;self&lt;/code&gt; ，不 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 。因此， &lt;code&gt;clone&lt;/code&gt; 方法中发生的任何突变都必须使用细胞类型。例如， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 维护其参考计数。</target>
        </trans-unit>
        <trans-unit id="022f67943cd560f4bdb5afc8c97b7f6c6d3167eb" translate="yes" xml:space="preserve">
          <source>This is sometimes done as part of an FFI:</source>
          <target state="translated">这有时是作为FFI的一部分进行的。</target>
        </trans-unit>
        <trans-unit id="29a8f7be9a323b371a4c7f94c367da9cdcb60e7e" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;(Android or DragonFly BSD or Emscripten or FreeBSD or Linux or NetBSD or OpenBSD) and Unix&lt;/strong&gt; only.</source>
          <target state="translated">仅在&lt;strong&gt;Unix（Android或DragonFly BSD或Emscripten或FreeBSD或Linux或NetBSD或OpenBSD）&lt;/strong&gt;上支持此功能。</target>
        </trans-unit>
        <trans-unit id="1cd9f4e2b3a9d48a4944f59c96788167ca07951a" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;Android or DragonFly BSD or Emscripten or FreeBSD or Linux or NetBSD or OpenBSD&lt;/strong&gt; only.</source>
          <target state="translated">仅在&lt;strong&gt;Android或DragonFly BSD或Emscripten或FreeBSD或Linux或NetBSD或OpenBSD&lt;/strong&gt;上支持此功能。</target>
        </trans-unit>
        <trans-unit id="c76ae31cc8e606b25f4d72f00019a489e501ce07" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;Linux&lt;/strong&gt; only.</source>
          <target state="translated">仅在&lt;strong&gt;Linux&lt;/strong&gt;上支持。</target>
        </trans-unit>
        <trans-unit id="100ddfe0611f62c2fe34cd0d08120e1dfeacd050" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;Unix&lt;/strong&gt; only.</source>
          <target state="translated">仅在&lt;strong&gt;Unix&lt;/strong&gt;上支持。</target>
        </trans-unit>
        <trans-unit id="820275ba907af27ec04ee3e4464292d92354d5b6" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;Windows&lt;/strong&gt; only.</source>
          <target state="translated">仅&lt;strong&gt;Windows&lt;/strong&gt;支持此功能。</target>
        </trans-unit>
        <trans-unit id="ce79f7fec51f65c567a6d4b960b891ab223ea0af" translate="yes" xml:space="preserve">
          <source>This is supported on Linux only.</source>
          <target state="translated">这只在Linux上支持。</target>
        </trans-unit>
        <trans-unit id="5d02662201a60807bdb13970d8ae5dbd58d92a03" translate="yes" xml:space="preserve">
          <source>This is supported on Unix only.</source>
          <target state="translated">这只在Unix上支持。</target>
        </trans-unit>
        <trans-unit id="fe81960399abac0748704c3a05349d9cd7f1ac2c" translate="yes" xml:space="preserve">
          <source>This is supported on Windows only.</source>
          <target state="translated">这只在Windows上支持。</target>
        </trans-unit>
        <trans-unit id="7dbd409e3c209511b0279195cd6826fb5e1a2b3b" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;longest&lt;/code&gt; function from Listing 10-22 that returns the longer of two string slices. But now it has an extra parameter named &lt;code&gt;ann&lt;/code&gt; of the generic type &lt;code&gt;T&lt;/code&gt;, which can be filled in by any type that implements the &lt;code&gt;Display&lt;/code&gt; trait as specified by the &lt;code&gt;where&lt;/code&gt; clause. This extra parameter will be printed before the function compares the lengths of the string slices, which is why the &lt;code&gt;Display&lt;/code&gt; trait bound is necessary. Because lifetimes are a type of generic, the declarations of the lifetime parameter &lt;code&gt;'a&lt;/code&gt; and the generic type parameter &lt;code&gt;T&lt;/code&gt; go in the same list inside the angle brackets after the function name.</source>
          <target state="translated">这是清单10-22中 &lt;code&gt;longest&lt;/code&gt; 函数，该函数返回两个字符串切片中的较长者。但是，现在它有了一个名为 &lt;code&gt;ann&lt;/code&gt; 的通用类型 &lt;code&gt;T&lt;/code&gt; 的额外参数，该参数可以由实现 &lt;code&gt;where&lt;/code&gt; 子句指定的 &lt;code&gt;Display&lt;/code&gt; trait 的任何类型填充。在函数比较字符串片段的长度之前，将打印此额外的参数，这就是为什么必须使用 &lt;code&gt;Display&lt;/code&gt; trait绑定的原因。由于生命周期是一种通用类型，因此生命周期参数 &lt;code&gt;'a&lt;/code&gt; 和通用类型参数 &lt;code&gt;T&lt;/code&gt; 的声明位于函数名称后尖括号内的同一列表中。</target>
        </trans-unit>
        <trans-unit id="771b5400b1697f2e03b3ff52d8994e98c72fb56e" translate="yes" xml:space="preserve">
          <source>This is the alignment used for struct fields. It may be smaller than the preferred alignment.</source>
          <target state="translated">这是用于结构字段的对齐方式。它可能小于首选的对齐方式。</target>
        </trans-unit>
        <trans-unit id="d7e12ec340db516b6de450f2a63092abb536959d" translate="yes" xml:space="preserve">
          <source>This is the const generic equivalent of &lt;a href=&quot;#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt;的const泛型等效项。</target>
        </trans-unit>
        <trans-unit id="9ea5fa4cdf245151000dcd8208cd57fa7396ef40" translate="yes" xml:space="preserve">
          <source>This is the correct syntax:</source>
          <target state="translated">这是正确的语法。</target>
        </trans-unit>
        <trans-unit id="8a3edb9de97e0819d33135bbb50051a98c123c3a" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable number.</source>
          <target state="translated">这是 &lt;code&gt;1.0&lt;/code&gt; 与下一个较大的可表示数字之间的差。</target>
        </trans-unit>
        <trans-unit id="540ad0b8406b1727e0f455b9b013663295117df7" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next largest representable number.</source>
          <target state="translated">这是 &lt;code&gt;1.0&lt;/code&gt; 与下一个最大可表示数字之间的差。</target>
        </trans-unit>
        <trans-unit id="c620ac5f199d804600d9e6fa867d20d7e4f16f11" translate="yes" xml:space="preserve">
          <source>This is the first example of Rust&amp;rsquo;s safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing. Chapter 9 discusses more of Rust&amp;rsquo;s error handling.</source>
          <target state="translated">这是Rust实施安全原则的第一个示例。在许多低级语言中，不会执行这种检查，并且当您提供错误的索引时，可以访问无效的内存。Rust通过立即退出而不是允许内存访问并继续操作来保护您免受此类错误的侵害。第9章讨论了Rust的更多错误处理。</target>
        </trans-unit>
        <trans-unit id="96d082bf8459464d47b35442a1fa45813a325a53" translate="yes" xml:space="preserve">
          <source>This is the main iterator trait. For more about the concept of iterators generally, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;. In particular, you may want to know how to &lt;a href=&quot;index#implementing-iterator&quot;&gt;implement &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是主要的迭代器特征。有关一般迭代器概念的更多信息，请参阅&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。特别是，您可能想知道如何&lt;a href=&quot;index#implementing-iterator&quot;&gt;实现 &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b386764c4159d37f683e85f4c4afa8c88d4fe909" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">这是索引 &lt;code&gt;str&lt;/code&gt; 的非紧急选择。每当等效的索引操作将崩溃时，将返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="289f1434eafb60316aca77ad31a00e3c0eb9323a" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">这是索引 &lt;code&gt;str&lt;/code&gt; 的非紧急选择。每当等效的索引操作将崩溃时，将返回&lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="759018d521d201d38bc076c0727a5d9a6e429fac" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#method.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt;的非恐慌形式。</target>
        </trans-unit>
        <trans-unit id="70fed40b0a485aa104ed49c92498ff0b436cf03b" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;的非惊慌变体。</target>
        </trans-unit>
        <trans-unit id="ccd5e95eaa2f4ad9676aca34c8e9ba1ff21b3015" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是&lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的背面开始接收元素。&lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd0528fc88151b305168bd5debfa38b6c659b612" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是&lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的背面开始接收元素。&lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0fe748271e612bae240bf98e735a830b559c459" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是&lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的背面开始接收元素。&lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d3a0dba802b6e4f6285d94d4683f5056846f9fd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;Iterator::fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">这是&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;Iterator::fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的后面开始接收元素。</target>
        </trans-unit>
        <trans-unit id="cce445e189c1252f0055062d54b89751ff0fb729" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">这是&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的后面开始接收元素。</target>
        </trans-unit>
        <trans-unit id="bc1780a770503660513f01fa15c1efc71fef0175" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">这是&lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的背面开始接收元素。</target>
        </trans-unit>
        <trans-unit id="fe6ff5d62e332d4883802b0cf8675d53b663b171" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是&lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的背面开始接收元素。&lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53f33f9266690c3f1f82aab587ca29e140daa7ab" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">这是&lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt;的反向版​​本：它从迭代器的后面开始接收元素。</target>
        </trans-unit>
        <trans-unit id="d46122a89a465fda704ceb8118ba4c1126be2832" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是[ &lt;code&gt;try_fold()&lt;/code&gt; ] 的反向版​​本：它从迭代器的背面开始获取元素。&lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f495531f8eacf0a1680dc0219ed83707197faddd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是[ &lt;code&gt;try_fold()&lt;/code&gt; ] 的反向版​​本：它从迭代器的背面开始获取元素。&lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ec81940d41390cbbcb80997a4e3d957d2b9a317" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是[ &lt;code&gt;try_fold()&lt;/code&gt; ] 的反向版​​本：它从迭代器的背面开始获取元素。&lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ff3fa51ad38f312277040719826a7c977bbcd8a" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">这是[ &lt;code&gt;try_fold()&lt;/code&gt; ] 的反向版​​本：它从迭代器的背面开始获取元素。&lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383e94e01b1343c9d6bcfb23e7f045e384d94336" translate="yes" xml:space="preserve">
          <source>This is the same as using the &lt;code&gt;==&lt;/code&gt; operator, but less generic: the arguments have to be &lt;code&gt;*const T&lt;/code&gt; raw pointers, not anything that implements &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">这与使用 &lt;code&gt;==&lt;/code&gt; 运算符相同，但通用性较低：参数必须是 &lt;code&gt;*const T&lt;/code&gt; 原始指针，而不是任何实现 &lt;code&gt;PartialEq&lt;/code&gt; 的指针。</target>
        </trans-unit>
        <trans-unit id="22b2f39cdef64a09df83167c24366e9e24591fdf" translate="yes" xml:space="preserve">
          <source>This is the unchecked alternative to indexing the &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">这是索引 &lt;code&gt;str&lt;/code&gt; 的未经检查的替代方法。</target>
        </trans-unit>
        <trans-unit id="589a4243aa6d42e7fc5ac36f0baed5a47e1de444" translate="yes" xml:space="preserve">
          <source>This is used for object safety, to check that a method's receiver type can be dispatched on.</source>
          <target state="translated">这用于对象安全,检查一个方法的接收器类型能否被派发上。</target>
        </trans-unit>
        <trans-unit id="9aea807f1415223ad9d946b1ace7fbf6d55fe5aa" translate="yes" xml:space="preserve">
          <source>This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.</source>
          <target state="translated">当程序员知道线程在一段时间内将无所事事,从而避免浪费计算时间时,就会使用这个方法。</target>
        </trans-unit>
        <trans-unit id="5ce1e416198eb464ee0a2977f8013c35c0e89565" translate="yes" xml:space="preserve">
          <source>This is useful any time that the compiler can't determine that some code is unreachable. For example:</source>
          <target state="translated">在编译器无法确定某些代码无法到达的时候,这一点都很有用。例如:</target>
        </trans-unit>
        <trans-unit id="85e4c5ffc08236fd25e25201dcbaaa8757900c78" translate="yes" xml:space="preserve">
          <source>This is useful for</source>
          <target state="translated">这对以下情况很有用</target>
        </trans-unit>
        <trans-unit id="a885d8fe460e46c9230b0d468a457bef6acf54a6" translate="yes" xml:space="preserve">
          <source>This is useful for a flavor of &quot;optimistic check&quot; before deciding to block on a receiver.</source>
          <target state="translated">这对于在决定对接盘侠进行阻击之前,进行一味的 &quot;乐观检查 &quot;是很有用的。</target>
        </trans-unit>
        <trans-unit id="79e1d9086d9f417d98c9a3f1df01e78fe0db96d9" translate="yes" xml:space="preserve">
          <source>This is useful for initializing types which lazily allocate, like &lt;code&gt;Vec::new&lt;/code&gt; does.</source>
          <target state="translated">这对于初始化延迟分配的类型很有用，例如 &lt;code&gt;Vec::new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08ec962229a27774cdabf85bddcaa5d6f625b9ff" translate="yes" xml:space="preserve">
          <source>This is useful to allow applying iterator adaptors while still retaining ownership of the original iterator.</source>
          <target state="translated">这对于允许应用迭代器适配器,同时仍然保留原始迭代器的所有权非常有用。</target>
        </trans-unit>
        <trans-unit id="920763b96fccf7eb85a93a16a5bdd675d6fd634c" translate="yes" xml:space="preserve">
          <source>This is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.</source>
          <target state="translated">当底层资源的所有权之前已经转移到Rust之外的代码时,这很有用,例如通过将原始文件描述符传输到C代码。</target>
        </trans-unit>
        <trans-unit id="c983c1aa2c476c3f346d2a87a469f6be7bac78d1" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; into an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; may contain a value that an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; to an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; (essentially giving the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;'s value modulo &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;) or by simply returning &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;, or by some other method. The &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">当您执行的类型转换可能会成功完成但可能还需要特殊处理时，这很有用。例如，&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;使用&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;特性将&lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;转换为i32，因为&lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;可能包含&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;无法表示的值，因此转换将丢失数据。这可能通过截断处理&lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;到&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;（基本上是给&lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;的价值模&lt;a href=&quot;../i32/constant.max&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt;），或简单地返回&lt;a href=&quot;../i32/constant.max&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt;，或通过其他方法。在&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;特性适用于完美的转换，所以 &lt;code&gt;TryFrom&lt;/code&gt; 特质会通知程序员类型转换何时会变差，并让他们决定如何处理它。</target>
        </trans-unit>
        <trans-unit id="63ccb84e9a4faa353cb290ddc5e855748a76c17b" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;code&gt;i64&lt;/code&gt; into an &lt;code&gt;i32&lt;/code&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;code&gt;i64&lt;/code&gt; may contain a value that an &lt;code&gt;i32&lt;/code&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;code&gt;i64&lt;/code&gt; to an &lt;code&gt;i32&lt;/code&gt; (essentially giving the &lt;code&gt;i64&lt;/code&gt;'s value modulo &lt;code&gt;i32::MAX&lt;/code&gt;) or by simply returning &lt;code&gt;i32::MAX&lt;/code&gt;, or by some other method. The &lt;code&gt;From&lt;/code&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">当您执行的类型转换可能会成功完成但可能还需要特殊处理时，这很有用。例如， &lt;code&gt;i32&lt;/code&gt; 使用&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;特性将 &lt;code&gt;i64&lt;/code&gt; 转换为i32，因为 &lt;code&gt;i64&lt;/code&gt; 可能包含 &lt;code&gt;i32&lt;/code&gt; 无法表示的值，因此转换将丢失数据。这可能通过截断处理 &lt;code&gt;i64&lt;/code&gt; 到 &lt;code&gt;i32&lt;/code&gt; （基本上是给 &lt;code&gt;i64&lt;/code&gt; 的价值模 &lt;code&gt;i32::MAX&lt;/code&gt; ），或简单地返回 &lt;code&gt;i32::MAX&lt;/code&gt; ，或通过其他方法。在 &lt;code&gt;From&lt;/code&gt; 特性适用于完美的转换，所以 &lt;code&gt;TryFrom&lt;/code&gt; 特质会通知程序员类型转换何时会变差，并让他们决定如何处理它。</target>
        </trans-unit>
        <trans-unit id="878335df341d736b2b477f7d269d41d041479a70" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.</source>
          <target state="translated">当你有一个迭代器的迭代器或一个可以变成迭代器的事物的迭代器,而你想去掉一个层次的间接性时,这很有用。</target>
        </trans-unit>
        <trans-unit id="bc06069272831e3fab63600d60da8286a4aa9faf" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator over &lt;code&gt;&amp;amp;T&lt;/code&gt;, but you need an iterator over &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">当在 &lt;code&gt;&amp;amp;T&lt;/code&gt; 上有一个迭代器，但在 &lt;code&gt;T&lt;/code&gt; 上需要一个迭代器时，这很有用。</target>
        </trans-unit>
        <trans-unit id="28c350dd4bfc1f4f50a6db4a558fce8f481fa714" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted list of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望输出格式化的项目列表作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分时，这很有用。</target>
        </trans-unit>
        <trans-unit id="023c37d743c95a28f62cb66dc28c6981840e275e" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted map as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望将格式化的地图作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分输出时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="5a019c845f0ac55c26e73d5fc98b9e29c14a5266" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted set of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望输出格式化的项目集作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分时，这很有用。</target>
        </trans-unit>
        <trans-unit id="742e4efaa0964cab1a9b13d64aa3f1ee505fbe93" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted struct as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望将格式化的结构作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分输出时，这很有用。</target>
        </trans-unit>
        <trans-unit id="7450774ae735743f9affac51ccc2935a02180916" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted tuple as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">当您希望将格式化的元组作为&lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt;实现的一部分输出时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="678189b9778744d56a77a9ddbd180a89dff66dd0" translate="yes" xml:space="preserve">
          <source>This is usually not needed when writing safe code, as &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;es&lt;/a&gt; already poison themselves when a thread panics while holding the lock.</source>
          <target state="translated">这编写安全的代码时，因为通常不需要&lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; ES&lt;/a&gt;已经毒害自己，当持有的锁，而线程恐慌。</target>
        </trans-unit>
        <trans-unit id="73513599023f5ddb254ee6ed0d00bccac264c338" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="translated">通常与 &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 。然而，当 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;有&lt;/em&gt;没有静态已知的尺寸，例如，切片&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;性状对象&lt;/a&gt;，然后 &lt;code&gt;size_of_val&lt;/code&gt; 可用于获得动态已知大小。</target>
        </trans-unit>
        <trans-unit id="8b96a4f28b82d88010bb7132ad9ee35ef317464c" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val_raw&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="translated">这通常与 &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 。然而，当 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;有&lt;/em&gt;没有静态已知的尺寸，例如，切片&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;性状对象&lt;/a&gt;，然后 &lt;code&gt;size_of_val_raw&lt;/code&gt; 可用于获得动态已知大小。</target>
        </trans-unit>
        <trans-unit id="8abe6d863c59136664f0a7528f19c0cd3ff2fed7" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the exact signature that&amp;rsquo;s in the standard library: in the standard library, &lt;code&gt;add&lt;/code&gt; is defined using generics. Here, we&amp;rsquo;re looking at the signature of &lt;code&gt;add&lt;/code&gt; with concrete types substituted for the generic ones, which is what happens when we call this method with &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">这不是标准库中的确切签名：在标准库中， &lt;code&gt;add&lt;/code&gt; 是使用泛型定义的。在这里，我们正在查看用具体类型替换通用类型的 &lt;code&gt;add&lt;/code&gt; 的签名，这是在我们使用 &lt;code&gt;String&lt;/code&gt; 值调用此方法时发生的情况。我们将在第10章中讨论泛型。此签名为我们提供了了解 &lt;code&gt;+&lt;/code&gt; 运算符的棘手位所需的线索。</target>
        </trans-unit>
        <trans-unit id="677e3e0ad58a3857efcf5b71bd28f251f1ad71c2" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the last you&amp;rsquo;ll see of concurrency in this book: the project in Chapter 20 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.</source>
          <target state="translated">这不是本书中您最后看到的并发性：第20章的项目将比本章讨论的较小示例更实际地使用本章中的概念。</target>
        </trans-unit>
        <trans-unit id="c724cabc6d2e28a46495b5e9f7308161c3ff4773" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method is a good solution. Example:</source>
          <target state="translated">这是不允许的,但使用一个特质来实现一个方法是一个很好的解决方案。例子:</target>
        </trans-unit>
        <trans-unit id="89a100ed08885eb96e8a08b563ffa2fce44e1756" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method or constant is a good solution. Example:</source>
          <target state="translated">这是不允许的,但使用一个特质来实现一个方法或常量是一个很好的解决方案。例子:</target>
        </trans-unit>
        <trans-unit id="c15fbb2556c65982174521dc6e82a15681dc164d" translate="yes" xml:space="preserve">
          <source>This isn't typically the method you want; these addresses don't typically function on modern systems. Use &lt;code&gt;to_ipv6_mapped&lt;/code&gt; instead.</source>
          <target state="translated">这通常不是您想要的方法。这些地址通常在现代系统上不起作用。请改用 &lt;code&gt;to_ipv6_mapped&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca75bc59c45502aa721dfcf6b2008b560ce93b8c" translate="yes" xml:space="preserve">
          <source>This issue also ties into the second problem: although &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are configuration variables to our program, variables like &lt;code&gt;contents&lt;/code&gt; are used to perform the program&amp;rsquo;s logic. The longer &lt;code&gt;main&lt;/code&gt; becomes, the more variables we&amp;rsquo;ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It&amp;rsquo;s best to group the configuration variables into one structure to make their purpose clear.</source>
          <target state="translated">此问题还与第二个问题有关：尽管 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 是程序的配置变量，但诸如 &lt;code&gt;contents&lt;/code&gt; 类的变量仍用于执行程序的逻辑。较长的 &lt;code&gt;main&lt;/code&gt; 变，我们需要纳入范围的多个变量;我们范围内的变量越多，跟踪每个变量的目的就越困难。最好将配置变量分组为一个结构，以明确其用途。</target>
        </trans-unit>
        <trans-unit id="f6ff2f3673f7e2d10b1136073892f6a7e26909fe" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">此迭代器已&lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;融合&lt;/a&gt;，但是&lt;strong&gt;未指定&lt;/strong&gt;迭代完成后的 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 的特定值，除了&lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt;一旦不再产生值将返回 &lt;code&gt;true&lt;/code&gt; 之外。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1db674404809b8384b33fb85e1f59e9aa55c87a" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">此迭代器已&lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;融合&lt;/a&gt;，但是&lt;strong&gt;未指定&lt;/strong&gt;迭代完成后的 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 的特定值，除了&lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt;一旦不再产生值将返回 &lt;code&gt;true&lt;/code&gt; 之外。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22ff5b740b07569a5d9914bbdea6a0fe28474b82" translate="yes" xml:space="preserve">
          <source>This iterator is returned from the &lt;a href=&quot;fn.read_dir&quot;&gt;&lt;code&gt;read_dir&lt;/code&gt;&lt;/a&gt; function of this module and will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Through a &lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt; information like the entry's path and possibly other metadata can be learned.</source>
          <target state="translated">此迭代器从此模块的&lt;a href=&quot;fn.read_dir&quot;&gt; &lt;code&gt;read_dir&lt;/code&gt; &lt;/a&gt;函数返回，并将产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。通过&lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; ,可以&lt;/a&gt;了解类似于条目路径以及可能的其他元数据的信息。</target>
        </trans-unit>
        <trans-unit id="039cfdd22f7232d788dc3924aaf58e6af89b9b42" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned if the corresponding channel has hung up.</source>
          <target state="translated">每当调用&lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;时，此迭代器将阻塞，等待新消息；如果相应的通道已挂断，则将不返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47622e0905704752b067e8fb130b53a4d875da6d" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned when the corresponding channel has hung up.</source>
          <target state="translated">每当调用&lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;时，此迭代器将阻塞，等待新消息，并且当相应的通道挂断时，将不返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d5f1a4f383a40c5608e98cdb7f233b0d0bd50b4" translate="yes" xml:space="preserve">
          <source>This iterator will never block the caller in order to wait for data to become available. Instead, it will return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此迭代器永远不会阻塞调用方，以等待数据可用。相反，它将返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ded90014878b45a9d1013952a0eeccef1815fa3" translate="yes" xml:space="preserve">
          <source>This iterator yields mutable references to the slice's elements, so while the element type of the slice is &lt;code&gt;i32&lt;/code&gt;, the element type of the iterator is &lt;code&gt;&amp;amp;mut i32&lt;/code&gt;.</source>
          <target state="translated">该迭代器产生对slice元素的可变引用，因此，虽然slice的元素类型为 &lt;code&gt;i32&lt;/code&gt; ，但是迭代器的元素类型为 &lt;code&gt;&amp;amp;mut i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11293328eb4e550149e3eb11d18b4b99dadeb4a" translate="yes" xml:space="preserve">
          <source>This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and the primary method is the &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该密钥使用目标平台可用的最快实现。用&lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt;实例化！宏，主要方法是&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="8ba72c9f8d060c616c313ff46104db0834e023c2" translate="yes" xml:space="preserve">
          <source>This kind of reordering is handled transparently by the CPU.</source>
          <target state="translated">这种重新排序是由CPU透明地处理的。</target>
        </trans-unit>
        <trans-unit id="01e9e67a62e244fe3547a3a6a38b452018a02bd0" translate="yes" xml:space="preserve">
          <source>This kind of string &lt;em&gt;can&lt;/em&gt; be mutated:</source>
          <target state="translated">这种字符串&lt;em&gt;可以&lt;/em&gt;被改变：</target>
        </trans-unit>
        <trans-unit id="a40000b09a25d1541d4b670c6d1a695e653d4397" translate="yes" xml:space="preserve">
          <source>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. &lt;code&gt;2.f64&lt;/code&gt; would attempt to call a method named &lt;code&gt;f64&lt;/code&gt; on &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">最后一个示例有所不同，因为无法将后缀语法与以句点结尾的浮点文字一起使用。 &lt;code&gt;2.f64&lt;/code&gt; 将尝试在 &lt;code&gt;2&lt;/code&gt; 上调用名为 &lt;code&gt;f64&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="d48b41e91473a0fe92d3d1ed63ecf51de63aefff" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">该长度以字节为单位，而不是&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或字形。换句话说，可能不是人们认为弦的长度。</target>
        </trans-unit>
        <trans-unit id="73dde2c319f588f84c6b8fc0596849d35bbf8b64" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">该长度以字节为单位，而不是&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或字形。换句话说，可能不是人们认为弦的长度。</target>
        </trans-unit>
        <trans-unit id="903d848487fc64b3813a8038fcea8db3d845066a" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">该长度以字节为单位，而不是&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或字形。换句话说，可能不是人们认为弦的长度。</target>
        </trans-unit>
        <trans-unit id="7b4fe84d99fc580ad8ef75775e9a6a1acf338c01" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">该长度以字节为单位，而不是&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或字形。换句话说，可能不是人们认为弦的长度。</target>
        </trans-unit>
        <trans-unit id="2f8980a7dcbb36debff75ad398d722c2e476b435" translate="yes" xml:space="preserve">
          <source>This limitation may be removed in a future version of Rust.</source>
          <target state="translated">这个限制可能会在未来的Rust版本中被删除。</target>
        </trans-unit>
        <trans-unit id="65d7d6e48995b9a8b70ff571d23a4947777c0d68" translate="yes" xml:space="preserve">
          <source>This limitation on the size &lt;code&gt;N&lt;/code&gt; exists because Rust does not yet support code that is generic over the size of an array type. &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Bar; 3]&lt;/code&gt; are instances of same generic type &lt;code&gt;[T; 3]&lt;/code&gt;, but &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Foo; 5]&lt;/code&gt; are entirely different types. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">之所以存在对大小 &lt;code&gt;N&lt;/code&gt; 的限制，是因为Rust尚不支持在数组类型的大小上通用的代码。 &lt;code&gt;[Foo; 3]&lt;/code&gt; 和 &lt;code&gt;[Bar; 3]&lt;/code&gt; 是相同泛型 &lt;code&gt;[T; 3]&lt;/code&gt; ，但 &lt;code&gt;[Foo; 3]&lt;/code&gt; 和 &lt;code&gt;[Foo; 5]&lt;/code&gt; 是完全不同的类型。作为权宜之计，特质实现是静态生成的，最大大小为32。</target>
        </trans-unit>
        <trans-unit id="08204384af7f77c5b07543f234ee809fc102751e" translate="yes" xml:space="preserve">
          <source>This line brings &lt;code&gt;std::io&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">这行代码将 &lt;code&gt;std::io&lt;/code&gt; 和 &lt;code&gt;std::io::Write&lt;/code&gt; 纳入作用域。</target>
        </trans-unit>
        <trans-unit id="c84219e32c60c562866367e57dce5465f094cc72" translate="yes" xml:space="preserve">
          <source>This line creates a new empty string called &lt;code&gt;s&lt;/code&gt;, which we can then load data into. Often, we&amp;rsquo;ll have some initial data that we want to start the string with. For that, we use the &lt;code&gt;to_string&lt;/code&gt; method, which is available on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait, as string literals do. Listing 8-12 shows two examples.</source>
          <target state="translated">该行创建了一个名为 &lt;code&gt;s&lt;/code&gt; 的新空字符串，然后我们可以将数据加载到其中。通常，我们会使用一些初始数据作为字符串的开头。为此，我们使用 &lt;code&gt;to_string&lt;/code&gt; 方法，该方法可在实现 &lt;code&gt;Display&lt;/code&gt; 特征的任何类型上使用，就像字符串文字一样。清单8-12显示了两个示例。</target>
        </trans-unit>
        <trans-unit id="c6d1af215b1b045e01e47bacfa1ae42f66655d33" translate="yes" xml:space="preserve">
          <source>This line creates a new variable named &lt;code&gt;foo&lt;/code&gt; and binds it to the value of the &lt;code&gt;bar&lt;/code&gt; variable. In Rust, variables are immutable by default. We&amp;rsquo;ll be discussing this concept in detail in the &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;Variables and Mutability&amp;rdquo;&lt;/a&gt; section in Chapter 3. The following example shows how to use &lt;code&gt;mut&lt;/code&gt; before the variable name to make a variable mutable:</source>
          <target state="translated">这行代码创建一个名为 &lt;code&gt;foo&lt;/code&gt; 的新变量，并将其绑定到 &lt;code&gt;bar&lt;/code&gt; 变量的值。在Rust中，默认情况下变量是不可变的。我们将在第3章的&lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;变量和可变性&amp;rdquo;&lt;/a&gt;部分中详细讨论这个概念。下面的示例演示如何在变量名称之前使用 &lt;code&gt;mut&lt;/code&gt; 来使变量可变：</target>
        </trans-unit>
        <trans-unit id="f414052fdd19a240f8f368c285f45f2ce792b467" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here.</source>
          <target state="translated">这一行在这个小程序中完成了所有的工作:它将文字打印到屏幕上。这里有四个重要的细节需要注意。</target>
        </trans-unit>
        <trans-unit id="5d9eacc9407c12ec62c5abf0aec26e9081e77d6a" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here. First, Rust style is to indent with four spaces, not a tab.</source>
          <target state="translated">这一行在这个小程序中完成了所有的工作:它将文字打印到屏幕上。这里有四个重要的细节需要注意。首先,Rust的风格是用四个空格缩进,而不是制表符。</target>
        </trans-unit>
        <trans-unit id="6bb12529672d4d91a104d1b5e1346fffbd28c07c" translate="yes" xml:space="preserve">
          <source>This line prints the string we saved the user&amp;rsquo;s input in. The set of curly brackets, &lt;code&gt;{}&lt;/code&gt;, is a placeholder: think of &lt;code&gt;{}&lt;/code&gt; as little crab pincers that hold a value in place. You can print more than one value using curly brackets: the first set of curly brackets holds the first value listed after the format string, the second set holds the second value, and so on. Printing multiple values in one call to &lt;code&gt;println!&lt;/code&gt; would look like this:</source>
          <target state="translated">该行显示了我们保存用户输入内容的字符串。大括号 &lt;code&gt;{}&lt;/code&gt; 组是一个占位符：将 &lt;code&gt;{}&lt;/code&gt; 看作是保留了适当值的小蟹钳。您可以使用大括号打印多个值：第一组大括号包含格式字符串后列出的第一个值，第二组大括号包含第二个值，依此类推。一次调用 &lt;code&gt;println!&lt;/code&gt; 打印多个值！看起来像这样：</target>
        </trans-unit>
        <trans-unit id="250f132a4cd3e14f1923c5e6c25a460649fabde4" translate="yes" xml:space="preserve">
          <source>This list is intended to grow over time and it is not recommended to exhaustively match against it.</source>
          <target state="translated">这个榜单的目的是随着时间的推移而增长,不建议详尽对照。</target>
        </trans-unit>
        <trans-unit id="308882c8bb15621452c72c71d1e862ba6ca42816" translate="yes" xml:space="preserve">
          <source>This longer form is equivalent to the example in the previous section but is more verbose. We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.</source>
          <target state="translated">这个较长的形式相当于上一节的例子,但比较啰嗦。我们将特质边界与通用类型参数的声明放在冒号之后,并放在角括号内。</target>
        </trans-unit>
        <trans-unit id="cc7e694b75fd14e7d2942129d96e2363378281a2" translate="yes" xml:space="preserve">
          <source>This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in &lt;code&gt;s1&lt;/code&gt; and bind it to &lt;code&gt;s2&lt;/code&gt;. But this isn&amp;rsquo;t quite what happens.</source>
          <target state="translated">这看起来与之前的代码非常相似，因此我们可以假设它的工作方式是相同的：也就是说，第二行将在 &lt;code&gt;s1&lt;/code&gt; 中复制值并将其绑定到 &lt;code&gt;s2&lt;/code&gt; 。但这不是完全会发生的事情。</target>
        </trans-unit>
        <trans-unit id="1be98a7c6692df395b8bd9dd115eb38bb55be823" translate="yes" xml:space="preserve">
          <source>This macro accepts a 'writer', a format string, and a list of arguments. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该宏接受一个&amp;ldquo; writer&amp;rdquo;，一个格式字符串和一个参数列表。参数将根据指定的格式字符串进行格式化，并将结果传递给编写器。 writer可以是带有 &lt;code&gt;write_fmt&lt;/code&gt; 方法的任何值；通常，这来自&lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt;特征的实现。宏返回 &lt;code&gt;write_fmt&lt;/code&gt; 方法返回的任何内容；通常是&lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3025eb870ba9e5f6ef770103ab20b04b0f42de4f" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该宏接受格式字符串，参数列表和&amp;ldquo; writer&amp;rdquo;。参数将根据指定的格式字符串进行格式化，并将结果传递给编写器。writer可以是带有 &lt;code&gt;write_fmt&lt;/code&gt; 方法的任何值；通常，这来自&lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt;特征的实现。宏返回 &lt;code&gt;write_fmt&lt;/code&gt; 方法返回的任何内容；通常是&lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9c26f6e16b6bec90033e045df684b9983904c03" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;std::fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;std::fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该宏接受格式字符串，参数列表和&amp;ldquo; writer&amp;rdquo;。参数将根据指定的格式字符串进行格式化，并将结果传递给编写器。 writer可以是带有 &lt;code&gt;write_fmt&lt;/code&gt; 方法的任何值；通常，这来自于&lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;std::fmt::Write&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt;特性的实现。宏返回 &lt;code&gt;write_fmt&lt;/code&gt; 方法返回的任何内容；通常是&lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;std::fmt::Result&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5250c44d93ce30f02a5f809915ffe3743184cf00" translate="yes" xml:space="preserve">
          <source>This macro bakes in propagation of &lt;a href=&quot;enum.poll#variant.Pending&quot;&gt;&lt;code&gt;Pending&lt;/code&gt;&lt;/a&gt; signals by returning early.</source>
          <target state="translated">该宏通过提早返回来烘焙&lt;a href=&quot;enum.poll#variant.Pending&quot;&gt; &lt;code&gt;Pending&lt;/code&gt; &lt;/a&gt;信号的传播。</target>
        </trans-unit>
        <trans-unit id="80d761ee9febd1152f2043eb4792d1bde7232938" translate="yes" xml:space="preserve">
          <source>This macro bakes in propagation of &lt;code&gt;Pending&lt;/code&gt; signals by returning early.</source>
          <target state="translated">该宏通过提早返回来烘焙 &lt;code&gt;Pending&lt;/code&gt; 信号的传播。</target>
        </trans-unit>
        <trans-unit id="9104464c61f2440f3d22798d14bf9b51373598ab" translate="yes" xml:space="preserve">
          <source>This macro functions by taking a formatting string literal containing &lt;code&gt;{}&lt;/code&gt; for each additional argument passed. &lt;code&gt;format_args!&lt;/code&gt; prepares the additional parameters to ensure the output can be interpreted as a string and canonicalizes the arguments into a single type. Any value that implements the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait can be passed to &lt;code&gt;format_args!&lt;/code&gt;, as can any &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; implementation be passed to a &lt;code&gt;{:?}&lt;/code&gt; within the formatting string.</source>
          <target state="translated">此宏通过为每个传递的附加参数采用包含 &lt;code&gt;{}&lt;/code&gt; 的格式字符串文字来运行。 &lt;code&gt;format_args!&lt;/code&gt; 准备其他参数，以确保输出可以解释为字符串，并将参数规范化为单个类型。任何实现&lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;特性的值都可以传递给 &lt;code&gt;format_args!&lt;/code&gt; ，任何&lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;实现都可以传递给格式字符串内的 &lt;code&gt;{:?}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0f46ebdcffb6d5939dcac636e4ba0ac8074178d" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">该宏具有第二种形式，其中可以提供带有或不带有用于格式化的参数的自定义紧急消息。有关此格式的语法，请参见&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cb7c87fdbeb8a27a8d17493d87d56c13827aded" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">该宏具有第二种形式，其中可以提供自定义紧急消息，带有或不带有用于格式化的参数。有关此格式的语法，请参见&lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b5986245d717af402afebe47105d05cdf22c051" translate="yes" xml:space="preserve">
          <source>This macro is provided in the standard library and will detect at runtime whether the specified CPU feature is detected. This does &lt;strong&gt;not&lt;/strong&gt; resolve at compile time unless the specified feature is already enabled for the entire crate. Runtime detection currently relies mostly on the &lt;code&gt;cpuid&lt;/code&gt; instruction.</source>
          <target state="translated">标准库中提供了此宏，它将在运行时检测是否检测到指定的CPU功能。这并&lt;strong&gt;不会&lt;/strong&gt;，除非指定功能，则整个箱子已经启用在编译时解决。当前，运行时检测主要依赖于 &lt;code&gt;cpuid&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="9c76b02a9e85e30ad24e030882216f3064330d6d" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variants.</source>
          <target state="translated">该宏是在示例代码和测试中声明条件的理想方式。 &lt;code&gt;panic!&lt;/code&gt; 与&lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;枚举的 &lt;code&gt;unwrap&lt;/code&gt; 方法紧密相关。两种实现都 &lt;code&gt;panic!&lt;/code&gt; 将它们设置为&amp;ldquo;&lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;或&amp;ldquo;&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;变体时。</target>
        </trans-unit>
        <trans-unit id="80d199c9b2bbee396aca26a7f3417fd4e87ff814" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to None or Err variants.</source>
          <target state="translated">该宏是在示例代码和测试中声明条件的理想方式。 &lt;code&gt;panic!&lt;/code&gt; 与&lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;枚举的 &lt;code&gt;unwrap&lt;/code&gt; 方法紧密相关。两种实现都 &lt;code&gt;panic!&lt;/code&gt; 将它们设置为&amp;ldquo;无&amp;rdquo;或&amp;ldquo;错误&amp;rdquo;变体时。</target>
        </trans-unit>
        <trans-unit id="d0ebce932633e1b0cd797b4ddeb6ac5a11d9e6f7" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;a href=&quot;boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;any/trait.any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">此宏用于将恐慌注入Rust线程，从而使线程完全陷入恐慌状态。每个线程的恐慌都可以作为&lt;a href=&quot;boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;any/trait.any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 类型，以及 &lt;code&gt;panic!&lt;/code&gt; 的单参数形式！宏将是要传输的值。</target>
        </trans-unit>
        <trans-unit id="cf0774da3df0d29e08106daf482fff334bcea403" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">此宏用于将紧急情况注入Rust线程，从而使该线程完全发生紧急情况。每个线程的恐慌都可以作为 &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; 类型，以及 &lt;code&gt;panic!&lt;/code&gt; 的单参数形式！宏将是要传输的值。</target>
        </trans-unit>
        <trans-unit id="e7802aaf0db102edbab92f402c03063ff3b73be4" translate="yes" xml:space="preserve">
          <source>This macro only takes one argument which is a string literal of the feature being tested for. The feature names supported are the lowercase versions of the ones defined by Intel in &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;their documentation&lt;/a&gt;.</source>
          <target state="translated">该宏仅接受一个参数，该参数是要测试的功能的字符串文字。支持的功能名称是英特尔在&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;其文档中&lt;/a&gt;定义的功能的小写版本。</target>
        </trans-unit>
        <trans-unit id="4bd8a54709ee381edf667e1b754c2dd4776028dd" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">这个宏产生一个&lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;类型的值。该值可以传递给&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;的宏，以执行有用的重定向。所有其他格式化宏（&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;等）都通过此代理。 &lt;code&gt;format_args!&lt;/code&gt; 与派生宏不同，它避免了堆分配。</target>
        </trans-unit>
        <trans-unit id="209265c4eb72c5eca06cd095d36df90048938379" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">该宏产生类型为&lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;的值。可以将该值传递到&lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;的宏，以执行有用的重定向。所有其他格式化宏（&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;等）都通过此代理。 &lt;code&gt;format_args!&lt;/code&gt; 与派生宏不同，它避免了堆分配。</target>
        </trans-unit>
        <trans-unit id="1d449e18cd48bf8c444aeabc9c847abf69b5ab8d" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, but emits an error during &lt;em&gt;compilation&lt;/em&gt; rather than at &lt;em&gt;runtime&lt;/em&gt;.</source>
          <target state="translated">当板条箱使用条件编译策略为错误条件提供更好的错误消息时，应使用此宏。这是编译器级别的&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;，但在&lt;em&gt;编译&lt;/em&gt;过程中而不是在&lt;em&gt;运行时&lt;/em&gt;发出错误。</target>
        </trans-unit>
        <trans-unit id="d49c196cc9f23d7594245f1cc87a1f518746592e" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, which emits an error at &lt;em&gt;runtime&lt;/em&gt;, rather than during compilation.</source>
          <target state="translated">当板条箱使用条件编译策略为错误条件提供更好的错误消息时，应使用此宏。这是编译器级别的&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;，它会在&lt;em&gt;运行时&lt;/em&gt;（而不是在编译期间）发出错误。</target>
        </trans-unit>
        <trans-unit id="68d15cf83524f34dd8d8be7a2a8e7bed6740e783" translate="yes" xml:space="preserve">
          <source>This macro supports the same names that &lt;code&gt;#[target_feature]&lt;/code&gt; supports. Unlike &lt;code&gt;#[target_feature]&lt;/code&gt;, however, this macro does not support names separated with a comma. Instead testing for multiple features must be done through separate macro invocations for now.</source>
          <target state="translated">该宏支持 &lt;code&gt;#[target_feature]&lt;/code&gt; 支持的相同名称。但是，与 &lt;code&gt;#[target_feature]&lt;/code&gt; 不同，此宏不支持用逗号分隔的名称。相反，现在必须通过单独的宏调用来测试多个功能。</target>
        </trans-unit>
        <trans-unit id="fefc6add454f34259443790785050840eebbeb57" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</source>
          <target state="translated">这个宏接收任意数量的逗号分隔的标识符,并将它们全部连接成一个,产生一个新标识符的表达式。请注意,由于卫生原因,这个宏不能捕获局部变量。另外,作为一般规则,宏只允许在项、语句或表达式的位置使用。这意味着虽然你可以使用这个宏来引用现有的变量、函数或模块等,但你不能用它定义一个新的变量。</target>
        </trans-unit>
        <trans-unit id="a79ce9bb3fa69012483f80e7a1a2541065700d68" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated literals, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which represents all of the literals concatenated left-to-right.</source>
          <target state="translated">该宏采用任意数量的逗号分隔的文字，产生类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的表达式，该表达式表示从左到右串联的所有文字。</target>
        </trans-unit>
        <trans-unit id="79fc3c2904becf8aa3c820c279472de0fe3a1f68" translate="yes" xml:space="preserve">
          <source>This macro will expand to the value of the named environment variable at compile time, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">该宏将在编译时扩展为指定的环境变量的值，从而产生类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的表达式。</target>
        </trans-unit>
        <trans-unit id="95e973b1ebc33842358cee19e0dba22c8a81f994" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">该宏将产生 &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; ，即文件的内容。</target>
        </trans-unit>
        <trans-unit id="9cdb0bb59a3aefac2ea084695df47352b8cc7f18" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">该宏将产生类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的表达式，该表达式是文件的内容。</target>
        </trans-unit>
        <trans-unit id="8d3907f6b0e9a61a4bdb55de9a362a92915237c3" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the stringification of all the tokens passed to the macro. No restrictions are placed on the syntax of the macro invocation itself.</source>
          <target state="translated">这个宏将产生类型为 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的表达式，该表达式是传递给该宏的所有令牌的字符串化。宏调用本身的语法没有任何限制。</target>
        </trans-unit>
        <trans-unit id="96f8e740156b1fe8242bb1857eb516b34c772e7e" translate="yes" xml:space="preserve">
          <source>This macro would parse the SQL statement inside it and check that it&amp;rsquo;s syntactically correct, which is much more complex processing than a &lt;code&gt;macro_rules!&lt;/code&gt; macro can do. The &lt;code&gt;sql!&lt;/code&gt; macro would be defined like this:</source>
          <target state="translated">该宏将解析其中的SQL语句，并检查其语法是否正确，这比 &lt;code&gt;macro_rules!&lt;/code&gt; 复杂得多！宏可以做。的 &lt;code&gt;sql!&lt;/code&gt; 宏的定义如下：</target>
        </trans-unit>
        <trans-unit id="f58f7dcc462ef7387fceff17b5cae04e3cbcbf04" translate="yes" xml:space="preserve">
          <source>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</source>
          <target state="translated">这使得该特质在作用域中的所有类型上都能实现。因此,如果你试图在此后的另一个类型上实现它,那么这些实现将发生冲突。例子:</target>
        </trans-unit>
        <trans-unit id="024ad2ae59c4dd5f5ee7d7c019680237dc88183b" translate="yes" xml:space="preserve">
          <source>This may be allowed at some point in the future, but the implementation is not yet complete. See the tracking issues for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/69431&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-lang/rust/issues/74935&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;const fn&lt;/code&gt;, and (to support &lt;code&gt;for&lt;/code&gt; loops in &lt;code&gt;const fn&lt;/code&gt;) the tracking issues for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/67792&quot;&gt;&lt;code&gt;impl const Trait for Ty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-lang/rust/issues/57349&quot;&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="translated">在将来的某个时候可能会允许这样做，但是实现尚未完成。请参阅&lt;a href=&quot;https://github.com/rust-lang/rust/issues/69431&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;和跟踪问题&lt;a href=&quot;https://github.com/rust-lang/rust/issues/74935&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;const fn&lt;/code&gt; ，和（支持 &lt;code&gt;for&lt;/code&gt; 在循环 &lt;code&gt;const fn&lt;/code&gt; ）的跟踪问题&lt;a href=&quot;https://github.com/rust-lang/rust/issues/67792&quot;&gt; &lt;code&gt;impl const Trait for Ty&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://github.com/rust-lang/rust/issues/57349&quot;&gt; &lt;code&gt;&amp;amp;mut T&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;const fn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dafc2f14b4f56d8dc5d075ff34c826a36e387880" translate="yes" xml:space="preserve">
          <source>This may not actually increase the capacity:</source>
          <target state="translated">这实际上可能并没有增加容量。</target>
        </trans-unit>
        <trans-unit id="af903b6fc00acf0d280f6c29b1e0e8d3aeb94082" translate="yes" xml:space="preserve">
          <source>This may only be called by &lt;code&gt;Read&lt;/code&gt;ers which guarantee that they will not read from buffers passed to &lt;code&gt;Read&lt;/code&gt; methods, and that the return value of the method accurately reflects the number of bytes that have been written to the head of the buffer.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 器只能调用此方法，以确保它们不会从传递给 &lt;code&gt;Read&lt;/code&gt; 方法的缓冲区中读取，并且该方法的返回值准确地反映了已写入缓冲区头部的字节数。</target>
        </trans-unit>
        <trans-unit id="14a8a7c42cf833272747226b7446d6fe81b3ec47" translate="yes" xml:space="preserve">
          <source>This may require additional type hints in the function body.</source>
          <target state="translated">这可能需要在功能体中增加类型提示。</target>
        </trans-unit>
        <trans-unit id="ac8b21b0f73b2747acf512efef8390bcec866c71" translate="yes" xml:space="preserve">
          <source>This means iterator adapters can rely on the source not changing during iteration but they cannot rely on it in their Drop implementations.</source>
          <target state="translated">这意味着迭代器适配器可以依靠源在迭代过程中不发生变化,但在他们的Drop实现中不能依靠它。</target>
        </trans-unit>
        <trans-unit id="b07ba109060bf875c034ba50fdb9ffdabfec4929" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all permitted.</source>
          <target state="translated">这意味着 &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 都被允许。</target>
        </trans-unit>
        <trans-unit id="7a8c1c98c2b07fe7a77662bf8cf1e31aa75a3d05" translate="yes" xml:space="preserve">
          <source>This means that any external crate referencing &lt;code&gt;implementation::api::f&lt;/code&gt; would receive a privacy violation, while the path &lt;code&gt;api::f&lt;/code&gt; would be allowed.</source>
          <target state="translated">这意味着引用 &lt;code&gt;implementation::api::f&lt;/code&gt; 任何外部板条箱都会收到隐私侵犯，而允许使用路径 &lt;code&gt;api::f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be2e4dfa333e1a56bbed2f9ca40e5f02293eda70" translate="yes" xml:space="preserve">
          <source>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</source>
          <target state="translated">这意味着,可能前面的一些模式太过笼统,这个模式太过具体,或者顺序不对。</target>
        </trans-unit>
        <trans-unit id="3a6a30f5c049c4edc23b7fd66710a9051982b10a" translate="yes" xml:space="preserve">
          <source>This means that someone can specify such a function:</source>
          <target state="translated">这意味着,有人可以指定这样一个功能。</target>
        </trans-unit>
        <trans-unit id="cb26a69e23fbbf1b07ba0d9979e852887a91fd3d" translate="yes" xml:space="preserve">
          <source>This means that the contents of the first string above &lt;em&gt;will&lt;/em&gt; fit into a &lt;code&gt;char&lt;/code&gt; while the contents of the second string &lt;em&gt;will not&lt;/em&gt;. Trying to create a &lt;code&gt;char&lt;/code&gt; literal with the contents of the second string gives an error:</source>
          <target state="translated">这意味着上面第一个字符串的内容&lt;em&gt;将&lt;/em&gt;适合 &lt;code&gt;char&lt;/code&gt; ,而第二个字符串的内容&lt;em&gt;将不&lt;/em&gt;适合。尝试使用第二个字符串的内容创建 &lt;code&gt;char&lt;/code&gt; 文字会产生错误：</target>
        </trans-unit>
        <trans-unit id="f9131c9dc6b963db63fbff2769fe5ceda6bacdcc" translate="yes" xml:space="preserve">
          <source>This means that the operands don't have to be moved out of.</source>
          <target state="translated">这意味着操作数不必移出。</target>
        </trans-unit>
        <trans-unit id="b2ca51239acb100a6dd5efb03e14c814a0a94286" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;s&lt;/code&gt; reaches the end of &lt;code&gt;demo&lt;/code&gt;, its destructor gets exclusive access to its &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrowed string data. allowing another borrow of that string data (&lt;code&gt;p&lt;/code&gt;), to exist across the drop of &lt;code&gt;s&lt;/code&gt; would be a violation of the principle that &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrows have exclusive, unaliased access to their referenced data.</source>
          <target state="translated">这意味着，当 &lt;code&gt;s&lt;/code&gt; 到达 &lt;code&gt;demo&lt;/code&gt; 的末尾时，其析构函数将获得对其 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 借入的字符串数据的独占访问权。允许在 &lt;code&gt;s&lt;/code&gt; 的整个液滴中再次存在该字符串数据（ &lt;code&gt;p&lt;/code&gt; ）的借项，将违反 &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrows对其引用数据具有独占，非混淆访问的原则。</target>
        </trans-unit>
        <trans-unit id="9b50029fc42e472fbad4bc857af78f98f36c748f" translate="yes" xml:space="preserve">
          <source>This means that, for example, the padding byte in &lt;code&gt;(u8, u16)&lt;/code&gt; is not necessarily zeroed.</source>
          <target state="translated">这意味着，例如 &lt;code&gt;(u8, u16)&lt;/code&gt; 的填充字节不必为零。</target>
        </trans-unit>
        <trans-unit id="382ebf724244bccd694c658a6e7769ce6b7c071d" translate="yes" xml:space="preserve">
          <source>This means, that in addition to &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a != b&lt;/code&gt; being strict inverses, the equality must be (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">这意味着，除了 &lt;code&gt;a == b&lt;/code&gt; 和 &lt;code&gt;a != b&lt;/code&gt; 是严格的逆之外，等式还必须是（对于所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="30330510a00e9290fc18b35d20dbe32f6afe0cd7" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;false&lt;/code&gt; after iteration has finished:</source>
          <target state="translated">迭代完成后，此方法始终返回 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f2cb7c4ca14739fd7d110ae41517acd9e412a5c2" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">这个方法本身是安全的,但正确使用它需要格外小心。另一个线程可以在任何时候改变强计数,包括可能在调用这个方法和对结果采取行动之间。</target>
        </trans-unit>
        <trans-unit id="949f62fcaa7fc2070951a1bf81357a1eb29cd126" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">这个方法本身是安全的,但正确使用它需要格外小心。另一个线程可以在任何时候改变弱点计数,包括可能在调用这个方法和对结果采取行动之间。</target>
        </trans-unit>
        <trans-unit id="3282baf6619178b04f6e093d59df95e6b50b4f0b" translate="yes" xml:space="preserve">
          <source>This method can be used for string data that is &lt;em&gt;terminated&lt;/em&gt;, rather than &lt;em&gt;separated&lt;/em&gt; by a pattern.</source>
          <target state="translated">此方法可用于&lt;em&gt;终止的&lt;/em&gt;字符串数据，而不用模式&lt;em&gt;分隔&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3369ccac8ace2a653ec652b1d0a5f9f1bd24f346" translate="yes" xml:space="preserve">
          <source>This method can be used to reverse a comparison:</source>
          <target state="translated">此方法可用于反向比较。</target>
        </trans-unit>
        <trans-unit id="9f13cbe122409bed70a7bfa8652dd2b252fa340b" translate="yes" xml:space="preserve">
          <source>This method can be useful for situations in which the vector is serving as a buffer for other code, particularly over FFI:</source>
          <target state="translated">这种方法对于向量作为其他代码的缓冲区的情况很有用,特别是在FFI上。</target>
        </trans-unit>
        <trans-unit id="ce975c1398d44efbe8c10a5c85f55c0075a45068" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire byte slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">只有当整个字节分片被成功写入时,本方法才能成功,直到所有数据被写入或出现错误,本方法才会返回。</target>
        </trans-unit>
        <trans-unit id="e42e806090a8aa6caab77166483a1eda09b5296d" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire string slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">只有当整个字符串分片被成功写入时,本方法才能成功,直到所有数据被写入或出现错误,本方法才会返回。</target>
        </trans-unit>
        <trans-unit id="b1f7d3cdb0bfa41dd91aa3d1bf03416a16ee48f3" translate="yes" xml:space="preserve">
          <source>This method differs from &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data. Compared with &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, this function has two failure cases instead of one (one for disconnection, one for a full buffer).</source>
          <target state="translated">此方法不同于&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;，如果通道的缓冲区已满或没有接收器正在等待获取某些数据，则立即返回。与&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;相比，此函数有两种故障情况，而不是一种（一种情况是断开连接，一种情况是完整的缓冲区）。</target>
        </trans-unit>
        <trans-unit id="028002d34f3fafd7bc54cd77bcaa912497a3b074" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; pass ownership of the raw file descriptor to the caller. The descriptor is only guaranteed to be valid while the original object has not yet been destroyed.</source>
          <target state="translated">这个方法并&lt;strong&gt;没有&lt;/strong&gt;将原始文件描述符给调用者的所有权。仅当原始对象尚未销毁时，才保证描述符是有效的。</target>
        </trans-unit>
        <trans-unit id="5fd9fa51612a49edd496cd80117e23b29a509eb6" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by microseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one million).</source>
          <target state="translated">这种方法并&lt;strong&gt;没有&lt;/strong&gt;在由微秒表示返回的持续时间的长度。返回的数字始终表示秒的小数部分（即，小于一百万）。</target>
        </trans-unit>
        <trans-unit id="d3a3c1cf0cc150bd1c72971205d2190e708b8d2b" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by milliseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one thousand).</source>
          <target state="translated">这种方法并&lt;strong&gt;没有&lt;/strong&gt;在由毫秒表示返回的持续时间的长度。返回的数字始终代表秒的小数部分（即，小于一千）。</target>
        </trans-unit>
        <trans-unit id="e8135547d5a3a3a5006fe1cbd5d76d770ff2a7a9" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by nanoseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one billion).</source>
          <target state="translated">这种方法并&lt;strong&gt;没有&lt;/strong&gt;在由纳秒表示返回的持续时间的长度。返回的数字始终代表秒的小数部分（即，小于十亿）。</target>
        </trans-unit>
        <trans-unit id="ac2e63056cc906cac74875b70f6f9009af31f73d" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort a deque.</source>
          <target state="translated">本方法不分配也不改变插入元素的顺序。由于它返回的是一个可改变的分片,因此可以用来对deque进行排序。</target>
        </trans-unit>
        <trans-unit id="bdc4e2ef2ed35366fa011a172b72477b2d16bbd4" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort or binary search a deque.</source>
          <target state="translated">本方法不分配也不改变插入元素的顺序。由于它返回的是一个可改变的分片,因此可以用来对deque进行排序或二进制搜索。</target>
        </trans-unit>
        <trans-unit id="16f6f5d172fff1f1f8e9b8bb728e19c58e51b4b5" translate="yes" xml:space="preserve">
          <source>This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and &lt;em&gt;not&lt;/em&gt; write something like this:</source>
          <target state="translated">该方法不会产生值，但是写入可能会失败。处理错误情况，而&lt;em&gt;不要&lt;/em&gt;编写类似以下内容至关重要：</target>
        </trans-unit>
        <trans-unit id="0b024448d5d7228119631ad22266fba4066f9577" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;ExactSizeIterator::len()&lt;/code&gt;&lt;/a&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">此方法具有使用&lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt; &lt;code&gt;ExactSizeIterator::len()&lt;/code&gt; &lt;/a&gt;的默认实现，因此您无需自己实现。</target>
        </trans-unit>
        <trans-unit id="803e98a2b6e5f0d6a98c75881fdb55c1597f80f0" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;code&gt;self.len()&lt;/code&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">此方法具有使用 &lt;code&gt;self.len()&lt;/code&gt; 的默认实现，因此您无需自己实现。</target>
        </trans-unit>
        <trans-unit id="02fc3c4c098f9a864e6c45270c0a8ae6ffc408ef" translate="yes" xml:space="preserve">
          <source>This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">此方法具有默认实现，因此通常不应直接实现它。但是，如果您可以提供更有效的实现，则可以这样做。请参阅&lt;a href=&quot;trait.exactsizeiterator&quot;&gt;特征级&lt;/a&gt;文档以获取示例。</target>
        </trans-unit>
        <trans-unit id="89f3649aa28c1d3c90be74ebfb70d517cce77458" translate="yes" xml:space="preserve">
          <source>This method has no purpose when either input element &lt;code&gt;T&lt;/code&gt; or output element &lt;code&gt;U&lt;/code&gt; are zero-sized and will return the original slice without splitting anything.</source>
          <target state="translated">当输入元素 &lt;code&gt;T&lt;/code&gt; 或输出元素 &lt;code&gt;U&lt;/code&gt; 的大小为零时，此方法无用，并且将返回原始切片而不拆分任何内容。</target>
        </trans-unit>
        <trans-unit id="08ef0643ebf0dc48a599dc8d5b289675edb9e0a3" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">当值超出范围时，将隐式调用此方法，并且无法显式调用此方法（这是编译器错误&lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;）。但是，前奏中的&lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt;函数可用于调用参数的 &lt;code&gt;Drop&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="37d2a8db1a00abc88d21d10b6113bf279aaebd51" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;std::mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">当值超出范围时，将隐式调用此方法，并且无法显式调用此方法（这是编译器错误&lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;）。但是，前奏中的&lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;std::mem::drop&lt;/code&gt; &lt;/a&gt;函数可用于调用参数的 &lt;code&gt;Drop&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="0b2c9d3aaaa76ea8e330a8973b644085bc25e3bb" translate="yes" xml:space="preserve">
          <source>This method is carefully constructed to avoid allocation. It will consume the error, moving out the bytes, so that a copy of the bytes does not need to be made.</source>
          <target state="translated">这种方法是精心构造的,以避免分配。它将消耗错误,移出字节,这样就不需要对字节进行复制。</target>
        </trans-unit>
        <trans-unit id="ef9d0891851c4c2229a94b62e2e2cf59a2fd15db" translate="yes" xml:space="preserve">
          <source>This method is deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">不推荐使用此方法，而赞成在 &lt;code&gt;u8&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;[u8]&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 上使用相同名称的固有方法。</target>
        </trans-unit>
        <trans-unit id="84886aa1dad1934a5c9bdd981667f36e45fab018" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">此方法与&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;等效，除了不进行任何运行时声明，即 &lt;code&gt;v&lt;/code&gt; 不包含0字节，并且它需要实际的字节向量，而不是可以使用Into转换为1的任何东西。</target>
        </trans-unit>
        <trans-unit id="38f2c8e8e67faa398a8a8adc0a46e90cd363606b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">此方法等效于&lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt;不同之处在于没有做出运行时断言，即 &lt;code&gt;v&lt;/code&gt; 不包含0字节，并且它需要一个实际的字节向量，而不是可以使用Into转换为1的任何东西。</target>
        </trans-unit>
        <trans-unit id="0358b021b2254c197a04c16c02e67b7c9901af56" translate="yes" xml:space="preserve">
          <source>This method is essentially a &lt;code&gt;transmute&lt;/code&gt; with respect to the elements in the returned middle slice, so all the usual caveats pertaining to &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; also apply here.</source>
          <target state="translated">该方法本质上是一个 &lt;code&gt;transmute&lt;/code&gt; 相对于在返回的中间片的元件，因此，所有属于通常的告诫 &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; 也适用于此。</target>
        </trans-unit>
        <trans-unit id="dd229ccab2f3fea46c41c098065dd891d877a2e6" translate="yes" xml:space="preserve">
          <source>This method is identical to &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt;, except for the relaxed lifetime bounds, which render it unsafe. For a more complete documentation see &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法与&lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt;相同，除了宽松的生存期限制（使生存期变得不安全）。有关更完整的文档，请参见&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bc2506b00444cfc62462ac1af4908c0bbe44456" translate="yes" xml:space="preserve">
          <source>This method is implemented using up to three seek operations. If this method returns successfully, the seek position is unchanged (i.e. the position before calling this method is the same as afterwards). However, if this method returns an error, the seek position is unspecified.</source>
          <target state="translated">本方法最多使用三个寻求操作来实现。如果本方法成功返回,则寻求位置不变(即调用本方法之前的位置与之后的位置相同)。但是,如果本方法返回错误,则寻求的位置是不指定的。</target>
        </trans-unit>
        <trans-unit id="f531cfc3a2c409d73bd0f5c2e2364c282b1a69bd" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired. &lt;code&gt;Drop&lt;/code&gt; will be invoked on the returned value following normal end-of-scope rules.</source>
          <target state="translated">此方法主要用于移出液滴中的值。您可以使用此方法获取值并根据需要使用它，而不是使用&lt;a href=&quot;#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt;来手动删除该值。遵循正常范围终止规则，将对返回的值调用 &lt;code&gt;Drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff2d30c02e4e3426a2eb2e0e84eb302b53b0327c" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired.</source>
          <target state="translated">此方法主要用于移出液滴中的值。您可以使用此方法获取值并根据需要使用它，而不是使用&lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt;来手动删除该值。</target>
        </trans-unit>
        <trans-unit id="923fe0c4f9dba0ad8dc8e37a00ed66b6a9da0759" translate="yes" xml:space="preserve">
          <source>This method is primarily used to interface with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro, but it is rare that this should explicitly be called. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro should be favored to invoke this method instead.</source>
          <target state="translated">此方法主要用于与&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;接口！宏，但是很少需要显式调用它。在&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;应该偏爱使用宏来调用此方法。</target>
        </trans-unit>
        <trans-unit id="80fc60d5306ac7d19519f64033eaf35397e48023" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法已被软弃用。&lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e4625fa8bf128959917fb79c2180bb0bb7de232" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法已被软弃用。&lt;a href=&quot;../error/trait.error#method.description&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a9beb6c54e6c8b198cf2df220314195725bd7bb" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法已被软弃用。&lt;a href=&quot;error/trait.error#method.description&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5490d12dcf25f9008acb9584a8ddf0c95e1664f2" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法稳定且可用，但不安全。为了解决这个问题，不赞成使用不安全的&lt;a href=&quot;#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a040da9f6f49ab3965186c9b54eab70d6aecfa7" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法稳定且可用，但不安全。为了解决这个问题，不赞成使用不安全的&lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="428465480a8425bf96628f818ad9aad9c7155318" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法是&lt;a href=&quot;#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; &lt;/a&gt;的const泛型等效项。</target>
        </trans-unit>
        <trans-unit id="d5d24cf3a26d22530ab9cc10e498dc43f87c776a" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法是&lt;a href=&quot;#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; &lt;/a&gt;的const泛型等效项。</target>
        </trans-unit>
        <trans-unit id="881a668b22b8af1fbfcb4abff65037dd8a73fd44" translate="yes" xml:space="preserve">
          <source>This method is unsafe because a &lt;code&gt;Read&lt;/code&gt;er could otherwise return a non-zeroing &lt;code&gt;Initializer&lt;/code&gt; from another &lt;code&gt;Read&lt;/code&gt; type without an &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">这种方法是不安全的，因为一个 &lt;code&gt;Read&lt;/code&gt; 呃否则可能返回非零 &lt;code&gt;Initializer&lt;/code&gt; 从另一个 &lt;code&gt;Read&lt;/code&gt; 类型没有 &lt;code&gt;unsafe&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="272d98e018b9a74f9a82d093db1b7d2de5f94a24" translate="yes" xml:space="preserve">
          <source>This method is useful when doing multiple calls to functions that consume the pinned type.</source>
          <target state="translated">这个方法在对消耗pinned类型的函数进行多次调用时很有用。</target>
        </trans-unit>
        <trans-unit id="b649b72cfd66bc53cdd1236dc499f467fbbbfc65" translate="yes" xml:space="preserve">
          <source>This method requires &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; to be able clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;#method.resize_with&quot;&gt;&lt;code&gt;resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法要求&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;能够克隆传递的值。如果您需要更大的灵活性（或者想要依靠&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;），请使用&lt;a href=&quot;#method.resize_with&quot;&gt; &lt;code&gt;resize_with&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe86d6b287ee66b5bfe82d8d97c6de5a30a28fea" translate="yes" xml:space="preserve">
          <source>This method requires &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, in order to be able to clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;struct.vec#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了能够克隆传递的值，此方法需要 &lt;code&gt;T&lt;/code&gt; 来实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;。如果您需要更大的灵活性（或者想要依靠&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;），请使用&lt;a href=&quot;struct.vec#method.resize_with&quot;&gt; &lt;code&gt;Vec::resize_with&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9a3bfc3f1c3963b065d50d6828d4da511aead6e" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="translated">如果slice不以 &lt;code&gt;suffix&lt;/code&gt; 结尾，则此方法返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;suffix&lt;/code&gt; 为空片，它也会返回原始片</target>
        </trans-unit>
        <trans-unit id="b59bebec2345a5a01479f3be93783390bba5fe3b" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="translated">如果slice不以 &lt;code&gt;prefix&lt;/code&gt; 开头，则此方法返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;prefix&lt;/code&gt; 是空片，它也会返回原始片。</target>
        </trans-unit>
        <trans-unit id="b95f081db21ce8cf4e6f46e10880425784f2765c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">对于[RFC 4291第2.4节]保留的范围内的地址，此方法返回&lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt;，即具有以下格式的地址：</target>
        </trans-unit>
        <trans-unit id="14217d50c79e4eb45c163835b69cd4e673a45e20" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">根据&lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291第2.5.7节，&lt;/a&gt;此方法对站点本地地址返回&lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c067946f55e22970a3dc70591f782f7bfd3be70c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">对于[RFC 4291第2.4节]保留的范围内的地址，即具有以下格式的地址，此方法返回&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1ac7dcf5283432feb1c671ca5dfa7bc7104e0a1d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">根据&lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291第2.5.7节，&lt;/a&gt;此方法对站点本地地址返回&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="48c542fa498c19ba50cecb51c023284b67bf89ad" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="translated">如果slice不以 &lt;code&gt;suffix&lt;/code&gt; 结尾，则此方法返回&lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;suffix&lt;/code&gt; 为空片，它也会返回原始片</target>
        </trans-unit>
        <trans-unit id="da5bb928bae82aca5b2fc0bf565da6017cb0d4d8" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="translated">如果slice不以 &lt;code&gt;prefix&lt;/code&gt; 开头，则此方法返回&lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;prefix&lt;/code&gt; 是空片，它也会返回原始片。</target>
        </trans-unit>
        <trans-unit id="8678f0273a7a7e566a6f4ee8c92fbd30439ee626" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;Ok(())&lt;/code&gt; if the cell was empty and &lt;code&gt;Err(value)&lt;/code&gt; if it was full.</source>
          <target state="translated">如果单元格为空，则此方法返回 &lt;code&gt;Ok(())&lt;/code&gt; ;如果单元格已满，则返回 &lt;code&gt;Err(value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fe438568aa64ab40ad3ae63a4e80c06e5f2d121" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; after iteration has finished:</source>
          <target state="translated">迭代完成后，此方法返回 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a10727aefe2c0619a67b5c808cec5f4b8a1e7af5" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的&lt;a href=&quot;../../cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="553b97aa02f0558b1b0de2b63742a555e1d788b0" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的&lt;a href=&quot;../cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fe70a42b371f1df3da8be36396abdc2eaf19453" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的&lt;a href=&quot;cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36badfc81f37e8dd9893bdb06702e1f5b7aef202" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的&lt;a href=&quot;enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c319c899ab4990e562735b3d21d0f6cd464c7156" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的&lt;a href=&quot;enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da8759d1633206733343524980d7a489afd16956" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f3bbc3554d60688630609ad13846c405e876fac" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。&lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e875552f6e4025920ca5a71d7c281b1fbfaaa2a8" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。&lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="400399c6db28cb18bc3db2944eff105cd4fca3da" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。&lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a47b24f63b5fe410c6da12441f9c98d2fe17c15" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间的 &lt;code&gt;Ordering&lt;/code&gt; 。&lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3cf087c16e29fe754de64f334036b96fe0b3931" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists.</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。</target>
        </trans-unit>
        <trans-unit id="eb17b52a796e0693ad06487790fde93b26d1d781" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。&lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39953b189e90eb45e12641b5213bac17fb6a067f" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。&lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a426df736d2450e1483768eb842876560c3cb8d7" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。&lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64233d3af8194ec0eefc11c727f80c62d14630a" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">如果存在，则此方法返回 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值之间的顺序。&lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="edb583eeb291a512bd3d2447d1fbe080bc3b9dce" translate="yes" xml:space="preserve">
          <source>This method should generally not be invoked manually, but rather through the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro itself.</source>
          <target state="translated">通常不应手动调用此方法，而应通过&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;宏本身。</target>
        </trans-unit>
        <trans-unit id="d7174476c42e976c470e5d3d833837447fe7b624" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.</source>
          <target state="translated">这个方法将片子分割成三个不同的片子:前缀、新类型的正确对齐的中间片子和后缀片子。对于给定的类型和输入分片,该方法尽最大努力使中间分片的长度尽可能大,但只有你的算法的性能应该取决于此,而不是它的正确性。</target>
        </trans-unit>
        <trans-unit id="a7dca763f7ea1b34a0cad9b954868418d78e506c" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method may make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness. It is permissible for all of the input data to be returned as the prefix or suffix slice.</source>
          <target state="translated">这个方法将片子分割成三个不同的片子:前缀、新类型的正确对齐的中间片子和后缀片子。对于给定的类型和输入分片,该方法可以使中间分片的长度尽可能大,但只有你的算法的性能应该取决于此,而不是其正确性。允许将所有的输入数据作为前缀或后缀分片返回。</target>
        </trans-unit>
        <trans-unit id="8000abb209a936f78ade63de708f2749dd5748c7" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">此方法测试 &lt;code&gt;!=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3639f2a22177e5f40d5314d575e638c54018960a" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="e3ea7ba813a098b9b6ae43b0aee731d0092913bf" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;../../../cmp/trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f00abfa17fbf62bab913260c77c4736307dd6b08" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c257c51217cc2c43c24273fbc2f10164037dd5b1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34550195d18fa1542599bef9324d74efad99aeb1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d32084f8ce776d9a529be0f1da6ec9ca22e44396" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 值是否相等，并由 &lt;code&gt;==&lt;/code&gt; 使用。&lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9893b74b381c1707e88afd0a7ed6401e06b38424" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。</target>
        </trans-unit>
        <trans-unit id="9be75e39e05fc52a961a6f8a30bebafa3abc619e" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b084733b90b43f4725bbd31294cb1f36404ce0a" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44184bc5bd845c73d3a6bdc521b7927b64cd5369" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eec657a4246dd487288b986e3d57dfd9657b208" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;trait.partialord#method.gt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0eabc442f100ec2b7e353c049aaaf4ca623d1f2c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator.</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。</target>
        </trans-unit>
        <trans-unit id="4194eb24934481036250e733ab18937ab48da677" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="219eec29ea3645fe37ee0a3de43c26a2abe5b61f" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7907168214aeaea1aa4db413b937e0f747bd41c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e579d59fed2657492555041f61545aa7206f59b6" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试大于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并由 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;trait.partialord#method.ge&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0e789163efc5086c683b5a1f62c9a3bb50e4538" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。</target>
        </trans-unit>
        <trans-unit id="a9a38093c98e8f8478fc7a4cb9a47c1ad908df47" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d167afca39913e71e4062a05ae7a9d99838896ab" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ebc7cc22118ac04d1f984d545d5be0d85818a1e" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54945ad3f8cac4a154fb7b9e35518b30ae999d4d" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试少于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符使用。&lt;a href=&quot;trait.partialord#method.lt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d161a6ff3e691349ec054ac0d4002d49a30e7893" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator.</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。</target>
        </trans-unit>
        <trans-unit id="aadf89f483a504081f46ca5ef3749d0af43a4387" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb1ab74197bbadea31b206cbb3f4c8f2c4d9f37" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db00fc514ef8b2e5769c8d739b13605dcfb91f42" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bca462ad1eb0c753d442b14b7fe002228f03d1ee" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此方法测试小于或等于（针对 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ），并且由 &lt;code&gt;&amp;lt;=&lt;/code&gt; 运算符使用。&lt;a href=&quot;trait.partialord#method.le&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f2ae443e73d5f88ef06a1d6b529c7d18527f78a" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法使用&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;值在每次推送时创建新值。如果您希望&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;给定的值，请使用&lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1dc00be165ac3a4a63601e65e376c360363d264c" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法使用&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;值在每次推送时创建新值。如果您希望&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;给定的值，请使用&lt;a href=&quot;struct.vec#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5ffc4fb20de54f6e75ded6f37d7e6542ba4dcb3" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">此方法使用闭包在每次推送时创建新值。如果您希望&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;给定的值，请使用&lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt;。如果要使用&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;特征来生成值，则可以将&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt;作为第二个参数传递。</target>
        </trans-unit>
        <trans-unit id="94cb38be3cc225054f996a63889a25410328f00e" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;Vec::resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">此方法使用闭包在每次推送时创建新值。如果您希望&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;给定的值，请使用&lt;a href=&quot;struct.vec#method.resize&quot;&gt; &lt;code&gt;Vec::resize&lt;/code&gt; &lt;/a&gt;。如果要使用&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;特征来生成值，则可以传递&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default&lt;/code&gt; &lt;/a&gt;作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="b2c5f86d4c9d838972d27ad9b235e2a91344da57" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the argument.</source>
          <target state="translated">此方法使用闭包创建新值。如果您希望&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;给定的值，请使用&lt;a href=&quot;#method.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt;。如果要使用&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;特质生成值，则可以传递&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default&lt;/code&gt; &lt;/a&gt;作为参数。</target>
        </trans-unit>
        <trans-unit id="900514ffa4e50bfbbb68fdfe9dc96a8ee8c53300" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values. If you'd rather &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the argument.</source>
          <target state="translated">此方法使用闭包创建新值。如果您希望&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;给定的值，请使用&lt;a href=&quot;#method.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt;。如果要使用&lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;特质生成值，则可以传递&lt;a href=&quot;default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default&lt;/code&gt; &lt;/a&gt;作为参数。</target>
        </trans-unit>
        <trans-unit id="6e8aba760b1e58965c26c5247df8d78a97a2b7d9" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此方法将验证RFC中定义的格式，并且不会将以下地址（例如 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; &lt;code&gt;fe81::&lt;/code&gt; 或fe81：:）识别为单播本地链接地址。如果您需要不太严格的验证，请改用&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57f44223f055f4bc85ef6eebc9a26838b98e07df" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此方法将验证RFC中定义的格式，并且不会将以下地址（例如 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; &lt;code&gt;fe81::&lt;/code&gt; 或fe81：:）识别为单播本地链接地址。如果您需要不太严格的验证，请使用&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;is_unicast_link_local()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34a9aeb12096c73821e3d3f2146e3bcd68d312a7" translate="yes" xml:space="preserve">
          <source>This method will be deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">不推荐使用此方法，而应使用 &lt;code&gt;u8&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;[u8]&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 上同名的固有方法。</target>
        </trans-unit>
        <trans-unit id="71c3fa499cb951e39a31bf79d7f47ca94405dd75" translate="yes" xml:space="preserve">
          <source>This method will be removed soon.</source>
          <target state="translated">这种方法将很快被删除。</target>
        </trans-unit>
        <trans-unit id="dab63bf4ac92d7a8265610c22503839aea1e5938" translate="yes" xml:space="preserve">
          <source>This method will block the calling thread if another initialization routine is currently running.</source>
          <target state="translated">如果当前正在运行另一个初始化例程,该方法将阻止调用线程。</target>
        </trans-unit>
        <trans-unit id="fd65ab04cca83f42050b2936debdcfa64855e2e3" translate="yes" xml:space="preserve">
          <source>This method will call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; repeatedly until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, returning the number of times it saw &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; has to be called at least once even if the iterator does not have any elements.</source>
          <target state="translated">此方法将重复调用&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;，直到遇到&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;为止，并返回它看到&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;的次数。请注意，即使迭代器没有任何元素，&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;也必须至少调用一次。</target>
        </trans-unit>
        <trans-unit id="4dcd7df93995d5669f9a19d9090b19b5d2473592" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">此方法将连续调用&lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; ,&lt;/a&gt;直到没有更多数据要写入或返回非&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误为止。在成功写入整个缓冲区或发生此类错误之前，此方法将不会返回。从此方法生成的不是&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误将被返回。</target>
        </trans-unit>
        <trans-unit id="0bf4855a0328106cbe0baa3671aad93298aa630b" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">此方法将连续调用&lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; ,&lt;/a&gt;直到没有更多数据要写入或返回非&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误为止。在成功写入整个缓冲区或发生此类错误之前，此方法将不会返回。从此方法生成的不是&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误将被返回。</target>
        </trans-unit>
        <trans-unit id="34bd7dd9f2f6fd228fe4ece502dea492de39f939" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">此方法将连续调用&lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; ,&lt;/a&gt;直到没有更多数据要写入或返回非&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误为止。在成功写入整个缓冲区或发生此类错误之前，此方法将不会返回。从此方法生成的不是&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误将被返回。</target>
        </trans-unit>
        <trans-unit id="59d4273ac7a3ba1d7a87ecc5115120efa61d6d44" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until all buffers have been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">此方法将连续调用&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; ,&lt;/a&gt;直到没有更多数据要写入或返回非&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误为止。在成功写入所有缓冲区或发生此类错误之前，此方法将不会返回。从此方法生成的不是&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误将被返回。</target>
        </trans-unit>
        <trans-unit id="d3edbd42d79d3d4c4b13caf2b0a59c3d785c0e55" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">此方法将连续调用&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; ,&lt;/a&gt;直到没有更多数据要写入或返回非&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误为止。在成功写入整个缓冲区或发生此类错误之前，此方法将不会返回。从此方法生成的不是&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误将被返回。</target>
        </trans-unit>
        <trans-unit id="b531b20d0eb83c8a34e8a69001999cab52351ebf" translate="yes" xml:space="preserve">
          <source>This method will currently always return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, but this may change in future versions.</source>
          <target state="translated">该方法当前将始终返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;，但是在将来的版本中可能会更改。</target>
        </trans-unit>
        <trans-unit id="f5ce2db6ab8281674bdcae7d5e2f97235788a1d6" translate="yes" xml:space="preserve">
          <source>This method will eagerly skip &lt;code&gt;n&lt;/code&gt; elements by calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; up to &lt;code&gt;n&lt;/code&gt; times until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered.</source>
          <target state="translated">此方法将热切地跳过 &lt;code&gt;n&lt;/code&gt; 通过调用元素&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;高达 &lt;code&gt;n&lt;/code&gt; 直到次&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;遇到。</target>
        </trans-unit>
        <trans-unit id="2170c54e7e7e211e3d0e2c65e377ae8bcaea7ac1" translate="yes" xml:space="preserve">
          <source>This method will ensure that any current waiters on the condition variable are awoken. Calls to &lt;code&gt;notify_all()&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">此方法将确保唤醒条件变量上的所有当前侍者。不会以任何方式缓冲对 &lt;code&gt;notify_all()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="149968b75a735130b9e849f252f39d4aeeb3370e" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until it returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. While doing so, it keeps track of the current element. After &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned, &lt;code&gt;last()&lt;/code&gt; will then return the last element it saw.</source>
          <target state="translated">此方法将评估迭代器，直到返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;为止。这样做时，它会跟踪当前元素。后&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;返回， &lt;code&gt;last()&lt;/code&gt; 将回它看到最后一个元素。</target>
        </trans-unit>
        <trans-unit id="60132e29639954faf0b02a7c1a61ca490fca81f1" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until its &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Once &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, &lt;code&gt;count()&lt;/code&gt; returns the number of times it called &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法将评估迭代器，直到其&lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;为止。一旦遇到&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;count()&lt;/code&gt; 返回其调用&lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;的次数。</target>
        </trans-unit>
        <trans-unit id="430231e1c82b4b198abc958a7fd105f7b17a6eb0" translate="yes" xml:space="preserve">
          <source>This method will fail if the socket is not connected. The &lt;code&gt;connect&lt;/code&gt; method will connect this socket to a remote address.</source>
          <target state="translated">如果未连接套接字，此方法将失败。该 &lt;code&gt;connect&lt;/code&gt; 方法此套接字连接到远程地址。</target>
        </trans-unit>
        <trans-unit id="99d3a71bbe68b832fc3370a5188434c797f36ae5" translate="yes" xml:space="preserve">
          <source>This method will never block the caller in order to wait for data to become available. Instead, this will always return immediately with a possible option of pending data on the channel.</source>
          <target state="translated">这个方法永远不会为了等待数据可用而阻止调用者。相反,它总是会立即返回一个可能的通道上的待处理数据的选项。</target>
        </trans-unit>
        <trans-unit id="cbdaac7e9262e1ca34c4fe476a690d8dd791b78c" translate="yes" xml:space="preserve">
          <source>This method will never block the current thread.</source>
          <target state="translated">此方法永远不会阻止当前线程。</target>
        </trans-unit>
        <trans-unit id="46d2c9fdd8f22af9ddb09186941e568038365eb2" translate="yes" xml:space="preserve">
          <source>This method will panic if result is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">如果结果不是有限的，负的或 &lt;code&gt;Duration&lt;/code&gt; 上限，则此方法将出现恐慌。</target>
        </trans-unit>
        <trans-unit id="361fc3f209ee1e7f236b4d7adeffb54823eee70f" translate="yes" xml:space="preserve">
          <source>This method will take care to not copy the vector, for efficiency's sake.</source>
          <target state="translated">这个方法为了提高效率,会注意不要复制矢量。</target>
        </trans-unit>
        <trans-unit id="086f7043b4f8a7fd4a6336d78995f0e85e9d5744" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;key&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="translated">与 &lt;code&gt;key&lt;/code&gt; 一起使用，此方法是 &lt;code&gt;entry&lt;/code&gt; 的替代方法，可以在事先不知道完整条目的情况下使用。喜欢 &lt;code&gt;entry&lt;/code&gt; 方法时，它可以使用。</target>
        </trans-unit>
        <trans-unit id="8e6fca229e267292b225ded4f3ea56dd1917d4dd" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;value&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="translated">此方法与 &lt;code&gt;value&lt;/code&gt; 一起是 &lt;code&gt;entry&lt;/code&gt; 的替代方法，可以在事先不知道完整条目的情况下使用。喜欢 &lt;code&gt;entry&lt;/code&gt; 方法时，它可以使用。</target>
        </trans-unit>
        <trans-unit id="15bda4a4da4275b96ba5bd1843478dd37908d7e9" translate="yes" xml:space="preserve">
          <source>This module also provides an implementation of thread-local storage for Rust programs. Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized.</source>
          <target state="translated">本模块还提供了Rust程序的线程本地存储的实现。线程本地存储是一种将数据存储到全局变量中的方法,程序中的每个线程都有自己的副本。线程不共享这些数据,所以访问不需要同步。</target>
        </trans-unit>
        <trans-unit id="a618e47bcd778e6fbdbebc05ca474e36092d34bf" translate="yes" xml:space="preserve">
          <source>This module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of &lt;code&gt;std::os::$platform&lt;/code&gt;.</source>
          <target state="translated">这个模块包含基本方法来操纵本地文件系统的内容。该模块中的所有方法均表示跨平台文件系统操作。在 &lt;code&gt;std::os::$platform&lt;/code&gt; 的扩展特性中可以找到特定于平台的其他功能。</target>
        </trans-unit>
        <trans-unit id="facf45454888eb2d77ede3ccdd2076d5cf487a0e" translate="yes" xml:space="preserve">
          <source>This module contains functions for querying the size and alignment of types, initializing and manipulating memory.</source>
          <target state="translated">这个模块包含了查询类型的大小和对齐方式、初始化和操作内存的函数。</target>
        </trans-unit>
        <trans-unit id="2408b577206af618721c013114d9c06e429f800a" translate="yes" xml:space="preserve">
          <source>This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories.</source>
          <target state="translated">该模块包含了检查环境变量、进程参数、当前目录和其他各种重要目录等各个方面的函数。</target>
        </trans-unit>
        <trans-unit id="493f5d09dd437f62e48924cee92d925e5c7d2ef1" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, a trait for converting &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt;s, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">此模块包含&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;类型，转换&lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt;的特征以及使用&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;可能导致的几种错误类型。</target>
        </trans-unit>
        <trans-unit id="0a09e5de88124067a8f4a272146af1f58ce6f16e" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, the &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt; trait for converting to strings, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">该模块包含&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;类型，用于转换为字符串的&lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt;特性以及使用&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;可能导致的几种错误类型。</target>
        </trans-unit>
        <trans-unit id="a15bad5d969fcb97693f6f0bc38018fba7343164" translate="yes" xml:space="preserve">
          <source>This module contains the runtime support for the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings.</source>
          <target state="translated">该模块包含对&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;的运行时支持！语法扩展。该宏在编译器中实现，以发出对该模块的调用，以便在运行时将参数格式化为字符串。</target>
        </trans-unit>
        <trans-unit id="12f15aefb562d878bda21e27716658fa02862f93" translate="yes" xml:space="preserve">
          <source>This module contains the support necessary to capture a stack backtrace of a running OS thread from the OS thread itself. The &lt;code&gt;Backtrace&lt;/code&gt; type supports capturing a stack trace via the &lt;code&gt;Backtrace::capture&lt;/code&gt; and &lt;code&gt;Backtrace::force_capture&lt;/code&gt; functions.</source>
          <target state="translated">该模块包含从OS线程本身捕获正在运行的OS线程的堆栈回溯所必需的支持。该 &lt;code&gt;Backtrace&lt;/code&gt; 类型支持捕捉经由所述栈跟踪 &lt;code&gt;Backtrace::capture&lt;/code&gt; 和 &lt;code&gt;Backtrace::force_capture&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="fe75678b9da36500f1155d5a63660783d7b96c49" translate="yes" xml:space="preserve">
          <source>This module contains various tools for ordering and comparing values. In summary:</source>
          <target state="translated">该模块包含各种排序和比较值的工具。总的来说:</target>
        </trans-unit>
        <trans-unit id="5526cfdf674b75dda2276399dbf95bab9061f815" translate="yes" xml:space="preserve">
          <source>This module defines atomic versions of a select number of primitive types, including &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicisize&quot;&gt;&lt;code&gt;AtomicIsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicusize&quot;&gt;&lt;code&gt;AtomicUsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomici8&quot;&gt;&lt;code&gt;AtomicI8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicu16&quot;&gt;&lt;code&gt;AtomicU16&lt;/code&gt;&lt;/a&gt;, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</source>
          <target state="translated">该模块定义了一些基本类型的原子版本，包括&lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.atomicisize&quot;&gt; &lt;code&gt;AtomicIsize&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.atomicusize&quot;&gt; &lt;code&gt;AtomicUsize&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.atomici8&quot;&gt; &lt;code&gt;AtomicI8&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.atomicu16&quot;&gt; &lt;code&gt;AtomicU16&lt;/code&gt; &lt;/a&gt;等。原子类型提供了一些操作，当正确使用这些操作时，它们将在线程之间同步更新。</target>
        </trans-unit>
        <trans-unit id="69b6d67047755d0189ccf8e0dd69886ba1af9f48" translate="yes" xml:space="preserve">
          <source>This module exists for technical reasons, the primary documentation for &lt;code&gt;char&lt;/code&gt; is directly on &lt;a href=&quot;../primitive.char&quot;&gt;the &lt;code&gt;char&lt;/code&gt; primitive type&lt;/a&gt; itself.</source>
          <target state="translated">此模块存在技术上的原因，对主文档 &lt;code&gt;char&lt;/code&gt; 是直接在&lt;a href=&quot;../primitive.char&quot;&gt;所述 &lt;code&gt;char&lt;/code&gt; 基元类型&lt;/a&gt;本身。</target>
        </trans-unit>
        <trans-unit id="0c05c40f88eef085aa06e135cdea7a637a633c60" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;Any&lt;/code&gt; trait, which enables dynamic typing of any &lt;code&gt;'static&lt;/code&gt; type through runtime reflection.</source>
          <target state="translated">该模块实现了 &lt;code&gt;Any&lt;/code&gt; 特征，该特征允许通过运行时反射来动态键入任何 &lt;code&gt;'static&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="a2779c978566f8d66cd98dfb5457c45d53a57fb6" translate="yes" xml:space="preserve">
          <source>This module is largely organized by type:</source>
          <target state="translated">本模块主要是按类型组织的。</target>
        </trans-unit>
        <trans-unit id="5be07f93f33ed08d424575dcac18854b8631d380" translate="yes" xml:space="preserve">
          <source>This module is mostly concerned with spawning and interacting with child processes, but it also provides &lt;a href=&quot;fn.abort&quot;&gt;&lt;code&gt;abort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.exit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; for terminating the current process.</source>
          <target state="translated">此模块主要与产生和与子进程交互有关，但它也提供&lt;a href=&quot;fn.abort&quot;&gt; &lt;code&gt;abort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.exit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt;以终止当前进程。</target>
        </trans-unit>
        <trans-unit id="288daae4ba933c2cf1c52332e7aec01da8baaf15" translate="yes" xml:space="preserve">
          <source>This module is the home of the iterator implementations for the iterators implemented on &lt;code&gt;char&lt;/code&gt;, as well as some useful constants and conversion functions that convert various types to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">该模块是在 &lt;code&gt;char&lt;/code&gt; 上实现的迭代器的迭代器实现的宿主，以及一些有用的常量和将各种类型转换为 &lt;code&gt;char&lt;/code&gt; 的转换函数。</target>
        </trans-unit>
        <trans-unit id="55568ed1c38eacf7d09bc4bc93efa4b457d73318" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;Permissions::readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">该模块当前仅提供一点信息&lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;Permissions::readonly&lt;/code&gt; &lt;/a&gt;，该信息在所有当前支持的平台上公开。Unix特定的功能（例如模式位）可通过&lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt;特性获得。</target>
        </trans-unit>
        <trans-unit id="16223be8f664aa8af7792fdf4f8c15d5b579360d" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">该模块当前仅提供一点信息&lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt;，该信息在所有当前支持的平台上公开。通过&lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt;特性可以使用特定于Unix的功能，例如模式位。</target>
        </trans-unit>
        <trans-unit id="72abc30b878e9efe98c4c560589176b50cfcfb02" translate="yes" xml:space="preserve">
          <source>This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use &lt;code&gt;#[derive(Hash)]&lt;/code&gt;:</source>
          <target state="translated">该模块提供了一种通用的方法来计算值的哈希值。使类型可 &lt;code&gt;#[derive(Hash)]&lt;/code&gt; 的最简单方法是使用＃[derive（Hash）]：</target>
        </trans-unit>
        <trans-unit id="8f6357e74fc7527ed8e55102f82ccb8843f20d51" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f32&lt;/code&gt; floating point data type.</source>
          <target state="translated">该模块提供特定于 &lt;code&gt;f32&lt;/code&gt; 浮点数据类型实现的常量。</target>
        </trans-unit>
        <trans-unit id="87f0d2ad3a049e2ea757e82944e2e6b1d2f310c4" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f64&lt;/code&gt; floating point data type.</source>
          <target state="translated">该模块提供特定于 &lt;code&gt;f64&lt;/code&gt; 浮点数据类型的实现的常量。</target>
        </trans-unit>
        <trans-unit id="4dd1d432064e6f3e28ac8c1d81caf06446f388ba" translate="yes" xml:space="preserve">
          <source>This module provides message-based communication over channels, concretely defined among three types:</source>
          <target state="translated">该模块提供基于消息的通道通信,具体定义为三种类型。</target>
        </trans-unit>
        <trans-unit id="bfedf6f4f14d905a894526b273dfe17f7e7c03dc" translate="yes" xml:space="preserve">
          <source>This module provides networking functionality for the Transmission Control and User Datagram Protocols, as well as types for IP and socket addresses.</source>
          <target state="translated">该模块提供了传输控制和用户数据报协议的联网功能,以及IP和套接字地址的类型。</target>
        </trans-unit>
        <trans-unit id="fcfa8dfe7aed9682173752b15b6103829ea655a1" translate="yes" xml:space="preserve">
          <source>This module provides some extra types that are useful when doing numerical work. See the individual documentation for each piece for more information.</source>
          <target state="translated">这个模块提供了一些额外的类型,在进行数值工作时很有用。更多信息请参见每个模块的文档。</target>
        </trans-unit>
        <trans-unit id="b42dc453d74574a22f838766ed6a6210b7719f9b" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">该模块提供了两种类型，&lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;（类似于&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;），用于抽象地处理路径。这些类型分别是&lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 的&lt;/a&gt;瘦包装器，这意味着它们根据本地平台的路径语法直接在字符串上工作。</target>
        </trans-unit>
        <trans-unit id="a9add5ffa74ddef61504588ae8fe02f3fc02034e" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">该模块提供了两种类型，即&lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;（类似于&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;），用于抽象地处理路径。这些类型分别是&lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 的&lt;/a&gt;薄包装器，这意味着它们根据本地平台的路径语法直接在字符串上工作。</target>
        </trans-unit>
        <trans-unit id="f2fe72f6bcf1faf654e10546253a992773369d18" translate="yes" xml:space="preserve">
          <source>This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.</source>
          <target state="translated">这个模块提供了处理非Rust接口数据的实用程序,比如其他编程语言和底层操作系统。它主要用于FFI(Foreign Function Interface)绑定和需要与其他语言交换类似C语言字符串的代码。</target>
        </trans-unit>
        <trans-unit id="523a58a1796e44e7bd8c46d95ef23447cedfbc5f" translate="yes" xml:space="preserve">
          <source>This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.</source>
          <target state="translated">这个模块重新导出基元类型,以允许使用不可能被其他声明类型所影响的类型。</target>
        </trans-unit>
        <trans-unit id="2bfbd1c67f1485adce8aa9ca96b08fda6c8d21af" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">该互斥锁将阻止线程等待锁可用。互斥锁也可以通过&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;构造函数进行静态初始化或创建。每个互斥锁都有一个类型参数，代表它要保护的数据。只能通过&lt;a href=&quot;#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;返回的RAII保护访问数据，这保证了只有互斥锁被锁定时才可以访问数据。</target>
        </trans-unit>
        <trans-unit id="37c35fdf98665e8061d3ede706452fcafbf6bf45" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;struct.mutex#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">该互斥锁将阻止线程等待锁可用。互斥锁也可以通过&lt;a href=&quot;struct.mutex#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;构造函数进行静态初始化或创建。每个互斥锁都有一个类型参数，代表它要保护的数据。只能通过&lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;返回的RAII保护来访问数据，这保证了只有互斥锁被锁定时才可以访问数据。</target>
        </trans-unit>
        <trans-unit id="c6bb4ef8774a69f40318879a20a2f5485ae10af2" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">这永远不需要重新分配，但是如果循环缓冲区恰好不在分配的开始，则确实需要进行&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）数据移动。</target>
        </trans-unit>
        <trans-unit id="56f3b065f3863bd74d78c00a2522270062418669" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do O(n) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">这永远不需要重新分配,但如果循环缓冲区不恰好在分配的开始,则需要做O(n)数据移动。</target>
        </trans-unit>
        <trans-unit id="d28b87d734ed0d5315fcb74f17b2994ec84a38d2" translate="yes" xml:space="preserve">
          <source>This new slice goes from &lt;code&gt;begin&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;, including &lt;code&gt;begin&lt;/code&gt; but excluding &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">这种新的切片去从 &lt;code&gt;begin&lt;/code&gt; 到 &lt;code&gt;end&lt;/code&gt; ，包括 &lt;code&gt;begin&lt;/code&gt; ，但不包括 &lt;code&gt;end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5e5d3eaf75778ffc4640687e8cefa2e10e75497" translate="yes" xml:space="preserve">
          <source>This next example calls a supertrait method on a generic parameter.</source>
          <target state="translated">下面这个例子调用了一个通用参数上的supertrait方法。</target>
        </trans-unit>
        <trans-unit id="9f7ad17f03d80b97ecff41fe1815f8dca0918d1f" translate="yes" xml:space="preserve">
          <source>This next example gives &lt;code&gt;radius&lt;/code&gt; a default implementation using the &lt;code&gt;area&lt;/code&gt; function from &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">下一个示例使用 &lt;code&gt;Shape&lt;/code&gt; 中的 &lt;code&gt;area&lt;/code&gt; 函数为 &lt;code&gt;radius&lt;/code&gt; 提供默认实现。</target>
        </trans-unit>
        <trans-unit id="50d4d7072a1ea5b824d1df9626f273fc9c52a75a" translate="yes" xml:space="preserve">
          <source>This number is a lower bound; the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; might be able to hold more, but is guaranteed to be able to hold at least this many.</source>
          <target state="translated">此数字是一个下限；在 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 可能能够容纳更多的，但是保证能够容纳至少该许多。</target>
        </trans-unit>
        <trans-unit id="75625b78a6cc53054a38dc48c604ece0622bfe30" translate="yes" xml:space="preserve">
          <source>This number is simply useful for passing to other methods, like &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt;&lt;code&gt;OsString::with_capacity&lt;/code&gt;&lt;/a&gt; to avoid reallocations.</source>
          <target state="translated">此数字对于传递给其他方法（例如&lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt; &lt;code&gt;OsString::with_capacity&lt;/code&gt; &lt;/a&gt;以避免重新分配非常有用。</target>
        </trans-unit>
        <trans-unit id="1f022d625542e31d83b61a7cfb496898fc698f8a" translate="yes" xml:space="preserve">
          <source>This only differs from the previous &lt;code&gt;impl&lt;/code&gt; in that the parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;ForeignTrait2&lt;/code&gt; have been swapped. This example does &lt;em&gt;not&lt;/em&gt; violate the orphan rule; it is permitted.</source>
          <target state="translated">从以前这仅不同 &lt;code&gt;impl&lt;/code&gt; ，所述参数 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;ForeignTrait2&lt;/code&gt; 已经交换。这个例子并&lt;em&gt;没有&lt;/em&gt;违反规则的孤儿; 这是允许的。</target>
        </trans-unit>
        <trans-unit id="1833c0a27c1d09954fa6a057a5eb72b9706f31ec" translate="yes" xml:space="preserve">
          <source>This only includes environment variables explicitly set with &lt;a href=&quot;struct.command#method.env&quot;&gt;&lt;code&gt;Command::env&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.envs&quot;&gt;&lt;code&gt;Command::envs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.env_remove&quot;&gt;&lt;code&gt;Command::env_remove&lt;/code&gt;&lt;/a&gt;. It does not include environment variables that will be inherited by the child process.</source>
          <target state="translated">这仅包括通过&lt;a href=&quot;struct.command#method.env&quot;&gt; &lt;code&gt;Command::env&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.command#method.envs&quot;&gt; &lt;code&gt;Command::envs&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.command#method.env_remove&quot;&gt; &lt;code&gt;Command::env_remove&lt;/code&gt; &lt;/a&gt;明确设置的环境变量。它不包括子进程将继承的环境变量。</target>
        </trans-unit>
        <trans-unit id="123296246acbbeb137b9c0c76f971008749a56bb" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;fs::set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">此操作也&lt;strong&gt;不会&lt;/strong&gt;修改文件。要修改文件系统，请使用&lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;fs::set_permissions&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="7036bf2f2a1e56b239ac49dd49a90706f4ff18c2" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">此操作也&lt;strong&gt;不会&lt;/strong&gt;修改文件。要修改文件系统，请使用&lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;set_permissions&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="0c0bbc4d892938033fbacd4684ea2a287c924f8c" translate="yes" xml:space="preserve">
          <source>This operation is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">此操作为 &lt;code&gt;O(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd1a487434fc87832e2f1a787954854ff60dfa9b" translate="yes" xml:space="preserve">
          <source>This operation is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="translated">此运算为&lt;em&gt;O&lt;/em&gt;（1）。</target>
        </trans-unit>
        <trans-unit id="1fdec81639aa08f036b813714ac253cba45f17ed" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called 'reduce' or 'inject'.</source>
          <target state="translated">这种操作有时被称为 &quot;减少 &quot;或 &quot;注入&quot;。</target>
        </trans-unit>
        <trans-unit id="c8451edf8bf7bc5bb1bf0555fcc9a5705a25da14" translate="yes" xml:space="preserve">
          <source>This operation performs an unconditional mapping without tailoring. That is, the conversion is independent of context and language.</source>
          <target state="translated">这个操作执行无条件的映射,不需要裁剪。也就是说,转换是独立于上下文和语言的。</target>
        </trans-unit>
        <trans-unit id="e2fd1d86e77ef341cc160d32009392653fd89ec1" translate="yes" xml:space="preserve">
          <source>This operation rounds towards zero, truncating any fractional part of the exact result.</source>
          <target state="translated">这个操作向零进位,将精确结果的任何小数部分截断。</target>
        </trans-unit>
        <trans-unit id="77029037758bda804fd792f27ba1f29cea457a7e" translate="yes" xml:space="preserve">
          <source>This operation satisfies &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt;. The result has the same sign as the left operand.</source>
          <target state="translated">该运算满足 &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt; 。结果与左操作数的符号相同。</target>
        </trans-unit>
        <trans-unit id="bdbe7ca28eb7e43951e771605b8bd474b48c29e7" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time and &lt;em&gt;O&lt;/em&gt;(1) memory.</source>
          <target state="translated">此操作应在&lt;em&gt;O&lt;/em&gt;（1）时间和&lt;em&gt;O&lt;/em&gt;（1）内存中进行计算。</target>
        </trans-unit>
        <trans-unit id="43df87c6439b0a85582f9e67d3c1fce146118f3d" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time.</source>
          <target state="translated">此运算应以&lt;em&gt;O&lt;/em&gt;（1）时间计算。</target>
        </trans-unit>
        <trans-unit id="0d494ef70142bea4ddf2b4f6d9f09545f47dd54e" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time.</source>
          <target state="translated">此运算应以&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）时间计算。</target>
        </trans-unit>
        <trans-unit id="48c9bdd59dbbaca42da37bc9d33eec68b2af8961" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time and O(1) memory.</source>
          <target state="translated">这个操作应该用O(1)时间和O(1)内存来计算。</target>
        </trans-unit>
        <trans-unit id="fc7c0f50f52c35ea7e364b7e26d103277ce95b38" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time.</source>
          <target state="translated">这个操作的计算时间应该是O(1)。</target>
        </trans-unit>
        <trans-unit id="a13a41f53da524732e21aa1da4b3958def62f00f" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(n) time.</source>
          <target state="translated">这个操作的计算时间应该是O(n)。</target>
        </trans-unit>
        <trans-unit id="4da5d428cc5f4bb1f1eadb7b45f2669f2c6be87e" translate="yes" xml:space="preserve">
          <source>This operation was interrupted.</source>
          <target state="translated">这个操作被打断了。</target>
        </trans-unit>
        <trans-unit id="e5b25bf34db3082fbebf881dd2f3b63132ce24a9" translate="yes" xml:space="preserve">
          <source>This operation wraps around on overflow.</source>
          <target state="translated">这个操作在溢出时环绕。</target>
        </trans-unit>
        <trans-unit id="513292ffc7d15c4c6459299bf349f4e8ef41bcc6" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此选项默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07732c105324f285891b421be7b1897cf45eb1a8" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created if the file does not yet already exist.</source>
          <target state="translated">这个选项表明,如果文件还不存在,是否会创建一个新的文件。</target>
        </trans-unit>
        <trans-unit id="2ab719a36168121ae6911773d2659e3887ae7b87" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created. No file is allowed to exist at the target location, also no (dangling) symlink.</source>
          <target state="translated">这个选项表示是否要创建一个新的文件,目标位置不允许有文件存在,也不允许有(悬空)符号链接。目标位置不允许存在任何文件,也不允许有(悬空的)符号链接。</target>
        </trans-unit>
        <trans-unit id="1997355865e9c95bba24957f07adb48aa7900b34" translate="yes" xml:space="preserve">
          <source>This option is useful because it is atomic. Otherwise between checking whether a file exists and creating a new one, the file may have been created by another process (a TOCTOU race condition / attack).</source>
          <target state="translated">这个选项很有用,因为它是原子性的。否则在检查文件是否存在和创建新文件之间,文件可能已经被另一个进程创建了(TOCTOU竞赛条件/攻击)。</target>
        </trans-unit>
        <trans-unit id="4d1d1f446736eda75bb94ad6c4911fc032b1110f" translate="yes" xml:space="preserve">
          <source>This option, when true, means that writes will append to a file instead of overwriting previous contents. Note that setting &lt;code&gt;.write(true).append(true)&lt;/code&gt; has the same effect as setting only &lt;code&gt;.append(true)&lt;/code&gt;.</source>
          <target state="translated">此选项为true时，表示写入将追加到文件，而不是覆盖先前的内容。请注意，设置 &lt;code&gt;.write(true).append(true)&lt;/code&gt; 它和设置只有相同的效果 &lt;code&gt;.append(true)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="279fd5d225ffc9cf4a6694f03d2272dc1973056a" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;read&lt;/code&gt;-able if opened.</source>
          <target state="translated">该选项为true时，表示如果打开该文件，则该文件应为 &lt;code&gt;read&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa691cde7b75893eb561d3865c9d79612f73f71" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;write&lt;/code&gt;-able if opened.</source>
          <target state="translated">该选项为true时，表示打开该文件应为可 &lt;code&gt;write&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="42af0ae9cc5372b7ccd519ad313f0abe9e0cfe15" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a load.</source>
          <target state="translated">该排序仅适用于可以执行负载的操作。</target>
        </trans-unit>
        <trans-unit id="20a3da5b9e12d0ccdf3e64c2e589466b4721fced" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a store.</source>
          <target state="translated">这种排序只适用于可以执行存储的操作。</target>
        </trans-unit>
        <trans-unit id="ea76b31c997f4d8a61f17e8560093311b945344f" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that combine both loads and stores.</source>
          <target state="translated">这种订购方式只适用于同时进行加载和存储的操作。</target>
        </trans-unit>
        <trans-unit id="a87804f30fcdf78425015d26ec12efca3e1a08c7" translate="yes" xml:space="preserve">
          <source>This output is better: we now have a reasonable error message. However, we also have extraneous information we don&amp;rsquo;t want to give to our users. Perhaps using the technique we used in Listing 9-10 isn&amp;rsquo;t the best to use here: a call to &lt;code&gt;panic!&lt;/code&gt; is more appropriate for a programming problem than a usage problem, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;as discussed in Chapter 9&lt;/a&gt;. Instead, we can use the other technique you learned about in Chapter 9&amp;mdash;&lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;returning a &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; that indicates either success or an error.</source>
          <target state="translated">输出更好：我们现在有一条合理的错误消息。但是，我们也有不想提供给用户的无关信息。也许使用清单9-10中使用的技术不是此处最好的使用：引起 &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;如第9章所述&lt;/a&gt;，比使用问题更适合编程问题。相反，我们可以使用你在第三章了解了其他技术的9- &lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;返回 &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;，表示成功或错误。</target>
        </trans-unit>
        <trans-unit id="04051f730c7eeba40e7dd9250f9fd3ae55f310b9" translate="yes" xml:space="preserve">
          <source>This output isn&amp;rsquo;t what we wanted. We want to call the &lt;code&gt;baby_name&lt;/code&gt; function that is part of the &lt;code&gt;Animal&lt;/code&gt; trait that we implemented on &lt;code&gt;Dog&lt;/code&gt; so the code prints &lt;code&gt;A baby dog is called a puppy&lt;/code&gt;. The technique of specifying the trait name that we used in Listing 19-18 doesn&amp;rsquo;t help here; if we change &lt;code&gt;main&lt;/code&gt; to the code in Listing 19-20, we&amp;rsquo;ll get a compilation error.</source>
          <target state="translated">此输出不是我们想要的。我们要调用 &lt;code&gt;baby_name&lt;/code&gt; 函数，该函数是我们在 &lt;code&gt;Dog&lt;/code&gt; 上实现的 &lt;code&gt;Animal&lt;/code&gt; 特质的一部分，因此代码可以打印出来 &lt;code&gt;A baby dog is called a puppy&lt;/code&gt; 。清单19-18中使用的指定特征名称的技术在这里没有帮助；如果将 &lt;code&gt;main&lt;/code&gt; 更改为清单19-20中的代码，则会收到编译错误。</target>
        </trans-unit>
        <trans-unit id="66b4788ea5425d4692dd1ffafd058fec8508d60c" translate="yes" xml:space="preserve">
          <source>This output shows &lt;code&gt;cargo test&lt;/code&gt; only ran the tests for the &lt;code&gt;add-one&lt;/code&gt; crate and didn&amp;rsquo;t run the &lt;code&gt;adder&lt;/code&gt; crate tests.</source>
          <target state="translated">此输出显示 &lt;code&gt;cargo test&lt;/code&gt; 只跑了测试 &lt;code&gt;add-one&lt;/code&gt; 箱子，并没有运行 &lt;code&gt;adder&lt;/code&gt; 箱测试。</target>
        </trans-unit>
        <trans-unit id="f91d4073e1806ac4e46d9be9407b7439ade530c5" translate="yes" xml:space="preserve">
          <source>This outputs:</source>
          <target state="translated">该产出:</target>
        </trans-unit>
        <trans-unit id="220a338b4d08066eba2a22fb127e73c40665ebcb" translate="yes" xml:space="preserve">
          <source>This overwrites pinned data, but that is okay: its destructor gets run before being overwritten, so no pinning guarantee is violated.</source>
          <target state="translated">这将覆盖被钉定的数据,但这没关系:在被覆盖之前,它的析构器会被运行,所以没有违反钉定保证。</target>
        </trans-unit>
        <trans-unit id="05caefb888af241727a56b286e8ae483a7d9633f" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">此页面记录了&lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;遵循规则的正式规范。它们最初是在&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550中&lt;/a&gt;指定的，从中复制了大部分文本，并在后续的RFC中进行了扩展。</target>
        </trans-unit>
        <trans-unit id="3b9633b5692298146f03a49947c6dcff6df1f7b9" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">此页面记录了&lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;遵循规则的正式规范。它们最初是在&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550中&lt;/a&gt;指定的，从中复制了大部分文本，并在后续的RFC中进行了扩展。</target>
        </trans-unit>
        <trans-unit id="f87b1d9607de86149c082e3d8de19453e0048df2" translate="yes" xml:space="preserve">
          <source>This pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we&amp;rsquo;ve allocated on the heap. Let&amp;rsquo;s explore some of those situations now.</source>
          <target state="translated">这种模式对Rust代码的编写方式有深远的影响。现在看来似乎很简单，但是在更复杂的情况下，当我们想让多个变量使用我们在堆上分配的数据时，代码的行为可能出乎意料。现在让我们探讨其中的一些情况。</target>
        </trans-unit>
        <trans-unit id="ebae1cd81adce77daea1f3e37e663633c554fab5" translate="yes" xml:space="preserve">
          <source>This pattern is about separating concerns: &lt;em&gt;main.rs&lt;/em&gt; handles running the program, and &lt;em&gt;lib.rs&lt;/em&gt; handles all the logic of the task at hand. Because you can&amp;rsquo;t test the &lt;code&gt;main&lt;/code&gt; function directly, this structure lets you test all of your program&amp;rsquo;s logic by moving it into functions in &lt;em&gt;lib.rs&lt;/em&gt;. The only code that remains in &lt;em&gt;main.rs&lt;/em&gt; will be small enough to verify its correctness by reading it. Let&amp;rsquo;s rework our program by following this process.</source>
          <target state="translated">这种模式是关于分离关注点的：&lt;em&gt;main.rs&lt;/em&gt;处理运行程序，而&lt;em&gt;lib.rs&lt;/em&gt;处理手头任务的所有逻辑。因为您不能直接测试 &lt;code&gt;main&lt;/code&gt; 函数，所以这种结构可以通过将其移至&lt;em&gt;lib.rs中的&lt;/em&gt;函数中&lt;em&gt;来&lt;/em&gt;测试程序的所有逻辑。保留在&lt;em&gt;main.rs中&lt;/em&gt;的唯一代码将足够小，可以通过读取代码来验证其正确性。让我们按照以下过程重做我们的程序。</target>
        </trans-unit>
        <trans-unit id="4f7fef1aec609824d9a98cbd4986f806fb8112f5" translate="yes" xml:space="preserve">
          <source>This pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">当这个模式的一个子模式是可以反驳的。</target>
        </trans-unit>
        <trans-unit id="8e7824ffc5e192a74a0014b97fd199a69a9bbad1" translate="yes" xml:space="preserve">
          <source>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator &lt;code&gt;?&lt;/code&gt; to make this easier.</source>
          <target state="translated">这种传播错误的模式在Rust中很常见，以至于Rust提供了问号运算符 &lt;code&gt;?&lt;/code&gt; 使它更容易。</target>
        </trans-unit>
        <trans-unit id="be8e420bedd2fafb3e2ace598d4c2a4fc61a219a" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its lowercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">它无需裁剪即可执行复杂的无条件映射：根据&lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode数据库&lt;/a&gt;和其他复杂映射&lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt;，将一个Unicode字符映射为其小写字母。这里不考虑条件映射（基于上下文或语言）。</target>
        </trans-unit>
        <trans-unit id="2bedef26ecd391020afcece167562372d74e3b11" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its uppercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">它无需剪裁即可执行复杂的无条件映射：根据&lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode数据库&lt;/a&gt;和其他复杂映射&lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt;，将一个Unicode字符映射为其大写形式。这里不考虑条件映射（基于上下文或语言）。</target>
        </trans-unit>
        <trans-unit id="367fd59cc7a5ce52d6910a709b90bfcbe81a7ab5" translate="yes" xml:space="preserve">
          <source>This piece of Rust history is relevant because it&amp;rsquo;s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.</source>
          <target state="translated">Rust的这段历史很重要，因为可能会出现更多确定性模式并将其添加到编译器中。将来，可能需要更少的生命周期注释。</target>
        </trans-unit>
        <trans-unit id="4d1e98917aa47fb301eb32dc85055855554e0b37" translate="yes" xml:space="preserve">
          <source>This pinned future is then polled by calling the &lt;a href=&quot;../../std/future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;Future::poll&lt;/code&gt;&lt;/a&gt; method and passing it the current &lt;a href=&quot;#task-context&quot;&gt;task context&lt;/a&gt;;</source>
          <target state="translated">然后，通过调用&lt;a href=&quot;../../std/future/trait.future#tymethod.poll&quot;&gt; &lt;code&gt;Future::poll&lt;/code&gt; &lt;/a&gt;方法并将其传递给当前&lt;a href=&quot;#task-context&quot;&gt;任务上下文来&lt;/a&gt;轮询固定的Future。</target>
        </trans-unit>
        <trans-unit id="ce7cedc5fc51216f120f0eb8fae3379dc963620e" translate="yes" xml:space="preserve">
          <source>This prints output like:</source>
          <target state="translated">这就打印出了这样的输出。</target>
        </trans-unit>
        <trans-unit id="ff9f7a5e1d4525cd7d8438461ac9c53da48b455e" translate="yes" xml:space="preserve">
          <source>This prints to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;:</source>
          <target state="translated">打印到&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3c9f3b33a54ec1f8657331a04066cc462bed4e33" translate="yes" xml:space="preserve">
          <source>This problem can be solved by specifying from which trait we want to use the &lt;code&gt;Bar&lt;/code&gt; type:</source>
          <target state="translated">可以通过指定要使用 &lt;code&gt;Bar&lt;/code&gt; 类型的特征来解决此问题：</target>
        </trans-unit>
        <trans-unit id="fc4e53a566f64cd7b3bd5c8e48b6dab0075560d7" translate="yes" xml:space="preserve">
          <source>This process does not take into account the mutability or lifetime of the receiver, or whether a method is &lt;code&gt;unsafe&lt;/code&gt;. Once a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.</source>
          <target state="translated">此过程未考虑接收方的可变性或生存期，也未考虑方法是否 &lt;code&gt;unsafe&lt;/code&gt; 。查找方法后，如果由于一个或多个原因而无法调用该方法，则结果是编译器错误。</target>
        </trans-unit>
        <trans-unit id="1ff3edc7107794fccb9370413ce9f2edb3d33555" translate="yes" xml:space="preserve">
          <source>This process is just one of many ways to write software, but TDD can help drive code design as well. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.</source>
          <target state="translated">这个过程只是编写软件的众多方法之一,但TDD也可以帮助推动代码设计。在编写使测试通过的代码之前,先编写测试,有助于在整个过程中保持较高的测试覆盖率。</target>
        </trans-unit>
        <trans-unit id="2a5870cc6149419aa4b701948d1d720f8c2eb21c" translate="yes" xml:space="preserve">
          <source>This program compiles without any errors and would also do so if we used &lt;code&gt;word&lt;/code&gt; after calling &lt;code&gt;s.clear()&lt;/code&gt;. Because &lt;code&gt;word&lt;/code&gt; isn&amp;rsquo;t connected to the state of &lt;code&gt;s&lt;/code&gt; at all, &lt;code&gt;word&lt;/code&gt; still contains the value &lt;code&gt;5&lt;/code&gt;. We could use that value &lt;code&gt;5&lt;/code&gt; with the variable &lt;code&gt;s&lt;/code&gt; to try to extract the first word out, but this would be a bug because the contents of &lt;code&gt;s&lt;/code&gt; have changed since we saved &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">该程序的编译没有任何错误，如果我们在调用 &lt;code&gt;s.clear()&lt;/code&gt; 之后使用 &lt;code&gt;word&lt;/code&gt; ，也可以这样做。因为 &lt;code&gt;word&lt;/code&gt; 根本不连接到 &lt;code&gt;s&lt;/code&gt; 的状态，所以 &lt;code&gt;word&lt;/code&gt; 仍然包含值 &lt;code&gt;5&lt;/code&gt; 。我们可以将值 &lt;code&gt;5&lt;/code&gt; 与变量 &lt;code&gt;s&lt;/code&gt; 一起使用以尝试提取第一个单词，但这将是一个错误，因为自从我们在 &lt;code&gt;word&lt;/code&gt; 中保存 &lt;code&gt;5&lt;/code&gt; 以来 &lt;code&gt;s&lt;/code&gt; 的内容已更改。</target>
        </trans-unit>
        <trans-unit id="a1a216c5bb2240db271ccf5242339067640e2983" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their index. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">该程序创建一个元组 &lt;code&gt;x&lt;/code&gt; ，然后使用它们的索引为每个元素创建新变量。与大多数编程语言一样，元组中的第一个索引为0。</target>
        </trans-unit>
        <trans-unit id="a953795409deaf59d9e6550cf24f5329cf86ee13" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their respective indices. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">该程序创建一个元组 &lt;code&gt;x&lt;/code&gt; ，然后通过使用它们各自的索引为每个元素创建新变量。与大多数编程语言一样，元组中的第一个索引为0。</target>
        </trans-unit>
        <trans-unit id="052f0899e565e8d2644e743be0e56bf26e6e1767" translate="yes" xml:space="preserve">
          <source>This program first binds &lt;code&gt;x&lt;/code&gt; to a value of &lt;code&gt;5&lt;/code&gt;. Then it shadows &lt;code&gt;x&lt;/code&gt; by repeating &lt;code&gt;let x =&lt;/code&gt;, taking the original value and adding &lt;code&gt;1&lt;/code&gt; so the value of &lt;code&gt;x&lt;/code&gt; is then &lt;code&gt;6&lt;/code&gt;. The third &lt;code&gt;let&lt;/code&gt; statement also shadows &lt;code&gt;x&lt;/code&gt;, multiplying the previous value by &lt;code&gt;2&lt;/code&gt; to give &lt;code&gt;x&lt;/code&gt; a final value of &lt;code&gt;12&lt;/code&gt;. When we run this program, it will output the following:</source>
          <target state="translated">该程序首先将 &lt;code&gt;x&lt;/code&gt; 绑定为 &lt;code&gt;5&lt;/code&gt; 。然后，它阴影 &lt;code&gt;x&lt;/code&gt; 通过重复 &lt;code&gt;let x =&lt;/code&gt; ，取原始值和添加 &lt;code&gt;1&lt;/code&gt; 这样的值 &lt;code&gt;x&lt;/code&gt; 是则 &lt;code&gt;6&lt;/code&gt; 。第三个 &lt;code&gt;let&lt;/code&gt; 语句也将 &lt;code&gt;x&lt;/code&gt; 遮盖起来，将先前的值乘以 &lt;code&gt;2&lt;/code&gt; 得到 &lt;code&gt;x&lt;/code&gt; 的最终值为 &lt;code&gt;12&lt;/code&gt; 。当我们运行该程序时，它将输出以下内容：</target>
        </trans-unit>
        <trans-unit id="e37eff19d0df592c13224ef2e32fd74387b55f9e" translate="yes" xml:space="preserve">
          <source>This program first creates a tuple and binds it to the variable &lt;code&gt;tup&lt;/code&gt;. It then uses a pattern with &lt;code&gt;let&lt;/code&gt; to take &lt;code&gt;tup&lt;/code&gt; and turn it into three separate variables, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. This is called &lt;em&gt;destructuring&lt;/em&gt;, because it breaks the single tuple into three parts. Finally, the program prints the value of &lt;code&gt;y&lt;/code&gt;, which is &lt;code&gt;6.4&lt;/code&gt;.</source>
          <target state="translated">该程序首先创建一个元组并将其绑定到变量 &lt;code&gt;tup&lt;/code&gt; 。然后，它使用 &lt;code&gt;let&lt;/code&gt; 的模式将 &lt;code&gt;tup&lt;/code&gt; 转换为三个独立的变量 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 。这称为&lt;em&gt;解构&lt;/em&gt;，因为它会将单个元组分为三部分。最后，程序打印的值 &lt;code&gt;y&lt;/code&gt; ，这是 &lt;code&gt;6.4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e68e59981686f4d6d9628e4a0f06c39a18431f20" translate="yes" xml:space="preserve">
          <source>This program has four possible paths it can take. After running it, you should see the following output:</source>
          <target state="translated">这个程序有四种可能的路径。运行后,你应该看到以下输出。</target>
        </trans-unit>
        <trans-unit id="c268368ea9194ea4e99d8e793596c3443d5a9397" translate="yes" xml:space="preserve">
          <source>This project was a hands-on way to introduce you to many new Rust concepts: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, the use of external crates, and more. In the next few chapters, you&amp;rsquo;ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</source>
          <target state="translated">该项目是向您介绍许多Rust新概念的动手方式： &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;match&lt;/code&gt; ，方法，关联函数，外部包装箱的使用等。在接下来的几章中，您将更详细地了解这些概念。第3章介绍了大多数编程语言所具有的概念，例如变量，数据类型和函数，并介绍了如何在Rust中使用它们。第4章探讨所有权，此功能使Rust与其他语言有所不同。第5章讨论结构和方法语法，第6章介绍枚举的工作方式。</target>
        </trans-unit>
        <trans-unit id="9ce38c4decb31cc4f3034ac7fae7c79d93e80f53" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, and has no extra methods.</source>
          <target state="translated">编译器无法检查此属性，因此 &lt;code&gt;Eq&lt;/code&gt; 表示&lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;，并且没有其他方法。</target>
        </trans-unit>
        <trans-unit id="ab41f4f49ac9b596f3ff341e670c3c513d2c2a1e" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;code&gt;PartialEq&lt;/code&gt;, and has no extra methods.</source>
          <target state="translated">编译器无法检查此属性，因此 &lt;code&gt;Eq&lt;/code&gt; 表示 &lt;code&gt;PartialEq&lt;/code&gt; ，并且没有其他方法。</target>
        </trans-unit>
        <trans-unit id="1608442363fd58986072b46f4e6a650827d3385c" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;.</source>
          <target state="translated">此属性由&lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="25a4736ccf9a4ba3c3e3dac30177800bc1f743c9" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;.</source>
          <target state="translated">此属性由&lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="2cdf66b6082611e25a822825249d22e6f28f1917" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">此属性由&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="93af0d07e68cafd035375823424d1e725ddb07d1" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt;.</source>
          <target state="translated">此属性在&lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849中&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="85df454e96ffa6c63ed8ab37d8086b690c9dba86" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt;.</source>
          <target state="translated">此属性在&lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193中&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="9d5a4dec1164aed352e96ad9af690b1a3591dc76" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">此属性在&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291中&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="c731a3c6e670f4842c76f756fa1e0f4c4f1cfae6" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;em&gt;UNIX Network Programming, Second Edition&lt;/em&gt;, W. Richard Stevens, p. 891; see also &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;.</source>
          <target state="translated">此属性在&lt;em&gt;UNIX Network Programming，第二版&lt;/em&gt;，W。Richard Stevens，p。891; 另请参阅&lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19926d7df32802514fef095810b287a92fa4b874" translate="yes" xml:space="preserve">
          <source>This queue has &lt;code&gt;O(1)&lt;/code&gt; amortized inserts and removals from both ends of the container. It also has &lt;code&gt;O(1)&lt;/code&gt; indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">此队列在容器的两端具有 &lt;code&gt;O(1)&lt;/code&gt; 分摊的插入和删除。它还具有像矢量一样的 &lt;code&gt;O(1)&lt;/code&gt; 索引。所包含的元素不需要是可复制的，并且如果所包含的类型是可发送的，则队列将是可发送的。</target>
        </trans-unit>
        <trans-unit id="f222b6950bf888a7c8ce05739a640f15b3f1b84f" translate="yes" xml:space="preserve">
          <source>This queue has &lt;em&gt;O&lt;/em&gt;(1) amortized inserts and removals from both ends of the container. It also has &lt;em&gt;O&lt;/em&gt;(1) indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">此队列在容器的两端具有&lt;em&gt;O&lt;/em&gt;（1）摊销的插入和删除。它还具有像向量一样的&lt;em&gt;O&lt;/em&gt;（1）索引。所包含的元素不需要是可复制的，并且如果所包含的类型是可发送的，则队列将是可发送的。</target>
        </trans-unit>
        <trans-unit id="ae16a9ff1b9b0bb4dc2773f7faab160bd7347257" translate="yes" xml:space="preserve">
          <source>This reader has reached its &quot;end of file&quot; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will &lt;em&gt;always&lt;/em&gt; no longer be able to produce bytes.</source>
          <target state="translated">该阅读器已到达其&amp;ldquo;文件结尾&amp;rdquo;，可能不再能够产生字节。请注意，这并不意味着读取器将&lt;em&gt;永远&lt;/em&gt;不再能够产生字节。</target>
        </trans-unit>
        <trans-unit id="eabbe1cac74b5970cf00777c8a04a9b08b503051" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">此重新排序具有附加属性，即使用比较器功能，位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即，不分配）和 &lt;code&gt;O(n)&lt;/code&gt; 最坏的情况。在其他库中，此功能也称为&amp;ldquo;第k个元素&amp;rdquo;。它使用提供的比较器函数返回以下值的三元组：所有元素小于给定索引处的元素，给定索引处的值以及所有元素大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="5a5e3f81a187820f825f4369ca83b2c286d9273d" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">此重新排序具有附加属性，即使用比较器功能，位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即不分配）和&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）最坏的情况。在其他库中，此功能也称为&amp;ldquo;第k个元素&amp;rdquo;。它使用提供的比较器函数返回以下值的三元组：所有元素小于给定索引处的元素，给定索引处的值以及所有元素大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="58333e6fd2204efb6d059b5e0ebaa3ad2ae11cea" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">此重新排序具有附加属性，即使用密钥提取功能，位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即，不分配）和 &lt;code&gt;O(n)&lt;/code&gt; 最坏的情况。在其他库中，此功能也称为&amp;ldquo;第k个元素&amp;rdquo;。它使用提供的键提取函数返回以下值的三元组：所有元素小于给定索引处的元素，给定索引处的值以及所有元素大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="c83a0af8a141703ce8a894f271d81b6b5d0d2d99" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">此重新排序具有附加属性，即使用密钥提取功能，位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即不分配）和&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）最坏的情况。在其他库中，此功能也称为&amp;ldquo;第k个元素&amp;rdquo;。它使用提供的键提取函数返回以下值的三元组：所有元素小于给定索引处的元素，给定索引处的值以及所有元素大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="18b0ecb2451beab6446b7792a5f32ac5b93e64f7" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">此重新排序具有附加属性，即位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即未分配）和 &lt;code&gt;O(n)&lt;/code&gt; 最坏的情况。在其他库中，此功能也被称为&amp;ldquo;第k个元素&amp;rdquo;。它返回以下值的三元组：所有元素小于给定索引处的元素，给定索引的值以及所有元素大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="3d259af27d2572df43e2afe02e6f4d51f6ff06a9" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">此重新排序具有附加属性，即位置 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 处的任何值将小于或等于位置 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 处的任何值。另外，这种重新排序是不稳定的（即，任意数量的相等元素都可能在位置 &lt;code&gt;index&lt;/code&gt; 处结束），就地（即不分配）和&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）最坏的情况。在其他库中，此功能也被称为&amp;ldquo;第k个元素&amp;rdquo;。它返回以下值的三元组：所有元素都小于给定索引处的元素，给定索引处的值，以及所有元素都大于给定索引处的元素。</target>
        </trans-unit>
        <trans-unit id="6a44d46360998129b78ed15d687f727979c543e5" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums.</source>
          <target state="translated">这种表示方法可以应用于结构、联合和枚举。</target>
        </trans-unit>
        <trans-unit id="c79281349d10df09672689425c0c484e6ef587c0" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums. The exception is &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enums&lt;/a&gt; for which the &lt;code&gt;C&lt;/code&gt; representation is an error.</source>
          <target state="translated">此表示形式可以应用于结构，联合和枚举。&lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;零变量枚举&lt;/a&gt;例外，其 &lt;code&gt;C&lt;/code&gt; 表示形式是错误的。</target>
        </trans-unit>
        <trans-unit id="54d003da75e5c18c6d78ec752d4c5ea2c1005e03" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; so that we can ignore the pinning invariants when unwrapping it.</source>
          <target state="translated">这要求此 &lt;code&gt;Pin&lt;/code&gt; 内的数据为&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; ,&lt;/a&gt;以便在展开时可以忽略固定不变。</target>
        </trans-unit>
        <trans-unit id="84a024e08861a138f89bc49f72665722f5345893" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">这要求此 &lt;code&gt;Pin&lt;/code&gt; 内的数据为 &lt;code&gt;Unpin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb8049ba5b3a969809828fb6b20b4c6f803c243a" translate="yes" xml:space="preserve">
          <source>This restriction allows for mutation but in a very controlled fashion. It&amp;rsquo;s something that new Rustaceans struggle with, because most languages let you mutate whenever you&amp;rsquo;d like.</source>
          <target state="translated">该限制允许突变，但是以非常受控的方式。这是新的Rustaceans苦苦挣扎的事情，因为大多数语言都允许您随时更改。</target>
        </trans-unit>
        <trans-unit id="b9005ee922bd85c1b8cdd5bf9e647bc71bc7e1d1" translate="yes" xml:space="preserve">
          <source>This restricts us to a &lt;code&gt;Screen&lt;/code&gt; instance that has a list of components all of type &lt;code&gt;Button&lt;/code&gt; or all of type &lt;code&gt;TextField&lt;/code&gt;. If you&amp;rsquo;ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</source>
          <target state="translated">这将我们限制为一个 &lt;code&gt;Screen&lt;/code&gt; 实例，该实例具有一个全部为 &lt;code&gt;Button&lt;/code&gt; 类型或全部 &lt;code&gt;TextField&lt;/code&gt; 类型的组件的列表。如果只使用同质集合，则最好使用泛型和特征范围，因为定义将在编译时进行单态化以使用具体类型。</target>
        </trans-unit>
        <trans-unit id="fef61557094c53c94d8f4b9c87d239c1c4ddf6a3" translate="yes" xml:space="preserve">
          <source>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message in this case would print the value we got from the &lt;code&gt;greeting&lt;/code&gt; function. Let&amp;rsquo;s change the test function, giving it a custom failure message made from a format string with a placeholder filled in with the actual value we got from the &lt;code&gt;greeting&lt;/code&gt; function:</source>
          <target state="translated">此结果仅表明断言失败以及断言在哪一行上。在这种情况下，更有用的失败消息将显示从 &lt;code&gt;greeting&lt;/code&gt; 函数获得的值。让我们更改测试功能，为它提供一个自定义的失败消息，该消息是由格式字符串组成的，占位符填充了我们从 &lt;code&gt;greeting&lt;/code&gt; 函数获得的实际值：</target>
        </trans-unit>
        <trans-unit id="0886cd5bf439fbbc8be3535b3d5401de7c87877b" translate="yes" xml:space="preserve">
          <source>This return type means the call to &lt;code&gt;File::open&lt;/code&gt; might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The &lt;code&gt;File::open&lt;/code&gt; function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the &lt;code&gt;Result&lt;/code&gt; enum conveys.</source>
          <target state="translated">此返回类型意味着对 &lt;code&gt;File::open&lt;/code&gt; 的调用可能会成功，并返回一个我们可以读取或写入的文件句柄。函数调用也可能失败：例如，该文件可能不存在，或者我们可能没有访问该文件的权限。该 &lt;code&gt;File::open&lt;/code&gt; 功能需要有一种方式来告诉我们，无论是成功还是失败，并在同一时间给我们任何文件句柄或错误信息。该信息正是 &lt;code&gt;Result&lt;/code&gt; 枚举所传达的信息。</target>
        </trans-unit>
        <trans-unit id="6e6467b9314c67467a583133eaf79a55bec1323c" translate="yes" xml:space="preserve">
          <source>This returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the working directory will not be changed.</source>
          <target state="translated">如果不会更改工作目录，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7256f6dfb124c4206009cc4970395f092ae3141" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;None&lt;/code&gt; if the cursor is currently pointing to the &quot;ghost&quot; non-element.</source>
          <target state="translated">如果光标当前指向&amp;ldquo; ghost&amp;rdquo;非元素，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b3770e7d2efd1b08fe66eb571f2a780fb54e25f" translate="yes" xml:space="preserve">
          <source>This returns a numeric identifier for the thread identified by this &lt;code&gt;ThreadId&lt;/code&gt;.</source>
          <target state="translated">这将返回此 &lt;code&gt;ThreadId&lt;/code&gt; 标识的线程的数字标识符。</target>
        </trans-unit>
        <trans-unit id="368beec57f1181b8799a91ee73ada8b4184da78e" translate="yes" xml:space="preserve">
          <source>This reuses all the nodes from &lt;code&gt;other&lt;/code&gt; and moves them into &lt;code&gt;self&lt;/code&gt;. After this operation, &lt;code&gt;other&lt;/code&gt; becomes empty.</source>
          <target state="translated">这将从 &lt;code&gt;other&lt;/code&gt; 节点重用所有节点，并将它们移到 &lt;code&gt;self&lt;/code&gt; 。此操作后， &lt;code&gt;other&lt;/code&gt; 变为空。</target>
        </trans-unit>
        <trans-unit id="7730271090bac7f074841851b1b821f9fc7fca43" translate="yes" xml:space="preserve">
          <source>This rework may seem like overkill for our small program, but we&amp;rsquo;re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It&amp;rsquo;s good to check your progress often, to help identify the cause of problems when they occur.</source>
          <target state="translated">对于我们的小型程序来说，这种返工似乎有些过头，但是我们正在逐步进行小型重构。进行更改后，再次运行该程序以验证参数解析仍然有效。最好经常检查进度，以帮助确定问题发生的原因。</target>
        </trans-unit>
        <trans-unit id="c68a9d1019f31cc86d07a97f90c903ea86167b11" translate="yes" xml:space="preserve">
          <source>This rule also applies to type parameters of impl blocks that contain const methods</source>
          <target state="translated">这个规则也适用于包含 const 方法的 impl 块的类型参数。</target>
        </trans-unit>
        <trans-unit id="c9e400474c407c09b7fb37164368bcd30fbe8830" translate="yes" xml:space="preserve">
          <source>This runs the code in &lt;em&gt;adder/src/main.rs&lt;/em&gt;, which depends on the &lt;code&gt;add-one&lt;/code&gt; crate.</source>
          <target state="translated">这将在&lt;em&gt;adder / src / main.rs中&lt;/em&gt;运行代码，具体取决于 &lt;code&gt;add-one&lt;/code&gt; 板条箱。</target>
        </trans-unit>
        <trans-unit id="e6b2224800e73c42ee25267c2896a776ab41e710" translate="yes" xml:space="preserve">
          <source>This section documents features that affect the ABI of the compiled output of a crate.</source>
          <target state="translated">本节记录了影响装箱的编译输出的ABI的特征。</target>
        </trans-unit>
        <trans-unit id="7dc2765b02ef149354a7a9ee16a696edf0827240" translate="yes" xml:space="preserve">
          <source>This section documents features that define some aspects of the Rust runtime.</source>
          <target state="translated">本节记录了定义Rust运行时某些方面的特性。</target>
        </trans-unit>
        <trans-unit id="f7c12226b9e0c0ca24fa6bdd6239b023bf8ef3a4" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;CString&lt;/code&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">仅应使用通过在 &lt;code&gt;CString&lt;/code&gt; 上调用&lt;a href=&quot;#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt;获得的指针来调用此方法。其他用法（例如，尝试获取由外来代码分配的字符串的所有权）可能导致未定义的行为或分配器损坏。</target>
        </trans-unit>
        <trans-unit id="bb13fd72f340b7885313dcc12025456f86beff96" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">仅应使用先前通过调用&lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt; &lt;code&gt;CString::into_raw&lt;/code&gt; &lt;/a&gt;获得的指针来调用此方法。其他用法（例如，尝试获取由外来代码分配的字符串的所有权）可能导致未定义的行为或分配器损坏。</target>
        </trans-unit>
        <trans-unit id="6de4781e84fd1ffb8326c915806ff4604cbf7406" translate="yes" xml:space="preserve">
          <source>This shows the source code file with the &lt;em&gt;.rs&lt;/em&gt; extension, the executable file (&lt;em&gt;main.exe&lt;/em&gt; on Windows, but &lt;em&gt;main&lt;/em&gt; on all other platforms), and, when using Windows, a file containing debugging information with the &lt;em&gt;.pdb&lt;/em&gt; extension. From here, you run the &lt;em&gt;main&lt;/em&gt; or &lt;em&gt;main.exe&lt;/em&gt; file, like this:</source>
          <target state="translated">这显示了带有&lt;em&gt;.rs&lt;/em&gt;扩展名的源代码文件，可执行文件（在Windows 上是&lt;em&gt;main.exe&lt;/em&gt;，在所有其他平台上是&lt;em&gt;main&lt;/em&gt;），以及在使用Windows时，包含一个带有&lt;em&gt;.pdb&lt;/em&gt;扩展名的调试信息的文件。在这里，运行&lt;em&gt;main&lt;/em&gt;或&lt;em&gt;main.exe&lt;/em&gt;文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="9575f8046ce99c60fbe347fdb162c3debc44c697" translate="yes" xml:space="preserve">
          <source>This slice has the type &lt;code&gt;&amp;amp;[i32]&lt;/code&gt;. It works the same way as string slices do, by storing a reference to the first element and a length. You&amp;rsquo;ll use this kind of slice for all sorts of other collections. We&amp;rsquo;ll discuss these collections in detail when we talk about vectors in Chapter 8.</source>
          <target state="translated">该切片的类型为 &lt;code&gt;&amp;amp;[i32]&lt;/code&gt; 。通过存储对第一个元素和长度的引用，它的工作方式与字符串切片相同。您将在所有其他集合中使用这种切片。在第8章中讨论向量时，我们将详细讨论这些集合。</target>
        </trans-unit>
        <trans-unit id="d65fb4bd24471a81f14e38e503058f70c64833b3" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">这种排序是稳定的（即，不对相等元素进行重新排序），并且在 &lt;code&gt;O(m * n * log(n))&lt;/code&gt; 最坏的情况下（键函数是 &lt;code&gt;O(m)&lt;/code&gt; )是最差的。</target>
        </trans-unit>
        <trans-unit id="b5c9c4b26823864ca42f73d970b5f61574652362" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">这种排序是稳定的（即，不对相等元素进行重新排序），并且在 &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; 最坏的情况下是稳定的，其中键函数是 &lt;code&gt;O(m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3fe498c20a11bda205dc93f4390f850884c310c" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n + n log n)&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">这种排序是稳定的（即，不对相等元素进行重新排序），并且在 &lt;code&gt;O(m n + n log n)&lt;/code&gt; 最坏的情况下（键函数为 &lt;code&gt;O(m)&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="04ff5f9e434224075f07c47221408f586ed69430" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">这种排序是稳定的（即，不对相等元素进行重新排序），并且在 &lt;code&gt;O(m n log(m n))&lt;/code&gt; 最坏的情况下，键函数是 &lt;code&gt;O(m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13defa388ad16a8832cba0851748fe2d9c59598b" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n * log(n))&lt;/code&gt; worst-case.</source>
          <target state="translated">这种排序是稳定的（即，不对相等元素进行重新排序），并且 &lt;code&gt;O(n * log(n))&lt;/code&gt; 最坏的情况。</target>
        </trans-unit>
        <trans-unit id="29bb618262e9818d4542507320a836e4faf4b56f" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">这种排序是稳定的（即，不会对相等的元素重新排序），并且 &lt;code&gt;O(n log n)&lt;/code&gt; 最坏的情况。</target>
        </trans-unit>
        <trans-unit id="342fc35a79498863eed086153ecf4de54d803470" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="translated">这种排序是稳定的（即，不对相等元素进行重新排序），并且在最坏的情况下&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; * log（&lt;em&gt;n&lt;/em&gt;））是关键函数是&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;m&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="b9e6ed2e7770cad1c08fcd52e4c75266e91bca66" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; + &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="translated">这种排序是稳定的（即，不对相等的元素重新排序），并且在最坏的情况下&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; + &lt;em&gt;n&lt;/em&gt; * log（&lt;em&gt;n&lt;/em&gt;））是关键函数为&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;m&lt;/em&gt;）的情况。</target>
        </trans-unit>
        <trans-unit id="b0fa553880d5f214b25277a39b204d8402684264" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="translated">这种排序是稳定的（即，不对相等的元素重新排序），并且是&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt; * log（&lt;em&gt;n&lt;/em&gt;））最坏的情况。</target>
        </trans-unit>
        <trans-unit id="f8094b9acbcdfe817a2beca8fbbfd03d36adf019" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">这种排序是不稳定的（即可能重新排序相等的元素），就地（即不分配）和 &lt;code&gt;O(m n log(m n))&lt;/code&gt; 最坏的情况，其中关键函数是 &lt;code&gt;O(m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e852a79da20e649bf213cb6826ee95c589ae984" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">这种排序是不稳定的（即可能重新排列相等的元素），就地（即不分配）和 &lt;code&gt;O(n log n)&lt;/code&gt; 最坏的情况。</target>
        </trans-unit>
        <trans-unit id="3d7156d28541cb0cabeaa7410dd06cdaa9199652" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="translated">这种排序是不稳定的（即可能重新排序相等的元素），就地（即不分配）和&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt; * log（&lt;em&gt;n&lt;/em&gt;））最坏的情况。</target>
        </trans-unit>
        <trans-unit id="b3e0c73c0881bd5d99646c6bd52683bfabd1a90e" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(m * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="translated">这种排序是不稳定的（即可能重新排序相等的元素），就地（即不分配）和&lt;em&gt;O&lt;/em&gt;（m * &lt;em&gt;n&lt;/em&gt; * log（&lt;em&gt;n&lt;/em&gt;））最坏的情况，其中键函数是&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;m&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="7b9136d07194a4e8e43750309da02e688255bd47" translate="yes" xml:space="preserve">
          <source>This sort of behavior has been known to &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;lead to privilege escalation&lt;/a&gt; when used incorrectly.</source>
          <target state="translated">如果使用不当，这种行为会&lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;导致特权升级&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4609a563600ff8952232a98685a394486b72fb56" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has been suspended, and typically corresponds to a &lt;code&gt;yield&lt;/code&gt; statement. The value provided in this variant corresponds to the expression passed to &lt;code&gt;yield&lt;/code&gt; and allows generators to provide a value each time they yield.</source>
          <target state="translated">此状态表明生成器已暂停，通常对应于 &lt;code&gt;yield&lt;/code&gt; 语句。此变量中提供的值与传递给 &lt;code&gt;yield&lt;/code&gt; 的表达式相对应，并允许生成器在每次生成时提供一个值。</target>
        </trans-unit>
        <trans-unit id="90c88a5ca708244c3219f050c7309e58bf365755" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has finished execution with the provided value. Once a generator has returned &lt;code&gt;Complete&lt;/code&gt; it is considered a programmer error to call &lt;code&gt;resume&lt;/code&gt; again.</source>
          <target state="translated">此状态表明生成器已使用提供的值完成了执行。生成器返回 &lt;code&gt;Complete&lt;/code&gt; ，再次调用 &lt;code&gt;resume&lt;/code&gt; 将被视为程序员错误。</target>
        </trans-unit>
        <trans-unit id="7be578f8354e75e786ae7f8a72194e570efdeae6" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;</source>
          <target state="translated">此流将被忽略。这等效于将流附加到 &lt;code&gt;/dev/null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86aaaf1ade8618d076dfddfcf43a493fbd9d9208" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;.</source>
          <target state="translated">此流将被忽略。这等效于将流附加到 &lt;code&gt;/dev/null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="047e86b07f343619951ab342d709e9864cc54c3d" translate="yes" xml:space="preserve">
          <source>This struct has one field, &lt;code&gt;part&lt;/code&gt;, that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of &lt;code&gt;ImportantExcerpt&lt;/code&gt; can&amp;rsquo;t outlive the reference it holds in its &lt;code&gt;part&lt;/code&gt; field.</source>
          <target state="translated">该结构具有一个字段 &lt;code&gt;part&lt;/code&gt; ，其中包含一个字符串切片，这是一个引用。与泛型数据类型一样，我们在结构名称之后的尖括号内声明泛型生命周期参数的名称，以便可以在结构定义的主体中使用生命周期参数。此注释表示 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 的实例不能超过其在 &lt;code&gt;part&lt;/code&gt; 字段中保存的引用的寿命。</target>
        </trans-unit>
        <trans-unit id="035a190c93ffcb98a162f4a1c124850fba76f70b" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该结构与 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 和 &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; 类的类型具有相同的布局。</target>
        </trans-unit>
        <trans-unit id="8bcde4812fcc7ef55a0760fedbc39c027f9accb6" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该结构与 &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; 和 &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; 类的类型具有相同的布局。</target>
        </trans-unit>
        <trans-unit id="78fc6455134464feceba11cc2db121b5a8d643b0" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt;&lt;code&gt;Vec::sort_by_key&lt;/code&gt;&lt;/a&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">该结构是与&lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt; &lt;code&gt;Vec::sort_by_key&lt;/code&gt; &lt;/a&gt;类的函数一起使用的辅助函数，可用于对键的一部分进行反向排序。</target>
        </trans-unit>
        <trans-unit id="698bb1f1506a6aa8b90b6f64dc7e32c0c5091a12" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;code&gt;Vec::sort_by_key&lt;/code&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">该结构是与 &lt;code&gt;Vec::sort_by_key&lt;/code&gt; 类的函数一起使用的辅助函数，可用于对键的一部分进行反向排序。</target>
        </trans-unit>
        <trans-unit id="84ced59217a045f0ae6136d2f9bd0162d392046f" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;env::args()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个结构是由&lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;env::args()&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="421112f55866033bf937c2c2104c004765f83d6c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;env::args_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个结构是由&lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;env::args_os()&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="6d98990c007f08843ac1df1a07fad048ba02e034" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_args&quot;&gt;&lt;code&gt;Command::get_args&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构由&lt;a href=&quot;struct.command#method.get_args&quot;&gt; &lt;code&gt;Command::get_args&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c34405b53d7303b0dec8e54e6aa5a0abefbaa23c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_envs&quot;&gt;&lt;code&gt;Command::get_envs&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构由&lt;a href=&quot;struct.command#method.get_envs&quot;&gt; &lt;code&gt;Command::get_envs&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2147718c894a448fcb5bace3573d8c66021b6ecf" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt;&lt;code&gt;Vec::drain_filter&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个结构是由&lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt; &lt;code&gt;Vec::drain_filter&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="3b56bd91b0140c9f3d261bb2e7de1a84ee87136c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;Vec::splice()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个结构是由&lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;Vec::splice()&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="3b94fdb25d3a1999fbb00df483466c3f3ad93974" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;（通过所提供的&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;性状）。</target>
        </trans-unit>
        <trans-unit id="0f993739b1a6e12d97f61853ab3a7aeead8ab4b9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks&quot;&gt;&lt;code&gt;array_chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.array_chunks&quot;&gt; &lt;code&gt;array_chunks&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="306d58f57f3d10dc00f2031814b48c48929d8df3" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks_mut&quot;&gt;&lt;code&gt;array_chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.array_chunks_mut&quot;&gt; &lt;code&gt;array_chunks_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f3c9f948ac0eb252b070770390b8ad86aa3b895" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_windows&quot;&gt;&lt;code&gt;array_windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.array_windows&quot;&gt; &lt;code&gt;array_windows&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1dd8330957d499a2a2bc9ec6116864588108859d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;上的&lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="4f546acf131aa1e22a602b9ef3fb82d4387eee8e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e45db796c91b4ce48eb20085844caa57f6053703" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4164f449a467d7ed1b48f5a88a1f8a74fb26a190" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt;&lt;code&gt;chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt; &lt;code&gt;chunks_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76b48770dc5ec192ca6962e1d7faa3bd68e942ab" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上的&lt;a href=&quot;../primitive.slice#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="7681a887be4ac8a42d7f0ef28706aee3c6323619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="523facc9e10029a951175d54b1f37f2671749ed6" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt;&lt;code&gt;rchunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt; &lt;code&gt;rchunks&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建的。</target>
        </trans-unit>
        <trans-unit id="7743c6e4ca6fc913a9f4d37b6de12a320056fa8b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt;&lt;code&gt;rchunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt; &lt;code&gt;rchunks_exact&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建。</target>
        </trans-unit>
        <trans-unit id="82404af50a38a848751818c48976a9a56b795818" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt;&lt;code&gt;rchunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt; &lt;code&gt;rchunks_exact_mut&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建。</target>
        </trans-unit>
        <trans-unit id="711c0f689f1d3a75f7b5a1b1833bc925f8986127" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt;&lt;code&gt;rchunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt; &lt;code&gt;rchunks_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ffea197c31595a869becf274e9c9ef3509b405a" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a28e12c215b6246a69d2f856da858d720de99619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt;&lt;code&gt;rsplit_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt; &lt;code&gt;rsplit_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1ddb16a3352ab0f837d4fac934c98e22db158e5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建的。</target>
        </trans-unit>
        <trans-unit id="2305be064f2e36144fd442bf726fd4dd5a160216" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt;&lt;code&gt;rsplitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构由&lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt; &lt;code&gt;rsplitn_mut&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;上创建。</target>
        </trans-unit>
        <trans-unit id="9d2c4405dee882e98a94c3681ae8ce615cfcc3f7" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;的&lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="abdc8d3421db5241b7ca4544a7b51d6159d67e49" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt;&lt;code&gt;split_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">此结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;的&lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt; &lt;code&gt;split_mut&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="b850789ebec6b616db674ca7582ef014921e3e50" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;的&lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;splitn&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="fcbac1aabe82a2c466b31106e57bd4691b6a4588" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt;&lt;code&gt;splitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">这个结构是由创建&lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt; &lt;code&gt;splitn_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4faa0b9911c89c4588e753ca1891a11cb9aac5c2" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt;方法在&lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;上创建的。</target>
        </trans-unit>
        <trans-unit id="972c0f2531dd3e046ad902a7f6f569ef9de9571e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="9dc716c653425077e3bf50725d3ddc775e25fe94" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构由&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt; &lt;code&gt;char_indices&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="607ded9325aedcb5c140c227e32c8ad28d5439d9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="eb31472d0cae7541e173fe527a7087a142820c04" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt;&lt;code&gt;encode_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt; &lt;code&gt;encode_utf16&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e7c273a10bb61ef5da70d27b34dc57f12929254d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt;&lt;code&gt;split_ascii_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt; &lt;code&gt;split_ascii_whitespace&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e335f4d066241eacb01d34cbc9797fdfc696dc6b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f9cd50ffb5bf76be59d59fc2f81ddf738ff0464b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;std::env::args&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该结构是由&lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;std::env::args&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0ec39f7b0daa2776e166f7fac0653e5c7c5e4333" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;std::env::args_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该结构是由&lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;std::env::args_os&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d49df01529faa1803ee9ac5934efa956bfb59ca5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.string#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.string#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7821d89ece3dc45805333802521c4ece28a6ec77" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="df074a53b5359b4dd926d5ab8c21cb3fdb8391e4" translate="yes" xml:space="preserve">
          <source>This struct is created with the &lt;a href=&quot;../primitive.str#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该结构是通过&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.str#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="5a1492f5f04561e29bfe6f623f2dc30782a50bbf" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">通常通过调用&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt;创建此结构。请参阅&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt;的文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="8df7525ac9b1331bb51b51ca2c5df8a11c0a1c0e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">通常通过调用&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt;创建此结构。请参阅&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt;的文档以获取更多详细信息。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
