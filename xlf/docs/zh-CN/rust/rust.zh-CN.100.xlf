<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="800e827a6bd80027fcc168148b39b2bc4798dafa" translate="yes" xml:space="preserve">
          <source>TakeWhile::partial_cmp</source>
          <target state="translated">TakeWhile::partial_cmp</target>
        </trans-unit>
        <trans-unit id="756f2fd59afc727df9fab561f13734ed10cc1035" translate="yes" xml:space="preserve">
          <source>TakeWhile::partition</source>
          <target state="translated">TakeWhile::partition</target>
        </trans-unit>
        <trans-unit id="b3708fa6ef243ab03b8f0e01148054537baba7c2" translate="yes" xml:space="preserve">
          <source>TakeWhile::peekable</source>
          <target state="translated">TakeWhile::peekable</target>
        </trans-unit>
        <trans-unit id="3ddf00384fd53b19d286b7ce9f31e5c8e130add2" translate="yes" xml:space="preserve">
          <source>TakeWhile::position</source>
          <target state="translated">TakeWhile::position</target>
        </trans-unit>
        <trans-unit id="103103944a1d96c94fd7efea8dc3417e1dcec47e" translate="yes" xml:space="preserve">
          <source>TakeWhile::product</source>
          <target state="translated">TakeWhile::product</target>
        </trans-unit>
        <trans-unit id="9db7de0140db3938f59bf212e7c6b8c4ab1a5b22" translate="yes" xml:space="preserve">
          <source>TakeWhile::rev</source>
          <target state="translated">TakeWhile::rev</target>
        </trans-unit>
        <trans-unit id="aa7afa9cbae96b3a55ad383eb829e62995e9d3b0" translate="yes" xml:space="preserve">
          <source>TakeWhile::rposition</source>
          <target state="translated">TakeWhile::rposition</target>
        </trans-unit>
        <trans-unit id="aad375a583a0085240c857eb42a8dfb87e2e4e1c" translate="yes" xml:space="preserve">
          <source>TakeWhile::scan</source>
          <target state="translated">TakeWhile::scan</target>
        </trans-unit>
        <trans-unit id="cd86cfe53884486177c23f0ff823be46500dc9e1" translate="yes" xml:space="preserve">
          <source>TakeWhile::size_hint</source>
          <target state="translated">TakeWhile::size_hint</target>
        </trans-unit>
        <trans-unit id="5e176c9b3bf37b02aef10f7907a61a6ac9a47da8" translate="yes" xml:space="preserve">
          <source>TakeWhile::skip</source>
          <target state="translated">TakeWhile::skip</target>
        </trans-unit>
        <trans-unit id="64e54491abe005b30c8d866999d58ab787b271b2" translate="yes" xml:space="preserve">
          <source>TakeWhile::skip_while</source>
          <target state="translated">TakeWhile::skip_while</target>
        </trans-unit>
        <trans-unit id="ba9f9f10db1b73ab0c564edb9c28453e72ee8d7c" translate="yes" xml:space="preserve">
          <source>TakeWhile::step_by</source>
          <target state="translated">TakeWhile::step_by</target>
        </trans-unit>
        <trans-unit id="9d9273a97581b55606d39ff31ae4fc4bd97d0343" translate="yes" xml:space="preserve">
          <source>TakeWhile::sum</source>
          <target state="translated">TakeWhile::sum</target>
        </trans-unit>
        <trans-unit id="c679b6dec55380d66c68043added100d9b1e3e12" translate="yes" xml:space="preserve">
          <source>TakeWhile::take</source>
          <target state="translated">TakeWhile::take</target>
        </trans-unit>
        <trans-unit id="98bc022ab936f48f4c132862157a433b58b1ed1d" translate="yes" xml:space="preserve">
          <source>TakeWhile::take_while</source>
          <target state="translated">TakeWhile::take_while</target>
        </trans-unit>
        <trans-unit id="b57cfb71237e7ec5ab624251b87030d240a46226" translate="yes" xml:space="preserve">
          <source>TakeWhile::to_owned</source>
          <target state="translated">TakeWhile::to_owned</target>
        </trans-unit>
        <trans-unit id="37e399f48eff7903115e7d86661abdf8e05fd4b1" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_fold</source>
          <target state="translated">TakeWhile::try_fold</target>
        </trans-unit>
        <trans-unit id="759bc51854e6a28a5380a5f6b7a415cd0f555f0f" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_for_each</source>
          <target state="translated">TakeWhile::try_for_each</target>
        </trans-unit>
        <trans-unit id="7fb911b85cc860ff38f3b721f59503e01735b148" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_from</source>
          <target state="translated">TakeWhile::try_from</target>
        </trans-unit>
        <trans-unit id="5de7c55a9b68a872ef23f0276b88d1c9ecf0fc8a" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_into</source>
          <target state="translated">TakeWhile::try_into</target>
        </trans-unit>
        <trans-unit id="87c136784211d463521272370803a4f358f45d54" translate="yes" xml:space="preserve">
          <source>TakeWhile::type_id</source>
          <target state="translated">TakeWhile::type_id</target>
        </trans-unit>
        <trans-unit id="2c32f5c719493f4a777e4c32b66c95f758c27273" translate="yes" xml:space="preserve">
          <source>TakeWhile::unzip</source>
          <target state="translated">TakeWhile::unzip</target>
        </trans-unit>
        <trans-unit id="d4376e438d96018f64f5876aa47fe4d14ae53315" translate="yes" xml:space="preserve">
          <source>TakeWhile::zip</source>
          <target state="translated">TakeWhile::zip</target>
        </trans-unit>
        <trans-unit id="686ef3911209faeb469101adcbd7e6e7d810ef4c" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;*O*(min(k, len() - k))&lt;/code&gt; time and no extra space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ef4edffae6c9317836493dc9e695ad35618a15" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;*O*(min(mid, len() - mid))&lt;/code&gt; time and no extra space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a3fbbd6670f1404e88f845d8e70bb6e1310ad2" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;O(min(k, len() - k))&lt;/code&gt; time and no extra space.</source>
          <target state="translated">占用 &lt;code&gt;O(min(k, len() - k))&lt;/code&gt; 时间并且没有多余空间。</target>
        </trans-unit>
        <trans-unit id="2675fff809feea07b6b8e81b85ffeea6cb2ff42a" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;O(min(mid, len() - mid))&lt;/code&gt; time and no extra space.</source>
          <target state="translated">占用 &lt;code&gt;O(min(mid, len() - mid))&lt;/code&gt; 时间，没有多余的空间。</target>
        </trans-unit>
        <trans-unit id="cd9e4e1ce47cfbb22bdd9618d61401a9a4bbe1ab" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element.</source>
          <target state="translated">取一个闭包并创建一个迭代器,该迭代器在每个元素上调用该闭包。</target>
        </trans-unit>
        <trans-unit id="9d3b7aa7666b1bb97d700268dbfed96edd954290" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../../../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">采用闭包并创建一个迭代器，该迭代器在每个元素上调用该闭包。&lt;a href=&quot;../../../iter/trait.iterator#method.map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15197bb083d7273e4a694b7c5e032b5e1c0781f3" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">采用闭包并创建一个迭代器，该迭代器在每个元素上调用该闭包。&lt;a href=&quot;../../iter/trait.iterator#method.map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4434c8dd599ef23b0c9ba44e32c1fa55b943ae82" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">采用闭包并创建一个迭代器，该迭代器在每个元素上调用该闭包。&lt;a href=&quot;../iter/trait.iterator#method.map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6257eea37e0de73bcadd8777f056a323db82c336" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">采用闭包并创建一个迭代器，该迭代器在每个元素上调用该闭包。&lt;a href=&quot;iter/trait.iterator#method.map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1ad1d9466847f0b48f38483a158304137e697a6" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">采用闭包并创建一个迭代器，该迭代器在每个元素上调用该闭包。&lt;a href=&quot;trait.iterator#method.map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b67dad0714b16a4867cfc86c2882827f4a196a85" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">接受&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;中的每个元素：如果为&lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则不获取其他元素，并返回&lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果没有&lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;发生，则返回包含每个&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;值的容器。</target>
        </trans-unit>
        <trans-unit id="c0d108a90f72b979216289a1535302bae686a314" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae2387e48cfe171ba07e4b4b0225bc9c8162619" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc47bd052a8b6d5124696117910cb85d1a433ca" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa16ae10062698ed9b295ae08170d14623d7392d" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b254b78336a4f1d88a19a88b9cd87eebc4af74" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e929c2f84b980189b0ca395f9fd1ebf18d6a9b2" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">接受&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;中的每个元素：如果为&lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则不获取其他元素，并返回&lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果没有&lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;发生，则返回包含每个&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;值的容器。</target>
        </trans-unit>
        <trans-unit id="70a9e6b588aac0e816346721c7b37888db944102" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7590beabf441bb63691e8eea48b72c9c8f6a403" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc7f913ad909dfc000ef9eb96b0c827728188e0" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1c7f91156f7afd567ca4e08a2abfd735e16c17" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ccdebe9d4ccf3b0664327970602a14b42c1657" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39228003dfd9a65d31657d9ccd88aa95394f718" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt; and collects it into an &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80659447eb965dd52f894d84ba633d8bce5db96" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt; and collects it into an &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217627f67f88406b5f9f17a93f1493e04a1a8227" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is a &lt;code&gt;None&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;None&lt;/code&gt; is returned. Should no &lt;code&gt;None&lt;/code&gt; occur, the product of all elements is returned.</source>
          <target state="translated">接受 &lt;code&gt;Iterator&lt;/code&gt; 中的每个元素：如果它为 &lt;code&gt;None&lt;/code&gt; ，则不采用其他元素，并返回 &lt;code&gt;None&lt;/code&gt; 。如果没有 &lt;code&gt;None&lt;/code&gt; 发生，则返回所有元素的乘积。</target>
        </trans-unit>
        <trans-unit id="e4aa0fd801953cd40a086ec1d2ff51bb44eb736e" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is a &lt;code&gt;None&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;None&lt;/code&gt; is returned. Should no &lt;code&gt;None&lt;/code&gt; occur, the sum of all elements is returned.</source>
          <target state="translated">接受 &lt;code&gt;Iterator&lt;/code&gt; 中的每个元素：如果它为 &lt;code&gt;None&lt;/code&gt; ，则不采用其他元素，并返回 &lt;code&gt;None&lt;/code&gt; 。如果没有 &lt;code&gt;None&lt;/code&gt; 发生，则返回所有元素的总和。</target>
        </trans-unit>
        <trans-unit id="c1fb0a7041f8cb3602712be575a96b71a9c34edb" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, a container with the values of each &lt;code&gt;Result&lt;/code&gt; is returned.</source>
          <target state="translated">接受 &lt;code&gt;Iterator&lt;/code&gt; 中的每个元素：如果它是 &lt;code&gt;Err&lt;/code&gt; ，则不再获取其他元素，并返回 &lt;code&gt;Err&lt;/code&gt; 。如果没有发生 &lt;code&gt;Err&lt;/code&gt; ，则返回包含每个 &lt;code&gt;Result&lt;/code&gt; 值的容器。</target>
        </trans-unit>
        <trans-unit id="42c26fa2ecac3de7729494a9359458db2460cecc" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, the product of all elements is returned.</source>
          <target state="translated">接受 &lt;code&gt;Iterator&lt;/code&gt; 中的每个元素：如果它是 &lt;code&gt;Err&lt;/code&gt; ，则不再获取其他元素，并返回 &lt;code&gt;Err&lt;/code&gt; 。如果没有发生 &lt;code&gt;Err&lt;/code&gt; ，则返回所有元素的乘积。</target>
        </trans-unit>
        <trans-unit id="c82330496098a00243d3f411105f0f70776be883" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, the sum of all elements is returned.</source>
          <target state="translated">接受 &lt;code&gt;Iterator&lt;/code&gt; 中的每个元素：如果它是 &lt;code&gt;Err&lt;/code&gt; ，则不再获取其他元素，并返回 &lt;code&gt;Err&lt;/code&gt; 。如果没有发生 &lt;code&gt;Err&lt;/code&gt; ，则返回所有元素的总和。</target>
        </trans-unit>
        <trans-unit id="01d5fda76710ca0641abcbb3e4cbb1bb6e17f736" translate="yes" xml:space="preserve">
          <source>Takes each element, adds them together, and returns the result.</source>
          <target state="translated">将每个元素加在一起,然后返回结果。</target>
        </trans-unit>
        <trans-unit id="6776e27751852b377b68c46a8017d15dd715c595" translate="yes" xml:space="preserve">
          <source>Takes linear (in &lt;code&gt;self.len()&lt;/code&gt;) time.</source>
          <target state="translated">采取线性（在 &lt;code&gt;self.len()&lt;/code&gt; 中）时间。</target>
        </trans-unit>
        <trans-unit id="fdca1895a18c3a298f6533b4c2e334951c66b62c" translate="yes" xml:space="preserve">
          <source>Takes ownership and &quot;forgets&quot; about the value &lt;strong&gt;without running its destructor&lt;/strong&gt;.</source>
          <target state="translated">在&lt;strong&gt;不运行其析构函数的情况下&lt;/strong&gt;获取所有权并&amp;ldquo;忘记&amp;rdquo;该值。</target>
        </trans-unit>
        <trans-unit id="b8fa769819072fbe610e5e9c85934d3a05171939" translate="yes" xml:space="preserve">
          <source>Takes the contained value out.</source>
          <target state="translated">将包含的值取出。</target>
        </trans-unit>
        <trans-unit id="4aec823974aa072f464dcb5cc764f9240e0f60dd" translate="yes" xml:space="preserve">
          <source>Takes the cubic root of a number.</source>
          <target state="translated">取一个数字的立方根。</target>
        </trans-unit>
        <trans-unit id="f045194d706e7e41fabb862c8032ea26f5f950f2" translate="yes" xml:space="preserve">
          <source>Takes the reciprocal (inverse) of a number, &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">取数字的倒数（倒数） &lt;code&gt;1/x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a48b57259f94b360feec04d91e3f646f9cba125" translate="yes" xml:space="preserve">
          <source>Takes the square root of a number.</source>
          <target state="translated">取一个数字的平方根。</target>
        </trans-unit>
        <trans-unit id="29583c6b4f13f8e1828da3f713db57dac29990e1" translate="yes" xml:space="preserve">
          <source>Takes the value from the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; container out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc799efc0b882851473c22ca2ca5ccf94ddabfe1" translate="yes" xml:space="preserve">
          <source>Takes the value of the cell, leaving &lt;code&gt;Default::default()&lt;/code&gt; in its place.</source>
          <target state="translated">获取单元格的值，并在其位置保留 &lt;code&gt;Default::default()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21859ca86840d9216ef1aca0008b5877f29f5e68" translate="yes" xml:space="preserve">
          <source>Takes the value of the entry out of the map, and returns it.</source>
          <target state="translated">将条目的值从地图中取出,并返回。</target>
        </trans-unit>
        <trans-unit id="e353877ad2ec8473ab467885d9861796b98bdada" translate="yes" xml:space="preserve">
          <source>Takes the value out of the entry, and returns it.</source>
          <target state="translated">从条目中取出数值,然后返回。</target>
        </trans-unit>
        <trans-unit id="761daab64ee172552a57dae50c6f8a92c4d9c366" translate="yes" xml:space="preserve">
          <source>Takes the value out of the option, leaving a &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in its place.</source>
          <target state="translated">从选项中取出值，并在其位置保留&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7c52a2ee2d265275374b5c1f093b7a06a9428c4" translate="yes" xml:space="preserve">
          <source>Takes the value out of the option, leaving a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba923f497880c808c6be64ea728bee38b782b657" translate="yes" xml:space="preserve">
          <source>Takes the wrapped value, leaving &lt;code&gt;Default::default()&lt;/code&gt; in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f95b9cdf9802bc6e9feca2c7b307fe24034be8d" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence.</source>
          <target state="translated">取两个迭代器,并在两个迭代器上依次创建一个新的迭代器。</target>
        </trans-unit>
        <trans-unit id="787908ffef98464dc332707d755e2c4f129a3015" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../../../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">接受两个迭代器，并依次在两个迭代器上创建一个新的迭代器。&lt;a href=&quot;../../../iter/trait.iterator#method.chain&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96c4c94db35b0a5de2fc876c74307d69f4d1f941" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">接受两个迭代器，并依次在两个迭代器上创建一个新的迭代器。&lt;a href=&quot;../../iter/trait.iterator#method.chain&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09c1398fa07d7872f8f96945eceb77ea195aaf9f" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">接受两个迭代器，并依次在两个迭代器上创建一个新的迭代器。&lt;a href=&quot;../iter/trait.iterator#method.chain&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e8033a8a0d88d9c00564885e5bd3facaba3011b" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">接受两个迭代器，并依次在两个迭代器上创建一个新的迭代器。&lt;a href=&quot;iter/trait.iterator#method.chain&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="772b77fdfc8e9968126bb233f7891ef8441c5352" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">接受两个迭代器，并依次在两个迭代器上创建一个新的迭代器。&lt;a href=&quot;trait.iterator#method.chain&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e48610b94d0c8b865914c76042a0dd63c8ace3fb" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">以&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;作为参数：</target>
        </trans-unit>
        <trans-unit id="4f62d9e379567856d558f8df128e53e7eeda59a9" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">以&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;作为参数：</target>
        </trans-unit>
        <trans-unit id="acf17a2c9691dbabd08f8be26e62792363680f2f" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">以&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;作为参数：</target>
        </trans-unit>
        <trans-unit id="9b593af3c7f2108f31456b5ab2cb3574e71f3b6e" translate="yes" xml:space="preserve">
          <source>Taking ownership and then returning ownership with every function is a bit tedious. What if we want to let a function use a value but not take ownership? It&amp;rsquo;s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.</source>
          <target state="translated">拥有所有权然后返回所有功能的所有权有点乏味。如果我们想让函数使用值而不是所有权，该怎么办？令人非常烦恼的是，除了我们可能还想返回的函数主体所产生的任何数据之外，如果我们想要再次使用它，还需要将返回的信息传递回去。</target>
        </trans-unit>
        <trans-unit id="4aa5a6c5b61f9a1ca73ba483f7a4a44ead615a2c" translate="yes" xml:space="preserve">
          <source>Targets which do not support switching between linkage of the C runtime will ignore this flag. It's recommended to inspect the resulting binary to ensure that it's linked as you would expect after the compiler succeeds.</source>
          <target state="translated">不支持在C运行时的链接之间切换的目标将忽略这个标志。建议检查所产生的二进制文件,以确保在编译成功后,它是按照你所期望的方式链接的。</target>
        </trans-unit>
        <trans-unit id="9ad8024a2c7b1265fb5e22250fc7a31283cdbd36" translate="yes" xml:space="preserve">
          <source>TcpListener</source>
          <target state="translated">TcpListener</target>
        </trans-unit>
        <trans-unit id="ece7cdbc23c076f1d64f752343ef7aec8eec539f" translate="yes" xml:space="preserve">
          <source>TcpListener::accept</source>
          <target state="translated">TcpListener::accept</target>
        </trans-unit>
        <trans-unit id="a2a291bb7ab19718d31f7478d18104e4158a939c" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_fd</source>
          <target state="translated">TcpListener::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="49f5fe2427c190a7f8a472e06e6d569a7ff427c4" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_socket</source>
          <target state="translated">TcpListener::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="2e2338f796fa51dd367f2f2c91e316fe98afe3a0" translate="yes" xml:space="preserve">
          <source>TcpListener::bind</source>
          <target state="translated">TcpListener::bind</target>
        </trans-unit>
        <trans-unit id="bc75d22ad0ef01f38f6f564c0448b514f01f2b1e" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow</source>
          <target state="translated">TcpListener::borrow</target>
        </trans-unit>
        <trans-unit id="b7bf89d05dc43863ce7b237f1c9339841b44d828" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow_mut</source>
          <target state="translated">TcpListener::borrow_mut</target>
        </trans-unit>
        <trans-unit id="67148bab8cc6c3ad3159fa098deca2df5084c5bc" translate="yes" xml:space="preserve">
          <source>TcpListener::fmt</source>
          <target state="translated">TcpListener::fmt</target>
        </trans-unit>
        <trans-unit id="e2222d5e97ec906a2d58760a4b094c72e792239f" translate="yes" xml:space="preserve">
          <source>TcpListener::from</source>
          <target state="translated">TcpListener::from</target>
        </trans-unit>
        <trans-unit id="965dc7a632243e984a2b9e894788c6c21d7eb5d8" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_fd</source>
          <target state="translated">TcpListener::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="482dc849c70cec776e4f8a473271ccf0cb6cf277" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_socket</source>
          <target state="translated">TcpListener::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="1934b5e7d2fb2d8224b23b4ad0d2399a5cb3b873" translate="yes" xml:space="preserve">
          <source>TcpListener::incoming</source>
          <target state="translated">TcpListener::incoming</target>
        </trans-unit>
        <trans-unit id="428c642a4eaf5906beb8fe4edf0ac026bb70054c" translate="yes" xml:space="preserve">
          <source>TcpListener::into</source>
          <target state="translated">TcpListener::into</target>
        </trans-unit>
        <trans-unit id="ecf165a93c2c3a51f657446508db4792cbb31eef" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_fd</source>
          <target state="translated">TcpListener::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="171dba66a0881e83fbf754117718cae198277962" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_socket</source>
          <target state="translated">TcpListener::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2275a3d2aa672ca4311b697b11d81ca54319cd4f" translate="yes" xml:space="preserve">
          <source>TcpListener::local_addr</source>
          <target state="translated">TcpListener::local_addr</target>
        </trans-unit>
        <trans-unit id="ec11714ec8bf6a942994646bb7ec40f6ec987004" translate="yes" xml:space="preserve">
          <source>TcpListener::only_v6</source>
          <target state="translated">TcpListener::only_v6</target>
        </trans-unit>
        <trans-unit id="8f9762884937dfa70d1e7429478f09a0cb47d310" translate="yes" xml:space="preserve">
          <source>TcpListener::set_nonblocking</source>
          <target state="translated">TcpListener::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="226f648e250e40bcc471fd5a673bff010846e472" translate="yes" xml:space="preserve">
          <source>TcpListener::set_only_v6</source>
          <target state="translated">TcpListener::set_only_v6</target>
        </trans-unit>
        <trans-unit id="4715bf3aa73135001a12ace3fe29f1f7e2fa4701" translate="yes" xml:space="preserve">
          <source>TcpListener::set_ttl</source>
          <target state="translated">TcpListener::set_ttl</target>
        </trans-unit>
        <trans-unit id="52dd134154d36dce171d232dad1f997d4a86ef76" translate="yes" xml:space="preserve">
          <source>TcpListener::take_error</source>
          <target state="translated">TcpListener::take_error</target>
        </trans-unit>
        <trans-unit id="346a3319242ccfb5f2d382bc3687dc41f26c3692" translate="yes" xml:space="preserve">
          <source>TcpListener::try_clone</source>
          <target state="translated">TcpListener::try_clone</target>
        </trans-unit>
        <trans-unit id="8774def23dc815607fb5f6d621a655e6351d76ed" translate="yes" xml:space="preserve">
          <source>TcpListener::try_from</source>
          <target state="translated">TcpListener::try_from</target>
        </trans-unit>
        <trans-unit id="4d964782d52d7cadd1d535988a4c17142f01c956" translate="yes" xml:space="preserve">
          <source>TcpListener::try_into</source>
          <target state="translated">TcpListener::try_into</target>
        </trans-unit>
        <trans-unit id="720c95f141c0826fd5fca57448ce533672b87275" translate="yes" xml:space="preserve">
          <source>TcpListener::ttl</source>
          <target state="translated">TcpListener::ttl</target>
        </trans-unit>
        <trans-unit id="8b5ab82dcc35d3a2cd49204d3a4a7a3449b42f85" translate="yes" xml:space="preserve">
          <source>TcpListener::type_id</source>
          <target state="translated">TcpListener::type_id</target>
        </trans-unit>
        <trans-unit id="35342d32149945519f7e31daff4e30855fbeba49" translate="yes" xml:space="preserve">
          <source>TcpStream</source>
          <target state="translated">TcpStream</target>
        </trans-unit>
        <trans-unit id="9eafc6b129d5efa5c4b0a83e50a95e30344816f3" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_fd</source>
          <target state="translated">TcpStream::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="09ec2aef24015b31ab23113ac683d2f8346c1f39" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_socket</source>
          <target state="translated">TcpStream::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="12e762e3cfe2aa9d71a2a757abb3507e964d1881" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow</source>
          <target state="translated">TcpStream::borrow</target>
        </trans-unit>
        <trans-unit id="d91a58f6ef21ac04bf7fb8b19bbc87b6dbe9fb4c" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow_mut</source>
          <target state="translated">TcpStream::borrow_mut</target>
        </trans-unit>
        <trans-unit id="11f8dcda0e1ccab974f38cf496de4e39b14b25cb" translate="yes" xml:space="preserve">
          <source>TcpStream::by_ref</source>
          <target state="translated">TcpStream::by_ref</target>
        </trans-unit>
        <trans-unit id="bfbef109c2e4f33f2aedd0c714f14f49404d152c" translate="yes" xml:space="preserve">
          <source>TcpStream::bytes</source>
          <target state="translated">TcpStream::bytes</target>
        </trans-unit>
        <trans-unit id="e1fe899d60189a16135ede51a667e0fdef40fd00" translate="yes" xml:space="preserve">
          <source>TcpStream::chain</source>
          <target state="translated">TcpStream::chain</target>
        </trans-unit>
        <trans-unit id="9b075e5500b6c35efe89a7d4bf0762c653e6221c" translate="yes" xml:space="preserve">
          <source>TcpStream::connect</source>
          <target state="translated">TcpStream::connect</target>
        </trans-unit>
        <trans-unit id="7c9bc4cc7e00f6a9f012c5c2f74296bd08fb3cd9" translate="yes" xml:space="preserve">
          <source>TcpStream::connect_timeout</source>
          <target state="translated">TcpStream::connect_timeout</target>
        </trans-unit>
        <trans-unit id="7e82ba30a964300fd5401b21bdde38ef8892a264" translate="yes" xml:space="preserve">
          <source>TcpStream::flush</source>
          <target state="translated">TcpStream::flush</target>
        </trans-unit>
        <trans-unit id="5e2f83b6ef3a2fd9f5722070fe250aef910cb0f5" translate="yes" xml:space="preserve">
          <source>TcpStream::fmt</source>
          <target state="translated">TcpStream::fmt</target>
        </trans-unit>
        <trans-unit id="3a3304a1471ecd9e54075022592709e4164425d3" translate="yes" xml:space="preserve">
          <source>TcpStream::from</source>
          <target state="translated">TcpStream::from</target>
        </trans-unit>
        <trans-unit id="0c544151d800149c130a2b4e5fa0242d2c6c5fe2" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_fd</source>
          <target state="translated">TcpStream::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="f33ab52a5f61c4e532d24e2b9d448a864ab588ef" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_socket</source>
          <target state="translated">TcpStream::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="ac8cf31a8273795291384f9b9a189065f0e4ddda" translate="yes" xml:space="preserve">
          <source>TcpStream::initializer</source>
          <target state="translated">TcpStream::initializer</target>
        </trans-unit>
        <trans-unit id="bb02adb8fb5756c502d5d11c517f31b37848f5b3" translate="yes" xml:space="preserve">
          <source>TcpStream::into</source>
          <target state="translated">TcpStream::into</target>
        </trans-unit>
        <trans-unit id="8b62d5f9b1506a6417ce6b1e7abc2fe81f1a512b" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_fd</source>
          <target state="translated">TcpStream::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="2d62e49030fac395488f03a44bc65385d791c4a1" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_socket</source>
          <target state="translated">TcpStream::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2f15c295f6cbee27e4704ba77400c3f9cdb74347" translate="yes" xml:space="preserve">
          <source>TcpStream::local_addr</source>
          <target state="translated">TcpStream::local_addr</target>
        </trans-unit>
        <trans-unit id="3e41769cd3c7bc5fe0ffd071decfac8538fce3c8" translate="yes" xml:space="preserve">
          <source>TcpStream::nodelay</source>
          <target state="translated">TcpStream::nodelay</target>
        </trans-unit>
        <trans-unit id="b1c4ef3a856c377290ba0effe22fa456b4c5d618" translate="yes" xml:space="preserve">
          <source>TcpStream::peek</source>
          <target state="translated">TcpStream::peek</target>
        </trans-unit>
        <trans-unit id="02b5be94fe4bd3a77f45294ce309a022defb0142" translate="yes" xml:space="preserve">
          <source>TcpStream::peer_addr</source>
          <target state="translated">TcpStream::peer_addr</target>
        </trans-unit>
        <trans-unit id="168308bcf15754b94b3cd0ff91dc84d727c89085" translate="yes" xml:space="preserve">
          <source>TcpStream::read</source>
          <target state="translated">TcpStream::read</target>
        </trans-unit>
        <trans-unit id="a51f803ec2bc3d6b94f3630947f31e7b2bee3ed5" translate="yes" xml:space="preserve">
          <source>TcpStream::read_exact</source>
          <target state="translated">TcpStream::read_exact</target>
        </trans-unit>
        <trans-unit id="cddced3b85b2ead651c93e97a2f622b9f49035db" translate="yes" xml:space="preserve">
          <source>TcpStream::read_timeout</source>
          <target state="translated">TcpStream::read_timeout</target>
        </trans-unit>
        <trans-unit id="1957796c8b2bd9a577cc9018f30d0a2d1c2fe241" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_end</source>
          <target state="translated">TcpStream::read_to_end</target>
        </trans-unit>
        <trans-unit id="9f494c5d56be921420520740cf0cbafa75a20b7b" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_string</source>
          <target state="translated">TcpStream::read_to_string</target>
        </trans-unit>
        <trans-unit id="c6fa288859680339e04670a33f1a14f57af1e652" translate="yes" xml:space="preserve">
          <source>TcpStream::read_vectored</source>
          <target state="translated">TcpStream::read_vectored</target>
        </trans-unit>
        <trans-unit id="e83138e7f219d526516674b5550a795c09cf97fa" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nodelay</source>
          <target state="translated">TcpStream::set_nodelay</target>
        </trans-unit>
        <trans-unit id="6f3db10df76b321eadb9c9c65b440fd1e62d4157" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nonblocking</source>
          <target state="translated">TcpStream::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="0ef1754192987fd2a71c4d09d1363328c40af9e8" translate="yes" xml:space="preserve">
          <source>TcpStream::set_read_timeout</source>
          <target state="translated">TcpStream::set_read_timeout</target>
        </trans-unit>
        <trans-unit id="1c0d37734b35b5aaae88202ef8744780ebadf163" translate="yes" xml:space="preserve">
          <source>TcpStream::set_ttl</source>
          <target state="translated">TcpStream::set_ttl</target>
        </trans-unit>
        <trans-unit id="cf06a99e15825f5af0170343a971d82291a1bb70" translate="yes" xml:space="preserve">
          <source>TcpStream::set_write_timeout</source>
          <target state="translated">TcpStream::set_write_timeout</target>
        </trans-unit>
        <trans-unit id="de9f03e4aaf65b0dacf8a1a510098378140fbad7" translate="yes" xml:space="preserve">
          <source>TcpStream::shutdown</source>
          <target state="translated">TcpStream::shutdown</target>
        </trans-unit>
        <trans-unit id="f729ec43f0af2f4768020c3c186531540aa6fe75" translate="yes" xml:space="preserve">
          <source>TcpStream::take</source>
          <target state="translated">TcpStream::take</target>
        </trans-unit>
        <trans-unit id="07ca37092d4865ff34b3da8842e6f13eb4a33726" translate="yes" xml:space="preserve">
          <source>TcpStream::take_error</source>
          <target state="translated">TcpStream::take_error</target>
        </trans-unit>
        <trans-unit id="3f33672645be4d6e5bd0541f33a42009a106b1ad" translate="yes" xml:space="preserve">
          <source>TcpStream::try_clone</source>
          <target state="translated">TcpStream::try_clone</target>
        </trans-unit>
        <trans-unit id="0e120d19ada990068a0b20ff52db32daba2c74d5" translate="yes" xml:space="preserve">
          <source>TcpStream::try_from</source>
          <target state="translated">TcpStream::try_from</target>
        </trans-unit>
        <trans-unit id="0b039d724a73bfa4d009fb758a03fb779a56b987" translate="yes" xml:space="preserve">
          <source>TcpStream::try_into</source>
          <target state="translated">TcpStream::try_into</target>
        </trans-unit>
        <trans-unit id="833adb6a3443ef8c2bc774bcc30192c98f27094a" translate="yes" xml:space="preserve">
          <source>TcpStream::ttl</source>
          <target state="translated">TcpStream::ttl</target>
        </trans-unit>
        <trans-unit id="ad00f68ee2a21774a182c99f9b2a83cd6f6f89e9" translate="yes" xml:space="preserve">
          <source>TcpStream::type_id</source>
          <target state="translated">TcpStream::type_id</target>
        </trans-unit>
        <trans-unit id="accd5bacb0184a5ab554a0ca248574c5b5ddbbcb" translate="yes" xml:space="preserve">
          <source>TcpStream::write</source>
          <target state="translated">TcpStream::write</target>
        </trans-unit>
        <trans-unit id="0058eeee13c9051b5e0a752af3087b29d7b02d7b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_all</source>
          <target state="translated">TcpStream::write_all</target>
        </trans-unit>
        <trans-unit id="cb06fd9c7d1d55fc4b3f3e15dc0163521ac1465b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_fmt</source>
          <target state="translated">TcpStream::write_fmt</target>
        </trans-unit>
        <trans-unit id="a5e3f17e3264af59b558a0fdcba770ba3c28fa37" translate="yes" xml:space="preserve">
          <source>TcpStream::write_timeout</source>
          <target state="translated">TcpStream::write_timeout</target>
        </trans-unit>
        <trans-unit id="6e74581726f107bfc541797c5b9030282bc56e97" translate="yes" xml:space="preserve">
          <source>TcpStream::write_vectored</source>
          <target state="translated">TcpStream::write_vectored</target>
        </trans-unit>
        <trans-unit id="b6eac90e1928ad9ea4411f97ebcf59a5c7e10ed0" translate="yes" xml:space="preserve">
          <source>Teams of Developers</source>
          <target state="translated">开发者团队</target>
        </trans-unit>
        <trans-unit id="260e040b381f220359095e13ffb45be2fbc63287" translate="yes" xml:space="preserve">
          <source>Tells LLVM that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">告诉LLVM,代码中的这一点是无法到达的,从而可以进一步优化。</target>
        </trans-unit>
        <trans-unit id="a946abf59c33631dd9c09fe026f5fda52ecefd51" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">告知此缓冲区 &lt;code&gt;amt&lt;/code&gt; 字节已从缓冲区中消耗掉，因此不应再在 &lt;code&gt;read&lt;/code&gt; 调用中返回它们。</target>
        </trans-unit>
        <trans-unit id="092a16374b222f88ad28cf25d43d7648234ed176" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">告知此缓冲区 &lt;code&gt;amt&lt;/code&gt; 字节已从缓冲区中消耗掉，因此不应再在 &lt;code&gt;read&lt;/code&gt; 调用中返回它们。&lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="027be37242a148e84d0572e0cc986124d9c751bc" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">告知此缓冲区 &lt;code&gt;amt&lt;/code&gt; 字节已从缓冲区中消耗掉，因此不应再在 &lt;code&gt;read&lt;/code&gt; 调用中返回它们。&lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea3b911565206879ae5d6cb4146bc834dfb6a7f3" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">告知此缓冲区 &lt;code&gt;amt&lt;/code&gt; 字节已从缓冲区中消耗掉，因此不应再在 &lt;code&gt;read&lt;/code&gt; 调用中返回它们。&lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68f4c5ea285ef679416734518ea1144f7f9f2cf1" translate="yes" xml:space="preserve">
          <source>Temporal quantification.</source>
          <target state="translated">时间上的量化。</target>
        </trans-unit>
        <trans-unit id="be80baca9006a4100bd6b71127149a07eb502503" translate="yes" xml:space="preserve">
          <source>Temporaries</source>
          <target state="translated">Temporaries</target>
        </trans-unit>
        <trans-unit id="b1380bff4b98c3f3b1a409ce860a8bd5d4ce8c7b" translate="yes" xml:space="preserve">
          <source>Temporaries are also created to hold the result of operands to an expression while the other operands are evaluated. The temporaries are associated to the scope of the expression with that operand. Since the temporaries are moved from once the expression is evaluated, dropping them has no effect unless one of the operands to an expression breaks out of the expression, returns, or panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121a6beed14a5f45c5406020e211d50eaf732ff" translate="yes" xml:space="preserve">
          <source>Temporaries are not always dropped at the end of the enclosing statement. In simple cases where the &lt;code&gt;&amp;amp;&lt;/code&gt; expression is immediately stored into a variable, the compiler will automatically extend the lifetime of the temporary until the end of the enclosing block. Therefore, an alternative way to fix the original program is to write &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; and not &lt;code&gt;let tmp = foo()&lt;/code&gt;:</source>
          <target state="translated">临时语句并不总是在封闭语句的末尾删除。在将 &lt;code&gt;&amp;amp;&lt;/code&gt; 表达式立即存储到变量的简单情况下，编译器将自动延长临时项的生存期，直到封闭块结束。因此，修复原始程序的另一种方法是编写 &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; 而不是 &lt;code&gt;let tmp = foo()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ff4686225d8fb1e953162a00f63d6b94d5a386fd" translate="yes" xml:space="preserve">
          <source>Temporaries that are created in the final expression of a function body are dropped &lt;em&gt;after&lt;/em&gt; any named variables bound in the function body, as there is no smaller enclosing temporary scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae8496ab0d5e20c300ea07a6c87645fbefee013" translate="yes" xml:space="preserve">
          <source>Temporary lifetime extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a237179150c9f45b00df9097591b1d7f10ef2038" translate="yes" xml:space="preserve">
          <source>Temporary lifetimes</source>
          <target state="translated">暂时性寿命</target>
        </trans-unit>
        <trans-unit id="ace2219c94d381961a79fb4617905c5cfbbacbf7" translate="yes" xml:space="preserve">
          <source>Temporary scopes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc9ea018278b216d5b6d6db9b73a7c2a6e7a8c8" translate="yes" xml:space="preserve">
          <source>Terminates the current process with the specified exit code.</source>
          <target state="translated">用指定的退出代码终止当前进程。</target>
        </trans-unit>
        <trans-unit id="4abcdd83ee3f3bce743cbed96b2ad9f965bea36e" translate="yes" xml:space="preserve">
          <source>Terminates the process in an abnormal fashion.</source>
          <target state="translated">以非正常方式终止该过程。</target>
        </trans-unit>
        <trans-unit id="2ee85218866a19e0d9f6c52c176e4eaf9d0877b2" translate="yes" xml:space="preserve">
          <source>Termination</source>
          <target state="translated">Termination</target>
        </trans-unit>
        <trans-unit id="4d00170cd71cecfb46cdbb7ebdf05a4a02fee721" translate="yes" xml:space="preserve">
          <source>Termination::report</source>
          <target state="translated">Termination::report</target>
        </trans-unit>
        <trans-unit id="00f441aa04210533cf8168c3d0baeda960edac55" translate="yes" xml:space="preserve">
          <source>Terminator for various items and statements, &lt;a href=&quot;types/array&quot;&gt;Array types&lt;/a&gt;</source>
          <target state="translated">各种项目和语句的终止符，&lt;a href=&quot;types/array&quot;&gt;数组类型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94aaabf5a007f6525e86dbe783c284fccc74a25c" translate="yes" xml:space="preserve">
          <source>Test Organization</source>
          <target state="translated">测试组织</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="da7894cbcc38e877e01ccb02e3c5e98f656c5624" translate="yes" xml:space="preserve">
          <source>Testing Equality with the &lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; Macros</source>
          <target state="translated">用 &lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; 测试平等！和 &lt;code&gt;assert_ne!&lt;/code&gt; 巨集</target>
        </trans-unit>
        <trans-unit id="117ea1d14f7b6fbe5fa90955d52644403f513522" translate="yes" xml:space="preserve">
          <source>Testing Private Functions</source>
          <target state="translated">测试私有功能</target>
        </trans-unit>
        <trans-unit id="932c5d1d0f6f5178e61a3f6e97a669a7ad5fc25b" translate="yes" xml:space="preserve">
          <source>Testing attributes</source>
          <target state="translated">测试属性</target>
        </trans-unit>
        <trans-unit id="6966e45073f574893b66ceb3ad6d45bb2ced06e0" translate="yes" xml:space="preserve">
          <source>Testing is a complex skill: although we can&amp;rsquo;t cover every detail about how to write good tests in one chapter, we&amp;rsquo;ll discuss the mechanics of Rust&amp;rsquo;s testing facilities. We&amp;rsquo;ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.</source>
          <target state="translated">测试是一项复杂的技能：尽管我们无法在一章中涵盖有关如何编写良好测试的所有细节，但我们将讨论Rust测试设施的机制。我们将讨论编写测试时为您提供的批注和宏，为运行测试提供的默认行为和选项，以及如何将测试组织为单元测试和集成测试。</target>
        </trans-unit>
        <trans-unit id="f7c988b9b3e507c053615421186791199dc1b08e" translate="yes" xml:space="preserve">
          <source>Testing the First Part</source>
          <target state="translated">测试第一部分</target>
        </trans-unit>
        <trans-unit id="833858d67cb9edd86a232319e147507d73e766ab" translate="yes" xml:space="preserve">
          <source>Tests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</source>
          <target state="translated">测试是验证非测试代码是否以预期方式运行的Rust函数。测试函数的主体通常执行这三个动作。</target>
        </trans-unit>
        <trans-unit id="9557b92aa71fea3ff4e10ad5c651a01d327198f2" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;person&lt;/code&gt; has the &lt;code&gt;car&lt;/code&gt; field filled with something.</source>
          <target state="translated">测试 &lt;code&gt;person&lt;/code&gt; 是否在 &lt;code&gt;car&lt;/code&gt; 场上装满东西。</target>
        </trans-unit>
        <trans-unit id="21b62ab2004ca1232d413d8d665d134b12791482" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate.</source>
          <target state="translated">测试迭代器中是否有元素与谓词匹配。</target>
        </trans-unit>
        <trans-unit id="10d2dce236b59fb61d9321a2651527964d17f562" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的任何元素是否与谓词匹配。&lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="209ac04cb187d92f123ce6700c9444025e5580b3" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的任何元素是否与谓词匹配。&lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80ec10f423a5beaec1ab62efd9e4031e5aaa4a11" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的任何元素是否与谓词匹配。&lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="760ae5105c89912ab7a036138a76c59ddfecc44b" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的任何元素是否与谓词匹配。&lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df440409ef320551129c77bcadb79c6c4ba84e37" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的任何元素是否与谓词匹配。&lt;a href=&quot;trait.iterator#method.any&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42f540ef5575b87eda1bc58cc8c893cf2e3e2964" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate.</source>
          <target state="translated">测试迭代器中的每一个元素是否匹配一个谓词。</target>
        </trans-unit>
        <trans-unit id="52e69927724e46dd631e47a69a4f2cdc74a668ca" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的每个元素是否与谓词匹配。&lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c572c6f114e3b7b0e63531ab8e78116f0d5ac5de" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的每个元素是否与谓词匹配。&lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a987e1ebbc5dd44d57ed09974bfdcc0f02c47b55" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的每个元素是否与谓词匹配。&lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74b456b0054dd24ca1a515d72ae7f4e5367d4633" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的每个元素是否与谓词匹配。&lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92be4e62f1c703e57b0a705c84b8aca1511558d2" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">测试迭代器的每个元素是否与谓词匹配。&lt;a href=&quot;trait.iterator#method.all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ebc400fe5bb7d000d0d73f12e63cdedd3140090" translate="yes" xml:space="preserve">
          <source>Tests if the person's &lt;code&gt;age&lt;/code&gt; field is between 13 and 19, and binds its value to the &lt;code&gt;person_age&lt;/code&gt; variable.</source>
          <target state="translated">测试人员的 &lt;code&gt;age&lt;/code&gt; 字段是否在13到19之间，并将其值绑定到 &lt;code&gt;person_age&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="13e062493861ff1e884762affb6f292d7aaa95d6" translate="yes" xml:space="preserve">
          <source>Tests that return &lt;code&gt;()&lt;/code&gt; pass as long as they terminate and do not panic. Tests that return a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; pass as long as they return &lt;code&gt;Ok(())&lt;/code&gt;. Tests that do not terminate neither pass nor fail.</source>
          <target state="translated">只要return &lt;code&gt;()&lt;/code&gt; 终止并且不慌不忙，它们就会通过测试。返回 &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; 测试只要它们返回 &lt;code&gt;Ok(())&lt;/code&gt; 即可通过。不终止的测试既不会通过也不会失败。</target>
        </trans-unit>
        <trans-unit id="240e8d8b35fd6dbae3889295d03396f4179097df" translate="yes" xml:space="preserve">
          <source>Tests that use &lt;code&gt;should_panic&lt;/code&gt; can be imprecise because they only indicate that the code has caused some panic. A &lt;code&gt;should_panic&lt;/code&gt; test would pass even if the test panics for a different reason from the one we were expecting to happen. To make &lt;code&gt;should_panic&lt;/code&gt; tests more precise, we can add an optional &lt;code&gt;expected&lt;/code&gt; parameter to the &lt;code&gt;should_panic&lt;/code&gt; attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for &lt;code&gt;Guess&lt;/code&gt; in Listing 11-9 where the &lt;code&gt;new&lt;/code&gt; function panics with different messages depending on whether the value is too small or too large.</source>
          <target state="translated">使用 &lt;code&gt;should_panic&lt;/code&gt; 的测试可能是不精确的，因为它们仅表明代码引起了一些恐慌。一个 &lt;code&gt;should_panic&lt;/code&gt; 测试会通过，即使从一个不同的原因的测试恐慌我们期待的事情发生。为了使 &lt;code&gt;should_panic&lt;/code&gt; 测试更加精确，我们可以在 &lt;code&gt;should_panic&lt;/code&gt; 属性中添加可选的 &lt;code&gt;expected&lt;/code&gt; 参数。测试工具将确保失败消息包含提供的文本。例如，考虑清单11-9中为 &lt;code&gt;Guess&lt;/code&gt; 修改的代码，其中， &lt;code&gt;new&lt;/code&gt; 函数会根据值是太小还是太大而出现不同的消息，从而出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="6bb384831446531aa67968092446024f5dcdae5e" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a directory. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">测试此文件类型是否代表目录。结果与&lt;a href=&quot;struct.filetype#method.is_file&quot;&gt; &lt;code&gt;is_file&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt;的结果互斥；这些测试只能通过零或其中一项。</target>
        </trans-unit>
        <trans-unit id="47c7f108fa56b78dae837cfbc2c1b6e6d82a8892" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a regular file. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">测试此文件类型是否代表常规文件。结果与&lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt; &lt;code&gt;is_dir&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt;的结果互斥；这些测试只能通过零或其中一项。</target>
        </trans-unit>
        <trans-unit id="8e2618283b789dcbc952fac3457682ad9646a29b" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a symbolic link. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">测试此文件类型是否代表符号链接。结果与&lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt; &lt;code&gt;is_dir&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.filetype#method.is_file&quot;&gt; &lt;code&gt;is_file&lt;/code&gt; &lt;/a&gt;的结果互斥；这些测试只能通过零或其中一项。</target>
        </trans-unit>
        <trans-unit id="24e8ed91cce37f2bfddb7d0a6e1b5b5dd3e13c8b" translate="yes" xml:space="preserve">
          <source>Text directionality</source>
          <target state="translated">文本方向性</target>
        </trans-unit>
        <trans-unit id="ece7c96ceb6b3c2888b8a50e4cc0084fdd3cc5ad" translate="yes" xml:space="preserve">
          <source>Textual Scope</source>
          <target state="translated">文本范围</target>
        </trans-unit>
        <trans-unit id="f351ed281e01f153c5130339693bdde4a4318e5b" translate="yes" xml:space="preserve">
          <source>Textual representation</source>
          <target state="translated">文字表述</target>
        </trans-unit>
        <trans-unit id="50a53707975aa4e011ef0d8fc19d6a0815b5a0af" translate="yes" xml:space="preserve">
          <source>Textual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with &lt;code&gt;let&lt;/code&gt; except it also applies at the module level. When &lt;code&gt;macro_rules!&lt;/code&gt; is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:</source>
          <target state="translated">文本范围主要基于事物在源文件中出现的顺序，并且类似于用 &lt;code&gt;let&lt;/code&gt; 声明的局部变量的范围，但它也适用于模块级别。当 &lt;code&gt;macro_rules!&lt;/code&gt; 用于定义宏，宏将在定义后进入范围（注意，由于从调用站点查找名称，因此仍可以递归使用），直到关闭其周围的范围（通常是模块）为止。这可以输入子模块，甚至可以跨越多个文件：</target>
        </trans-unit>
        <trans-unit id="3250cb346f89521461c9526f4b4c9e22ab7dec1d" translate="yes" xml:space="preserve">
          <source>Textual types</source>
          <target state="translated">文本类型</target>
        </trans-unit>
        <trans-unit id="43b22d6c26a5be334da039abbdd3a863691ba7f8" translate="yes" xml:space="preserve">
          <source>Thankfully, you won't need to worry about upholding this property when deriving both &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;.</source>
          <target state="translated">值得庆幸的是，在使用 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 导出&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;Hash&lt;/code&gt; 时，您无需担心维护此属性。</target>
        </trans-unit>
        <trans-unit id="d87603b9cd3744161580179aa52163b0ef139449" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use 'static:</source>
          <target state="translated">多亏了静态生命期的洗脱,你通常不必明确地使用 &quot;静态&quot;。</target>
        </trans-unit>
        <trans-unit id="ccd80fa4141d21f8d736b44824bc5d805727e80f" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdae0de8a5a5798d4caf783e96f237ed5528f2b" translate="yes" xml:space="preserve">
          <source>Thanks to this process, you can always check out the next build of Rust and verify for yourself that it&amp;rsquo;s easy to upgrade to: if a beta release doesn&amp;rsquo;t work as expected, you can report it to the team and get it fixed before the next stable release happens! Breakage in a beta release is relatively rare, but &lt;code&gt;rustc&lt;/code&gt; is still a piece of software, and bugs do exist.</source>
          <target state="translated">通过此过程，您始终可以签出Rust的下一个版本，并亲自验证其易于升级到：如果beta版本无法按预期工作，则可以将其报告给团队并在修复之前进行修复。下一个稳定版本发布了！Beta版本中出现破损的情况相对较少，但 &lt;code&gt;rustc&lt;/code&gt; 仍然是一款软件，并且确实存在错误。</target>
        </trans-unit>
        <trans-unit id="93b38f3306b86b6513f0666ee48835c2b21219b2" translate="yes" xml:space="preserve">
          <source>That first part is done by us: when we call &lt;code&gt;String::from&lt;/code&gt;, its implementation requests the memory it needs. This is pretty much universal in programming languages.</source>
          <target state="translated">第一部分由我们完成：当我们调用 &lt;code&gt;String::from&lt;/code&gt; ，其实现会请求所需的内存。这在编程语言中几乎是通用的。</target>
        </trans-unit>
        <trans-unit id="1348e5b21c821f227473000afcbce413f66d2f49" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the iterator yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">也就是说，对于每个元素 &lt;code&gt;a&lt;/code&gt; 及其随后的元素 &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;a &amp;lt;= b&lt;/code&gt; 必须成立。如果迭代器的结果恰好为零或一个元素，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf20cf0a5a4308c50df24aa720ae0a415bab9777" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the slice yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">也就是说，对于每个元素 &lt;code&gt;a&lt;/code&gt; 及其随后的元素 &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;a &amp;lt;= b&lt;/code&gt; 必须成立。如果切片精确地产生零或一个元素，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6141d9d942518cd742366c4e9a373eaeca5ba99a" translate="yes" xml:space="preserve">
          <source>That number of bytes is always between 1 and 4, inclusive.</source>
          <target state="translated">这个字节数总是在1到4之间,包括。</target>
        </trans-unit>
        <trans-unit id="5636ef2e6fa0c7ceabc2956a6a83de732290f283" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable, so &lt;code&gt;forget&lt;/code&gt; is only recommended for specialized use cases like those shown below.</source>
          <target state="translated">就是说，通常不希望泄漏诸如内存或I / O对象之类的资源，因此建议仅在特殊使用情况下（如以下所示），才建议 &lt;code&gt;forget&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="bb0090f499faa8dbbaeb7f14d05f8e092483990d" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable. The need comes up in some specialized use cases for FFI or unsafe code, but even then, &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; is typically preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e204c683273a7064bf611cb21bf25b6a58ab5e" translate="yes" xml:space="preserve">
          <source>That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the trait's protocol.</source>
          <target state="translated">也就是说,实施应该提供一个正确的估计,因为否则就违反了性状的协议。</target>
        </trans-unit>
        <trans-unit id="7bf3790580feeb3b9968c1d5ee569f07fe6dc889" translate="yes" xml:space="preserve">
          <source>That said, there is no wrong way to read this book. Read it however you feel helps you best.</source>
          <target state="translated">也就是说,读这本书的方式没有错。你觉得怎么读对你最有帮助就怎么读。</target>
        </trans-unit>
        <trans-unit id="947746e61ef4047bc2347841bf565d094e7bdec0" translate="yes" xml:space="preserve">
          <source>That solves our problem! With only &lt;code&gt;s2&lt;/code&gt; valid, when it goes out of scope, it alone will free the memory, and we&amp;rsquo;re done.</source>
          <target state="translated">那解决了我们的问题！只有 &lt;code&gt;s2&lt;/code&gt; 有效，当它超出范围时，仅凭它就可以释放内存，我们就完成了。</target>
        </trans-unit>
        <trans-unit id="9ce801650086879dbc3fc82fa6315949a2552c96" translate="yes" xml:space="preserve">
          <source>That was a bit of a whirlwind tour of unwind safety, but for more information about unwind safety and how it applies to Rust, see an &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;associated RFC&lt;/a&gt;.</source>
          <target state="translated">放风安全有点儿麻烦，但有关放风安全及其如何应用于Rust的更多信息，请参阅&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;相关的RFC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92b56514bc3604cf70d965940d81ed28035240b2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s 18 bytes and is how computers ultimately store this data. If we look at them as Unicode scalar values, which are what Rust&amp;rsquo;s &lt;code&gt;char&lt;/code&gt; type is, those bytes look like this:</source>
          <target state="translated">那是18个字节，这是计算机最终存储此数据的方式。如果我们将它们视为Unicode标量值（即Rust的 &lt;code&gt;char&lt;/code&gt; 类型），则这些字节如下所示：</target>
        </trans-unit>
        <trans-unit id="9fac4c3e9f71b06878dbbb47f3ce2814227f227f" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of &lt;code&gt;match&lt;/code&gt;! The &lt;code&gt;match&lt;/code&gt; expression is very useful but also very much a primitive. In Chapter 13, you&amp;rsquo;ll learn about closures; the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many methods that accept a closure and are implemented using &lt;code&gt;match&lt;/code&gt; expressions. Using those methods will make your code more concise. A more seasoned Rustacean might write this code instead of Listing 9-5:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 很多！该 &lt;code&gt;match&lt;/code&gt; 的表达是非常有用的，但也很原始。在第13章中，您将学习闭包。该 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 类型具有接纳封闭件，并使用被实现许多方法 &lt;code&gt;match&lt;/code&gt; 表达式。使用这些方法将使您的代码更简洁。经验丰富的Rustacean可能会编写以下代码，而不是清单9-5：</target>
        </trans-unit>
        <trans-unit id="ef238338d4e12acdba68729fda27f2648f9a373c" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of output! The exact output you see might be different depending on your operating system and Rust version. In order to get backtraces with this information, debug symbols must be enabled. Debug symbols are enabled by default when using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo run&lt;/code&gt; without the &lt;code&gt;--release&lt;/code&gt; flag, as we have here.</source>
          <target state="translated">大量的输出！您看到的确切输出可能会有所不同，具体取决于您的操作系统和Rust版本。为了获得带有此信息的回溯，必须启用调试符号。如此处所示，当使用无 &lt;code&gt;--release&lt;/code&gt; 标志的 &lt;code&gt;cargo build&lt;/code&gt; 或 &lt;code&gt;cargo run&lt;/code&gt; 时，默认情况下会启用调试符号。</target>
        </trans-unit>
        <trans-unit id="1b9244a451d65d27f90f013b616e273e2c23a8a2" translate="yes" xml:space="preserve">
          <source>That's it! Let's dig into iterators.</source>
          <target state="translated">就是这样!让我们来研究一下迭代器。</target>
        </trans-unit>
        <trans-unit id="061168032f743f39ddf71cf9c7a9d9f5d6f181f3" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="translated">此类型作为队列的&amp;ldquo;默认&amp;rdquo;用法是使用&lt;a href=&quot;#method.push_back&quot;&gt; &lt;code&gt;push_back&lt;/code&gt; &lt;/a&gt;添加到队列中，使用&lt;a href=&quot;#method.pop_front&quot;&gt; &lt;code&gt;pop_front&lt;/code&gt; &lt;/a&gt;从队列中删除。以这种方式向后&lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;并&lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt;推入，然后在 &lt;code&gt;VecDeque&lt;/code&gt; 上进行迭代。</target>
        </trans-unit>
        <trans-unit id="e1996b7a38e8030e5ba09e25339c72996ff81148" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;../struct.vecdeque#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;../struct.vecdeque#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;../struct.vecdeque#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8660a906a07f3cb76ce3714efc3b35a643f54a" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;struct.vecdeque#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;struct.vecdeque#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;struct.vecdeque#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cb9e838bce9598fdfd4c3684f101808c1294f8" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section in Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f389fc23a4edc2c2a963efce47f9899bcc8519" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section of Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="translated">删除了第19章的&amp;ldquo;高级生存时间&amp;rdquo;部分，因为编译器的改进使该部分中的构造更加罕见。</target>
        </trans-unit>
        <trans-unit id="f99557dc0a8fdf7a63f0792d647f548b4ff6f7ab" translate="yes" xml:space="preserve">
          <source>The 128-bit signed integer type.</source>
          <target state="translated">128位有符号整数类型。</target>
        </trans-unit>
        <trans-unit id="2ecb830f3b64176d279185c7c171382698dc346b" translate="yes" xml:space="preserve">
          <source>The 128-bit unsigned integer type.</source>
          <target state="translated">128位无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="024e734140c83218cfd913643692a04c708db5ec" translate="yes" xml:space="preserve">
          <source>The 16-bit signed integer type.</source>
          <target state="translated">16位有符号整数类型。</target>
        </trans-unit>
        <trans-unit id="c45d15aa8a84f450baba97f342935672e6fa7c43" translate="yes" xml:space="preserve">
          <source>The 16-bit unsigned integer type.</source>
          <target state="translated">16位无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="fca5433f25a52ee7287767b1930704d918391065" translate="yes" xml:space="preserve">
          <source>The 2015 edition does not allow use declarations to reference the &lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;extern prelude&lt;/a&gt;. Thus &lt;a href=&quot;extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; declarations are still required in 2015 to reference an external crate in a use declaration. Beginning with the 2018 edition, use declarations can specify an external crate dependency the same way &lt;code&gt;extern crate&lt;/code&gt; can.</source>
          <target state="translated">2015版不允许使用声明引用&lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;外部前奏&lt;/a&gt;。因此，2015年仍然需要&lt;a href=&quot;extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt;声明，以在使用声明中引用外部包装箱。从2018年版本开始，use声明可以指定外部包装箱依赖关系，方式与 &lt;code&gt;extern crate&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b6d857578ac6c78bfa58339fa5a83d29b7a47348" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This iteration of the book contains a number of changes to reflect those improvements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b6de1c048ad3b08c5d50eb1e62ebf661747fc3" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This printing of the book contains a number of changes to reflect those improvements:</source>
          <target state="translated">2018年版的Rust语言包括许多改进,使Rust更符合人体工程学,更容易学习。本书的这次印刷包含了一些变化,以反映这些改进。</target>
        </trans-unit>
        <trans-unit id="2c35b45536addab0f127b7ef2a73381bf5aab740" translate="yes" xml:space="preserve">
          <source>The 32-bit floating point type.</source>
          <target state="translated">32位浮点类型。</target>
        </trans-unit>
        <trans-unit id="ede6acb001e744d94e80e43f20515bed53288286" translate="yes" xml:space="preserve">
          <source>The 32-bit signed integer type.</source>
          <target state="translated">32位有符号整数类型。</target>
        </trans-unit>
        <trans-unit id="a9e99a82ec2d26441031e5f8781a5ebb65a83e0e" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer type.</source>
          <target state="translated">32位无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="13cb697c6b75c7757e9c51749eb9c614ddc9a70f" translate="yes" xml:space="preserve">
          <source>The 64-bit floating point type.</source>
          <target state="translated">64位浮点类型。</target>
        </trans-unit>
        <trans-unit id="748e7d28f53e7a36937bb25af3f1a76e6a491ad6" translate="yes" xml:space="preserve">
          <source>The 64-bit signed integer type.</source>
          <target state="translated">64位有符号整数类型。</target>
        </trans-unit>
        <trans-unit id="25aeddd62dc36790a2166200538648d83779c0d0" translate="yes" xml:space="preserve">
          <source>The 64-bit unsigned integer type.</source>
          <target state="translated">64位无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="0825a8c90a6add467ca53950b645a26af9033007" translate="yes" xml:space="preserve">
          <source>The 8-bit signed integer type.</source>
          <target state="translated">8位有符号的整数类型。</target>
        </trans-unit>
        <trans-unit id="6d1f46b751b47e95357a0c40c6e78729c3531e1e" translate="yes" xml:space="preserve">
          <source>The 8-bit unsigned integer type.</source>
          <target state="translated">8位无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="b568b58db2fe5b477d28998d21858de250eecb32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.clone&quot;&gt;&lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt;&lt;/a&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">该&lt;a href=&quot;#method.clone&quot;&gt; &lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt; &lt;/a&gt;语法是最地道的，因为它传达更明确的代码的含义。在上面的示例中，使用此语法可以更轻松地看到此代码正在创建新引用，而不是复制foo的全部内容。</target>
        </trans-unit>
        <trans-unit id="fd0354b8e891bd703f8ef8a8ce8547a17dc2e4cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="translated">该&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;方法将套接字连接到同行。</target>
        </trans-unit>
        <trans-unit id="de66ae551d77056e5d10cff2c3fd9dbcc9b63e6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect this socket to a remote address. This method will fail if the socket is not connected.</source>
          <target state="translated">该&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;方法此套接字连接到远程地址。如果未连接套接字，此方法将失败。</target>
        </trans-unit>
        <trans-unit id="3822ea1855bf914e5a814986732fc459619fc61c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="translated">所述&lt;a href=&quot;#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;方法可以模拟 &lt;code&gt;truncate&lt;/code&gt; ，但导致要返回而不是丢弃多余的元件。</target>
        </trans-unit>
        <trans-unit id="a9d6dbd0eeefdb718b7113fea8088d62bd58b0d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="translated">该&lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;方法具有缺省实现，因此你通常不应该实现它。但是，您可能能够提供比默认设置更有效的实现，因此在这种情况下将其覆盖是有意义的。</target>
        </trans-unit>
        <trans-unit id="dade93dc3cf6b97db5474305c3207f7c692d153c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="translated">该&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;适配器是非常有用的，但只有当闭合参数产生的值。如果它产生一个迭代器，则会有一个间接层。 &lt;code&gt;flat_map()&lt;/code&gt; 会自行删除此额​​外的图层。</target>
        </trans-unit>
        <trans-unit id="7a52c1262c15b7898ef7ba52e5c11aa28470cc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="translated">该&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法将实际检查所提供的 &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; 没有在中间0字节，如果找到返回一个错误。</target>
        </trans-unit>
        <trans-unit id="156348d96d775ff156fee076f0f98b0084e3469d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="translated">所述&lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;方法可被用于将数据发送到指定地址。&lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt;将仅从该地址接收数据。</target>
        </trans-unit>
        <trans-unit id="1ad11576c65e9334d7573beaf36142b4de74e09c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6b3d78fe45feec8a5741e2a3ac93f1ed3a19d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="translated">该&lt;a href=&quot;#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;方法是适配器和明确自己的缓冲区确保所有缓存数据已经被推到了&amp;ldquo;真汇&amp;rdquo;是有用的。</target>
        </trans-unit>
        <trans-unit id="8a62cb575b08d38c732e1bba9328976a264fdb19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="translated">该&lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;方法将尝试一些数据写入到对象，返回多少字节被成功写入。</target>
        </trans-unit>
        <trans-unit id="8fcdedc3c9e84c7fa96e2530650c1bc070bc790b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt;&lt;code&gt;async move&lt;/code&gt; block&lt;/a&gt; in the body captures all function parameters, including those that are unused or bound to a &lt;code&gt;_&lt;/code&gt; pattern. This ensures that function parameters are dropped in the same order as they would be if the function were not async, except that the drop occurs when the returned future has been fully awaited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78f52a30365dea52628c4ade488db0345ffa3ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; macros are identical to &lt;a href=&quot;../macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, respectively, except they emit their output to stderr.</source>
          <target state="translated">电子版&lt;a href=&quot;../macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt;宏与&lt;a href=&quot;../macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;完全相同！和&lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;，除了它们将输出发送到stderr之外。</target>
        </trans-unit>
        <trans-unit id="15b30e899910805c24344f039598ed4f0cfd76f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; macro is intended to be familiar to those coming from C's &lt;code&gt;printf&lt;/code&gt;/&lt;code&gt;fprintf&lt;/code&gt; functions or Python's &lt;code&gt;str.format&lt;/code&gt; function.</source>
          <target state="translated">该&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; &lt;code&gt;str.format&lt;/code&gt; 在使那些使用C的 &lt;code&gt;printf&lt;/code&gt; / &lt;code&gt;fprintf&lt;/code&gt; 函数或Python的str.format函数的用户熟悉。</target>
        </trans-unit>
        <trans-unit id="5d076b83cf0704732b7b9eb8c03c4bfbdeaffd03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da9aedd3913426ccb3cbeae460a449f6f18fc2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="translated">该&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;宏将安全地创建此结构的实例。该宏在编译时验证格式字符串，因此可以安全地执行&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;函数的使用。</target>
        </trans-unit>
        <trans-unit id="d6220f58fc37e6b8b0afc01735948c86469d85de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec!&lt;/code&gt;&lt;/a&gt; macro is provided to make initialization more convenient:</source>
          <target state="translated">该&lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec!&lt;/code&gt; &lt;/a&gt;提供了宏以使初始化更加方便：</target>
        </trans-unit>
        <trans-unit id="d6015eed300b7de406449e79cfdc1aa2f387182e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/a&gt; works as usual and import the macro names into the macro-use prelude.</source>
          <target state="translated">该&lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt; &lt;code&gt;macro_use&lt;/code&gt; 属性&lt;/a&gt;照常工作，并导入宏名到宏观使用的前奏。</target>
        </trans-unit>
        <trans-unit id="3ee79a0bb859db06f06e2ddc850e161230b3ef29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; constraint is because the closure will need to be passed &lt;em&gt;by value&lt;/em&gt; from the thread where it is spawned to the new thread. Its return value will need to be passed from the new thread to the thread where it is &lt;code&gt;join&lt;/code&gt;ed. As a reminder, the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; marker trait expresses that it is safe to be passed from thread to thread. &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; expresses that it is safe to have a reference be passed from thread to thread.</source>
          <target state="translated">该&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;约束是因为关闭将需要传递&lt;em&gt;的值&lt;/em&gt;从那里催生新线程的线程。它的返回值需要从新线程传递到 &lt;code&gt;join&lt;/code&gt; 它的线程。提醒一下，&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;标记特征表示从线程到线程传递是安全的。&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;表示从线程到线程传递引用是安全的。</target>
        </trans-unit>
        <trans-unit id="9c69caf5cbc6ae5668ac370ea6aa28c0348ce679" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; to an associated item is any path to the implementing type, followed by the associated item's identifier as the final path component.</source>
          <target state="translated">该&lt;a href=&quot;../paths&quot;&gt;路径&lt;/a&gt;到相关的项目是将实施类型的任何路径，接着由相关联的项的识别码作为最终路径组件。</target>
        </trans-unit>
        <trans-unit id="1dedee4df1c883aa9e7db0132fc24154a02120fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt; type is used instead to prevent moves through the type system. Pointers &lt;code&gt;P&amp;lt;T&amp;gt;&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper can't be moved out of. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin&lt;/code&gt; module&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c6d762c492370e5bdcdefde3e4fc5cf31a9b6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/items/unions&quot;&gt;Rust equivalent of a C-style union&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/items/unions&quot;&gt;相当于C样式联合&lt;/a&gt;的Rust。</target>
        </trans-unit>
        <trans-unit id="86cbe7690d77cc63e21bdfee9a1e9528110648c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/types/trait-object&quot;&gt;Reference&lt;/a&gt; has more information about trait objects, their limitations and the differences between editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6f479476a4a73b474dd9bb423ce981f3c3f329" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of this result indicates that the primitive was not poisoned, and the &lt;code&gt;Guard&lt;/code&gt; is contained within. The &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant indicates that the primitive was poisoned. Note that the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant &lt;em&gt;also&lt;/em&gt; carries the associated guard, and it can be acquired through the &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">此结果的&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;变体表明该原语未中毒，并且其中包含 &lt;code&gt;Guard&lt;/code&gt; 。该&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;变种表明，原始是被毒死的。请注意，&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;变体&lt;em&gt;还&lt;/em&gt;带有关联的防护，可以通过&lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; &lt;/a&gt;方法获取它。</target>
        </trans-unit>
        <trans-unit id="79df059e358a4241ab821f0fe6e918cdbba9f208" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait is a supertrait of &lt;code&gt;Copy&lt;/code&gt;, so it also needs compiler generated implementations. It is implemented by the compiler for the following types:</source>
          <target state="translated">该&lt;a href=&quot;../std/clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;性状是的supertrait &lt;code&gt;Copy&lt;/code&gt; ，因此它也需要编译器生成实施方式。它由编译器针对以下类型实现：</target>
        </trans-unit>
        <trans-unit id="90ba5aefe61d573b28b76d88a60eabe0413d5c63" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeefbcb93aa9d7429fc3ba4a3a1ce956f75d5cfc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment. &lt;code&gt;Copy&lt;/code&gt; cannot be implemented for types which implement &lt;code&gt;Drop&lt;/code&gt;, or which have fields that are not &lt;code&gt;Copy&lt;/code&gt;. &lt;code&gt;Copy&lt;/code&gt; is implemented by the compiler for</source>
          <target state="translated">该&lt;a href=&quot;../std/marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;特性改变实现它的类型的语义。类型实现 &lt;code&gt;Copy&lt;/code&gt; 的值将被复制而不是在赋值时移动。 &lt;code&gt;Copy&lt;/code&gt; 不能为它们实现类型来实现 &lt;code&gt;Drop&lt;/code&gt; ，或有不字段 &lt;code&gt;Copy&lt;/code&gt; 。 &lt;code&gt;Copy&lt;/code&gt; 是由编译器实现的</target>
        </trans-unit>
        <trans-unit id="0e14c3a80117b6ea49358dfdccbdf20f1c51a89c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to send from one thread to another.</source>
          <target state="translated">该&lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;特质表明，这种类型的值是安全的，从一个线程发送到另一个。</target>
        </trans-unit>
        <trans-unit id="974ae2ba65e9e772d3c59ca8b9d11adff4f54e38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd79bdd63f1cb15136ac63579db2daa51f56797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="translated">在&lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt; &lt;code&gt;RefUnwindSafe&lt;/code&gt; &lt;/a&gt;特点是&lt;em&gt;自动特质&lt;/em&gt;。自动特征具有特殊的属性。</target>
        </trans-unit>
        <trans-unit id="292a56639a943e7a95497bb0cf72fbedd7460764" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait indicates that the size of this type is known at compile-time; that is, it's not a &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;. &lt;a href=&quot;types/parameters&quot;&gt;Type parameters&lt;/a&gt; are &lt;code&gt;Sized&lt;/code&gt; by default. &lt;code&gt;Sized&lt;/code&gt; is always implemented automatically by the compiler, not by &lt;a href=&quot;items/implementations&quot;&gt;implementation items&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;性状表明这种类型的大小在编译时已知的; 也就是说，它不是&lt;a href=&quot;dynamically-sized-types&quot;&gt;动态大小的类型&lt;/a&gt;。默认情况下，&lt;a href=&quot;types/parameters&quot;&gt;类型参数&lt;/a&gt;的 &lt;code&gt;Sized&lt;/code&gt; 为。 &lt;code&gt;Sized&lt;/code&gt; 总是由编译器自动实现，而不是由&lt;a href=&quot;items/implementations&quot;&gt;实现项&lt;/a&gt;自动实现。</target>
        </trans-unit>
        <trans-unit id="bbed2a3ef9298a62094e0bee99c5f47d5609e39c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to share between multiple threads. This trait must be implemented for all types used in immutable &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;特征表明，这种类型的值是安全的多线程之间共享。必须为不可变&lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; 项目中&lt;/a&gt;使用的所有类型实现此特征。</target>
        </trans-unit>
        <trans-unit id="0bd4f0026aa17cd077440ff412c90263cb35c5bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; trait provides a &lt;a href=&quot;destructors&quot;&gt;destructor&lt;/a&gt;, to be run whenever a value of this type is to be destroyed.</source>
          <target state="translated">的&lt;a href=&quot;../std/ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;性状提供了&lt;a href=&quot;destructors&quot;&gt;析构函数&lt;/a&gt;，要运行每当这种类型的值是要被破坏。</target>
        </trans-unit>
        <trans-unit id="767089bdc12afceff4b8eaec0f0a325f5d336e5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt; method on strings&lt;/a&gt; parses a string into some kind of number. Because this method can parse a variety of number types, we need to tell Rust the exact number type we want by using &lt;code&gt;let guess: u32&lt;/code&gt;. The colon (&lt;code&gt;:&lt;/code&gt;) after &lt;code&gt;guess&lt;/code&gt; tells Rust we&amp;rsquo;ll annotate the variable&amp;rsquo;s type. Rust has a few built-in number types; the &lt;code&gt;u32&lt;/code&gt; seen here is an unsigned, 32-bit integer. It&amp;rsquo;s a good default choice for a small positive number. You&amp;rsquo;ll learn about other number types in Chapter 3. Additionally, the &lt;code&gt;u32&lt;/code&gt; annotation in this example program and the comparison with &lt;code&gt;secret_number&lt;/code&gt; means that Rust will infer that &lt;code&gt;secret_number&lt;/code&gt; should be a &lt;code&gt;u32&lt;/code&gt; as well. So now the comparison will be between two values of the same type!</source>
          <target state="translated">&lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt;字符串&lt;/a&gt;的 &lt;code&gt;parse&lt;/code&gt; 方法将字符串解析为某种数字。因为此方法可以解析各种数字类型，所以我们需要通过 &lt;code&gt;let guess: u32&lt;/code&gt; 来告诉Rust我们想要的确切数字类型：u32。冒号（ &lt;code&gt;:&lt;/code&gt; ）之后 &lt;code&gt;guess&lt;/code&gt; 告诉锈我们将注释变量的类型。 Rust有一些内置的数字类型。这里看到的 &lt;code&gt;u32&lt;/code&gt; 是一个无符号的32位整数。对于较小的正数，这是一个很好的默认选择。你会在第3章此外了解其他数字类型，在 &lt;code&gt;u32&lt;/code&gt; 在这个示例程序注释和与比较 &lt;code&gt;secret_number&lt;/code&gt; 意味着生锈推断 &lt;code&gt;secret_number&lt;/code&gt; 应该是一个 &lt;code&gt;u32&lt;/code&gt; 也是。因此，现在将在相同类型的两个值之间进行比较！</target>
        </trans-unit>
        <trans-unit id="c4baaa152505c4dd10d0a8afc8811ba9994e6d24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a13bea0cade14eaae143cc58b002085ddc4bf19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac19fe7126085cad17eb0b418fa395ae25fa16f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;../str/index&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt;提供的&lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; &lt;/a&gt;类型表示将&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;的切片转换为&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;时可能发生的错误。从这个意义上讲，它类似于 &lt;code&gt;FromUtf8Error&lt;/code&gt; ，您可以通过&lt;a href=&quot;#method.utf8_error&quot;&gt; &lt;code&gt;utf8_error&lt;/code&gt; &lt;/a&gt;方法从 &lt;code&gt;FromUtf8Error&lt;/code&gt; 中获得一个。</target>
        </trans-unit>
        <trans-unit id="7fb67cacdd201c958a0c7d558837d2a8082fe699" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="translated">&lt;a href=&quot;../str/index&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt;提供的&lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; &lt;/a&gt;类型表示将&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;的切片转换为&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;时可能发生的错误。从这个意义上讲，它类似于 &lt;code&gt;FromUtf8Error&lt;/code&gt; 。有关使用它的更多详细信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="239e6c53cbac59da452aab2dc0d25e7124ea430b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;struct.fromutf8error#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d50f09079feb56741d3701cde3c9928a1a6e9ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddda8120a353c19c1143b9fe623d73b4dcc57ac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; function consumes a box and returns the raw pointer. It doesn't destroy &lt;code&gt;T&lt;/code&gt; or deallocate any memory.</source>
          <target state="translated">该&lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt;功能会消耗一箱，并返回原始指针。它不会破坏 &lt;code&gt;T&lt;/code&gt; 或释放任何内存。</target>
        </trans-unit>
        <trans-unit id="f8812873ebf26389aa2891235cb5791e408b7568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;collections/index&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other typical collection types, including the common &lt;a href=&quot;collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;collections/index&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt;模块定义映射，集合，链表和其他典型的集合类型，包括常见&lt;a href=&quot;collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a000df2416eeaceaee8b63bcc4f4d96683535efe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt; attributes are active. The &lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; attribute is inert when compiling for tests and active otherwise. &lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;Attribute macros&lt;/a&gt; are active. All other attributes are inert.</source>
          <target state="translated">该&lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt; &lt;code&gt;cfg_attr&lt;/code&gt; &lt;/a&gt;属性是活动的。进行测试编译时，&lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;属性为inert，否则为active。&lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;属性宏&lt;/a&gt;处于活动状态。所有其他属性均为惰性。</target>
        </trans-unit>
        <trans-unit id="6870dee47d3fe5b85f2f338b73c3f7cce4094df6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; except for raw pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a453b12ad8603a837d27104bf0cf09312a2b66" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; produces a place which can be moved from. This means that the &lt;code&gt;*&lt;/code&gt; operator and the destructor of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; are built-in to the language.</source>
          <target state="translated">的&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;引用操作符&lt;/a&gt;为 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 产生可从被移动的地方。这意味着 &lt;code&gt;*&lt;/code&gt; 运算符和 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 的析构函数是该语言的内置函数。</target>
        </trans-unit>
        <trans-unit id="69b248ba9e2f044518c42fe197df63cfa4b2abff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;引用操作符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecbb9300a5b716ea6923d97c4a33bcc05beabca8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.current&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt; function is available even for threads not spawned by the APIs of this module.</source>
          <target state="translated">即使不是此模块的API产生的&lt;a href=&quot;fn.current&quot;&gt; &lt;code&gt;thread::current&lt;/code&gt; &lt;/a&gt;函数也可用。</target>
        </trans-unit>
        <trans-unit id="83c879af00d7b8c642fb06e560ce31570f391a07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function provides an iterator over the bytes of an escaped version of the character given.</source>
          <target state="translated">该&lt;a href=&quot;fn.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt;功能提供超过给定的字符的转义版本字节的迭代器。</target>
        </trans-unit>
        <trans-unit id="04034ef7d1f4bac81675e414f3f0f4340588ab73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;thread::park&lt;/code&gt;&lt;/a&gt; function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return &lt;em&gt;spuriously&lt;/em&gt;, without consuming the token. &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;thread::park_timeout&lt;/code&gt;&lt;/a&gt; does the same, but allows specifying a maximum time to block the thread for.</source>
          <target state="translated">该&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;thread::park&lt;/code&gt; &lt;/a&gt;的功能块当前线程，除非或直到该令牌可用于它的线程处理，在这一点上，原子所消耗的令牌。它也可能&lt;em&gt;虚假地&lt;/em&gt;返回，而不消耗令牌。&lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;thread::park_timeout&lt;/code&gt; &lt;/a&gt;功能相同，但是允许指定最大时间来阻止线程。</target>
        </trans-unit>
        <trans-unit id="010183e81cf43fb24dc3ff708d62a66ab46d9a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; free function uses a &lt;code&gt;Builder&lt;/code&gt; with default configuration and &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;s its return value.</source>
          <target state="translated">该&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;免费功能使用 &lt;code&gt;Builder&lt;/code&gt; 的默认配置和&lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt;开发它的返回值。</target>
        </trans-unit>
        <trans-unit id="29d01ae14bfbd0d95900d7de260d830e6b2aebdb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of a &lt;code&gt;match&lt;/code&gt; expression is not a temporary scope, so temporaries in the scrutinee can be dropped after the &lt;code&gt;match&lt;/code&gt; expression. For example, the temporary for &lt;code&gt;1&lt;/code&gt; in &lt;code&gt;match 1 { ref mut z =&amp;gt; z };&lt;/code&gt; lives until the end of the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d631316da22e8f49a59e622d46e415aca63cb44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of an &lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="translated">所述&lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt;一个的&lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt; &lt;code&gt;if let&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;expressions/match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;，或者&lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; &lt;/a&gt;表达。</target>
        </trans-unit>
        <trans-unit id="f60d04280a375c73571ef4d8073dd6fd2b866e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;nomicon&lt;/a&gt; has additional documentation.</source>
          <target state="translated">该&lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;nomicon&lt;/a&gt;有其他文档。</target>
        </trans-unit>
        <trans-unit id="234fa73a8f6dcc88ca3eeed24db16797666a2694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFC&lt;/a&gt; contains motivations and more details.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFC&lt;/a&gt;包含动机和更多的细节。</target>
        </trans-unit>
        <trans-unit id="b6a13e231d1887805079fed3345d62d70fa98ffc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules#prelude-items&quot;&gt;&lt;code&gt;no_implicit_prelude&lt;/code&gt;&lt;/a&gt; attribute can be used on a module to disable prelude lookups within that module.</source>
          <target state="translated">所述&lt;a href=&quot;modules#prelude-items&quot;&gt; &lt;code&gt;no_implicit_prelude&lt;/code&gt; &lt;/a&gt;属性可以一个模块到该模块内禁止前奏查找上使用。</target>
        </trans-unit>
        <trans-unit id="2d090eed4aa4b11f0c7d0fffa892207e5f74b95a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;option/index&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/index&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling types, &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;iter/index&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines Rust's iterator trait, &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to access collections.</source>
          <target state="translated">的&lt;a href=&quot;option/index&quot;&gt; &lt;code&gt;option&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;result/index&quot;&gt; &lt;code&gt;result&lt;/code&gt; &lt;/a&gt;模块定义可选和错误处理的类型，&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;。在&lt;a href=&quot;iter/index&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;模块定义锈病的迭代特性，&lt;a href=&quot;iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;，它与工作&lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;循环来访问集合。</target>
        </trans-unit>
        <trans-unit id="a5d9a354e8b0f07a3115dc9b0844a83e58a8610e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9260d9d3256bee11715c7bab554254f578e52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bee548c1faeb9c0868a59d1b0359e0916d54967" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="translated">的&lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt;方法可用于产生非拥有&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。一个&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针可以&lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt; d一个 &lt;code&gt;Arc&lt;/code&gt; ，但是这将返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;如果该值已经下降。</target>
        </trans-unit>
        <trans-unit id="74bc0ed50e554fb672c29105c76cd20026688a4b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value stored in the allocation has already been dropped. In other words, &lt;code&gt;Weak&lt;/code&gt; pointers do not keep the value inside the allocation alive; however, they &lt;em&gt;do&lt;/em&gt; keep the allocation (the backing store for the value) alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c3ecdf0be1261908d0f10ca942b75ee9286aef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; instance can be created with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">该&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt;例如可以与创建&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;宏。</target>
        </trans-unit>
        <trans-unit id="fa75ef55ee98f7d19f2ace1042e87faf9ee8ae65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt; struct wraps a writer and buffers its output. But it only does this batched write when it goes out of scope, or when the internal buffer is full. Sometimes, you'd prefer to write each line as it's completed, rather than the entire buffer at once. Enter &lt;code&gt;LineWriter&lt;/code&gt;. It does exactly that.</source>
          <target state="translated">该&lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; &lt;/a&gt;结构封装了一个作家和缓冲输出。但是，只有在超出范围或内部缓冲区已满时，才执行此批量写入。有时，您宁愿在完成时写每一行，而不是一次写整个缓冲区。输入 &lt;code&gt;LineWriter&lt;/code&gt; 。它确实做到了。</target>
        </trans-unit>
        <trans-unit id="a07405d582facf4ae9638d6c46ccf83d378ca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; method will take ownership of the builder and create an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to the thread handle with the given configuration.</source>
          <target state="translated">该&lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;方法将采取建设者的所有权，并创建一个&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;与给定的配置线程句柄。</target>
        </trans-unit>
        <trans-unit id="8461a34249fb23d4197f5b2441105518f99e167b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct is used to configure and spawn processes:</source>
          <target state="translated">该&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt;结构是用于配置和产卵的过程：</target>
        </trans-unit>
        <trans-unit id="c0f682c8845fc1182cef69275c8073a32be2d0f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command#method.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; of a child process can be configured by passing an &lt;a href=&quot;struct.stdio&quot;&gt;&lt;code&gt;Stdio&lt;/code&gt;&lt;/a&gt; to the corresponding method on &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;. Once spawned, they can be accessed from the &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;. For example, piping output from one command into another command can be done like so:</source>
          <target state="translated">可以通过将&lt;a href=&quot;struct.stdio&quot;&gt; &lt;code&gt;Stdio&lt;/code&gt; &lt;/a&gt;传递给&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt;上的相应方法来配置子进程的&lt;a href=&quot;struct.command#method.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.command#method.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.command#method.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;。生成后，可以从&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; 中&lt;/a&gt;访问它们。例如，可以将一个命令的输出管道输送到另一命令，如下所示：</target>
        </trans-unit>
        <trans-unit id="f9ad904c74c4288c252921bb9ae74bd23e865305" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979c5c1602643a6a3cebe7ffbfac71410fb43889" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;thread::Result&lt;/code&gt;&lt;/a&gt; containing &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; of the final value produced by the child thread, or &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; of the value given to a call to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if the child panicked.</source>
          <target state="translated">该&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;方法返回一个&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;thread::Result&lt;/code&gt; &lt;/a&gt;含有&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;由子线程产生的最终价值，或&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;给一个调用的值来&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;如果孩子惊慌失措。</target>
        </trans-unit>
        <trans-unit id="d70df5ac1306fbf7451739c8b7b5cbb316412dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method yields a reference to the contained value which cannot be sent across threads or escape the given closure.</source>
          <target state="translated">在&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;方法产生于不能跨线程发送或逸出所述给定封闭件所包含的值的引用。</target>
        </trans-unit>
        <trans-unit id="4cdf73c1055626ea58f2e6c5956631d7c37626c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="translated">的&lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt;方法可用于产生非拥有&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。一个&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针可以&lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt; d到&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;，但是这将返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;如果该值已经下降。</target>
        </trans-unit>
        <trans-unit id="bcfdea4875bc006b185727ffa377cb6c800ff1eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value stored in the allocation has already been dropped. In other words, &lt;code&gt;Weak&lt;/code&gt; pointers do not keep the value inside the allocation alive; however, they &lt;em&gt;do&lt;/em&gt; keep the allocation (the backing store for the inner value) alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673675ebe57e0604b8f52dd76cd89f3cf84af682" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; operation can only fail if the sending half of a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) is disconnected, implying that no further messages will ever be received.</source>
          <target state="translated">所述&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;如果一个的发送一半操作只能失败&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;（或&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;）断开，这意味着没有进一步的消息将永远被接收。</target>
        </trans-unit>
        <trans-unit id="2096b737ddfebc05d46f568e296a81f0a3d0197e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="translated">的&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;可以被克隆到&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;多次，以相同的信道，但只有一个&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;被支持。</target>
        </trans-unit>
        <trans-unit id="d38fd997ec90eab994427a1fbc1ca66e988ed96b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="translated">的&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt;可以被克隆到&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;多次，以相同的信道，但只有一个&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;被支持。</target>
        </trans-unit>
        <trans-unit id="7001293def1e95a9d6c40ad63bf180d03eb64fd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; atomically makes the token available if it wasn't already. Because the token is initially absent, &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; will result in the second call returning immediately.</source>
          <target state="translated">&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;方法原子地使令牌可用（如果尚未存在）。由于令牌最初不存在，因此先&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;然后再进行驻留将导致第二个呼叫立即返回。</target>
        </trans-unit>
        <trans-unit id="3b63b1ad0bef3b06d878599f3be015ecfe5404bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.unixdatagram#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1599d30320e03334b98613759c0cb03ef5b8af44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53484ac76a42814fdd6d0152dc58d8216dd587e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6d0b5a4d7abf2551cbce00a21d08c3b9b0ea9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;thread/index&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;sync/index&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; contains further primitive shared memory types, including &lt;a href=&quot;sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sync/mpsc/index&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.</source>
          <target state="translated">该&lt;a href=&quot;thread/index&quot;&gt; &lt;code&gt;thread&lt;/code&gt; &lt;/a&gt;模块包含锈病的线程抽象。&lt;a href=&quot;sync/index&quot;&gt; &lt;code&gt;sync&lt;/code&gt; &lt;/a&gt;包含其他原始共享内存类型，包括&lt;a href=&quot;sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;sync/mpsc/index&quot;&gt; &lt;code&gt;mpsc&lt;/code&gt; &lt;/a&gt;，其中包含用于消息传递的通道类型。</target>
        </trans-unit>
        <trans-unit id="49a461a4d2bf3262db6f2402e2172259bf56947f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.asciiext&quot;&gt;&lt;code&gt;AsciiExt&lt;/code&gt;&lt;/a&gt; trait provides methods that allow for character operations that only act on the ASCII subset and leave non-ASCII characters alone.</source>
          <target state="translated">该&lt;a href=&quot;trait.asciiext&quot;&gt; &lt;code&gt;AsciiExt&lt;/code&gt; &lt;/a&gt;特征提供了允许字符操作只作用于ASCII子集，并独自离开非ASCII字符的方法。</target>
        </trans-unit>
        <trans-unit id="1a4c8cc0a085c3df1289a22cd8aaec879c0c1b9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.doubleendediterator&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">该&lt;a href=&quot;trait.doubleendediterator&quot;&gt;特征级&lt;/a&gt;文档包含更多细节。</target>
        </trans-unit>
        <trans-unit id="a9baa3ad4d7314655f1af4e53b409fbc088f4b8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method is generally used when errors cross &quot;abstraction boundaries&quot;. If one module must report an error that is caused by an error from a lower-level module, it can allow access to that error via the &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method. This makes it possible for the high-level module to provide its own errors while also revealing some of the implementation for debugging via &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; chains.</source>
          <target state="translated">所述&lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt;当错误跨越&amp;ldquo;抽象边界&amp;rdquo;的方法，一般使用。如果一个模块必须报告由下级模块的错误引起的错误，则它可以允许通过&lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt;方法访问该错误。这使得高级模块可以提供自己的错误，同时还可以公开一些通过&lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt;链进行调试的实现。</target>
        </trans-unit>
        <trans-unit id="3fb97ac2277aef1f78113f1e75546370dbbdba9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8960e05e681fd3c863585eb072cff67079ae758" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; traits are implemented by types that can be invoked like functions. Note that &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt; and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;self&lt;/code&gt;. These correspond to the three kinds of methods that can be invoked on an instance: call-by-reference, call-by-mutable-reference, and call-by-value. The most common use of these traits is to act as bounds to higher-level functions that take functions or closures as arguments.</source>
          <target state="translated">该&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;性状是由可调用类的函数类型实现的。注意，&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;接受 &lt;code&gt;&amp;amp;self&lt;/code&gt; ，&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;接受 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;接受 &lt;code&gt;self&lt;/code&gt; 。这些对应于可以在实例上调用的三种方法：按引用调用，按可变引用调用和按值调用。这些特征最常见的用法是充当以函数或闭包为参数的高级函数的边界。</target>
        </trans-unit>
        <trans-unit id="c33bacd306c2aa86080fee643cadd9fa3a5a922c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af84d72464a620d276e568d18222de12da4b2fde" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; iterator implements &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;, meaning that you can also &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; backwards:</source>
          <target state="translated">该&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;迭代器工具&lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;，这意味着你还可以&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;倒退：</target>
        </trans-unit>
        <trans-unit id="a0672d71e250ee0ec8fcc8dfa66640aade0f2d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; traits behave like &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, but should be implemented when the conversion can fail.</source>
          <target state="translated">该&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;性状表现得像&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;，而应实现时，转换可能会失败。</target>
        </trans-unit>
        <trans-unit id="e376c9d77b7276078629a96e3397aaf50b87d100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa424efe4823f7e6a6edaf5a49990756704380f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75436aa22cb5f73032a0aa74018fe133c992dee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;type-layout#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;type-layout#primitive-representations&quot;&gt;原始的陈述&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76a754ff1ade7a85d17901c16d28f4fc1a0ec281" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/inferred&quot;&gt;inferred type&lt;/a&gt; which asks the compiler to determine the type.</source>
          <target state="translated">要求编译器确定类型的&lt;a href=&quot;types/inferred&quot;&gt;推断&lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="bbc904b6676167d928a315d71b571002efe99186" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/never&quot;&gt;never&lt;/a&gt; type.</source>
          <target state="translated">该&lt;a href=&quot;types/never&quot;&gt;永不&lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="2be3f45b2596938280efdad2e1e3c487cd3dd502" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dac89caf1fb6bb25d3f0271f01c85dae090eff" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Only Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="translated">的 &lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; 运算符只能用于返回 &lt;code&gt;Result&lt;/code&gt; 函数中</target>
        </trans-unit>
        <trans-unit id="bf416e54f0f3d3a2ee8340cdce3195c04f0662bc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; Placeholder</source>
          <target state="translated">该 &lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; 占位符</target>
        </trans-unit>
        <trans-unit id="7d36ad4c51a4dc937d643fbbbf54439f451168f2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; Function and Invalid Unicode</source>
          <target state="translated">该 &lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; 功能和无效的Unicode</target>
        </trans-unit>
        <trans-unit id="43afa187f9cf6582feca58fbbf7f12992daae6dc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-automatically_derived-attribute&quot;&gt;automatically_derived&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae32b9d596051c5f8a6c5be151de5b2bd58f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-c-representation&quot;&gt;C&lt;/code&gt; Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe7f8f8cbbf771865519c2bb3d21bb5f521d891" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg-attribute&quot;&gt;cfg&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572d131266eef7422234c8cd8f4bf975d532a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg-macro&quot;&gt;cfg&lt;/code&gt; macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff73ca7cbd9ceded9b08042dee3a7e44286d5879" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg_attr-attribute&quot;&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab454a301e64c91054b75436344fb463ed4e31a" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cold-attribute&quot;&gt;cold&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3918f7c748b8a6de02591e90a158be55e179161" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-crate_name-attribute&quot;&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56779e684809e370ff842b9fd00e8e8533305b15" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-deprecated-attribute&quot;&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d264c9c886b4e7e93efe14011caf84a4cb0f8edc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-export_name-attribute&quot;&gt;export_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64953382ec25ebff3523c686f871b6cac0e50ffe" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-global_allocator-attribute&quot;&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71beea8a8240cee1b864ee8a097da9cb395a0451" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-ignore-attribute&quot;&gt;ignore&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e444fdfbdbbdaea724f409a0908c1ddaf47280" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-inline-attribute&quot;&gt;inline&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f91b9733dfb285998974fd7a3ed63a6997485d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">该 &lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; 特质和 &lt;code&gt;next&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="289229034807d95c3121d3bcf9cb7e25c1ac9ef2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link-attribute&quot;&gt;link&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf19b8ac8c37c88b76bf5924f5303e2d1b3cbfc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link_name-attribute&quot;&gt;link_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fca57741dda84795b52faabc81edaee2bb29077" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link_section-attribute&quot;&gt;link_section&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b70af9354cb75b7660a9b63a471bca4708883" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-macro_use-attribute&quot;&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479b4a692bc6c43f38d4737f51dec06b4e143a16" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt; Control Flow Operator</source>
          <target state="translated">在 &lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt; 的控制流程操作工</target>
        </trans-unit>
        <trans-unit id="3764cbd865c70d966aece7af300dfa7f637fe423" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-must_use-attribute&quot;&gt;must_use&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f1e16c1f0bc3e100253f9a6db177a6d4101ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_builtins-attribute&quot;&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc45c323650c2f34949e4b642c8e1bc1d4214794" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_link-attribute&quot;&gt;no_link&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12971ae998085805bad575f162d256452bcc1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_main-attribute&quot;&gt;no_main&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f55be277b4754e64848202241f85fe626641b3d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_mangle-attribute&quot;&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5417fc07a4925f25ebbeb5f618a1275243378ced" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; Enum and Its Advantages Over Null Values</source>
          <target state="translated">该 &lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; 枚举和它所具有的优势空值</target>
        </trans-unit>
        <trans-unit id="456d9c623e0db72560e9d4ff7d18d6a3d51bb4a0" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-panic_handler-attribute&quot;&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f2fa5a516f880089540c2827decd01d5a6e7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-path-attribute&quot;&gt;path&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272c0059788508ea23a5913dedfc781999a4329c" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-proc_macro-crate&quot;&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1850ba5995c1ec62eca62cf6b54da74c57b2f08" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-recursion_limit-attribute&quot;&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7debe8457b97e78697481f2ab2a13b2dce10763" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-should_panic-attribute&quot;&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93213a38ad3b67a68894b916ca83c68efaaa5823" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt; Type</source>
          <target state="translated">该 &lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="1fa123d3091c3f529b13b66733146b6cc074b9ee" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-target_feature-attribute&quot;&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec1dda37a4f697fee6a707ed0b667ec2bc1a23e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-test-attribute&quot;&gt;test&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf59ceebdbbaa090bce70ec65f673058503cd1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-track_caller-attribute&quot;&gt;track_caller&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad072e3ed2e5bdacb782947af3c6085d2383d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-transparent-representation&quot;&gt;transparent&lt;/code&gt; Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222c253464f70dc2d46508fef9bded38b979180e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-type_length_limit-attribute&quot;&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b350e27ebb9ddb5535abd7bc5f0b158500f6c7ea" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-used-attribute&quot;&gt;used&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b55666424bcbda4791627f5d3c1a25c9fd2797" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-windows_subsystem-attribute&quot;&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844971eb58988950f234035bf3b738d18df15983" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!&lt;/code&gt; type, also called &quot;never&quot;.</source>
          <target state="translated">该 &lt;code&gt;!&lt;/code&gt; 类型，也称为&amp;ldquo;从不&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1959101a4f878a742e6d622df58125da3c9ee8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#![feature]&lt;/code&gt; attribute specified an unknown feature.</source>
          <target state="translated">该 &lt;code&gt;#![feature]&lt;/code&gt; 属性指定一个未知的功能。</target>
        </trans-unit>
        <trans-unit id="6772d2ae0b060a250746d33cd174746c466f1400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation on the tests module tells Rust to compile and run the test code only when you run &lt;code&gt;cargo test&lt;/code&gt;, not when you run &lt;code&gt;cargo build&lt;/code&gt;. This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You&amp;rsquo;ll see that because integration tests go in a different directory, they don&amp;rsquo;t need the &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation. However, because unit tests go in the same files as the code, you&amp;rsquo;ll use &lt;code&gt;#[cfg(test)]&lt;/code&gt; to specify that they shouldn&amp;rsquo;t be included in the compiled result.</source>
          <target state="translated">该 &lt;code&gt;#[cfg(test)]&lt;/code&gt; 的测试模块上的注解告诉锈编译只有当你运行运行测试代码 &lt;code&gt;cargo test&lt;/code&gt; ，而不是当您运行 &lt;code&gt;cargo build&lt;/code&gt; 。当您只想构建库时，这样可以节省编译时间，并且由于不包括测试，因此可以节省生成的编译工件中的空间。您会看到，因为集成测试位于另一个目录中，所以它们不需要 &lt;code&gt;#[cfg(test)]&lt;/code&gt; 批注。但是，由于单元测试与代码位于同一文件中，因此您将使用 &lt;code&gt;#[cfg(test)]&lt;/code&gt; 来指定不应将其包含在编译结果中。</target>
        </trans-unit>
        <trans-unit id="519f31417527ab16777c33990a8b19270d90ed97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute</source>
          <target state="translated">的 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="e73c0e75e8ab048b307c0488b5dbff0af69bd767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; can only be used once in a crate or its recursive dependencies.</source>
          <target state="translated">的 &lt;code&gt;#[global_allocator]&lt;/code&gt; 只能一次在一个箱子或它的递归依赖性使用。</target>
        </trans-unit>
        <trans-unit id="672159bbb94aa0ec135859c99523eca0ebc397f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[macro_export]&lt;/code&gt; annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can&amp;rsquo;t be brought into scope.</source>
          <target state="translated">的 &lt;code&gt;#[macro_export]&lt;/code&gt; 注释指示该宏应该可每当在其中定义宏的板条箱被带入范围。没有此注释，宏将无法进入范围。</target>
        </trans-unit>
        <trans-unit id="859ec264725730980afa9483dd83d3f313613cc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(C)]&lt;/code&gt; attribute can only be placed on structs and enums.</source>
          <target state="translated">的 &lt;code&gt;#[repr(C)]&lt;/code&gt; 属性只能被放置在结构和枚举。</target>
        </trans-unit>
        <trans-unit id="20ce08781d178cc7ecc1d0ee2405f13954a27792" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(packed)]&lt;/code&gt; and &lt;code&gt;#[repr(simd)]&lt;/code&gt; attributes only work on structs.</source>
          <target state="translated">该 &lt;code&gt;#[repr(packed)]&lt;/code&gt; 和 &lt;code&gt;#[repr(simd)]&lt;/code&gt; 在结构属性唯一的工作。</target>
        </trans-unit>
        <trans-unit id="37e64d7cdeff0fe84feb89e7cacb8aa07bcc4dd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(u8)]&lt;/code&gt;, &lt;code&gt;#[repr(i16)]&lt;/code&gt;, etc attributes only work on enums.</source>
          <target state="translated">的 &lt;code&gt;#[repr(u8)]&lt;/code&gt; ， &lt;code&gt;#[repr(i16)]&lt;/code&gt; 等上枚举属性唯一的工作。</target>
        </trans-unit>
        <trans-unit id="c9b512964c382c5f5d5e0080e7203c876528ceb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</source>
          <target state="translated">的 &lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; 属性，可以指定用于当一个特定性状上不放置在一个位置，需要该性状的类型实现了自定义的错误消息。例如，当编译以下代码时：</target>
        </trans-unit>
        <trans-unit id="910d7829ddf09eb2fc4a2ff115280a7e351c19be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[simd]&lt;/code&gt; attribute can only be applied to non empty tuple structs, because it doesn't make sense to try to use SIMD operations when there are no values to operate on.</source>
          <target state="translated">该 &lt;code&gt;#[simd]&lt;/code&gt; 属性只能应用于非空的元组结构，因为它没有意义的尝试使用SIMD操作时，有没有值进行操作。</target>
        </trans-unit>
        <trans-unit id="20a3879322df478a4cc556128e471d1c66adae12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[unwind]&lt;/code&gt; attribute should be used as follows:</source>
          <target state="translated">的 &lt;code&gt;#[unwind]&lt;/code&gt; 属性应该被使用如下：</target>
        </trans-unit>
        <trans-unit id="98359d44655df527d34cb1e33db3c37a01e294d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0afa92240bade4867a8d2b0fc7bc387cff228f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="translated">的 &lt;code&gt;&amp;amp;&lt;/code&gt; （共享借）和 &lt;code&gt;&amp;amp;mut&lt;/code&gt; （可变借）运算符是一元前缀运算符。当应用于&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;位置表达式时&lt;/a&gt;，此表达式会生成对该值所引用位置的引用（指针）。在参考期间，存储位置也会置于借入状态。对于共享借用（ &lt;code&gt;&amp;amp;&lt;/code&gt; ），这意味着该位置可能不会发生突变，但可以再次读取或共享。对于可变借位（ &lt;code&gt;&amp;amp;mut&lt;/code&gt; ），在借位到期之前，无法以任何方式访问该位置。 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 在可变的位置表达式上下文中评估其操作数。如果将 &lt;code&gt;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 运算符应用于&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;值表达式&lt;/a&gt;，然后创建一个&lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;临时值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="289f7ac6e65862e6021cefdfd8637885846add32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; indicates that this argument is a &lt;em&gt;reference&lt;/em&gt;, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust&amp;rsquo;s major advantages is how safe and easy it is to use references. You don&amp;rsquo;t need to know a lot of those details to finish this program. For now, all you need to know is that like variables, references are immutable by default. Hence, you need to write &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; rather than &lt;code&gt;&amp;amp;guess&lt;/code&gt; to make it mutable. (Chapter 4 will explain references more thoroughly.)</source>
          <target state="translated">在 &lt;code&gt;&amp;amp;&lt;/code&gt; 表示，这种说法是一个&lt;em&gt;参考&lt;/em&gt;，它给你一个方法，让数据的代码访问一片多个部分，而无需将数据复制到内存中多次。引用是一个复杂的功能，Rust的主要优点之一是使用引用的安全性和简便性。您不需要了解很多这些细节即可完成此程序。现在，您只需要知道变量就像变量一样，默认情况下引用是不可变的。因此，您需要编写 &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;guess&lt;/code&gt; 使其可变。（第4章将更全面地解释参考资料。）</target>
        </trans-unit>
        <trans-unit id="0ba71ec6a87d61177d25877a820fc83d9405b11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;s1&lt;/code&gt; syntax lets us create a reference that &lt;em&gt;refers&lt;/em&gt; to the value of &lt;code&gt;s1&lt;/code&gt; but does not own it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.</source>
          <target state="translated">在 &lt;code&gt;&amp;amp;s1&lt;/code&gt; 的语法让我们创建一个基准&lt;em&gt;是指&lt;/em&gt;它的值 &lt;code&gt;s1&lt;/code&gt; 但不拥有它。因为它不拥有它，所以当引用超出范围时，它所指向的值将不会被删除。</target>
        </trans-unit>
        <trans-unit id="ac2092b7195c0e20492c6630d5e4fa162bb49bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type guarantees that its contents are UTF-8, and so we can compare the length it would take if each code point was represented as a &lt;code&gt;char&lt;/code&gt; vs in the &lt;code&gt;&amp;amp;str&lt;/code&gt; itself:</source>
          <target state="translated">所述 &lt;code&gt;&amp;amp;str&lt;/code&gt; 型保证其内容是UTF-8，所以我们可以比较长，将采取如果每个码点被描绘成 &lt;code&gt;char&lt;/code&gt; 在VS &lt;code&gt;&amp;amp;str&lt;/code&gt; 的本身：</target>
        </trans-unit>
        <trans-unit id="9573f9c210e855e348b2b66cefde61b52fa3eea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type is one of the two main string types, the other being &lt;code&gt;String&lt;/code&gt;. Unlike its &lt;code&gt;String&lt;/code&gt; counterpart, its contents are borrowed.</source>
          <target state="translated">所述 &lt;code&gt;&amp;amp;str&lt;/code&gt; 类型是两种主要串类型中的一种，另一种是 &lt;code&gt;String&lt;/code&gt; 。与 &lt;code&gt;String&lt;/code&gt; 对应项不同，它的内容是借来的。</target>
        </trans-unit>
        <trans-unit id="9dd45416e37868ecd085972d08ce3b564e5e5995" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; syntax tells the shell to write the contents of standard output to &lt;em&gt;output.txt&lt;/em&gt; instead of the screen. We didn&amp;rsquo;t see the error message we were expecting printed to the screen, so that means it must have ended up in the file. This is what &lt;em&gt;output.txt&lt;/em&gt; contains:</source>
          <target state="translated">所述 &lt;code&gt;&amp;gt;&lt;/code&gt; 语法告诉shell到标准输出的内容写入到&lt;em&gt;output.txt的&lt;/em&gt;，而不是在屏幕上。我们没有在屏幕上看到我们期望的错误消息，因此这意味着该错误消息必须已存在于文件中。这是&lt;em&gt;output.txt&lt;/em&gt;包含的内容：</target>
        </trans-unit>
        <trans-unit id="b005addd17171fe396053ec0c62812c2c97cade4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; syntax is a feature of Rust we haven&amp;rsquo;t talked about yet. It&amp;rsquo;s a generic type parameter, and we&amp;rsquo;ll cover generics in more detail in Chapter 10. For now, all you need to know is that &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; means the &lt;code&gt;Some&lt;/code&gt; variant of the &lt;code&gt;Option&lt;/code&gt; enum can hold one piece of data of any type. Here are some examples of using &lt;code&gt;Option&lt;/code&gt; values to hold number types and string types:</source>
          <target state="translated">该 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 语法，我们还没有谈到尚锈的特点。这是一个泛型类型参数，我们将在第10章中更详细地介绍泛型。现在，您只需要知道 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 表示 &lt;code&gt;Option&lt;/code&gt; 枚举的 &lt;code&gt;Some&lt;/code&gt; 变体可以容纳任何类型的数据。以下是一些使用 &lt;code&gt;Option&lt;/code&gt; 值保存数字类型和字符串类型的示例：</target>
        </trans-unit>
        <trans-unit id="0e8f2a70b6f25c55e2febf941fcc1166aa49e75b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'static&lt;/code&gt; constraint means that the closure and its return value must have a lifetime of the whole program execution. The reason for this is that threads can &lt;code&gt;detach&lt;/code&gt; and outlive the lifetime they have been created in. Indeed if the thread, and by extension its return value, can outlive their caller, we need to make sure that they will be valid afterwards, and since we &lt;em&gt;can't&lt;/em&gt; know when it will return we need to have them valid as long as possible, that is until the end of the program, hence the &lt;code&gt;'static&lt;/code&gt; lifetime.</source>
          <target state="translated">在 &lt;code&gt;'static&lt;/code&gt; 约束手段，封闭和它的返回值必须在整个程序执行的寿命。这样做的原因是线程可以 &lt;code&gt;detach&lt;/code&gt; 并超过创建它们的生命周期。确实，如果线程及其扩展值可以超过调用者的寿命，那么我们需要确保它们之后才有效，并且我们&lt;em&gt;不&lt;/em&gt;知道何时返回，我们需要使它们尽可能长的有效，直到程序结束，因此才是 &lt;code&gt;'static&lt;/code&gt; 生命周期&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d507c32a06112cec989a75204d96602b968865dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type has exactly one value &lt;code&gt;()&lt;/code&gt;, and is used when there is no other meaningful value that could be returned. &lt;code&gt;()&lt;/code&gt; is most commonly seen implicitly: functions without a &lt;code&gt;-&amp;gt; ...&lt;/code&gt; implicitly have return type &lt;code&gt;()&lt;/code&gt;, that is, these are equivalent:</source>
          <target state="translated">在 &lt;code&gt;()&lt;/code&gt; 类型具有一个值 &lt;code&gt;()&lt;/code&gt; ，并且当存在可能被返回任何其它有意义的值被使用。 &lt;code&gt;()&lt;/code&gt; 是最常见的隐式视图：不带 &lt;code&gt;-&amp;gt; ...&lt;/code&gt; 函数隐式具有返回类型 &lt;code&gt;()&lt;/code&gt; ，即，这些等效：</target>
        </trans-unit>
        <trans-unit id="e3861dba93432d9d5236ce5338f7751eb3d446a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, also called &quot;unit&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7f39bcbd9c29a0b11698eda466dd66f20fff6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, sometimes called &quot;unit&quot; or &quot;nil&quot;.</source>
          <target state="translated">在 &lt;code&gt;()&lt;/code&gt; 的类型，有时被称为&amp;ldquo;单元&amp;rdquo;或&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="918cd095e0c314aaf612bef93955c593d22df666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(*m)&lt;/code&gt; dereferences the &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into a &lt;code&gt;String&lt;/code&gt;. Then the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[..]&lt;/code&gt; take a string slice of the &lt;code&gt;String&lt;/code&gt; that is equal to the whole string to match the signature of &lt;code&gt;hello&lt;/code&gt;. The code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.</source>
          <target state="translated">的 &lt;code&gt;(*m)&lt;/code&gt; 取消引用 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 成 &lt;code&gt;String&lt;/code&gt; 。然后 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;[..]&lt;/code&gt; 取 &lt;code&gt;String&lt;/code&gt; 的字符串切片，该字符串切片等于整个字符串，以匹配 &lt;code&gt;hello&lt;/code&gt; 的签名。带有反引用强制的代码更难以阅读，编写和理解，其中涉及所有这些符号。 Deref强制使Rust可以为我们自动处理这些转换。</target>
        </trans-unit>
        <trans-unit id="dceab58b2710b9293ff102afe19580771458da84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; (dereference) operator is also a unary prefix operator. When applied to a &lt;a href=&quot;../types/pointer&quot;&gt;pointer&lt;/a&gt; it denotes the pointed-to location. If the expression is of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, and is either a local variable, a (nested) field of a local variable or is a mutable &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, then the resulting memory location can be assigned to. Dereferencing a raw pointer requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;*&lt;/code&gt; （反引用）操作符也是一元前缀运算符。当应用于&lt;a href=&quot;../types/pointer&quot;&gt;指针时，&lt;/a&gt;它表示指向的位置。如果表达式的类型为 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; ，或者是局部变量，局部变量的（嵌套的）字段或者是可变的&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;位置表达式&lt;/a&gt;，那么可以将结果存储位置分配给它。取消引用原始指针需要 &lt;code&gt;unsafe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9081a0fc77deca2ae1677facd10e7e74970f88a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; syntax is also valid with trait bounds on generic types:</source>
          <target state="translated">本 &lt;code&gt;+&lt;/code&gt; 语法也与泛型类型的特征界限有效：</target>
        </trans-unit>
        <trans-unit id="afa4c918a009f5cfb91d99e9fea97354edfccd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; type operator was used in an ambiguous context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7d56124b7814800cfa939450d0c6d38a399da8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operators may be composed with the &lt;code&gt;=&lt;/code&gt; operator. The expression &lt;code&gt;place_exp OP= value&lt;/code&gt; is equivalent to &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt;. For example, &lt;code&gt;x = x + 1&lt;/code&gt; may be written as &lt;code&gt;x += 1&lt;/code&gt;. Any such expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;. These operators can all be overloaded using the trait with the same name as for the normal operation followed by 'Assign', for example, &lt;code&gt;std::ops::AddAssign&lt;/code&gt; is used to overload &lt;code&gt;+=&lt;/code&gt;. As with &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;place_expr&lt;/code&gt; must be a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 运算符可以由 &lt;code&gt;=&lt;/code&gt; 运算符组成。表达式 &lt;code&gt;place_exp OP= value&lt;/code&gt; 等效于 &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt; 。例如， &lt;code&gt;x = x + 1&lt;/code&gt; 可以写成 &lt;code&gt;x += 1&lt;/code&gt; 。任何此类表达式始终具有&lt;a href=&quot;../types/tuple&quot;&gt; &lt;code&gt;unit&lt;/code&gt; 类型&lt;/a&gt;。这些操作符都可以使用具有与正常操作相同名称的特征来重载，例如后跟&amp;ldquo; Assign&amp;rdquo;， &lt;code&gt;std::ops::AddAssign&lt;/code&gt; 用于重载 &lt;code&gt;+=&lt;/code&gt; 。与 &lt;code&gt;=&lt;/code&gt; 一样， &lt;code&gt;place_expr&lt;/code&gt; 必须是一个&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;位置表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a770a23638a823405304b5862ae9b043051acefe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8565fcc01087bd00c830a709f76c89a8bec0ee11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="translated">该 &lt;code&gt;...&lt;/code&gt; 语法允许我们以匹配值的包含范围。在以下代码中，当模式与范围内的任何值匹配时，该机械臂将执行：</target>
        </trans-unit>
        <trans-unit id="a4afeb6b704f2eeee4511dc907c8b58744889e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax is kept for backwards compatibility.</source>
          <target state="translated">该 &lt;code&gt;...&lt;/code&gt; 语法是为了向后兼容性。</target>
        </trans-unit>
        <trans-unit id="e2e1f03ffc70a6a254885658fe3c94afc796ca12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;..=&lt;/code&gt; operators will construct an object of one of the &lt;code&gt;std::ops::Range&lt;/code&gt; (or &lt;code&gt;core::ops::Range&lt;/code&gt;) variants, according to the following table:</source>
          <target state="translated">所述 &lt;code&gt;..&lt;/code&gt; 和 &lt;code&gt;..=&lt;/code&gt; 运营商将构造中的一个的对象 &lt;code&gt;std::ops::Range&lt;/code&gt; （或 &lt;code&gt;core::ops::Range&lt;/code&gt; ）变体，根据下表：</target>
        </trans-unit>
        <trans-unit id="92e96dedbdbf92f3e2e6464ed4a171437558a608" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; syntax is a &lt;code&gt;RangeFull&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;..&lt;/code&gt; 语法是 &lt;code&gt;RangeFull&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e498b96e1f982900a97ac68d2121f886fa57f814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc028c330bc0f9500e9f59b98e8ba94a546679b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeToInclusive&lt;/code&gt;:</source>
          <target state="translated">所述 &lt;code&gt;..=end&lt;/code&gt; 语法是一个 &lt;code&gt;RangeToInclusive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="06bff2e76574f65224a2d8263399ed02a85a5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..end&lt;/code&gt; syntax is a &lt;code&gt;RangeTo&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;..end&lt;/code&gt; 语法是 &lt;code&gt;RangeTo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e2942c55d614162c6590171ee52a6786d9039b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0 measured&lt;/code&gt; statistic is for benchmark tests that measure performance. Benchmark tests are, as of this writing, only available in nightly Rust. See &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;the documentation about benchmark tests&lt;/a&gt; to learn more.</source>
          <target state="translated">所 &lt;code&gt;0 measured&lt;/code&gt; 统计数据为0，用于衡量性能的基准测试。在撰写本文时，基准测试仅在每晚的Rust中提供。请参阅&lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;有关基准测试的文档&lt;/a&gt;以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="79584c510d0bdac6b79741ca275d743c77143fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="translated">在 &lt;code&gt;3&lt;/code&gt; 不再存在，因为它是为了消费，看看迭代应停止，但没有放回迭代器。</target>
        </trans-unit>
        <trans-unit id="e721998eb3ac8ff36164c3da054ad164e33f55c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;five&lt;/code&gt; is the function&amp;rsquo;s return value, which is why the return type is &lt;code&gt;i32&lt;/code&gt;. Let&amp;rsquo;s examine this in more detail. There are two important bits: first, the line &lt;code&gt;let x = five();&lt;/code&gt; shows that we&amp;rsquo;re using the return value of a function to initialize a variable. Because the function &lt;code&gt;five&lt;/code&gt; returns a &lt;code&gt;5&lt;/code&gt;, that line is the same as the following:</source>
          <target state="translated">该 &lt;code&gt;5&lt;/code&gt; 中 &lt;code&gt;five&lt;/code&gt; 是函数的返回值，这就是为什么返回类型为 &lt;code&gt;i32&lt;/code&gt; 。让我们更详细地研究一下。有两个重要的位：首先，该行 &lt;code&gt;let x = five();&lt;/code&gt; 表明我们正在使用函数的返回值来初始化变量。由于函数 &lt;code&gt;five&lt;/code&gt; 返回 &lt;code&gt;5&lt;/code&gt; ，因此该行与以下内容相同：</target>
        </trans-unit>
        <trans-unit id="f64d85c43f38ffb1d9f69e7f8ec2961df3c8d6da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; syntax in the &lt;code&gt;::new&lt;/code&gt; line indicates that &lt;code&gt;new&lt;/code&gt; is an &lt;em&gt;associated function&lt;/em&gt; of the &lt;code&gt;String&lt;/code&gt; type. An associated function is implemented on a type, in this case &lt;code&gt;String&lt;/code&gt;, rather than on a particular instance of a &lt;code&gt;String&lt;/code&gt;. Some languages call this a &lt;em&gt;static method&lt;/em&gt;.</source>
          <target state="translated">的 &lt;code&gt;::&lt;/code&gt; 语法在 &lt;code&gt;::new&lt;/code&gt; 行指示 &lt;code&gt;new&lt;/code&gt; 是一个&lt;em&gt;相关联的功能&lt;/em&gt;的的 &lt;code&gt;String&lt;/code&gt; 类型。相关联的功能的类型来实现，在这种情况下 &lt;code&gt;String&lt;/code&gt; ，而不是在一个特定实例 &lt;code&gt;String&lt;/code&gt; 。一些语言将其称为&lt;em&gt;静态方法&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6c666ec2c7e67dbab00bbae26838dd52620a7c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; token is required before the opening &lt;code&gt;&amp;lt;&lt;/code&gt; for generic arguments to avoid ambiguity with the less-than operator. This is colloquially known as &quot;turbofish&quot; syntax.</source>
          <target state="translated">的 &lt;code&gt;::&lt;/code&gt; 令牌开口之前所需 &lt;code&gt;&amp;lt;&lt;/code&gt; 仿制参数以避免歧义与小于运算符。俗称&amp;ldquo; turbofish&amp;rdquo;语法。</target>
        </trans-unit>
        <trans-unit id="973f4c6b5b84dfca6c5a6d4e2198053b9adfe1f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function can be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec4c0c2491bd5a54898bf44aa756701f4e9b5fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can only be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function must be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;?&lt;/code&gt; 运算符只能在返回类型为 &lt;code&gt;Result&lt;/code&gt; 的函数中使用，因为它的定义与清单9-6中定义的 &lt;code&gt;match&lt;/code&gt; 表达式的工作方式相同。所述的部分 &lt;code&gt;match&lt;/code&gt; ，需要返回类型 &lt;code&gt;Result&lt;/code&gt; 是 &lt;code&gt;return Err(e)&lt;/code&gt; ，因此，函数的返回类型必须是 &lt;code&gt;Result&lt;/code&gt; 为与此兼容 &lt;code&gt;return&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd74ffef5a8c90c3fd4d6d76e29ea8086760c062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator eliminates a lot of boilerplate and makes this function&amp;rsquo;s implementation simpler. We could even shorten this code further by chaining method calls immediately after the &lt;code&gt;?&lt;/code&gt;, as shown in Listing 9-8.</source>
          <target state="translated">的 &lt;code&gt;?&lt;/code&gt; 操作员省去了很多样板，并使此功能的实现更简单。我们甚至可以通过在 &lt;code&gt;?&lt;/code&gt; 之后立即链接方法调用来进一步缩短此代码。，如清单9-8所示。</target>
        </trans-unit>
        <trans-unit id="69d45072228b4f483bc2426682521ed37346faf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator was added to replace &lt;code&gt;try!&lt;/code&gt; and should be used instead. Furthermore, &lt;code&gt;try&lt;/code&gt; is a reserved word in Rust 2018, so if you must use it, you will need to use the &lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;raw-identifier syntax&lt;/a&gt;: &lt;code&gt;r#try&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;?&lt;/code&gt; 运算符被添加到替换 &lt;code&gt;try!&lt;/code&gt; 并且应改为使用。此外， &lt;code&gt;try&lt;/code&gt; 是Rust 2018中的保留字，因此如果必须使用它，则需要使用&lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;raw-identifier语法&lt;/a&gt;： &lt;code&gt;r#try&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c02b9d3c4349fb0a9b0da69a54ee8f956959e334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; placed after a &lt;code&gt;Result&lt;/code&gt; value is defined to work in almost the same way as the &lt;code&gt;match&lt;/code&gt; expressions we defined to handle the &lt;code&gt;Result&lt;/code&gt; values in Listing 9-6. If the value of the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt;, the value inside the &lt;code&gt;Ok&lt;/code&gt; will get returned from this expression, and the program will continue. If the value is an &lt;code&gt;Err&lt;/code&gt;, the &lt;code&gt;Err&lt;/code&gt; will be returned from the whole function as if we had used the &lt;code&gt;return&lt;/code&gt; keyword so the error value gets propagated to the calling code.</source>
          <target state="translated">的 &lt;code&gt;?&lt;/code&gt; 在定义 &lt;code&gt;Result&lt;/code&gt; 值之后放置的代码，其工作方式 &lt;code&gt;match&lt;/code&gt; 我们定义为处理清单9-6中的 &lt;code&gt;Result&lt;/code&gt; 值的匹配表达式几乎相同。如果值 &lt;code&gt;Result&lt;/code&gt; 是 &lt;code&gt;Ok&lt;/code&gt; ，内部值 &lt;code&gt;Ok&lt;/code&gt; 将得到该表达式返回，并计划将继续进行。如果该值是一个 &lt;code&gt;Err&lt;/code&gt; ，该 &lt;code&gt;Err&lt;/code&gt; 会从整体功能，如果我们使用了返回 &lt;code&gt;return&lt;/code&gt; 关键字所以错误值被传播到调用代码。</target>
        </trans-unit>
        <trans-unit id="1dcf74da2de6e2e77e988e297d47588fe8eb0ad5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">由于多种原因， &lt;code&gt;Alloc&lt;/code&gt; 特质是 &lt;code&gt;unsafe&lt;/code&gt; 特质，实施者必须确保遵守以下合同：</target>
        </trans-unit>
        <trans-unit id="98e48446e54082f0c926a4f9b0d797094660f773" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocErr&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="translated">该 &lt;code&gt;AllocErr&lt;/code&gt; 错误表示分配失败给定的输入参数与这个分配器结合时，可能是由于资源枯竭，或者有些不妥。</target>
        </trans-unit>
        <trans-unit id="40c7890578f6b7272b5ec64894b3d7a1fbafa432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocError&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15f84d510941143cdca2ea70c5b85337d8cfce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Binary&lt;/code&gt; trait should format its output as a number in binary.</source>
          <target state="translated">该 &lt;code&gt;Binary&lt;/code&gt; 特质应在其输出格式为二进制的数字。</target>
        </trans-unit>
        <trans-unit id="379b6b1f35d3ee950871663ac9c0d0834cb49cc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;...&amp;gt;&lt;/code&gt; ensures that the result is of known size, and the pin is required to keep it in the same place in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e3077926ddb39580746ea9c9fb509f4ede0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is a smart pointer because it implements the &lt;code&gt;Deref&lt;/code&gt; trait, which allows &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; values to be treated like references. When a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the &lt;code&gt;Drop&lt;/code&gt; trait implementation. Let&amp;rsquo;s explore these two traits in more detail. These two traits will be even more important to the functionality provided by the other smart pointer types we&amp;rsquo;ll discuss in the rest of this chapter.</source>
          <target state="translated">的 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 类型是一个智能指针因为它实现了 &lt;code&gt;Deref&lt;/code&gt; 性状，这允许 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 值以相同的附图标记进行处理。当 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 值超出范围时，由于 &lt;code&gt;Drop&lt;/code&gt; trait实现的原因，该Box指向的堆数据也会被清除。让我们更详细地探讨这两个特征。对于我们将在本章其余部分讨论的其他智能指针类型提供的功能，这两个特征将更加重要。</target>
        </trans-unit>
        <trans-unit id="66f94ad31e24eabd73aee0f8f7b4d3256d1ad7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type in the same way. We&amp;rsquo;ll also define a &lt;code&gt;new&lt;/code&gt; function to match the &lt;code&gt;new&lt;/code&gt; function defined on &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 型最终定义为具有一个元素的元组结构，因此清单15-8限定 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 以相同的方式类型。我们也将定义一个 &lt;code&gt;new&lt;/code&gt; 功能，以符合 &lt;code&gt;new&lt;/code&gt; 定义的功能 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf6505b6927d963f13c67732403dd5931ac1ed9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a &lt;em&gt;trait object&lt;/em&gt;, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="translated">该 &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; 类型称为&lt;em&gt;特征的对象&lt;/em&gt;，我们将在讨论&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;是允许不同类型的值使用特质对象&amp;rdquo;&lt;/a&gt;在第17章一节，现在，你可以阅读 &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; 到表示&amp;ldquo;任何类型的错误&amp;rdquo;。使用 &lt;code&gt;?&lt;/code&gt; 在具有此返回类型的 &lt;code&gt;main&lt;/code&gt; 函数中是允许的。</target>
        </trans-unit>
        <trans-unit id="f421012dfbbefb54564368d8001a12741e0df3e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a trait object, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da298387c32437955972d3bd8b7791a6a295347" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1691172593fd486c5eabaf315f65ace8dbf6dcde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="translated">该 &lt;code&gt;BufReader&lt;/code&gt; 结构增加了缓冲以任何读者。</target>
        </trans-unit>
        <trans-unit id="258a1854757eccfe175a683df1ba477ca28eb2bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; Representation</source>
          <target state="translated">该 &lt;code&gt;C&lt;/code&gt; 表示</target>
        </trans-unit>
        <trans-unit id="13bde6b705c6f0c548e0105a8252725ac6ce4d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation for items has a defined layout. With this layout, the size of items is also stable as long as all fields have a stable size.</source>
          <target state="translated">项目的 &lt;code&gt;C&lt;/code&gt; 表示形式具有已定义的布局。使用此布局，只要所有字段的大小都稳定，则项目的大小也将保持稳定。</target>
        </trans-unit>
        <trans-unit id="51da5ab6258546c0e07e79893a79989cd376412d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation is designed for dual purposes. One purpose is for creating types that are interoperable with the C Language. The second purpose is to create types that you can soundly perform operations on that rely on data layout such as reinterpreting values as a different type.</source>
          <target state="translated">该 &lt;code&gt;C&lt;/code&gt; 表示是专门为双重目的。目的之一是创建可与C语言互操作的类型。第二个目的是创建可以依靠数据布局可靠地执行操作的类型，例如将值重新解释为其他类型。</target>
        </trans-unit>
        <trans-unit id="d3b29c11032bb6739237ad8f95e6e66861078b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher::new&lt;/code&gt; function takes a generic parameter &lt;code&gt;T&lt;/code&gt;, which we&amp;rsquo;ve defined as having the same trait bound as the &lt;code&gt;Cacher&lt;/code&gt; struct. Then &lt;code&gt;Cacher::new&lt;/code&gt; returns a &lt;code&gt;Cacher&lt;/code&gt; instance that holds the closure specified in the &lt;code&gt;calculation&lt;/code&gt; field and a &lt;code&gt;None&lt;/code&gt; value in the &lt;code&gt;value&lt;/code&gt; field, because we haven&amp;rsquo;t executed the closure yet.</source>
          <target state="translated">该 &lt;code&gt;Cacher::new&lt;/code&gt; 功能需要一个泛型参数 &lt;code&gt;T&lt;/code&gt; ，我们已经定义为具有约束为同一性状 &lt;code&gt;Cacher&lt;/code&gt; 结构。然后 &lt;code&gt;Cacher::new&lt;/code&gt; 回报 &lt;code&gt;Cacher&lt;/code&gt; 保存在指定的封闭实例 &lt;code&gt;calculation&lt;/code&gt; 领域和 &lt;code&gt;None&lt;/code&gt; 在值 &lt;code&gt;value&lt;/code&gt; 字段，因为我们还没有执行关闭呢。</target>
        </trans-unit>
        <trans-unit id="b4813a8ce2e935eef24c8392e81d63c3906c4494" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher&lt;/code&gt; struct has a &lt;code&gt;calculation&lt;/code&gt; field of the generic type &lt;code&gt;T&lt;/code&gt;. The trait bounds on &lt;code&gt;T&lt;/code&gt; specify that it&amp;rsquo;s a closure by using the &lt;code&gt;Fn&lt;/code&gt; trait. Any closure we want to store in the &lt;code&gt;calculation&lt;/code&gt; field must have one &lt;code&gt;u32&lt;/code&gt; parameter (specified within the parentheses after &lt;code&gt;Fn&lt;/code&gt;) and must return a &lt;code&gt;u32&lt;/code&gt; (specified after the &lt;code&gt;-&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;Cacher&lt;/code&gt; 结构有一个 &lt;code&gt;calculation&lt;/code&gt; 所述类型的字段 &lt;code&gt;T&lt;/code&gt; 。 &lt;code&gt;T&lt;/code&gt; 上的特征边界通过使用 &lt;code&gt;Fn&lt;/code&gt; 特征来指定它是闭包。我们要存储在 &lt;code&gt;calculation&lt;/code&gt; 字段中的任何闭包都必须具有一个 &lt;code&gt;u32&lt;/code&gt; 参数（在 &lt;code&gt;Fn&lt;/code&gt; 之后的括号内指定），并且必须返回 &lt;code&gt;u32&lt;/code&gt; （在 &lt;code&gt;-&amp;gt;&lt;/code&gt; 之后指定）。</target>
        </trans-unit>
        <trans-unit id="b2611487755ed0f487d8741cbb5ae43a528fa050" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CannotReallocInPlace&lt;/code&gt; error is used when &lt;code&gt;grow_in_place&lt;/code&gt; or &lt;code&gt;shrink_in_place&lt;/code&gt; were unable to reuse the given memory block for a requested layout.</source>
          <target state="translated">所述 &lt;code&gt;CannotReallocInPlace&lt;/code&gt; 当使用误差 &lt;code&gt;grow_in_place&lt;/code&gt; 或 &lt;code&gt;shrink_in_place&lt;/code&gt; 无法重新使用给定的存储块对于所请求的布局。</target>
        </trans-unit>
        <trans-unit id="66ff318ae517f73cd3f13be64857852133418c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait allows you to explicitly create a deep copy of a value, and the duplication process might involve running arbitrary code and copying heap data. See the &lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;&amp;ldquo;Ways Variables and Data Interact: Clone&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Clone&lt;/code&gt; 特性允许你明确地创建一个值的深层副本，并在复制过程可能涉及运行任意代码，并可复制堆数据。请参阅&lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;&amp;ldquo;方式变量和数据交互：克隆&amp;rdquo;&lt;/a&gt;一节中第4章的详细信息 &lt;code&gt;Clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad03569cf96b66590827b19ede2029d2fc0e960d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait for types that cannot be 'implicitly copied'.</source>
          <target state="translated">无法&amp;ldquo;隐式复制&amp;rdquo;的类型的&amp;ldquo; &lt;code&gt;Clone&lt;/code&gt; 特征。</target>
        </trans-unit>
        <trans-unit id="18eff9d7482bec9f52eb9a085d95c11254b36933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CoerceUnsized&lt;/code&gt; trait takes a struct type. Make sure the type you are providing to &lt;code&gt;CoerceUnsized&lt;/code&gt; is a struct with only the last field containing an unsized type.</source>
          <target state="translated">该 &lt;code&gt;CoerceUnsized&lt;/code&gt; 特质需要一个结构类型。确保您要提供给 &lt;code&gt;CoerceUnsized&lt;/code&gt; 的类型是一个结构，只有最后一个字段包含未定尺寸的类型。</target>
        </trans-unit>
        <trans-unit id="e548ae9701e88686017ab152887ae716380c763e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Config::new&lt;/code&gt; function definition</source>
          <target state="translated">在 &lt;code&gt;Config::new&lt;/code&gt; 功能定义</target>
        </trans-unit>
        <trans-unit id="501a0b9d21e10f396777e5d2959bafbe25f146ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variant will need the size of an &lt;code&gt;i32&lt;/code&gt; plus the space to store the box&amp;rsquo;s pointer data. The &lt;code&gt;Nil&lt;/code&gt; variant stores no values, so it needs less space than the &lt;code&gt;Cons&lt;/code&gt; variant. We now know that any &lt;code&gt;List&lt;/code&gt; value will take up the size of an &lt;code&gt;i32&lt;/code&gt; plus the size of a box&amp;rsquo;s pointer data. By using a box, we&amp;rsquo;ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a &lt;code&gt;List&lt;/code&gt; value. Figure 15-2 shows what the &lt;code&gt;Cons&lt;/code&gt; variant looks like now.</source>
          <target state="translated">该 &lt;code&gt;Cons&lt;/code&gt; 变体将需要一个规模 &lt;code&gt;i32&lt;/code&gt; 加上空间来存储箱的指针数据。在 &lt;code&gt;Nil&lt;/code&gt; 变形店的值，因此它需要比更小的空间 &lt;code&gt;Cons&lt;/code&gt; 变种。现在我们知道，任何 &lt;code&gt;List&lt;/code&gt; 值都将占用 &lt;code&gt;i32&lt;/code&gt; 的大小加上框的指针数据的大小。通过使用一个框，我们打破了无限的递归链，因此编译器可以确定存储 &lt;code&gt;List&lt;/code&gt; 值所需的大小。图15-2显示了 &lt;code&gt;Cons&lt;/code&gt; 变型现在的样子。</target>
        </trans-unit>
        <trans-unit id="a626d0216123ae4ac45161a1bdf7e2c4de5ee23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variants own the data they hold, so when we create the &lt;code&gt;b&lt;/code&gt; list, &lt;code&gt;a&lt;/code&gt; is moved into &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; owns &lt;code&gt;a&lt;/code&gt;. Then, when we try to use &lt;code&gt;a&lt;/code&gt; again when creating &lt;code&gt;c&lt;/code&gt;, we&amp;rsquo;re not allowed to because &lt;code&gt;a&lt;/code&gt; has been moved.</source>
          <target state="translated">该 &lt;code&gt;Cons&lt;/code&gt; 变型拥有其所持有的数据，所以当我们创建 &lt;code&gt;b&lt;/code&gt; 名单， &lt;code&gt;a&lt;/code&gt; 被移动到 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 拥有 &lt;code&gt;a&lt;/code&gt; 。然后，当我们在创建 &lt;code&gt;c&lt;/code&gt; 时尝试再次使用 &lt;code&gt;a&lt;/code&gt; 时，由于 &lt;code&gt;a&lt;/code&gt; 已被移动，因此我们不允许这样做。</target>
        </trans-unit>
        <trans-unit id="0ddcf60586798598b647a102cf947282e0f109f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Context&lt;/code&gt; of an asynchronous task.</source>
          <target state="translated">异步任务的 &lt;code&gt;Context&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2f260e119bb2a2221aaead7149c78bb8d75b87a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait allows you to duplicate a value by only copying bits stored on the stack; no arbitrary code is necessary. See the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Copy&lt;/code&gt; 特性，您可以通过仅复制存储在堆栈上的比特重复的值; 无需任何代码。请参阅&lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;堆栈的只读数据：复制&amp;rdquo;&lt;/a&gt;第4章一节的详细信息 &lt;code&gt;Copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6af89e2c9cf5d947b4b736850c9a97076811fab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait doesn&amp;rsquo;t define any methods to prevent programmers from overloading those methods and violating the assumption that no arbitrary code is being run. That way, all programmers can assume that copying a value will be very fast.</source>
          <target state="translated">该 &lt;code&gt;Copy&lt;/code&gt; 特性并没有定义任何方法来阻止程序员重载这些方法，违反假定不任意代码正在运行。这样，所有程序员都可以假定复制值将非常快。</target>
        </trans-unit>
        <trans-unit id="d9a9d9ddc02bc50daec8b0c1f2146daf65e918a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is implemented by default only on primitive types. If your type only contains primitive types, you'll be able to implement &lt;code&gt;Copy&lt;/code&gt; on it. Otherwise, it won't be possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="translated">该 &lt;code&gt;Copy&lt;/code&gt; 特点是很少需要; 实现 &lt;code&gt;Copy&lt;/code&gt; 的类型有可用的优化，这意味着您不必调用 &lt;code&gt;clone&lt;/code&gt; ，这使代码更加简洁。</target>
        </trans-unit>
        <trans-unit id="19e60de5e2cec4f66ffc273d83b18ba133a29961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which contains a field that doesn't implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1853088c8596ec738b63d0b306b0f2a10680d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which is neither a struct nor an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cc8d6ab49e3b2451486ee83ff4fdc2f0dab312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type with a &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="translated">该 &lt;code&gt;Counter&lt;/code&gt; 结构有一个字段中指定 &lt;code&gt;count&lt;/code&gt; 。该场拥有 &lt;code&gt;u32&lt;/code&gt; 值将继续跟踪我们在迭代从1到5的过程中，其中 &lt;code&gt;count&lt;/code&gt; ，因为我们要实施领域是私人 &lt;code&gt;Counter&lt;/code&gt; 来管理它的价值。该 &lt;code&gt;new&lt;/code&gt; 功能的强制始终在一个0值开始新的实例行为 &lt;code&gt;count&lt;/code&gt; 领域。</target>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="translated">在 &lt;code&gt;Debug&lt;/code&gt; 特性允许你打印一个类型的实例进行调试，让您和您使用其它类型的程序员可以在程序执行中的特定点检查一个实例。</target>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="translated">在 &lt;code&gt;Debug&lt;/code&gt; 特性使调试格式字符串格式化，这表明你加入 &lt;code&gt;:?&lt;/code&gt; 内 &lt;code&gt;{}&lt;/code&gt; 占位符。</target>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="translated">在 &lt;code&gt;Debug&lt;/code&gt; 特质是必需的，例如，在使用中的 &lt;code&gt;assert_eq!&lt;/code&gt; 宏。如果相等声明失败，此宏将打印作为参数指定的实例的值，以便程序员可以了解为什么两个实例不相等。</target>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Default::default&lt;/code&gt; 功能是结合常用的与所讨论的结构更新语法&lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;创建实例从其他实例用结构更新语法&amp;rdquo;&lt;/a&gt;第5章中部分可以自定义一个结构的几个字段，然后设置和使用其余字段的默认值，方法是使用 &lt;code&gt;..Default::default()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f7be30b5dee7044de3817ca4c87b66ab54682e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the &lt;code&gt;Default&lt;/code&gt; trait as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Default&lt;/code&gt; 特性允许你创建一个类型的默认值。派生 &lt;code&gt;Default&lt;/code&gt; 实现 &lt;code&gt;default&lt;/code&gt; 功能。 &lt;code&gt;default&lt;/code&gt; 函数的派生实现在类型的每个部分上调用 &lt;code&gt;default&lt;/code&gt; 函数，这意味着类型中的所有字段或值也必须实现 &lt;code&gt;Default&lt;/code&gt; 才能派生 &lt;code&gt;Default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="translated">类型的 &lt;code&gt;Default&lt;/code&gt; 特征可能具有有意义的默认值。</target>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;Default&lt;/code&gt; 当您使用方法性状需要 &lt;code&gt;unwrap_or_default&lt;/code&gt; 上 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 实例中，例如。如果 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 是 &lt;code&gt;None&lt;/code&gt; ，该方法 &lt;code&gt;unwrap_or_default&lt;/code&gt; 将返回的结果 &lt;code&gt;Default::default&lt;/code&gt; 为类型 &lt;code&gt;T&lt;/code&gt; 存储在 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="faec1eafc86ec050669e657d677254ae1cc5eb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait was derived on an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="translated">当前， &lt;code&gt;DispatchFromDyn&lt;/code&gt; 特质只能针对内置指针类型和作为它们周围的新型包装器的结构实现-也就是说，该结构必须仅具有一个字段（ &lt;code&gt;PhantomData&lt;/code&gt; 除外），并且该字段本身必须实现 &lt;code&gt;DispatchFromDyn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4511d27b8bd2f5f7b72a8b815a18a15df561075" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="translated">该 &lt;code&gt;DraftPost&lt;/code&gt; 结构有一个 &lt;code&gt;add_text&lt;/code&gt; 方法，因此我们可以添加文本 &lt;code&gt;content&lt;/code&gt; 和以前一样，但要注意 &lt;code&gt;DraftPost&lt;/code&gt; 没有一个 &lt;code&gt;content&lt;/code&gt; 定义的方法！因此，现在程序可以确保所有帖子均以草稿帖子开头，并且草稿帖子没有可供显示的内容。规避这些约束的任何尝试都将导致编译器错误。</target>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Drop&lt;/code&gt; 特点包括在前奏，所以我们并不需要把它纳入范围。我们在 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 上实现 &lt;code&gt;Drop&lt;/code&gt; 特性，并为调用 &lt;code&gt;println!&lt;/code&gt; 的 &lt;code&gt;drop&lt;/code&gt; 方法提供实现。。当您的类型实例超出范围时， &lt;code&gt;drop&lt;/code&gt; 函数的主体是放置要运行的任何逻辑的位置。我们在此处打印一些文本，以演示Rust何时调用 &lt;code&gt;drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="translated">该 &lt;code&gt;Eq&lt;/code&gt; 特质没有任何方法。其目的是表明每个带注释类型的值都等于其自身。该 &lt;code&gt;Eq&lt;/code&gt; 特质只能应用于类型也实现 &lt;code&gt;PartialEq&lt;/code&gt; ，虽然没有实现所有类型的 &lt;code&gt;PartialEq&lt;/code&gt; 可以实现 &lt;code&gt;Eq&lt;/code&gt; 。浮点数类型就是这样的一个例子：浮点数的实现表示非数字（ &lt;code&gt;NaN&lt;/code&gt; ）值的两个实例彼此不相等。</target>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="translated">该 &lt;code&gt;F&lt;/code&gt; 类型参数也有特质的约束 &lt;code&gt;Send&lt;/code&gt; 和寿命约束 &lt;code&gt;'static&lt;/code&gt; ，这是在我们的情况非常有用：我们需要 &lt;code&gt;Send&lt;/code&gt; 到封闭从一个线程转移到另一个和 &lt;code&gt;'static&lt;/code&gt; ，因为我们不知道该线程多久执行。让我们在 &lt;code&gt;ThreadPool&lt;/code&gt; 上创建一个 &lt;code&gt;execute&lt;/code&gt; 方法，该方法将采用以下类型的 &lt;code&gt;F&lt;/code&gt; 型泛型参数：</target>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;F&lt;/code&gt; 类型参数是我们关心这里的一个;在 &lt;code&gt;T&lt;/code&gt; 类型参数与返回值，而我们并不关心这一点。我们可以看到 &lt;code&gt;spawn&lt;/code&gt; 使用 &lt;code&gt;FnOnce&lt;/code&gt; 作为绑定到 &lt;code&gt;F&lt;/code&gt; 的特征。这可能也是我们想要的，因为我们最终将传递进入 &lt;code&gt;execute&lt;/code&gt; 的参数传递给 &lt;code&gt;spawn&lt;/code&gt; 。我们可以进一步确信 &lt;code&gt;FnOnce&lt;/code&gt; 是我们希望使用的，因为线程运行的请求将只执行该请求的关闭一次，它匹配的性状 &lt;code&gt;Once&lt;/code&gt; 在 &lt;code&gt;FnOnce&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">该 &lt;code&gt;Fn&lt;/code&gt; 性状是由标准库提供。所有闭包均实现至少一个特征： &lt;code&gt;Fn&lt;/code&gt; ， &lt;code&gt;FnMut&lt;/code&gt; 或 &lt;code&gt;FnOnce&lt;/code&gt; 。我们将在&lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;封闭性捕获环境&amp;rdquo;&lt;/a&gt;部分中讨论这些特征之间的区别；在此示例中，我们可以使用 &lt;code&gt;Fn&lt;/code&gt; 特性。</target>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="translated">执行错误处理时， &lt;code&gt;From&lt;/code&gt; 也非常有用。当构造一个可能失败的函数时，返回类型通常为 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 的形式。在 &lt;code&gt;From&lt;/code&gt; 通过允许函数返回封装多个错误类型单一的错误类型特点简化了错误处理。有关更多详细信息，请参见&amp;ldquo;示例&amp;rdquo;部分和&lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;该书&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="translated">从此函数返回的 &lt;code&gt;GeneratorState&lt;/code&gt; 枚举指示生成器在返回时处于什么状态。如果返回了 &lt;code&gt;Yielded&lt;/code&gt; 变量，则生成器已达到暂停点，并且已产生一个值。此状态下的生成器可在以后恢复。</target>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">该 &lt;code&gt;GlobalAlloc&lt;/code&gt; 特点是 &lt;code&gt;unsafe&lt;/code&gt; 的多种原因特质，和实现者必须确保他们遵守这些合同：</target>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Hash&lt;/code&gt; 性状可以拍摄到一个类型任意大小的的一个实例，并且该实例映射到使用散列函数固定大小的值。派生 &lt;code&gt;Hash&lt;/code&gt; 实现 &lt;code&gt;hash&lt;/code&gt; 方法。 &lt;code&gt;hash&lt;/code&gt; 方法的派生实现结合了在类型的每个部分上调用 &lt;code&gt;hash&lt;/code&gt; 的结果，这意味着所有字段或值还必须实现 &lt;code&gt;Hash&lt;/code&gt; 才能派生 &lt;code&gt;Hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="translated">所述 &lt;code&gt;Iterator&lt;/code&gt; 的性状具有许多与所述的标准库提供的默认的实现不同的方法; 您可以通过查看标准库API文档中有关 &lt;code&gt;Iterator&lt;/code&gt; 特性的信息来了解这些方法。其中一些方法在其定义中调用了 &lt;code&gt;next&lt;/code&gt; 方法，这就是为什么在实现 &lt;code&gt;Iterator&lt;/code&gt; trait 时需要实现 &lt;code&gt;next&lt;/code&gt; 方法的原因。</target>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Iterator&lt;/code&gt; 特质仅需要实现者定义一个方法：将 &lt;code&gt;next&lt;/code&gt; 方法，该方法在包裹在一个时间返回迭代器的一个项目 &lt;code&gt;Some&lt;/code&gt; ，并且当迭代结束时，返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="translated">该 &lt;code&gt;LinkedList&lt;/code&gt; 允许推动并在恒定的时间任一端弹出元件。</target>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;LowerExp&lt;/code&gt; 特点应设置其在科学记数法输出与小写 &lt;code&gt;e&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="translated">所述 &lt;code&gt;LowerHex&lt;/code&gt; 性状应在其输出格式化为十六进制的数，用 &lt;code&gt;a&lt;/code&gt; 通过 &lt;code&gt;f&lt;/code&gt; 小写。</target>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="translated">的 &lt;code&gt;Octal&lt;/code&gt; 性状应格式化于基-8-其为一个数字输出。</target>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 枚举是非常有用，它甚至包括在前奏; 您无需将其明确纳入范围。此外，它的变体也是如此：您可以直接使用 &lt;code&gt;Some&lt;/code&gt; 和 &lt;code&gt;None&lt;/code&gt; ，而无需使用 &lt;code&gt;Option::&lt;/code&gt; 前缀。的 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ENUM是仍然只是一个普通的枚举和 &lt;code&gt;Some(T)&lt;/code&gt; 和 &lt;code&gt;None&lt;/code&gt; 的类型的变体仍然 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="translated">该 &lt;code&gt;Option&lt;/code&gt; 类型。有关更多信息，请参见&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Ord&lt;/code&gt; 特质让你知道，注释类型的任何两个数值，一个有效的订货会存在。的 &lt;code&gt;Ord&lt;/code&gt; 特质实施 &lt;code&gt;cmp&lt;/code&gt; 方法，它返回一个 &lt;code&gt;Ordering&lt;/code&gt; ，而不是一个 &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; 因为有效的排序将始终是可能的。您只能将 &lt;code&gt;Ord&lt;/code&gt; 特性应用于也实现 &lt;code&gt;PartialOrd&lt;/code&gt; 和 &lt;code&gt;Eq&lt;/code&gt; 的类型（并且 &lt;code&gt;Eq&lt;/code&gt; 需要 &lt;code&gt;PartialEq&lt;/code&gt; ）。当结构和枚举衍生， &lt;code&gt;cmp&lt;/code&gt; 表现为派生执行同样的方式 &lt;code&gt;partial_cmp&lt;/code&gt; 确实有 &lt;code&gt;PartialOrd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="translated">将 &lt;code&gt;Orphan Check&lt;/code&gt; 状态，每一个特征实现必须要么满足下列条件：</target>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="translated">该 &lt;code&gt;PartialEq&lt;/code&gt; 特质可以让你比较一个类型的实例来检查平等和允许使用的 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="translated">该 &lt;code&gt;PartialEq&lt;/code&gt; 特质是必需的，例如，与使用的 &lt;code&gt;assert_eq!&lt;/code&gt; 宏，它需要能够比较一个类型的两个实例是否相等。</target>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;PartialOrd&lt;/code&gt; 特质可以让你比较一个类型的实例进行排序。实现 &lt;code&gt;PartialOrd&lt;/code&gt; 的类型可以与 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; 运算符一起使用。您只能将 &lt;code&gt;PartialOrd&lt;/code&gt; 特性应用于也实现 &lt;code&gt;PartialEq&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="translated">所述 &lt;code&gt;PartialOrd&lt;/code&gt; 性状是必需的，例如，对于 &lt;code&gt;gen_range&lt;/code&gt; 从方法 &lt;code&gt;rand&lt;/code&gt; 生成在由低值和高值所指定的范围内的随机值板条箱。</target>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="translated">该 &lt;code&gt;Pointer&lt;/code&gt; 特质应该格式化它作为一个内存位置输出。通常以十六进制表示。</target>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;Range&lt;/code&gt; &lt;code&gt;start..end&lt;/code&gt; 包含的所有值 &lt;code&gt;x &amp;gt;= start&lt;/code&gt; 和 &lt;code&gt;x &amp;lt; end&lt;/code&gt; 。除非 &lt;code&gt;start &amp;lt; end&lt;/code&gt; 否则它是空的。</target>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;RangeFrom&lt;/code&gt; &lt;code&gt;start..&lt;/code&gt; 包含的所有值 &lt;code&gt;x &amp;gt;= start&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;RangeInclusive&lt;/code&gt; &lt;code&gt;start..=end&lt;/code&gt; 包含的所有值 &lt;code&gt;x &amp;gt;= start&lt;/code&gt; 和 &lt;code&gt;x &amp;lt;= end&lt;/code&gt; 。除非 &lt;code&gt;start &amp;lt;= end&lt;/code&gt; 否则它为空。</target>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">所述 &lt;code&gt;RangeTo&lt;/code&gt; &lt;code&gt;..end&lt;/code&gt; 包含的所有值 &lt;code&gt;x &amp;lt; end&lt;/code&gt; 。它不能作为&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;因为它没有起点。</target>
        </trans-unit>
        <trans-unit id="0de78a1c773797166ef937a052ccd5e9331c867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">所述 &lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; 包含的所有值 &lt;code&gt;x &amp;lt;= end&lt;/code&gt; 。它不能作为&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;因为它没有起点。</target>
        </trans-unit>
        <trans-unit id="0729997e88bb0119e0af233dfbcdefc61396cf4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">该 &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; 语法是最地道的，因为它传达更明确的代码的含义。在上面的示例中，使用此语法可以更轻松地看到此代码正在创建新引用，而不是复制foo的全部内容。</target>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="translated">在 &lt;code&gt;Read&lt;/code&gt; 特质允许从源读取字节。</target>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="translated">所述 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 跟踪多少 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 智能指针当前是活动的。我们每次通话时间 &lt;code&gt;borrow&lt;/code&gt; 的 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 增加它的许多一成不变借入如何积极计数。当 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 值超出范围时，不可变借位的计数将减少一。就像编译时借用规则一样， &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 让我们在任何时间点都有许多不可变借用或一个可变借用。</target>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="translated">该 &lt;code&gt;RefCell&lt;/code&gt; 已经不可改变借来的，所以这不能失败。</target>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="translated">该 &lt;code&gt;RefCell&lt;/code&gt; 已经性情不定地借来的，所以这不能失败。</target>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="translated">该 &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; 被重复了很多。因此， &lt;code&gt;std::io&lt;/code&gt; 具有这种类型的别名声明：</target>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="translated">该 &lt;code&gt;Result&lt;/code&gt; 枚举超过两种类型，通用 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;E&lt;/code&gt; ，并且具有两个变体： &lt;code&gt;Ok&lt;/code&gt; ，保持类型的值 &lt;code&gt;T&lt;/code&gt; ，以及 &lt;code&gt;Err&lt;/code&gt; ，它保存类型的值 &lt;code&gt;E&lt;/code&gt; 。通过此定义，可以在我们有可能成功（返回某些 &lt;code&gt;T&lt;/code&gt; 类型的值）或失败（返回某种 &lt;code&gt;E&lt;/code&gt; 类型的错误）的操作的任何地方使用 &lt;code&gt;Result&lt;/code&gt; 枚举。实际上，这就是我们在清单9-3中打开文件所使用的文件，其中，当文件成功打开时， &lt;code&gt;T&lt;/code&gt; 填充为 &lt;code&gt;std::fs::File&lt;/code&gt; 类型，而E则填充为 &lt;code&gt;E&lt;/code&gt; 当打开文件时出现问题时，将其填充为 &lt;code&gt;std::io::Error&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="translated">的 &lt;code&gt;Result&lt;/code&gt; 的类型是&lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;枚举&lt;/em&gt;&lt;/a&gt;，通常被称为&lt;em&gt;枚举&lt;/em&gt;。枚举是可以具有一组固定值的类型，这些值称为枚举的&lt;em&gt;variants&lt;/em&gt;。第6章将更详细地介绍枚举。</target>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="translated">在 &lt;code&gt;Seek&lt;/code&gt; 性状提供可以的字节流内移动的光标。</target>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="translated">该 &lt;code&gt;Self&lt;/code&gt; 关键字是我们正在实施的特征或方法的类型的别名。特质对象必须是对象安全的，因为一旦使用了特征对象，Rust就不再知道实现该特征的具体类型。如果特征方法返回具体的 &lt;code&gt;Self&lt;/code&gt; 类型，但是特征对象忘记了 &lt;code&gt;Self&lt;/code&gt; 的确切类型，则该方法将无法使用原始的具体类型。使用特征时，使用具体类型参数填充的泛型类型参数也是如此：具体类型成为实现特征的类型的一部分。当通过使用trait对象而忘记了类型时，就无法知道用什么类型来填充泛型类型参数。</target>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="translated">所述 &lt;code&gt;Self&lt;/code&gt; 关键字表示当前类型，这可以解释为什么它只能一个IMPL，性状，或类型定义内部使用。它可以访问类型的关联项目：</target>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="translated">所述 &lt;code&gt;Self&lt;/code&gt; 关键字是一个IMPL，性状，或类型定义之外使用。</target>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="translated">该 &lt;code&gt;Self&lt;/code&gt; 项可以与类型正在实施更换。</target>
        </trans-unit>
        <trans-unit id="268068ec98ee8d589f1d0d25a4fa87cb52fefae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias &lt;code&gt;Self&lt;/code&gt;, other type aliases, or associated type projections resolving to the implementing type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="translated">的 &lt;code&gt;Send&lt;/code&gt; 标记性状表示该类型实施的所有权 &lt;code&gt;Send&lt;/code&gt; 可以在线程之间转移。几乎每种Rust类型都是 &lt;code&gt;Send&lt;/code&gt; ，但是有一些例外，包括 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; ：这不能 &lt;code&gt;Send&lt;/code&gt; 因为如果您克隆了 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值并尝试将克隆的所有权转让给另一个线程，则两个线程都可能会更新参考计数在同一时间。因此， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 被实现为在单线程情况下使用，您不想为此付出线程安全的性能损失。</target>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="translated">在 &lt;code&gt;Sized&lt;/code&gt; 特点是内置的编译器类型与在编译时已知常量大小特殊的特质。该特征会根据编译器的需要自动为类型实现，并且目前不允许为某个类型显式实现。</target>
        </trans-unit>
        <trans-unit id="faed9283b4f09789ea3439cf47c62be8b01765b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait was implemented explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="translated">该 &lt;code&gt;Some(5)&lt;/code&gt; 值不匹配的格局 &lt;code&gt;None&lt;/code&gt; ，所以我们继续到下一个手臂。</target>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="translated">该 &lt;code&gt;State&lt;/code&gt; 特质定义了不同的后国家共享的行为，和 &lt;code&gt;Draft&lt;/code&gt; ， &lt;code&gt;PendingReview&lt;/code&gt; 和 &lt;code&gt;Published&lt;/code&gt; 国家都将实施 &lt;code&gt;State&lt;/code&gt; 特质。目前，特征没有任何方法，我们将从仅定义&amp;ldquo; &lt;code&gt;Draft&lt;/code&gt; 状态开始，因为这是我们希望帖子开始的状态。</target>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="translated">该 &lt;code&gt;String&lt;/code&gt; 类型实现了 &lt;code&gt;Clone&lt;/code&gt; 特质，当我们调用的 &lt;code&gt;clone&lt;/code&gt; 方法上的一个实例 &lt;code&gt;String&lt;/code&gt; 我们回来的实例 &lt;code&gt;String&lt;/code&gt; 。类似地，如果我们在 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的实例上调用 &lt;code&gt;clone&lt;/code&gt; ，则会取回 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的实例。 &lt;code&gt;clone&lt;/code&gt; 的签名需要知道 &lt;code&gt;Self&lt;/code&gt; 会使用哪种类型，因为这是返回类型。</target>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;String&lt;/code&gt; 类型是具有对字符串的内容所有权最常见的字符串类型。它与其借来的对等体&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;有着密切的关系。</target>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="translated">的 &lt;code&gt;String&lt;/code&gt; 类型，这是由锈的标准库提供，而不是编码到核心语言，是可增长的，可变的，拥有，UTF-8编码的字符串类型。当Rustaceans在Rust中引用&amp;ldquo;字符串&amp;rdquo;时，它们通常指的是 &lt;code&gt;String&lt;/code&gt; 和字符串slice &lt;code&gt;&amp;amp;str&lt;/code&gt; 类型，而不仅仅是这些类型之一。尽管本节主要涉及 &lt;code&gt;String&lt;/code&gt; ，但是两种类型在Rust的标准库中都大量使用，并且 &lt;code&gt;String&lt;/code&gt; 和string slice都是UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="translated">的 &lt;code&gt;Sync&lt;/code&gt; 和 &lt;code&gt;Send&lt;/code&gt; 性状，其延伸锈病的并发保证由标准库提供的用户定义的类型以及类型</target>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Sync&lt;/code&gt; 标记特征表明，它是实现类型安全 &lt;code&gt;Sync&lt;/code&gt; 从多个线程引用。换句话说，如果 &lt;code&gt;&amp;amp;T&lt;/code&gt; （对 &lt;code&gt;T&lt;/code&gt; 的引用）是 &lt;code&gt;Send&lt;/code&gt; ，则任何类型 &lt;code&gt;T&lt;/code&gt; 都是 &lt;code&gt;Sync&lt;/code&gt; ，这意味着可以将引用安全地发送到另一个线程。类似于 &lt;code&gt;Send&lt;/code&gt; ，基本类型是 &lt;code&gt;Sync&lt;/code&gt; 的，完全的那些类型的组成类型的 &lt;code&gt;Sync&lt;/code&gt; 也是 &lt;code&gt;Sync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="translated">该 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;E&lt;/code&gt; 是通用的类型参数：我们将在第10章，你现在需要知道的是，什么详细讨论泛型 &lt;code&gt;T&lt;/code&gt; 表示，将在成功的情况下，内返回值的类型 &lt;code&gt;Ok&lt;/code&gt; 变种，和 &lt;code&gt;E&lt;/code&gt; 表示将在内的失效情况返回的错误的类型 &lt;code&gt;Err&lt;/code&gt; 变体。由于 &lt;code&gt;Result&lt;/code&gt; 具有这些泛型类型参数，因此我们可以使用 &lt;code&gt;Result&lt;/code&gt; 类型和标准库在许多不同的情况下（我们要返回的成功值和错误值可能不同）定义的函数。</target>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Thread&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="translated">所述 &lt;code&gt;ThreadPool&lt;/code&gt; 将创建一个信道并保持到该信道的发送侧。</target>
        </trans-unit>
        <trans-unit id="e48c39ae08cbb88aef00b305b9017512b2fc007b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;.get()&lt;/code&gt;&lt;/a&gt; gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">该 &lt;code&gt;UnsafeCell&lt;/code&gt; API本身在技术上是非常简单的：它给你一个原始指针 &lt;code&gt;*mut T&lt;/code&gt; 其内容。作为抽象设计者，&lt;em&gt;您&lt;/em&gt;有责任正确使用该原始指针。</target>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;UpperExp&lt;/code&gt; 特点应设置其在科学记数法输出，一个大写 &lt;code&gt;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="translated">所述 &lt;code&gt;UpperHex&lt;/code&gt; 性状应格式化其作为十六进制的数输出，与 &lt;code&gt;A&lt;/code&gt; 通过 &lt;code&gt;F&lt;/code&gt; 大写。</target>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="translated">该 &lt;code&gt;Vec&lt;/code&gt; 类型允许访问的值由指数，因为它实现了&lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;的特征。一个例子将更加明确：</target>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="translated">该 &lt;code&gt;_&lt;/code&gt; 模式会匹配任何值。通过将其放在我们的其他手臂之后， &lt;code&gt;_&lt;/code&gt; 将匹配在其之前未指定的所有可能情况。在 &lt;code&gt;()&lt;/code&gt; 仅仅是单位值，所以什么都不会的发生 &lt;code&gt;_&lt;/code&gt; 情况。结果，我们可以说我们不想对未在 &lt;code&gt;_&lt;/code&gt; 占位符之前列出的所有可能值做任何事情。</target>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="translated">该 &lt;code&gt;abort&lt;/code&gt; 函数终止的过程，所以析构函数将不会在下面的例子中运行：</target>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="translated">该 &lt;code&gt;add&lt;/code&gt; 方法增加了 &lt;code&gt;x&lt;/code&gt; 两个值 &lt;code&gt;Point&lt;/code&gt; 实例和 &lt;code&gt;y&lt;/code&gt; 两个值 &lt;code&gt;Point&lt;/code&gt; 实例创建一个新的 &lt;code&gt;Point&lt;/code&gt; 。所述 &lt;code&gt;Add&lt;/code&gt; 性状具有名为关联的类型 &lt;code&gt;Output&lt;/code&gt; ，用于确定从所述返回的类型 &lt;code&gt;add&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="translated">该 &lt;code&gt;add_text&lt;/code&gt; 方法采用可变引用 &lt;code&gt;self&lt;/code&gt; ，因为我们改变 &lt;code&gt;Post&lt;/code&gt; ，我们正在调用实例 &lt;code&gt;add_text&lt;/code&gt; 上。然后，我们在 &lt;code&gt;content&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 中调用 &lt;code&gt;push_str&lt;/code&gt; ，并传递 &lt;code&gt;text&lt;/code&gt; 参数以添加到保存的 &lt;code&gt;content&lt;/code&gt; 。此行为不取决于帖子所处的状态，因此它不是状态模式的一部分。该 &lt;code&gt;add_text&lt;/code&gt; 方法不与互动 &lt;code&gt;state&lt;/code&gt; 在所有领域，但它是我们要支持行为的一部分。</target>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="translated">的 &lt;code&gt;align&lt;/code&gt; 和 &lt;code&gt;packed&lt;/code&gt; 改性剂可被用来分别提高或降低的对准 &lt;code&gt;struct&lt;/code&gt; S和 &lt;code&gt;union&lt;/code&gt; 秒。 &lt;code&gt;packed&lt;/code&gt; 也可能会更改字段之间的填充。</target>
        </trans-unit>
        <trans-unit id="0e0634e43790fec0970517f968c2cdaea9942a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">的 &lt;code&gt;align&lt;/code&gt; 和 &lt;code&gt;packed&lt;/code&gt; 改性剂不能在相同类型的应用和一个 &lt;code&gt;packed&lt;/code&gt; 类型不能传递地包含另一个 &lt;code&gt;align&lt;/code&gt; 编类型。 &lt;code&gt;align&lt;/code&gt; 和 &lt;code&gt;packed&lt;/code&gt; 只能应用于&lt;a href=&quot;type-layout#the-default-representation&quot;&gt;默认&lt;/a&gt;和&lt;a href=&quot;type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; &lt;/a&gt;表示形式。</target>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="translated">所述 &lt;code&gt;align&lt;/code&gt; 改性剂也可以在所施加的 &lt;code&gt;enum&lt;/code&gt; 。启用时，对 &lt;code&gt;enum&lt;/code&gt; 对齐方式的影响与使用相同 &lt;code&gt;align&lt;/code&gt; 修饰符将 &lt;code&gt;enum&lt;/code&gt; 包裹在新类型 &lt;code&gt;struct&lt;/code&gt; 时是相同的。</target>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;amt&lt;/code&gt; 必须是 &lt;code&gt;&amp;lt;=&lt;/code&gt; 返回通过在缓冲器中的字节数&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6cdd430203e5d1bc8171135295b8e6a12c3f9ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="translated">该 &lt;code&gt;approve&lt;/code&gt; 方法类似于 &lt;code&gt;request_review&lt;/code&gt; 方法：将设置 &lt;code&gt;state&lt;/code&gt; 到目前的状态说，这应该有当该国获得批准，如清单17-16的价值：</target>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="translated">的 &lt;code&gt;area&lt;/code&gt; 函数访问 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 的领域 &lt;code&gt;Rectangle&lt;/code&gt; 实例。现在，我们对 &lt;code&gt;area&lt;/code&gt; 的功能签名准确地说明了我们的意思：使用 &lt;code&gt;Rectangle&lt;/code&gt; 的 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 字段计算Rectangle的面积。这表示宽度和高度彼此相关，并且为值指定了描述性名称，而不是使用元组索引值 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 。为了清楚起见，这是一个胜利。</target>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="translated">该 &lt;code&gt;area&lt;/code&gt; 的功能应该是计算一个矩形的面积，但是我们写的函数有两个参数。参数是相关的，但是在我们程序的任何地方都没有表达。将宽度和高度组合在一起将更易读，更易管理。在第3章的&lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;元组类型&amp;rdquo;&lt;/a&gt;部分中，我们已经讨论了使用元组的一种方法。</target>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="translated">该 &lt;code&gt;art&lt;/code&gt; 板条箱的用户仍然可以看到和从清单14-3使用的内部结构，如清单14-4中所示，或者它们可以使用更方便的结构清单14-5中，如清单14-6中：</target>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="translated">该 &lt;code&gt;as&lt;/code&gt; 关键字可以用来改变什么箱子是你在项目中提到。如果箱子名称中包含破折号，则将其隐式导入，并用下划线代替破折号。</target>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="translated">该 &lt;code&gt;assert!&lt;/code&gt; 当您要确保测试中的某些条件评估为 &lt;code&gt;true&lt;/code&gt; 时，标准库提供的宏非常有用。我们给 &lt;code&gt;assert!&lt;/code&gt; 宏一个计算结果为布尔值的参数。如果值为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;assert!&lt;/code&gt; 什么都不做，测试通过了。如果该值为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;assert!&lt;/code&gt; 宏引起了 &lt;code&gt;panic!&lt;/code&gt; 宏，导致测试失败。使用 &lt;code&gt;assert!&lt;/code&gt; 宏可帮助我们检查代码是否按预期的方式运行。</target>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="translated">该 &lt;code&gt;assert_ne!&lt;/code&gt; 如果我们给它的两个值不相等，则宏将通过；如果它们相等，则宏将失败。此宏对于案件最有用的时候我们还不能确定一个值什么&lt;em&gt;会&lt;/em&gt;是，但我们知道价值肯定什么&lt;em&gt;也不会&lt;/em&gt;，如果因为我们打算我们的代码是起作用的。例如，如果我们要测试一个保证以某种方式更改其输入的函数，但是更改输入的方式取决于我们运行测试的星期几，则最好断言是该函数的输出不等于输入。</target>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="translated">在这种情况下， &lt;code&gt;bind&lt;/code&gt; 函数的作用类似于 &lt;code&gt;new&lt;/code&gt; 函数，它将返回一个新的 &lt;code&gt;TcpListener&lt;/code&gt; 实例。该功能称为 &lt;code&gt;bind&lt;/code&gt; 的原因是在网络中，连接到要侦听的端口称为&amp;ldquo;绑定到端口&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="translated">该 &lt;code&gt;bind&lt;/code&gt; 函数返回一个 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ，这表明结合可能会失败。例如，连接到端口80需要管理员特权（非管理员只能在高于1024的端口上侦听），因此，如果我们在没有管理员的情况下尝试连接到端口80，则绑定将不起作用。再举一个例子，如果我们运行程序的两个实例，并且两个程序监听同一个端口，则绑定将不起作用。因为我们只是出于学习目的而编写基本服务器，所以我们不必担心处理此类错误；相反，如果发生错误，我们使用 &lt;code&gt;unwrap&lt;/code&gt; 停止程序。</target>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="translated">该 &lt;code&gt;bool&lt;/code&gt; 表示值，这只能是要么 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。如果将 &lt;code&gt;bool&lt;/code&gt; 转换为整数，则 &lt;code&gt;true&lt;/code&gt; 为1， &lt;code&gt;false&lt;/code&gt; 为0。</target>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;bool&lt;/code&gt; 类型是它可以是一个数据类型 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。布尔类型使用一个字节的内存。它用于比较和按位运算，如 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 。和 &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="translated">的 &lt;code&gt;break&lt;/code&gt; 语句可以采取一个参数（其将是如果环路表达式的值 &lt;code&gt;break&lt;/code&gt; 执行语句）中 &lt;code&gt;loop&lt;/code&gt; 的循环，但不 &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ，或 &lt;code&gt;while let&lt;/code&gt; 环路。</target>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="translated">该 &lt;code&gt;bytes&lt;/code&gt; 方法返回各自原始字节，这可能是适合您的域：</target>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="translated">该 &lt;code&gt;can_hold&lt;/code&gt; 方法返回一个布尔值，这意味着它是一个完美的用例的 &lt;code&gt;assert!&lt;/code&gt; 宏。在清单11-6中，我们编写了一个测试 &lt;code&gt;can_hold&lt;/code&gt; 方法的测试，方法是创建一个 &lt;code&gt;Rectangle&lt;/code&gt; 实例，该实例的宽度为8，高度为7，并断言它可以容纳另一个 &lt;code&gt;Rectangle&lt;/code&gt; 实例，其宽度为5，高度为7。 1。</target>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="translated">该 &lt;code&gt;cargo install&lt;/code&gt; 命令，可以在本地安装和使用二进制包装箱。这并不是要替换系统软件包。对于Rust开发人员来说，这是一种便捷的方式来安装其他人在&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io上&lt;/a&gt;共享的工具。请注意，您只能安装具有二进制目标的软件包。甲&lt;em&gt;二进制目标&lt;/em&gt;是创建如果板条箱具有可运行程序&lt;em&gt;的src / main.rs&lt;/em&gt;文件或指定为一个二进制的另一个文件，而不是一个库目标不是自身可运行的，但适用于包括其他内程式。通常，包装箱在&lt;em&gt;README&lt;/em&gt;文件中具有有关包装箱是库，具有二进制目标还是两者都有的信息。</target>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="translated">该 &lt;code&gt;cargo test&lt;/code&gt; 命令运行在我们的项目中的所有测试，如清单11-2英寸</target>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;cfg&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">在允许属性的任何地方都允许 &lt;code&gt;cfg&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="translated">该 &lt;code&gt;cfg&lt;/code&gt; 属性支持只有三种谓词：</target>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">该 &lt;code&gt;cfg&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="translated">所述 &lt;code&gt;cfg&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;有条件地包括其附着于基于配置谓词的东西。</target>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;cfg_attr&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">该 &lt;code&gt;cfg_attr&lt;/code&gt; 属性允许任何地方的属性是允许的。</target>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="translated">所述 &lt;code&gt;cfg_attr&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;有条件地包括&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;基于配置谓词。</target>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">所述 &lt;code&gt;char&lt;/code&gt; 类型表示一个字符。更具体地说，由于&amp;ldquo;字符&amp;rdquo;不是Unicode中定义明确的概念，因此 &lt;code&gt;char&lt;/code&gt; 是&amp;ldquo; &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt; &amp;rdquo;，与&amp;ldquo; &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode代码点&lt;/a&gt; &amp;rdquo; 相似但不相同。</target>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="translated">在 &lt;code&gt;cold&lt;/code&gt; 和 &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;的属性&lt;/a&gt;提出建议的方式，可能比这将不提示做更快地生成代码。该属性仅是提示，可以忽略。</target>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">在 &lt;code&gt;cold&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="f187d03d0870d5f7cf8d911158a2ad4bf8bfb1f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about &lt;code&gt;const&lt;/code&gt; as used in raw pointers can be read at the Rust docs for the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer primitive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="translated">的 &lt;code&gt;const&lt;/code&gt; 关键字也被用在原始指针结合 &lt;code&gt;mut&lt;/code&gt; ，如所见 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 。有关更多信息，请参阅Rust文档的&lt;a href=&quot;primitive.pointer&quot;&gt;指针&lt;/a&gt;原始部分。</target>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="translated">该 &lt;code&gt;core&lt;/code&gt; 箱子总是添加到EXTERN序幕。该 &lt;code&gt;std&lt;/code&gt; 板条箱中加入，只要该&lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt; &lt;code&gt;no_std&lt;/code&gt; &lt;/a&gt;在箱子根没有指定属性。</target>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;crate_name&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">该 &lt;code&gt;data&lt;/code&gt; 指针可用于所要求的执行器来存储任意数据。例如，这可以是指向与任务关联的 &lt;code&gt;Arc&lt;/code&gt; 的类型擦除的指针。此Poiner的值将作为第一个参数传递给 &lt;code&gt;vtable&lt;/code&gt; 一部分的所有函数。</target>
        </trans-unit>
        <trans-unit id="9e90fa7bb07af3f80ba061dbc0af88db5a79ba76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this pointer will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="translated">该 &lt;code&gt;dbg!(..)&lt;/code&gt; 宏将输入：</target>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="translated">该 &lt;code&gt;dbg!&lt;/code&gt; 宏在发行版中的工作原理完全相同。当仅在发行版本中发生的调试问题或在发行模式下进行的调试明显更快时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;deprecated&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="8b0ffc1f78b8eb9694b4e7509ecdd919acc0c0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can only be present &lt;strong&gt;once&lt;/strong&gt; on an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="translated">该 &lt;code&gt;deprecated&lt;/code&gt; 属性有以下几种形式：</target>
        </trans-unit>
        <trans-unit id="44c311ce3d12b2d5a8a0632c6cd020f999b4ee16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;, or &lt;a href=&quot;../macros-by-example&quot;&gt;macro definition&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">所述 &lt;code&gt;deprecated&lt;/code&gt; 属性可以被应用于任何&lt;a href=&quot;../items&quot;&gt;项目&lt;/a&gt;，&lt;a href=&quot;../items/traits&quot;&gt;性状项目&lt;/a&gt;，&lt;a href=&quot;../items/enumerations&quot;&gt;枚举变体&lt;/a&gt;，&lt;a href=&quot;../items/structs&quot;&gt;结构字段&lt;/a&gt;，或&lt;a href=&quot;../items/external-blocks&quot;&gt;外部块项目&lt;/a&gt;。它不能应用于&lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;特质实施项目&lt;/a&gt;。当应用于包含其他项（例如&lt;a href=&quot;../items/modules&quot;&gt;模块&lt;/a&gt;或&lt;a href=&quot;../items/implementations&quot;&gt;实现）的&lt;/a&gt;项时，所有子项都将继承deprecation属性。</target>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="translated">此生成输出中显示的 &lt;code&gt;dev&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt; 表示编译器正在使用不同的配置文件。</target>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;drop&lt;/code&gt; 的时候方法被调用 &lt;code&gt;_x&lt;/code&gt; 去的范围完成，因此， &lt;code&gt;main&lt;/code&gt; 打印 &lt;code&gt;Dropping!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">该 &lt;code&gt;dst&lt;/code&gt; 路径将指向目录的符号链接 &lt;code&gt;src&lt;/code&gt; 路径。</target>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">该 &lt;code&gt;dst&lt;/code&gt; 路径将指向文件的符号链接 &lt;code&gt;src&lt;/code&gt; 路径。</target>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="translated">该 &lt;code&gt;dst&lt;/code&gt; 路径将是指向一个链接 &lt;code&gt;src&lt;/code&gt; 路径。请注意，系统通常要求这两个路径都位于同一文件系统上。</target>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">该 &lt;code&gt;dst&lt;/code&gt; 路径将指向一个符号链接 &lt;code&gt;src&lt;/code&gt; 路径。</target>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="translated">该 &lt;code&gt;dst&lt;/code&gt; 路径将指向一个符号链接 &lt;code&gt;src&lt;/code&gt; 路径。在Windows上，这将是文件符号链接，而不是目录符号链接。因此，应该使用特定于平台的&lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt; &lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt; &lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt; &lt;code&gt;symlink_dir&lt;/code&gt; &lt;/a&gt;来使意图明确。</target>
        </trans-unit>
        <trans-unit id="fce5aa6e4c6fe0d2a117a0ec0a2f7f52bfd2748e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dyn&lt;/code&gt; keyword is used to highlight that calls to methods on the associated &lt;code&gt;Trait&lt;/code&gt; are dynamically dispatched. To use the trait this way, it must be 'object safe'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="translated">&lt;em&gt;Cargo.toml中&lt;/em&gt;的 &lt;code&gt;edition&lt;/code&gt; 密钥指示编译器应为您的代码使用哪个版本。如果密钥不存在，出于向后兼容的原因，Rust使用 &lt;code&gt;2015&lt;/code&gt; 作为版本值。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4302d0f2edafc20c30c1bca4c608a973532a107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; block of an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="translated">的 &lt;code&gt;entry&lt;/code&gt; API旨在用于操纵有条件上的键或不存在下的映射的内容提供了一种高效的机制。这样做的主要动机是提供有效的累加器图。例如，如果希望保持对每个键被看到的次数的计数，则他们将必须执行一些条件逻辑来确定这是否是第一次被看到。通常，这需要先 &lt;code&gt;find&lt;/code&gt; 后跟 &lt;code&gt;insert&lt;/code&gt; ，以有效地重复每次插入的搜索工作。</target>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 类型类似于一个 &lt;code&gt;data&lt;/code&gt; 在ML构造函数声明，或者&lt;em&gt;拾取ADT&lt;/em&gt;在中间状态。</target>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="translated">该 &lt;code&gt;env::args&lt;/code&gt; 函数返回一个迭代！而不是将迭代器的值收集到向量中，然后将切片传递给 &lt;code&gt;Config::new&lt;/code&gt; ，现在我们将从 &lt;code&gt;env::args&lt;/code&gt; 返回的迭代器的所有权直接传递给 &lt;code&gt;Config::new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="translated">该 &lt;code&gt;execute&lt;/code&gt; 方法将发送它要执行下降通道的发送端的工作。</target>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;expensive_test&lt;/code&gt; 功能被列为 &lt;code&gt;ignored&lt;/code&gt; 。如果我们只想运行忽略的测试，则可以使用 &lt;code&gt;cargo test -- --ignored&lt;/code&gt; ignored ：</target>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;export_name&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="71ce9eba53db805fddc2d08a297018a65234c4f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; function qualifier allows providing function &lt;em&gt;definitions&lt;/em&gt; that can be called with a particular ABI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">该 &lt;code&gt;extern&lt;/code&gt; 关键字在鲁斯特两个地方使用。一种是与&lt;a href=&quot;index&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt;关键字结合使用，以使您的Rust代码了解项目中的其他Rust板条箱，例如， &lt;code&gt;extern crate lazy_static;&lt;/code&gt; 。另一个用途是在外部功能接口（FFI）中。</target>
        </trans-unit>
        <trans-unit id="80a6e01d93b27f65515594890e0091001ba7b217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute only accept a &quot;feature flag&quot; and can only be used on nightly. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36584ecca666e59936c11f071bcfcb0da92fd4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute was badly formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424a7adcc55a187f305df277831d5dda5afa7154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute can only be used on foreign function declarations which have no side effects except for their return value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fac3c8fa0259e175ffb5e9aab803c7bd9140ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute was used on something other than a foreign function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe6d270783e8b73023767bbcd8ed3a773bacf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute can only be used on foreign functions which do not have side effects or infinite loops:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883b8dfd3c5fc179185e1d061b052f5f3e0fb52a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute was used on a non-foreign function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="translated">该 &lt;code&gt;fix_incorrect_order&lt;/code&gt; 功能是在 &lt;code&gt;back_of_house&lt;/code&gt; 模块，所以我们可以用 &lt;code&gt;super&lt;/code&gt; 去的父模块 &lt;code&gt;back_of_house&lt;/code&gt; ，在这种情况下是 &lt;code&gt;crate&lt;/code&gt; ，根。从那里，我们找到 &lt;code&gt;serve_order&lt;/code&gt; 并找到它。成功！我们认为 &lt;code&gt;back_of_house&lt;/code&gt; 模块和 &lt;code&gt;serve_order&lt;/code&gt; 函数之间可能保持相同的关系，并且如果我们决定重新组织包装箱的模块树，它们可能会一起移动。因此，我们使用了 &lt;code&gt;super&lt;/code&gt; ，因此，如果此代码被移至其他模块，则将来在更新代码的地方将更少。</target>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="translated">该 &lt;code&gt;fn&lt;/code&gt; 语法声明了一个新的功能，括号， &lt;code&gt;()&lt;/code&gt; ，表示没有参数，并且大括号， &lt;code&gt;{&lt;/code&gt; ，启动功能的身体。</target>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="translated">在 &lt;code&gt;for&lt;/code&gt; 关键字在很多语法位置使用：</target>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="translated">在 &lt;code&gt;for&lt;/code&gt; 目前循环变量命名为 &lt;code&gt;_i&lt;/code&gt; ，并警告不再出现。</target>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="translated">该 &lt;code&gt;forbid&lt;/code&gt; 掉毛的场合，比如 &lt;code&gt;deny&lt;/code&gt; ，使对应的编译器警告变成硬错误。与 &lt;code&gt;deny&lt;/code&gt; 不同， &lt;code&gt;forbid&lt;/code&gt; 防止其自身被内部属性覆盖。</target>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="translated">的 &lt;code&gt;format&lt;/code&gt; 函数接受一个&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt;结构并返回生成的格式的字符串。</target>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 文件不存在。</target>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 路径不是一个文件。</target>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;global_allocator&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="ae2c6463795dadd5e649f9eb12f49008495df3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0ca98b2928cdd13f0ccd74c40e39e4e68ec9cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="translated">所述 &lt;code&gt;hello_macro_derive&lt;/code&gt; 函数的第一转换 &lt;code&gt;input&lt;/code&gt; 从一个 &lt;code&gt;TokenStream&lt;/code&gt; 到一个数据结构，我们就可以解释和执行操作。这就是 &lt;code&gt;syn&lt;/code&gt; 发挥作用的地方。 &lt;code&gt;syn&lt;/code&gt; 中的 &lt;code&gt;parse&lt;/code&gt; 函数采用 &lt;code&gt;TokenStream&lt;/code&gt; 并返回代表解析后的Rust代码的 &lt;code&gt;DeriveInput&lt;/code&gt; 结构。清单19-32显示了从解析 &lt;code&gt;struct Pancakes;&lt;/code&gt; 结构得到的 &lt;code&gt;DeriveInput&lt;/code&gt; 结构的相关部分；串：</target>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="translated">该 &lt;code&gt;hello_macro_derive&lt;/code&gt; 函数将被调用时，我们的图书馆指定的用户 &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; 上的类型。这是可能的，因为我们在这里用 &lt;code&gt;proc_macro_derive&lt;/code&gt; 注释了 &lt;code&gt;hello_macro_derive&lt;/code&gt; 函数，并指定了名称 &lt;code&gt;HelloMacro&lt;/code&gt; ，它与我们的特征名称匹配；这是大多数程序宏都遵循的约定。</target>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="translated">该 &lt;code&gt;if let&lt;/code&gt; 语法，您可以结合 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 而忽略其余为更简洁的方式来处理值相匹配的一个模式。考虑清单6-6中的程序，该程序与 &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; 值匹配，但仅想在值为3时执行代码。</target>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="translated">这次 &lt;code&gt;if&lt;/code&gt; 条件的值为 &lt;code&gt;3&lt;/code&gt; ，Rust引发错误：</target>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="translated">该 &lt;code&gt;if&lt;/code&gt; 表达式检查我们的值是否超出范围，讲述问题的用户，并呼吁 &lt;code&gt;continue&lt;/code&gt; 开始循环的下一次迭代，并要求另一种猜测。在 &lt;code&gt;if&lt;/code&gt; 表达式之后，我们可以继续进行 &lt;code&gt;guess&lt;/code&gt; 和秘密数字之间的比较，知道 &lt;code&gt;guess&lt;/code&gt; 在1到100之间。</target>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="translated">所述 &lt;code&gt;if&lt;/code&gt; 关键字在一个其它地方使用拉斯特，即作为模式匹配本身，使图案如一个部分 &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; 被使用。</target>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;ignore&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="translated">该 &lt;code&gt;ignore&lt;/code&gt; 属性可任选与书面&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法指定测试为何被忽略的一个原因。</target>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="translated">该 &lt;code&gt;impl Trait&lt;/code&gt; 不与内出现返回类型捕捉寿命参数 &lt;code&gt;impl Trait&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="translated">该 &lt;code&gt;impl Trait&lt;/code&gt; 语法是方便，使得在简单的情况下，更简洁的代码。在其他情况下，特征绑定语法可以表示更多的复杂性。例如，我们可以有两个实现 &lt;code&gt;Summary&lt;/code&gt; 的参数。使用 &lt;code&gt;impl Trait&lt;/code&gt; 语法如下所示：</target>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="translated">该 &lt;code&gt;impl Trait&lt;/code&gt; 语法同样适用于简单的案件，但实际上是一个较长的形式，被称为语法糖&lt;em&gt;约束特征&lt;/em&gt; ; 它看起来像这样：</target>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="translated">所述 &lt;code&gt;impl&lt;/code&gt; 关键字主要用于对类型限定的实施方式。固有实现是独立的，而特征实现则用于实现类型的特征或其他特征。</target>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; 上的 &lt;code&gt;incoming&lt;/code&gt; 方法返回一个迭代器，该迭代器为我们提供了一系列流（更具体地说，类型为 &lt;code&gt;TcpStream&lt;/code&gt; 的流）。单个&lt;em&gt;流&lt;/em&gt;表示客户端和服务器之间的开放连接。阿&lt;em&gt;连接&lt;/em&gt;为在其中客户机连接到服务器，该服务器生成响应的全部请求和响应过程的名称，服务器关闭连接。这样， &lt;code&gt;TcpStream&lt;/code&gt; 将从其自身读取以查看客户端发送的内容，然后允许我们将响应写入流中。总体而言，此 &lt;code&gt;for&lt;/code&gt; 循环将依次处理每个连接并产生一系列流供我们处理。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;inline&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="translated">该 &lt;code&gt;inline&lt;/code&gt; 属性只支持两个参数：</target>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">该 &lt;code&gt;inline&lt;/code&gt; 属性的格式不正确。</target>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="translated">该 &lt;code&gt;isize&lt;/code&gt; 类型是有符号整数类型，具有相同的位数为平台的指针类型。对象和数组大小的理论上限是最大 &lt;code&gt;isize&lt;/code&gt; 值。这样可确保 &lt;code&gt;isize&lt;/code&gt; 可用于计算指向对象或数组的指针之间的差异，并可寻址对象中的每个字节以及末尾的一个字节。</target>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="translated">现在， &lt;code&gt;it_works&lt;/code&gt; 函数具有返回类型 &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt; 。在函数的主体中，而不是调用 &lt;code&gt;assert_eq!&lt;/code&gt; 宏，则在测试通过时返回 &lt;code&gt;Ok(())&lt;/code&gt; ，而在测试失败时返回内部带有 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;Err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="translated">在 &lt;code&gt;largest&lt;/code&gt; 功能有一个名为参数 &lt;code&gt;list&lt;/code&gt; ，它代表了任何具体的切片 &lt;code&gt;i32&lt;/code&gt; 价值观，我们可能会传递到功能。结果，当我们调用该函数时，代码将在传入的特定值上运行。</target>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="translated">最大的 &lt;code&gt;largest_i32&lt;/code&gt; 函数是我们在清单10-3中提取的函数， &lt;code&gt;i32&lt;/code&gt; 在片中找到最大的i32。该 &lt;code&gt;largest_char&lt;/code&gt; 函数查找最大的 &lt;code&gt;char&lt;/code&gt; 中分得一杯羹。函数体具有相同的代码，因此让我们通过在单个函数中引入泛型类型参数来消除重复。</target>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">该 &lt;code&gt;len&lt;/code&gt; 参数是的数目&lt;strong&gt;的元素&lt;/strong&gt;，而不是字节数。</target>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="translated">该 &lt;code&gt;let y = 6&lt;/code&gt; 语句没有返回值，所以没有任何东西 &lt;code&gt;x&lt;/code&gt; 绑定到。这与其他语言（例如C和Ruby）中的情况不同，在其他语言中，赋值返回赋值。在这些语言中，您可以编写 &lt;code&gt;x = y = 6&lt;/code&gt; 并使 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的值均为 &lt;code&gt;6&lt;/code&gt; ；Rust中不是这种情况。</target>
        </trans-unit>
        <trans-unit id="38e40fe06999fccdbadcd0aed2907afe5c6e93b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">该 &lt;code&gt;lines&lt;/code&gt; 方法返回迭代器。我们将在[第13章] [ch13]中深入讨论迭代器，但回想一下您在&lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;清单3-5中&lt;/a&gt;看到了使用迭代器的这种方式，其中我们使用了带迭代器的 &lt;code&gt;for&lt;/code&gt; 循环在每个项目上运行一些代码在一个集合中。</target>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;link&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;link_name&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="translated">所述 &lt;code&gt;link_name&lt;/code&gt; 属性可以在声明中指定的内侧 &lt;code&gt;extern&lt;/code&gt; 块表示码元导入针对给定功能或静态的。它使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法指定符号的名称。</target>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;link_section&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="translated">的 &lt;code&gt;locality&lt;/code&gt; 参数必须是恒定的整数，并且一个时间局部性说明符，从（0） -无局部性，（3） -极其本地保持在高速缓存中</target>
        </trans-unit>
        <trans-unit id="08d3f68a2cf00952341cb92b2cabeabf4f7aad60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="translated">该 &lt;code&gt;loop&lt;/code&gt; 关键字创建一个无限循环。现在，我们将添加它，以使用户有更多机会猜测数字：</target>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="translated">该 &lt;code&gt;loop&lt;/code&gt; 关键字告诉锈永远比执行的代码块一遍又一遍，或者直到你明确告诉它停止。</target>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;macro_use&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="translated">这里的 &lt;code&gt;main&lt;/code&gt; 功能创建了 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 结构的实例，该实例持有对变量 &lt;code&gt;novel&lt;/code&gt; 拥有的 &lt;code&gt;String&lt;/code&gt; 的第一句的引用。Novell中的数据在创建 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 实例之前 &lt;code&gt;novel&lt;/code&gt; 存在。另外， &lt;code&gt;novel&lt;/code&gt; 在直到 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 超出范围后才超出范围，因此 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 实例中的引用是有效的。</target>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="translated">的 &lt;code&gt;main&lt;/code&gt; 功能是特殊的，有什么返回类型必须是限制。main的一种有效返回类型是 &lt;code&gt;()&lt;/code&gt; ，方便地，另一种有效返回类型是 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 函数原型不应该采取的论点。例：</target>
        </trans-unit>
        <trans-unit id="db6afd48cca2e467a026116d5334792843766266" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was defined with generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="translated">的 &lt;code&gt;main&lt;/code&gt; 功能被错误地宣告。</target>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="translated">该 &lt;code&gt;move&lt;/code&gt; 关闭经常一起使用 &lt;code&gt;thread::spawn&lt;/code&gt; ，因为它可以让你从一个线程在另一个线程使用的数据。</target>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;mpsc::channel&lt;/code&gt; 函数返回一个元组，所述第一元件，其是发送端和所述第二元件是所述接收端。缩写 &lt;code&gt;tx&lt;/code&gt; 和 &lt;code&gt;rx&lt;/code&gt; 传统上分别在&lt;em&gt;发送器&lt;/em&gt;和&lt;em&gt;接收器的&lt;/em&gt;许多字段中使用，因此我们将变量命名为表示每个端点。我们使用一个 &lt;code&gt;let&lt;/code&gt; 语句，该模式具有破坏元组的结构；我们将在第18章中讨论在 &lt;code&gt;let&lt;/code&gt; 语句和解构中使用模式。以这种方式使用 &lt;code&gt;let&lt;/code&gt; 语句是提取 &lt;code&gt;mpsc::channel&lt;/code&gt; 返回的元组片段的便捷方法。</target>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;must_use&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="translated">所述 &lt;code&gt;must_use&lt;/code&gt; 属性可以通过使用包括消息的&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法如 &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt; 。该消息将与警告一起给出。</target>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 如果密钥必须包含 &lt;code&gt;kind&lt;/code&gt; 指定的。</target>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;no_builtins&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;no_link&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;no_main&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;no_mangle&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="translated">在 &lt;code&gt;not&lt;/code&gt; CFG-谓词的格式不正确。</target>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="translated">在 &lt;code&gt;not&lt;/code&gt; 谓语预计一个CFG模式。例：</target>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="translated">的 &lt;code&gt;number&lt;/code&gt; 变量将被绑定到基于所述结果的值 &lt;code&gt;if&lt;/code&gt; 表达式。运行以下代码，看看会发生什么：</target>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="translated">在两种情况下， &lt;code&gt;op_string_ref&lt;/code&gt; 绑定的类型均为 &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;opt-level&lt;/code&gt; 设置控制优化的数量锈病将适用于你的代码，范围0〜3采用更优化的编译延伸时间，因此，如果你在开发和经常编译代码，你要快即使生成的代码运行速度较慢，也可以进行编译。这是默认的原因 &lt;code&gt;opt-level&lt;/code&gt; 的 &lt;code&gt;dev&lt;/code&gt; 是 &lt;code&gt;0&lt;/code&gt; 。当您准备发布代码时，最好花费更多时间进行编译。您只能在发布模式下编译一次，但是您将运行已编译的程序多次，因此发布模式将较长的编译时间换成运行速度更快的代码。这就是 &lt;code&gt;release&lt;/code&gt; 配置文件的默认 &lt;code&gt;opt-level&lt;/code&gt; 为 &lt;code&gt;3&lt;/code&gt; 的原因。</target>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="translated">定义 &lt;code&gt;Entry&lt;/code&gt; 的 &lt;code&gt;or_insert&lt;/code&gt; 方法以返回对相应 &lt;code&gt;Entry&lt;/code&gt; 密钥的值的可变引用（如果该密钥存在），如果不存在，则将该参数作为该密钥的新值插入，并返回对该新值的可变引用。这种技术比自己编写逻辑要干净得多，此外，它与借位检查器的配合也更加出色。</target>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;panic_handler&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;path&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="translated">该 &lt;code&gt;path&lt;/code&gt; 在非目录文件分。</target>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;poll&lt;/code&gt; 功能不是在一个紧凑的循环反复调用-相反，它应该只被调用时，未来的表明它准备取得进展（通过调用 &lt;code&gt;wake()&lt;/code&gt; ）。如果您熟悉Unix 上的 &lt;code&gt;poll(2)&lt;/code&gt; 或 &lt;code&gt;select(2)&lt;/code&gt; 系统调用，则值得注意的是，期货通常&lt;em&gt;不会&lt;/em&gt;遇到&amp;ldquo;所有唤醒都必须轮询所有事件&amp;rdquo;的问题。它们更像 &lt;code&gt;epoll(4)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="translated">该 &lt;code&gt;poll&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="translated">该 &lt;code&gt;prefetch&lt;/code&gt; 固有是一个提示给代码生成如果支持插入一个预取指令; 否则，它是无操作的。预取对程序的行为没有影响，但可以更改其性能特征。</target>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">该 &lt;code&gt;println!&lt;/code&gt; 函数只能打印到标准输出，因此我们必须使用其他内容才能打印到标准错误。</target>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;println!&lt;/code&gt; 宏可以进行多种格式设置，默认情况下，大括号告诉 &lt;code&gt;println!&lt;/code&gt; 。使用称为 &lt;code&gt;Display&lt;/code&gt; 的格式：用于直接最终用户使用的输出。到目前为止，我们已经看到的基本类型默认情况下实现了 &lt;code&gt;Display&lt;/code&gt; ，因为您只想向用户显示 &lt;code&gt;1&lt;/code&gt; 或任何其他基本类型。但是有了结构， &lt;code&gt;println!&lt;/code&gt; 格式化输出的格式应该不太清晰，因为有更多的显示可能性：是否要使用逗号？您是否要打印大括号？是否应显示所有字段？由于存在这种歧义，Rust不会尝试猜测我们想要的是什么，并且结构没有提供的 &lt;code&gt;Display&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02931ec361bbc5f61952272ead50c2b1cc721cb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">该 &lt;code&gt;proc_macro&lt;/code&gt; 箱</target>
        </trans-unit>
        <trans-unit id="0ebc19fdeafa41e303e045832093f26b01f1011c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="translated">该 &lt;code&gt;pub&lt;/code&gt; 关键字是一个函数内部使用。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="b670fe1e664ec6db0ea27f497b8f300d96565afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="translated">该 &lt;code&gt;pub&lt;/code&gt; 关键字是公共枚举内部使用。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="translated">所述 &lt;code&gt;push&lt;/code&gt; 方法使用单个字符作为参数，并把它添加到 &lt;code&gt;String&lt;/code&gt; 。清单8-17显示了使用 &lt;code&gt;push&lt;/code&gt; 方法将字母&lt;em&gt;l&lt;/em&gt;添加到 &lt;code&gt;String&lt;/code&gt; 的代码。</target>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="translated">该 &lt;code&gt;quote!&lt;/code&gt; 宏还提供了一些非常酷的模板机制：我们可以输入 &lt;code&gt;#name&lt;/code&gt; ，然后 &lt;code&gt;quote!&lt;/code&gt; 将其替换为变量 &lt;code&gt;name&lt;/code&gt; 的值。您甚至可以执行一些重复操作，类似于常规宏的工作方式。检查出&lt;a href=&quot;https://docs.rs/quote&quot;&gt;的 &lt;code&gt;quote&lt;/code&gt; 箱子的文档&lt;/a&gt;进行彻底的介绍。</target>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;quote!&lt;/code&gt; 宏使我们可以定义要返回的Rust代码。编译器期望与 &lt;code&gt;quote!&lt;/code&gt; 的直接结果有所不同！宏的执行，因此我们需要将其转换为 &lt;code&gt;TokenStream&lt;/code&gt; 。我们通过调用执行此 &lt;code&gt;into&lt;/code&gt; 方法，它消耗该中间表示，并返回所需的值 &lt;code&gt;TokenStream&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;recursion_limit&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="translated">该 &lt;code&gt;ref&lt;/code&gt; 和/或 &lt;code&gt;mut&lt;/code&gt; &lt;em&gt;IDENTIFIER&lt;/em&gt;语法相匹配的任何值和结合它与相同名称的给定字段的变量。</target>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="translated">在 &lt;code&gt;repeat()&lt;/code&gt; 函数一遍又一遍重复一个值。</target>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="translated">该 &lt;code&gt;repeat_with()&lt;/code&gt; 函数调用了一遍又一遍的中继器。</target>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="translated">该 &lt;code&gt;request_review&lt;/code&gt; 和 &lt;code&gt;approve&lt;/code&gt; 方式取得其所有权的 &lt;code&gt;self&lt;/code&gt; ，从而消耗 &lt;code&gt;DraftPost&lt;/code&gt; 和 &lt;code&gt;PendingReviewPost&lt;/code&gt; 实例，并将它们转化成 &lt;code&gt;PendingReviewPost&lt;/code&gt; 和出版 &lt;code&gt;Post&lt;/code&gt; 分别。这样，在我们对它们调用 &lt;code&gt;request_review&lt;/code&gt; 之后，我们将不会再有任何缠绵的 &lt;code&gt;DraftPost&lt;/code&gt; 实例，依此类推。该 &lt;code&gt;PendingReviewPost&lt;/code&gt; 结构不具有 &lt;code&gt;content&lt;/code&gt; 上定义的方法，所以试图读取编译错误内容的结果，与 &lt;code&gt;DraftPost&lt;/code&gt; 。因为获取已发布 &lt;code&gt;Post&lt;/code&gt; 的唯一方法确实定义了 &lt;code&gt;content&lt;/code&gt; 方法的实例是在 &lt;code&gt;PendingReviewPost&lt;/code&gt; 上调用 &lt;code&gt;approve&lt;/code&gt; 方法，而获得 &lt;code&gt;PendingReviewPost&lt;/code&gt; 的唯一方法是在 &lt;code&gt;DraftPost&lt;/code&gt; 上调用 &lt;code&gt;request_review&lt;/code&gt; 方法，我们现在已将博客文章工作流程编码为类型系统。</target>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;Draft&lt;/code&gt; 上的 &lt;code&gt;request_review&lt;/code&gt; 方法需要返回新的 &lt;code&gt;PendingReview&lt;/code&gt; 结构的带框实例，该实例表示帖子等待审阅时的状态。该 &lt;code&gt;PendingReview&lt;/code&gt; 结构也实现了 &lt;code&gt;request_review&lt;/code&gt; 方法，但没有做任何转换。而是返回自身，因为当我们请求对已经处于 &lt;code&gt;PendingReview&lt;/code&gt; 状态的帖子进行评论时，它应该保持在 &lt;code&gt;PendingReview&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="translated">在 &lt;code&gt;run&lt;/code&gt; 命令就派上用场了，当你需要快速迭代的一个项目，我们将在这场比赛中做的，移动到下一个前快速测试每个迭代。</target>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="translated">在 &lt;code&gt;run&lt;/code&gt; 函数定义</target>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="translated">现在， &lt;code&gt;run&lt;/code&gt; 功能包含 &lt;code&gt;main&lt;/code&gt; 剩余的所有逻辑，从读取文件开始。在 &lt;code&gt;run&lt;/code&gt; 函数将 &lt;code&gt;Config&lt;/code&gt; 实例作为参数。</target>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="translated">该 &lt;code&gt;rustfmt&lt;/code&gt; 工具根据社区的代码风格重新格式化你的代码。许多协作项目都使用 &lt;code&gt;rustfmt&lt;/code&gt; 来防止有关编写Rust时使用哪种样式的争论：每个人都使用该工具格式化代码。</target>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="translated">该 &lt;code&gt;same_bucket&lt;/code&gt; 函数传递引用从切片两个元素，必须确定元素比较相等。元素以与切片中的顺序相反的顺序传递，因此，如果 &lt;code&gt;same_bucket(a, b)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;a&lt;/code&gt; 将在切片的末尾移动。</target>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="translated">该 &lt;code&gt;same_bucket&lt;/code&gt; 函数传递引用从矢量两个元素，并且必须确定该元件比较相等。元素以与切片中的顺序相反的顺序传递，因此，如果 &lt;code&gt;same_bucket(a, b)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则将 &lt;code&gt;a&lt;/code&gt; 删除。</target>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="translated">清单12-21中所示的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数将与 &lt;code&gt;search&lt;/code&gt; 函数几乎相同。唯一的区别是，我们将小写 &lt;code&gt;query&lt;/code&gt; 和每一 &lt;code&gt;line&lt;/code&gt; 因此无论输入参数的大小写如何，当我们检查行是否包含查询时，它们都是相同的大小写。</target>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="translated">所述 &lt;code&gt;self&lt;/code&gt; 板条箱可进口它创建了一个结合到当前板条箱。在这种情况下，必须使用 &lt;code&gt;as&lt;/code&gt; 子句来指定将其绑定到的名称。</target>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="translated">在 &lt;code&gt;self&lt;/code&gt; 进口出现不止一次在列表中。</target>
        </trans-unit>
        <trans-unit id="776137337eaf5141c6cf75f1ef731869806d23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;abitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="translated">该 &lt;code&gt;self&lt;/code&gt; 关键字不能单独出现在一个最后一段 &lt;code&gt;use&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="translated">该 &lt;code&gt;self&lt;/code&gt; 关键字是在静态方法中使用。</target>
        </trans-unit>
        <trans-unit id="a9568dcdfe3a23be1dee117543923d717013ab13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used inside of an associated function without a &quot;&lt;code&gt;self&lt;/code&gt; receiver&quot; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67620c2fbc5330097742f848b2b9886ad0ef4ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; parameter in a method has an invalid &quot;receiver type&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="translated">现在 &lt;code&gt;sent_messages&lt;/code&gt; 字段的类型为 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt; 。在 &lt;code&gt;new&lt;/code&gt; 函数中，我们围绕空向量创建一个新的 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="translated">所述 &lt;code&gt;shoes_in_my_size&lt;/code&gt; 函数采用的鞋矢量和鞋的大小作为参数的所有权。它返回一个仅包含指定大小的鞋子的向量。</target>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;should_panic&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="translated">所述 &lt;code&gt;should_panic&lt;/code&gt; 属性可任选地采取必须在恐慌消息内出现的输入串。如果在消息中找不到该字符串，则测试将失败。可以使用带有 &lt;code&gt;expected&lt;/code&gt; 字段的&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法或&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt;语法传递字符串。</target>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="translated">所述 &lt;code&gt;simd_shuffle&lt;/code&gt; 功能需要在它的名字最后一个参数传递的阵列的长度。例：</target>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;spawn&lt;/code&gt; 函数返回一个 &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是类型，所述封闭的回报。让我们也尝试使用 &lt;code&gt;JoinHandle&lt;/code&gt; ，看看会发生什么。在我们的例子中，我们传递给线程池的闭包将处理连接并且不返回任何内容，因此 &lt;code&gt;T&lt;/code&gt; 将是单位类型 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="translated">该 &lt;code&gt;src&lt;/code&gt; 路径不是一个文件或不存在。</target>
        </trans-unit>
        <trans-unit id="07635229348f3268d25fca1958c374b441ce892b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; function was defined with a where clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="translated">的 &lt;code&gt;static&lt;/code&gt; 参数，另一方面，确保在存储器中的固定位置。这并不总是意味着该值是恒定的。例如，全局互斥锁也可以声明为 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="translated">该 &lt;code&gt;std::env&lt;/code&gt; 模块包含用于处理环境变量更多有用的功能：看看它的文档，看看有什么是可用的。</target>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="translated">该 &lt;code&gt;std::io&lt;/code&gt; 模块包含了一些做的输入和输出，当你需要共同的东西。该模块最核心的部分是&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;特征，它提供了用于读取和写入输入和输出的最通用的接口。</target>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="translated">所述 &lt;code&gt;std::mem::drop&lt;/code&gt; 函数是从不同 &lt;code&gt;drop&lt;/code&gt; 在该方法中 &lt;code&gt;Drop&lt;/code&gt; 性状。我们通过传递我们想要强制作为早期参数删除的值来进行调用。该函数处于序幕中，因此我们可以在清单15-15中修改 &lt;code&gt;main&lt;/code&gt; 来调用 &lt;code&gt;drop&lt;/code&gt; 函数，如清单15-16所示：</target>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="translated">该 &lt;code&gt;steps_between&lt;/code&gt; 功能提供了一种有效地比较两个 &lt;code&gt;Step&lt;/code&gt; 的对象。</target>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;str&lt;/code&gt; 型，也称为&amp;ldquo;串片&amp;rdquo;，是最原始的字符串类型。通常以借用形式 &lt;code&gt;&amp;amp;str&lt;/code&gt; 查看。它也是字符串文字 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="translated">该 &lt;code&gt;stringify!&lt;/code&gt; 这里使用的宏内置于Rust中。它采用Rust表达式，例如 &lt;code&gt;1 + 2&lt;/code&gt; ，并且在编译时将表达式转换为字符串文字，例如 &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt; 。这与 &lt;code&gt;format!&lt;/code&gt; 不同！或 &lt;code&gt;println!&lt;/code&gt; ，这些宏会评估表达式，然后将结果转换为 &lt;code&gt;String&lt;/code&gt; 。有一种可能性，即 &lt;code&gt;#name&lt;/code&gt; 输入可能是一个表达式字面上打印，所以我们使用 &lt;code&gt;stringify!&lt;/code&gt; 。用 &lt;code&gt;stringify!&lt;/code&gt; 还可以通过在编译时将 &lt;code&gt;#name&lt;/code&gt; 转换为字符串文字来节省分配。</target>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="translated">该 &lt;code&gt;syn&lt;/code&gt; 箱子从一个字符串转换为数据结构，我们可以执行操作解析锈代码。该 &lt;code&gt;quote&lt;/code&gt; 箱子轮流 &lt;code&gt;syn&lt;/code&gt; 数据结构放回锈代码。这些板条箱使解析我们可能要处理的任何种类的Rust代码变得更加简单：为Rust代码编写完整的解析器并不是一件容易的事。</target>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="translated">该 &lt;code&gt;take&lt;/code&gt; 方法是在所定义的 &lt;code&gt;Iterator&lt;/code&gt; 的性状和至多限制了迭代前两项。该 &lt;code&gt;ThreadPool&lt;/code&gt; 将在年底走出去的范围 &lt;code&gt;main&lt;/code&gt; 和 &lt;code&gt;drop&lt;/code&gt; 执行将运行。</target>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;target_feature&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;test&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="c6b28a9d1db605fca4af25fdaf7d2f63f3f4ff7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track_caller&lt;/code&gt; attribute may be applied to any function with &lt;a href=&quot;../items/external-blocks#abi&quot;&gt;&lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; with the exception of the entry point &lt;code&gt;fn main&lt;/code&gt;. When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">该 &lt;code&gt;transparent&lt;/code&gt; 表示</target>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;transparent&lt;/code&gt; 表示只能使用 &lt;code&gt;struct&lt;/code&gt; 具有单个非零大小字段和任意数量的零大小的领域，包括第&lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt; &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="811b48cd1ea2c8f7773b17e401a6ef4a6664ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on a &lt;a href=&quot;items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; with a single variant that has:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="translated">该 &lt;code&gt;try_recv&lt;/code&gt; 方法不会阻止，而是将返回一个 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 立即：一个 &lt;code&gt;Ok&lt;/code&gt; 值保存的消息（如果可用）和 &lt;code&gt;Err&lt;/code&gt; 值，如果此时没有任何消息。如果 &lt;code&gt;try_recv&lt;/code&gt; 在等待消息时还有其他工作要做，那么使用try_recv很有用：我们可以编写一个循环，每 &lt;code&gt;try_recv&lt;/code&gt; 调用try_recv，处理一条消息（如果一条消息可用），否则执行其他工作一段时间，直到再次检查。</target>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="translated">该 &lt;code&gt;type Target = T;&lt;/code&gt; 语法定义了要使用的 &lt;code&gt;Deref&lt;/code&gt; 特征的关联类型。关联类型是声明泛型参数的略有不同的方式，但是您现在不必担心它们。我们将在第19章中更详细地介绍它们。</target>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;type_length_limit&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="88b76f9ce33c0af8e240ed6b37ada9e83ea43da5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="translated">该 &lt;code&gt;typeof&lt;/code&gt; 运算关键字当前被保留，但没有实现。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="dd3cfc211f63708e7ec9409ea2198c30928717cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword has two uses: to declare the existence of contracts the compiler can't check (&lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt;), and to declare that a programmer has checked that these contracts have been upheld (&lt;code&gt;unsafe {}&lt;/code&gt; and &lt;code&gt;unsafe impl&lt;/code&gt;, but also &lt;code&gt;unsafe fn&lt;/code&gt; -- see below). They are not mutually exclusive, as can be seen in &lt;code&gt;unsafe fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a346e1081bfa2911e1aa0fde6117ab4a081928a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;unsafe&lt;/code&gt; 限定符表示该类型的值是一个&lt;a href=&quot;../unsafe-functions&quot;&gt;不安全的功能&lt;/a&gt;，以及 &lt;code&gt;extern&lt;/code&gt; 限定符表示它是一个&lt;a href=&quot;../items/functions#extern-functions&quot;&gt;外部函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">在 &lt;code&gt;unwind&lt;/code&gt; 属性的格式不正确。</target>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">在 &lt;code&gt;used&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="translated">所述 &lt;code&gt;usize&lt;/code&gt; 类型是无符号整数类型具有相同数目的比特作为平台的指针类型。它可以代表进程中的每个内存地址。</target>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">的 &lt;code&gt;value&lt;/code&gt; 字段的类型是 &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt; 。在执行关闭之前， &lt;code&gt;value&lt;/code&gt; 将为 &lt;code&gt;None&lt;/code&gt; 。当使用 &lt;code&gt;Cacher&lt;/code&gt; 的代码要求关闭的&lt;em&gt;结果&lt;/em&gt;时， &lt;code&gt;Cacher&lt;/code&gt; 将在那时执行关闭并将结果存储在 &lt;code&gt;value&lt;/code&gt; 字段的 &lt;code&gt;Some&lt;/code&gt; 变体中。然后，如果代码再次要求关闭的结果，而不是再次执行关闭， &lt;code&gt;Cacher&lt;/code&gt; 将返回 &lt;code&gt;Some&lt;/code&gt; 变体中保存的结果。</target>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="translated">该 &lt;code&gt;vtable&lt;/code&gt; 自定义从 &lt;code&gt;RawWaker&lt;/code&gt; 创建的 &lt;code&gt;Waker&lt;/code&gt; 的行为。对于 &lt;code&gt;Waker&lt;/code&gt; 上的每个操作，将调用基础 &lt;code&gt;RawWaker&lt;/code&gt; 的 &lt;code&gt;vtable&lt;/code&gt; 中的关联函数。</target>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="translated">从主机环境导入符号时， &lt;code&gt;wasm_import_module&lt;/code&gt; 键可用于为 &lt;code&gt;extern&lt;/code&gt; 块中的项目指定&lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly模块&lt;/a&gt;名称。如果未指定 &lt;code&gt;wasm_import_module&lt;/code&gt; ,则默认模块名称为 &lt;code&gt;env&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Button&lt;/code&gt; 上的 &lt;code&gt;width&lt;/code&gt; ， &lt;code&gt;height&lt;/code&gt; 和 &lt;code&gt;label&lt;/code&gt; 字段将与其他组件（例如 &lt;code&gt;TextField&lt;/code&gt; 类型）上的字段不同，后者可能具有这些字段和一个 &lt;code&gt;placeholder&lt;/code&gt; 字段。我们要在屏幕上绘制的每种类型都将实现 &lt;code&gt;Draw&lt;/code&gt; 特性，但将在 &lt;code&gt;draw&lt;/code&gt; 方法中使用不同的代码来定义如何绘制该特定类型，如 &lt;code&gt;Button&lt;/code&gt; 此处（没有实际的GUI代码，这超出了范围）本章的内容）。该 &lt;code&gt;Button&lt;/code&gt; 类型，例如，可能有一个额外 &lt;code&gt;impl&lt;/code&gt; 包含与用户单击按钮时发生的情况有关的方法的块。这些类型的方法不适用于 &lt;code&gt;TextField&lt;/code&gt; 之类的类型。</target>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">该 &lt;code&gt;windows_subsystem&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="translated">该 &lt;code&gt;write&lt;/code&gt; 功能需要一个输出流，以及 &lt;code&gt;Arguments&lt;/code&gt; 结构可以与预编译 &lt;code&gt;format_args!&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="translated">该 &lt;code&gt;x&lt;/code&gt; 部分是一个模式！正如我们对 &lt;code&gt;let&lt;/code&gt; 所做的那样，我们可以将函数参数中的元组与模式匹配。清单18-7在将值传递给函数时将值拆分为一个元组。</target>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="translated">该 &lt;code&gt;x&lt;/code&gt; 值被移动到闭合件所限定的闭合时，因为我们添加的 &lt;code&gt;move&lt;/code&gt; 关键字。然后，闭包拥有 &lt;code&gt;x&lt;/code&gt; 的所有权，并且 &lt;code&gt;main&lt;/code&gt; 不再在 &lt;code&gt;println!&lt;/code&gt; 使用 &lt;code&gt;x&lt;/code&gt; ！声明。删除 &lt;code&gt;println!&lt;/code&gt; 将修复此示例。</target>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="translated">该&lt;em id=&quot;the-tests-directory&quot;&gt;测试&lt;/em&gt;目录</target>
        </trans-unit>
        <trans-unit id="2382217293f35827ef839ef57a6e0636f3faa56f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;automatically_derived&lt;/code&gt; attribute&lt;/em&gt; is automatically added to &lt;a href=&quot;../items/implementations&quot;&gt;implementations&lt;/a&gt; created by the &lt;code&gt;derive&lt;/code&gt; attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="translated">在&lt;em&gt; &lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;&lt;/em&gt;表明，由于功能是不可能被调用。</target>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;&lt;/em&gt;可以在板条箱水平被施加到指定与板条箱的名称&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法。</target>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="translated">该&lt;em&gt; &lt;code&gt;deprecated&lt;/code&gt; 属性&lt;/em&gt;标记为过时的项目。 &lt;code&gt;rustc&lt;/code&gt; 将发出有关 &lt;code&gt;#[deprecated]&lt;/code&gt; 物品使用的警告。 &lt;code&gt;rustdoc&lt;/code&gt; 将显示不推荐使用的项目，包括 &lt;code&gt;since&lt;/code&gt; 版本和 &lt;code&gt;note&lt;/code&gt; （如果可用）。</target>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="translated">的&lt;em&gt; &lt;code&gt;derive&lt;/code&gt; 属性&lt;/em&gt;允许新&lt;a href=&quot;../items&quot;&gt;的项目&lt;/a&gt;为数据结构自动生成。它使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt;语法指定要实现的特征列表或&lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;派生&lt;/a&gt;要处理的宏的路径。</target>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="translated">该&lt;em&gt; &lt;code&gt;export_name&lt;/code&gt; 属性&lt;/em&gt;指定将在一个导出符号的名称，&lt;a href=&quot;items/functions&quot;&gt;功能&lt;/a&gt;或&lt;a href=&quot;items/static-items&quot;&gt;静态的&lt;/a&gt;。它使用&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法指定符号名称。</target>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="translated">该&lt;em&gt; &lt;code&gt;global_allocator&lt;/code&gt; 属性&lt;/em&gt;上使用一个&lt;a href=&quot;items/static-items&quot;&gt;静态项目&lt;/a&gt;实施&lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;特质设置全局分配器。</target>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;&lt;/em&gt;表明归因功能的副本应放置在呼叫者，而不是生成的代码来调用定义它的功能。</target>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="translated">该&lt;em&gt; &lt;code&gt;link&lt;/code&gt; 属性&lt;/em&gt;指定一个本地库编译器应与内部链接，物品的名称 &lt;code&gt;extern&lt;/code&gt; 块。它使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt;语法指定其输入。该 &lt;code&gt;name&lt;/code&gt; 关键是本机库链接的名称。该 &lt;code&gt;kind&lt;/code&gt; 键是任选的值指定的那种具有以下可能的值库：</target>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;link_section&lt;/code&gt; 属性&lt;/em&gt;指定的一个对象文件的部分&lt;a href=&quot;items/functions&quot;&gt;功能&lt;/a&gt;或&lt;a href=&quot;items/static-items&quot;&gt;静态&lt;/a&gt;的内容将被放置到。它使用&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法指定节名称。</target>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="translated">该&lt;em&gt; &lt;code&gt;macro_use&lt;/code&gt; 属性&lt;/em&gt;有两个目的。首先，通过将其应用于模块，可用于使模块的宏作用域在模块关闭时不会结束：</target>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="translated">该&lt;em&gt; &lt;code&gt;must_use&lt;/code&gt; 属性&lt;/em&gt;用来发出警告诊断时，是不是&amp;ldquo;用&amp;rdquo;的值。它可以应用到用户定义的复合类型（&lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; 小号&lt;/a&gt;，&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 小号&lt;/a&gt;和&lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; 小号&lt;/a&gt;），&lt;a href=&quot;../items/functions&quot;&gt;功能&lt;/a&gt;，和&lt;a href=&quot;../items/traits&quot;&gt;性状&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;&lt;/em&gt;可以在板条箱级别禁用优化某些代码模式来的被假定为存在的库函数的调用来施加。</target>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;no_link&lt;/code&gt; 属性&lt;/em&gt;可以在一个指定 &lt;code&gt;extern crate&lt;/code&gt; 项，以防止条板箱连接到输出。通常用于加载板条箱以仅访问其宏。</target>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;&lt;/em&gt;可以在板条箱水平被施加到发光禁用的 &lt;code&gt;main&lt;/code&gt; 符号的可执行二进制文件。当链接到某个其他对象定义 &lt;code&gt;main&lt;/code&gt; 时，这很有用。</target>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="translated">该&lt;em&gt; &lt;code&gt;no_mangle&lt;/code&gt; 属性&lt;/em&gt;可以在任何可以使用&lt;a href=&quot;items&quot;&gt;的项目&lt;/a&gt;，以禁用标准符号名字改编。该项目的符号将是该项目名称的标识符。</target>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="translated">该&lt;em&gt; &lt;code&gt;panic_handler&lt;/code&gt; 属性&lt;/em&gt;只能应用于函数签名 &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt; 。标有此&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;的功能定义了紧急情况。该&lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt;结构包含了恐慌的位置信息。在二进制，dylib或cdylib板条箱的依赖关系图中，必须有一个 &lt;code&gt;panic_handler&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;recursion_limit&lt;/code&gt; 属性&lt;/em&gt;可以在被施加&lt;a href=&quot;../crates-and-source-files&quot;&gt;箱&lt;/a&gt;级设置为类似宏膨胀或自动解除引用潜在无限递归编译时操作的最大深度。它使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法指定递归深度。</target>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;&lt;/em&gt;可以被应用到一个&lt;a href=&quot;../unsafe-functions&quot;&gt;不安全的功能&lt;/a&gt;，以使代码生成该功能为特定平台架构功能。它使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt;语法和单个 &lt;code&gt;enable&lt;/code&gt; 键来启用，该键的值是一个用逗号分隔的功能名称字符串，以启用。</target>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="translated">的&lt;em&gt; &lt;code&gt;test&lt;/code&gt; 属性&lt;/em&gt;标记的功能将被作为测试执行。仅在测试模式下才编译这些函数。测试函数必须是不带参数的自由，单态函数，并且返回类型必须为以下之一：</target>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;type_length_limit&lt;/code&gt; 属性&lt;/em&gt;限制monomorphization期间构建一个具体类型时制成型取代的最大数。它在&lt;a href=&quot;../crates-and-source-files&quot;&gt;板条箱&lt;/a&gt;级别应用，并使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法根据类型替换的数量设置限制。</target>
        </trans-unit>
        <trans-unit id="6e74f839ef9f1efad1a8f9c7c9bbeff2f9cc5cae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="translated">将&lt;em&gt; &lt;code&gt;used&lt;/code&gt; 属性&lt;/em&gt;可以只适用于&lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; 项目&lt;/a&gt;。此&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;强制编译器将变量保留在输出对象文件（.o，.rlib等）中，即使该包装箱中的任何其他项未使用或引用该变量也是如此。</target>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="translated">所述&lt;em&gt; &lt;code&gt;windows_subsystem&lt;/code&gt; 属性&lt;/em&gt;可以在板条箱水平来设置被应用&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;子系统&lt;/a&gt;上的Windows目标链接时。它使用&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;语法指定值为 &lt;code&gt;console&lt;/code&gt; 或 &lt;code&gt;windows&lt;/code&gt; 的子系统。在非Windows目标上以及对于非 &lt;code&gt;bin&lt;/code&gt; &lt;a href=&quot;linkage&quot;&gt;类型&lt;/a&gt;，将忽略此属性。</target>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">值的&lt;em&gt;对齐方式&lt;/em&gt;指定哪些地址可以有效存储该值。对齐 &lt;code&gt;n&lt;/code&gt; 的值只能存储在n的倍数的地址处。例如，对齐2的值必须存储在偶数地址，而对齐1的值必须存储在任何地址。对齐方式以字节为单位，必须至少为1，并且始终为2的幂。可以使用&lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt; &lt;code&gt;align_of_val&lt;/code&gt; &lt;/a&gt;函数检查值的对齐方式。</target>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">使用&lt;em&gt;at&lt;/em&gt;运算符（ &lt;code&gt;@&lt;/code&gt; ），我们可以创建一个变量，该变量在测试该值以查看其是否与模式匹配的同时保留一个值。清单18-29显示了一个示例，我们要测试 &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; 字段是否在 &lt;code&gt;3...7&lt;/code&gt; 范围内。但是我们也想将值绑定到变量 &lt;code&gt;id_variable&lt;/code&gt; ,以便可以在与arm相关的代码中使用它。我们可以使用与字段相同的名称来命名变量 &lt;code&gt;id&lt;/code&gt; ，但是在此示例中，我们将使用其他名称。</target>
        </trans-unit>
        <trans-unit id="6fe3095ea3510353b505863afd4ade90995e4e2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3..=7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="translated">的&lt;em&gt;反斜杠转义&lt;/em&gt;是字符 &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; 必须以表示其ASCII编码被转义） &lt;code&gt;0x5C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="translated">的&lt;em&gt;反斜杠转义&lt;/em&gt;是字符 &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; 必须以表示本身被转义）。</target>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="translated">该&lt;em&gt;堆&lt;/em&gt;是描述盒的总称。堆中分配的生命周期取决于指向它的box值的生命周期。由于框值本身可以传入和传出帧，也可以存储在堆中，因此堆分配可能会在分配它们的帧中失效。保证堆中的分配在分配的整个生命周期中都驻留在堆中的单个位置上-不会由于移动box值而重新定位。</target>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">该&lt;em&gt;项目&lt;/em&gt;的程序是已经他们的值在编译时计算和防锈处理的存储器图像中唯一地存储的那些函数，模块和类型。项目既不动态分配也不释放。</target>
        </trans-unit>
        <trans-unit id="7f297b31862071391a99da1af535c50f23bb4ea5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="translated">的&lt;em&gt;空逃逸&lt;/em&gt;是字符 &lt;code&gt;U+0030&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ），并表示的Unicode值 &lt;code&gt;U+0000&lt;/code&gt; （NUL）。</target>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="translated">的&lt;em&gt;空逃逸&lt;/em&gt;是字符 &lt;code&gt;U+0030&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ），并表示字节值 &lt;code&gt;0x00&lt;/code&gt; （ASCII NUL）。</target>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="translated">的&lt;em&gt;前奏&lt;/em&gt;是事物的名单生锈自动进口到每一个锈病程序。它保持尽可能的小，并且专注于几乎在每个Rust程序中使用的东西，尤其是特质。</target>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">在&lt;em&gt;原始的陈述&lt;/em&gt;具有相同的名称作为原始整数类型的表示。那就是： &lt;code&gt;u8&lt;/code&gt; ， &lt;code&gt;u16&lt;/code&gt; ， &lt;code&gt;u32&lt;/code&gt; ， &lt;code&gt;u64&lt;/code&gt; ， &lt;code&gt;u128&lt;/code&gt; ， &lt;code&gt;usize&lt;/code&gt; ， &lt;code&gt;i8&lt;/code&gt; ， &lt;code&gt;i16&lt;/code&gt; ， &lt;code&gt;i32&lt;/code&gt; ， &lt;code&gt;i64&lt;/code&gt; ， &lt;code&gt;i128&lt;/code&gt; ，和 &lt;code&gt;isize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3ce8f949608b1daede8105623fa327eab5c410b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rest pattern&lt;/em&gt; (the &lt;code&gt;..&lt;/code&gt; token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in &lt;a href=&quot;#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, and &lt;a href=&quot;#slice-patterns&quot;&gt;slice&lt;/a&gt; patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; for &lt;a href=&quot;#slice-patterns&quot;&gt;slice patterns&lt;/a&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">值的&lt;em&gt;大小&lt;/em&gt;是具有该项目类型（包括对齐填充）的数组中连续元素之间的字节偏移量。值的大小始终是其对齐方式的倍数。可以使用&lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt;函数检查值的大小。</target>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="translated">的&lt;em&gt;状态模式&lt;/em&gt;是一种面向对象的设计模式。模式的症结在于，值具有一些内部状态，该状态由一组&lt;em&gt;状态对象表示&lt;/em&gt;，并且值的行为根据内部状态而变化。状态对象共享功能：在Rust中，我们当然使用结构和特征，而不是对象和继承。每个状态对象负责自己的行为，并控制何时应更改为另一个状态。持有状态对象的值对状态的不同行为或何时在状态之间进行转换一无所知。</target>
        </trans-unit>
        <trans-unit id="ec835310b404eed2cb3a60731c66a0fc7069cf96" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;successor&lt;/em&gt; operation moves towards values that compare greater. The &lt;em&gt;predecessor&lt;/em&gt; operation moves towards values that compare lesser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b31d9fd96bdd059ab3da8b882ee0c455f89891" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;temporary scope&lt;/em&gt; of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;place context&lt;/a&gt;, unless it is &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c8131f661492ad3eb04d5338d01ccf9f429562" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">该&lt;em&gt;通配符模式&lt;/em&gt;的任何值匹配。它用于忽略无关紧要的值。在其他模式中，它匹配单个数据字段（与匹配其余字段的 &lt;code&gt;..&lt;/code&gt; 相反）。与标识符模式不同，它不会复制，移动或借用与其匹配的值。</target>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="translated">该&lt;strong&gt;通道&lt;/strong&gt;的发送一半已断开，并且永远不会有上它接收到的任何更多的数据。</target>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="translated">该&lt;strong&gt;编译器&lt;/strong&gt;重新排序的指令：如果编译器可以发出在较早点的指令，它会尝试这样做。例如，它可能会在代码块的顶部提升内存负载，以便CPU可以开始从内存中&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;预&lt;/a&gt;取值。</target>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="translated">现在， &lt;code&gt;cargo doc&lt;/code&gt; 为该板条箱生成的API文档将在首页上列出并链接重新导出，如图14-4所示，从而使 &lt;code&gt;PrimaryColor&lt;/code&gt; 和 &lt;code&gt;SecondaryColor&lt;/code&gt; 类型以及 &lt;code&gt;mix&lt;/code&gt; 功能更易于查找。</target>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="translated">通常通过获取当前线程的句柄，将该句柄放置在共享数据结构中，以便其他线程可以找到它，然后将其 &lt;code&gt;park&lt;/code&gt; 在循环中来使用该API 。当满足某些所需条件时，另一个线程将在该句柄上调用&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 的API</target>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="translated">测试功能的解剖</target>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="translated">阵列类型</target>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="translated">布尔类型</target>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">布尔类型 &lt;code&gt;bool&lt;/code&gt; ，其值为 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="translated">借款检查器</target>
        </trans-unit>
        <trans-unit id="706bc5bdd045092d3c34365727a87c607d4ff3a3" translate="yes" xml:space="preserve">
          <source>The C side must &lt;strong&gt;not&lt;/strong&gt; modify the length of the string (by writing a &lt;code&gt;NULL&lt;/code&gt; somewhere inside the string or removing the final one) before it makes it back into Rust using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;. See the safety section in &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096fc2c3eb95fb5d0ee6aa092c0689c069929e6f" translate="yes" xml:space="preserve">
          <source>The C-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6976366f57ccb20ad430117c89098f7fb1348a" translate="yes" xml:space="preserve">
          <source>The C-variadic type &lt;code&gt;...&lt;/code&gt; has been nested inside another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="translated">字符类型</target>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="translated">Clippy工具是一个分析代码的lints集合,这样你就可以发现常见的错误并改进你的Rust代码。</target>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="translated">默认表示法</target>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="translated">宏和函数的区别</target>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="translated">Glob Operator</target>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="translated">HTML格式可从&lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt;在线获得，以及通过 &lt;code&gt;rustup&lt;/code&gt; 安装的Rust可以离线获得；运行 &lt;code&gt;rustup docs --book&lt;/code&gt; 打开。</target>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="translated">I/O前奏曲</target>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="translated">I/O操作的超时时间已过,导致其被取消。</target>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="translated">IEEE 754-2008&amp;ldquo; binary32&amp;rdquo;和&amp;ldquo; binary64&amp;rdquo;浮点类型分别为 &lt;code&gt;f32&lt;/code&gt; 和 &lt;code&gt;f64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="translated">匹配器反变量</target>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="translated">永远不回来的类型</target>
        </trans-unit>
        <trans-unit id="41b8e7692f976fe91f0cb8053dcf33a7090a4f8c" translate="yes" xml:space="preserve">
          <source>The Pattern API provides a generic mechanism for using different pattern types when searching through a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="translated">RFC流程和团队</target>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="translated">参考文献规则</target>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="translated">Rust语言服务器为集成开发环境(IDE)集成代码完成和内联错误信息提供动力。</target>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="translated">锈迹斑斑的前奏</target>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="translated">铁锈前奏曲。</target>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="translated">Rust编程语言</target>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="translated">Rust标准库</target>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Rust标准库是便携式Rust软件的基础，Rust软件是针对&lt;a href=&quot;https://crates.io&quot;&gt;更广泛的Rust生态系统的&lt;/a&gt;一组最小且经过实践检验的共享抽象。它提供的核心类型，如&lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，库定义&lt;a href=&quot;#primitives&quot;&gt;的语言基本操作&lt;/a&gt;，&lt;a href=&quot;#macros&quot;&gt;标准宏&lt;/a&gt;，&lt;a href=&quot;io/index&quot;&gt;I / O&lt;/a&gt;和&lt;a href=&quot;thread/index&quot;&gt;多线程&lt;/a&gt;，其中&lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;许多其他的事情&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d3f2d23ee5d88e5e35ea9e8e79bcbc0fd6e3b11" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="translated">Rust编译器不会将以下行为视为&lt;em&gt;不安全&lt;/em&gt;，尽管程序员可能（应该）发现它们是不希望的，意外的或错误的。</target>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="translated">Rust编译器有一个&lt;em&gt;借用检查器&lt;/em&gt;，可以比较作用域以确定所有借用是否有效。清单10-18显示了与清单10-17相同的代码，但带有注释，显示了变量的生存期。</target>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="translated">Rust编译器始终以单个源文件作为输入来调用，并且始终生成单个输出板条箱。该源文件的处理可能会导致其他源文件作为模块加载。源文件的扩展名为 &lt;code&gt;.rs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="translated">Rust语言和编译器的发布周期为六周，这意味着用户将不断获得新功能。其他编程语言很少发布较大的更改； Rust会更频繁地发布较小的更新。一段时间后，所有这些微小的变化加起来。但是从发行版本到发行版本，可能很难回头说：&amp;ldquo;哇，在Rust 1.10和Rust 1.31之间，Rust已经改变了很多！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="bb670b9e802863986c803bc2c279a2c3ad127d26" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in &lt;a href=&quot;appendix-01-keywords&quot;&gt;Appendix A&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="translated">与其他语言一样，Rust语言具有一组&lt;em&gt;关键字&lt;/em&gt;，仅保留给该语言使用。请记住，您不能将这些词用作变量或函数的名称。大多数关键字具有特殊含义，您将使用它们在Rust程序中执行各种任务；有几个没有与之关联的当前功能，但已保留用于将来可能会添加到Rust的功能。您可以在附录A中找到关键字列表。</target>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="translated">Rust语言希望也能支持许多其他用户。这里提到的只是最大的利益相关者。总体而言，Rust的最大野心是通过提供安全性&lt;em&gt;和&lt;/em&gt;生产率，速度&lt;em&gt;和&lt;/em&gt;人体工程学来消除程序员数十年来接受的折衷方案。尝试一下Rust，看看它的选择是否对您有用。</target>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="translated">Rust运行时</target>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="translated">Rust标准库为消息传递和智能指针类型（例如 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 提供了通道，这些类型可以在并发上下文中安全使用。类型系统和借位检查器确保使用这些解决方案的代码不会以数据争用或无效引用结尾。一旦可以编译代码，您就可以放心，它可以愉快地在多个线程上运行，而不会遇到其他语言中常见的难以追踪的错误。并发编程不再是一个令人恐惧的概念：继续前进，毫不费力地使您的程序并发！</target>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="translated">Rust类型系统具有我们在本书中提到但尚未讨论的一些功能。我们将首先讨论新类型，然后再检查为什么新类型可用作类型。然后，我们继续输入别名，该别名类似于新类型，但语义稍有不同。我们还将讨论 &lt;code&gt;!&lt;/code&gt; 类型和动态调整大小的类型。</target>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="translated">切片式</target>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="translated">栈和堆</target>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="translated">静态寿命</target>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="translated">测试模块和 &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt; 的权衡</target>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">传输控制协议在&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793中&lt;/a&gt;指定。</target>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="translated">元组类型</target>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="translated">不应该直接实现Unsize特性。所有Unsize的实现都是由编译器自动提供的。</target>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="translated">返回仅由其实现的特征指定的类型的功能在闭包和迭代器的上下文中特别有用，我们将在第13章中介绍闭包和迭代器。指定。该 &lt;code&gt;impl Trait&lt;/code&gt; 语法，您可以简明地指定一个函数返回某种类型实现了 &lt;code&gt;Iterator&lt;/code&gt; 特性，而无需写出一个很长的类型。</target>
        </trans-unit>
        <trans-unit id="8344955111fdc074c9729e11010ee2eab0af03c1" translate="yes" xml:space="preserve">
          <source>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde40ac9fea8ec2f55d9ca0d422fc89008496087" translate="yes" xml:space="preserve">
          <source>The above indirection is the additional runtime cost of calling a function on a &lt;code&gt;dyn Trait&lt;/code&gt;. Methods called by dynamic dispatch generally cannot be inlined by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb20b7d624d1708cb7603af7f7d5931910cd966" translate="yes" xml:space="preserve">
          <source>The above is &lt;em&gt;still&lt;/em&gt; an expression but it will always evaluate to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede9c72b891dfc1d92b0b9fffc4f21007f9ae902" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">&lt;code&gt;i128::min_value()&lt;/code&gt; 的绝对值不能表示为 &lt;code&gt;i128&lt;/code&gt; ，尝试计算它会导致溢出。这意味着在这种情况下，调试模式下的代码将触发紧急情况，优化的代码将返回 &lt;code&gt;i128::min_value()&lt;/code&gt; 而不会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="68e6f1c95dcf27a099d3d4e155f55896bf8faf93" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">&lt;code&gt;i16::min_value()&lt;/code&gt; 的绝对值不能表示为 &lt;code&gt;i16&lt;/code&gt; ，尝试计算它会导致溢出。这意味着在这种情况下，调试模式下的代码将触发紧急情况，优化的代码将返回 &lt;code&gt;i16::min_value()&lt;/code&gt; 而不会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="37e2f0833c2e3fce2e0d86c6e578d1435f9c3b8f" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">&lt;code&gt;i32::min_value()&lt;/code&gt; 的绝对值不能表示为 &lt;code&gt;i32&lt;/code&gt; ，尝试计算它会导致溢出。这意味着在这种情况下，调试模式下的代码将触发紧急情况，优化的代码将返回 &lt;code&gt;i32::min_value()&lt;/code&gt; 而不会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="2ddae722d1b9330d37bd61655516374aae130695" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">&lt;code&gt;i64::min_value()&lt;/code&gt; 的绝对值不能表示为 &lt;code&gt;i64&lt;/code&gt; ，并且尝试计算它会导致溢出。这意味着在这种情况下，调试模式下的代码将触发紧急情况，优化的代码将返回 &lt;code&gt;i64::min_value()&lt;/code&gt; 而不会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="94540f2ba32a8d4e2123f1b683b0ff15f6511fa8" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">&lt;code&gt;i8::min_value()&lt;/code&gt; 的绝对值不能表示为 &lt;code&gt;i8&lt;/code&gt; ，尝试计算它会导致溢出。这意味着在这种情况下，调试模式下的代码将触发紧急情况，优化的代码将返回 &lt;code&gt;i8::min_value()&lt;/code&gt; 而不会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="f3616827787c274826d0feb8bc695ca0f90e8398" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">&lt;code&gt;isize::min_value()&lt;/code&gt; 的绝对值不能表示为 &lt;code&gt;isize&lt;/code&gt; ，尝试对其进行计算将导致溢出。这意味着在调试模式下的代码将在这种情况下触发紧急情况，优化的代码将返回 &lt;code&gt;isize::min_value()&lt;/code&gt; 而不会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="409fd764bcabc3595ffe004849ff8f4e30564756" translate="yes" xml:space="preserve">
          <source>The actual desugaring is more complex:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="translated">如果平台指定了最小堆栈大小,那么实际的堆栈大小可能会大于这个值。</target>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="translated">加法赋值运算符 &lt;code&gt;+=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">加法运算符 &lt;code&gt;+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="161b60a028315218a44d6ebb4a0a56ea64addb73" translate="yes" xml:space="preserve">
          <source>The address of temporary value was taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">地址类型可以是&lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt;特征的任何实现。有关具体示例，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="translated">在运行时检查借贷规则的好处是,某些内存安全的情况就会被允许,而编译时的检查则不允许。静态分析和Rust编译器一样,本质上是保守的。代码的某些属性是无法通过分析代码来检测的:最著名的例子是Halting问题,这不在本书的讨论范围内,但却是一个有趣的研究课题。</target>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="translated">使用特征对象和Rust的类型系统来编写类似于使用鸭子类型的代码的代码的优点是，我们不必在运行时检查值是否实现了特定方法，也不必担心如果值不实现方法却会出错。我们还是这样称呼。如果值未实现特征对象所需的特征，Rust将不会编译我们的代码。</target>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="translated">在编译时检查借用规则的优点在于，在开发过程中会更快地发现错误，并且不会对运行时性能产生任何影响，因为所有分析都是预先完成的。由于这些原因，在大多数情况下，在编译时检查借用规则是最佳选择，这就是Rust的默认设置。</target>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="translated">对齐方式以 &lt;code&gt;#[repr(align(x))]&lt;/code&gt; 或 &lt;code&gt;#[repr(packed(x))]&lt;/code&gt; 的形式指定为整数参数。对齐值必须是1到2 &lt;sup&gt;29的&lt;/sup&gt; 2的幂。对于 &lt;code&gt;packed&lt;/code&gt; ，如果没有给出值，如 &lt;code&gt;#[repr(packed)]&lt;/code&gt; ，则该值为1。</target>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="translated">可以分别使用 &lt;code&gt;align&lt;/code&gt; 和 &lt;code&gt;packed&lt;/code&gt; 修饰符来提高或降低对齐方式。它们更改属性中指定的表示形式。如果未指定任何表示形式，则会更改默认表示形式。</target>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="translated">调整修饰符</target>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">值的对齐方式指定首选从哪个地址开始。总是二的幂。对值的引用必须对齐。&lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;更多&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="translated">结构体的对齐方式是指其中最对齐的字段的对齐方式。</target>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="translated">所分配的内存块可能被初始化,也可能不被初始化。</target>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="translated">分配错误钩子是一个全局资源。</target>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">当可靠的内存分配失败时（在运行时中止之前），将调用分配错误挂钩。默认的挂钩将向标准错误打印一条消息，但是可以使用&lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt;函数自定义此行为。</target>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="translated">备用标志 &lt;code&gt;#&lt;/code&gt; 在输出前面添加一个 &lt;code&gt;0b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="translated">备用标志 &lt;code&gt;#&lt;/code&gt; 在输出前面添加 &lt;code&gt;0o&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="translated">备用标志 &lt;code&gt;#&lt;/code&gt; 在输出前面添加一个 &lt;code&gt;0x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">这个问题的答案的问题是&lt;em&gt;Cargo.lock&lt;/em&gt;文件，它创建的第一次运行 &lt;code&gt;cargo build&lt;/code&gt; ，现在是你的&lt;em&gt;guessing_game&lt;/em&gt;目录。首次构建项目时，Cargo会找出符合条件的所有依赖项版本，然后将它们写入&lt;em&gt;Cargo.lock&lt;/em&gt;文件。将来在构建项目时，Cargo将看到&lt;em&gt;Cargo.lock&lt;/em&gt;文件存在并使用那里指定的版本，而不是再次进行所有确定版本的工作。这使您可以自动生成可复制的版本。换句话说，由于 &lt;code&gt;0.3.14&lt;/code&gt; ，您的项目将保持在0.3.14，直到您明确升级&lt;em&gt;为止。&lt;/em&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="8fb95ccc8cbb2b44a80d4d0a731ecb5bea70e713" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.5.5&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50839f5b75ebf2449202c65bd78e83e2a04633c" translate="yes" xml:space="preserve">
          <source>The argument order should be changed to match the parameter declaration order, as in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3b9111423732cd0796ed3af4340d1aeaddff87" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;llvm_asm&lt;/code&gt; macro is not well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="translated">参数 &lt;code&gt;mid&lt;/code&gt; 应该是字符串开头的字节偏移量。它也必须在UTF-8代码点的边界上。</target>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="translated">参数将按照指定的格式字符串格式化到提供的输出流中。</target>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="translated">通过实现&lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt;和&lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt;特性，可以为数组和切片以外的类型实现数组索引表达式。</target>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="translated">名为 &lt;code&gt;a&lt;/code&gt; 的数组将包含 &lt;code&gt;5&lt;/code&gt; 个元素，这些元素最初将全部设置为值 &lt;code&gt;3&lt;/code&gt; 。这与编写 &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; 但以更简洁的方式</target>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="translated">可以从解析中返回的相关错误。</target>
        </trans-unit>
        <trans-unit id="264397f1a1d81bc0bfb862d1058ae5d080545332" translate="yes" xml:space="preserve">
          <source>The associated type used was not defined in the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;types/trait-object&quot;&gt;特质对象&lt;/a&gt;持有的引用的假定生存期称为其&lt;em&gt;默认对象生存期界限&lt;/em&gt;。这些定义在&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599中，&lt;/a&gt;并在&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156中进行了&lt;/a&gt;修订。</target>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="translated">原子内在函数对机器字提供常见的原子操作，并具有多种可能的存储顺序。它们遵循与C ++ 11相同的语义。请参阅[ &lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;原子&lt;/a&gt; ] 上的LLVM文档。</target>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="translated">本模块中的原子类型可能不是在所有平台上都可以使用。但是,这里的原子类型都是广泛存在的,一般都可以依赖现有的原子类型。一些明显的例外是:</target>
        </trans-unit>
        <trans-unit id="71cc0f45759d249e1ba21744ede7b9ef7445260e" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">该属性包括该属性的路径，然后是一个可选的定界标记树，其解释由该属性定义。除宏属性外的其他属性也允许输入为等号（ &lt;code&gt;=&lt;/code&gt; ）后跟文字表达式。有关更多详细信息，请参见下面的&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;元项目语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">该属性用于其类型实现&lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;特性的 &lt;code&gt;static&lt;/code&gt; 项目。可以由外部库提供此类型：</target>
        </trans-unit>
        <trans-unit id="638938ad1b96ca367b1ad29ad316e67748e69b45" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">在块表达式中有意义的属性是&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">在函数上具有意义的属性是&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint检查属性&lt;/a&gt;，&lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../procedural-macros&quot;&gt;过程宏属性&lt;/a&gt;，&lt;a href=&quot;../attributes/testing&quot;&gt;测试属性&lt;/a&gt;和&lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;优化提示属性&lt;/a&gt;。函数还接受属性宏。</target>
        </trans-unit>
        <trans-unit id="622c3bad6ebce7dda9ab10b347056427bd42a746" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="translated">清单14-4中的代码作者使用了 &lt;code&gt;art&lt;/code&gt; 包装盒，不得不弄清楚 &lt;code&gt;PrimaryColor&lt;/code&gt; 在 &lt;code&gt;kinds&lt;/code&gt; 模块中，而 &lt;code&gt;mix&lt;/code&gt; 在 &lt;code&gt;utils&lt;/code&gt; 模块中。所述的模块结构 &lt;code&gt;art&lt;/code&gt; 箱子是更相关的上工作的开发 &lt;code&gt;art&lt;/code&gt; 板条箱比使用开发商 &lt;code&gt;art&lt;/code&gt; 板条箱。将板条箱的各个部分组织到 &lt;code&gt;kinds&lt;/code&gt; 模块和 &lt;code&gt;utils&lt;/code&gt; 模块的内部结构对于试图了解如何使用 &lt;code&gt;art&lt;/code&gt; 板条箱的人来说不包含任何有用的信息。相反， &lt;code&gt;art&lt;/code&gt; crate的模块结构引起混乱，因为开发人员必须弄清楚在哪里看，而结构不便，因为开发人员必须在 &lt;code&gt;use&lt;/code&gt; 语句中指定模块名称。</target>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="translated">该代码的作者可能希望 &lt;code&gt;collect()&lt;/code&gt; 返回 &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt; ，但是编译器无法确定没有另一个 &lt;code&gt;T&lt;/code&gt; 类型同时实现 &lt;code&gt;Try&lt;/code&gt; 和 &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; 范围，使得 &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 。因此，此代码不明确，并返回错误。</target>
        </trans-unit>
        <trans-unit id="946c3c8468dffe1ee08b57091aa458b31b356f72" translate="yes" xml:space="preserve">
          <source>The automatically generated &quot;drop glue&quot; which recursively calls the destructors of the all fields of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="translated">状态不好是不是一件&lt;em&gt;预期&lt;/em&gt;偶尔发生。</target>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="translated">一个的基&lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;官能更新&lt;/a&gt;结构表达。</target>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="translated">返回的行为 &lt;code&gt;Waker&lt;/code&gt; ，如果在规定的合同是不明确的&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;的和&lt;a href=&quot;struct.rawwakervtable&quot;&gt; &lt;code&gt;RawWakerVTable&lt;/code&gt; &lt;/a&gt;的文档不成立。因此，此方法不安全。</target>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="translated">此方法的行为必须独立于 &lt;code&gt;Read&lt;/code&gt; 的状态-该方法仅采用 &lt;code&gt;&amp;amp;self&lt;/code&gt; ,以便可以通过特征对象使用。</target>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="translated">具有此限制的好处是Rust可以防止在编译时发生数据争用。一个&lt;em&gt;数据的比赛&lt;/em&gt;相似，竞争条件，当这三种行为的发生情况：</target>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="translated">定义访问模式的位被 &lt;code&gt;O_ACCMODE&lt;/code&gt; 屏蔽，以确保它们不会干扰Rusts选项设置的访问模式。</target>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="translated">按位AND赋值运算符 &lt;code&gt;&amp;amp;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">按位AND运算符 &lt;code&gt;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="translated">按位或赋值运算符 &lt;code&gt;|=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">按位或运算符 &lt;code&gt;|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="translated">按位XOR赋值运算符 &lt;code&gt;^=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">按位XOR运算符 &lt;code&gt;^&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="translated">从概念上讲，功能块包装在绑定参数模式的块中，然后 &lt;code&gt;return&lt;/code&gt; s功能块的值。这意味着，如果对该块的尾部表达式求值，最终将其返回给调用方。与往常一样，如果函数到达函数体，则该函数体中的显式return表达式将简化该隐式返回。</target>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="translated">块的大小必须在 &lt;code&gt;[use_min, use_max]&lt;/code&gt; 范围内，其中：</target>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="translated">块的起始地址必须与 &lt;code&gt;layout.align()&lt;/code&gt; 对齐。</target>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="translated">在两种情况下， &lt;code&gt;if let&lt;/code&gt; 和 &lt;code&gt;unwrap_or_else&lt;/code&gt; 函数的主体相同：我们输出错误并退出。</target>
        </trans-unit>
        <trans-unit id="a084bd821dcd5af3bead7d20966da99b85c8d3d6" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="translated">该函数的主体通过调用 &lt;code&gt;File::open&lt;/code&gt; 函数开始。然后我们处理 &lt;code&gt;Result&lt;/code&gt; 有返回值 &lt;code&gt;match&lt;/code&gt; 类似 &lt;code&gt;match&lt;/code&gt; 9-4，而不是只调用 &lt;code&gt;panic!&lt;/code&gt; 在 &lt;code&gt;Err&lt;/code&gt; 的情况下，我们从该函数中提前返回，并将 &lt;code&gt;File::open&lt;/code&gt; 的错误值作为该函数的错误值传递回调用代码。如果 &lt;code&gt;File::open&lt;/code&gt; 成功，我们将文件句柄存储在变量 &lt;code&gt;f&lt;/code&gt; 中并继续。</target>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="translated">该方法的主体将使用 &lt;code&gt;self&lt;/code&gt; 获得我们调用该方法所基于的值。在这个例子中，我们创建了一个变量 &lt;code&gt;m&lt;/code&gt; 具有价值 &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt; ，而这正是 &lt;code&gt;self&lt;/code&gt; 会在体内 &lt;code&gt;call&lt;/code&gt; 方法时 &lt;code&gt;m.call()&lt;/code&gt; 运行。</target>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="translated">Erich Gamma，Richard Helm，Ralph Johnson和John Vlissides 撰写的《&lt;em&gt;设计模式：可重用的面向对象软件&lt;/em&gt;的&lt;em&gt;元素》&lt;/em&gt;（Addison-Wesley Professional，1994年）俗称&lt;em&gt;&amp;ldquo;四人帮&amp;rdquo;&lt;/em&gt;一书，是一本面向对象的目录。设计模式。它以这种方式定义OOP：</target>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="translated">布尔型。</target>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="translated">借用一直持续到返回的 &lt;code&gt;Ref&lt;/code&gt; 退出作用域为止。可以同时提取多个不可变的借项。</target>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="translated">借用一直持续到返回的 &lt;code&gt;RefMut&lt;/code&gt; 或 &lt;code&gt;RefMut&lt;/code&gt; 退出合并范围派生的所有RefMut为止。该借用处于活动状态时，不能借入该值。</target>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="translated">在返回写入器之前,缓冲区会被写出来。</target>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="translated">指定的缓冲区长度为0字节。</target>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="translated">内置的 &lt;code&gt;cfg&lt;/code&gt; 宏采用单个配置谓词，并且在谓词为true时评估为 &lt;code&gt;true&lt;/code&gt; 文字，在其为false时评估为 &lt;code&gt;false&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">在函数上有意义的内置属性是&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check属性&lt;/a&gt;， &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;no_implicit_prelude&lt;/code&gt; 。模块还接受宏属性。</target>
        </trans-unit>
        <trans-unit id="0658caeac4e6cc6250807a10a1d1127da8f7b8cb" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a module are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="translated">内置函数特征是在函数参数的元组上通用的。如果使用尖括号（ &lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt; ）而不是括号（ &lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; ）表示函数特征，则类型参数应为元组。否则，将无法使用函数调用符号，并且闭包将不会实现该特征。</target>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">c-main函数仅支持将整数作为返回类型。因此，实现 &lt;code&gt;Termination&lt;/code&gt; 特性的每种类型都必须转换为整数。</target>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="translated">如果另一个持有该锁的线程惊慌失措，则对 &lt;code&gt;lock&lt;/code&gt; 的调用将失败。在那种情况下，没有人能够获得锁，因此如果我们处于这种情况，我们选择 &lt;code&gt;unwrap&lt;/code&gt; 并让该线程出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">调用 &lt;code&gt;panic!&lt;/code&gt; 导致最后两行中包含错误消息。第一行显示了紧急消息以及源代码中发生紧急事件的位置：&lt;em&gt;src / main.rs：2：5&lt;/em&gt;表示这是第二行，即&lt;em&gt;src / main.rs&lt;/em&gt;文件的第五个字符。</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;A👍%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; 调用很容易导致错误。例如，如果字符串包含 &lt;code&gt;A👍%&lt;/code&gt; ，则无法将其转换为数字。由于 &lt;code&gt;parse&lt;/code&gt; 方法可能会失败，因此它会返回 &lt;code&gt;Result&lt;/code&gt; 类型，就像 &lt;code&gt;read_line&lt;/code&gt; 方法所做的一样（前面在&lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;使用 &lt;code&gt;Result&lt;/code&gt; 类型处理潜在的失败&amp;rdquo;中进行&lt;/a&gt;了讨论）。再次使用 &lt;code&gt;expect&lt;/code&gt; 方法，将以相同的方式处理此 &lt;code&gt;Result&lt;/code&gt; 。如果 &lt;code&gt;parse&lt;/code&gt; 由于无法从字符串中创建数字而返回 &lt;code&gt;Err&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 变体，则 &lt;code&gt;expect&lt;/code&gt; 通话会使游戏崩溃并打印我们给出的消息。如果 &lt;code&gt;parse&lt;/code&gt; 可以成功将字符串转换为数字，它将返回 &lt;code&gt;Result&lt;/code&gt; 的 &lt;code&gt;Ok&lt;/code&gt; 变体，并且 &lt;code&gt;expect&lt;/code&gt; 将从 &lt;code&gt;Ok&lt;/code&gt; 值中返回我们想要的数字。</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">对 &lt;code&gt;recv&lt;/code&gt; 的调用会阻塞，因此，如果尚无作业，则当前线程将等待，直到有可用的作业为止。的 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 确保只有一个 &lt;code&gt;Worker&lt;/code&gt; 在一个时间线程试图请求的作业。</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">调用者必须确保所提供的线程闭包中的任何引用或它的返回类型都不能超过所产线程的寿命。这可以通过两种方式来保证。</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用者还必须确保从未使用此指针或从其派生的任何指针将指针（非传递性地）指向的内存写入（除非在 &lt;code&gt;UnsafeCell&lt;/code&gt; 内）。如果您需要更改切片的内容，请使用&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbd8e378206e5ebe48537e21894c0d0196aa5c37" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2daa4ea0adccac77e0ee2e5186b78bccb935a23d" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying &lt;code&gt;str&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用者必须确保返回的指针永远不会被写入。如果需要更改字符串切片的内容，请使用&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c95ecf028004da1510b460935745006e917bea1" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2dba4a5088d0450aaa1d7584230c3882b4aa0e" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">调用者必须确保分片的时间超过这个函数返回的指针,否则最终会指向垃圾。</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">调用者必须确保向量超过这个函数返回的指针,否则它最终会指向垃圾。修改向量可能会导致其缓冲区被重新分配,这也会使任何指向它的指针无效。</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">调用的线程将被阻塞,直到没有更多的写入者持有锁。当本方法返回时,锁内可能还有其他读者。本方法不保证有争议的读者或写入者是否会先获得锁的顺序。</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">对 &lt;code&gt;thread::sleep&lt;/code&gt; 的调用强制线程在短时间内停止执行，从而允许其他线程运行。线程可能会轮流使用，但不能保证：这取决于您的操作系统如何调度线程。在此运行中，即使从代码生成的线程中首先出现了print语句，也首先打印了主线程。即使我们告诉生成的线程打印直到 &lt;code&gt;i&lt;/code&gt; 为9，它也只能在主线程关闭之前达到5。</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">在此平台上成功终止的规范ExitCode。</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">本平台上不成功终止的规范ExitCode。</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">规范路径只在特定的板条箱内有意义。没有跨箱子的全局命名空间;一个物品的规范路径只是在箱子中标识它。</target>
        </trans-unit>
        <trans-unit id="42b8d1ea1b4247711765802c026fc2d790b1362d" translate="yes" xml:space="preserve">
          <source>The canonical safe use of &lt;code&gt;mem::forget&lt;/code&gt; is to circumvent a value's destructor implemented by the &lt;code&gt;Drop&lt;/code&gt; trait. For example, this will leak a &lt;code&gt;File&lt;/code&gt;, i.e. reclaim the space taken by the variable but never close the underlying system resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">容量可以进一步地增加比 &lt;code&gt;additional&lt;/code&gt; 字节，如果它选择，以避免频繁的重新分配。</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">向量的容量是为将添加到向量上的任何将来元素分配的空间量。请勿将其与向量的&lt;em&gt;长度&lt;/em&gt;混淆，后者指定了向量中实际元素的数量。如果向量的长度超过其容量，则其容量将自动增加，但必须重新分配其元素。</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">容量将至少保持与长度和供应值一样大。</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">&lt;a href=&quot;types/closure&quot;&gt;闭包&lt;/a&gt;的捕获值以未指定的顺序删除。</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">我们需要对 &lt;code&gt;main&lt;/code&gt; 进行的更改以重新分配 &lt;code&gt;post&lt;/code&gt; ，这意味着此实现不再完全遵循面向对象的状态模式：状态之间的转换不再完全封装在 &lt;code&gt;Post&lt;/code&gt; 实现中。但是，我们的收获是，由于类型系统和编译时发生的类型检查，现在无效状态已成为不可能！这样可以确保在将某些错误（例如未发布帖子的内容显示）投入生产之前，将其发现。</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">这个转义词所代表的字符</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">字符类型 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">子描述符继承自相应的父描述符。</target>
        </trans-unit>
        <trans-unit id="57f64da60a0aae4c7ca65b39d52634b157698777" translate="yes" xml:space="preserve">
          <source>The chunks are array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fa38fbe64a63fe95b52b94271d4ba554613043" translate="yes" xml:space="preserve">
          <source>The chunks are mutable array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">块是可变切片，并且不重叠。如果 &lt;code&gt;chunk_size&lt;/code&gt; 没有划分切片的长度，那么最后一个块的长度将不会为 &lt;code&gt;chunk_size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">块是可变切片，并且不重叠。如果 &lt;code&gt;chunk_size&lt;/code&gt; 不分割切片的长度，则最后一个不超过 &lt;code&gt;chunk_size-1&lt;/code&gt; 的元素将被忽略，并可从迭代器的 &lt;code&gt;into_remainder&lt;/code&gt; 函数中检索。</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">块是切片，并且不重叠。如果 &lt;code&gt;chunk_size&lt;/code&gt; 没有划分切片的长度，那么最后一个块的长度将不会为 &lt;code&gt;chunk_size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">块是切片，并且不重叠。如果 &lt;code&gt;chunk_size&lt;/code&gt; 没有划分切片的长度，那么最后一个不超过 &lt;code&gt;chunk_size-1&lt;/code&gt; 的元素将被忽略，并且可以从迭代器的 &lt;code&gt;remainder&lt;/code&gt; 函数中检索。</target>
        </trans-unit>
        <trans-unit id="5ab8cfd0030cc999866ad155de372dfc9a291653" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">闭包 &lt;code&gt;f&lt;/code&gt; 产生了一次&lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt;结构，该结构可用于查询 &lt;code&gt;Once&lt;/code&gt; 状态的中毒状态。</target>
        </trans-unit>
        <trans-unit id="6122336d1e3dc25f0e6a48ca5c6617d72884ddeb" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">如果在多个线程中同时调用闭包 &lt;code&gt;f&lt;/code&gt; ,则它将仅执行一次。但是，如果该关闭恐慌，则它将&lt;em&gt;毒害&lt;/em&gt;此 &lt;code&gt;Once&lt;/code&gt; 实例，从而导致所有将来对 &lt;code&gt;call_once&lt;/code&gt; 的调用也都惊慌。</target>
        </trans-unit>
        <trans-unit id="9a9ae7f6f31f6430eeec94354c414e42d745c712" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;a href=&quot;../keyword.move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; keyword on the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">闭包可以使用捕获及其环境来跟踪迭代之间的状态。根据迭代器的使用方式，这可能需要在闭包上指定 &lt;code&gt;move&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">闭包从环境中捕获 &lt;code&gt;shoe_size&lt;/code&gt; 参数，并将该值与每个鞋子的大小进行比较，仅保留指定大小的鞋子。最后，调用 &lt;code&gt;collect&lt;/code&gt; 将经过修改的迭代器返回的值收集到该函数返回的向量中。</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">闭包定义位于 &lt;code&gt;=&lt;/code&gt; 之后，以将其分配给变量 &lt;code&gt;expensive_closure&lt;/code&gt; 。要定义一个闭合，我们从一对垂直管道（ &lt;code&gt;|&lt;/code&gt; ）开始，在其中我们为闭合指定参数。选择该语法是因为它与Smalltalk和Ruby中的闭包定义相似。此闭包有一个名为 &lt;code&gt;num&lt;/code&gt; 的参数：如果我们有多个参数，则将它们用逗号分隔，例如 &lt;code&gt;|param1, param2|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">闭包允许返回一个I/O错误,其OS错误代码将被传达回父体,并作为请求spwn时的错误返回。</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">闭包必须返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;filter()&lt;/code&gt; 创建一个迭代器，该迭代器在每个元素上调用此闭包。如果闭包返回 &lt;code&gt;true&lt;/code&gt; ，则返回元素。如果闭包返回 &lt;code&gt;false&lt;/code&gt; ，它将再次尝试，并在下一个元素上调用闭包，看看它是否通过了测试。</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">闭包必须返回&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;filter_map&lt;/code&gt; 创建一个迭代器，该迭代器在每个元素上调用此闭包。如果闭包返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt;，则返回该元素。如果闭包返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，它将重试，并在下一个元素上调用闭包，看是否将返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">需要使用提供的闭包来遵守&lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;特性，以确保所有捕获的变量都可以安全地越过该边界。此绑定的目的是对类型系统中的&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;异常安全性&lt;/a&gt;概念进行编码。此功能的大多数用法都不必担心此限制，因为程序自然会在没有 &lt;code&gt;unsafe&lt;/code&gt; 代码的情况下是安全的。如果出现问题，可以使用&lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt;包装器结构快速断言此处的用法确实是安全的。</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">闭包使用 &lt;code&gt;v&lt;/code&gt; ，因此它将捕获 &lt;code&gt;v&lt;/code&gt; 并将其纳入闭包环境的一部分。因为 &lt;code&gt;thread::spawn&lt;/code&gt; 在新线程中运行此闭包，所以我们应该能够在该新线程内访问 &lt;code&gt;v&lt;/code&gt; 。但是，当我们编译此示例时，我们得到以下错误：</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">与每个分支关联的代码是一个表达式，而在匹配分支中该表达式的结果值是为整个 &lt;code&gt;match&lt;/code&gt; 表达式返回的值。</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">清单13-17中的代码不执行任何操作。我们指定的闭包永远不会被调用。该警告提醒我们原因：迭代器适配器是惰性的，我们需要在此处使用迭代器。</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">清单13-3中的代码多次调用了慢速计算函数。第一 &lt;code&gt;if&lt;/code&gt; 块调用 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 两次， &lt;code&gt;if&lt;/code&gt; 里面的外 &lt;code&gt;else&lt;/code&gt; 都不会调用它，第二里面的代码 &lt;code&gt;else&lt;/code&gt; 情况下，一旦调用它。</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">清单16-1中的代码不仅由于主线程结束而在大多数时间过早地停止了产生的线程，而且不能保证产生的线程将完全运行。原因是不能保证线程的运行顺序！</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">清单16-8中的代码已编译并运行，但没有清楚地向我们展示两个单独的线程正在通过通道相互通信。在清单16-10中，我们进行了一些修改，以证明清单16-8中的代码正在同时运行：生成的线程现在将发送多条消息，并在每条消息之间暂停一秒钟。</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">清单18-1中的代码显示了对几种条件的一系列检查，这些条件决定了背景色应该是什么。在此示例中，我们创建了带有硬编码值的变量，真实程序可能会从用户输入中接收这些值。</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">清单18-3中的代码将打印以下内容。</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">清单20-14中的代码将编译，但尚未创建任何线程。我们已经更改了 &lt;code&gt;ThreadPool&lt;/code&gt; 的定义，以保存一个 &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 实例的矢量，使用 &lt;code&gt;size&lt;/code&gt; 的容量初始化该矢量，设置一个 &lt;code&gt;for&lt;/code&gt; 循环，该循环将运行一些代码来创建线程，并返回一个包含它们的 &lt;code&gt;ThreadPool&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="d3a6f7dff2487d4bcc7b7e0489bef3c4a5207416" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">清单20-21中的代码按照我们的预期通过使用线程池异步响应请求。我们收到一些关于我们未直接使用的 &lt;code&gt;workers&lt;/code&gt; ， &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;thread&lt;/code&gt; 字段的警告，提醒我们我们没有清除任何内容。当我们使用不太优雅的ctrl-c方法暂停主线程时，所有其他线程也会立即停止，即使它们处于服务请求的中间。</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">清单5-7中的代码还在 &lt;code&gt;user2&lt;/code&gt; 中创建了一个实例，该实例的 &lt;code&gt;email&lt;/code&gt; 和 &lt;code&gt;username&lt;/code&gt; 值不同，但是 &lt;code&gt;user1&lt;/code&gt; 的 &lt;code&gt;active&lt;/code&gt; 和 &lt;code&gt;sign_in_count&lt;/code&gt; 字段的值相同。</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">清单8-7中的代码可能看起来应该工作：为什么对第一个元素的引用应该关心向量结尾处的变化？此错误是由于向量的工作方式造成的：如果没有足够的空间将所有元素放在每个元素的旁边，则在向量的末尾添加新元素可能需要分配新的内存并将旧元素复制到新空间中向量当前所在的其他位置。在这种情况下，对第一个元素的引用将指向释放的内存。借用规则阻止程序在这种情况下结束。</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">清单9-4中的代码会 &lt;code&gt;panic!&lt;/code&gt; 不管为什么 &lt;code&gt;File::open&lt;/code&gt; 失败。我们要做的是针对不同的失败原因采取不同的操作：如果 &lt;code&gt;File::open&lt;/code&gt; 因文件不存在而失败，我们想要创建文件并将句柄返回到新文件。如果 &lt;code&gt;File::open&lt;/code&gt; 由于其他任何原因失败（例如，由于我们没有打开文件的权限），我们仍然希望代码 &lt;code&gt;panic!&lt;/code&gt; 与清单9-4相同。请看清单9-5，它添加了一个内部 &lt;code&gt;match&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">该代码试图将 &lt;code&gt;receiver&lt;/code&gt; 传递给多个 &lt;code&gt;Worker&lt;/code&gt; 实例。正如您从第16章所回顾的那样，这是行不通的，Rust提供的通道实现是多个&lt;em&gt;生产者&lt;/em&gt;，单个&lt;em&gt;消费者&lt;/em&gt;。这意味着我们不能仅仅克隆通道的使用端来修复此代码。即使我们可以，那也不是我们想要使用的技术。相反，我们希望通过在所有工作程序之间共享单个 &lt;code&gt;receiver&lt;/code&gt; 在线程之间分配作业。</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">该代码指的是一个不在范围内的特征。</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">然后，调用此代码的代码将处理获取包含用户名的 &lt;code&gt;Ok&lt;/code&gt; 值或包含 &lt;code&gt;io::Error&lt;/code&gt; 的 &lt;code&gt;Err&lt;/code&gt; 值。我们不知道调用代码将如何处理这些值。如果调用代码获得 &lt;code&gt;Err&lt;/code&gt; 值，则可能会出现 &lt;code&gt;panic!&lt;/code&gt; 并崩溃程序，使用默认用户名，或从文件以外的其他位置查找用户名。我们没有足够的信息来了解调用代码实际上在试图做什么，因此我们将所有成功或错误信息向上传播，以使其能够正确处理。</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">藏品可以预留更多的空间,避免频繁的重新分配。</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$()&lt;/code&gt; 后面的逗号表示，在与 &lt;code&gt;$()&lt;/code&gt; 中的代码匹配的代码之后，可以有选择地显示文字逗号分隔符。该 &lt;code&gt;*&lt;/code&gt; 指定的模式匹配的零个或多个任何的先于 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">该命令下载脚本并开始安装 &lt;code&gt;rustup&lt;/code&gt; 工具，该工具将安装Rust的最新稳定版本。可能会提示您输入密码。如果安装成功，将显示以下行：</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">这两个路径的共同部分是 &lt;code&gt;std::io&lt;/code&gt; ，这是完整的第一个路径。要将这两个路径合并为一个 &lt;code&gt;use&lt;/code&gt; 语句，我们可以在嵌套路径中使用 &lt;code&gt;self&lt;/code&gt; ，如清单7-20所示。</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">比较器功能必须定义切片中元素的总顺序。如果顺序不是总计，则未指定元素的顺序。如果一个订单（对于所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ）为：</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">比较器函数必须为分片中的元素定义一个总排序。如果排序不是总排序,则元素的顺序是不指定的。如果一个顺序是(对于所有的a、b和c),那么它就是一个总顺序。</target>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">比较器函数应实现与基础切片的排序顺序一致的顺序，并返回一个顺序代码，该顺序代码指示其参数是所需目标的 &lt;code&gt;Less&lt;/code&gt; ， &lt;code&gt;Equal&lt;/code&gt; 还是 &lt;code&gt;Greater&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ，比较必须满足：</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">编译没有产生任何错误，但是程序导致&lt;em&gt;运行时&lt;/em&gt;错误，并且没有成功退出。当您尝试使用索引访问元素时，Rust将检查您指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust将惊慌。</target>
        </trans-unit>
        <trans-unit id="0a0cf1febd61e4c4aeb0165c7c721394953162c8" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">编译模型集中在称为&lt;em&gt;板条箱的&lt;/em&gt;工件上。每次编译都会以源代码形式处理单个板条箱，如果成功，则会以二进制形式生成单个板条箱：可执行文件或某种库。&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
