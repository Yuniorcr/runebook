<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1eb81e5b136891ec83f03fa70901b0982c774c3e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">迭代器将产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。最初构造迭代器后，可能会遇到新的错误。</target>
        </trans-unit>
        <trans-unit id="fea22bab4e7d7d638613556e79b891a323ca2ee5" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54667f9a5f59c23223b23e9276c48f67c43aae4e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">迭代器将产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的实例。最初构造迭代器后，可能会遇到新的错误。</target>
        </trans-unit>
        <trans-unit id="6720eac87f145ca4ebd08c14afcbc3e18eb5bc63" translate="yes" xml:space="preserve">
          <source>The iterator will yield the &lt;code&gt;Path&lt;/code&gt; that is returned if the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method is used zero or more times. That means, the iterator will yield &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; and so on. If the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will do likewise. The iterator will always yield at least one value, namely &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt;方法使用零次或多次，则迭代器将产生返回的 &lt;code&gt;Path&lt;/code&gt; 。这意味着，迭代器将产生 &lt;code&gt;&amp;amp;self&lt;/code&gt; ， &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt; ， &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; 等等。如果&lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt;方法返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则迭代器也将这样做。迭代器将始终产生至少一个值，即 &lt;code&gt;&amp;amp;self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ed296a3da7075e704c60a55541d4eefcc61a2e" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;，则迭代器产生一个值，否则为null。</target>
        </trans-unit>
        <trans-unit id="33a7221657feedb4eb9bdbc29b15b1cfdbff0941" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果结果为&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，则迭代器将产生一个值，否则将没有值。</target>
        </trans-unit>
        <trans-unit id="98fcd488b58bec9ba13c409525786e8e34d2f3d0" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908b09e4328c560c75c00a1be9bba8fa3c1792fa" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果结果为&lt;a href=&quot;enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，则迭代器将产生一个值，否则将没有值。</target>
        </trans-unit>
        <trans-unit id="8fd298b9ad5df85747acb6e44bba1366e3481860" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">如果结果为&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;，则迭代器产生一个值，否则为0。</target>
        </trans-unit>
        <trans-unit id="41c263ba9c3e1377bcbb306e69ddac6adfb8f150" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80110840b4186388c3ebdd6fff4960efb23a3ca" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">迭代器产生元组。位置是第一，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是第二。</target>
        </trans-unit>
        <trans-unit id="6ec1542f766c1ecbdef3897acebe4cebd30ca6ee" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787f68c0ad38019edb27d78451a4d5831f65e4ab" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">迭代器产生元组。位置是第一，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是第二。</target>
        </trans-unit>
        <trans-unit id="10db2a64e13645a875ad4c150b72d85dec4465d0" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6814fb791ef3836a2e395759e70c2ff3a369ee11" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;read_line&lt;/code&gt; is to take whatever the user types into standard input and place that into a string, so it takes that string as an argument. The string argument needs to be mutable so the method can change the string&amp;rsquo;s content by adding the user input.</source>
          <target state="translated">&lt;code&gt;read_line&lt;/code&gt; 的工作是将用户键入的任何内容输入标准输入并将其放入字符串，因此它将该字符串作为参数。字符串参数必须是可变的，因此该方法可以通过添加用户输入来更改字符串的内容。</target>
        </trans-unit>
        <trans-unit id="41c36730094f242762fc2db352770667844d977d" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7b114b0c6414134b72184594654a5acaffb577" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">联接句柄在删除后将隐式&lt;em&gt;分离&lt;/em&gt;子线程。在这种情况下，子线程可能会超过父线程（除非父线程是主线程；整个过程在主线程完成时终止）。此外，连接手柄提供了一个&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;方法，其可用于连接子线程。如果子线程出现紧急情况，&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt;其中包含提供给&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt;的参数。</target>
        </trans-unit>
        <trans-unit id="099a2e1e2bdb72897b42735f9f375efdb1e2c049" translate="yes" xml:space="preserve">
          <source>The key line in this error is &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt;. With our non-generic versions of the &lt;code&gt;largest&lt;/code&gt; function, we were only trying to find the largest &lt;code&gt;i32&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. As discussed in the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4, types like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; that have a known size can be stored on the stack, so they implement the &lt;code&gt;Copy&lt;/code&gt; trait. But when we made the &lt;code&gt;largest&lt;/code&gt; function generic, it became possible for the &lt;code&gt;list&lt;/code&gt; parameter to have types in it that don&amp;rsquo;t implement the &lt;code&gt;Copy&lt;/code&gt; trait. Consequently, we wouldn&amp;rsquo;t be able to move the value out of &lt;code&gt;list[0]&lt;/code&gt; and into the &lt;code&gt;largest&lt;/code&gt; variable, resulting in this error.</source>
          <target state="translated">此错误中的关键行 &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt; 。对于 &lt;code&gt;largest&lt;/code&gt; 函数的非泛型版本，我们只是试图找到最大的 &lt;code&gt;i32&lt;/code&gt; 或 &lt;code&gt;char&lt;/code&gt; 。如第4章&lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;仅堆栈数据：复制&amp;rdquo;&lt;/a&gt;部分所述，具有已知大小的类型（如 &lt;code&gt;i32&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; )可以存储在堆栈中，因此它们实现了 &lt;code&gt;Copy&lt;/code&gt; 特征。但是当我们使 &lt;code&gt;largest&lt;/code&gt; 函数通用时， &lt;code&gt;list&lt;/code&gt; 参数就有可能在其中实现不实现 &lt;code&gt;Copy&lt;/code&gt; 的类型。特征。因此，我们将无法将值移出 &lt;code&gt;list[0]&lt;/code&gt; 并移至 &lt;code&gt;largest&lt;/code&gt; 变量，从而导致此错误。</target>
        </trans-unit>
        <trans-unit id="bceeadadeee15f4a164537fd341fe02f08db51ce" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">密钥可以是地图密钥类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与密钥类型的匹配。</target>
        </trans-unit>
        <trans-unit id="1967c0afcde1ba185b21a2a66c76557126c2a896" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">密钥可以是地图密钥类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与密钥类型的匹配。</target>
        </trans-unit>
        <trans-unit id="25f3fabcbbf37a65231d46a27fb9b7a82a76e913" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">密钥可以是地图密钥类型的任何借用形式，但是借用形式上的顺序&lt;em&gt;必须&lt;/em&gt;与密钥类型上的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="5794a7e2452d7c2d7acdcd9ca75f9f681dde7e71" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">联合体的关键属性是联合体中的所有字段共享共同的存储空间,因此对联合体中一个字段的写入可以覆盖其他字段,联合体的大小由其最大字段的大小决定。因此,对一个联合体的一个字段的写入可以覆盖它的其他字段,一个联合体的大小是由它的最大字段的大小决定的。</target>
        </trans-unit>
        <trans-unit id="af36c49ed669c54fb87fd9d4d2b45f5df4d5de97" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730d38429c1bd8714c2ac7995eb67557271f3b30" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;pub&lt;/code&gt; makes any module, function, or data structure accessible from inside of external modules. The &lt;code&gt;pub&lt;/code&gt; keyword may also be used in a &lt;code&gt;use&lt;/code&gt; declaration to re-export an identifier from a namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6097954d2b4ff2c7af7f3ee3f3f7074587267681" translate="yes" xml:space="preserve">
          <source>The kinds of patterns for parameters is limited to one of the following:</source>
          <target state="translated">参数模式的种类仅限于以下一种。</target>
        </trans-unit>
        <trans-unit id="9150d911250adb9488a9891d8d1a7dd89c179545" translate="yes" xml:space="preserve">
          <source>The lack of infinite output indicates that this code didn&amp;rsquo;t create a reference cycle. We can also tell this by looking at the values we get from calling &lt;code&gt;Rc::strong_count&lt;/code&gt; and &lt;code&gt;Rc::weak_count&lt;/code&gt;.</source>
          <target state="translated">缺少无限的输出表明该代码未创建参考循环。我们还可以通过查看从调用 &lt;code&gt;Rc::strong_count&lt;/code&gt; 和 &lt;code&gt;Rc::weak_count&lt;/code&gt; 得到的值来说明这一点。</target>
        </trans-unit>
        <trans-unit id="4f0cd1d95a878dd3fb3eb033669531c63a686db3" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e53524d7493db6ac00628d4141587167732e22" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</source>
          <target state="translated">lang属性用于标记Rust内置的特殊项目。这包括影响编译器行为的特殊特征（如 &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Sized&lt;/code&gt; ），以及可以自动调用的特殊功能（例如，对切片进行索引时进行越界访问的处理程序）。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="080a1610af4bccfcd8725cb110cddf449fbd60f7" translate="yes" xml:space="preserve">
          <source>The lang attribute was used in an invalid context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d001aa0e948f210ef67db3ed9f1079f66965d658" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type.</source>
          <target state="translated">这个整数类型所能代表的最大值。</target>
        </trans-unit>
        <trans-unit id="55a17e21fb4394b20facf75f686648a8590b11f1" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt;&lt;code&gt;i128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73325de7bc5986e41ec8d92ed9701ddacd280f3" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt;&lt;code&gt;i16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7bb87b47e7f2c22de123ec199f4be989c0dcaf2" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf18dde926e284162a660a1b1a2a30b118d1c49a" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt;&lt;code&gt;i64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22c4dd542e2ceff2527d706e65d0c5acc6f4d52" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt;&lt;code&gt;i8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2e67766c1f950d1a3f862bddde0bc78e36aacd" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt;&lt;code&gt;isize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697ca9e8dc5fcb1feb5a529df70222ec030c2428" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt;&lt;code&gt;u128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23128039031afffa375e1d18e6f18c10d1470457" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt;&lt;code&gt;u16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cead8aa8b3423346a603591b8a3bb3bb38de07d" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt;&lt;code&gt;u32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdca1f692589c69870c6eba29a4be248c639ebc" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt;&lt;code&gt;u64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1cfd44e67cca085f5a9478c1e9579b369e52ad" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt;&lt;code&gt;u8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c52af57b6ca83f430b64beb1abd9c9176989341" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bab83aeec1382113d53e6e7d14863dd49ec843d" translate="yes" xml:space="preserve">
          <source>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call &lt;code&gt;borrow&lt;/code&gt; on the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; to get an immutable reference to the vector.</source>
          <target state="translated">我们必须做的最后一个更改是在断言中：要查看内部向量中有多少项，我们对 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 调用 &lt;code&gt;borrow&lt;/code&gt; 以获取对该向量的不变引用。</target>
        </trans-unit>
        <trans-unit id="b92b068be4c2b594134000422ae50b8df0c8bac3" translate="yes" xml:space="preserve">
          <source>The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</source>
          <target state="translated">最后一个区别是,常量只能设置为一个常量表达式,而不能设置为一个函数调用的结果或任何其他只能在运行时计算的值。</target>
        </trans-unit>
        <trans-unit id="293474ffe041aff8a994854d8cad3ac993cf31b4" translate="yes" xml:space="preserve">
          <source>The last element returned, if any, will contain the remainder of the slice.</source>
          <target state="translated">返回的最后一个元素(如果有的话)将包含分片的剩余部分。</target>
        </trans-unit>
        <trans-unit id="8d491eebdf550e16362be621e1476cb5ece9206f" translate="yes" xml:space="preserve">
          <source>The last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">的最后一个字段 &lt;code&gt;Foo&lt;/code&gt; 有一个类型涉及 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf70627b4e81c57a3ddc9f76311bc0b01f381dcd" translate="yes" xml:space="preserve">
          <source>The last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">输出的最后一行显示已安装二进制文件的位置和名称，在 &lt;code&gt;ripgrep&lt;/code&gt; 的情况下为 &lt;code&gt;rg&lt;/code&gt; 。只要安装目录位于 &lt;code&gt;$PATH&lt;/code&gt; ，如前所述，您就可以运行 &lt;code&gt;rg --help&lt;/code&gt; 并开始使用一个更快，更可靠的工具搜索文件！</target>
        </trans-unit>
        <trans-unit id="3dc7b6a27a6191be06711a90615e83b643711efc" translate="yes" xml:space="preserve">
          <source>The last line shows that &lt;code&gt;&amp;amp;bar&lt;/code&gt; is not a function pointer either. Rather, it is a reference to the function-specific ZST. &lt;code&gt;&amp;amp;bar&lt;/code&gt; is basically never what you want when &lt;code&gt;bar&lt;/code&gt; is a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982060970609630bdcfd3dbdc543a9a98b2de24a" translate="yes" xml:space="preserve">
          <source>The last line, &lt;code&gt;[dependencies]&lt;/code&gt;, is the start of a section for you to list any of your project&amp;rsquo;s dependencies. In Rust, packages of code are referred to as &lt;em&gt;crates&lt;/em&gt;. We won&amp;rsquo;t need any other crates for this project, but we will in the first project in Chapter 2, so we&amp;rsquo;ll use this dependencies section then.</source>
          <target state="translated">最后一行 &lt;code&gt;[dependencies]&lt;/code&gt; 是本节的开头，您可以列出任何项目的依赖项。在Rust中，代码包称为&lt;em&gt;板条箱&lt;/em&gt;。对于该项目，我们不需要任何其他包装，但是在第2章的第一个项目中，我们将使用此依赖项部分。</target>
        </trans-unit>
        <trans-unit id="c8d286da9b3987ef73f4d9e79523c9888a168257" translate="yes" xml:space="preserve">
          <source>The last of our common collections is the &lt;em&gt;hash map&lt;/em&gt;. The type &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; stores a mapping of keys of type &lt;code&gt;K&lt;/code&gt; to values of type &lt;code&gt;V&lt;/code&gt;. It does this via a &lt;em&gt;hashing function&lt;/em&gt;, which determines how it places these keys and values into memory. Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, dictionary, or associative array, just to name a few.</source>
          <target state="translated">我们最常用的集合是&lt;em&gt;哈希图&lt;/em&gt;。类型 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 存储类型的键的映射 &lt;code&gt;K&lt;/code&gt; 到类型的值 &lt;code&gt;V&lt;/code&gt; 。它通过&lt;em&gt;散列函数&lt;/em&gt;执行此操作，该&lt;em&gt;函数&lt;/em&gt;确定如何将这些键和值放入内存中。许多编程语言都支持这种数据结构，但是它们经常使用不同的名称，例如哈希，地图，对象，哈希表，字典或关联数组，仅举几例。</target>
        </trans-unit>
        <trans-unit id="e50377e1cc3271006121b6b6e503348b95075085" translate="yes" xml:space="preserve">
          <source>The last part is the HTTP version the client uses, and then the request line ends in a &lt;em&gt;CRLF sequence&lt;/em&gt;. (CRLF stands for &lt;em&gt;carriage return&lt;/em&gt; and &lt;em&gt;line feed&lt;/em&gt;, which are terms from the typewriter days!) The CRLF sequence can also be written as &lt;code&gt;\r\n&lt;/code&gt;, where &lt;code&gt;\r&lt;/code&gt; is a carriage return and &lt;code&gt;\n&lt;/code&gt; is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">最后一部分是客户端使用的HTTP版本，然后请求行以&lt;em&gt;CRLF序列&lt;/em&gt;结束。（CRLF代表&lt;em&gt;回车&lt;/em&gt;和&lt;em&gt;换行&lt;/em&gt;，这是打字机时代的术语！）CRLF序列也可以写为 &lt;code&gt;\r\n&lt;/code&gt; ，其中 &lt;code&gt;\r&lt;/code&gt; 是回车，而 &lt;code&gt;\n&lt;/code&gt; 是换行。CRLF序列将请求行与其余请求数据分开。请注意，在打印CRLF时，我们看到的是新行开头，而不是 &lt;code&gt;\r\n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7f87628bb5e91d33e6ee47cc631179039d310fa" translate="yes" xml:space="preserve">
          <source>The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</source>
          <target state="translated">类型的布局是指它的大小、对齐方式以及它的字段的相对偏移。对于enums,如何布局和解释判别符也是类型布局的一部分。</target>
        </trans-unit>
        <trans-unit id="bb7242c48b73507f4d4792c2cb29fe84ab3a4519" translate="yes" xml:space="preserve">
          <source>The layout of allocation request that failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81ce81ead59e71cfd072129a8c87907148c562c" translate="yes" xml:space="preserve">
          <source>The left operand of an &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;assignment&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;赋值&lt;/a&gt;或&lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;复合赋值&lt;/a&gt;表达式的左操作数。</target>
        </trans-unit>
        <trans-unit id="1c0d113ddd28e543817cdc902e3988c72a15e13a" translate="yes" xml:space="preserve">
          <source>The left shift assignment operator &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">左移赋值运算符 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="553d8d3f55b49cb8907e0699dd0a3d9c13298c80" translate="yes" xml:space="preserve">
          <source>The left shift operator &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; and &lt;code&gt;a.shl(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">左移位运算符 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 。请注意，由于此特征是针对具有多个右侧类型的所有整数类型实现的，因此Rust的类型检查器对 &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt; 进行了特殊处理，将整数运算的结果类型设置为左侧操作数的类型。这意味着尽管 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 和 &lt;code&gt;a.shl(b)&lt;/code&gt; 从求值的角度来看是相同的，但是在类型推断方面它们是不同的。</target>
        </trans-unit>
        <trans-unit id="abb83d0dbf2481e1c0cc0aff75ee4837acd9c8fb" translate="yes" xml:space="preserve">
          <source>The left-hand side of a compound assignment expression must be a place expression. A place expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</source>
          <target state="translated">复合赋值表达式的左侧必须是一个位置表达式。场所表达式代表一个内存位置,包括项目路径(即命名空间变量)、取消引用、索引表达式和字段引用。</target>
        </trans-unit>
        <trans-unit id="9df6999a3c0f46759818b5fb8abefef29f79e559" translate="yes" xml:space="preserve">
          <source>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</source>
          <target state="translated">赋值操作符的左侧必须是一个位置表达式。位置表达式代表一个内存位置,可以是一个变量(可选择命名间距)、一个取消引用、一个索引表达式或一个字段引用。</target>
        </trans-unit>
        <trans-unit id="e2c37a7f1d5752be8f4a3cd4c10444c370f709c8" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583ea3cae577825fe984e0b2dabdc2098e762a9c" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the operating system. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">长度是 &lt;code&gt;String&lt;/code&gt; 当前正在使用的内容的内存量（以字节为单位）。容量是 &lt;code&gt;String&lt;/code&gt; 从操作系统接收的内存总量（以字节为单位）。长度和容量之间的差异很重要，但在这种情况下并不重要，因此，现在可以忽略容量。</target>
        </trans-unit>
        <trans-unit id="bec01c75ecf9080484e0035ecb4817690e9d17fa" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;other&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 的长度必须与 &lt;code&gt;self&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1d3c6c04d874a34e3f73cf44da542c5ee7d39510" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;src&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 的长度必须与 &lt;code&gt;self&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f5ae40e336b72c0149684750f73301547acc7603" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b0bfaafe677ff19be99641d06a9d0388b357ef" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified. Erroneous code example:</source>
          <target state="translated">未指定平台固有函数 &lt;code&gt;simd_shuffle&lt;/code&gt; 的长度。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="2e4dc711d20d353ed60fc2eb7d0105870f230a29" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;. As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe8cad4da628228b8d9a6730b144662e5d5b147" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;; As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">返回的长度是 &lt;code&gt;OsStr&lt;/code&gt; 使用的基础存储的长度；如&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;简介中所述，&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;OsStr&lt;/code&gt; 以最适合于本机平台和Rust字符串形式之间的廉价相互转换的形式存储字符串，这两种形式在存储大小和编码方面可能存在很大差异。</target>
        </trans-unit>
        <trans-unit id="99a0d51daa7130da604f883d5259ae5835cb10c2" translate="yes" xml:space="preserve">
          <source>The lifetime bound for this object type cannot be deduced from context and must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71866b1db7de253967c22f08d6dc545dfcd4182b" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for &lt;code&gt;bar()&lt;/code&gt; implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30238ceba60deefc79cfa25b4649d1a595edd0d8" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">bar（）实现的生存期约束 &lt;code&gt;'b&lt;/code&gt; 与特征声明不匹配。确保生命周期声明在特征声明和实现中完全匹配。例：</target>
        </trans-unit>
        <trans-unit id="61076c57b01b556a6cbf075ae8202a67124b97eb" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have</source>
          <target state="translated">寿命省略规则要求任何具有省略输出寿命的函数签名必须具有以下两种情况之一</target>
        </trans-unit>
        <trans-unit id="15fb2549a777717fb62ea70833166d18eb32b15d" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7914129f994f43353c3efa7974019d9a960355fb" translate="yes" xml:space="preserve">
          <source>The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context, such as by providing a helper function taking the lifetime of a host value for the slice, or by explicit annotation.</source>
          <target state="translated">返回的分片的寿命是根据其使用情况推断出来的。为了防止意外的滥用,建议将寿命与上下文中任何一个源的寿命联系起来,比如提供一个辅助函数,为分片取一个主机值的寿命,或者通过显式注释。</target>
        </trans-unit>
        <trans-unit id="af0f1e1de97ff5087fa423eab95c1e381b7b3ee8" translate="yes" xml:space="preserve">
          <source>The lifetime of the returned &lt;code&gt;Cursor&lt;/code&gt; is bound to that of the &lt;code&gt;CursorMut&lt;/code&gt;, which means it cannot outlive the &lt;code&gt;CursorMut&lt;/code&gt; and that the &lt;code&gt;CursorMut&lt;/code&gt; is frozen for the lifetime of the &lt;code&gt;Cursor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57046a8e7fbf89990ae303fb2235f525d1c99061" translate="yes" xml:space="preserve">
          <source>The lifetime parameter declaration after &lt;code&gt;impl&lt;/code&gt; and its use after the type name are required, but we&amp;rsquo;re not required to annotate the lifetime of the reference to &lt;code&gt;self&lt;/code&gt; because of the first elision rule.</source>
          <target state="translated">必需在 &lt;code&gt;impl&lt;/code&gt; 之后声明生命周期参数，并在类型名称后使用它，但是由于第一个省略规则，我们不需要注释对 &lt;code&gt;self&lt;/code&gt; 的引用的生命周期。</target>
        </trans-unit>
        <trans-unit id="37f7629efc4022ff5cf0b561478f77607b602987" translate="yes" xml:space="preserve">
          <source>The lifetime parameters of the method do not match the trait declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f07422d02861a626046c58ce643a2a52da0ac8" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; is an error message intended for programmers. It won&amp;rsquo;t help our end users understand what happened and what they should do instead. Let&amp;rsquo;s fix that now.</source>
          <target state="translated">行 &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; 是一条针对程序员的错误消息。它不会帮助我们的最终用户了解发生了什么以及应该怎么做。让我们现在修复它。</target>
        </trans-unit>
        <trans-unit id="5a0147b8f24f32bab15f7fb8959607d1c4391ac2" translate="yes" xml:space="preserve">
          <source>The line is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1c3b88f137cbbbccea4f427174e92d6650dd55" translate="yes" xml:space="preserve">
          <source>The lines execute in the order in which they appear in the &lt;code&gt;main&lt;/code&gt; function. First, the &amp;ldquo;Hello, world!&amp;rdquo; message prints, and then &lt;code&gt;another_function&lt;/code&gt; is called and its message is printed.</source>
          <target state="translated">这些行以它们在 &lt;code&gt;main&lt;/code&gt; 功能中出现的顺序执行。首先，&amp;ldquo;你好，世界！&amp;rdquo; 消息打印，然后调用 &lt;code&gt;another_function&lt;/code&gt; 并打印其消息。</target>
        </trans-unit>
        <trans-unit id="a2f50a40f788fe52620261459fe43b43f06256a8" translate="yes" xml:space="preserve">
          <source>The linkage of the C runtime is configured to respect the &lt;code&gt;crt-static&lt;/code&gt; target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</source>
          <target state="translated">C运行时的链接配置为尊重 &lt;code&gt;crt-static&lt;/code&gt; 目标功能。这些目标功能通常是从命令行通过标志配置到编译器本身的。例如，要启用静态运行时，可以执行：</target>
        </trans-unit>
        <trans-unit id="efca89d0995e1ff0c39cef27089410685b77deb1" translate="yes" xml:space="preserve">
          <source>The list of derivable traits provided in this appendix is not comprehensive: libraries can implement &lt;code&gt;derive&lt;/code&gt; for their own traits, making the list of traits you can use &lt;code&gt;derive&lt;/code&gt; with truly open-ended. Implementing &lt;code&gt;derive&lt;/code&gt; involves using a procedural macro, which is covered in the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section of Chapter 19.</source>
          <target state="translated">本附录中提供的衍生性状的名单并不全面：库可以实现 &lt;code&gt;derive&lt;/code&gt; 为自己的特质，使得性状的列表，你可以使用 &lt;code&gt;derive&lt;/code&gt; 与真正开放的。实现 &lt;code&gt;derive&lt;/code&gt; 涉及使用过程宏，该&lt;a href=&quot;ch19-06-macros#macros&quot;&gt;宏&lt;/a&gt;在第19章的&amp;ldquo;宏&amp;rdquo;部分中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="e9a2965c85bdbd082d28a62c5ab1cef15f730b46" translate="yes" xml:space="preserve">
          <source>The list of types is:</source>
          <target state="translated">类型清单是:</target>
        </trans-unit>
        <trans-unit id="91f214c30e2ceb29652b72be6f5c77765c1026b7" translate="yes" xml:space="preserve">
          <source>The literal characters &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; may be included in a string by preceding them with the same character. For example, the &lt;code&gt;{&lt;/code&gt; character is escaped with &lt;code&gt;{{&lt;/code&gt; and the &lt;code&gt;}&lt;/code&gt; character is escaped with &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">文字字符 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 可以包含在字符串中，方法是在它们前面加上相同的字符。例如， &lt;code&gt;{&lt;/code&gt; 字符逃脱 &lt;code&gt;{{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 字符与转义 &lt;code&gt;}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5be7b0512e1a505e9266eb524c4b5165ed24536" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired at this time because the operation would otherwise block.</source>
          <target state="translated">此时不能获取锁,因为否则操作会被阻止。</target>
        </trans-unit>
        <trans-unit id="ca27685a95f0186521159c6d95fa9cb158ac3333" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired because another thread failed while holding the lock.</source>
          <target state="translated">由于另一个线程在持有锁时失败,所以无法获得锁。</target>
        </trans-unit>
        <trans-unit id="e835ab2030797bd0af68c5e546090096d0ef15ed" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits for accessing the underlying data.</source>
          <target state="translated">当返回的锁超出范围时，将释放该锁。返回的防护还实现了&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt;特性以访问基础数据。</target>
        </trans-unit>
        <trans-unit id="ca99507e16c078ed3bf090ad447532972842294c" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait for writing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f3d5bdf30a84c247ddb912c9e27503ec850ddb" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;code&gt;Write&lt;/code&gt; trait for writing data.</source>
          <target state="translated">当返回的锁超出范围时，将释放该锁。返回的防护还实现了用于写入数据的 &lt;code&gt;Write&lt;/code&gt; 特质。</target>
        </trans-unit>
        <trans-unit id="9fbc8134425c3ce849c012cee6ed6bdb948d21a6" translate="yes" xml:space="preserve">
          <source>The logic around the &lt;code&gt;value&lt;/code&gt; field we&amp;rsquo;ve just described is defined in Listing 13-10.</source>
          <target state="translated">清单13-10中定义了我们刚刚描述的围绕 &lt;code&gt;value&lt;/code&gt; 字段的逻辑。</target>
        </trans-unit>
        <trans-unit id="f2cf3737106dde9e749616b8670f272a444680a9" translate="yes" xml:space="preserve">
          <source>The lower bound of the range (inclusive).</source>
          <target state="translated">幅度的下限(含)。</target>
        </trans-unit>
        <trans-unit id="0766d14228f909fbfdac3f3dca197e2a666359ec" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any.</source>
          <target state="translated">导致该错误的低级原因(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="4b8803f6ab5b8d7b772e6a580f89ee4b72aef2f4" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">导致此错误的底层原因（如果有）。&lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5980cf0091c024091baef1d2b8180b13d7e8fb92" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">导致此错误的底层原因（如果有）。&lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f757a43bf56678673d64a896a7ea59d83e9d1668" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">导致此错误的底层原因（如果有）。&lt;a href=&quot;error/trait.error#method.cause&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828185ce8f6bedf0299995b3c4e9cb20b7a41ecd" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any.</source>
          <target state="translated">此错误的低级来源(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="ea0a6930dc7de4d466ce55f6448d31ae162ca38c" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此错误的下级来源（如果有）。&lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb0a1822fe706b0e16bb4cab78928338d81339e3" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此错误的下级来源（如果有）。&lt;a href=&quot;../error/trait.error#method.source&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccd557ca491cf82db4f740ce89716ec64f4fabf" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此错误的下级来源（如果有）。&lt;a href=&quot;error/trait.error#method.source&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6b9226fd8ae01998a5ebc10002aa19b3691743f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parameterized).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0846c263b7366386582dfe4d412a3ad4ba7b9f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</source>
          <target state="translated">本机代码 &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; ， &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; ， &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; ，或任何其它类型的取代基是不同的。因此，编译器按需生成实现。如果使用 &lt;code&gt;bool&lt;/code&gt; 参数调用 &lt;code&gt;foo()&lt;/code&gt; ，则编译器将仅为 &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; 生成代码。当我们有其他类型参数时，编译器生成的单态化实现的数量不会急剧增加，因为只有在使用未经参数化的替换调用函数时（即，没有任何替换类型本身都被参数化的替换），编译器才会生成一个实现。 。</target>
        </trans-unit>
        <trans-unit id="ec5d54a07ee0f8ac568e82f61b376d035a168bca" translate="yes" xml:space="preserve">
          <source>The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">宏本身将决定如何解释这样的标记以及是否产生错误。</target>
        </trans-unit>
        <trans-unit id="8db5958c7dabf9cedcc4db6e6fa16a59d45c2565" translate="yes" xml:space="preserve">
          <source>The macro works by using the &lt;code&gt;Debug&lt;/code&gt; implementation of the type of the given expression to print the value to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; along with the source location of the macro invocation as well as the source code of the expression.</source>
          <target state="translated">宏通过使用给定表达式类型的 &lt;code&gt;Debug&lt;/code&gt; 实现来工作，以将值以及宏调用的源位置以及表达式的源代码打印到&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9498e8eb390e83cb5dbd448b585676f4b5c37123" translate="yes" xml:space="preserve">
          <source>The macro wraps any number of static declarations and makes them thread local. Publicity and attributes for each static are allowed. Example:</source>
          <target state="translated">该宏封装了任意数量的静态声明,并使其成为线程本地。允许每个静态的公共性和属性。例如</target>
        </trans-unit>
        <trans-unit id="2eb59c956ec6e4722a7e8cfdea3a410b913da22e" translate="yes" xml:space="preserve">
          <source>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it&amp;rsquo;s intended to reference. Consider the program in Listing 10-17, which has an outer scope and an inner scope.</source>
          <target state="translated">生存期的主要目的是防止悬而未决的引用，这些引用使程序引用的不是其要引用的数据。考虑清单10-17中的程序，它具有一个外部作用域和一个内部作用域。</target>
        </trans-unit>
        <trans-unit id="c087688652f35bf8ea7f8323996c74d4edfcf197" translate="yes" xml:space="preserve">
          <source>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of &lt;code&gt;self&lt;/code&gt; in every method&amp;rsquo;s signature, is for organization. We&amp;rsquo;ve put all the things we can do with an instance of a type in one &lt;code&gt;impl&lt;/code&gt; block rather than making future users of our code search for capabilities of &lt;code&gt;Rectangle&lt;/code&gt; in various places in the library we provide.</source>
          <target state="translated">除了使用方法语法而且不必在每个方法的签名中重复使用 &lt;code&gt;self&lt;/code&gt; 的类型之外，使用方法代替函数的主要好处是对于组织。我们将类型实例的所有功能都放在一个 &lt;code&gt;impl&lt;/code&gt; 块中，而不是让我们的代码的未来用户在我们提供的库中的各个位置搜索 &lt;code&gt;Rectangle&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="8008407990a4be341211e8be036085a004b45e43" translate="yes" xml:space="preserve">
          <source>The main error message, &amp;ldquo;mismatched types,&amp;rdquo; reveals the core issue with this code. The definition of the function &lt;code&gt;plus_one&lt;/code&gt; says that it will return an &lt;code&gt;i32&lt;/code&gt;, but statements don&amp;rsquo;t evaluate to a value, which is expressed by &lt;code&gt;()&lt;/code&gt;, an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.</source>
          <target state="translated">主要错误消息&amp;ldquo;类型不匹配&amp;rdquo;揭示了此代码的核心问题。函数 &lt;code&gt;plus_one&lt;/code&gt; 的定义说它将返回一个 &lt;code&gt;i32&lt;/code&gt; ，但是语句的值不等于一个由空元组 &lt;code&gt;()&lt;/code&gt; 表示的值。因此，不会返回任何内容，这与函数定义相矛盾并导致错误。在此输出中，Rust提供了一条消息，可能有助于纠正此问题：建议删除分号，以解决错误。</target>
        </trans-unit>
        <trans-unit id="573ea76510aaa810e82bed4691dcc0e4c2771be9" translate="yes" xml:space="preserve">
          <source>The main place you'll see &lt;code&gt;!&lt;/code&gt; used explicitly is in generic code. Consider the &lt;a href=&quot;str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">您将看到的主要地方 &lt;code&gt;!&lt;/code&gt; 显式使用的是通用代码。考虑&lt;a href=&quot;str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;特性：</target>
        </trans-unit>
        <trans-unit id="3347fce894ee36b7a76776d17f6b05d7ee4e0c6f" translate="yes" xml:space="preserve">
          <source>The main thread will wait for the spawned thread to finish and then run its &lt;code&gt;for&lt;/code&gt; loop, so the output won&amp;rsquo;t be interleaved anymore, as shown here:</source>
          <target state="translated">主线程将等待生成的线程完成，然后运行其 &lt;code&gt;for&lt;/code&gt; 循环，因此输出将不再被交错，如下所示：</target>
        </trans-unit>
        <trans-unit id="d7af4b9befadab1a133dab8d7948b44dbc8d708d" translate="yes" xml:space="preserve">
          <source>The main thread will wait with a timeout on the condvar and then leave once the boolean has been updated and notified.</source>
          <target state="translated">主线程会在condvar上超时等待,一旦布尔值被更新并通知,就会离开。</target>
        </trans-unit>
        <trans-unit id="2f4d9785a094ac7050147e12df1b0f82f8cae6fe" translate="yes" xml:space="preserve">
          <source>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</source>
          <target state="translated">类型同义词的主要用例是减少重复。例如,我们可能有一个很长的类型,比如这样。</target>
        </trans-unit>
        <trans-unit id="e1aa73c2c8bcfa6f25fb308f2154aee4987ca459" translate="yes" xml:space="preserve">
          <source>The main way to use Boolean values is through conditionals, such as an &lt;code&gt;if&lt;/code&gt; expression. We&amp;rsquo;ll cover how &lt;code&gt;if&lt;/code&gt; expressions work in Rust in the &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;Control Flow&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">使用布尔值的主要方法是通过条件，例如 &lt;code&gt;if&lt;/code&gt; 表达式。我们将介绍如何 &lt;code&gt;if&lt;/code&gt; 表达式鲁斯特的工作&lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;控制流&amp;rdquo;&lt;/a&gt;一节。</target>
        </trans-unit>
        <trans-unit id="67f97a592dc5c37dc58d2c3fd741d8753b33f60e" translate="yes" xml:space="preserve">
          <source>The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">到&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt;的映射不是该功能的兼容性合同的一部分，尤其是在将来，&lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt;类型可能会更改为更特定的类型。</target>
        </trans-unit>
        <trans-unit id="f8fda3a6ce0d45625dd9cd044a1a98a742c97014" translate="yes" xml:space="preserve">
          <source>The match condition states that the arm only matches if the value of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, or &lt;code&gt;6&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; if &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. When this code runs, the pattern of the first arm matches because &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;, but the match guard &lt;code&gt;if y&lt;/code&gt; is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints &lt;code&gt;no&lt;/code&gt;. The reason is that the &lt;code&gt;if&lt;/code&gt; condition applies to the whole pattern &lt;code&gt;4 | 5 | 6&lt;/code&gt;, not only to the last value &lt;code&gt;6&lt;/code&gt;. In other words, the precedence of a match guard in relation to a pattern behaves like this:</source>
          <target state="translated">匹配条件的状态，如果值的臂只匹配 &lt;code&gt;x&lt;/code&gt; 等于 &lt;code&gt;4&lt;/code&gt; ， &lt;code&gt;5&lt;/code&gt; ，或 &lt;code&gt;6&lt;/code&gt; &lt;em&gt;和&lt;/em&gt;如果 &lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。运行此代码时，由于 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;4&lt;/code&gt; ，因此第一臂的模式匹配，但是 &lt;code&gt;if y&lt;/code&gt; 为false 则匹配保护，因此不会选择第一臂。代码移至确实匹配的第二臂，该程序打印 &lt;code&gt;no&lt;/code&gt; 。原因是 &lt;code&gt;if&lt;/code&gt; 条件适用于整个模式 &lt;code&gt;4 | 5 | 6&lt;/code&gt; ，不仅是最后一个值 &lt;code&gt;6&lt;/code&gt; 。换句话说，匹配保护相对于模式的优先级表现如下：</target>
        </trans-unit>
        <trans-unit id="6477b3c15cf1efd2f96aba3a277d7e0dd00d128c" translate="yes" xml:space="preserve">
          <source>The match guard &lt;code&gt;if n == y&lt;/code&gt; is not a pattern and therefore doesn&amp;rsquo;t introduce new variables. This &lt;code&gt;y&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; the outer &lt;code&gt;y&lt;/code&gt; rather than a new shadowed &lt;code&gt;y&lt;/code&gt;, and we can look for a value that has the same value as the outer &lt;code&gt;y&lt;/code&gt; by comparing &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if n == y&lt;/code&gt; 则匹配防护不是模式，因此不会引入新的变量。这个 &lt;code&gt;y&lt;/code&gt; &lt;em&gt;是&lt;/em&gt;外部 &lt;code&gt;y&lt;/code&gt; 而不是一个新的阴影 &lt;code&gt;y&lt;/code&gt; ，我们可以通过将 &lt;code&gt;n&lt;/code&gt; 与 &lt;code&gt;y&lt;/code&gt; 进行比较来寻找与外部 &lt;code&gt;y&lt;/code&gt; 具有相同值的值。</target>
        </trans-unit>
        <trans-unit id="0a68bad7489889370013d2c1b380ae26eafd0a34" translate="yes" xml:space="preserve">
          <source>The matched value was assigned in a match guard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4a7cee97aca95b9c65ea2bcda5404ae104d4f6" translate="yes" xml:space="preserve">
          <source>The maximum duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639334ee92fbc7d55384c7ec82527ac8487a080f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444f3162cb088de418eba38f4a421be7235eea6f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</source>
          <target state="translated">达到了一个枚举的最大值,所以不能在下一个枚举值中自动设置。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="69d28668979329993270aea55163f780c2136684" translate="yes" xml:space="preserve">
          <source>The memory allocator returned an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f691ffd885b1cdd7c3aced4e660ea6b5f2bc5114" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;buf&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297bebe1d80f3b348c7c8e6094a67afc0f518766" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;ptr&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 处的内存需要事先由标准库使用的同一分配器分配。</target>
        </trans-unit>
        <trans-unit id="533d683a4cce37c267e983c916aea2694b115c42" translate="yes" xml:space="preserve">
          <source>The memory block will contain the following contents after a successful call to &lt;code&gt;grow_zeroed&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4c6be6867180c56169b0ceb625f117dffee9cb" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;struct&lt;/code&gt; is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;. In either case, fields may be given in any order in a corresponding struct &lt;em&gt;expression&lt;/em&gt;; the resulting &lt;code&gt;struct&lt;/code&gt; value will always have the same memory layout.</source>
          <target state="translated">默认情况下，未定义 &lt;code&gt;struct&lt;/code&gt; 的内存布局，以允许编译器优化（如字段重新排序），但可以使用&lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; 属性&lt;/a&gt;将其固定。无论哪种情况，都可以在相应的struct &lt;em&gt;表达式中&lt;/em&gt;以任何顺序指定字段；结果 &lt;code&gt;struct&lt;/code&gt; 值将始终具有相同的内存布局。</target>
        </trans-unit>
        <trans-unit id="613a15d193cb4b5b9d7d2448a0d26f441bad60d3" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;union&lt;/code&gt; is undefined by default, but the &lt;code&gt;#[repr(...)]&lt;/code&gt; attribute can be used to fix a layout.</source>
          <target state="translated">一个的存储器布局 &lt;code&gt;union&lt;/code&gt; 被默认未定义，但 &lt;code&gt;#[repr(...)]&lt;/code&gt; 属性可用于固定的布局。</target>
        </trans-unit>
        <trans-unit id="62988640c5b4ea3199910497b4399a06d9aa4bb8" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the memory allocator at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5158117ae58dde222908d602ad3b6cfbc19fbd1b" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the operating system at runtime.</source>
          <target state="translated">必须在运行时向操作系统申请内存。</target>
        </trans-unit>
        <trans-unit id="5fb7e987a9654eee8114bb60b92e8b3cf5d47151" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be accessed through any other pointer (not derived from the return value) for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;. Both read and write accesses are forbidden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff115e1f60568ae547418e535b08f2a38631c573" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be mutated for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;, except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6139b94477b7472bd857c001d753b72d8df9f27e" translate="yes" xml:space="preserve">
          <source>The message can be of any (&lt;code&gt;Any + Send&lt;/code&gt;) type, not just strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d782721b766f719dd5b6d817f0d6bb437eb7d6a" translate="yes" xml:space="preserve">
          <source>The message is wrapped in a &lt;code&gt;Box&amp;lt;'static + Any + Send&amp;gt;&lt;/code&gt;, which can be accessed later using &lt;a href=&quot;struct.panicinfo#method.payload&quot;&gt;&lt;code&gt;PanicInfo::payload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86a2a43ba3e98f03e1d643c5eb2cb7bce34d7c4" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so counting elements of an iterator with more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">该方法无法防止溢出，因此对迭代器的元素进行计数（其数量超过&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;元素）会产生错误的结果或引起恐慌。如果启用了调试断言，则可以保证出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="177a5c2ea6344ea77e9ae3a6db8fc74469cc253c" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">该方法无法防止溢出，因此枚举多于&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;元素会产生错误的结果或引起恐慌。如果启用了调试断言，则可以保证出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="3a1826392947e9b9a700c20663562183cfe20bf1" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;code&gt;usize::MAX&lt;/code&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">该方法无法防止溢出，因此枚举多于 &lt;code&gt;usize::MAX&lt;/code&gt; 元素会产生错误的结果或引起恐慌。如果启用了调试断言，则可以保证出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="19d8816b84fe470f79cf77755eeb8ee64e555da5" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so if there are more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">该方法无法防止溢出，因此，如果存在不超过&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;不匹配的元素，则它会产生错误的结果或引起恐慌。如果启用了调试断言，则可以保证出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="1be550addda456adee08f228dc9b4f31db12dda4" translate="yes" xml:space="preserve">
          <source>The method will panic if the given step is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果给定步骤为 &lt;code&gt;0&lt;/code&gt; ,则该方法将出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="18a6ab41791924ffc3860ab7c005689a5ace692a" translate="yes" xml:space="preserve">
          <source>The minimum alignment of a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61a28fc808f2bb8277ab6d2dda14e2b5dc3214d" translate="yes" xml:space="preserve">
          <source>The minimum byte alignment for a memory block of this layout.</source>
          <target state="translated">该布局的内存块的最小字节对齐方式。</target>
        </trans-unit>
        <trans-unit id="e621ea6ab30e14c7bfa77e4fee05fb852bfe464d" translate="yes" xml:space="preserve">
          <source>The minimum duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b04e5eee8d92581fabe61b454bd932d16d3b4ee" translate="yes" xml:space="preserve">
          <source>The minimum size in bytes for a memory block of this layout.</source>
          <target state="translated">此布局的内存块的最小尺寸,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="4650b1470ff8fe4b9a6a554cb10a84ba4229b041" translate="yes" xml:space="preserve">
          <source>The mirror use case of FFI is also done via the &lt;code&gt;extern&lt;/code&gt; keyword:</source>
          <target state="translated">FFI的镜像用例也通过 &lt;code&gt;extern&lt;/code&gt; 关键字完成：</target>
        </trans-unit>
        <trans-unit id="a82559d5a04edc93a72fe140de851778ee358fc2" translate="yes" xml:space="preserve">
          <source>The module tree might remind you of the filesystem&amp;rsquo;s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.</source>
          <target state="translated">模块树可能会让您想起计算机上文件系统的目录树。这是一个非常恰当的比较！就像文件系统中的目录一样，您可以使用模块来组织代码。就像目录中的文件一样，我们需要一种找到模块的方法。</target>
        </trans-unit>
        <trans-unit id="ea4c9b3e2b6f858a3799aa18909b3e42f1061d3e" translate="yes" xml:space="preserve">
          <source>The module tree remains the same, and the function calls in &lt;code&gt;eat_at_restaurant&lt;/code&gt; will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.</source>
          <target state="translated">模块树保持不变，即使定义位于不同的文件中， &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中的函数调用也无需任何修改即可工作。这种技术使您可以随着模块大小的增加而将其移动到新文件中。</target>
        </trans-unit>
        <trans-unit id="fb5cf295cab45b30e8f8d196e49ec369e86db99a" translate="yes" xml:space="preserve">
          <source>The monomorphized version of the code looks like the following. The generic &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is replaced with the specific definitions created by the compiler:</source>
          <target state="translated">该代码的单一版本如下所示。通用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 替换为编译器创建的特定定义：</target>
        </trans-unit>
        <trans-unit id="75cf509b67ca81925881254de671f6530c684e13" translate="yes" xml:space="preserve">
          <source>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even &lt;em&gt;must&lt;/em&gt; be used, e.g.</source>
          <target state="translated">一种更常见的继承变异性（必须具有对变量的唯一访问权）是使Rust能够强烈地推理指针别名，静态地防止崩溃错误的关键语言元素之一。因此，首选继承的可变性，而内部可变性是不得已的方法。由于细胞类型可以实现原本不允许的突变，因此有时可能适合内部变异，甚至&lt;em&gt;必须&lt;/em&gt;使用内部变异，例如</target>
        </trans-unit>
        <trans-unit id="22b87181f4af9bcd4494ede540e86fdd7af786b7" translate="yes" xml:space="preserve">
          <source>The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one collection into another. You take a collection, call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it, do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.</source>
          <target state="translated">使用 &lt;code&gt;collect()&lt;/code&gt; 的最基本模式是将一个集合转换为另一个集合。你把一个集合，呼吁&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;就可以了，做了一堆的变换，然后 &lt;code&gt;collect()&lt;/code&gt; 在最后。</target>
        </trans-unit>
        <trans-unit id="8acfa5660545764d445a8a9080882c9972414cad" translate="yes" xml:space="preserve">
          <source>The most basic usage of the keyword is &lt;code&gt;use path::to::item;&lt;/code&gt;, though a number of convenient shortcuts are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524cfe2dc48693915271c90c3e4b7d15d2163d53" translate="yes" xml:space="preserve">
          <source>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</source>
          <target state="translated">这个错误最可能的来源是使用角括号符号而没有将函数参数类型包装成元组,例如。</target>
        </trans-unit>
        <trans-unit id="f1fae4bef53f01c296ad8cf52cd2f776bcb2545a" translate="yes" xml:space="preserve">
          <source>The most straightforward smart pointer is a &lt;em&gt;box&lt;/em&gt;, whose type is written &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</source>
          <target state="translated">最简单的智能指针是一个&lt;em&gt;框&lt;/em&gt;，其类型为 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 。框允许您将数据存储在堆而不是堆栈上。堆栈上剩下的是指向堆数据的指针。请参考第4章以查看堆栈和堆之间的区别。</target>
        </trans-unit>
        <trans-unit id="c84503d5e594d47f23b7b930df844dc25ee59200" translate="yes" xml:space="preserve">
          <source>The most surprising behavior occurs when &quot;the same&quot; file is reachable via multiple paths in the module system (usually using the &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; attribute or similar), which can cause what appears to be identical code to return differing values from this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224b0446b4293b35c3feb8b386382ff2882bd862" translate="yes" xml:space="preserve">
          <source>The most widely used form of macros in Rust is &lt;em&gt;declarative macros&lt;/em&gt;. These are also sometimes referred to as &amp;ldquo;macros by example,&amp;rdquo; &amp;ldquo;&lt;code&gt;macro_rules!&lt;/code&gt; macros,&amp;rdquo; or just plain &amp;ldquo;macros.&amp;rdquo; At their core, declarative macros allow you to write something similar to a Rust &lt;code&gt;match&lt;/code&gt; expression. As discussed in Chapter 6, &lt;code&gt;match&lt;/code&gt; expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</source>
          <target state="translated">Rust中使用最广泛的宏形式是&lt;em&gt;声明性宏&lt;/em&gt;。这些有时也被称为&amp;ldquo;示例宏&amp;rdquo;，&amp;ldquo; &lt;code&gt;macro_rules!&lt;/code&gt; 宏&amp;rdquo;或简单的&amp;ldquo;宏&amp;rdquo;。声明性宏的核心是，您可以编写类似于Rust &lt;code&gt;match&lt;/code&gt; 表达式的内容。如在第6章，讨论 &lt;code&gt;match&lt;/code&gt; 表达式是一种控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式相关联的代码。宏还将值与与特定代码关联的模式进行比较：在这种情况下，该值是传递给宏的文字Rust源代码；将模式与该源代码的结构进行比较；并且与每个模式相关联的代码在匹配时将替换传递给宏的代码。这一切都是在编译过程中发生的。</target>
        </trans-unit>
        <trans-unit id="5c8119cbdd49364e9c5037e1b8a03abc1bccdb46" translate="yes" xml:space="preserve">
          <source>The motivation for this design is twofold:</source>
          <target state="translated">这种设计的动机有两个。</target>
        </trans-unit>
        <trans-unit id="6fd4e131dbce656fa77aa6dbacb12fee04853072" translate="yes" xml:space="preserve">
          <source>The multi-argument form of this macro panics with a string and has the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax for building a string.</source>
          <target state="translated">此宏的多参数形式恐慌，带有字符串，并且&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;用于构建字符串的语法。</target>
        </trans-unit>
        <trans-unit id="ff7a3f839c4dac34de65c2bfcbc13d6c2f460e6c" translate="yes" xml:space="preserve">
          <source>The multiplication assignment operator &lt;code&gt;*=&lt;/code&gt;.</source>
          <target state="translated">乘法赋值运算符 &lt;code&gt;*=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="945e202ccc3f817f464a16a52710aeff055613cc" translate="yes" xml:space="preserve">
          <source>The multiplication operator &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">乘法运算符 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="395bf55779b3f4b37031c67eb2f13567f6e766a4" translate="yes" xml:space="preserve">
          <source>The mutability of a pointer does not change its size. As such, &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; have the same size. Likewise for &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">指针的可变性不会改变其大小。因此， &lt;code&gt;&amp;amp;T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 具有相同的大小。对于 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="f42a8b27f0c72155ef0f3b14d7be6cafaaf62841" translate="yes" xml:space="preserve">
          <source>The mutable slice yields mutable references to the elements:</source>
          <target state="translated">可变的分片产生可变的元素引用。</target>
        </trans-unit>
        <trans-unit id="3c3cbd1ab17a10688ead5cf4d56f2dfc9e512608" translate="yes" xml:space="preserve">
          <source>The mutexes in this module implement a strategy called &quot;poisoning&quot; where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).</source>
          <target state="translated">本模块中的mutexes实现了一种叫做 &quot;中毒 &quot;的策略,只要有线程在持有mutex时发生恐慌,就认为mutex中毒了。一旦一个mutex中毒,所有其他线程都无法默认访问数据,因为数据很可能被污染了(某个不变性没有被维护)。</target>
        </trans-unit>
        <trans-unit id="d8b50303b0747d7e3abc95898503b5bde7711980" translate="yes" xml:space="preserve">
          <source>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</source>
          <target state="translated">为一个外部箱子选择的名称与另一个已经导入到当前模块的外部箱子相冲突。</target>
        </trans-unit>
        <trans-unit id="d94375d609f70bc0ddb2da1f070fd5b681c30cc1" translate="yes" xml:space="preserve">
          <source>The name for an item declaration conflicts with an external crate's name.</source>
          <target state="translated">项目声明的名称与外部箱子的名称冲突。</target>
        </trans-unit>
        <trans-unit id="286d59804da04e407ec36eb2be39e9e0c7ff3343" translate="yes" xml:space="preserve">
          <source>The name must not contain null bytes (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="translated">该名称不得包含空字节（ &lt;code&gt;\0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6584162ced4a99e7d4548e6dfca0a1b5adbdbd8e" translate="yes" xml:space="preserve">
          <source>The need for synchronization</source>
          <target state="translated">同步化的必要性</target>
        </trans-unit>
        <trans-unit id="9491a60a88ee503552e1418886a35e38dd1f594f" translate="yes" xml:space="preserve">
          <source>The need for this type arises from the fact that:</source>
          <target state="translated">之所以需要这种类型,是因为:</target>
        </trans-unit>
        <trans-unit id="3e795b9b16f895fca00c98b1df11fc0d63c7301f" translate="yes" xml:space="preserve">
          <source>The network operation failed because it was not connected yet.</source>
          <target state="translated">因尚未连接,网络操作失败。</target>
        </trans-unit>
        <trans-unit id="7c5a2cc50c7976456054417007ed08f73bfd9e80" translate="yes" xml:space="preserve">
          <source>The never type &lt;code&gt;!&lt;/code&gt; is a type with no values, representing the result of computations that never complete. Expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type.</source>
          <target state="translated">从不输入 &lt;code&gt;!&lt;/code&gt; 是没有值的类型，表示永远不会完成的计算结果。类型的表达式 &lt;code&gt;!&lt;/code&gt; 可以强制为任何其他类型。</target>
        </trans-unit>
        <trans-unit id="2876200ee40ea0a4251130e3bb42070db01f59e5" translate="yes" xml:space="preserve">
          <source>The never type is useful with the &lt;code&gt;panic!&lt;/code&gt; macro as well. Remember the &lt;code&gt;unwrap&lt;/code&gt; function that we call on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; values to produce a value or panic? Here is its definition:</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; ，永不使用类型！宏也是如此。还记得我们在 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 值上调用的 &lt;code&gt;unwrap&lt;/code&gt; 函数来产生值或发生恐慌吗？这是它的定义：</target>
        </trans-unit>
        <trans-unit id="56b6326e5da7a2c1bad08c52fe9675cb30d6fc5f" translate="yes" xml:space="preserve">
          <source>The new test for the case-&lt;em&gt;insensitive&lt;/em&gt; search uses &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; as its query. In the &lt;code&gt;search_case_insensitive&lt;/code&gt; function we&amp;rsquo;re about to add, the query &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; should match the line containing &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; with a capital R and match the line &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven&amp;rsquo;t yet defined the &lt;code&gt;search_case_insensitive&lt;/code&gt; function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the &lt;code&gt;search&lt;/code&gt; function in Listing 12-16 to see the test compile and fail.</source>
          <target state="translated">&lt;em&gt;不区分大小写&lt;/em&gt;搜索的新测试使用 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; 作为查询。在我们要添加的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数中，查询 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; 应将包含 &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; 与大写R匹配，并与 &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; 行匹配。即使两者的查询大小写不同。这是我们的测试失败，并且由于我们尚未定义 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数，因此将无法编译。随意添加一个总是返回一个空向量的框架实现，类似于清单12-16中的 &lt;code&gt;search&lt;/code&gt; 功能可以看到测试编译和失败的方式。</target>
        </trans-unit>
        <trans-unit id="9a3696a40107bd6d0870f3607ce5d6e5073b6d6b" translate="yes" xml:space="preserve">
          <source>The newtype pattern is useful for tasks beyond those we&amp;rsquo;ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 19-15: recall that the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structs wrapped &lt;code&gt;u32&lt;/code&gt; values in a newtype. If we wrote a function with a parameter of type &lt;code&gt;Millimeters&lt;/code&gt;, we couldn&amp;rsquo;t compile a program that accidentally tried to call that function with a value of type &lt;code&gt;Meters&lt;/code&gt; or a plain &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">新类型模式对到目前为止我们已经讨论过的任务非常有用，包括静态强制值永不混淆以及指示值的单位。您在清单19-15中看到了一个使用新类型表示单位的示例：回想一下， &lt;code&gt;Millimeters&lt;/code&gt; 和 &lt;code&gt;Meters&lt;/code&gt; 结构将 &lt;code&gt;u32&lt;/code&gt; 值包装成新类型。如果我们编写的函数的参数类型为 &lt;code&gt;Millimeters&lt;/code&gt; ，那么我们将无法编译一个程序，意外地尝试使用 &lt;code&gt;Meters&lt;/code&gt; 或普通 &lt;code&gt;u32&lt;/code&gt; 类型的值来调用该函数。</target>
        </trans-unit>
        <trans-unit id="b591edfc8b3d018e277499297a4856c76a36dc2a" translate="yes" xml:space="preserve">
          <source>The next four lines set the configuration information Cargo needs to compile your program: the name, the version, who wrote it, and the edition of Rust to use. Cargo gets your name and email information from your environment, so if that information is not correct, fix the information now and then save the file. We&amp;rsquo;ll talk about the &lt;code&gt;edition&lt;/code&gt; key in Appendix E.</source>
          <target state="translated">接下来的四行设置了Cargo编译程序所需的配置信息：名称，版本，编写者以及要使用的Rust版本。货运从您的环境中获取您的姓名和电子邮件信息，因此，如果该信息不正确，请立即修复该信息，然后保存文件。我们将在附录E中讨论 &lt;code&gt;edition&lt;/code&gt; 密钥。</target>
        </trans-unit>
        <trans-unit id="6a7a2603b03740bcea191aea3d000fd9f48ffbb9" translate="yes" xml:space="preserve">
          <source>The next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-28 or the version using iterators in Listing 13-29. Most Rust programmers prefer to use the iterator style. It&amp;rsquo;s a bit tougher to get the hang of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it&amp;rsquo;s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.</source>
          <target state="translated">下一个逻辑问题是您应该在自己的代码中选择哪种样式以及为什么选择：清单13-28中的原始实现或清单13-29中使用迭代器的版本。大多数Rust程序员更喜欢使用迭代器样式。首先要掌握一点困难，但是一旦您了解了各种迭代器适配器及其作用，就可以更容易地理解迭代器。该代码没有摆弄循环的各个部分并构建新的向量，而是专注于循环的高级目标。这样可以抽象一些常用的代码，因此更容易看到此代码特有的概念，例如迭代器中每个元素必须通过的过滤条件。</target>
        </trans-unit>
        <trans-unit id="57f6548988daa34617ffdf2e9ca86d7e443df79f" translate="yes" xml:space="preserve">
          <source>The next note line tells us that we can set the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to get a backtrace of exactly what happened to cause the error. A &lt;em&gt;backtrace&lt;/em&gt; is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. That&amp;rsquo;s the spot where the problem originated. The lines above the lines mentioning your files are code that your code called; the lines below are code that called your code. These lines might include core Rust code, standard library code, or crates that you&amp;rsquo;re using. Let&amp;rsquo;s try getting a backtrace by setting the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to any value except 0. Listing 9-2 shows output similar to what you&amp;rsquo;ll see.</source>
          <target state="translated">下一条注释行告诉我们，我们可以设置 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 环境变量来获得对引起错误的确切原因的追溯。一个&lt;em&gt;回溯&lt;/em&gt;是已经叫了这一点的所有功能的列表。 Rust中的回溯与其他语言一样工作：读取回溯的关键是从顶部开始并进行读取，直到看到写入的文件为止。那就是问题起源的地方。上面提到文件的那行是您的代码所调用的代码；下面的行是称为您的代码的代码。这些行可能包括核心Rust代码，标准库代码或您正在使用的板条箱。让我们尝试通过设置 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 获得回溯 环境变量为除0以外的任何值。清单9-2显示的输出与您将看到的类似。</target>
        </trans-unit>
        <trans-unit id="771993487043dfd3c7aa5a2390e7d9f0063dbedb" translate="yes" xml:space="preserve">
          <source>The next part of the code, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt;, calls the &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method on the standard input handle to get input from the user. We&amp;rsquo;re also passing one argument to &lt;code&gt;read_line&lt;/code&gt;: &lt;code&gt;&amp;amp;mut guess&lt;/code&gt;.</source>
          <target state="translated">代码的下一部分 &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt; 调用标准输入句柄上的&lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt; &lt;code&gt;read_line&lt;/code&gt; &lt;/a&gt;方法以从用户获取输入。我们还将一个参数传递给 &lt;code&gt;read_line&lt;/code&gt; ： &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f3a0383282eca508bd91153f03681dc6f1973f4" translate="yes" xml:space="preserve">
          <source>The next part of the request line is &lt;em&gt;/&lt;/em&gt;, which indicates the &lt;em&gt;Uniform Resource Identifier&lt;/em&gt;&lt;em&gt;(URI)&lt;/em&gt; the client is requesting: a URI is almost, but not quite, the same as a &lt;em&gt;Uniform Resource Locator&lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt;. The difference between URIs and URLs isn&amp;rsquo;t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.</source>
          <target state="translated">请求行的下一部分是&lt;em&gt;/&lt;/em&gt;，它指示客户&lt;em&gt;端正&lt;/em&gt;在请求的&lt;em&gt;统一资源标识符&lt;/em&gt;&lt;em&gt;（URI）&lt;/em&gt;：URI与&lt;em&gt;统一资源定位符&lt;/em&gt;&lt;em&gt;（URL）&lt;/em&gt;几乎相同，但并不完全相同。在本章中，URI和URL之间的区别对于我们的目的并不重要，但是HTTP规范使用术语URI，因此在这里我们可以在心理上用URL代替URI。</target>
        </trans-unit>
        <trans-unit id="504232041214e8dae75346e3d17c4c0bf4814b9b" translate="yes" xml:space="preserve">
          <source>The next part of the test output, which starts with &lt;code&gt;Doc-tests adder&lt;/code&gt;, is for the results of any documentation tests. We don&amp;rsquo;t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps us keep our docs and our code in sync! We&amp;rsquo;ll discuss how to write documentation tests in the &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;Documentation Comments as Tests&amp;rdquo;&lt;/a&gt; section of Chapter 14. For now, we&amp;rsquo;ll ignore the &lt;code&gt;Doc-tests&lt;/code&gt; output.</source>
          <target state="translated">测试输出的下一部分以 &lt;code&gt;Doc-tests adder&lt;/code&gt; 开头，用于任何文档测试的结果。我们还没有任何文档测试，但是Rust可以编译API文档中出现的任何代码示例。此功能可帮助我们使文档和代码保持同步！我们将在第14章的&lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;将文档注释作为测试&amp;rdquo;&lt;/a&gt;部分中讨论如何编写文档测试。现在，我们将忽略 &lt;code&gt;Doc-tests&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="1ac4585430b879637fa9bf73df289a63ff5c8c8c" translate="yes" xml:space="preserve">
          <source>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named &lt;code&gt;foo&lt;/code&gt;, a custom derive procedural macro crate is called &lt;code&gt;foo_derive&lt;/code&gt;. Let&amp;rsquo;s start a new crate called &lt;code&gt;hello_macro_derive&lt;/code&gt; inside our &lt;code&gt;hello_macro&lt;/code&gt; project:</source>
          <target state="translated">下一步是定义过程宏。在撰写本文时，过程宏必须放在自己的箱子里。最终，这一限制可能会解除。用于构造包装箱和宏包装箱的约定如下：对于名为 &lt;code&gt;foo&lt;/code&gt; 的包装箱，自定义派生过程宏包装箱称为 &lt;code&gt;foo_derive&lt;/code&gt; 。让我们在 &lt;code&gt;hello_macro&lt;/code&gt; 项目中启动一个名为 &lt;code&gt;hello_macro_derive&lt;/code&gt; 的新板条箱：</target>
        </trans-unit>
        <trans-unit id="86c376c4d2f9126074dd6023a007174609449704" translate="yes" xml:space="preserve">
          <source>The next time you run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will update the registry of crates available and reevaluate your &lt;code&gt;rand&lt;/code&gt; requirements according to the new version you have specified.</source>
          <target state="translated">下次您运行 &lt;code&gt;cargo build&lt;/code&gt; ，Cargo将更新可用包装箱的注册表，并根据您指定的新版本重新评估您的 &lt;code&gt;rand&lt;/code&gt; 要求。</target>
        </trans-unit>
        <trans-unit id="14f1a8115e3ecc473c296ccb90a19424fd7f3781" translate="yes" xml:space="preserve">
          <source>The nightly feature &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;Arbitrary self types&lt;/a&gt; extends the accepted set of receiver types to also include any type that can dereference to &lt;code&gt;Self&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e15e37e03d384e681f27ce15aeb9d3bb4095a8" translate="yes" xml:space="preserve">
          <source>The node that was removed is returned as a new &lt;code&gt;LinkedList&lt;/code&gt; containing only this node. The cursor is moved to point to the next element in the current &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145ccdcfae9c0bd6f7e5de42ea443500c786c639" translate="yes" xml:space="preserve">
          <source>The nominal type is called the &lt;em&gt;implementing type&lt;/em&gt; and the associable items are the &lt;em&gt;associated items&lt;/em&gt; to the implementing type.</source>
          <target state="translated">名义类型称为&lt;em&gt;实施类型&lt;/em&gt;，而&lt;em&gt;相关项目&lt;/em&gt;是与实施类型&lt;em&gt;相关的项目&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a450d39487d717bce9613fc2953a92eb80b07994" translate="yes" xml:space="preserve">
          <source>The note mentions &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, which is a &lt;em&gt;trait&lt;/em&gt;. We&amp;rsquo;ll talk about traits in the next section. For now, this error states that the body of &lt;code&gt;largest&lt;/code&gt; won&amp;rsquo;t work for all possible types that &lt;code&gt;T&lt;/code&gt; could be. Because we want to compare values of type &lt;code&gt;T&lt;/code&gt; in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; trait that you can implement on types (see Appendix C for more on this trait). You&amp;rsquo;ll learn how to specify that a generic type has a particular trait in the &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;Traits as Parameters&amp;rdquo;&lt;/a&gt; section, but let&amp;rsquo;s first explore other ways of using generic type parameters.</source>
          <target state="translated">注释中提到了 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; ，这是一个&lt;em&gt;特征&lt;/em&gt;。我们将在下一节中讨论特征。目前，此错误表明， &lt;code&gt;largest&lt;/code&gt; 的主体对 &lt;code&gt;T&lt;/code&gt; 可能适用的所有类型都不起作用。因为我们要比较主体中 &lt;code&gt;T&lt;/code&gt; 类型的值，所以我们只能使用其值可以排序的类型。为了启用比较，标准库具有 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; 特性，您可以在类型上实现（有关此特性的更多信息，请参见附录C）。您将在&lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;特性作为参数&amp;rdquo;&lt;/a&gt;部分中学习如何指定泛型类型具有特定特征，但让我们首先探讨使用泛型类型参数的其他方法。</target>
        </trans-unit>
        <trans-unit id="39a86e3fff1f9b2a932559db164eca88c47636bb" translate="yes" xml:space="preserve">
          <source>The number of arguments passed to a function must match the number of arguments specified in the function signature.</source>
          <target state="translated">传递给函数的参数数必须与函数签名中指定的参数数一致。</target>
        </trans-unit>
        <trans-unit id="1499b95664ab693551effdfbf1800a214feda909" translate="yes" xml:space="preserve">
          <source>The number of elements determines the arity of the tuple. A tuple with &lt;code&gt;n&lt;/code&gt; elements is called an &lt;code&gt;n-ary tuple&lt;/code&gt;. For example, a tuple with 2 elements is a 2-ary tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5008d92a3f283390aac2066e3363b4399cff1" translate="yes" xml:space="preserve">
          <source>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</source>
          <target state="translated">数组或切片模式中的元素数量与被匹配数组中的元素数量不同。</target>
        </trans-unit>
        <trans-unit id="110544a8e2a789b8a0779516d37df0cd0dba8ad5" translate="yes" xml:space="preserve">
          <source>The number of operands is the arity of the constructed tuple. Tuple expressions without operands produce the unit tuple. For other tuple expressions, the first written operand initializes the 0th element and subsequent operands initializes the next highest element. For example, in the tuple expression &lt;code&gt;('a', 'b', 'c')&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; initializes the value of the 0th element, &lt;code&gt;'b'&lt;/code&gt; the 1st, and &lt;code&gt;'c'&lt;/code&gt; the 2nd.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7202e21ed0c94540f8855e2b43b5089a13dd9685" translate="yes" xml:space="preserve">
          <source>The number of supplied arguments must exactly match the number of defined type parameters.</source>
          <target state="translated">提供的参数数量必须与定义的类型参数数量完全一致。</target>
        </trans-unit>
        <trans-unit id="1505278c99d9fb45d4f4157fc24b25e9be942498" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">偏移量是有界的，不能依赖&amp;ldquo;环绕&amp;rdquo;地址空间。也就是说，无限精度之和必须适合 &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb0b1c110f4f91ff6afa42a1772303d08fd7f686" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a usize.</source>
          <target state="translated">偏移量在界内,不能依靠 &quot;绕过 &quot;地址空间。也就是说,无限精度的和必须适合一个usize。</target>
        </trans-unit>
        <trans-unit id="dec85f2a58c1002de0f34de579c15b9ae5dcc5c3" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum, &lt;strong&gt;in bytes&lt;/strong&gt; must fit in a usize.</source>
          <target state="translated">偏移量是有界的，不能依赖&amp;ldquo;环绕&amp;rdquo;地址空间。也就是说，&lt;strong&gt;以字节为单位&lt;/strong&gt;的无限精度总和必须适合usize。</target>
        </trans-unit>
        <trans-unit id="b405bb6eb2033937b629bd683503a6e77a48009c" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;offset_to&lt;/code&gt; methods.</source>
          <target state="translated">偏移量以 &lt;code&gt;T&lt;/code&gt; 元素的数量表示，而不是以字节表示。返回的值可以与 &lt;code&gt;offset&lt;/code&gt; 或 &lt;code&gt;offset_to&lt;/code&gt; 方法一起使用。</target>
        </trans-unit>
        <trans-unit id="85ba9b2d34ef606ffd767c5e393592519fd3aa95" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;wrapping_add&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be821c2089924c0d18d107c2c27f16675f5ac1c" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor.</source>
          <target state="translated">这个偏移量是相对于文件的开始而言的,因此与当前光标无关。</target>
        </trans-unit>
        <trans-unit id="084e82e27a45f945c98a971924845d2bbfc865a4" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the read.</source>
          <target state="translated">偏移量相对于文件的开头，因此独立于当前光标。当前光标&lt;strong&gt;是&lt;/strong&gt;这个函数的影响，它被设定为读出结束。</target>
        </trans-unit>
        <trans-unit id="caf802013d8abd4267e3b977c2a718d4ec2a76b7" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the write.</source>
          <target state="translated">偏移量相对于文件的开头，因此独立于当前光标。当前光标&lt;strong&gt;是&lt;/strong&gt;这个函数的影响，它被设置在写结束。</target>
        </trans-unit>
        <trans-unit id="e661f5d3042445d2052a045a18f9872b66b5bc29" translate="yes" xml:space="preserve">
          <source>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</source>
          <target state="translated">旧的借款检查器存在已知的健全性问题,基本无法修复。新的基于NLL的借款检查器就是解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="ff9f5d5ca24724dc4d44a56e5f4a630aa34c4326" translate="yes" xml:space="preserve">
          <source>The one exception is the implicit &lt;code&gt;Self&lt;/code&gt; type of a trait. A trait does not have an implicit &lt;code&gt;Sized&lt;/code&gt; bound as this is incompatible with &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.</source>
          <target state="translated">一个例外是特征的隐式 &lt;code&gt;Self&lt;/code&gt; 类型。特质没有隐式的 &lt;code&gt;Sized&lt;/code&gt; 限制，因为它与&lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;特质对象&lt;/a&gt;不兼容，根据定义，特质对象需要与所有可能的实现者一起使用，因此可以是任意大小。</target>
        </trans-unit>
        <trans-unit id="251eb8c6b3ec1dc5000df1aa3f1d9769e8fc67e3" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one divides &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">可能发生这种换行的唯一情况是将 &lt;code&gt;MIN / -1&lt;/code&gt; 除以有符号类型（其中 &lt;code&gt;MIN&lt;/code&gt; 是该类型的负最小值）；这等效于 &lt;code&gt;-MIN&lt;/code&gt; ，它是一个太大的正值，无法在类型中表示。在这种情况下，此函数将自身返回 &lt;code&gt;MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76c053c143fda09cee97a50ed7a5afba7b9b021c" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one negates &lt;code&gt;MIN&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">可能发生这样的包装的唯一情况是当一个否定 &lt;code&gt;MIN&lt;/code&gt; 上的签名的类型（其中， &lt;code&gt;MIN&lt;/code&gt; 是该类型的负最小值）; 这是一个太大的值，无法在类型中表示。在这种情况下，此函数将自身返回 &lt;code&gt;MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f6de3ab26de46b22b8646658bc86041ba8f3d5e" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">可能发生这种换行的唯一情况是，当某类型取负的最小值为该类型的绝对值时，该正值太大而无法在该类型中表示。在这种情况下，此函数将自身返回 &lt;code&gt;MIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45d6aabe4740755ea8f6332847150daa44a43b07" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type; this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e8e964be307b9ddc1a920575e78207b9d44077" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to a copied value of &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b5a7f2069f2def348d2148cbc38445c3e27f4c" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to the value in &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">清单15-7和清单15-6之间的唯一区别是，此处我们将 &lt;code&gt;y&lt;/code&gt; 设置为指向 &lt;code&gt;x&lt;/code&gt; 中的值的盒子的实例，而不是指向 &lt;code&gt;x&lt;/code&gt; 的值的引用。在最后一个断言中，我们可以使用dereference运算符以与 &lt;code&gt;y&lt;/code&gt; 为引用时相同的方式跟踪框的指针。接下来，我们将探索 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 特殊之处，它使我们能够通过定义自己的box类型来使用解引用运算符。</target>
        </trans-unit>
        <trans-unit id="f7b8368bfb1b8c79cdb7d78152517d184d409bdd" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7a3f715132d2845165ebc499ef1753bb78d047" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors. &lt;code&gt;const&lt;/code&gt; functions are only available on a nightly compiler. Rust currently does not support more general compile-time function execution.</source>
          <target state="translated">可以在静态或常量表达式中调用的唯一函数是 &lt;code&gt;const&lt;/code&gt; 函数和struct / enum构造函数。 &lt;code&gt;const&lt;/code&gt; 函数仅在夜间编译器上可用。Rust目前不支持更常规的编译时函数执行。</target>
        </trans-unit>
        <trans-unit id="f7c42c506a124c9ffe70241d1844e481774b0efe" translate="yes" xml:space="preserve">
          <source>The only lifetime allowed in a constant is &lt;code&gt;'static&lt;/code&gt;, which is the lifetime that encompasses all others in a Rust program. For example, if you wanted to define a constant string, it would look like this:</source>
          <target state="translated">常量中唯一允许的生存期是 &lt;code&gt;'static&lt;/code&gt; ，这是Rust程序中包含所有其他生存期的生存期。例如，如果您想定义一个常量字符串，它将看起来像这样：</target>
        </trans-unit>
        <trans-unit id="c90e7627a1475de1daf664c395cb8fc220c2a179" translate="yes" xml:space="preserve">
          <source>The operand of a field expression.</source>
          <target state="translated">字段表达式的操作数。</target>
        </trans-unit>
        <trans-unit id="c815094584bba28655815f7e3484796d5b4ac295" translate="yes" xml:space="preserve">
          <source>The operand of a unary &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference&lt;/a&gt; operator.</source>
          <target state="translated">一元&lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;借用&lt;/a&gt;或&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;取消引用&lt;/a&gt;运算符的操作数。</target>
        </trans-unit>
        <trans-unit id="cfdf71c707b06cc703ce65b9173f06d5346346a9" translate="yes" xml:space="preserve">
          <source>The operand of an extending &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f114bcdcaebb0db94cec84309f6c6e9289e758" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8300616806da6883f068d3a939bb5817283d75af" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">任何&lt;a href=&quot;expressions#implicit-borrows&quot;&gt;隐式借用&lt;/a&gt;的操作数。</target>
        </trans-unit>
        <trans-unit id="13205f7dcdf1bb624db42e4217ccc5c5fe9a6c93" translate="yes" xml:space="preserve">
          <source>The operand of any extending borrow expression has its temporary scope extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0018d918b5db8fa5a5c40594da4082243e89b941" translate="yes" xml:space="preserve">
          <source>The operand(s) of an extending &lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;cast&lt;/a&gt;, &lt;a href=&quot;expressions/struct-expr&quot;&gt;braced struct&lt;/a&gt;, or &lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;tuple&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02413f33b0997a467453e2cc175754042613115c" translate="yes" xml:space="preserve">
          <source>The operation failed because a pipe was closed.</source>
          <target state="translated">操作失败的原因是管道被关闭。</target>
        </trans-unit>
        <trans-unit id="e0b6b6bb05edcbe700535a8a02fd6257faeb1085" translate="yes" xml:space="preserve">
          <source>The operation lacked the necessary privileges to complete.</source>
          <target state="translated">该操作缺乏必要的权限,无法完成。</target>
        </trans-unit>
        <trans-unit id="d56bd5ac430688946f617fddd5ff8737ea77aabc" translate="yes" xml:space="preserve">
          <source>The operation needs to block to complete, but the blocking operation was requested to not occur.</source>
          <target state="translated">操作需要阻断才能完成,但要求不发生阻断操作。</target>
        </trans-unit>
        <trans-unit id="554600e43876fa49fe1808261768a1599008a1a5" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; may be applied to operands of boolean type. The &lt;code&gt;||&lt;/code&gt; operator denotes logical 'or', and the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator denotes logical 'and'. They differ from &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, &lt;code&gt;||&lt;/code&gt; only evaluates its right-hand operand when the left-hand operand evaluates to &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; only when it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">运营商 &lt;code&gt;||&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 可以应用于布尔类型的操作数。该 &lt;code&gt;||&lt;/code&gt; 运算符表示逻辑&amp;ldquo;或&amp;rdquo;， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符表示逻辑&amp;ldquo;和&amp;rdquo;。它们与 &lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 中，当左边的操作数尚不确定表达式的结果的右边的操作数仅被评估。也就是说， &lt;code&gt;||&lt;/code&gt; 仅当左侧操作数的结果为 &lt;code&gt;false&lt;/code&gt; 时，才评估其右侧操作数；仅当 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 的结果为 &lt;code&gt;true&lt;/code&gt; 时，才评估其右操作数。</target>
        </trans-unit>
        <trans-unit id="94a90205d7a5e5f5664d5fdcbd09052010d467f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8 byte order mark&lt;/em&gt;&lt;/a&gt; (UTF8BOM production) indicates that the file is encoded in UTF8. It can only occur at the beginning of the file and is ignored by the compiler.</source>
          <target state="translated">可选的&lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8字节顺序标记&lt;/em&gt;&lt;/a&gt;（UTF8BOM产生）指示文件以UTF8编码。它只能出现在文件的开头，并且被编译器忽略。</target>
        </trans-unit>
        <trans-unit id="22d7081f01819ecc0a53443b4c5e3e1a4e2c048a" translate="yes" xml:space="preserve">
          <source>The optional fill character and alignment is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. It must be defined before &lt;code&gt;width&lt;/code&gt;, right after the &lt;code&gt;:&lt;/code&gt;. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. Filling comes in the following variants for different alignments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef92817d2fa5638a8f8e4bfed63d30ce997249b" translate="yes" xml:space="preserve">
          <source>The order in which this iterator returns entries is platform and filesystem dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60297fe01f4f2a21350a894e6ee139ac8e93f1b8" translate="yes" xml:space="preserve">
          <source>The order in which to evaluate the sub-expressions</source>
          <target state="translated">评估子表达式的顺序。</target>
        </trans-unit>
        <trans-unit id="61bedc7c16635e05c26ee08451d7e761461ef5bb" translate="yes" xml:space="preserve">
          <source>The organizational problem of allocating responsibility for multiple tasks to the &lt;code&gt;main&lt;/code&gt; function is common to many binary projects. As a result, the Rust community has developed a process to use as a guideline for splitting the separate concerns of a binary program when &lt;code&gt;main&lt;/code&gt; starts getting large. The process has the following steps:</source>
          <target state="translated">将多个任务的责任分配给 &lt;code&gt;main&lt;/code&gt; 功能的组织问题在许多二进制项目中很常见。结果，Rust社区开发了一种流程，当 &lt;code&gt;main&lt;/code&gt; 开始变大时，将其用作拆分二进制程序的单独问题的指南。该过程包括以下步骤：</target>
        </trans-unit>
        <trans-unit id="41be0c260fec224b2719e05df384f73991bede1b" translate="yes" xml:space="preserve">
          <source>The other arm of the &lt;code&gt;match&lt;/code&gt; handles the case where we get an &lt;code&gt;Err&lt;/code&gt; value from &lt;code&gt;File::open&lt;/code&gt;. In this example, we&amp;rsquo;ve chosen to call the &lt;code&gt;panic!&lt;/code&gt; macro. If there&amp;rsquo;s no file named &lt;em&gt;hello.txt&lt;/em&gt; in our current directory and we run this code, we&amp;rsquo;ll see the following output from the &lt;code&gt;panic!&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 的另一部分处理从 &lt;code&gt;File::open&lt;/code&gt; 获得 &lt;code&gt;Err&lt;/code&gt; 值的情况。在这个例子中，我们选择了 &lt;code&gt;panic!&lt;/code&gt; 宏。如果当前目录中没有名为&lt;em&gt;hello.txt&lt;/em&gt;的文件，并且运行此代码，我们将看到 &lt;code&gt;panic!&lt;/code&gt; 的以下输出！巨集：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7bf4938ef9d644fa6590a14199d49f21d906882" translate="yes" xml:space="preserve">
          <source>The other difference between &lt;code&gt;mut&lt;/code&gt; and shadowing is that because we&amp;rsquo;re effectively creating a new variable when we use the &lt;code&gt;let&lt;/code&gt; keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 和shadowing 之间的另一个区别是，因为当我们再次使用 &lt;code&gt;let&lt;/code&gt; 关键字时，我们正在有效地创建一个新变量，因此我们可以更改值的类型，但可以重用相同的名称。例如，假设我们的程序要求用户通过输入空格字符来显示他们想要在某些文本之间有多少空格，但是我们确实希望将该输入存储为数字：</target>
        </trans-unit>
        <trans-unit id="df7669a1bf85d9740015e4131e57d2cd1eb9d9d3" translate="yes" xml:space="preserve">
          <source>The other main use of the &lt;code&gt;const&lt;/code&gt; keyword is in &lt;code&gt;const fn&lt;/code&gt;. This marks a function as being callable in the body of a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; item and in array initializers (commonly called &quot;const contexts&quot;). &lt;code&gt;const fn&lt;/code&gt; are restricted in the set of operations they can perform, to ensure that they can be evaluated at compile-time. See the &lt;a href=&quot;../reference/const_eval&quot;&gt;Reference&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27877809931e30e4d816c929aaf44550dc13948" translate="yes" xml:space="preserve">
          <source>The other option is to decide that pinning is &quot;structural&quot; for &lt;code&gt;field&lt;/code&gt;, meaning that if the struct is pinned then so is the field.</source>
          <target state="translated">另一种选择是确定钉住 &lt;code&gt;field&lt;/code&gt; 是&amp;ldquo;结构&amp;rdquo; ，这意味着如果钉住结构，则字段也钉住。</target>
        </trans-unit>
        <trans-unit id="0642ecd58583a2694ae6dacfe0a415f63c694440" translate="yes" xml:space="preserve">
          <source>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called &lt;em&gt;polymorphism&lt;/em&gt;, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</source>
          <target state="translated">使用继承的另一个原因与类型系统有关：允许子类型在与父类型相同的位置使用。这也称为&lt;em&gt;多态&lt;/em&gt;，这意味着如果它们共享某些特征，则可以在运行时将它们彼此替换。</target>
        </trans-unit>
        <trans-unit id="89dc389d4ca8b1b17999395cda6f46045ddfd179" translate="yes" xml:space="preserve">
          <source>The other use of the &lt;code&gt;impl&lt;/code&gt; keyword is in &lt;code&gt;impl Trait&lt;/code&gt; syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 关键字的另一种用法是 &lt;code&gt;impl Trait&lt;/code&gt; 语法，可以将其视为&amp;ldquo;实现此特征的具体类型&amp;rdquo;的简写。它的主要用途是与闭包一起使用，闭包具有在编译时生成的类型定义，不能简单地将其键入。</target>
        </trans-unit>
        <trans-unit id="5fa7bdd2f67d8992d16557677350c79fe148aa6f" translate="yes" xml:space="preserve">
          <source>The other way to solve this error is to make the private type public. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b16008db0e7fefb3576376fa59c7cdb24bc4ca" translate="yes" xml:space="preserve">
          <source>The outer scope declares a variable named &lt;code&gt;r&lt;/code&gt; with no initial value, and the inner scope declares a variable named &lt;code&gt;x&lt;/code&gt; with the initial value of 5. Inside the inner scope, we attempt to set the value of &lt;code&gt;r&lt;/code&gt; as a reference to &lt;code&gt;x&lt;/code&gt;. Then the inner scope ends, and we attempt to print the value in &lt;code&gt;r&lt;/code&gt;. This code won&amp;rsquo;t compile because the value &lt;code&gt;r&lt;/code&gt; is referring to has gone out of scope before we try to use it. Here is the error message:</source>
          <target state="translated">外部作用域声明一个没有初始值的名为 &lt;code&gt;r&lt;/code&gt; 的变量，而内部作用域声明一个初始值为5的名为 &lt;code&gt;x&lt;/code&gt; 的变量。在内部作用域内，我们尝试将 &lt;code&gt;r&lt;/code&gt; 的值设置为对 &lt;code&gt;x&lt;/code&gt; 的引用。然后内部作用域结束，我们尝试在 &lt;code&gt;r&lt;/code&gt; 中打印该值。这段代码不会编译，因为在我们尝试使用 &lt;code&gt;r&lt;/code&gt; 之前，它所引用的值已经超出范围。这是错误消息：</target>
        </trans-unit>
        <trans-unit id="ee4813584901b6edf7255c9100533eb924eb1e04" translate="yes" xml:space="preserve">
          <source>The output of a finished process.</source>
          <target state="translated">完成过程的输出。</target>
        </trans-unit>
        <trans-unit id="7091d6ad7f032d028b64c465cb0226168ae0e89e" translate="yes" xml:space="preserve">
          <source>The output of this function should not be used in anything that might have security implications. For example:</source>
          <target state="translated">这个函数的输出不应该用于任何可能有安全影响的事情。例如:</target>
        </trans-unit>
        <trans-unit id="c978821bc364ab92333f8a77fd4cf50814193dc4" translate="yes" xml:space="preserve">
          <source>The output that the future will produce on completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5a226f1cb2eaa0ff96072c4caeb2fee856332d" translate="yes" xml:space="preserve">
          <source>The output type returned by methods.</source>
          <target state="translated">方法返回的输出类型。</target>
        </trans-unit>
        <trans-unit id="b3fedfd8280044a357b6d9f266e6194249a97d9a" translate="yes" xml:space="preserve">
          <source>The output will be the recommended workout plan. Listing 13-2 shows the &lt;code&gt;main&lt;/code&gt; function we&amp;rsquo;ll use.</source>
          <target state="translated">输出将是建议的锻炼计划。清单13-2显示了我们将使用的 &lt;code&gt;main&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="884c1b47c0faf2e5f38e29c6c1a9622d7629d70c" translate="yes" xml:space="preserve">
          <source>The overall goal of these requirements is to let the consumer of a pipeline use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c750221db5bde24f0432e5395fa0e7d6b2249e8f" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;buf&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39c88ef6b933b61e4ea4a039f34870326ac716b" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">将 &lt;code&gt;ptr&lt;/code&gt; 的所有权有效地转移到 &lt;code&gt;String&lt;/code&gt; ，然后可以随意分配，重新分配或更改指针所指向的内存内容。调用此函数后，请确保没有其他东西使用指针。</target>
        </trans-unit>
        <trans-unit id="0c5ac2aeb05d71a34b822c034365a66e97f5d90e" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 的所有权有效地转移到 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，然后Vec &amp;lt;T&amp;gt;可以随意取消分配，重新分配或更改指针所指向的内存内容。调用此函数后，请确保没有其他东西使用指针。</target>
        </trans-unit>
        <trans-unit id="459d615a7b443b2b18398d7b4e4094d21aa9904a" translate="yes" xml:space="preserve">
          <source>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by &lt;code&gt;drop&lt;/code&gt; unless the data has been moved to be owned by another variable.</source>
          <target state="translated">变量的所有权每次都遵循相同的模式：将值分配给另一个变量将其移动。当包含堆中数据的变量超出范围时，将 &lt;code&gt;drop&lt;/code&gt; 该值，除非该数据已被移交给另一个变量拥有。</target>
        </trans-unit>
        <trans-unit id="8158170312c35ad0b4ff632e830474174c9789f6" translate="yes" xml:space="preserve">
          <source>The ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let&amp;rsquo;s do an experiment to show how channels and ownership work together to prevent problems: we&amp;rsquo;ll try to use a &lt;code&gt;val&lt;/code&gt; value in the spawned thread &lt;em&gt;after&lt;/em&gt; we&amp;rsquo;ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn&amp;rsquo;t allowed:</source>
          <target state="translated">所有权规则在消息发送中起着至关重要的作用，因为它们可以帮助您编写安全的并发代码。防止并发编程出错是考虑整个Rust程序所有权的好处。让我们做一个实验，展示通道和所有权如何一起工作以防止问题：在将其发送到通道&lt;em&gt;之后，&lt;/em&gt;我们将尝试在生成的线程中使用 &lt;code&gt;val&lt;/code&gt; 值。尝试编译清单16-9中的代码，以查看为什么不允许使用此代码：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58f56a016b810f8287c744364955b1ffc32f9240" translate="yes" xml:space="preserve">
          <source>The panic hook is a global resource.</source>
          <target state="translated">慌钩是一种全球资源。</target>
        </trans-unit>
        <trans-unit id="684aef30b999855f4bf1399a43d22fd82b7e6c9d" translate="yes" xml:space="preserve">
          <source>The panic hook is invoked when a thread panics, but before the panic runtime is invoked. As such, the hook will run with both the aborting and unwinding runtimes. The default hook prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the &lt;code&gt;set_hook&lt;/code&gt; and &lt;a href=&quot;fn.take_hook&quot;&gt;&lt;code&gt;take_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">当线程出现紧急情况时，将在调用紧急情况运行时之前调用紧急情况钩子。因此，该挂钩将与中止和展开运行时一起运行。默认钩子将消息打印到标准错误，并在请求时生成回溯，但是可以使用 &lt;code&gt;set_hook&lt;/code&gt; 和&lt;a href=&quot;fn.take_hook&quot;&gt; &lt;code&gt;take_hook&lt;/code&gt; &lt;/a&gt;函数自定义此行为。</target>
        </trans-unit>
        <trans-unit id="563c97e45aeee516b45222324d4cc368e8c084ba" translate="yes" xml:space="preserve">
          <source>The parameters given to &lt;code&gt;Layout::from_size_align&lt;/code&gt; or some other &lt;code&gt;Layout&lt;/code&gt; constructor do not satisfy its documented constraints.</source>
          <target state="translated">给 &lt;code&gt;Layout::from_size_align&lt;/code&gt; 或其他一些 &lt;code&gt;Layout&lt;/code&gt; 构造函数提供的参数不满足其记录的约束。</target>
        </trans-unit>
        <trans-unit id="3c2a54faaf19386dc2b06158bf3003e146fc0f45" translate="yes" xml:space="preserve">
          <source>The parameters of any trait method must match between a trait implementation and the trait definition.</source>
          <target state="translated">任何特质方法的参数必须在特质实现和特质定义之间匹配。</target>
        </trans-unit>
        <trans-unit id="df3b8f99f35d92ad550b740bf7dc9171d35b97ed" translate="yes" xml:space="preserve">
          <source>The parent of a statement scope is the scope of the block that contains the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46091b9f972d668faf65caa23b2e09a8a170568" translate="yes" xml:space="preserve">
          <source>The parent of all other scopes is the scope of the immediately enclosing expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04065a98d4b38354b6e3e4d4abb130f6c621783" translate="yes" xml:space="preserve">
          <source>The parent of the arm scope is the scope of the &lt;code&gt;match&lt;/code&gt; expression that it belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a327800a21f08b5d4e1948e88aac172c2121be" translate="yes" xml:space="preserve">
          <source>The parent of the current &lt;a href=&quot;../reference/items/modules&quot;&gt;module&lt;/a&gt;.</source>
          <target state="translated">当前&lt;a href=&quot;../reference/items/modules&quot;&gt;模块&lt;/a&gt;的父级。</target>
        </trans-unit>
        <trans-unit id="529eb4e30d49293a9076afc4b5e1cde599b49562" translate="yes" xml:space="preserve">
          <source>The parent of the expression after the &lt;code&gt;=&amp;gt;&lt;/code&gt; in a &lt;code&gt;match&lt;/code&gt; expression is the scope of the arm that it's in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf69b726f2264b18f25a14f0c4351943f8d4d50" translate="yes" xml:space="preserve">
          <source>The parent of the expression for a &lt;code&gt;match&lt;/code&gt; guard is the scope of the arm that the guard is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e7154b1118c2abd23aedcc36e2f4febf44487b" translate="yes" xml:space="preserve">
          <source>The parent of the expression in an expression statement is the scope of the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1edfebb91e8c5be33d3f8d00037717971d53a2" translate="yes" xml:space="preserve">
          <source>The parent of the initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt; is the &lt;code&gt;let&lt;/code&gt; statement's scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7896dc490ba78587890c7c602aaea52ff1e61a5" translate="yes" xml:space="preserve">
          <source>The parent thread can also wait on the completion of the child thread; a call to &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; produces a &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, which provides a &lt;code&gt;join&lt;/code&gt; method for waiting:</source>
          <target state="translated">父线程也可以等待子线程的完成。对&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;的调用将产生&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt;，该JoinHandle提供了用于等待的 &lt;code&gt;join&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="46e80e0e5a125dc6b093687f5b3dfa680a2d94d7" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;inline&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">带括号的 &lt;code&gt;inline&lt;/code&gt; 属性需要指定参数：</target>
        </trans-unit>
        <trans-unit id="15c1964228f17e3bf48dc3c0a27f630dfed2aef1" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;instruction_set&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2172d9db47abf995cf78b6d1056e43a62f663b4" translate="yes" xml:space="preserve">
          <source>The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language. In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</source>
          <target state="translated">宏系统使用的解析器功能相当强大,但为了防止当前或未来版本的语言出现歧义,它受到了限制。特别是,除了关于模棱两可的扩展的规则外,一个元变量匹配的非终端后面必须跟上一个已经决定可以安全使用的标记。</target>
        </trans-unit>
        <trans-unit id="72524139620fe5680057ec138f1bc4009c442555" translate="yes" xml:space="preserve">
          <source>The path prefix for modules is the canonical path to that module. For bare implementations, it is the canonical path of the item being implemented surrounded by angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets. For &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt;, it is the canonical path of the item being implemented followed by &lt;code&gt;as&lt;/code&gt; followed by the canonical path to the trait all surrounded in angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets.</source>
          <target state="translated">模块的路径前缀是该模块的规范路径。对于裸露的实现，这是被尖括号（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）包围的要实现的项目的规范路径。对于&lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;性状的实现&lt;/a&gt;，这是该项目的规范的路径被实现的，接着 &lt;code&gt;as&lt;/code&gt; 随后规范路径到性状的角度（所有包围 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）括号。</target>
        </trans-unit>
        <trans-unit id="c6a4fb9e71adbfcd1bb4598c90adf218d993dcba" translate="yes" xml:space="preserve">
          <source>The path to the associated items is &lt;code&gt;&amp;lt;&lt;/code&gt; followed by a path to the implementing type followed by &lt;code&gt;as&lt;/code&gt; followed by a path to the trait followed by &lt;code&gt;&amp;gt;&lt;/code&gt; as a path component followed by the associated item's path component.</source>
          <target state="translated">关联项目的路径是 &lt;code&gt;&amp;lt;&lt;/code&gt; ,后面是实现类型的路径，接着是 &lt;code&gt;as&lt;/code&gt; 然后是特征的路径，然后是 &lt;code&gt;&amp;gt;&lt;/code&gt; 作为路径组成部分，然后是关联项目的路径组成部分。</target>
        </trans-unit>
        <trans-unit id="e791bfe4c14128fe94a9448b536323c040235679" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="9b997b2f72267455f266b90593be72c411299620" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="d7a545179141a5b3642800fa8e44597af1f79a17" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="eab1bd44108e3c6ec8d1d8c6acc9fac3b5f45a9e" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="b3313c804137756973c3dae6df1f5d957a288624" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">该模式可以是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;或确定字符是否匹配的闭包。</target>
        </trans-unit>
        <trans-unit id="bfcc6e07c89f929bc9a9b9157ac58712686768e0" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">模式可以是实现模式特征的任何类型。值得注意的示例是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;和确定拆分的闭包。</target>
        </trans-unit>
        <trans-unit id="eb766e07c7ab39fe3b62bc217205480afe2f8cd2" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">模式可以是实现模式特征的任何类型。值得注意的示例是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;和确定拆分的闭包。其他库可能会提供更复杂的模式，例如正则表达式。</target>
        </trans-unit>
        <trans-unit id="53665fb10463c2a5a8c8a6c23b4c3d2013b572a7" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">模式可以是实现模式特征的任何类型。值得注意的示例是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;和确定拆分的闭包。</target>
        </trans-unit>
        <trans-unit id="8059c918e0a15a39f2f09be5faf1d4cb011e74e6" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">模式可以是实现模式特征的任何类型。值得注意的示例是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;和确定拆分的闭包。其他库可能会提供更复杂的模式，例如正则表达式。</target>
        </trans-unit>
        <trans-unit id="70fe7a4be65487325b69a6e9166bdb513323e0b5" translate="yes" xml:space="preserve">
          <source>The pattern in the following example does four things:</source>
          <target state="translated">下面例子中的模式做了四件事。</target>
        </trans-unit>
        <trans-unit id="5a181811e45dbf2fc9dddcbe8e2017ec7127d78e" translate="yes" xml:space="preserve">
          <source>The pattern in the second match arm introduces a new variable named &lt;code&gt;y&lt;/code&gt; that will match any value inside a &lt;code&gt;Some&lt;/code&gt; value. Because we&amp;rsquo;re in a new scope inside the &lt;code&gt;match&lt;/code&gt; expression, this is a new &lt;code&gt;y&lt;/code&gt; variable, not the &lt;code&gt;y&lt;/code&gt; we declared at the beginning with the value 10. This new &lt;code&gt;y&lt;/code&gt; binding will match any value inside a &lt;code&gt;Some&lt;/code&gt;, which is what we have in &lt;code&gt;x&lt;/code&gt;. Therefore, this new &lt;code&gt;y&lt;/code&gt; binds to the inner value of the &lt;code&gt;Some&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. That value is &lt;code&gt;5&lt;/code&gt;, so the expression for that arm executes and prints &lt;code&gt;Matched, y = 5&lt;/code&gt;.</source>
          <target state="translated">第二个匹配臂中的模式引入了一个名为 &lt;code&gt;y&lt;/code&gt; 的新变量，它将匹配 &lt;code&gt;Some&lt;/code&gt; 值内的任何值。因为我们位于 &lt;code&gt;match&lt;/code&gt; 表达式内的新作用域中，所以这是一个新的 &lt;code&gt;y&lt;/code&gt; 变量，而不是我们在开始时以值10声明的 &lt;code&gt;y&lt;/code&gt; 。此新 &lt;code&gt;y&lt;/code&gt; 绑定将匹配 &lt;code&gt;Some&lt;/code&gt; 中的任何值，这就是我们拥有的在 &lt;code&gt;x&lt;/code&gt; 中。因此，这种新 &lt;code&gt;y&lt;/code&gt; 结合到的内部值 &lt;code&gt;Some&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt; 。该值为 &lt;code&gt;5&lt;/code&gt; ，因此该手臂的表达式将执行并打印 &lt;code&gt;Matched, y = 5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd1b310fb5c60706a33dc63407dcff2f0de81ecd" translate="yes" xml:space="preserve">
          <source>The pattern is most commonly a single variable, which means no pattern matching is done and the expression given is bound to the variable. Apart from that, patterns used in &lt;code&gt;let&lt;/code&gt; bindings can be as complicated as needed, given that the pattern is exhaustive. See the &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust book&lt;/a&gt; for more information on pattern matching. The type of the pattern is optionally given afterwards, but if left blank is automatically inferred by the compiler if possible.</source>
          <target state="translated">模式通常是单个变量，这意味着不进行模式匹配，并且给定的表达式绑定到该变量。除此之外，考虑到该模式是穷举性的， &lt;code&gt;let&lt;/code&gt; 绑定中使用的模式可以根据需要复杂。有关模式匹配的更多信息，请参见&lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust书&lt;/a&gt;。模式的类型在以后可以选择给出，但是如果可能，编译器会自动推断出是否为空白。</target>
        </trans-unit>
        <trans-unit id="c2459ac3b35f7ffa8e048896d3c16ca10cfe1608" translate="yes" xml:space="preserve">
          <source>The pattern of the first arm in the &lt;code&gt;match&lt;/code&gt; expression matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant that contains a &lt;code&gt;Color::Rgb&lt;/code&gt; variant; then the pattern binds to the three inner &lt;code&gt;i32&lt;/code&gt; values. The pattern of the second arm also matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant, but the inner enum matches the &lt;code&gt;Color::Hsv&lt;/code&gt; variant instead. We can specify these complex conditions in one &lt;code&gt;match&lt;/code&gt; expression, even though two enums are involved.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 表达式中第一条手臂的模式与 &lt;code&gt;Message::ChangeColor&lt;/code&gt; 枚举变量匹配，该变量包含 &lt;code&gt;Color::Rgb&lt;/code&gt; 变量；然后该模式将绑定到三个内部 &lt;code&gt;i32&lt;/code&gt; 值。第二个 &lt;code&gt;Color::Hsv&lt;/code&gt; 的模式也与 &lt;code&gt;Message::ChangeColor&lt;/code&gt; 枚举变量匹配，但是内部枚举与Color :: Hsv变量匹配。即使涉及两个枚举，我们也可以在一个 &lt;code&gt;match&lt;/code&gt; 表达式中指定这些复杂条件。</target>
        </trans-unit>
        <trans-unit id="a42d62f0f2bbc370e10f35406b8b10d13fb51143" translate="yes" xml:space="preserve">
          <source>The patterns programmed into Rust&amp;rsquo;s analysis of references are called the &lt;em&gt;lifetime elision rules&lt;/em&gt;. These aren&amp;rsquo;t rules for programmers to follow; they&amp;rsquo;re a set of particular cases that the compiler will consider, and if your code fits these cases, you don&amp;rsquo;t need to write the lifetimes explicitly.</source>
          <target state="translated">编入Rust的参考分析中的模式称为&lt;em&gt;寿命省略规则&lt;/em&gt;。这些不是程序员要遵循的规则。它们是编译器将考虑的一组特殊情况，如果您的代码适合这些情况，则无需显式编写生存期。</target>
        </trans-unit>
        <trans-unit id="012a0566d4550e7174697625c83965140d98cc31" translate="yes" xml:space="preserve">
          <source>The peer address may be set by the &lt;code&gt;connect&lt;/code&gt; method, and this method will return an error if the socket has not already been connected.</source>
          <target state="translated">可以通过 &lt;code&gt;connect&lt;/code&gt; 方法设置对等地址，如果尚未连接套接字，则此方法将返回错误。</target>
        </trans-unit>
        <trans-unit id="c7338ebe0eb2e257ec72f81d23df2b1d8ecc7ce7" translate="yes" xml:space="preserve">
          <source>The performance of these two features (Spoiler alert: they&amp;rsquo;re faster than you might think!)</source>
          <target state="translated">这两个功能的性能（剧透警报：它们比您想象的要快！）</target>
        </trans-unit>
        <trans-unit id="b42828007b197505190540700b376ffcea8793e7" translate="yes" xml:space="preserve">
          <source>The pointer is valid only if there are some strong references. The pointer may be dangling, unaligned or even &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c13daf063b9e605b83028dc0feae2167ff80511" translate="yes" xml:space="preserve">
          <source>The pointer may be &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or be dangling in case the object has already been destroyed.</source>
          <target state="translated">如果对象已被破坏，则指针可以为&lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt;或悬空。</target>
        </trans-unit>
        <trans-unit id="c51f7cfe5691f3edc0397a76000e0e31815c58dc" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6cc95e7b609b2c158e2115aa97ef7549141c5d" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab75a519555d7d953b751dc8250587661100bb4" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032bd62f596d84915c186de815c7e316435955e0" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada677800eded9f5bb09a12d4c9272e1a48a79a4" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6efbb545be55e13f893ac7dc6eaebbf999874a" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7882f94a6f87dc84506e67cf6e6f86cd53b02982" translate="yes" xml:space="preserve">
          <source>The pointer must be properly aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3de011a05d32ff014b1d75b10f32cd8a5ceea0c" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) for the duration of this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97c31e45ac08eaf340466af2855c1d69a8c822f" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) when invoking this method. This method can be used to release the final &lt;code&gt;Arc&lt;/code&gt; and backing storage, but &lt;strong&gt;should not&lt;/strong&gt; be called after the final &lt;code&gt;Arc&lt;/code&gt; has been released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b7d63adfc51a7db20582294688b5c6c47a0e5f" translate="yes" xml:space="preserve">
          <source>The pointer must have originated from the &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; and must still own its potential weak reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561496e3426c59f66cb3091efa83ade648ff436f" translate="yes" xml:space="preserve">
          <source>The pointer must point to an initialized instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d562cc44e11330190c6c67edae5c28019986b445" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">该指针必须代表一个有效的弱计数。换句话说，它必须指向 &lt;code&gt;T&lt;/code&gt; 是或者&lt;em&gt;是&lt;/em&gt;由管理&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;和，弱计数&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;不能达到0.这是允许的强烈计数为0。</target>
        </trans-unit>
        <trans-unit id="20794b93602408cab637197663bf6c675231f221" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">该指针必须代表一个有效的弱计数。换句话说，它必须指向 &lt;code&gt;T&lt;/code&gt; 其是或&lt;em&gt;被&lt;/em&gt;由管理&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;和的，弱计数&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;不能达到0。允许为强计数为0。</target>
        </trans-unit>
        <trans-unit id="d6200eb92cc97fc1d9fec6dde1612acc6fca320f" translate="yes" xml:space="preserve">
          <source>The pointer passed to all functions inside the vtable is the &lt;code&gt;data&lt;/code&gt; pointer from the enclosing &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">传递给vtable内部所有函数的指针是来自封闭的&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;对象的 &lt;code&gt;data&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="1edb65c05d4061d65ef7c599b48750ef7ff50704" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">此函数返回的指针必须返回到Rust，并使用&lt;a href=&quot;#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt;进行重构以正确释放。具体地，应该&lt;em&gt;不&lt;/em&gt;使用标准C &lt;code&gt;free()&lt;/code&gt; 的函数来解除分配此字符串。</target>
        </trans-unit>
        <trans-unit id="80c5d8a7d931f08c90875d736c69378d02a8b64f" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33be8edf304b61e5005625c2c6aab855fc0ce0b3" translate="yes" xml:space="preserve">
          <source>The pointer will be properly aligned and non-null.</source>
          <target state="translated">指针将被正确对齐且非空。</target>
        </trans-unit>
        <trans-unit id="0c49a977fe21d66debc9a4c8b7d4cbbf312c9ff9" translate="yes" xml:space="preserve">
          <source>The pointer-sized signed integer type.</source>
          <target state="translated">指针大小的有符号整数类型。</target>
        </trans-unit>
        <trans-unit id="aebc6996cd3e6c3ef507e0e5f263e13ad4dcb04b" translate="yes" xml:space="preserve">
          <source>The pointer-sized unsigned integer type.</source>
          <target state="translated">指针大小的无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="589a00e779c762d350b4058d583ec6c935c455c7" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; had no internal buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aef48aecfebe1bd9e6f96a0939bb1d8fec84054" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">&lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; 用于查找的位置是如果 &lt;code&gt;BufReader&lt;/code&gt; 没有内部缓冲区，则底层阅读器将位于的位置。</target>
        </trans-unit>
        <trans-unit id="6f1678b0e093177e7620807a9112f4ef7365e563" translate="yes" xml:space="preserve">
          <source>The positive difference of two numbers.</source>
          <target state="translated">两个数的正差。</target>
        </trans-unit>
        <trans-unit id="e0a83025808dfefbef9f39106ce5fafd89bb2f1c" translate="yes" xml:space="preserve">
          <source>The practical use cases for &lt;code&gt;forget&lt;/code&gt; are rather specialized and mainly come up in unsafe or FFI code.</source>
          <target state="translated">&lt;code&gt;forget&lt;/code&gt; 的实际用例相当专业，主要用不安全或FFI代码编写。</target>
        </trans-unit>
        <trans-unit id="fb2efbc552f75b7ae8fe422ecdae2c87a030f044" translate="yes" xml:space="preserve">
          <source>The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</source>
          <target state="translated">Rust运算符和表达式的优先级排序如下,从强到弱。同一优先级的二元运算符按其关联性给出的顺序分组。</target>
        </trans-unit>
        <trans-unit id="5ed57a298428ca0f7395d0616c5eb17f0804c549" translate="yes" xml:space="preserve">
          <source>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</source>
          <target state="translated">精确的Rust别名规则有些变化,但要点没有争议。</target>
        </trans-unit>
        <trans-unit id="b19f5cee233892caf5ddceb163f25862486da448" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40bd8a03d88e20d491263cadc1752cd72c99258" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">确切的定义是：当且仅当 &lt;code&gt;&amp;amp;T&lt;/code&gt; 为&lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 时,&lt;/a&gt;类型 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;Sync&lt;/code&gt; 。换句话说，在线程之间传递 &lt;code&gt;&amp;amp;T&lt;/code&gt; 引用时，如果不可能发生&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;不确定的行为&lt;/a&gt;（包括数据争用）。</target>
        </trans-unit>
        <trans-unit id="f47fdb8c6eff67732e48f22a8373d2422de700a9" translate="yes" xml:space="preserve">
          <source>The precise memory layout of a struct is not specified. One can specify a particular layout using the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">没有指定结构的精确内存布局。可以使用&lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; 属性&lt;/a&gt;指定一种特定的布局。</target>
        </trans-unit>
        <trans-unit id="18073d476ac74d19109a41401163857e8cd5056d" translate="yes" xml:space="preserve">
          <source>The precise rules for validity are not determined yet. The guarantees that are provided at this point are very minimal:</source>
          <target state="translated">有效性的确切规则尚未确定。目前提供的保障是非常少的。</target>
        </trans-unit>
        <trans-unit id="4933f50236b0c7e48edc0beedb70199f13c5e285" translate="yes" xml:space="preserve">
          <source>The predicate passed to &lt;code&gt;partition()&lt;/code&gt; can return &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;partition()&lt;/code&gt; returns a pair, all of the elements for which it returned &lt;code&gt;true&lt;/code&gt;, and all of the elements for which it returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;partition()&lt;/code&gt; 的谓词可以返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;partition()&lt;/code&gt; 返回一对，返回其所有元素为 &lt;code&gt;true&lt;/code&gt; ，返回所有元素为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fb4a93626b0bdb54fdbc20512bf4f76ed5cc7cd" translate="yes" xml:space="preserve">
          <source>The preferred alignment of a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc19e95dcebc744b29e267ad8d2ebfde2e212c0" translate="yes" xml:space="preserve">
          <source>The prelude can be changed to the &lt;em&gt;core prelude&lt;/em&gt; by using the &lt;code&gt;no_std&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; on the root crate module. The linked crate is &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt;&lt;code&gt;core&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt;&lt;code&gt;core::prelude::v1&lt;/code&gt;&lt;/a&gt;. Using the core prelude over the standard prelude is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. &lt;code&gt;Box&lt;/code&gt; and &lt;code&gt;Vec&lt;/code&gt;) and file and network capabilities (e.g. &lt;code&gt;std::fs&lt;/code&gt; and &lt;code&gt;std::io&lt;/code&gt;).</source>
          <target state="translated">通过使用根板条箱模块上的 &lt;code&gt;no_std&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;，可以将前奏更改为&lt;em&gt;核心前奏&lt;/em&gt;。链接的板条箱是&lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt; &lt;code&gt;core&lt;/code&gt; &lt;/a&gt;，而prelude模块是&lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt; &lt;code&gt;core::prelude::v1&lt;/code&gt; &lt;/a&gt;。当板条箱针对不支持标准库的平台或有目的地不使用标准库的功能的平台时，在标准前奏中使用核心前奏很有用。这些功能主要是动态内存分配（例如 &lt;code&gt;Box&lt;/code&gt; 和 &lt;code&gt;Vec&lt;/code&gt; ）以及文件和网络功能（例如 &lt;code&gt;std::fs&lt;/code&gt; 和 &lt;code&gt;std::io&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="97af9d37776d235cea4e5a19d84cc2b3492bd088" translate="yes" xml:space="preserve">
          <source>The previous Appendix D, &amp;ldquo;Macros,&amp;rdquo; has been expanded to include procedural macros and was moved to the &amp;ldquo;Macros&amp;rdquo; section in Chapter 19.</source>
          <target state="translated">先前的附录D&amp;ldquo;宏&amp;rdquo;已扩展为包括过程宏，并移至第19章的&amp;ldquo;宏&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="757bcf5f0a1b2e7c263eb1294cae88079f56068e" translate="yes" xml:space="preserve">
          <source>The previous code example fixed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0414a5a5139b7f4e08b6a8b19dea661159e39f" translate="yes" xml:space="preserve">
          <source>The previous example contains a circular dependency between two traits: &lt;code&gt;FirstTrait&lt;/code&gt; depends on &lt;code&gt;SecondTrait&lt;/code&gt; which itself depends on &lt;code&gt;FirstTrait&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a02be48083e6dc1dccc9a7d07cadacc4a53e7c" translate="yes" xml:space="preserve">
          <source>The previously duplicated code is now outside the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks and uses the &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-8.</source>
          <target state="translated">现在，以前复制的代码位于 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块之外，并使用 &lt;code&gt;status_line&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 变量。这使得比较容易看出这两种情况之间的区别，这意味着如果我们想更改文件读取和响应写入的工作方式，则只有一个地方可以更新代码。清单20-9中的代码的行为与清单20-8中的代码相同。</target>
        </trans-unit>
        <trans-unit id="3c5b34498a69e2cebc3edcacf3022a159fa0d3cf" translate="yes" xml:space="preserve">
          <source>The primary separator of path components for the current platform.</source>
          <target state="translated">当前平台的路径组件的主要分离器。</target>
        </trans-unit>
        <trans-unit id="d6d94c1dd4c2a4fb7b30d949d7313e70926e43b0" translate="yes" xml:space="preserve">
          <source>The primary use for the &lt;code&gt;let&lt;/code&gt; keyword is in &lt;code&gt;let&lt;/code&gt; statements, which are used to introduce a new set of variables into the current scope, as given by a pattern.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 关键字的主要用途是在 &lt;code&gt;let&lt;/code&gt; 语句中，该语句用于将一组新变量引入当前作用域，如模式所示。</target>
        </trans-unit>
        <trans-unit id="14d97c2e9b793134fb211ba0f8484d81636a707d" translate="yes" xml:space="preserve">
          <source>The primary use of the &lt;code&gt;crate&lt;/code&gt; keyword is as a part of &lt;code&gt;extern crate&lt;/code&gt; declarations, which are used to specify a dependency on a crate external to the one it's declared in. Crates are the fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can be read about crates in the &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; 关键字的主要用途是 &lt;code&gt;extern crate&lt;/code&gt; 声明的一部分，extern crate声明用于指定对其声明的外部外部条件箱的依赖性。条板箱是Rust代码的基本编译单元，可以看作是库。或项目。在&lt;a href=&quot;../reference/items/extern-crates&quot;&gt;参考资料中&lt;/a&gt;可以找到有关板条箱的更多信息。</target>
        </trans-unit>
        <trans-unit id="229057a153cb547539a5140063be86de4fd5f109" translate="yes" xml:space="preserve">
          <source>The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.</source>
          <target state="translated">锁的优先级策略取决于底层操作系统的实现,这种类型不保证会使用任何特定的策略。</target>
        </trans-unit>
        <trans-unit id="aa4bf60f4fab6128150a2cced20eb507a73f2223" translate="yes" xml:space="preserve">
          <source>The private address ranges are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; and include:</source>
          <target state="translated">专用地址范围在&lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt;中定义，包括：</target>
        </trans-unit>
        <trans-unit id="66e536d148965eb5f5f66293b59e6e08d6c64117" translate="yes" xml:space="preserve">
          <source>The problem above can be solved by using the &lt;code&gt;ref&lt;/code&gt; keyword.</source>
          <target state="translated">上面的问题可以通过使用 &lt;code&gt;ref&lt;/code&gt; 关键字解决。</target>
        </trans-unit>
        <trans-unit id="a6b09f11dabd510af2bfd7f547ade1211b4999bd" translate="yes" xml:space="preserve">
          <source>The problem here is that foo is defined as accepting a parameter of type &lt;code&gt;Fn&lt;/code&gt;. Closures passed into foo will thus be inferred to be of type &lt;code&gt;Fn&lt;/code&gt;, meaning that they capture their context immutably.</source>
          <target state="translated">这里的问题是foo被定义为接受 &lt;code&gt;Fn&lt;/code&gt; 类型的参数。因此，传递给foo的闭包将被推断为 &lt;code&gt;Fn&lt;/code&gt; 类型，这意味着它们不可变地捕获其上下文。</target>
        </trans-unit>
        <trans-unit id="31cdd55efce31c6be1cacdfc4b62449817b4add1" translate="yes" xml:space="preserve">
          <source>The problem here is that if the given type or one of its fields implements the &lt;code&gt;Drop&lt;/code&gt; trait, this &lt;code&gt;Drop&lt;/code&gt; implementation cannot be called within a const context since it may run arbitrary, non-const-checked code. To prevent this issue, ensure all values with custom a custom &lt;code&gt;Drop&lt;/code&gt; implementation escape the initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0a1b6d65ca057a3fdc49e919abfbdd1b60d9bd" translate="yes" xml:space="preserve">
          <source>The problem here is that the lifetime isn't contrained by any of the arguments, making it impossible to determine how long it's supposed to live.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe892e0206a6e32b9668f223826cd09ae2236ca9" translate="yes" xml:space="preserve">
          <source>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</source>
          <target state="translated">这里的问题是,我们正试图从 MyTrait 中获取 X 的类型。不幸的是,X 的类型并没有被定义,因为它只在 trait 的实现中被具体化。这个代码的工作版本可能是这样的。</target>
        </trans-unit>
        <trans-unit id="e5cbbff1b6bec23be456b36b8e81795c5a5d74a0" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;result&lt;/code&gt; goes out of scope and gets cleaned up at the end of the &lt;code&gt;longest&lt;/code&gt; function. We&amp;rsquo;re also trying to return a reference to &lt;code&gt;result&lt;/code&gt; from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won&amp;rsquo;t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</source>
          <target state="translated">问题是 &lt;code&gt;result&lt;/code&gt; 超出了范围，并在 &lt;code&gt;longest&lt;/code&gt; 函数结束时被清除。我们还试图返回对该函数 &lt;code&gt;result&lt;/code&gt; 的引用。我们无法指定将更改悬空参考的生命周期参数，Rust不允许我们创建悬空参考。在这种情况下，最好的解决办法是返回一个拥有的数据类型，而不是返回一个引用，因此调用函数负责清理该值。</target>
        </trans-unit>
        <trans-unit id="967a587dbf080c4427ca5b25acc74fdfbb85e443" translate="yes" xml:space="preserve">
          <source>The problem is that the first time we called &lt;code&gt;c.value&lt;/code&gt; with 1, the &lt;code&gt;Cacher&lt;/code&gt; instance saved &lt;code&gt;Some(1)&lt;/code&gt; in &lt;code&gt;self.value&lt;/code&gt;. Thereafter, no matter what we pass in to the &lt;code&gt;value&lt;/code&gt; method, it will always return 1.</source>
          <target state="translated">问题在于，我们第一次使用1 调用 &lt;code&gt;c.value&lt;/code&gt; 时， &lt;code&gt;Cacher&lt;/code&gt; 实例将 &lt;code&gt;Some(1)&lt;/code&gt; 保存在 &lt;code&gt;self.value&lt;/code&gt; 中。此后，无论我们传递给 &lt;code&gt;value&lt;/code&gt; 方法什么，它将始终返回1。</target>
        </trans-unit>
        <trans-unit id="833738d2692abe453105a9ed609d8a8bc820fa2a" translate="yes" xml:space="preserve">
          <source>The problem is that the parameter &lt;code&gt;T&lt;/code&gt; does not appear in the implementing type (&lt;code&gt;Foo&lt;/code&gt;) of the impl. In this case, we can fix the error by moving the type parameter from the &lt;code&gt;impl&lt;/code&gt; to the method &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">问题是参数 &lt;code&gt;T&lt;/code&gt; 不会出现在impl 的实现类型（ &lt;code&gt;Foo&lt;/code&gt; ）中。在这种情况下，我们可以通过将类型参数从 &lt;code&gt;impl&lt;/code&gt; 移到 &lt;code&gt;get&lt;/code&gt; 方法来解决错误：</target>
        </trans-unit>
        <trans-unit id="457d0fe3119f86c660d95b413dfdd79fba1ea792" translate="yes" xml:space="preserve">
          <source>The problem isn&amp;rsquo;t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, and it is &lt;a href=&quot;../std/option/enum.option&quot;&gt;defined by the standard library&lt;/a&gt; as follows:</source>
          <target state="translated">问题不在于概念，而在于特定的实现。这样，Rust没有空值，但是它确实有一个枚举，该枚举可以编码存在或不存在的值的概念。该枚举是 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ，&lt;a href=&quot;../std/option/enum.option&quot;&gt;由标准库&lt;/a&gt;定义如下：</target>
        </trans-unit>
        <trans-unit id="11afe9c5b7d3b341c43395982cbb657bcfedf0f3" translate="yes" xml:space="preserve">
          <source>The problem with null values is that if you try to use a null value as a not-null value, you&amp;rsquo;ll get an error of some kind. Because this null or not-null property is pervasive, it&amp;rsquo;s extremely easy to make this kind of error.</source>
          <target state="translated">空值的问题在于，如果您尝试将空值用作非空值，则会出现某种错误。由于此null或not-null属性无处不在，因此很容易产生这种错误。</target>
        </trans-unit>
        <trans-unit id="c7ffb82b1f0d51caf9c86374d324e2fb9ccac1dd" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the contents.</source>
          <target state="translated">该进程缺乏查看内容的权限。</target>
        </trans-unit>
        <trans-unit id="475777e2dbe3eb987a1fdf9f7258e8744d697a33" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the number of hardware threads available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a1f341aa82ec15ad62b2ae6744edcef123d4a7" translate="yes" xml:space="preserve">
          <source>The process may be in a &quot;broken state&quot; if this function returns in error. For example the working directory, environment variables, signal handling settings, various user/group information, or aspects of stdio file descriptors may have changed. If a &quot;transactional spawn&quot; is required to gracefully handle errors it is recommended to use the cross-platform &lt;code&gt;spawn&lt;/code&gt; instead.</source>
          <target state="translated">如果此函数错误返回，则该过程可能处于&amp;ldquo;中断状态&amp;rdquo;。例如，工作目录，环境变量，信号处理设置，各种用户/组信息或stdio文件描述符的各个方面可能已更改。如果需要&amp;ldquo;事务生成&amp;rdquo;来妥善处理错误，建议改用跨平台 &lt;code&gt;spawn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68c2b04d8256c338d13f147c4eb19b87b45d4040" translate="yes" xml:space="preserve">
          <source>The programs we&amp;rsquo;ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we&amp;rsquo;ll cover in the &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;Cargo Workspaces&amp;rdquo;&lt;/a&gt; section in Chapter 14.</source>
          <target state="translated">到目前为止，我们编写的程序都在一个模块中的一个文件中。随着项目的发展，您可以通过将代码分成多个模块然后分成多个文件来组织代码。一个包可以包含多个二进制板条箱，也可以包含一个库板条箱。随着软件包的增长，您可以将零件提取到单独的板条箱中，这些板条箱成为外部依赖项。本章涵盖所有这些技术。对于一起发展的一组相互关联的程序包的大型项目，Cargo提供了工作区，我们将在第14章的&lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;货物工作区&amp;rdquo;&lt;/a&gt;一节中介绍这些工作区。</target>
        </trans-unit>
        <trans-unit id="5cc2497d5ed1d06060f022ff65bd8b3ff66c60a9" translate="yes" xml:space="preserve">
          <source>The provided &lt;a href=&quot;struct.layout#method.size&quot;&gt;&lt;code&gt;layout.size()&lt;/code&gt;&lt;/a&gt; must fall in the range &lt;code&gt;min ..= max&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1cd28ce339784f890d38adb07a623811959d09" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;path&lt;/code&gt; doesn't exist.</source>
          <target state="translated">提供的 &lt;code&gt;path&lt;/code&gt; 不存在。</target>
        </trans-unit>
        <trans-unit id="a99e10f876c8ad74bd47e22ac1f9e01fe1760d28" translate="yes" xml:space="preserve">
          <source>The public methods &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; are the only ways to access or modify data in an instance of &lt;code&gt;AveragedCollection&lt;/code&gt;. When an item is added to &lt;code&gt;list&lt;/code&gt; using the &lt;code&gt;add&lt;/code&gt; method or removed using the &lt;code&gt;remove&lt;/code&gt; method, the implementations of each call the private &lt;code&gt;update_average&lt;/code&gt; method that handles updating the &lt;code&gt;average&lt;/code&gt; field as well.</source>
          <target state="translated">公共方法 &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;remove&lt;/code&gt; 和 &lt;code&gt;average&lt;/code&gt; 是在 &lt;code&gt;AveragedCollection&lt;/code&gt; 实例中访问或修改数据的唯一方法。当使用 &lt;code&gt;add&lt;/code&gt; 方法将项目添加到 &lt;code&gt;list&lt;/code&gt; 或使用 &lt;code&gt;remove&lt;/code&gt; 方法将项目删除时，每个项目的实现都调用私有的 &lt;code&gt;update_average&lt;/code&gt; 方法，该方法也处理 &lt;code&gt;average&lt;/code&gt; 字段的更新。</target>
        </trans-unit>
        <trans-unit id="c64a2ba34c09d4f2e756bf0b0db2bf928ce82f04" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is called&lt;/em&gt;. Only once &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; returns or panics, the memory may be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a93f31254516d6844f82cc6e94b5893fc7d6231" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;code&gt;drop&lt;/code&gt; is called&lt;/em&gt;. Memory can be invalidated by deallocation, but also by replacing a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, or calling &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt;&lt;code&gt;Vec::set_len&lt;/code&gt;&lt;/a&gt; to &quot;kill&quot; some elements off of a vector. It can be repurposed by using &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;ptr::write&lt;/code&gt;&lt;/a&gt; to overwrite it without calling the destructor first.</source>
          <target state="translated">固定的目的是能够依靠某些数据在内存中的放置。为了使这项工作有效，不仅限制了移动数据，还限制了数据的传输。限制用于存储数据的内存的重新分配，重新利用或以其他方式使之无效。具体来说，对于固定的数据，您必须保持不变，即&lt;em&gt;从固定数据直到调用 &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt;，&lt;em&gt;其内存都不会失效或重新利用&lt;/em&gt;。存储器可以由解除分配被无效，而且通过更换&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt;由&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，或调用&lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt; &lt;code&gt;Vec::set_len&lt;/code&gt; &lt;/a&gt; &amp;ldquo;杀死&amp;rdquo;一些元件断开的载体。可以通过使用&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;ptr::write&lt;/code&gt; &lt;/a&gt;来重新设置它的用途，而无需先调用析构函数。</target>
        </trans-unit>
        <trans-unit id="dadde1acddaa4f2663e0f0f8fe2f53b8bd256d16" translate="yes" xml:space="preserve">
          <source>The purpose of these &lt;code&gt;Result&lt;/code&gt; types is to encode error-handling information. Values of the &lt;code&gt;Result&lt;/code&gt; type, like values of any type, have methods defined on them. An instance of &lt;code&gt;io::Result&lt;/code&gt; has an &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; method&lt;/a&gt; that you can call. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Err&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will cause the program to crash and display the message that you passed as an argument to &lt;code&gt;expect&lt;/code&gt;. If the &lt;code&gt;read_line&lt;/code&gt; method returns an &lt;code&gt;Err&lt;/code&gt;, it would likely be the result of an error coming from the underlying operating system. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will take the return value that &lt;code&gt;Ok&lt;/code&gt; is holding and return just that value to you so you can use it. In this case, that value is the number of bytes in what the user entered into standard input.</source>
          <target state="translated">这些 &lt;code&gt;Result&lt;/code&gt; 类型的目的是对错误处理信息进行编码。的值 &lt;code&gt;Result&lt;/code&gt; 类型，像任何类型的值，都方法对它们限定。 &lt;code&gt;io::Result&lt;/code&gt; 的实例具有您可以调用的&lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt; &lt;code&gt;expect&lt;/code&gt; 方法&lt;/a&gt;。如果这种情况下 &lt;code&gt;io::Result&lt;/code&gt; 是 &lt;code&gt;Err&lt;/code&gt; 值， &lt;code&gt;expect&lt;/code&gt; 将导致程序崩溃，并显示您作为参数传递给传递的消息 &lt;code&gt;expect&lt;/code&gt; 。如果 &lt;code&gt;read_line&lt;/code&gt; 方法返回 &lt;code&gt;Err&lt;/code&gt; ，则可能是来自底层操作系统的错误的结果。如果此 &lt;code&gt;io::Result&lt;/code&gt; 实例是一个 &lt;code&gt;Ok&lt;/code&gt; 值， &lt;code&gt;expect&lt;/code&gt; 将取 &lt;code&gt;Ok&lt;/code&gt; 持有的返回值，并将该值仅返回给您，以便您可以使用它。在这种情况下，该值是用户输入到标准输入中的字节数。</target>
        </trans-unit>
        <trans-unit id="17a957e4dd15537d9df26e9cd567ee8ac4ab9c24" translate="yes" xml:space="preserve">
          <source>The purpose of this example is to demonstrate a situation in which some generic parameters are declared with &lt;code&gt;impl&lt;/code&gt; and some are declared with the method definition. Here, the generic parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are declared after &lt;code&gt;impl&lt;/code&gt;, because they go with the struct definition. The generic parameters &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; are declared after &lt;code&gt;fn mixup&lt;/code&gt;, because they&amp;rsquo;re only relevant to the method.</source>
          <target state="translated">本示例的目的是演示一种情况，其中某些通用参数用 &lt;code&gt;impl&lt;/code&gt; 声明，而某些则用方法定义声明。此处，通用参数 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 在 &lt;code&gt;impl&lt;/code&gt; 之后声明，因为它们与struct定义一起使用。通用参数 &lt;code&gt;V&lt;/code&gt; 和 &lt;code&gt;W&lt;/code&gt; 在 &lt;code&gt;fn mixup&lt;/code&gt; 之后声明，因为它们仅与方法有关。</target>
        </trans-unit>
        <trans-unit id="83464f6d897f3cf3890af3a243744932372ed118" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to alleviate imports of many common I/O traits by adding a glob import to the top of I/O heavy modules:</source>
          <target state="translated">这个模块的目的是通过在I/O重度模块的顶部增加一个glob导入,来缓解很多常见的I/O特性的导入。</target>
        </trans-unit>
        <trans-unit id="c5176304cb4e1480563977bff5f9fc8f29f52bf7" translate="yes" xml:space="preserve">
          <source>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis.</source>
          <target state="translated">特质对象的目的是允许方法的 &quot;后期绑定&quot;。调用特质对象上的方法会在运行时导致虚拟调度:即从特质对象vtable中加载一个函数指针并间接调用。每个vtable条目的实际实现可以因对象而异。</target>
        </trans-unit>
        <trans-unit id="f15fea39e76fdfafefd43bfce074d20361154e36" translate="yes" xml:space="preserve">
          <source>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn&amp;rsquo;t working as expected. You&amp;rsquo;ll put unit tests in the &lt;em&gt;src&lt;/em&gt; directory in each file with the code that they&amp;rsquo;re testing. The convention is to create a module named &lt;code&gt;tests&lt;/code&gt; in each file to contain the test functions and to annotate the module with &lt;code&gt;cfg(test)&lt;/code&gt;.</source>
          <target state="translated">单元测试的目的是与其余代码隔离地测试每个代码单元，以快速查明代码在哪里正常工作和不正常工作。您将使用它们正在测试的代码将单元测试放在每个文件的&lt;em&gt;src&lt;/em&gt;目录中。约定是在每个文件中创建一个名为 &lt;code&gt;tests&lt;/code&gt; 的模块以包含测试功能，并使用 &lt;code&gt;cfg(test)&lt;/code&gt; 对该模块进行注释。</target>
        </trans-unit>
        <trans-unit id="60cba1f37e61726b832a14d7f1500e4426e9a5cc" translate="yes" xml:space="preserve">
          <source>The question mark operator</source>
          <target state="translated">问号运算符</target>
        </trans-unit>
        <trans-unit id="018537889ded2ab112f094946b8612c9a86b99ba" translate="yes" xml:space="preserve">
          <source>The question mark operator (&lt;code&gt;?&lt;/code&gt;) unwraps valid values or returns erroneous values, propagating them to the calling function. It is a unary postfix operator that can only be applied to the types &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">问号运算符（ &lt;code&gt;?&lt;/code&gt; ）取消包装有效值或返回错误值，将其传播到调用函数。它是一元后缀运算符，只能应用于 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ea5d63d0d5a319dd6d9072a4460aea03a494584" translate="yes" xml:space="preserve">
          <source>The question mark operator, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">问号运算符， &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61208bdae8b221a09aba4f839d74c11c2925c51c" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f32&lt;/code&gt; 内部表示形式的基数或基数。</target>
        </trans-unit>
        <trans-unit id="ea313a35fa236b37b46428fb2657491b2e33dea3" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f32::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc170d8fddda3392ca3bbfeb02d09cfb7f6a80ce" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; 内部表示形式的基数或基数。</target>
        </trans-unit>
        <trans-unit id="eb77af93de4b13de0ebcbd9266a033e54a3960fe" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f64::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9457bd197a286afc52dbcebb942e61605b222d" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;start &amp;lt;= x &amp;lt; end&lt;/code&gt;. It is empty if &lt;code&gt;start &amp;gt;= end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510a943d569cb4f1080072d01ababcb91699bcc6" translate="yes" xml:space="preserve">
          <source>The range is empty if either side is incomparable:</source>
          <target state="translated">如果任何一方不可比拟,则该范围为空。</target>
        </trans-unit>
        <trans-unit id="a7d43b8cf204eefd21645fceff96d69cfb297982" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2067413bc1879d44bf7542436c24e1555ca1bc" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc134868dea70688318900dea4fb56c096c2fce" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">原始指针必须事先已通过调用&lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc::into_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb442a6e9f4c3ea3ad88f7d20cbb90e50f086583" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">原始指针必须事先已通过调用&lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc::into_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61edb86c6e775bcbcc090bf0b2354d8086752aee" translate="yes" xml:space="preserve">
          <source>The re-ordering prevented by the different ordering semantics are:</source>
          <target state="translated">不同的排序语义所阻止的重新排序是:。</target>
        </trans-unit>
        <trans-unit id="db75fd7d163698847a2930407a821664ef9dc7a1" translate="yes" xml:space="preserve">
          <source>The reading portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;的读取部分应关闭。</target>
        </trans-unit>
        <trans-unit id="bb2e18a8faa1f91810d19956a7143af41d8b7e9f" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">弃用的原因是该函数基本上不能正确使用：&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;Rust编译器假定&lt;/a&gt;值已正确初始化。结果，调用例如 &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; 会导致立即不确定的行为，以返回肯定不是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的 &lt;code&gt;bool&lt;/code&gt; 。更糟糕的是，真正的未初始化内存（如此处返回的内存）的特殊之处在于，编译器知道它没有固定的值。这使在变量中具有未初始化的数据成为不确定的行为，即使该变量具有整数类型也是如此。 （请注意，关于未初始化整数的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。）</target>
        </trans-unit>
        <trans-unit id="0a840dd2de2cd2ee34a26f979453151250b4e843" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: it has the same effect as &lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt;&lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt;&lt;/a&gt;. As the &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt; documentation&lt;/a&gt; explains, &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d0c9e3177e947296d0e4cad464419f6391db88" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;rlib&lt;/code&gt; files do not contain any of their upstream dependencies. It wouldn't be very efficient for all &lt;code&gt;rlib&lt;/code&gt; files to contain a copy of &lt;code&gt;libstd.rlib&lt;/code&gt;!</source>
          <target state="translated">原因是 &lt;code&gt;rlib&lt;/code&gt; 文件不包含任何上游依赖项。所有 &lt;code&gt;rlib&lt;/code&gt; 文件都包含 &lt;code&gt;libstd.rlib&lt;/code&gt; 的副本并不是非常有效！</target>
        </trans-unit>
        <trans-unit id="f95aa7105ee4000143fc92462b837053383a52a0" translate="yes" xml:space="preserve">
          <source>The reason for this is that there are two appearances of type parameter &lt;code&gt;T&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; header, both as parameters for &lt;code&gt;ForeignTrait2&lt;/code&gt;. The first appearance is uncovered, and so runs afoul of the orphan rule.</source>
          <target state="translated">这是因为在 &lt;code&gt;impl&lt;/code&gt; 标头中出现了两种类型的参数 &lt;code&gt;T&lt;/code&gt; ，它们都是 &lt;code&gt;ForeignTrait2&lt;/code&gt; 的参数。首次露面是未发现的，因此与孤立规则不符。</target>
        </trans-unit>
        <trans-unit id="ef37c27a4f0dd2645ce86c85a75eac6a77fa29d9" translate="yes" xml:space="preserve">
          <source>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there&amp;rsquo;s no reason we would want to prevent &lt;code&gt;x&lt;/code&gt; from being valid after we create the variable &lt;code&gt;y&lt;/code&gt;. In other words, there&amp;rsquo;s no difference between deep and shallow copying here, so calling &lt;code&gt;clone&lt;/code&gt; wouldn&amp;rsquo;t do anything different from the usual shallow copying and we can leave it out.</source>
          <target state="translated">原因是诸如在编译时具有已知大小的整数之类的类型完全存储在堆栈中，因此可以快速创建实际值的副本。这意味着在创建变量 &lt;code&gt;y&lt;/code&gt; 之后我们没有理由要阻止 &lt;code&gt;x&lt;/code&gt; 有效。换句话说，这里的深层复制和浅层复制没有区别，因此调用 &lt;code&gt;clone&lt;/code&gt; 与通常的浅层复制没有什么不同，我们可以省去它。</target>
        </trans-unit>
        <trans-unit id="5c1ca57165d895e7b5a9a07fb8f81dd8e653560f" translate="yes" xml:space="preserve">
          <source>The reason is that you&amp;rsquo;re missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. To rectify this error, you need to include this information in the &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">原因是您缺少一些关键信息：需要描述和许可证，以便人们知道您的板条箱做什么以及可以使用哪些条款。要纠正此错误，您需要在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中包括此信息。</target>
        </trans-unit>
        <trans-unit id="87dec969a1d8a7fd52229930c681793b58499b7c" translate="yes" xml:space="preserve">
          <source>The reason is that, in the first example, there are many possible types that &lt;code&gt;!&lt;/code&gt; could coerce to, because many types implement &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt;. However, in the second example, the &lt;code&gt;else&lt;/code&gt; branch returns a &lt;code&gt;0&lt;/code&gt;, which the compiler infers from the return type to be of type &lt;code&gt;u32&lt;/code&gt;. Since &lt;code&gt;u32&lt;/code&gt; is a concrete type, &lt;code&gt;!&lt;/code&gt; can and will be coerced to it. See issue &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;#36375&lt;/a&gt; for more information on this quirk of &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725753993f38910ecfb713203cf3afe96ff590f2" translate="yes" xml:space="preserve">
          <source>The reason that this matter is that the type &lt;code&gt;fn(S)&lt;/code&gt; is not specific to any particular function: it's a function &lt;em&gt;pointer&lt;/em&gt;. So calling &lt;code&gt;x()&lt;/code&gt; results in a virtual call, whereas &lt;code&gt;foo()&lt;/code&gt; is statically dispatched, because the type of &lt;code&gt;foo&lt;/code&gt; tells us precisely what function is being called.</source>
          <target state="translated">之所以如此，是因为 &lt;code&gt;fn(S)&lt;/code&gt; 类型不是特定于任何特定函数的：它是一个函数&lt;em&gt;指针&lt;/em&gt;。因此，调用 &lt;code&gt;x()&lt;/code&gt; 会导致虚拟调用，而 &lt;code&gt;foo()&lt;/code&gt; 是静态调度的，因为 &lt;code&gt;foo&lt;/code&gt; 的类型精确地告诉我们正在调用什么函数。</target>
        </trans-unit>
        <trans-unit id="2f71ddaa6e32a7d6efaff9da8a4ddd4766615cbe" translate="yes" xml:space="preserve">
          <source>The reason the &lt;code&gt;deref&lt;/code&gt; method returns a reference to a value, and that the plain dereference outside the parentheses in &lt;code&gt;*(y.deref())&lt;/code&gt; is still necessary, is the ownership system. If the &lt;code&gt;deref&lt;/code&gt; method returned the value directly instead of a reference to the value, the value would be moved out of &lt;code&gt;self&lt;/code&gt;. We don&amp;rsquo;t want to take ownership of the inner value inside &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in this case or in most cases where we use the dereference operator.</source>
          <target state="translated">所有权制度是 &lt;code&gt;deref&lt;/code&gt; 方法返回对值的引用，并且仍需要在 &lt;code&gt;*(y.deref())&lt;/code&gt; 括号外进行普通取消引用的原因。如果 &lt;code&gt;deref&lt;/code&gt; 方法直接返回该值而不是对该值的引用，则该值将移出 &lt;code&gt;self&lt;/code&gt; 。在这种情况下，或者在大多数情况下，我们使用解引用运算符时，我们都不希望拥有 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 中内部值的所有权。</target>
        </trans-unit>
        <trans-unit id="1d62bb1a32655921533dae07c7931836afe25a19" translate="yes" xml:space="preserve">
          <source>The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn&amp;rsquo;t have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:</source>
          <target state="translated">此函数在没有生命周期注释的情况下进行编译的原因是历史悠久的：在Rust的早期版本（1.0之前的版本）中，由于每个引用都需要明确的生命周期，因此不会编译该代码。那时，函数签名应如下所示：</target>
        </trans-unit>
        <trans-unit id="bedb5e3116e5d92919b43a452878e5db1b96099b" translate="yes" xml:space="preserve">
          <source>The reason we&amp;rsquo;re able to use &lt;code&gt;&amp;amp;s2&lt;/code&gt; in the call to &lt;code&gt;add&lt;/code&gt; is that the compiler can &lt;em&gt;coerce&lt;/em&gt; the &lt;code&gt;&amp;amp;String&lt;/code&gt; argument into a &lt;code&gt;&amp;amp;str&lt;/code&gt;. When we call the &lt;code&gt;add&lt;/code&gt; method, Rust uses a &lt;em&gt;deref coercion&lt;/em&gt;, which here turns &lt;code&gt;&amp;amp;s2&lt;/code&gt; into &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt;. We&amp;rsquo;ll discuss deref coercion in more depth in Chapter 15. Because &lt;code&gt;add&lt;/code&gt; does not take ownership of the &lt;code&gt;s&lt;/code&gt; parameter, &lt;code&gt;s2&lt;/code&gt; will still be a valid &lt;code&gt;String&lt;/code&gt; after this operation.</source>
          <target state="translated">我们能够在 &lt;code&gt;add&lt;/code&gt; 调用中使用 &lt;code&gt;&amp;amp;s2&lt;/code&gt; 的原因是，编译器可以将 &lt;code&gt;&amp;amp;String&lt;/code&gt; 参数&lt;em&gt;强制&lt;/em&gt;转换为 &lt;code&gt;&amp;amp;str&lt;/code&gt; 。当我们调用 &lt;code&gt;add&lt;/code&gt; 方法时，Rust使用了&lt;em&gt;deref强制&lt;/em&gt;，这会将 &lt;code&gt;&amp;amp;s2&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt; 。我们将在第15章中更深入地讨论deref强制。由于 &lt;code&gt;add&lt;/code&gt; 不拥有 &lt;code&gt;s&lt;/code&gt; 参数的所有权，因此 &lt;code&gt;s2&lt;/code&gt; 在此操作之后仍将是有效的 &lt;code&gt;String&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f3cfdfa90a10325648e4c2eb952b413419929140" translate="yes" xml:space="preserve">
          <source>The receiver of a method, or the current module.</source>
          <target state="translated">方法的接受者,或当前模块。</target>
        </trans-unit>
        <trans-unit id="d73164a885c270ed79f7ee9c783984160bde564d" translate="yes" xml:space="preserve">
          <source>The receiving end of a channel has two useful methods: &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;try_recv&lt;/code&gt;. We&amp;rsquo;re using &lt;code&gt;recv&lt;/code&gt;, short for &lt;em&gt;receive&lt;/em&gt;, which will block the main thread&amp;rsquo;s execution and wait until a value is sent down the channel. Once a value is sent, &lt;code&gt;recv&lt;/code&gt; will return it in a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When the sending end of the channel closes, &lt;code&gt;recv&lt;/code&gt; will return an error to signal that no more values will be coming.</source>
          <target state="translated">通道的接收端有两个有用的方法： &lt;code&gt;recv&lt;/code&gt; 和 &lt;code&gt;try_recv&lt;/code&gt; 。我们正在使用 &lt;code&gt;recv&lt;/code&gt; ，它是&lt;em&gt;receive的&lt;/em&gt;缩写，它将阻塞主线程的执行，并等待一个值从通道发送出去。发送值后， &lt;code&gt;recv&lt;/code&gt; 将在 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 返回它。当通道的发送端关闭时， &lt;code&gt;recv&lt;/code&gt; 将返回一个错误，表示将不再有任何值。</target>
        </trans-unit>
        <trans-unit id="bb4caae3b66529c5330d18c3a08329f2bc2f3deb" translate="yes" xml:space="preserve">
          <source>The receiving half of Rust's &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) type. This half can only be owned by one thread.</source>
          <target state="translated">Rust的&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;（或&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;）类型的接收一半。这一半只能由一个线程拥有。</target>
        </trans-unit>
        <trans-unit id="8b2bfb185407e4c60c25d227a4ff77b2cda29f86" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust will try to drop &lt;code&gt;b&lt;/code&gt; first, which will decrease the count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance in &lt;code&gt;b&lt;/code&gt; by 1.</source>
          <target state="translated">所述的引用计数 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在这两种情况下 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是2后，我们在改变列表 &lt;code&gt;a&lt;/code&gt; 至点 &lt;code&gt;b&lt;/code&gt; 。在年底 &lt;code&gt;main&lt;/code&gt; ，锈病将尝试下降 &lt;code&gt;b&lt;/code&gt; 第一，这将减少的计数 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 例如在 &lt;code&gt;b&lt;/code&gt; 1。</target>
        </trans-unit>
        <trans-unit id="0309be91bd54044d4044342a0389163de0a934e4" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;src&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;dst&lt;/code&gt; with the same size.</source>
          <target state="translated">以 &lt;code&gt;src&lt;/code&gt; 开始且大小为 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 个字节的内存区域&lt;em&gt;不得&lt;/em&gt;与以 &lt;code&gt;dst&lt;/code&gt; 开始且大小相同的内存区域重叠。</target>
        </trans-unit>
        <trans-unit id="5dcc17f2dc1b8084d38071ff6ddcb2865d4ada36" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;x&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;y&lt;/code&gt; with the same size.</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 开始的内存区域，其大小为 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 个字节，&lt;em&gt;不得&lt;/em&gt;与从 &lt;code&gt;y&lt;/code&gt; 开始且大小相同的内存区域重叠。</target>
        </trans-unit>
        <trans-unit id="6e24cbd3ed4b7a19863f8c010bc7cecf513544b8" translate="yes" xml:space="preserve">
          <source>The relative order of partitioned items is not maintained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d262cc92a6d55445ae1cc06ba8d24d6a4bfc8a" translate="yes" xml:space="preserve">
          <source>The relevant &lt;code&gt;use&lt;/code&gt; statements</source>
          <target state="translated">相关 &lt;code&gt;use&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="92055677c3977ae45c2e91b99d3cb2b7bc2e7a00" translate="yes" xml:space="preserve">
          <source>The remainder assignment operator &lt;code&gt;%=&lt;/code&gt;.</source>
          <target state="translated">其余的赋值运算符 &lt;code&gt;%=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e1e6181542061352f1920b8d99d81207a670f7f" translate="yes" xml:space="preserve">
          <source>The remainder from the division of two floats.</source>
          <target state="translated">两次浮动的除法所产生的余数。</target>
        </trans-unit>
        <trans-unit id="054039eee5819e5face98778f38bf1e0291c343e" translate="yes" xml:space="preserve">
          <source>The remainder has the same sign as the dividend and is computed as: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt;.</source>
          <target state="translated">余数与除数具有相同的符号，并计算为： &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5654d619adf6380504b572e1ea12d7691a4525f9" translate="yes" xml:space="preserve">
          <source>The remainder operator &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">余数运算符 &lt;code&gt;%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b313ceee14929f12b1b754da920f2c480594a9a" translate="yes" xml:space="preserve">
          <source>The remaining characters are alphanumeric or &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">其余字符为字母数字或 &lt;code&gt;_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db31fc17b3b16891bdde4b2e11c17a8b55001a20" translate="yes" xml:space="preserve">
          <source>The removed element is replaced by the last element of the vector.</source>
          <target state="translated">移除的元素被替换为向量的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="bdcb1bbcfc5506185f4dcdac6bb92b93d0ea27b3" translate="yes" xml:space="preserve">
          <source>The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the &lt;code&gt;$( $i:ident ),*&lt;/code&gt; example above matches &lt;code&gt;$i&lt;/code&gt; to all of the identifiers in the list.</source>
          <target state="translated">重复的片段会匹配并转录为指定数量的片段，并由分隔符分隔。元变量与其对应片段的每次重复都匹配。例如，上面的 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 示例将 &lt;code&gt;$i&lt;/code&gt; 与列表中的所有标识符匹配。</target>
        </trans-unit>
        <trans-unit id="12103d0e7fb92d8d3b9ddae239cdf39dea7eeb65" translate="yes" xml:space="preserve">
          <source>The repetition operators are:</source>
          <target state="translated">重复运算符是:</target>
        </trans-unit>
        <trans-unit id="bfcbf2851f89edd4f300f9b36ba95aadb203f98e" translate="yes" xml:space="preserve">
          <source>The representation does &lt;em&gt;not&lt;/em&gt; look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation &lt;code&gt;s2 = s1&lt;/code&gt; could be very expensive in terms of runtime performance if the data on the heap were large.</source>
          <target state="translated">表示不会&lt;em&gt;不会&lt;/em&gt;看起来像图4-3，这是记忆是什么样子，如果锈复制而不是堆的数据也是如此。如果Rust这样做，则如果堆上的数据很大，则操作 &lt;code&gt;s2 = s1&lt;/code&gt; 就运行时性能而言可能会非常昂贵。</target>
        </trans-unit>
        <trans-unit id="0b1df299f3611946c8ad866e3a9d4772fabb543c" translate="yes" xml:space="preserve">
          <source>The representation of a &lt;code&gt;repr(C)&lt;/code&gt; enum with fields is a &lt;code&gt;repr(C)&lt;/code&gt; struct with two fields, also called a &quot;tagged union&quot; in C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3948c1d71b2273d20d352ff100e99a529e9f18b" translate="yes" xml:space="preserve">
          <source>The representation of a primitive representation enum is a &lt;code&gt;repr(C)&lt;/code&gt; union of &lt;code&gt;repr(C)&lt;/code&gt; structs for each variant with a field. The first field of each struct in the union is the primitive representation version of the enum with all fields removed (&quot;the tag&quot;) and the remaining fields are the fields of that variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3b4092c2efea2b55e7548a736c3333a566aec1" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 这样的特征对象的表示形式。</target>
        </trans-unit>
        <trans-unit id="4110c125de481ad527206c93b01dbedc11c02bc7" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84fd9c512efc7dcedf9b018795fbba5c08fc5ad5" translate="yes" xml:space="preserve">
          <source>The representation of a type can be changed by applying the &lt;code&gt;repr&lt;/code&gt; attribute to it. The following example shows a struct with a &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">可以通过将 &lt;code&gt;repr&lt;/code&gt; 属性应用于类型来更改类型的表示形式。以下示例显示具有 &lt;code&gt;C&lt;/code&gt; 表示形式的结构。</target>
        </trans-unit>
        <trans-unit id="5a8aa6aa295a219e257360fdb9ca2113bb7bc323" translate="yes" xml:space="preserve">
          <source>The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a &lt;code&gt;C&lt;/code&gt; representation that contains a struct &lt;code&gt;Inner&lt;/code&gt; with the default representation will not change the layout of &lt;code&gt;Inner&lt;/code&gt;.</source>
          <target state="translated">类型的表示形式可以更改字段之间的填充，但不能更改字段本身的布局。例如，具有 &lt;code&gt;C&lt;/code&gt; 表示形式的结构包含具有默认表示形式的结构 &lt;code&gt;Inner&lt;/code&gt; 的结构不会更改 &lt;code&gt;Inner&lt;/code&gt; 的布局。</target>
        </trans-unit>
        <trans-unit id="8de668564b1808c69c7a252869635782239a849b" translate="yes" xml:space="preserve">
          <source>The representation semantics of floating-point numbers are described in &lt;a href=&quot;types/numeric&quot;&gt;&quot;Machine Types&quot;&lt;/a&gt;.</source>
          <target state="translated">浮点数的表示语义在&lt;a href=&quot;types/numeric&quot;&gt;&amp;ldquo;机器类型&amp;rdquo;中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="568b4d39b3d684710e1069cdb58107435b4ee105" translate="yes" xml:space="preserve">
          <source>The requested ABI is unsupported by the current target.</source>
          <target state="translated">请求的ABI不受当前目标的支持。</target>
        </trans-unit>
        <trans-unit id="6079a0a7d416189b9655a6ad531ff1787c361185" translate="yes" xml:space="preserve">
          <source>The required alignment of the referenced value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f41ba31da382f1ab342b312f6ebecf708e0a4f" translate="yes" xml:space="preserve">
          <source>The required inputs are these:</source>
          <target state="translated">所需的投入是:</target>
        </trans-unit>
        <trans-unit id="f6ffffcc1dc56ad2b07c96ba04b8dfcf628fd050" translate="yes" xml:space="preserve">
          <source>The requirements for this program haven&amp;rsquo;t been agreed upon yet, and we&amp;rsquo;re pretty sure the &lt;code&gt;Hello&lt;/code&gt; text at the beginning of the greeting will change. We decided we don&amp;rsquo;t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the &lt;code&gt;greeting&lt;/code&gt; function, we&amp;rsquo;ll just assert that the output contains the text of the input parameter.</source>
          <target state="translated">该程序的要求尚未达成共识，我们非常确定问候语开头的 &lt;code&gt;Hello&lt;/code&gt; 文本会更改。我们决定不需要更改需求时就更新测试，因此，我们只断言输出包含输入参数的文本，而不是检查与 &lt;code&gt;greeting&lt;/code&gt; 函数返回的值是否完全相同。</target>
        </trans-unit>
        <trans-unit id="0cbf837e1937a12c606036644e82391851dc8756" translate="yes" xml:space="preserve">
          <source>The responsibilities that remain in the &lt;code&gt;main&lt;/code&gt; function after this process should be limited to the following:</source>
          <target state="translated">在此过程之后，保留在 &lt;code&gt;main&lt;/code&gt; 职能中的职责应限于以下各项：</target>
        </trans-unit>
        <trans-unit id="fb88378aaf4cdd384feeec625a8c476a227f1fe6" translate="yes" xml:space="preserve">
          <source>The rest of the traits defined in the standard library can&amp;rsquo;t be implemented on your types using &lt;code&gt;derive&lt;/code&gt;. These traits don&amp;rsquo;t have sensible default behavior, so it&amp;rsquo;s up to you to implement them in the way that makes sense for what you&amp;rsquo;re trying to accomplish.</source>
          <target state="translated">标准库中定义的其余特征不能使用 &lt;code&gt;derive&lt;/code&gt; 在您的类型上实现。这些特征没有明智的默认行为，因此取决于您要实现的目标，取决于您如何实施它们。</target>
        </trans-unit>
        <trans-unit id="3a3c86e891d6ad8a6d17dd1936fd9bfccb1b62f4" translate="yes" xml:space="preserve">
          <source>The rest of this book uses commands that work in both &lt;em&gt;cmd.exe&lt;/em&gt; and PowerShell. If there are specific differences, we&amp;rsquo;ll explain which to use.</source>
          <target state="translated">本书的其余部分使用在&lt;em&gt;cmd.exe&lt;/em&gt;和PowerShell 中均可使用的命令。如果有特定差异，我们将说明使用哪个。</target>
        </trans-unit>
        <trans-unit id="00dd9e9169ec993decc3de54bbe98c364e0e7806" translate="yes" xml:space="preserve">
          <source>The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.</source>
          <target state="translated">这个箱子文档的其余部分专门指出了Rust标准库的显著特征。</target>
        </trans-unit>
        <trans-unit id="ac1c550b13307d7f1181fa4746cc5e5943901d94" translate="yes" xml:space="preserve">
          <source>The rest pattern is always irrefutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cd0ab16fb284f9bcdd09aeae886a98592a2f2d" translate="yes" xml:space="preserve">
          <source>The result can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54e546283bfd6f5bb35e08c8e91500e43fa3efb" translate="yes" xml:space="preserve">
          <source>The result is allocated on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f60835a1f670fd1068b73e7310483f7414303f8" translate="yes" xml:space="preserve">
          <source>The result may not be correctly rounded owing to implementation details; &lt;code&gt;self.log2()&lt;/code&gt; can produce more accurate results for base 2, and &lt;code&gt;self.log10()&lt;/code&gt; can produce more accurate results for base 10.</source>
          <target state="translated">由于实施细节，结果可能无法正确舍入； &lt;code&gt;self.log2()&lt;/code&gt; 可以为基数2产生更准确的结果， &lt;code&gt;self.log10()&lt;/code&gt; 可以为基数10产生更准确的结果。</target>
        </trans-unit>
        <trans-unit id="c4dbebfb961a1bddcfad953b06a027b749fbba28" translate="yes" xml:space="preserve">
          <source>The result of &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; an expression with type &lt;a href=&quot;../std/boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and that can also be moved out of.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;取消引用&lt;/a&gt;类型为&lt;a href=&quot;../std/boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;的表达式的结果，也可以将其移出。</target>
        </trans-unit>
        <trans-unit id="fe2526308745be82b19ed557143eb06c9172e9c2" translate="yes" xml:space="preserve">
          <source>The result of a generator resumption.</source>
          <target state="translated">发电机复产的结果。</target>
        </trans-unit>
        <trans-unit id="d471d20c06ef14c004fab8262f7528514deaa1c4" translate="yes" xml:space="preserve">
          <source>The result of casting a reference to a pointer is valid for as long as the underlying object is live and no reference (just raw pointers) is used to access the same memory.</source>
          <target state="translated">只要底层对象是活的,并且没有使用任何引用(只是原始指针)来访问相同的内存,那么对指针的引用的铸造结果就有效。</target>
        </trans-unit>
        <trans-unit id="ac56fae426229e4d543dba38661557fbee8bb52d" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing with formatting strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cd246d6c4827dc128a4e9ac189ceccd07f4e85" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;的结果！宏是&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;类型的值。然后可以将此结构传递给该模块内部的&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;函数，以便处理格式字符串。该宏的目标是在处理格式字符串时甚至进一步防止中间分配。</target>
        </trans-unit>
        <trans-unit id="1c32345d3d6f612f235d03a8cd84044465cbfeea" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt;.</source>
          <target state="translated">结果将代表IP地址 &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99c7c63b15fc6ea4f165265a5fd114fc5db86d31" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;b&lt;/code&gt;.&lt;code&gt;c&lt;/code&gt;.&lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">结果将代表IP地址 &lt;code&gt;a&lt;/code&gt; 。 &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;c&lt;/code&gt; 。 &lt;code&gt;d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7373e6f7caa0a9dff8d78cf60558cf221157bd80" translate="yes" xml:space="preserve">
          <source>The resulting layout will be the same as that of a C struct containing two fields with the layouts of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in that order.</source>
          <target state="translated">生成的布局将与包含两个字段的C结构相同，该两个字段具有 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 的布局。</target>
        </trans-unit>
        <trans-unit id="99a0997f56bdadd8bd20428a4a2ef3bbae789fac" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">最终的生命周期与自我绑定，因此它的行为&amp;ldquo;好像&amp;rdquo;实际上是被借用的T的实例。如果需要更长的时间（未绑定），请使用 &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f78e2e736259493757a0ced96e6b992b486267c6" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">最终的生命周期与自我绑定，因此它的行为&amp;ldquo;好像&amp;rdquo;实际上是被借用的T的实例。如果需要更长的（未绑定）生存期，请使用 &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9220ca335fae6d1972b4901944a1126d0f38ae8e" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;).</source>
          <target state="translated">生成的指针不必在范围之内，但是取消引用有潜在的危险（这需要 &lt;code&gt;unsafe&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="81b4f59283eb3ce773831a86dd58d26e19da85b4" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;). In particular, the resulting pointer may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object than the one &lt;code&gt;self&lt;/code&gt; points to. In other words, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">生成的指针不必在范围之内，但是取消引用有潜在的危险（这需要 &lt;code&gt;unsafe&lt;/code&gt; ）。特别是，所得的指针可能&lt;em&gt;无法&lt;/em&gt;用于访问一个 &lt;code&gt;self&lt;/code&gt; 指向的不同的已分配对象。换句话说， &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;一样 &lt;code&gt;y&lt;/code&gt; ，和解除引用它是未定义的行为，除非 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 点到同一分配对象。</target>
        </trans-unit>
        <trans-unit id="52dcba8fc55d983793d49be111c09fcb50eb3b76" translate="yes" xml:space="preserve">
          <source>The resulting pointer will have provenance of &lt;code&gt;val&lt;/code&gt;, i.e., for a fat pointer, this operation is semantically the same as creating a new fat pointer with the data pointer value of &lt;code&gt;val&lt;/code&gt; but the metadata of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277fa9ca5234a7d85c4310d360b586b5679536d7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;!&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;!&lt;/code&gt; 之后的结果类型 操作员。</target>
        </trans-unit>
        <trans-unit id="e0fff7e85f4e0422c5e3edd89994815fd0fa33fe" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;%&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="bb2df529c05fcb3e3ae1db4ab5bf5c9f054fbf92" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="36522abccd158f4a83c30f6cbe7b1f733a467a76" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="1fe31e03010cc02b7a70dec74838acc1bf92f653" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 操作符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="49f0b7e4d4d9571dc029b144b407d2d00db70bde" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;*&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;*&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="5440b4202f92f92a6ad5f44ab02bb1836dc990f2" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;+&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="4a8bf360ec637ebc225332beb0f574739bca97a7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;-&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;-&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="541f705e1fd40afef0d79bd7f0f4268fa7398a27" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;/&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;/&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="5fff5e225b75cdf382af9bb7542d50be9c4363ed" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;^&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;^&lt;/code&gt; 运算符后的结果类型。</target>
        </trans-unit>
        <trans-unit id="fee8ba95ad793c2c7dda2e8911dcb02800ab8ed4" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;|&lt;/code&gt; operator.</source>
          <target state="translated">应用 &lt;code&gt;|&lt;/code&gt; 后的结果类型 操作员。</target>
        </trans-unit>
        <trans-unit id="0473503cf115b2a975e15da3f35244db7bce3d66" translate="yes" xml:space="preserve">
          <source>The resulting type after concatenation</source>
          <target state="translated">连接后的类型</target>
        </trans-unit>
        <trans-unit id="dbf5bd29abfe066aae072317675dfaca543c15fe" translate="yes" xml:space="preserve">
          <source>The resulting type after dereferencing.</source>
          <target state="translated">解除引用后的结果类型。</target>
        </trans-unit>
        <trans-unit id="76a4c8bb9eba17c026c554fa00db407a4ed92a09" translate="yes" xml:space="preserve">
          <source>The resulting type after obtaining ownership.</source>
          <target state="translated">获得所有权后产生的类型。</target>
        </trans-unit>
        <trans-unit id="04c53e531d342d2fc7cb2f6812bb0980d9b695cc" translate="yes" xml:space="preserve">
          <source>The resulting vector can be converted back into a box via &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;'s &lt;code&gt;into_boxed_slice&lt;/code&gt; method.</source>
          <target state="translated">可以通过 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的 &lt;code&gt;into_boxed_slice&lt;/code&gt; 方法将生成的向量转换回盒子。</target>
        </trans-unit>
        <trans-unit id="c631dfaa5b94e5b7afa0d3baba880ecf32c3c788" translate="yes" xml:space="preserve">
          <source>The return type in the desugaring is assumed to capture all lifetime parameters from the &lt;code&gt;async fn&lt;/code&gt; declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3c91f66fb428df18fd8a3b968cf270fb22e4f6" translate="yes" xml:space="preserve">
          <source>The return type isn&amp;rsquo;t &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">返回类型不是 &lt;code&gt;Self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87f17fcd6dd95b0936e246de85107f7f76aa4067" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt;&lt;code&gt;str::escape_debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt; &lt;code&gt;str::escape_debug&lt;/code&gt; &lt;/a&gt;的返回类型。</target>
        </trans-unit>
        <trans-unit id="db39743b7e18afb4b0cbc402d05c64c31d6c2284" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt;&lt;code&gt;str::escape_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt; &lt;code&gt;str::escape_default&lt;/code&gt; &lt;/a&gt;的返回类型。</target>
        </trans-unit>
        <trans-unit id="0d7f1d5c28f55e7c46b28c80bf7c947a04177ba0" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt;&lt;code&gt;str::escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt; &lt;code&gt;str::escape_unicode&lt;/code&gt; &lt;/a&gt;的返回类型。</target>
        </trans-unit>
        <trans-unit id="46984a9d3d93237d6af0b4171b9091187f1fd40f" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;read_input()&lt;/code&gt;, &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt;&lt;/a&gt;, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">的返回类型 &lt;code&gt;read_input()&lt;/code&gt; ，&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt; &lt;/a&gt;，是它没有一个&amp;ldquo;真实&amp;rdquo;的返回值，但又希望，如果他们碰巧返回错误的函数的很常见的类型。在这种情况下，此函数的唯一目的是读取并打印该行，因此我们使用 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc8688a274902ed01a0ecc5033bf35069d5bb391" translate="yes" xml:space="preserve">
          <source>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">返回值是指示是否写入了新值并包含先前值的结果。成功时，保证该值等于 &lt;code&gt;current&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b1ea39b856b2d5fee30e6b97044d7752b536c14" translate="yes" xml:space="preserve">
          <source>The return value is always the previous value. If it is equal to &lt;code&gt;current&lt;/code&gt;, then the value was updated.</source>
          <target state="translated">返回值始终是先前的值。如果等于 &lt;code&gt;current&lt;/code&gt; ，那么值已更新。</target>
        </trans-unit>
        <trans-unit id="fc0a38af017feefeb9d3ecc2b64620f7588f7e32" translate="yes" xml:space="preserve">
          <source>The return value may change depending on the compiler version and unsafe code may not rely on the result of this function for soundness. It is suggested to only use this function for performance optimizations where spurious &lt;code&gt;false&lt;/code&gt; return values by this function do not affect the outcome, but just the performance. The consequences of using this method to make runtime and compile-time code behave differently have not been explored. This method should not be used to introduce such differences, and it should also not be stabilized before we have a better understanding of this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bec0cf03017a322224afce0dc723c8da3b1c3f8" translate="yes" xml:space="preserve">
          <source>The return value of this function has no meaning if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">如果 &lt;code&gt;align&lt;/code&gt; 不是2的幂，则此函数的返回值没有意义。</target>
        </trans-unit>
        <trans-unit id="60b397a9e27c756600834e9e8bc999da0f2e38e6" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9e4888166c03a2354c980d922cf25c13eb44d0" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">返回的64位值等效于&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt;结构，该结构表示自1601年1月1日（UTC）起100纳秒间隔的数量。该结构会自动转换为 &lt;code&gt;u64&lt;/code&gt; 值，因为这是使用它的推荐方法。</target>
        </trans-unit>
        <trans-unit id="f17e579c0925b04170923132b19bbc2e328718e7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is safe to pass to &lt;a href=&quot;../primitive.slice#method.get_unchecked&quot;&gt;&lt;code&gt;slice::get_unchecked&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.slice#method.get_unchecked_mut&quot;&gt;&lt;code&gt;slice::get_unchecked_mut&lt;/code&gt;&lt;/a&gt; for slices of the given length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9caf07f01ab2822f3d6ed99758b9360c5c26af" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">返回的&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;是对该对象引用的同一套接字的引用。两个句柄均可用于接受传入连接，并且在一个侦听器上设置的选项将影响另一个。</target>
        </trans-unit>
        <trans-unit id="ded74a0ee30df2ab90178bc7d8c79f6560c92452" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed without the condition being met.</source>
          <target state="translated">返回的&lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt;值指示是否已知超时没有满足条件。</target>
        </trans-unit>
        <trans-unit id="38736111afdf682fcdb07c273e755038e1599f59" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed.</source>
          <target state="translated">返回的&lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt;值指示是否已知超时。</target>
        </trans-unit>
        <trans-unit id="a4d3afc22fc51194d42ebf97c4d4c71d6cf8d193" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Read&lt;/code&gt; instance will first read all bytes from this object until EOF is encountered. Afterwards the output is equivalent to the output of &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">返回的 &lt;code&gt;Read&lt;/code&gt; 实例将首先从该对象读取所有字节，直到遇到EOF。之后的输出等于 &lt;code&gt;next&lt;/code&gt; 的输出。</target>
        </trans-unit>
        <trans-unit id="c46cae45e911aa3ffb2e82c2b8df4d3f09691f8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TcpStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">返回的 &lt;code&gt;TcpStream&lt;/code&gt; 是对该对象引用的同一流的引用。两个句柄将读取和写入相同的数据流，并且在一个流上设置的选项将传播到另一流。</target>
        </trans-unit>
        <trans-unit id="f1bab9e66e16ee3bc6f8eaaaaca9a4320b7da4d4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UdpSocket&lt;/code&gt; is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other.</source>
          <target state="translated">返回的 &lt;code&gt;UdpSocket&lt;/code&gt; 是对该对象引用的同一套接字的引用。两个句柄将读取和写入相同的端口，并且在一个套接字上设置的选项将传播到另一个套接字。</target>
        </trans-unit>
        <trans-unit id="c1a563924be47f2135363b13913bddb8d81845c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixDatagram&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one side will affect the other.</source>
          <target state="translated">返回的 &lt;code&gt;UnixDatagram&lt;/code&gt; 是对该对象引用的同一套接字的引用。两个句柄均可用于接受传入的连接，并且一侧设置的选项会影响另一侧。</target>
        </trans-unit>
        <trans-unit id="3a69722b38c150ace8c17a0ad6c7500758c624a4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixListener&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">返回的 &lt;code&gt;UnixListener&lt;/code&gt; 是对该对象引用的同一套接字的引用。两个句柄均可用于接受传入连接，并且在一个侦听器上设置的选项将影响另一个。</target>
        </trans-unit>
        <trans-unit id="144b7ef360f6249426bb7be199321625b6985707" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">返回的 &lt;code&gt;UnixStream&lt;/code&gt; 是对该对象引用的同一流的引用。两个句柄将读取和写入相同的数据流，并且在一个流上设置的选项将传播到另一流。</target>
        </trans-unit>
        <trans-unit id="cb880b11df63d1e3077076bea22bb8b51ec8054d" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;AllocRef&lt;/code&gt; and will simply borrow this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3560a746a4c0e2ffb1141c7abaa941ae137d7b4" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Read&lt;/code&gt; and will simply borrow this current reader.</source>
          <target state="translated">返回的适配器还实现了 &lt;code&gt;Read&lt;/code&gt; 并将仅借用此当前的Reader。</target>
        </trans-unit>
        <trans-unit id="facac298df7b4792f8b8fe4cbcbc0a4967c70852" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Write&lt;/code&gt; and will simply borrow this current writer.</source>
          <target state="translated">返回的适配器还实现了 &lt;code&gt;Write&lt;/code&gt; ，并将仅借用此当前的writer。</target>
        </trans-unit>
        <trans-unit id="e389b4884c363b3fc760ebd7d93cdcb95de946c0" translate="yes" xml:space="preserve">
          <source>The returned block is suitable for passing to the &lt;code&gt;alloc&lt;/code&gt;/&lt;code&gt;realloc&lt;/code&gt; methods of this allocator.</source>
          <target state="translated">返回的块适合传递给此分配器的 &lt;code&gt;alloc&lt;/code&gt; / &lt;code&gt;realloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c91d87a8c74843f84b212121082c194e485a54b8" translate="yes" xml:space="preserve">
          <source>The returned block may have a larger size than specified by &lt;code&gt;layout.size()&lt;/code&gt;, and may or may not have its contents initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d367aab1faeec6de58c9c9955a240781bdbe40" translate="yes" xml:space="preserve">
          <source>The returned block of storage may or may not have its contents initialized. (Extension subtraits might restrict this behavior, e.g., to ensure initialization to particular sets of bit patterns.)</source>
          <target state="translated">返回的存储块可能有也可能没有初始化其内容。(扩展子集可能会限制这种行为,例如,为了确保初始化到特定的比特模式集。)</target>
        </trans-unit>
        <trans-unit id="ba2ebcfc4f605284f02edd68881e9753988594f5" translate="yes" xml:space="preserve">
          <source>The returned boolean is &lt;code&gt;false&lt;/code&gt; only if the timeout is known to have elapsed.</source>
          <target state="translated">仅当已知超时已过去时，返回的布尔值才为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef190a0092cd801a89bd32ca6438155668c7c711" translate="yes" xml:space="preserve">
          <source>The returned buffer does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.</source>
          <target state="translated">返回的缓冲区并&lt;strong&gt;没有&lt;/strong&gt;包含尾随NUL终止，并且可以保证它不会有任何内部NUL字节。</target>
        </trans-unit>
        <trans-unit id="c21f9df3ca074ffdfcc498df18bd9b3644edeb21" translate="yes" xml:space="preserve">
          <source>The returned iterator contains a snapshot of the process's environment variables at the time of this invocation. Modifications to environment variables afterwards will not be reflected in the returned iterator.</source>
          <target state="translated">返回的迭代器包含了这次调用时进程的环境变量的快照。之后对环境变量的修改不会反映在返回的迭代器中。</target>
        </trans-unit>
        <trans-unit id="94742684e4e1a0a940d70b49afd50e4db443fbed" translate="yes" xml:space="preserve">
          <source>The returned iterator may not actually yield any values depending on the outcome of any resolution performed.</source>
          <target state="translated">返回的迭代器实际上可能不会产生任何值,这取决于任何执行的解析结果。</target>
        </trans-unit>
        <trans-unit id="2aad97e80249c67281fd50b9abdb7bf4c0bc39de" translate="yes" xml:space="preserve">
          <source>The returned iterator might panic if the to-be-returned index would overflow a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要返回的索引会使&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;溢出，则返回的迭代器可能会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="3f6e0a2276ef2ac22ba60fa606f31e8d0538ab17" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212e83558d8f38fe873f76d6ab8c409b36c6c1ca" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">返回的迭代器要求该模式支持反向搜索，如果正向/反向搜索产生相同的元素，则它将为&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a192fbaedef699058263c6cf3d017b9555c1581" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</source>
          <target state="translated">返回的迭代器要求模式支持逆向搜索,如果正向/逆向搜索得到的元素相同,则会被双结束。</target>
        </trans-unit>
        <trans-unit id="31cf06022e130c2b8e694b6f17ab8cbe9626501c" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4543e6c97747a65b55c800608ca5f7c928ee84b5" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">如果模式允许反向搜索并且正向/反向搜索产生相同的元素，则返回的迭代器将为&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。这对于例如&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是正确的，但对于 &lt;code&gt;&amp;amp;str&lt;/code&gt; 则不是。</target>
        </trans-unit>
        <trans-unit id="fcd14ee368ff1244ad97f001dc72e74042b0095f" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">如果模式允许反向搜索并且正向/反向搜索产生相同的元素，则返回的迭代器将为&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。这对于例如&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是正确的，但对于 &lt;code&gt;&amp;amp;str&lt;/code&gt; 则不是。</target>
        </trans-unit>
        <trans-unit id="fb1179f626056fe35d781c0e7e7072fe8a2697c8" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e7ec844babb660dc32f9f713ab552f258e8f9a" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">返回的迭代器将永远不会返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，也不会产生对等方的&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;结构。对其进行迭代等效于在循环中调用&lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40daaaf435dcc6bfd52a2f60c0016a88fb0c4d52" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;TcpListener::accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cacc276ab85a92453bcb875fe7d5c79fd6233ed" translate="yes" xml:space="preserve">
          <source>The returned iterator will not be double ended, because it is not efficient to support.</source>
          <target state="translated">返回的迭代器不会是双结尾的,因为支持双结尾是没有效率的。</target>
        </trans-unit>
        <trans-unit id="6626efd84bc65ae6d8cabe4bc5b2e309e23cd9ee" translate="yes" xml:space="preserve">
          <source>The returned iterator will panic during iteration if any argument to the process is not valid unicode. If this is not desired, use the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;args_os&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">如果该进程的任何参数不是有效的unicode，则返回的迭代器将在迭代过程中发生混乱。如果不希望这样做，请改用&lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;args_os&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="48642a85c9b9785eaffc2d69f306f5a44a684795" translate="yes" xml:space="preserve">
          <source>The returned iterator yields only the &lt;code&gt;value&lt;/code&gt;s for which the supplied closure returns &lt;code&gt;Some(value)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4abf6a88076e830a1096ad48a0fcbdcd010f5d" translate="yes" xml:space="preserve">
          <source>The returned lifetime is not guaranteed to be the actual lifetime of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">返回的生命周期不能保证是 &lt;code&gt;ptr&lt;/code&gt; 的实际生命周期。</target>
        </trans-unit>
        <trans-unit id="dd646ddea405b753233bb6eb50b8340613c5b51f" translate="yes" xml:space="preserve">
          <source>The returned listener is ready for accepting connections.</source>
          <target state="translated">返回的监听器已经准备好接受连接。</target>
        </trans-unit>
        <trans-unit id="32a2e5d176a9d291f17213749b86ae928f9a79fd" translate="yes" xml:space="preserve">
          <source>The returned name refers to a source path on the compiling system, but it isn't valid to represent this directly as a &lt;code&gt;&amp;amp;Path&lt;/code&gt;. The compiled code may run on a different system with a different &lt;code&gt;Path&lt;/code&gt; implementation than the system providing the contents and this library does not currently have a different &quot;host path&quot; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3776d88d1ca8845ec6b1038a3cef52ddd6c1ee" translate="yes" xml:space="preserve">
          <source>The returned object can be used for error recovery, such as re-inspecting the buffer.</source>
          <target state="translated">返回的对象可用于错误恢复,如重新检查缓冲区。</target>
        </trans-unit>
        <trans-unit id="d094ca8efdcd1c477cd38db568c96ab96a8083f1" translate="yes" xml:space="preserve">
          <source>The returned pointer is read-only; writing to it (including passing it to C code that writes to it) causes undefined behavior.</source>
          <target state="translated">返回的指针是只读的;对它进行写入(包括传递给写入它的C代码)会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="9b9b68320305244b712b6eba3fb78b4a32d8f345" translate="yes" xml:space="preserve">
          <source>The returned pointer will be valid for as long as &lt;code&gt;self&lt;/code&gt; is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.</source>
          <target state="translated">返回的指针将一直有效，直到 &lt;code&gt;self&lt;/code&gt; 为止，并指向以0字节结尾的连续区域，以表示字符串的结尾。</target>
        </trans-unit>
        <trans-unit id="d1d3044eae78ae415d38e3ebb8ef901b44a28df4" translate="yes" xml:space="preserve">
          <source>The returned range is half-open, which means that the end pointer points &lt;em&gt;one past&lt;/em&gt; the last element of the slice. This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c27af8743c2ff7ed690feb622313cb681b2d0e2" translate="yes" xml:space="preserve">
          <source>The returned slice can be used to fill the vector with data (e.g. by reading from a file) before marking the data as initialized using the &lt;a href=&quot;struct.vec#method.set_len&quot;&gt;&lt;code&gt;set_len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0c4a80af7569dc2827892f37e1cf7abb925f27" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">返回片并&lt;strong&gt;没有&lt;/strong&gt;包含尾随NUL终止，并且可以保证它不会有任何内部NUL字节。如果需要nul终止符，请改用&lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a368474e9b2e8c2f52646dd2d7918f986464f59" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c2a4410e35e072d95d91733db13ddd5bf58ad1" translate="yes" xml:space="preserve">
          <source>The returned slice will &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator that this C string has.</source>
          <target state="translated">返回的片将&lt;strong&gt;不&lt;/strong&gt;包含此C字符串具有的尾随nul终止符。</target>
        </trans-unit>
        <trans-unit id="a46b9c2f552385dbbfeb1cece6cdbcca5271f43e" translate="yes" xml:space="preserve">
          <source>The returned string must not be considered to be a unique identifier of a type as multiple types may map to the same type name. Similarly, there is no guarantee that all parts of a type will appear in the returned string: for example, lifetime specifiers are currently not included. In addition, the output may change between versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6695d62fb3138a05ebea6941a15916ea38fd70" translate="yes" xml:space="preserve">
          <source>The returned type after indexing.</source>
          <target state="translated">索引后返回的类型。</target>
        </trans-unit>
        <trans-unit id="323e9e5f7457b4d404421a53102d137f9784ffb2" translate="yes" xml:space="preserve">
          <source>The returned type after the call operator is used.</source>
          <target state="translated">使用调用操作符后返回的类型。</target>
        </trans-unit>
        <trans-unit id="2d5978ed3eb5e45dd0ed7362549dedf897ab386a" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">返回的类型实现&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;Item&lt;/code&gt; 为&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 。如果成功读取了一个字节，则产生的项目为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; ,&lt;/a&gt;否则为&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。EOF映射为从此迭代器返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94490bb5f034be81aa72ad51da07b198637a8c28" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b4fa361f895a3f7a940a0df4cc75d5065e98e6" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;atime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastAccessTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">返回的值对应于Unix平台上的 &lt;code&gt;stat&lt;/code&gt; 的 &lt;code&gt;atime&lt;/code&gt; 字段和Windows平台上的 &lt;code&gt;ftLastAccessTime&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ab7615b505b03838f921f8936a1701e974958831" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">返回的值对应于 &lt;code&gt;birthtime&lt;/code&gt; 的领域 &lt;code&gt;stat&lt;/code&gt; 在Unix平台和 &lt;code&gt;ftCreationTime&lt;/code&gt; 在Windows平台领域。</target>
        </trans-unit>
        <trans-unit id="2eef349b822dea9863943a97049788d8df72cce1" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;btime&lt;/code&gt; field of &lt;code&gt;statx&lt;/code&gt; on Linux kernel starting from to 4.11, the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on other Unix platforms, and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5896159de75927b2d1b622cfd587f254e9fed43" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;mtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastWriteTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">返回的值对应于Unix平台上 &lt;code&gt;stat&lt;/code&gt; 的 &lt;code&gt;mtime&lt;/code&gt; 字段和Windows平台上的 &lt;code&gt;ftLastWriteTime&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="a0ea9c14c32dc6d6e0d323b13279abc6935b1d15" translate="yes" xml:space="preserve">
          <source>The returned value does include the fractional (nanosecond) part of the duration.</source>
          <target state="translated">返回的值确实包括持续时间的分数(纳秒)部分。</target>
        </trans-unit>
        <trans-unit id="ff15d0950ff1afde3f0762acc64a9f002a6a04c1" translate="yes" xml:space="preserve">
          <source>The returned value does not have meaning for directories.</source>
          <target state="translated">返回的值对目录没有意义。</target>
        </trans-unit>
        <trans-unit id="e8c08d63d79b2a138a0f12bb7a91ea3ec23dcec7" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的值不包括持续时间的小数（纳秒）部分，可以使用&lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt;获得。</target>
        </trans-unit>
        <trans-unit id="1bfa4d7247e116de4261b1e09435dc9dcadacc45" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5135e5751b93b5d235f37608301c3018208e63" translate="yes" xml:space="preserve">
          <source>The returned value is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d2d5505f46c3741e892512e8371427a53745d7" translate="yes" xml:space="preserve">
          <source>The right shift assignment operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">右移赋值运算符 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e00fa6358174afd137529285f589695abe7555ab" translate="yes" xml:space="preserve">
          <source>The right shift operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; and &lt;code&gt;a.shr(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">右移运算符 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 。请注意，由于此特征是针对具有多个右侧类型的所有整数类型实现的，因此Rust的类型检查器对 &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt; 特殊处理，将整数运算的结果类型设置为左侧操作数的类型。这意味着尽管 &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 和 &lt;code&gt;a.shr(b)&lt;/code&gt; 从求值的角度来看是相同的，但是在类型推断方面它们是不同的。</target>
        </trans-unit>
        <trans-unit id="4bed85e5cf48df182fbdc5f50e1999ffc9d50cbb" translate="yes" xml:space="preserve">
          <source>The right way to suppress the warning is to actually write error handling, but because you just want to crash this program when a problem occurs, you can use &lt;code&gt;expect&lt;/code&gt;. You&amp;rsquo;ll learn about recovering from errors in Chapter 9.</source>
          <target state="translated">抑制警告的正确方法是实际编写错误处理程序，但是由于您只想在发生问题时使该程序崩溃，因此可以使用 &lt;code&gt;expect&lt;/code&gt; 。您将在第9章中学习如何从错误中恢复。</target>
        </trans-unit>
        <trans-unit id="93b14b29a7aed966fc23a390a9832d3b882cc69b" translate="yes" xml:space="preserve">
          <source>The root directory component, appears after any prefix and before anything else.</source>
          <target state="translated">根目录组件,出现在任何前缀之后,其他任何东西之前。</target>
        </trans-unit>
        <trans-unit id="a168d72d668df499616b725b5ca80c1ff007a04a" translate="yes" xml:space="preserve">
          <source>The rules for &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; match those for normal struct types, while &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; behave as if &lt;a href=&quot;../attributes/derive&quot;&gt;derived&lt;/a&gt;. For &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, the order of cloning of the captured variables is left unspecified.</source>
          <target state="translated">&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;的规则与普通结构类型的规则匹配，而&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;行为就像&lt;a href=&quot;../attributes/derive&quot;&gt;派生的那样&lt;/a&gt;。对于&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，捕获变量的克隆顺序未指定。</target>
        </trans-unit>
        <trans-unit id="3563595879dbbd21c6c2906f7bd54a9b3679529d" translate="yes" xml:space="preserve">
          <source>The rust compiler cannot link to an external library if you don't give it its name. Example:</source>
          <target state="translated">如果你不给外部库命名,rust编译器就不能链接到它。例如</target>
        </trans-unit>
        <trans-unit id="54065002f88e1cb544dc442e2b3686e62225bf94" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">rust 编译器为每个目标维护一个在该目标上不支持的 ABI 的黑名单,如果一个 ABI 出现在这样的列表中,通常意味着该目标/ABI 组合目前不被 llvm 支持。如果一个 ABI 出现在这样的列表中,这通常意味着目标/ABI 组合目前不被 llvm 支持。</target>
        </trans-unit>
        <trans-unit id="e602506551cf00543c3919704a07e8c114c13f33" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a list of unsupported ABIs on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dcfff8659995d9c806c4ff5bfe72343be6d124" translate="yes" xml:space="preserve">
          <source>The rustfix tool is included with Rust installations and can automatically fix some compiler warnings. If you&amp;rsquo;ve written code in Rust, you&amp;rsquo;ve probably seen compiler warnings. For example, consider this code:</source>
          <target state="translated">rustfix工具包含在Rust安装中，可以自动修复一些编译器警告。如果您是用Rust编写代码的，则可能会看到编译器警告。例如，考虑以下代码：</target>
        </trans-unit>
        <trans-unit id="d95e676c8653714db7acc846f5781f129f187994" translate="yes" xml:space="preserve">
          <source>The safety and conciseness of &lt;code&gt;for&lt;/code&gt; loops make them the most commonly used loop construct in Rust. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a &lt;code&gt;while&lt;/code&gt; loop in Listing 3-3, most Rustaceans would use a &lt;code&gt;for&lt;/code&gt; loop. The way to do that would be to use a &lt;code&gt;Range&lt;/code&gt;, which is a type provided by the standard library that generates all numbers in sequence starting from one number and ending before another number.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 循环的安全性和简洁性使其成为Rust中最常用的循环构造。即使在您想要运行某些代码一定次数的情况下（例如清单3-3 中使用 &lt;code&gt;while&lt;/code&gt; 循环的倒计时示例），大多数Rustaceans也会使用 &lt;code&gt;for&lt;/code&gt; 循环。做到这一点的方法是使用 &lt;code&gt;Range&lt;/code&gt; ，它是标准库提供的一种类型，它按顺序生成所有数字，从一个数字开始到另一个数字之前结束。</target>
        </trans-unit>
        <trans-unit id="34c5f02c44747e09b58d1ec500165079e9867619" translate="yes" xml:space="preserve">
          <source>The same applies to transmutes to &lt;code&gt;*mut fn()&lt;/code&gt;, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just &lt;code&gt;fn()&lt;/code&gt; alone suffices for that. &lt;code&gt;*mut fn()&lt;/code&gt; is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</source>
          <target state="translated">在实践中观察到的 &lt;code&gt;*mut fn()&lt;/code&gt; 的变形也是如此。注意，尽管这种类型的使用通常是不正确的。目的通常是描述一个函数指针，但是仅使用 &lt;code&gt;fn()&lt;/code&gt; 就可以满足要求。 &lt;code&gt;*mut fn()&lt;/code&gt; 是指向fn指针的指针。（由于这些值通常只是传递给C代码，因此，在实践中几乎没有什么不同。）</target>
        </trans-unit>
        <trans-unit id="a7f4b342720ddcec9a49dfb2ca6daf016843320d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c676ce454b9f3ef8b4d42559af1943bf2b7913d9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7e4f0db03c726bc5bd7452fa0f56591b66e33d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf7a6ad9f8fb40e4ba7caca628efe6809216b4f" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ae9b3d116905ba91635f77fa80dd3badbdd424" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f595892b4fea20450f05cddbe7763f0e003caa0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b129096713d6e93f0f6771f5a02e553c2efcf3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902a2b25118315948a58ef98f0d17bd457899153" translate="yes" xml:space="preserve">
          <source>The same goes for doc comments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8159833047b3772ef09e1ff09bc6721b1345cc" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc57fcef5c1050ba1f9373a34844306a6911e2e" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_raw&quot;&gt;&lt;code&gt;as_raw&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">与&lt;a href=&quot;struct.weak#method.as_raw&quot;&gt; &lt;code&gt;as_raw&lt;/code&gt; &lt;/a&gt;一样，访问指针目标的限制也适用。</target>
        </trans-unit>
        <trans-unit id="e53c2cdb1077121198b1a8746e267d3b3a805b0e" translate="yes" xml:space="preserve">
          <source>The scope in which the variable &lt;code&gt;s&lt;/code&gt; is valid is the same as any function parameter&amp;rsquo;s scope, but we don&amp;rsquo;t drop what the reference points to when it goes out of scope because we don&amp;rsquo;t have ownership. When functions have references as parameters instead of the actual values, we won&amp;rsquo;t need to return the values in order to give back ownership, because we never had ownership.</source>
          <target state="translated">变量 &lt;code&gt;s&lt;/code&gt; 有效的作用域与任何函数参数的作用域相同，但是当它超出作用域时，由于没有所有权，我们不会删除引用指向的内容。当函数将引用作为参数而不是实际值作为参数时，我们将不需要返回这些值以归还所有权，因为我们从未拥有过所有权。</target>
        </trans-unit>
        <trans-unit id="2c0f9db762db77543e23786689d772ed7e180cf6" translate="yes" xml:space="preserve">
          <source>The scopes of the immutable references &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; end after the &lt;code&gt;println!&lt;/code&gt; where they are last used, which is before the mutable reference &lt;code&gt;r3&lt;/code&gt; is created. These scopes don&amp;rsquo;t overlap, so this code is allowed.</source>
          <target state="translated">不变引用 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 的作用域在 &lt;code&gt;println!&lt;/code&gt; 之后结束。在创建可变引用 &lt;code&gt;r3&lt;/code&gt; 之前，在最后一次使用它们的位置。这些范围不重叠，因此允许使用此代码。</target>
        </trans-unit>
        <trans-unit id="547c47e37f57601f738482d42256219a9633dd7e" translate="yes" xml:space="preserve">
          <source>The search path to be used may be controlled by setting the &lt;code&gt;PATH&lt;/code&gt; environment variable on the Command, but this has some implementation limitations on Windows (see issue #37519).</source>
          <target state="translated">可以通过在Command上设置 &lt;code&gt;PATH&lt;/code&gt; 环境变量来控制要使用的搜索路径，但这在Windows上具有一些实现限制（请参见问题＃37519）。</target>
        </trans-unit>
        <trans-unit id="3a555019f8dcc01c39b7fc4a4df1fa78e901c698" translate="yes" xml:space="preserve">
          <source>The second case example is a bit particular: the main function must always have this definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a1a4dab2732977e1598d466f79a0132530331a" translate="yes" xml:space="preserve">
          <source>The second form of macros is &lt;em&gt;procedural macros&lt;/em&gt;, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</source>
          <target state="translated">宏的第二种形式是&lt;em&gt;过程宏&lt;/em&gt;，它的作用类似于函数（并且是过程的一种）。程序宏接受某些代码作为输入，对该代码进行操作，并生成一些代码作为输出，而不是像声明式宏那样与模式匹配并将其替换为其他代码。</target>
        </trans-unit>
        <trans-unit id="014f5e70707fe70de5f920ceaf6bbf6f00b7acd7" translate="yes" xml:space="preserve">
          <source>The second half of the tuple that is returned is an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. A &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; here means that either there is no known upper bound, or the upper bound is larger than &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的元组的后半部分是&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 。这里的&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;表示没有已知上限，或者该上限大于&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4961749eb1f24345f8436cc7b35d0ebccb81384a" translate="yes" xml:space="preserve">
          <source>The second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of &lt;code&gt;tt ...&lt;/code&gt;'s, even as new syntactic forms are added to the language.</source>
          <target state="translated">第二个不变式说，一个分离的复数NT必须使用一个分隔符，它是NT内部内容的预定跟随集的一部分。这确保了合法的宏定义将继续将输入片段解析为 &lt;code&gt;tt ...&lt;/code&gt; 的相同定界序列，即使将新的语法形式添加到该语言中也是如此。</target>
        </trans-unit>
        <trans-unit id="3069a4f51af6a3b6633b4d681ece722a85d63fa2" translate="yes" xml:space="preserve">
          <source>The second is mutable references. They can be created from &lt;code&gt;mut&lt;/code&gt; variables and must be unique: no other variables can have a mutable reference, nor a shared reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2dca747a6f3fa79f2291ae843df5963e36bbc5" translate="yes" xml:space="preserve">
          <source>The second is that it is the offset in bytes between successive elements in an array with that item type.</source>
          <target state="translated">第二个是它是一个数组中该项目类型的连续元素之间的偏移量,单位是字节。</target>
        </trans-unit>
        <trans-unit id="a1e02e9dcee081f5b8c19c27d767e65c0ff37f76" translate="yes" xml:space="preserve">
          <source>The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section.</source>
          <target state="translated">第二种是普遍提高自己对语言的某一方面的知识。在这种情况下,只需浏览目录,直到你看到你想了解更多的东西,然后就开始阅读。如果一个链接看起来很有趣,就点击它,然后阅读有关该部分的内容。</target>
        </trans-unit>
        <trans-unit id="df5949936d6a2cd7eaf61fe27eb1fac54cf960fb" translate="yes" xml:space="preserve">
          <source>The second line that we added to the middle of the code prints the secret number. This is useful while we&amp;rsquo;re developing the program to be able to test it, but we&amp;rsquo;ll delete it from the final version. It&amp;rsquo;s not much of a game if the program prints the answer as soon as it starts!</source>
          <target state="translated">我们添加到代码中间的第二行将显示密码。在我们开发程序以对其进行测试时，这很有用，但是将从最终版本中删除它。如果程序一开始就打印答案，那将不是什么游戏！</target>
        </trans-unit>
        <trans-unit id="c1f82d829df68033c418a80c29f6453df31bb3f7" translate="yes" xml:space="preserve">
          <source>The second operand of a &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bb822113e197cd1e10145a43fbd748bc848a6a" translate="yes" xml:space="preserve">
          <source>The second problem with the current &lt;code&gt;Cacher&lt;/code&gt; implementation is that it only accepts closures that take one parameter of type &lt;code&gt;u32&lt;/code&gt; and return a &lt;code&gt;u32&lt;/code&gt;. We might want to cache the results of closures that take a string slice and return &lt;code&gt;usize&lt;/code&gt; values, for example. To fix this issue, try introducing more generic parameters to increase the flexibility of the &lt;code&gt;Cacher&lt;/code&gt; functionality.</source>
          <target state="translated">当前 &lt;code&gt;Cacher&lt;/code&gt; 实现的第二个问题是它只接受采用 &lt;code&gt;u32&lt;/code&gt; 类型的一个参数并返回 &lt;code&gt;u32&lt;/code&gt; 的闭包。例如，我们可能想要缓存采用字符串切片并返回 &lt;code&gt;usize&lt;/code&gt; 值的闭包结果。要解决此问题，请尝试引入更多通用参数以增加 &lt;code&gt;Cacher&lt;/code&gt; 功能的灵活性。</target>
        </trans-unit>
        <trans-unit id="92462e612674a20cc7e3c63f701740ce5bea5c75" translate="yes" xml:space="preserve">
          <source>The second rule applies because there is exactly one input lifetime. The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</source>
          <target state="translated">第二条规则适用,因为正好有一个输入寿命。第二条规则规定,一个输入参数的寿命被分配给输出寿命,所以现在的签名是这样的。</target>
        </trans-unit>
        <trans-unit id="66815e0776a29457690bd505c60d2e19937fa654" translate="yes" xml:space="preserve">
          <source>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt;.</source>
          <target state="translated">第二条规则是，如果仅存在一个输入生存期参数，则将生存期分配给所有输出生存期参数： &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aedd96f8435bb44ce30001804fbe27f5473ed0ee" translate="yes" xml:space="preserve">
          <source>The second time we call &lt;code&gt;add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use a relative path. The path starts with &lt;code&gt;front_of_house&lt;/code&gt;, the name of the module defined at the same level of the module tree as &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Here the filesystem equivalent would be using the path &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt;. Starting with a name means that the path is relative.</source>
          <target state="translated">第二次在 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 时，我们使用相对路径。路径以 &lt;code&gt;front_of_house&lt;/code&gt; 开始，front_of_house是在模块树的同一级别与eat_at_restaurant定义的模块 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。在这里，等效文件系统将使用路径 &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt; 。以名称开头表示路径是相对的。</target>
        </trans-unit>
        <trans-unit id="6719785aa3871b4c2a2d425aeb686279358fe018" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; customizes &lt;code&gt;Drop&lt;/code&gt; to deallocate the space on the heap that the box points to.</source>
          <target state="translated">智能指针模式的第二个重要特征是 &lt;code&gt;Drop&lt;/code&gt; ，它使您可以自定义值将超出范围时发生的情况。您可以提供任何类型的 &lt;code&gt;Drop&lt;/code&gt; 特性的实现，并且您指定的代码可用于释放资源，例如文件或网络连接。我们在智能指针的上下文中引入 &lt;code&gt;Drop&lt;/code&gt; ，因为在实现智能指针时几乎总是使用 &lt;code&gt;Drop&lt;/code&gt; 特性的功能。例如， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 自定义 &lt;code&gt;Drop&lt;/code&gt; 来取消分配Box指向的堆上的空间。</target>
        </trans-unit>
        <trans-unit id="445effcb8001016422ef7635d91738ff3683b61e" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, when a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is dropped it will deallocate the space on the heap that the box points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9253951b95bdbecdb3d6ee784fab1524db5c9af" translate="yes" xml:space="preserve">
          <source>The second type of operation that requires an unsafe block is calls to unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra &lt;code&gt;unsafe&lt;/code&gt; before the rest of the definition. The &lt;code&gt;unsafe&lt;/code&gt; keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can&amp;rsquo;t guarantee we&amp;rsquo;ve met these requirements. By calling an unsafe function within an &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;re saying that we&amp;rsquo;ve read this function&amp;rsquo;s documentation and take responsibility for upholding the function&amp;rsquo;s contracts.</source>
          <target state="translated">需要不安全块的第二种操作类型是对不安全功能的调用。不安全的函数和方法看起来与常规函数和方法完全一样，但是在定义其余部分之前，它们还有一个额外的 &lt;code&gt;unsafe&lt;/code&gt; 之处。在 &lt;code&gt;unsafe&lt;/code&gt; 在这方面的关键字表示该功能具有我们需要的时候，我们调用这个函数来维护要求，因为铁锈能不能保证我们已经满足了这些要求。通过在 &lt;code&gt;unsafe&lt;/code&gt; 块中调用不安全的函数，我们是说已经阅读了该函数的文档，并负责维护该函数的合同。</target>
        </trans-unit>
        <trans-unit id="3b5790cbd3c99b8bfcd34f57b9dbfe5e2b8bc741" translate="yes" xml:space="preserve">
          <source>The second-to-last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599ddbb55a436b4b2320e8d917bb378c0d788288" translate="yes" xml:space="preserve">
          <source>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</source>
          <target state="translated">向函数传递值的语义与向变量赋值的语义相似。向函数传递变量会像赋值一样,移动或复制变量。清单4-3中有一个例子,其中有一些注释显示了变量进入和退出作用域的位置。</target>
        </trans-unit>
        <trans-unit id="0ebf78e0ec598941096cd9f3613dea835a20177d" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">该函数的语义等同于&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; ,&lt;/a&gt;不同之处在于线程被阻塞的时间大约不超过 &lt;code&gt;dur&lt;/code&gt; 。由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确 &lt;code&gt;dur&lt;/code&gt; 因此该方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="9f8ab2e3b0b43343b07ba616db0d9b83ddc1ec9a" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">此函数的语义等同于&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;只是线程将被阻塞的时间大约不超过 &lt;code&gt;ms&lt;/code&gt; 毫秒。由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确为 &lt;code&gt;ms&lt;/code&gt; ,因此该方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="10369644dc806ec3584f4bc1cd00c1b37924dd8f" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">此函数的语义与&lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;/a&gt;等效，除了线程被阻塞的时间大致不超过 &lt;code&gt;dur&lt;/code&gt; 之外。由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确 &lt;code&gt;dur&lt;/code&gt; 因此该方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="599bdbbdba24d3dd39b2e820e78610be901175cf" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt; long.</source>
          <target state="translated">此函数的语义与&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;等效，除了线程被阻塞的时间不超过 &lt;code&gt;dur&lt;/code&gt; 之外。该方法不应当被用于精确的定时由于异常，如，可能不会导致最大的时间量等待为精确抢占或平台差异 &lt;code&gt;dur&lt;/code&gt; 长。</target>
        </trans-unit>
        <trans-unit id="9563714599dd3161cea050e5c59d88f3adc62446" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt; long.</source>
          <target state="translated">此函数的语义与&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;等效，除了线程被阻塞的时间不超过 &lt;code&gt;dur&lt;/code&gt; 之外。由于诸如抢占或平台差异之类的异常可能不会导致最长的等待时间恰好为 &lt;code&gt;ms&lt;/code&gt; 毫秒,因此该方法不应用于精确的计时。</target>
        </trans-unit>
        <trans-unit id="8ace657d10944a484e642331ec94fc1a6e6161be" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3371efd221cedf557721fc9ee15bda8759a39a9" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e595d1de9f2e3618f10b608ff234b6ad2944f66" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3d66bfcd3164df001d8c8d3ea53b374782f46" translate="yes" xml:space="preserve">
          <source>The semicolon &lt;code&gt;;&lt;/code&gt; can be used to discard the result of an expression at the end of a block, making the expression (and thus the block) evaluate to &lt;code&gt;()&lt;/code&gt;. For example,</source>
          <target state="translated">分号 &lt;code&gt;;&lt;/code&gt; 可以用于在一个块的末尾丢弃表达式的结果，使表达式（以及该块）的求值为 &lt;code&gt;()&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="bb5601bddd79e71c2b7b66e9a5ead92eff60bcdd" translate="yes" xml:space="preserve">
          <source>The send and receive operations on channels will all return a &lt;a href=&quot;../../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having &quot;hung up&quot; by being dropped in its corresponding thread.</source>
          <target state="translated">通道上的发送和接收操作都将返回&lt;a href=&quot;../../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;指示操作是否成功。不成功的操作通常表示通道的另一半已通过掉入其相应的线程而&amp;ldquo;挂起&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ea8d26ff0d36fb568a938927807eafbc1ae6f29d" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's asynchronous &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; type. This half can only be owned by one thread, but it can be cloned to send to other threads.</source>
          <target state="translated">Rust异步&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;类型的发送一半。这一半只能由一个线程拥有，但可以克隆以发送给其他线程。</target>
        </trans-unit>
        <trans-unit id="52ce535fefd9bc68502a1a5978b6409a82fd1bcb" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's synchronous &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Rust的同步&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;类型的发送一半。</target>
        </trans-unit>
        <trans-unit id="937e495e6de5b225295fc788a2b8a9723c5d12e3" translate="yes" xml:space="preserve">
          <source>The sequential nature of the tuple applies to its implementations of various traits. For example, in &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Ord&lt;/code&gt;, the elements are compared sequentially until the first non-equal set is found.</source>
          <target state="translated">元组的顺序性质适用于其各种特征的实现。例如，在 &lt;code&gt;PartialOrd&lt;/code&gt; 和 &lt;code&gt;Ord&lt;/code&gt; 中，将顺序比较元素，直到找到第一个不相等的集合。</target>
        </trans-unit>
        <trans-unit id="faf864ad82a0182728e07d76ebfb5f1fdf6dc8f4" translate="yes" xml:space="preserve">
          <source>The signed two's complement integer types consist of:</source>
          <target state="translated">有符号的二的补码整数类型包括。</target>
        </trans-unit>
        <trans-unit id="0a593fcbffb90fbe9434a8bd0cd231a38381ce34" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the &amp;ldquo;Hello, world!&amp;rdquo; project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dca1ad1ce59bbb51cae453b849e2d3bd139c7cf" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the Hello, world! project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">像我们到目前为止编写的那样，最简单的Rust程序没有任何依赖关系。因此，如果我们建立了Hello，世界！在Cargo项目中，它将仅使用Cargo处理代码的部分。在编写更复杂的Rust程序时，您将添加依赖项，并且如果使用Cargo启动项目，则添加依赖项将更加容易。</target>
        </trans-unit>
        <trans-unit id="cc9fb663ff26b10b3b0480942ea72891d7b9e8a8" translate="yes" xml:space="preserve">
          <source>The single-address property of statics is required.</source>
          <target state="translated">静态的单地址属性是必须的。</target>
        </trans-unit>
        <trans-unit id="019cb91a15aad53bc6628eee08e1df33b769b170" translate="yes" xml:space="preserve">
          <source>The size and offset of fields is determined by the following algorithm.</source>
          <target state="translated">字段的大小和偏移量由以下算法决定。</target>
        </trans-unit>
        <trans-unit id="cd076db2ed4f4f71100b51cbd80768553b1f9904" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddr&lt;/code&gt; 实例的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="36d5ae29044e3939345f3681fd2eee4951ec1d94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV4&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV4&lt;/code&gt; 结构的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="aa0a80c41eafe63e764438582cea6579e34fa99a" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV6&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV6&lt;/code&gt; 结构的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="e8de810002bae6a69cc3fd5fc7b805d907b3e5fa" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SystemTime&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SystemTime&lt;/code&gt; 结构的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="5b0dd86b903ec8c3b54b21a61cbefcfccd34c7a3" translate="yes" xml:space="preserve">
          <source>The size of a recursive type must be finite; in other words the recursive fields of the type must be &lt;a href=&quot;types/pointer&quot;&gt;pointer types&lt;/a&gt;.</source>
          <target state="translated">递归类型的大小必须是有限的。换句话说，该类型的递归字段必须是&lt;a href=&quot;types/pointer&quot;&gt;指针类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c26f5c42f6a164861e02ed67750e160fcf8f0712" translate="yes" xml:space="preserve">
          <source>The size of a symbolic link is the length of the pathname it contains, without a terminating null byte.</source>
          <target state="translated">符号链接的大小是它所包含的路径名的长度,不含终止的空字节。</target>
        </trans-unit>
        <trans-unit id="e1eaacf69ef80cbba3a3f01cf2e10bd4a9a5fca5" translate="yes" xml:space="preserve">
          <source>The size of a type in bytes.</source>
          <target state="translated">类型的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="96cd8943bd738b362434700faacd7dc900194564" translate="yes" xml:space="preserve">
          <source>The size of a union is the size of its largest field.</source>
          <target state="translated">联合体的大小是指其最大领域的大小。</target>
        </trans-unit>
        <trans-unit id="b7e7e7e0bae0750a49867bf9a72696378b080c09" translate="yes" xml:space="preserve">
          <source>The size of a value has two definitions.</source>
          <target state="translated">一个值的大小有两个定义。</target>
        </trans-unit>
        <trans-unit id="5e402a67efb4a62fa553a5f1394c869ac08acac0" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Instant&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Instant&lt;/code&gt; 结构的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="ba89d7b73eb9567f0b0c3196e6cf2e84c9f4c35c" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;IpAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;IpAddr&lt;/code&gt; 实例的大小可能会因目标操作系统而异。</target>
        </trans-unit>
        <trans-unit id="64ef5aa718e0f2a4fb9998a036169d75f54db6df" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv4Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv4Addr&lt;/code&gt; 结构的大小可能会有所不同，具体取决于目标操作系统。</target>
        </trans-unit>
        <trans-unit id="b28d6468d140c4a12bab4e35b4415d244e5f859a" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv6Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv6Addr&lt;/code&gt; 结构的大小可能会有所不同，具体取决于目标操作系统。</target>
        </trans-unit>
        <trans-unit id="a01d57dab257711e2df9579c72d88d59028c40dc" translate="yes" xml:space="preserve">
          <source>The size of most primitives is given in this table.</source>
          <target state="translated">本表给出了大多数基元的尺寸。</target>
        </trans-unit>
        <trans-unit id="5a098a792b06569a6bb6f2b7d98cf8797dcd4ec6" translate="yes" xml:space="preserve">
          <source>The size of the referenced value in bytes.</source>
          <target state="translated">参考值的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="62333b23a5b2b89de3b055144daa334820b9c575" translate="yes" xml:space="preserve">
          <source>The size of this integer type in bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1fbeb1b5be430f1bc9e3a92e1dadba4b4fdb71" translate="yes" xml:space="preserve">
          <source>The size of this primitive is how many bytes it takes to reference any location in memory. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</source>
          <target state="translated">此基元的大小是指引用内存中任何位置所需的字节数。例如,在 32 位目标上,这是 4 个字节,在 64 位目标上,这是 8 个字节。</target>
        </trans-unit>
        <trans-unit id="eaea58fd5debec4469854dd4c0d7e96ee309fa5f" translate="yes" xml:space="preserve">
          <source>The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e51743ff7cd79535af677e289113dcff07dbe9c" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte at the end of the slice.</source>
          <target state="translated">用于创建&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;的切片在切片末尾必须只有一个nul字节。</target>
        </trans-unit>
        <trans-unit id="06c3ab06faa47dfc08256f59e9e6b62a827af728" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad56ccc65a97d6c0192795237bde8dc8a187bcc7" translate="yes" xml:space="preserve">
          <source>The slices implement &lt;code&gt;IntoIterator&lt;/code&gt;. The iterator yields references to the slice elements.</source>
          <target state="translated">切片实现 &lt;code&gt;IntoIterator&lt;/code&gt; 。迭代器产生对slice元素的引用。</target>
        </trans-unit>
        <trans-unit id="4d54f29cfdc5fb0b14c6bc3d825908235a2d1e62" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type.</source>
          <target state="translated">这个整数类型所能代表的最小值。</target>
        </trans-unit>
        <trans-unit id="2ed21758c259b01204be09a1e5a970a7587f0275" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt;&lt;code&gt;i128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a50b28fc392edeb96ae6e8bbc1f3f65f1879e9" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt;&lt;code&gt;i16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab5eaa27a5d1f357d4d2bc91b9af02383caede4" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt;&lt;code&gt;i32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc283863a8f984dedbdb2f90ee6338a2b682ff86" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt;&lt;code&gt;i64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8fcd8d47309d686d033e491c707f9a8e4582c1" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt;&lt;code&gt;i8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124d5af779df7e9ad406378d4ae95baeff0f8e12" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt;&lt;code&gt;isize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7283dc0e8aef63acf9dd8ecc15410819b62a917" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt;&lt;code&gt;u128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1d26d88d80abad9936f065a519a8e6dae555c2" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt;&lt;code&gt;u16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5170dcabff61b3cd439cd574c1475742baecf6" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt;&lt;code&gt;u32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0709e957f7976c853e280aae68478111e39066d5" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt;&lt;code&gt;u64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa14915f9b53a3b041d9be135f24e5f469a12ccc" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt;&lt;code&gt;u8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275bb49ca6506b300934116c83ccd1ff11d81477" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt;&lt;code&gt;usize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c371b87930b46855075594aef0b191a2dcbb6afc" translate="yes" xml:space="preserve">
          <source>The smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is also not &lt;code&gt;Sync&lt;/code&gt; for the same reasons that it&amp;rsquo;s not &lt;code&gt;Send&lt;/code&gt;. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type (which we talked about in Chapter 15) and the family of related &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; types are not &lt;code&gt;Sync&lt;/code&gt;. The implementation of borrow checking that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does at runtime is not thread-safe. The smart pointer &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; and can be used to share access with multiple threads as you saw in the &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo;Sharing a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; Between Multiple Threads&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">智能指针 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 也不 &lt;code&gt;Sync&lt;/code&gt; ，原因与未 &lt;code&gt;Send&lt;/code&gt; 。所述 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; （我们将在第15章讲到）类型和相关的家族 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 类型不 &lt;code&gt;Sync&lt;/code&gt; 。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 在运行时执行的借位检查的实现不是线程安全的。智能指针 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 是 &lt;code&gt;Sync&lt;/code&gt; ，可以用来与多个线程共享访问，如&lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo; 在多个线程之间共享 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &amp;rdquo;&lt;/a&gt;部分中所看到的。</target>
        </trans-unit>
        <trans-unit id="348ea7c78b50388dc12ad8afa807cfbceb141e14" translate="yes" xml:space="preserve">
          <source>The socket will be closed when the value is dropped.</source>
          <target state="translated">当数值下降时,插座将被关闭。</target>
        </trans-unit>
        <trans-unit id="26c3406d4e79e978c77c7f71fb4706519f7ecd96" translate="yes" xml:space="preserve">
          <source>The solution here is to return the &lt;code&gt;String&lt;/code&gt; directly:</source>
          <target state="translated">解决方案是直接返回 &lt;code&gt;String&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b153caaa35f5e55b36f6162bb71df5061ac16716" translate="yes" xml:space="preserve">
          <source>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</source>
          <target state="translated">解决方法是选择一个不同的名称,不与任何导入到当前模块的外部箱子冲突。</target>
        </trans-unit>
        <trans-unit id="184f5f1102022e13bc531fc4c3a2f314884b9200" translate="yes" xml:space="preserve">
          <source>The solution is to coerce the array to a slice by calling a slice method:</source>
          <target state="translated">解决的办法是通过调用分片方法将数组胁迫成一个分片。</target>
        </trans-unit>
        <trans-unit id="4b8f691075403fc3cc04a12f17630d0a22222627" translate="yes" xml:space="preserve">
          <source>The solution is to declare the imports at the top of the block, function, or file.</source>
          <target state="translated">解决方法是在块、函数或文件的顶部声明导入。</target>
        </trans-unit>
        <trans-unit id="6d341bfc87265fdb3200162c1071f84eb34afeb9" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the items that you are re-exporting are themselves marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">解决此问题的方法是确保您要重新导出的项目本身都用 &lt;code&gt;pub&lt;/code&gt; 标记：</target>
        </trans-unit>
        <trans-unit id="ca1c4540563346f3ae5ba53810b40773e7e12128" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the module that you are re-exporting is itself marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">解决此问题的方法是确保要重新导出的模块本身已标记为 &lt;code&gt;pub&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ca9d7e79f3cd051af83e1b93c6feb0514cb1adc8" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated constant:</source>
          <target state="translated">解决这个问题的方法是去掉无关的关联常数。</target>
        </trans-unit>
        <trans-unit id="b66ecfc5844845f6ce826665530fcbac23beb458" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated type:</source>
          <target state="translated">解决这个问题的方法是删除无关的关联类型。</target>
        </trans-unit>
        <trans-unit id="f5e669f80a825dd22d2d4e3f89464bdf72e0692e" translate="yes" xml:space="preserve">
          <source>The solution to this problem is usually to switch to using a &lt;code&gt;move&lt;/code&gt; closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</source>
          <target state="translated">解决此问题的方法通常是切换到使用 &lt;code&gt;move&lt;/code&gt; 闭包。这种方法将数据移动（或复制，如果可能的话）到闭包中，而不是引用它。例如：</target>
        </trans-unit>
        <trans-unit id="4bc18e7ccda6a6b48c7507cdd496e8030bd28ca8" translate="yes" xml:space="preserve">
          <source>The source files from which this book is generated can be found on &lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">生成本书的源文件可以在&lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt;上找到。</target>
        </trans-unit>
        <trans-unit id="a49d6b47901cd19039274da891afacb7623398fb" translate="yes" xml:space="preserve">
          <source>The spawned thread may outlive the caller (unless the caller thread is the main thread; the whole process is terminated when the main thread finishes). The join handle can be used to block on termination of the child thread, including recovering its panics.</source>
          <target state="translated">生成的线程可能比调用者的寿命长(除非调用者线程是主线程;当主线程结束时,整个进程就会被终止)。加入句柄可以在子线程终止时进行阻塞,包括恢复其恐慌。</target>
        </trans-unit>
        <trans-unit id="3de206631f62d211730a1cc35e89663e7062bcfa" translate="yes" xml:space="preserve">
          <source>The specified environment variable was found, but it did not contain valid unicode data. The found data is returned as a payload of this variant.</source>
          <target state="translated">找到了指定的环境变量,但它不包含有效的unicode数据。找到的数据将作为该变量的有效载荷返回。</target>
        </trans-unit>
        <trans-unit id="ea36c8e1fa9f0022c16977222444b4a3c0ab84f9" translate="yes" xml:space="preserve">
          <source>The specified environment variable was not present in the current process's environment.</source>
          <target state="translated">在当前进程的环境中不存在指定的环境变量。</target>
        </trans-unit>
        <trans-unit id="9c4c268712a390c3c5b86d16dfd79086d462c7e5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;core::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45eb3e7f185d35fea76d0fcc8feefcf81bfa67b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;crate::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d879802905e96d1dbbee3b2bc193bcd1e8d256" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;core::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9900dab1e575f89f6a70cab38ccde57d12f174" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;crate::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f913c926721dcfb858ba0f49073ea9578b8b3f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;core::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="176610383e559ab75c30b3e60918dcf39baa4491" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769e7a49a82fbc73600ab216f157a9a4edfed6d2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68bf1becb5538df04aef3bc27ba3a8fc1c5f4d80" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;core::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f707ad710f27d4a519df162d93207b489b43663" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;crate::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb235568e3ec680a5ddbb056614a4544c534c3b1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;core::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb92f5b8279175442866093e128f5cb80c5d7d4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;crate::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b63712fb966ee55e431373c44ee70e5bdcc0d5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;core::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9a6b3a12732480c74ccdbdd6c6cd441416852" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;crate::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f183bce94483cede38b2e29f8c8da04b39e389f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626a03e32989e459202fcca2e29d114287d2e779" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;std::mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../mem/fn.needs_drop&quot;&gt; &lt;code&gt;std::mem::needs_drop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf0f4e1682c5598721794a53177e6ce27697d607" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;core::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b581000bfc2472e309baf4b78516cb35a337926" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;std::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;std::mem::size_of&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4df5be2153e7097fd8b00742eff3c445821681d5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5867b1e1c4944c1f7ed32488f5be2fa294b4986f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;std::mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../mem/fn.size_of_val&quot;&gt; &lt;code&gt;std::mem::size_of_val&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1746aa772dc9c98fd4e848556bc017af5d5a5814" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.abs&quot;&gt;&lt;code&gt;std::f32::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd019f674bd918f6d03e4b0946395283db961b78" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt;&lt;code&gt;std::f32::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26bbd19c72d02740271e9c35e7a28be8dc08d048" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt;&lt;code&gt;std::f32::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c494ecc8ddd36d321a87c24568cbae459fddb9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.cos&quot;&gt;&lt;code&gt;std::f32::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b0a8ab3fca707be3b5a4c013197b6ace7d6752" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp&quot;&gt;&lt;code&gt;std::f32::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="336a8852727ebc5c24637be3db7e37b682324956" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt;&lt;code&gt;std::f32::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e4b0f6edf39422d28e3db71bd5ccc4aa08c8f3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.floor&quot;&gt;&lt;code&gt;std::f32::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c54f6e18bc6b7c8320c4a68ccd5c641025d11b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ln&quot;&gt;&lt;code&gt;std::f32::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8fbd8555b23fb5da5a31c3691aceae539093012" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log10&quot;&gt;&lt;code&gt;std::f32::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163981a463a3f186e653d8b1d906aacc60bb507a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log2&quot;&gt;&lt;code&gt;std::f32::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad71542a1a997b3c3c61f5ecfa210cbb95931d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.max&quot;&gt;&lt;code&gt;f32::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275c6f9b837c44f59265b27a725f706ea01e4d88" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.min&quot;&gt;&lt;code&gt;f32::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a1adc351bf8541ff50457503f42947d2223aa1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt;&lt;code&gt;std::f32::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824767dc22e0a666300f3bbc86838e9e982d5929" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powf&quot;&gt;&lt;code&gt;std::f32::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9c8c235c9463f3bd3c7f8d97084f0aa09a4e6b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powi&quot;&gt;&lt;code&gt;std::f32::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7c21362121499d029cb16e6e1a0c1b3f1e8a1a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.round&quot;&gt;&lt;code&gt;std::f32::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4af107006e6e31e8e831e5d5f7bf515b2e1cc7d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sin&quot;&gt;&lt;code&gt;std::f32::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b79ebb4c8dc7ee3e2e853d2ae83194460b52cd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt;&lt;code&gt;std::f32::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2f3efeb8ac74af1f762963525599c78dfb84b4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt;&lt;code&gt;std::f32::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50e2d709a0ab57a5af9a3d0b85809c7253cdbbe" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.abs&quot;&gt;&lt;code&gt;std::f64::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8077c0447a55f70ad3a41280e7cdad8b5a596e3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt;&lt;code&gt;std::f64::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c784852d478dc5b87ed608a83b4485e61ffaa08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt;&lt;code&gt;std::f64::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3706879950fc2f859ec3405d83c39468b3d127b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.cos&quot;&gt;&lt;code&gt;std::f64::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe60787bdb5a14582899986ea8a8eb5151f047a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp&quot;&gt;&lt;code&gt;std::f64::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d57c3217aae4fa0b39647c7df0a1a27ba3ce04c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt;&lt;code&gt;std::f64::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ec2f6c9475943bd6d7a554d14049a4e570f218" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.floor&quot;&gt;&lt;code&gt;std::f64::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c322d0525dc747c93c991f848c51c52ac90096" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ln&quot;&gt;&lt;code&gt;std::f64::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85342dac467b551f64948da385b26bae5ec304e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log10&quot;&gt;&lt;code&gt;std::f64::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1fcf5615e4f3f284291f587c194c0ee80f02e1b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log2&quot;&gt;&lt;code&gt;std::f64::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33d40ec03fc6fd7670da5d91bb3dff1514508d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.max&quot;&gt;&lt;code&gt;f64::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5caceb4a4959b387b99fbf4eb4112cfa719de9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.min&quot;&gt;&lt;code&gt;f64::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184af9c54cafa84b2f1da9d8430a1cc45e2501b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt;&lt;code&gt;std::f64::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a62ab1447e5a688dfc2804caf90414ec922c3e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powf&quot;&gt;&lt;code&gt;std::f64::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa85dcefba2eba944e099df5e0b7568320b594" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powi&quot;&gt;&lt;code&gt;std::f64::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab11dcc6899cdf3c196ec2500a4f98d80cd92c0f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.round&quot;&gt;&lt;code&gt;std::f64::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc17db1c9e9aeccadbae543736abc641bf19581" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sin&quot;&gt;&lt;code&gt;std::f64::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9259a474b9633d2c178bcfa8945b9cf932f9b62" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt;&lt;code&gt;std::f64::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d46fbb4d6dd94cb20b274b64fb45bedd897ee1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt;&lt;code&gt;std::f64::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24ba042f8ed9a32e5152ef40108b6331e9ff075" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;std::pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ef8497ee38f892bb72694c3c391e01cf452f3c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt;&lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a878abfa4b4b05965b5ed62c9134a4b23816af" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f777a2d25d61f2a8a030aed5ab4e20e176d153a8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;core::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0344746e9b397b268af814908260e075e04e91" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;crate::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ad03e9160cb2408f7bd5aa45c03727935da29f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;core::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118ab008d64be2589235ff02dc721d1434d90f79" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;crate::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac108773792d7b27741d0ad608d7eda680fdf09" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;core::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70902b9a0728e1e3dbaf882574f3b031e91654e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;crate::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625b254ad12639bd7cf3b4b8d18b0e6a86ce6669" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.needs_drop&quot;&gt;&lt;code&gt;needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4decf20d903cd057fdbbe638ed8d8e3f26c756a4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c9dc52f1e3d1631dde7d53032bcc39a6df9f72" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58429d40c9c7f24b0a6d088073711682d0c11242" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5311916c06b10b8c928d0abda98be268ace4e6d6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3081645830dba10410e4d31cc6a792e5fa76abfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8d39a214853d9287e37063d7cab0006a733cdd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb2b502c2611a7e2eb731a194ab104f5f862370" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365e7e84eb752771b266d7d9e0c92f84d3398fe0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f323b62e22f70b85a5b00e81ad1dd75f18bb93e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bdf72440b67a4b60d0cb051b353e1a1e5f17d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb231858cd4689ec5627a23d29186ff8d439dec" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba45a4ad89ca37d142fe08556abef04250897691" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f793986afe8163ac71ccb416509b9ce1b93b28a7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f793b659028e7642830af52530c7830ca89493" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49aafe40a8bc9c4c0d4799be407063a6be2f80b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1036b996bdd682cf46fc64099bdeb270500f551" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8002438bcf3c0d48b47c6879f85d416ab04436" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a7b18952940b9b8182e6a6746cc4d6878e30de3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bf12a3e1dda34bbe1170fb23b2c7e3980fa2e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e3416a187e1174aeae58104e7efc1c7ee03ff6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17459feca9539df018355d8750621e9dbfee25c8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bb6ebc113b49007d6fcfdfafa151470c4d97fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b287de0c6ccb4c255ae592a699ddf51d510069e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc152c646978658d528a198a309e91d74e54a326" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1db276c3b3b4fd7ceb4e380bed1da5745f7ffc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951c50a3c5ccad37a2e3fca1e84b631f4373b483" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128d2037df6a05cf07d2834b7655c68820b3bd26" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab03d58d5f671c0a0db830b6b05ae77f18309c3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88060a6c5fb7a5ab11e95c384921daa2c4d4f5bf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd12eff27bb275374d877eb262054ae1c853f908" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1fc10d6447bc6c5afd961766bf358a30dcbdba" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f0f125817ae56a57898beaed413be79b5a5f7f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4f22637924c144abe1815857665dade4d3c51b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862ae83bdd80acbffd544e29d0952bfef39ef310" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301da9988d8a43a17c9bdfe746d0d24a87f91ac5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e408b07db98e8ee6804e680f2894d658fb2f63fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2ce54b599780814ddae4cc41ff6842ce0dffc8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c44a7a6b16b40cf235a33892e670e0a8bc5178" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae6f5127b74d22ebf6510c20a59c81a3de0cdfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695ca0d01b208d0e14efcb78593ea9daca909ab8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a2657e5f8e4cdd6d19f74f32446cf634f2c708" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27a067a3ca05d7ed184ca857f007a3ba758dcd5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f042c7aafd7bdff469934311d53691a7a1a1045" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91da36591ebb40c0553e91c9f934d905043cb8a9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e00a651851675118139e87206d58986105c4eb0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a857da52573d4e17b52a7e7c33c2b45cbcba5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7b5f35485a9f9923b0a484a1951a30bb3a1887" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993970aa50aa2516408dfe30230dc45762d3f244" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460da953958feb4d29ef7b565f8bb84fe0c27874" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe64adf45d801b3817879d281caf34973915fca3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30017d261ccaa47677175bc1d115dd370a15f192" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b88f8c0000bb8e04847190fb1bea4c60b0d2d4b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5515cfd3dce0baaa5d0933d153812410aa18e81b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f2a12d751dc3a744709ca812719eed5be6639d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b08115a886002f8e0b6d94070bb4e793dcb17c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65021746bc3a29e483b54a665e8fe3993f3b7531" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9074d1309228123f0a179daab86adda956d06578" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf31a4dfb044ce9c3c11fede562f450062e8cb70" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a08ca4aeb864c545fa763c7c1bc0c6adeca1e10" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e04028b595d303c299af1a09560b78dc738b23" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03d95dd3b76208c05df63103f2a4773075d06c7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527ff76b4c308bdfc8590a98e3e2f36b010f0a65" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecf9233457e6140afc96f591e6de39578ed746f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72330976c1ede5cb1f5f36f1315049842fbbb63" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07780502f5ae712c09c48bfbf053afbea4b8cc74" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ddb64e96ce0f4ae971acf4e42bb38eda10bc9a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd50153000fdd2e98065597c848234d48c5ae7ef" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6dbd5587aa433e73f8c34d35d442568a18d942" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f72e56df4940284d7926cf923d2abdf7ea9bb4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52da2c5cb5cf0d647cd3855825f192673441bdbd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b30bfb1f2876b5af31915eef811a342ebcdd3b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4382bd14df2effe7e74aa90568e6832848eea4e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61255cb553ed1c231e1f72bb0423d91f01ae315" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69be96162b6a1c17ecee094d784c23706a36adc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f289d7def13530cb2e5c5d7eaa967ea0cbc29ea7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb5f9b2cac38e545e679417e0916b9477cb828c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aedb9c670fb8b498f17ad50461be8607159cf171" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044d7d27fe09f49e2ad99740d35c149e3d409936" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c22889aedce154435ee258d0c40e6448efdbc64" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a58dd280c30118ad91cca00ca18fbb4a646d3fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f1a35ffbfc66293f3ecb009316545b57e972fd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f36baf03828badd5e395776499479459fdf74dd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b26c022d9640d58bf0ee1df55fea1127cc8b08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b715010a7a857987bd13e4e2c7860444d5f72aff" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f8d269b525f2aa0c49880dc3986476498a5a32" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b7d1ba04947e0d60fd8323f25d9cb851df4d45" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f46b18b5f9509f4b838f2cd1cc47b1cca4ac44" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eee377d6930faac324afa2f516a7fca7070547e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c150f5488b1c18a2f570344ce5e7e4fbf333ebdf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4467e4d025c942d0e46a8d42d28e9cb70772aadf" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;count_ones&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt;&lt;code&gt;u32::count_ones&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49764c7bf099d11524ff3ae31ea8122bd687603" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;leading_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt;&lt;code&gt;u32::leading_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94453dce8a2a385d273d4c54481b7123c231b9e1" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt;&lt;code&gt;u32::overflowing_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975a6bc8f0eb314f9e1b240024dd857b1481fb4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt;&lt;code&gt;u32::overflowing_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ac2c8d4649564823e71195e6e1991816e3c134" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt;&lt;code&gt;u32::overflowing_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea1555efef9a893424297cca53eccdff2cb4c12" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;reverse_bits&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt;&lt;code&gt;u32::reverse_bits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b9a60eaad995a8b508e08e5f720afcfb3cdf4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_left&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt;&lt;code&gt;u32::rotate_left&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39d8d5e922a37bc7cb7a4273c351e3237285524" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_right&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt;&lt;code&gt;u32::rotate_right&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9cb80ab093ca12a015c158de3a354687ef2774" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt;&lt;code&gt;u32::saturating_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfb3fdba827a384aada0939a551d1f733164685" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt;&lt;code&gt;u32::saturating_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7476e3eb126b1478bcad495831ba6637eb3d2b14" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;swap_bytes&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt;&lt;code&gt;u32::swap_bytes&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e398694f9fea1333665249a1e9c25a4d94f59367" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;trailing_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt;&lt;code&gt;u32::trailing_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c77154ad25fdd3e2bc406487defdcb53ca75726" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_add&quot;&gt;&lt;code&gt;u32::wrapping_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2b20ca06dc1c8110b4d0397b1994d813ffed56" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_mul&quot;&gt;&lt;code&gt;u32::wrapping_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00df89161b3ee01f6671c6eedc0e25647116beb0" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_sub&quot;&gt;&lt;code&gt;u32::wrapping_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e69ca4af06caf0678a0eb7f58dbb4160ebfce9" translate="yes" xml:space="preserve">
          <source>The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</source>
          <target state="translated">标准库API文档描述了向量、字符串和哈希图所具有的方法,这些方法将对这些练习有所帮助!</target>
        </trans-unit>
        <trans-unit id="ecfac3d3b7b498f942f6cc167a3014bcca50e8db" translate="yes" xml:space="preserve">
          <source>The standard library also provides a &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; newtype which ensures all standard arithmetic operations for &lt;code&gt;T&lt;/code&gt; have wrapping semantics.</source>
          <target state="translated">标准库还提供了一种 &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; NEWTYPE它保证了对所有标准算术运算 &lt;code&gt;T&lt;/code&gt; 有包裹语义。</target>
        </trans-unit>
        <trans-unit id="e62bb358494cb55da1b597b5302098f7179da4a8" translate="yes" xml:space="preserve">
          <source>The standard library contains additional 'smart pointer' types beyond references and raw pointers.</source>
          <target state="translated">除了引用和原始指针之外,标准库还包含额外的 &quot;智能指针 &quot;类型。</target>
        </trans-unit>
        <trans-unit id="4aeb001acf27f60d5c3f4949174f0ea7b98815a0" translate="yes" xml:space="preserve">
          <source>The standard library documentation for the &lt;code&gt;env::args&lt;/code&gt; function shows that the type of the iterator it returns is &lt;code&gt;std::env::Args&lt;/code&gt;. We&amp;rsquo;ve updated the signature of the &lt;code&gt;Config::new&lt;/code&gt; function so the parameter &lt;code&gt;args&lt;/code&gt; has the type &lt;code&gt;std::env::Args&lt;/code&gt; instead of &lt;code&gt;&amp;amp;[String]&lt;/code&gt;. Because we&amp;rsquo;re taking ownership of &lt;code&gt;args&lt;/code&gt; and we&amp;rsquo;ll be mutating &lt;code&gt;args&lt;/code&gt; by iterating over it, we can add the &lt;code&gt;mut&lt;/code&gt; keyword into the specification of the &lt;code&gt;args&lt;/code&gt; parameter to make it mutable.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; 函数的标准库文档显示，它返回的迭代器的类型为 &lt;code&gt;std::env::Args&lt;/code&gt; 。我们已经更新了 &lt;code&gt;Config::new&lt;/code&gt; 函数的签名，因此参数 &lt;code&gt;args&lt;/code&gt; 的类型为 &lt;code&gt;std::env::Args&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;[String]&lt;/code&gt; 。因为我们拥有 &lt;code&gt;args&lt;/code&gt; 的所有权，并且将通过对其进行迭代来使 &lt;code&gt;args&lt;/code&gt; 发生变异，所以我们可以将 &lt;code&gt;mut&lt;/code&gt; 关键字添加到 &lt;code&gt;args&lt;/code&gt; 参数的规范中以使其可变。</target>
        </trans-unit>
        <trans-unit id="0ac01984afb710ebee7af9fdef959461335b5771" translate="yes" xml:space="preserve">
          <source>The standard library does &lt;em&gt;not&lt;/em&gt; automatically wait on child processes (not even if the &lt;code&gt;Child&lt;/code&gt; is dropped), it is up to the application developer to do so. As a consequence, dropping &lt;code&gt;Child&lt;/code&gt; handles without waiting on them first is not recommended in long-running applications.</source>
          <target state="translated">标准库并&lt;em&gt;不能&lt;/em&gt;自动地等待子进程（甚至没有，如果 &lt;code&gt;Child&lt;/code&gt; 被丢弃），它是由应用程序开发人员这样做。因此，在长时间运行的应用程序中，建议不要先等待 &lt;code&gt;Child&lt;/code&gt; 句柄就删除它。</target>
        </trans-unit>
        <trans-unit id="c3da8861a8cd359749d019429f14004546548517" translate="yes" xml:space="preserve">
          <source>The standard library exports many modules &lt;em&gt;with the same name as primitive types&lt;/em&gt;. These define additional items related to the primitive type, but not the all-important methods.</source>
          <target state="translated">标准库导出了许多&lt;em&gt;与基本类型同名的&lt;/em&gt;模块。这些定义了与基本类型相关的其他项，但没有定义所有重要方法。</target>
        </trans-unit>
        <trans-unit id="be570bfc11d12183d4ccfc099e5e91a1312fadce" translate="yes" xml:space="preserve">
          <source>The standard library exposes three common ways to deal with contiguous regions of memory:</source>
          <target state="translated">标准库公开了三种处理内存连续区域的常见方法。</target>
        </trans-unit>
        <trans-unit id="d66210e7b423f4f4e31543419e308e2c95ac4c07" translate="yes" xml:space="preserve">
          <source>The standard library has other types that provide interior mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar except that instead of giving references to the inner value, the value is copied in and out of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;. There&amp;rsquo;s also &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, which offers interior mutability that&amp;rsquo;s safe to use across threads; we&amp;rsquo;ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</source>
          <target state="translated">标准库具有其它类型的提供内部可变性，如 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; ，这是不同之处在于代替给到内值的引用，该值和移出的复制类似 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 。还有 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ，它提供内部可变性，可以在线程之间安全使用。我们将在第16章中讨论它的用法。有关这些类型之间差异的更多信息，请查看标准库文档。</target>
        </trans-unit>
        <trans-unit id="a3eb5ea324c5e016fa7225e0db42ddd0287496a0" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">标准库在通常用作缓冲区的各种类型上实现一些I / O特性，例如 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac69e8dd1e3e493ce33a798e654cad2d62974e3" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../slice/index&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd43fc91f30c20105f33015f4862eaa4ba469ffd" translate="yes" xml:space="preserve">
          <source>The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate. For example the &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; and &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; targets typically come with both runtimes and the user selects which one they'd like. All targets in the compiler have a default mode of linking to the C runtime. Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</source>
          <target state="translated">通常，标准库会努力为目标适当地支持静态链接和动态链接的C运行时。例如， &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; 和 &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; 目标通常随两个运行时一起提供，用户可以选择所需的运行时。编译器中的所有目标都有链接到C运行时的默认模式。通常，目标默认情况下是动态链接的，但是默认情况下存在静态的例外，例如：</target>
        </trans-unit>
        <trans-unit id="e62009a1ff01cf79d8a5846c788aa68bf271141c" translate="yes" xml:space="preserve">
          <source>The standard library provides an implementation of &lt;code&gt;panic_handler&lt;/code&gt; that defaults to unwinding the stack but that can be &lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;changed to abort the process&lt;/a&gt;. The standard library's panic behavior can be modified at runtime with the &lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt; function.</source>
          <target state="translated">标准库提供 &lt;code&gt;panic_handler&lt;/code&gt; 的实现，该实现默认为展开堆栈，但可以&lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;更改以中止该进程&lt;/a&gt;。可以在运行时使用&lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt;函数修改标准库的紧急行为。</target>
        </trans-unit>
        <trans-unit id="a6bfe00112d50ce1df3b69fa8e0f97c99e921c7e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s &lt;code&gt;Add&lt;/code&gt; trait is an example of the second purpose: usually, you&amp;rsquo;ll add two like types, but the &lt;code&gt;Add&lt;/code&gt; trait provides the ability to customize beyond that. Using a default type parameter in the &lt;code&gt;Add&lt;/code&gt; trait definition means you don&amp;rsquo;t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn&amp;rsquo;t needed, making it easier to use the trait.</source>
          <target state="translated">标准库的 &lt;code&gt;Add&lt;/code&gt; trait是第二个目的的示例：通常，您将添加两个类似的类型，但是 &lt;code&gt;Add&lt;/code&gt; trait可以提供自定义功能。在&amp;ldquo; &lt;code&gt;Add&lt;/code&gt; 特征&amp;rdquo;定义中使用默认类型参数意味着您不必在大多数时间指定额外的参数。换句话说，不需要一些实现样板，从而更容易使用该特征。</target>
        </trans-unit>
        <trans-unit id="0eb239c2b2b429ca2fb24dfb5a68ef2028451c54" translate="yes" xml:space="preserve">
          <source>The start and end of the string (when &lt;code&gt;index == self.len()&lt;/code&gt;) are considered to be boundaries.</source>
          <target state="translated">字符串的开始和结束（当 &lt;code&gt;index == self.len()&lt;/code&gt; ）被视为边界。</target>
        </trans-unit>
        <trans-unit id="cc00d65ec1e11702c522241a5699948a50675d34" translate="yes" xml:space="preserve">
          <source>The starting index must come before the ending index;</source>
          <target state="translated">起始索引必须在结束索引之前。</target>
        </trans-unit>
        <trans-unit id="7d09dcb9f35a47d4d0374a51c368ed9570b886f1" translate="yes" xml:space="preserve">
          <source>The starting index must not exceed the ending index;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f319cd135ed3830fb0df0009e873ba0d9d3bd8" translate="yes" xml:space="preserve">
          <source>The static initializer is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt; evaluated at compile time. Static initializers may refer to other statics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ec0e6627e56520c118b2a4c9fe270333b4a9ac" translate="yes" xml:space="preserve">
          <source>The status (exit code) of the process.</source>
          <target state="translated">进程的状态(退出代码)。</target>
        </trans-unit>
        <trans-unit id="2deb263189905df596d3c94b6a6e46fb7fad91f4" translate="yes" xml:space="preserve">
          <source>The status code 200 is the standard success response. The text is a tiny successful HTTP response. Let&amp;rsquo;s write this to the stream as our response to a successful request! From the &lt;code&gt;handle_connection&lt;/code&gt; function, remove the &lt;code&gt;println!&lt;/code&gt; that was printing the request data and replace it with the code in Listing 20-3.</source>
          <target state="translated">状态码200是标准成功响应。文本是一个很小的成功HTTP响应。让我们将其写入流中，作为对成功请求的响应！从 &lt;code&gt;handle_connection&lt;/code&gt; 函数中，删除 &lt;code&gt;println!&lt;/code&gt; 它正在打印请求数据，并将其替换为清单20-3中的代码。</target>
        </trans-unit>
        <trans-unit id="121dc7dfe8e1f05a50f59cc42ea3919e004fbd87" translate="yes" xml:space="preserve">
          <source>The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.</source>
          <target state="translated">子进程的stdin句柄(如果有的话)将在等待之前被关闭。这有助于避免死锁:它确保子进程在等待父进程的输入时不会阻塞,而父进程则等待子进程退出。</target>
        </trans-unit>
        <trans-unit id="9e925de820aa28eb2278cfb5b172897339fec44e" translate="yes" xml:space="preserve">
          <source>The stem is:</source>
          <target state="translated">茎是。</target>
        </trans-unit>
        <trans-unit id="f0b062427634e6f3b4d22b8847d4a85e632115c3" translate="yes" xml:space="preserve">
          <source>The stream of &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; values up to a &lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt;&lt;code&gt;Done&lt;/code&gt;&lt;/a&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cd101b0d8222a260b75e7043b8f85140377fdb" translate="yes" xml:space="preserve">
          <source>The stream of &lt;code&gt;Match&lt;/code&gt; and &lt;code&gt;Reject&lt;/code&gt; values up to a &lt;code&gt;Done&lt;/code&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">直到 &lt;code&gt;Done&lt;/code&gt; &lt;code&gt;Match&lt;/code&gt; 和 &lt;code&gt;Reject&lt;/code&gt; 值流将包含相邻，不重叠，覆盖整个干草堆并位于utf8边界上的索引范围。</target>
        </trans-unit>
        <trans-unit id="fe598c8b995968505dc48317e5f0bc507dd1c32a" translate="yes" xml:space="preserve">
          <source>The stream typically has a fixed size, allowing seeking relative to either end or the current offset.</source>
          <target state="translated">流通常有一个固定的大小,允许相对于任何一端或当前偏移量寻找。</target>
        </trans-unit>
        <trans-unit id="3f8a9a233edfd6e32f4b57b8721cdb5b1b1aca0a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s3&lt;/code&gt; will contain &lt;code&gt;Hello, world!&lt;/code&gt; as a result of this code. The reason &lt;code&gt;s1&lt;/code&gt; is no longer valid after the addition and the reason we used a reference to &lt;code&gt;s2&lt;/code&gt; has to do with the signature of the method that gets called when we use the &lt;code&gt;+&lt;/code&gt; operator. The &lt;code&gt;+&lt;/code&gt; operator uses the &lt;code&gt;add&lt;/code&gt; method, whose signature looks something like this:</source>
          <target state="translated">字符串 &lt;code&gt;s3&lt;/code&gt; 将包含 &lt;code&gt;Hello, world!&lt;/code&gt; 作为此代码的结果。加完后 &lt;code&gt;s1&lt;/code&gt; 不再有效的原因，而我们引用 &lt;code&gt;s2&lt;/code&gt; 的原因与使用 &lt;code&gt;+&lt;/code&gt; 运算符时调用的方法的签名有关。在 &lt;code&gt;+&lt;/code&gt; 操作员使用 &lt;code&gt;add&lt;/code&gt; 方法，其签名看起来是这样的：</target>
        </trans-unit>
        <trans-unit id="00f2d10e6fe0131d33ac9bca9a600be0160e329e" translate="yes" xml:space="preserve">
          <source>The string Pattern API.</source>
          <target state="translated">字符串Pattern API。</target>
        </trans-unit>
        <trans-unit id="12fed2044893f571a9f644790505d48a15787f1f" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">该字符串应为可选的 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 号，后跟数字。前导和尾随空格表示错误。数字是这些字符的子集，具体取决于 &lt;code&gt;radix&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c23316acb8db6205270f951b08328de7cc2d92db" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">该字符串应为可选的 &lt;code&gt;+&lt;/code&gt; 号，后跟数字。前导和尾随空格表示错误。数字是这些字符的子集，具体取决于 &lt;code&gt;radix&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="468f8218bbd425a57c6d5b5fde91fdb78d951a69" translate="yes" xml:space="preserve">
          <source>The string on the right-hand side is only borrowed; its contents are copied into the returned &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">右侧的字符串仅可借用；它的内容被复制到返回的 &lt;code&gt;String&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="86da74512bec8006d79316da49e5b54d47ae707d" translate="yes" xml:space="preserve">
          <source>The string will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; length units of other OS strings without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the string will not allocate.</source>
          <target state="translated">该字符串将能够准确地 &lt;code&gt;capacity&lt;/code&gt; 其他OS字符串的容量长度单位，而无需重新分配。如果 &lt;code&gt;capacity&lt;/code&gt; 为0，则不会分配该字符串。</target>
        </trans-unit>
        <trans-unit id="b6f927907143ca3f662c21fec70de91f1f0df225" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;PointList&lt;/code&gt; cannot implement &lt;code&gt;Copy&lt;/code&gt;, because &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;Copy&lt;/code&gt;. If we attempt to derive a &lt;code&gt;Copy&lt;/code&gt; implementation, we'll get an error:</source>
          <target state="translated">该结构 &lt;code&gt;PointList&lt;/code&gt; 不能执行 &lt;code&gt;Copy&lt;/code&gt; ，因为&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;不 &lt;code&gt;Copy&lt;/code&gt; 。如果我们尝试派生一个 &lt;code&gt;Copy&lt;/code&gt; 实现，将会得到一个错误：</target>
        </trans-unit>
        <trans-unit id="5c8326afa9ea5c7b5b28789d2c040dda354125af" translate="yes" xml:space="preserve">
          <source>The struct is marked &lt;code&gt;pub&lt;/code&gt; so that other code can use it, but the fields within the struct remain private. This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; methods on the struct, as shown in Listing 17-2:</source>
          <target state="translated">该结构被标记为 &lt;code&gt;pub&lt;/code&gt; ,以便其他代码可以使用它，但是该结构内的字段保持私有。在这种情况下，这一点很重要，因为我们要确保无论何时在列表中添加或删除值，均值也会更新。我们通过在struct上实现 &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;remove&lt;/code&gt; 和 &lt;code&gt;average&lt;/code&gt; 方法来做到这一点，如清单17-2所示：</target>
        </trans-unit>
        <trans-unit id="9c1c27f7e80229e155110850a64cfa98b9973379" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;. This is the default, but &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87dba90688420e84c6cfc3a67588b540866213a" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;code&gt;Unpin&lt;/code&gt;. This is the default, but &lt;code&gt;Unpin&lt;/code&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;code&gt;Unpin&lt;/code&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">该结构只能是&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;如果所有的结构区是 &lt;code&gt;Unpin&lt;/code&gt; 。这是默认设置，但是 &lt;code&gt;Unpin&lt;/code&gt; 是一个安全特性，因此作为该结构的作者，您有责任&lt;em&gt;不&lt;/em&gt;添加诸如 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; 。 （请注意，添加投影操作需要使用不安全的代码，因此 &lt;code&gt;Unpin&lt;/code&gt; 是安全的特性这一事实并没有违反以下原则：使用 &lt;code&gt;unsafe&lt;/code&gt; 只需担心其中的任何一项。）</target>
        </trans-unit>
        <trans-unit id="a32a0dfa31f0f0289e823ec593ac2d0e0186cb3f" translate="yes" xml:space="preserve">
          <source>The structure in the &lt;code&gt;vec!&lt;/code&gt; body is similar to the structure of a &lt;code&gt;match&lt;/code&gt; expression. Here we have one arm with the pattern &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt;, followed by &lt;code&gt;=&amp;gt;&lt;/code&gt; and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.</source>
          <target state="translated">&lt;code&gt;vec!&lt;/code&gt; 的结构！主体类似于 &lt;code&gt;match&lt;/code&gt; 表达式的结构。在这里，我们有一个模式 &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt; 手臂，后跟 &lt;code&gt;=&amp;gt;&lt;/code&gt; 和与此模式相关的代码块。如果模式匹配，则将发出关联的代码块。鉴于这是该宏中唯一的模式，因此只有一种有效的匹配方法；任何其他模式都会导致错误。更复杂的宏将具有多个分支。</target>
        </trans-unit>
        <trans-unit id="feedd74875f823ef27b80e0ba6fe89baf9a484a0" translate="yes" xml:space="preserve">
          <source>The structure of your public API is a major consideration when publishing a crate. People who use your crate are less familiar with the structure than you are and might have difficulty finding the pieces they want to use if your crate has a large module hierarchy.</source>
          <target state="translated">当发布一个 crate 时,你的公共 API 的结构是一个主要的考虑因素。如果你的箱子有一个大的模块层次结构,那么使用你的箱子的人就不如你熟悉结构,可能会很难找到他们想要使用的部分。</target>
        </trans-unit>
        <trans-unit id="8bdec152aa7987052184ceacfeaf61672bfbc336" translate="yes" xml:space="preserve">
          <source>The subtraction assignment operator &lt;code&gt;-=&lt;/code&gt;.</source>
          <target state="translated">减法赋值运算符 &lt;code&gt;-=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9df0e8a4e443e9ee7a165601e70a6b8ea73f8885" translate="yes" xml:space="preserve">
          <source>The subtraction operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">减法运算符 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28fd4d4d9eae938e322b4e3df0e6f419cbd1966d" translate="yes" xml:space="preserve">
          <source>The summary line displays at the end: overall, our test result is &lt;code&gt;FAILED&lt;/code&gt;. We had one test pass and one test fail.</source>
          <target state="translated">摘要行显示在末尾：总体而言，我们的测试结果为 &lt;code&gt;FAILED&lt;/code&gt; 。我们进行了一次测试通过，一次测试失败。</target>
        </trans-unit>
        <trans-unit id="ee42b5387704f2d9fe3e70d6349076680fb579e8" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">提供的密钥可以是地图的密钥类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与密钥类型的匹配。</target>
        </trans-unit>
        <trans-unit id="4d0db9da1f6030ddf936168ba198ea7e2ea2a8e7" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">提供的密钥可以是地图的密钥类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与密钥类型的匹配。</target>
        </trans-unit>
        <trans-unit id="6157ddf403c8a4c61dced75b578898d85ccde0c2" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">提供的密钥可以是地图的密钥类型的任何借用形式，但是借用形式上的顺序&lt;em&gt;必须&lt;/em&gt;与密钥类型上的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="9a3120ffbc7b98288aabd741823275a65245701a" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;^C&lt;/code&gt; represents where you pressed ctrl-c . You may or may not see the word &lt;code&gt;again!&lt;/code&gt; printed after the &lt;code&gt;^C&lt;/code&gt;, depending on where the code was in the loop when it received the interrupt signal.</source>
          <target state="translated">&lt;code&gt;^C&lt;/code&gt; 符号表示您按ctrl-c的位置。您可能会或可能不会 &lt;code&gt;again!&lt;/code&gt; 看到这个词！在 &lt;code&gt;^C&lt;/code&gt; 之后打印，具体取决于代码在接收到中断信号时在循环中的位置。</target>
        </trans-unit>
        <trans-unit id="266a6ae6e0b1b671aa6c8cd7616208233ffe3a4b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;..&lt;/code&gt; will expand to as many values as it needs to be. Listing 18-24 shows how to use &lt;code&gt;..&lt;/code&gt; with a tuple.</source>
          <target state="translated">语法 &lt;code&gt;..&lt;/code&gt; 将扩展为所需的任意多个值。清单18-24显示了如何在元组中使用 &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79fc3d3c405b115d38b7334d712d4081f0801fc2" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;if let&lt;/code&gt; takes a pattern and an expression separated by an equal sign. It works the same way as a &lt;code&gt;match&lt;/code&gt;, where the expression is given to the &lt;code&gt;match&lt;/code&gt; and the pattern is its first arm.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 的语法采用由等号分隔的模式和表达式。它与 &lt;code&gt;match&lt;/code&gt; 的工作方式相同，其中将表达式提供给 &lt;code&gt;match&lt;/code&gt; ，而模式是其第一个分支。</target>
        </trans-unit>
        <trans-unit id="751b24fbac99aa6572c9e1b012dbbe4901f9dd78" translate="yes" xml:space="preserve">
          <source>The syntax and semantics for generators is unstable and will require a further RFC for stabilization. At this time, though, the syntax is closure-like:</source>
          <target state="translated">生成器的语法和语义是不稳定的,需要进一步的RFC来稳定。不过,目前的语法是类似于封闭的。</target>
        </trans-unit>
        <trans-unit id="f94369f4bb8ebdf54603588e1760be815601c761" translate="yes" xml:space="preserve">
          <source>The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by &lt;code&gt;{}&lt;/code&gt; instead of the C-like &lt;code&gt;%&lt;/code&gt;. The actual grammar for the formatting syntax is:</source>
          <target state="translated">所使用的格式语言的语法是从其他语言中提取的，因此不要太陌生。参数使用类似Python的语法格式化，这意味着参数用 &lt;code&gt;{}&lt;/code&gt; 而不是C相似的 &lt;code&gt;%&lt;/code&gt; 包围。格式化语法的实际语法为：</target>
        </trans-unit>
        <trans-unit id="b1fb2c0dcb9e4f22d10669f04073e3418ad44567" translate="yes" xml:space="preserve">
          <source>The syntax for using generics in struct definitions is similar to that used in function definitions. First, we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we can use the generic type in the struct definition where we would otherwise specify concrete data types.</source>
          <target state="translated">在结构体定义中使用泛型的语法与函数定义中使用的语法类似。首先,我们在结构名称之后的角括号内声明类型参数的名称。然后,我们可以在结构定义中使用通用类型,否则我们将指定具体的数据类型。</target>
        </trans-unit>
        <trans-unit id="be667267584bb9b3dbb1d7d6c41e7cff90529baf" translate="yes" xml:space="preserve">
          <source>The syntax given to this macro is the same syntax as the &lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">赋予该宏的语法与&lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;属性的语法相同。</target>
        </trans-unit>
        <trans-unit id="37efe90a09f5adb20955a8d29f6006705ceea1f4" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;code&gt;type Name = ExistingType;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a952c08ff986f0fd0f90d2e270d99cd3e69c17a4" translate="yes" xml:space="preserve">
          <source>The syntax is the following: &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt;. Only one &lt;code&gt;BaseTrait&lt;/code&gt; can be used so this will not compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5b87227107115d71da53fde65c7898c2f8a55f" translate="yes" xml:space="preserve">
          <source>The tail (elements in the vector after &lt;code&gt;range&lt;/code&gt;) is empty,</source>
          <target state="translated">尾部（ &lt;code&gt;range&lt;/code&gt; 后面的向量中的元素）为空，</target>
        </trans-unit>
        <trans-unit id="018e9509238447c67e6197a11d4f5ea0ec53b22e" translate="yes" xml:space="preserve">
          <source>The tail expression of &lt;a href=&quot;expressions/block-expr&quot;&gt;block expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;块表达式&lt;/a&gt;的尾部表达式。</target>
        </trans-unit>
        <trans-unit id="73007ab480751859048a54c88693df26b24125bb" translate="yes" xml:space="preserve">
          <source>The task context refers to the &lt;a href=&quot;../../std/task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; which was supplied to the current &lt;a href=&quot;block-expr#async-context&quot;&gt;async context&lt;/a&gt; when the async context itself was polled. Because &lt;code&gt;await&lt;/code&gt; expressions are only legal in an async context, there must be some task context available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8066bd3121283d3517acd4ab40b658c1a009321c" translate="yes" xml:space="preserve">
          <source>The temporary scopes for expressions in &lt;code&gt;let&lt;/code&gt; statements are sometimes &lt;em&gt;extended&lt;/em&gt; to the scope of the block containing the &lt;code&gt;let&lt;/code&gt; statement. This is done when the usual temporary scope would be too small, based on certain syntactic rules. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c615f1f00b080ca7312a1e8d344f8e1a91bfada3" translate="yes" xml:space="preserve">
          <source>The test shows that when we call &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we get back only shoes that have the same size as the value we specified.</source>
          <target state="translated">该测试表明，当我们调用 &lt;code&gt;shoes_in_my_size&lt;/code&gt; 时，我们仅取回与我们指定的值具有相同大小的鞋子。</target>
        </trans-unit>
        <trans-unit id="6d51660220a74ee89098ef8ef16d38d84170be2b" translate="yes" xml:space="preserve">
          <source>The text &lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; is printed between the &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; and &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; text, showing that the &lt;code&gt;drop&lt;/code&gt; method code is called to drop &lt;code&gt;c&lt;/code&gt; at that point.</source>
          <target state="translated">&lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; 的文本Droping CustomSmartPointer！在 &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; 的CustomSmartPointer之间打印。并且 &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; 文本，表明在该点调用了 &lt;code&gt;drop&lt;/code&gt; 方法代码以放置 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9d885657469b7761a884865d71e05fd15d67a2e" translate="yes" xml:space="preserve">
          <source>The text of this string is stored directly in the program&amp;rsquo;s binary, which is always available. Therefore, the lifetime of all string literals is &lt;code&gt;'static&lt;/code&gt;.</source>
          <target state="translated">该字符串的文本直接存储在程序的二进制文件中，该二进制文件始终可用。因此，所有字符串文字的生存期都是 &lt;code&gt;'static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2418c922b0dbbb7a6749b73d736e8d2a5be9d0c" translate="yes" xml:space="preserve">
          <source>The third argument is a function called if a panic occurs. This function takes the data pointer and a pointer to the target-specific exception object that was caught. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9a02cbbbeece965fc06bf102b3dfcc209b80a8" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9782d2dad9c654fee52ed918f0366cbe2abfa6a" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">第三种情况比较棘手：Rust还将强制对不可变引用进行可变的引用。但反过来是&lt;em&gt;不是&lt;/em&gt;可能：一成不变的引用绝不会强迫到可变引用。由于有借用规则，如果您有可变引用，则该可变引用必须是对该数据的唯一引用（否则，程序将无法编译）。将一个可变引用转换为一个不可变引用将永远不会违反借用规则。将不可变引用转换为可变引用将需要对该数据只有一个不可变引用，而借用规则并不保证这一点。因此，Rust无法做出将不可变引用转换为可变引用的假设。</target>
        </trans-unit>
        <trans-unit id="25bc1d6b7d2fd810584a49b63e54dae85fbc7654" translate="yes" xml:space="preserve">
          <source>The third invariant says that when we have a complex NT that can match two or more copies of the same thing with no separation in between, it must be permissible for them to be placed next to each other as per the first invariant. This invariant also requires they be nonempty, which eliminates a possible ambiguity.</source>
          <target state="translated">第三个不变性说的是,当我们有一个复杂的NT,可以匹配同一事物的两个或两个以上的副本,中间没有任何分离,按照第一个不变性,必须允许它们彼此相邻。这个不变式还要求它们是非空的,这就消除了一个可能的歧义。</target>
        </trans-unit>
        <trans-unit id="6858985d6a527c37bd8cd37f82674daea04d146f" translate="yes" xml:space="preserve">
          <source>The third pointer is a target-specific data pointer which is filled in with the specifics of the exception that occurred. For examples on Unix platforms this is a &lt;code&gt;*mut *mut T&lt;/code&gt; which is filled in by the compiler and on MSVC it's &lt;code&gt;*mut [usize; 2]&lt;/code&gt;. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">第三个指针是特定于目标的数据指针，其中填充了发生的异常的详细信息。例如，在Unix平台上，这是 &lt;code&gt;*mut *mut T&lt;/code&gt; ，由编译器填充；在MSVC上，它是 &lt;code&gt;*mut [usize; 2]&lt;/code&gt; 。有关更多信息，请参见编译器的源代码以及std的catch实现。</target>
        </trans-unit>
        <trans-unit id="af84a0e541b5cb8aad0df743eb686112ab5e9865" translate="yes" xml:space="preserve">
          <source>The third problem is that we&amp;rsquo;ve used &lt;code&gt;expect&lt;/code&gt; to print an error message when reading the file fails, but the error message just prints &lt;code&gt;Something went wrong reading the file&lt;/code&gt;. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we&amp;rsquo;d print the &lt;code&gt;Something went wrong reading the file&lt;/code&gt; error message, which wouldn&amp;rsquo;t give the user any information!</source>
          <target state="translated">第三个问题是，我们曾经 &lt;code&gt;expect&lt;/code&gt; 在读取文件失败时打印一条错误消息，但是该错误消息只是打印 &lt;code&gt;Something went wrong reading the file&lt;/code&gt; 。读取文件可能会以多种方式失败：例如，文件可能丢失，或者我们可能没有打开文件的权限。现在，无论情况如何，我们都会在 &lt;code&gt;Something went wrong reading the file&lt;/code&gt; 错误消息时打印出问题，这不会为用户提供任何信息！</target>
        </trans-unit>
        <trans-unit id="f9f5c0bd316756e98b375cf7ab85326d6fd86b72" translate="yes" xml:space="preserve">
          <source>The third rule is if there are multiple input lifetime parameters, but one of them is &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; because this is a method, the lifetime of &lt;code&gt;self&lt;/code&gt; is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</source>
          <target state="translated">第三个规则是，如果有多个输入生存期参数，但是其中一个是 &lt;code&gt;&amp;amp;self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ,因为这是一种方法，因此将 &lt;code&gt;self&lt;/code&gt; 的生存期分配给所有输出生存期参数。第三条规则使方法更易于读写，因为需要的符号更少。</target>
        </trans-unit>
        <trans-unit id="c69636ef08912707db1c3ff91b55a817a8ac72a9" translate="yes" xml:space="preserve">
          <source>The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality. It will never sleep less.</source>
          <target state="translated">由于调度的特殊性或平台依赖性功能,线程的睡眠时间可能会比指定的时间长。它永远不会减少睡眠时间。</target>
        </trans-unit>
        <trans-unit id="cd58c0bda6dec6815740b7eed1b811cfbd96ccbb" translate="yes" xml:space="preserve">
          <source>The thread name is provided to the OS where applicable (e.g., &lt;code&gt;pthread_setname_np&lt;/code&gt; in unix-like platforms).</source>
          <target state="translated">线程名称在适用的情况下提供给OS（例如，在类Unix平台中的 &lt;code&gt;pthread_setname_np&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3218fca211a825167101461324b25d4344214224" translate="yes" xml:space="preserve">
          <source>The threading model</source>
          <target state="translated">线程模型</target>
        </trans-unit>
        <trans-unit id="2518c4f037fbaea8573cb319d8682ea0e18ad153" translate="yes" xml:space="preserve">
          <source>The three forms of iteration</source>
          <target state="translated">迭代的三种形式</target>
        </trans-unit>
        <trans-unit id="6e441e5631d84f73392a981b4df2ae8555997336" translate="yes" xml:space="preserve">
          <source>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</source>
          <target state="translated">三种程序宏(自定义派生、属性类、函数类)的工作方式都很相似。</target>
        </trans-unit>
        <trans-unit id="d7a7ac48a6db407723719df4ec95a88c69119a40" translate="yes" xml:space="preserve">
          <source>The three sections of output include the unit tests, the integration test, and the doc tests. The first section for the unit tests is the same as we&amp;rsquo;ve been seeing: one line for each unit test (one named &lt;code&gt;internal&lt;/code&gt; that we added in Listing 11-12) and then a summary line for the unit tests.</source>
          <target state="translated">输出的三个部分包括单元测试，集成测试和doc测试。单元测试的第一部分与我们所见的相同：每个单元测试一行（在清单11-12中添加了一个名为 &lt;code&gt;internal&lt;/code&gt; 的行），然后是单元测试的摘要行。</target>
        </trans-unit>
        <trans-unit id="779ae776bee7c2504118b220c1641bc64af7f7ac" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df380516e9cdddf51f2d5d2da6e443a2e517824" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is O(log n) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">如果元素主要以升序推入，则时间复杂度会降低。在最坏的情况下，元素按升序排序推入，相对于包含&lt;em&gt;n个&lt;/em&gt;元素的堆，每次推入的摊销成本为O（log n）。</target>
        </trans-unit>
        <trans-unit id="95e46fd08ac08fd408281a4c8d24f1d26e9263c5" translate="yes" xml:space="preserve">
          <source>The to-be-stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.variant_count&quot;&gt;&lt;code&gt;mem::variant_count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7075cd0ebc9560a0210fd04b57fb94c1b2316eda" translate="yes" xml:space="preserve">
          <source>The tokens that can begin a type are, as of this writing, {&lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;\*&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, lifetimes, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt;, any non-keyword identifier, &lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;$crate&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;impl&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;unsafe&lt;/code&gt;, &lt;code&gt;typeof&lt;/code&gt;, &lt;code&gt;dyn&lt;/code&gt;}, although this list may not be complete because people won't always remember to update the appendix when new ones are added.</source>
          <target state="translated">在撰写本文时，可以开始类型的标记是{ &lt;code&gt;(&lt;/code&gt; ， &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;!&lt;/code&gt; ， &lt;code&gt;\*&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、、 &lt;code&gt;?&lt;/code&gt; ，lifetimes， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;::&lt;/code&gt; ，任何非关键字标识符， &lt;code&gt;super&lt;/code&gt; ， &lt;code&gt;self&lt;/code&gt; ， &lt;code&gt;Self&lt;/code&gt; ， &lt;code&gt;extern&lt;/code&gt; ， &lt;code&gt;crate&lt;/code&gt; ， &lt;code&gt;$crate&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;impl&lt;/code&gt; ， &lt;code&gt;fn&lt;/code&gt; ， &lt;code&gt;unsafe&lt;/code&gt; ， &lt;code&gt;typeof&lt;/code&gt; ， &lt;code&gt;dyn&lt;/code&gt; }，尽管此列表可能并不完整，因为添加新的附录时人们不会总是记得更新附录。</target>
        </trans-unit>
        <trans-unit id="3d918eb4366eadb0401bfe8b5fc6b1b9ce9e5b76" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate, we&amp;rsquo;ll get an error:</source>
          <target state="translated">现在，顶级&lt;em&gt;Cargo.lock&lt;/em&gt;包含有关 &lt;code&gt;add-one&lt;/code&gt; 对 &lt;code&gt;rand&lt;/code&gt; 的依赖性的信息。但是，即使在工作空间中的某处使用 &lt;code&gt;rand&lt;/code&gt; ，也不能在工作空间的其他板条箱中使用它，除非我们也将 &lt;code&gt;rand&lt;/code&gt; 添加到其&lt;em&gt;Cargo.toml&lt;/em&gt;文件中。例如，如果我们添加 &lt;code&gt;use rand;&lt;/code&gt; 到&lt;em&gt;加法&lt;/em&gt; &lt;code&gt;adder&lt;/code&gt; 包装箱的&lt;em&gt;adder / src / main.rs&lt;/em&gt;文件中，我们将收到错误消息：</target>
        </trans-unit>
        <trans-unit id="c0d4e33f5ea540060f03c5345b86c179052a0077" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package, we&amp;rsquo;ll get an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3286fb14b7fd80e70223a9fcdf3dbb91a27203" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4d3d21f95395d566b73337877fe60f19b91950" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f198377d0780cd2ae0fe23c39d58fa6a11c3ce1b" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c818e1dc9d477cbb1ce03a32e397d907f841e91" translate="yes" xml:space="preserve">
          <source>The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">切片的总大小不得大于内存中的 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;字节&lt;/strong&gt;。请参阅&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;的安全文档。</target>
        </trans-unit>
        <trans-unit id="4da1db74e1e609ac8cd961cdfb0fa46bfc3d2c9d" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">该特征还提供了便捷的方法，例如&lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;，它会在循环中调用 &lt;code&gt;write&lt;/code&gt; ，直到其整个输入都被写入为止。</target>
        </trans-unit>
        <trans-unit id="903fc77fd3444aa853b4918c8904a108213ce8a6" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddef280ba8303b75d43b99adadcdec8f8b461c8f" translate="yes" xml:space="preserve">
          <source>The trait being implemented is defined in the same crate.</source>
          <target state="translated">正在实施的性状是在同一个箱子里定义的。</target>
        </trans-unit>
        <trans-unit id="fe160012593c71ba4d94a64501b55cb584b3c84d" translate="yes" xml:space="preserve">
          <source>The trait cannot contain associated constants</source>
          <target state="translated">性状不能包含相关常量</target>
        </trans-unit>
        <trans-unit id="f49c4617e26c7a90e7ceb5715737675232c71e5c" translate="yes" xml:space="preserve">
          <source>The trait cannot require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">特质不能要求 &lt;code&gt;Self: Sized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bbcc07233474a5558580dca4726567afce0f2c1" translate="yes" xml:space="preserve">
          <source>The trait cannot use &lt;code&gt;Self&lt;/code&gt; as a type parameter in the supertrait listing</source>
          <target state="translated">特质不能在上级特征列表中使用 &lt;code&gt;Self&lt;/code&gt; 作为类型参数</target>
        </trans-unit>
        <trans-unit id="6c46ccc8f602f9dc98f8190aa7e9cb78c7a8a015" translate="yes" xml:space="preserve">
          <source>The trait implemented by builtin generator types.</source>
          <target state="translated">由内置生成器类型实现的特性。</target>
        </trans-unit>
        <trans-unit id="0c6838569af8d3e59a65e8aec127e2d3a1e1e919" translate="yes" xml:space="preserve">
          <source>The trait is known as the &lt;em&gt;implemented trait&lt;/em&gt;. The implementing type implements the implemented trait.</source>
          <target state="translated">该特性被称为已&lt;em&gt;实现特性&lt;/em&gt;。实现类型实现已实现的特征。</target>
        </trans-unit>
        <trans-unit id="8cf3ab6548fb883dab5c1d88de8c77fdb3ccf054" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478884f7bada94b695fbee645bd59c060678235f" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;code&gt;next()&lt;/code&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">该特征被标记为不安全，因为需要 &lt;code&gt;next()&lt;/code&gt; 方法返回的索引位于干草堆中的有效utf8边界上。这使具有此特征的使用者无需进行额外的运行时检查即可切入干草堆。</target>
        </trans-unit>
        <trans-unit id="6d63a097c314f3198ade51464ed8a948cd1d46d3" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe in order to restrict implementors to fixed-size arrays. User of this trait can assume that implementors have the exact layout in memory of a fixed size array (for example, for unsafe initialization).</source>
          <target state="translated">这个特性被标记为不安全,以限制实现者使用固定大小的数组。这个特性的用户可以假设实现者在内存中拥有固定大小数组的精确布局(例如,为了不安全的初始化)。</target>
        </trans-unit>
        <trans-unit id="6234c814e87094f91726f24487a4768fa303bb49" translate="yes" xml:space="preserve">
          <source>The trait is unsafe because implementers must uphold additional safety properties. See &lt;a href=&quot;trait.sourceiter#tymethod.as_inner&quot;&gt;&lt;code&gt;as_inner&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd4884c0b4bf389a086599eb28e009d3c721bad" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf58bfdb142c3e3e2fca00b9412242993f764d14" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;code&gt;Searcher&lt;/code&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">特征本身可以充当关联的 &lt;code&gt;Searcher&lt;/code&gt; 类型的构建器，后者可以实际查找字符串中模式的出现。</target>
        </trans-unit>
        <trans-unit id="4f44d782a6ca223ce6d84156fccfcf74f2f98110" translate="yes" xml:space="preserve">
          <source>The trait with a supertrait is called a &lt;strong&gt;subtrait&lt;/strong&gt; of its supertrait.</source>
          <target state="translated">具有超特征的特征称为其&lt;strong&gt;超&lt;/strong&gt;特征的子特征。</target>
        </trans-unit>
        <trans-unit id="d7357f4482763332c4dcdb5f743346a154d2e9c6" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt; and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">在性状&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt;用于超负荷&lt;a href=&quot;expressions/operator-expr&quot;&gt;运营&lt;/a&gt;，&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;索引表达式&lt;/a&gt;和&lt;a href=&quot;expressions/call-expr&quot;&gt;调用表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ada4715a52a3666c1e6ea1e317fd6cc2974a5b0" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt;, and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43292c5d9ba5055790b8cc673c3ce1d90efd4b3" translate="yes" xml:space="preserve">
          <source>The traits in this module are often used as trait bounds for generic functions such that to arguments of multiple types are supported. See the documentation of each trait for examples.</source>
          <target state="translated">本模块中的特质通常被用作通用函数的特质边界,这样就可以支持多个类型的参数。请参阅每个特质的文档中的例子。</target>
        </trans-unit>
        <trans-unit id="bbf2160d65d5756f9a6fd20c174d5b77d26006ee" translate="yes" xml:space="preserve">
          <source>The traits in this module provide a way to convert from one type to another type. Each trait serves a different purpose:</source>
          <target state="translated">本模块中的特质提供了一种从一种类型转换到另一种类型的方法。每个特征都有不同的用途。</target>
        </trans-unit>
        <trans-unit id="be87d5e421f146f48239b20f0b61521f853fc415" translate="yes" xml:space="preserve">
          <source>The transmitting end has a &lt;code&gt;send&lt;/code&gt; method that takes the value we want to send. The &lt;code&gt;send&lt;/code&gt; method returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, so if the receiving end has already been dropped and there&amp;rsquo;s nowhere to send a value, the send operation will return an error. In this example, we&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.</source>
          <target state="translated">发送端有一个 &lt;code&gt;send&lt;/code&gt; 方法，它采用我们要发送的值。所述 &lt;code&gt;send&lt;/code&gt; 方法返回一个 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 类型，因此，如果该接收端已经下降，有无处送的值，则发送操作将返回错误。在此示例中，我们将在发生错误时调用 &lt;code&gt;unwrap&lt;/code&gt; 进行恐慌。但是在实际的应用程序中，我们会正确地处理它：返回第9章，回顾正确处理错误的策略。</target>
        </trans-unit>
        <trans-unit id="358565a5dd8811594d3e7971e93dfbda2791693b" translate="yes" xml:space="preserve">
          <source>The tuple pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3273a21950fc06ce8b8962828961e34d0be457" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过在其内部值上调用 &lt;code&gt;&amp;gt;&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="de2c6ddac182efa31cffea571db9b44146fe9838" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过调用其内部值 &lt;code&gt;&amp;gt;=&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="9c699eaaa968f03f7073bd19cfb4a4bc4c553e9a" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过在其内部值上调用 &lt;code&gt;&amp;lt;&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="169dd7de97da6fed33fb4c7fffa1d0926634fd12" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过对它们的内部值调用 &lt;code&gt;&amp;lt;=&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="4559f811138e10e2014d510114ff2517b250941f" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过在其内部值上调用 &lt;code&gt;cmp()&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="39163b76dc0823f8bfd4c0f4a8969c804a3f8075" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;partial_cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过调用其内部值的 &lt;code&gt;partial_cmp()&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="a9f918beee4f5cf9d1253c5c05628d38cf96954a" translate="yes" xml:space="preserve">
          <source>The two configurations available are:</source>
          <target state="translated">现有的两种配置是:</target>
        </trans-unit>
        <trans-unit id="450583e125671dcb6a167d6b29518dd2bf3867fb" translate="yes" xml:space="preserve">
          <source>The two kinds of declaration statements are item declarations and &lt;code&gt;let&lt;/code&gt; statements.</source>
          <target state="translated">两种声明语句是项声明和 &lt;code&gt;let&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="29e11129b6c15c504dcd359f5946098de2a818e8" translate="yes" xml:space="preserve">
          <source>The two main protocols involved in web servers are the &lt;em&gt;Hypertext Transfer Protocol&lt;/em&gt;&lt;em&gt;(HTTP)&lt;/em&gt; and the &lt;em&gt;Transmission Control Protocol&lt;/em&gt;&lt;em&gt;(TCP)&lt;/em&gt;. Both protocols are &lt;em&gt;request-response&lt;/em&gt; protocols, meaning a &lt;em&gt;client&lt;/em&gt; initiates requests and a &lt;em&gt;server&lt;/em&gt; listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.</source>
          <target state="translated">Web服务器中涉及的两个主要协议是&lt;em&gt;超文本传输​​协议&lt;/em&gt;&lt;em&gt;（HTTP）&lt;/em&gt;和&lt;em&gt;传输控制协议&lt;/em&gt;&lt;em&gt;（TCP）&lt;/em&gt;。两种协议都是&lt;em&gt;请求-响应&lt;/em&gt;协议，这意味着&lt;em&gt;客户端&lt;/em&gt;发起请求，&lt;em&gt;服务器&lt;/em&gt;监听请求并向客户端提供响应。这些请求和响应的内容由协议定义。</target>
        </trans-unit>
        <trans-unit id="203df10027d062d490c4fbf35780fe4d1eed13fd" translate="yes" xml:space="preserve">
          <source>The two most common ways to evaluate an iterator are to use a &lt;code&gt;for&lt;/code&gt; loop like this, or using the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">评估迭代器的两种最常见方法是使用这样的 &lt;code&gt;for&lt;/code&gt; 循环，或使用&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;方法产生新的集合。</target>
        </trans-unit>
        <trans-unit id="f0616989ceb9af09d65c6d30395a15645c3fb4ed" translate="yes" xml:space="preserve">
          <source>The two new lines are:</source>
          <target state="translated">这两条新线是:</target>
        </trans-unit>
        <trans-unit id="e483fee205c9c53971b14b5a333e04a44a6db99b" translate="yes" xml:space="preserve">
          <source>The two pointed-to values may overlap. If the values do overlap, then the overlapping region of memory from &lt;code&gt;x&lt;/code&gt; will be used. This is demonstrated in the second example below.</source>
          <target state="translated">两个指向的值可能会重叠。如果值确实重叠，则将使用 &lt;code&gt;x&lt;/code&gt; 的内存重叠区域。下面的第二个示例对此进行了说明。</target>
        </trans-unit>
        <trans-unit id="7540e3538a7ee2b354c6ad5eceba51e063d25c18" translate="yes" xml:space="preserve">
          <source>The two slices returned go from the start of the string slice to &lt;code&gt;mid&lt;/code&gt;, and from &lt;code&gt;mid&lt;/code&gt; to the end of the string slice.</source>
          <target state="translated">返回的两个切片从字符串切片的开始到 &lt;code&gt;mid&lt;/code&gt; ，从字符串切片的 &lt;code&gt;mid&lt;/code&gt; 到结尾。</target>
        </trans-unit>
        <trans-unit id="643186e43b6d06589052d125f62e5365b9c9a558" translate="yes" xml:space="preserve">
          <source>The two threads continue alternating, but the main thread waits because of the call to &lt;code&gt;handle.join()&lt;/code&gt; and does not end until the spawned thread is finished.</source>
          <target state="translated">这两个线程继续交替，但是主线程由于对 &lt;code&gt;handle.join()&lt;/code&gt; 的调用而等待，直到生成的线程完成后才结束。</target>
        </trans-unit>
        <trans-unit id="6005b5c0e8b9fae85cf0f2f496cddef96188c2e3" translate="yes" xml:space="preserve">
          <source>The two values of the boolean type are written &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">布尔类型的两个值分别写为 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b6bd47b4f42af9e321626a41d3ac1a949889256" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same allocation in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372e682a79086a952e254015d9198d707b3497b2" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same value in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">类型&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;提供了在堆中分配的类型 &lt;code&gt;T&lt;/code&gt; 的值的共享所有权。在&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;会产生一个指向堆中相同值的新指针。当指向给定值的最后一个&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针被破坏时，指向的值也被破坏。</target>
        </trans-unit>
        <trans-unit id="061bd0bf671c2d672c454254d90151c86753f8be" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same allocation on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e13391af6d4685735ce2468fa0b2df950149996" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same value on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">类型 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 提供了在堆中分配的类型 &lt;code&gt;T&lt;/code&gt; 的值的共享所有权。在 &lt;code&gt;Arc&lt;/code&gt; 上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;会产生一个新的 &lt;code&gt;Arc&lt;/code&gt; 实例，该实例在堆上指向与源 &lt;code&gt;Arc&lt;/code&gt; 相同的值，同时增加引用计数。当指向给定值的最后一个 &lt;code&gt;Arc&lt;/code&gt; 指针被破坏时，指向的值也被破坏。</target>
        </trans-unit>
        <trans-unit id="c30f5ce28986d51c472e8b2cb793889a1cf9299e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Cow&lt;/code&gt; is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the &lt;code&gt;Borrow&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Cow&lt;/code&gt; 类型是一种智能指针，提供了写时克隆功能：它可以封装并提供对借入数据的不变访问，并在需要突变或所有权时懒惰地克隆数据。该类型旨在通过 &lt;code&gt;Borrow&lt;/code&gt; 特征与一般借用数据一起使用。</target>
        </trans-unit>
        <trans-unit id="9f7d7514bdc86a24a5ff52dd05fe5c13a9b5c0e6" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Item&lt;/code&gt; is a placeholder type, and the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s definition shows that it will return values of type &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt;. Implementors of the &lt;code&gt;Iterator&lt;/code&gt; trait will specify the concrete type for &lt;code&gt;Item&lt;/code&gt;, and the &lt;code&gt;next&lt;/code&gt; method will return an &lt;code&gt;Option&lt;/code&gt; containing a value of that concrete type.</source>
          <target state="translated">&lt;code&gt;Item&lt;/code&gt; 类型是一个占位符类型， &lt;code&gt;next&lt;/code&gt; 方法的定义表明它将返回 &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt; 类型的值。 &lt;code&gt;Iterator&lt;/code&gt; 特性的实现者将为 &lt;code&gt;Item&lt;/code&gt; 指定具体类型， &lt;code&gt;next&lt;/code&gt; 方法将返回包含该具体类型值的 &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b50c152c5140d221fbe925adaec14a20d6c4527c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Self&lt;/code&gt; acts as an alias to the type of the current trait implementer, or &quot;receiver type&quot;. Besides the already mentioned &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt; and &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; valid receiver types, the following are also valid: &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt;, and &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; (where P is one of the previous types except &lt;code&gt;Self&lt;/code&gt;). Note that &lt;code&gt;Self&lt;/code&gt; can also be the underlying implementing type, like &lt;code&gt;Foo&lt;/code&gt; in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f527297d32ae3d914332f31c2f8f0967b4e336" translate="yes" xml:space="preserve">
          <source>The type alias helps in two ways: it makes code easier to write &lt;em&gt;and&lt;/em&gt; it gives us a consistent interface across all of &lt;code&gt;std::io&lt;/code&gt;. Because it&amp;rsquo;s an alias, it&amp;rsquo;s just another &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which means we can use any methods that work on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with it, as well as special syntax like the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">类型别名有两个方面的帮助：它使代码更易于编写&lt;em&gt;，&lt;/em&gt;并且为我们提供了贯穿所有 &lt;code&gt;std::io&lt;/code&gt; 的一致接口。因为它是别名，所以它只是另一个 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ，这意味着我们可以使用对 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 起作用的任何方法，以及诸如 &lt;code&gt;?&lt;/code&gt; 的特殊语法。操作员。</target>
        </trans-unit>
        <trans-unit id="ea0e2aaa51d45e0a422d27f3c58e30936523ccce" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors.</source>
          <target state="translated">这里需要使用类型注释 &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; ，因为它可以 &lt;code&gt;collect&lt;/code&gt; 到许多不同的数据结构中，并且Rust除非您指定，否则不知道您想要哪个。但是，对于键和值类型的参数，我们使用下划线，Rust可以根据向量中数据的类型推断哈希映射包含的类型。</target>
        </trans-unit>
        <trans-unit id="19887ad86a95d19b831c6b68bb5aee99f3125dcd" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors. In Listing 8-21, the key type will be &lt;code&gt;String&lt;/code&gt; and the value type will be &lt;code&gt;i32&lt;/code&gt;, just as the types were in Listing 8-20.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf52c33ab9420faf47eea0ae86189b509c83d56" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in the previous code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a3cc90dfa59efcb3be0ad0da5e31c3b001a903" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in this example:</source>
          <target state="translated">类型定义包含一些字段，其类型需要一个有效期的注释。生存期注释（例如 &lt;code&gt;T: 'a&lt;/code&gt; ）用于确保T中的所有数据至少在生存期 &lt;code&gt;'a&lt;/code&gt; 内有效。当该类型包含关联的类型引用（例如 &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; ，通常会出现这种情况，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="fc99bc0924bfaeb5da14796b8d2b7f81fb11367e" translate="yes" xml:space="preserve">
          <source>The type does not fulfill the required lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9c0bf21d5e45e81b33f072a97367bb2e667f29" translate="yes" xml:space="preserve">
          <source>The type must have the &lt;code&gt;Sync&lt;/code&gt; trait bound to allow thread-safe access.</source>
          <target state="translated">该类型必须绑定 &lt;code&gt;Sync&lt;/code&gt; 特性，以允许线程安全访问。</target>
        </trans-unit>
        <trans-unit id="5761684433f543db118c22f7a347176798eaf3c5" translate="yes" xml:space="preserve">
          <source>The type name should not be considered a unique identifier of a type; multiple types may share the same type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abd0fc7da623f26ad9fecceeea94f5bfc1f633a" translate="yes" xml:space="preserve">
          <source>The type name used is not in scope.</source>
          <target state="translated">使用的类型名称不在范围内。</target>
        </trans-unit>
        <trans-unit id="89e2360bf1d9e23be29f6ad88e266a77e3f4f82f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;guess&lt;/code&gt; in this code would have to be an integer &lt;em&gt;and&lt;/em&gt; a string, and Rust requires that &lt;code&gt;guess&lt;/code&gt; have only one type. So what does &lt;code&gt;continue&lt;/code&gt; return? How were we allowed to return a &lt;code&gt;u32&lt;/code&gt; from one arm and have another arm that ends with &lt;code&gt;continue&lt;/code&gt; in Listing 19-26?</source>
          <target state="translated">此代码中的 &lt;code&gt;guess&lt;/code&gt; 类型必须是整数&lt;em&gt;和&lt;/em&gt;字符串，Rust要求该 &lt;code&gt;guess&lt;/code&gt; 只有一种类型。那么， &lt;code&gt;continue&lt;/code&gt; 返回什么呢？在清单19-26中，如何允许我们从一个手臂返回 &lt;code&gt;u32&lt;/code&gt; 并让另一个手臂以 &lt;code&gt;continue&lt;/code&gt; 结尾？</target>
        </trans-unit>
        <trans-unit id="ae6cd25ffa500de06212f0c2207844d88b02a6be" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;s&lt;/code&gt; here is &lt;code&gt;&amp;amp;str&lt;/code&gt;: it&amp;rsquo;s a slice pointing to that specific point of the binary. This is also why string literals are immutable; &lt;code&gt;&amp;amp;str&lt;/code&gt; is an immutable reference.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 的类型是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ：它是指向二进制文件的特定点的切片。这也是字符串文字不可变的原因。 &lt;code&gt;&amp;amp;str&lt;/code&gt; 是不可变的引用。</target>
        </trans-unit>
        <trans-unit id="34ca2b2668ed637a52d925af5ee324f0385b2620" translate="yes" xml:space="preserve">
          <source>The type of a block is the type of the final expression, or &lt;code&gt;()&lt;/code&gt; if the final expression is omitted.</source>
          <target state="translated">块的类型是最终表达式的类型，如果省略了最终表达式，则为 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04575cb944f5ba2523fe623e2ff7231ff81edabc" translate="yes" xml:space="preserve">
          <source>The type of a const parameter references other generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed47b86a36c39f67b1e05de4464008d8a1956f2c" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; floating-point literal is determined by type inference:</source>
          <target state="translated">不带&lt;em&gt;后缀的&lt;/em&gt;浮点文字的类型由类型推断确定：</target>
        </trans-unit>
        <trans-unit id="6114cd343a30b85f17666d6fd494268587f7b8ea" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; integer literal is determined by type inference:</source>
          <target state="translated">无&lt;em&gt;后缀&lt;/em&gt;整数文字的类型由类型推断确定：</target>
        </trans-unit>
        <trans-unit id="89c2fbc4e2ada9abaa3500c6a37ddee8522542e8" translate="yes" xml:space="preserve">
          <source>The type of the discriminant, which must satisfy the trait bounds required by &lt;code&gt;mem::Discriminant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d869126e3c264254879784374ee68ec03547b9" translate="yes" xml:space="preserve">
          <source>The type of the elements being iterated over.</source>
          <target state="translated">被迭代的元素的类型。</target>
        </trans-unit>
        <trans-unit id="af8245e533db8494bb30cc9dc28768887bbb8570" translate="yes" xml:space="preserve">
          <source>The type of the value that &lt;code&gt;File::open&lt;/code&gt; returns inside the &lt;code&gt;Err&lt;/code&gt; variant is &lt;code&gt;io::Error&lt;/code&gt;, which is a struct provided by the standard library. This struct has a method &lt;code&gt;kind&lt;/code&gt; that we can call to get an &lt;code&gt;io::ErrorKind&lt;/code&gt; value. The enum &lt;code&gt;io::ErrorKind&lt;/code&gt; is provided by the standard library and has variants representing the different kinds of errors that might result from an &lt;code&gt;io&lt;/code&gt; operation. The variant we want to use is &lt;code&gt;ErrorKind::NotFound&lt;/code&gt;, which indicates the file we&amp;rsquo;re trying to open doesn&amp;rsquo;t exist yet. So we match on &lt;code&gt;f&lt;/code&gt;, but we also have an inner match on &lt;code&gt;error.kind()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 在 &lt;code&gt;Err&lt;/code&gt; 变量内部返回的值的类型是 &lt;code&gt;io::Error&lt;/code&gt; ，这是标准库提供的结构。该结构具有一种方法 &lt;code&gt;kind&lt;/code&gt; ，我们可以调用该方法类型以获得 &lt;code&gt;io::ErrorKind&lt;/code&gt; 值。枚举 &lt;code&gt;io::ErrorKind&lt;/code&gt; 由标准库提供，并且具有表示 &lt;code&gt;io&lt;/code&gt; 操作可能导致的各种错误的变体。我们要使用的变体是 &lt;code&gt;ErrorKind::NotFound&lt;/code&gt; ，它指示我们要打开的文件尚不存在。因此，我们在 &lt;code&gt;f&lt;/code&gt; 上进行匹配，但在 &lt;code&gt;error.kind()&lt;/code&gt; 上也进行了内部匹配。</target>
        </trans-unit>
        <trans-unit id="545510a669763ef63063641881497bf7dd3f481a" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as failed.</source>
          <target state="translated">该值被视为失败时的类型。</target>
        </trans-unit>
        <trans-unit id="8b60f120f0bca222851815dfc6ed07a4a0520575" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as successful.</source>
          <target state="translated">此值的类型,当视为成功。</target>
        </trans-unit>
        <trans-unit id="bf039a86046c9f49aceed05895007223ced0c5ff" translate="yes" xml:space="preserve">
          <source>The type of value produced on completion.</source>
          <target state="translated">完成时产生的价值类型。</target>
        </trans-unit>
        <trans-unit id="16751927675b4a2fde8980932985c3b025559cb0" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns.</source>
          <target state="translated">该生成器返回的值的类型。</target>
        </trans-unit>
        <trans-unit id="bf293514c386bb6e45033b7b50e4549a332b83ad" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此生成器返回的值的类型。&lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcbd5cd653d3daa61c5d5d30831f8972d04f844c" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此生成器返回的值的类型。&lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5e0eda41ab22396cfa2f1334045d1746f855426" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields.</source>
          <target state="translated">这个发生器产生的值的类型。</target>
        </trans-unit>
        <trans-unit id="b8cb8237cc8b58247dbdfe05ac4618d5ded726d1" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">该生成器产生的值的类型。&lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="becf5070fa5e52c8db7c1d497d6f97d2d8cc4f48" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">该生成器产生的值的类型。&lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="586fe8d7efe2a1acc6c511b646a3a08c88efbb26" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;T&lt;/code&gt; represents the data that this lock protects. It is required that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; to be shared across threads and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; to allow concurrent access through readers. The RAII guards returned from the locking methods implement &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;write&lt;/code&gt; methods) to allow access to the content of the lock.</source>
          <target state="translated">类型参数 &lt;code&gt;T&lt;/code&gt; 表示此锁保护的数据。要求 &lt;code&gt;T&lt;/code&gt; 满足&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;要在线程之间共享和&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;以允许通过读取器并发访问。从锁定方法返回的RAII防护实现了&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;（对于 &lt;code&gt;write&lt;/code&gt; 方法，则使用&lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;）以允许访问锁的内容。</target>
        </trans-unit>
        <trans-unit id="f6f9ae50a3ab94a8cf9005786a7b9af006ffe517" translate="yes" xml:space="preserve">
          <source>The type parameters can also be explicitly supplied in a trailing &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt;.</source>
          <target state="translated">类型参数也可以在函数名称之后的尾随&lt;a href=&quot;../paths&quot;&gt;路径&lt;/a&gt;组件中显式提供。如果没有足够的上下文来确定类型参数，则可能有必要。例如， &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="618c44497e554625efd295f7702914ef5292c792" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; can be used outside item's signature as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2931173dcc6550d705628d261c402eccc53232" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; was used within a type on an item's signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d805f97c85ceb05a75d626e5740cb0e2204f44" translate="yes" xml:space="preserve">
          <source>The type returned by formatter methods.</source>
          <target state="translated">由formatter方法返回的类型。</target>
        </trans-unit>
        <trans-unit id="1c16d9adfa415d1c3d1e4550b932c426a82800c2" translate="yes" xml:space="preserve">
          <source>The type returned in the event of a conversion error.</source>
          <target state="translated">发生转换错误时返回的类型。</target>
        </trans-unit>
        <trans-unit id="2d7863bb088ba575c630ae75df049f3bc518eb6c" translate="yes" xml:space="preserve">
          <source>The type that the &lt;code&gt;else&lt;/code&gt; blocks evaluate to must be compatible with the type that the &lt;code&gt;if&lt;/code&gt; block evaluates to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e8d68133a2235c54df1609c3fa9dc8e972aa60" translate="yes" xml:space="preserve">
          <source>The type to return is inferred from context; this is equivalent to &lt;code&gt;Default::default()&lt;/code&gt; but shorter to type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b611879bfea657d3652c629b736393c4b650211" translate="yes" xml:space="preserve">
          <source>The type you are trying to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; for is not a struct. &lt;code&gt;CoerceUnsized&lt;/code&gt; can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of &lt;code&gt;CoerceUnsized&lt;/code&gt; whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">您尝试 &lt;code&gt;CoerceUnsized&lt;/code&gt; 的类型不是结构。 &lt;code&gt;CoerceUnsized&lt;/code&gt; 只能对结构实现。无需执行 &lt;code&gt;CoerceUnsized&lt;/code&gt; 的实现，就可以强制未大小类型，而包含未大小类型的结构需要知道其包含的未大小类型字段是否可以被强制。一个&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;未施胶类型&lt;/a&gt;是任何类型的，该编译器不知道在编译时间的长度或对准。包含未调整大小类型的任何结构也是未调整大小的。</target>
        </trans-unit>
        <trans-unit id="63c27305b7150da660772855aa4571d697d89b10" translate="yes" xml:space="preserve">
          <source>The type you can compare with is controlled by &lt;code&gt;PartialEq&lt;/code&gt;'s type parameter. For example, let's tweak our previous code a bit:</source>
          <target state="translated">您可以比较的类型由 &lt;code&gt;PartialEq&lt;/code&gt; 的type参数控制。例如，让我们稍微调整一下之前的代码：</target>
        </trans-unit>
        <trans-unit id="93ef2caad28212460c75d9146f8dc4d0899b2d98" translate="yes" xml:space="preserve">
          <source>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</source>
          <target state="translated">类型检查员需要知道一个表达式的类型,但该类型还没有被推断出来。</target>
        </trans-unit>
        <trans-unit id="f584bedf990c038f22247101ab8b097fb3a593e8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;*const T&lt;/code&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; all have the same size. If &lt;code&gt;T&lt;/code&gt; is Sized, all of those types have the same size as &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;*const T&lt;/code&gt; ， &lt;code&gt;&amp;amp;T&lt;/code&gt; ， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 全部具有相同的尺寸。如果 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;usize&lt;/code&gt; ，则所有这些类型的大小都与usize相同。</target>
        </trans-unit>
        <trans-unit id="5722d857751fd92f7cd76388f248410597abc535" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; hold textual data.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 类型保存文本数据。</target>
        </trans-unit>
        <trans-unit id="99894423e354dd0b37e0c9ced81c62b48fcf23b2" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff52a3715390889940af516c60b08b678feeadf3" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition. This error indicates that there was a mismatch.</source>
          <target state="translated">特质实现中任何相关常量的类型必须与特质定义中的类型相匹配。该错误表明存在不匹配的情况。</target>
        </trans-unit>
        <trans-unit id="2a9653c2b160c32821b432c07707efaa597921f1" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;Arc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取 &lt;code&gt;Weak&lt;/code&gt; 指针的典型方法是调用&lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;Arc::downgrade&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7670bf148a2a36a6287e0959f849df36450aeea" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;Rc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取 &lt;code&gt;Weak&lt;/code&gt; 指针的典型方法是调用&lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;Rc::downgrade&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e38264f429668f9c24babca8440ad652db0e6325" translate="yes" xml:space="preserve">
          <source>The unary logical negation operator &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">一元逻辑否定运算符 &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6144b29ea1cdce68ecac471463a0fdc0639b34f9" translate="yes" xml:space="preserve">
          <source>The unary negation operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">一元求反运算符 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7181a66c31dbb848d4da8d3e96055db8ae78d130" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;struct.metadata&quot;&gt;&lt;code&gt;Metadata&lt;/code&gt;&lt;/a&gt; struct needs to be retrieved with the &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt; function and not the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function follows symbolic links, so &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt; would always return &lt;code&gt;false&lt;/code&gt; for the target file.</source>
          <target state="translated">需要使用&lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt;函数而不是&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;函数来检索基础&lt;a href=&quot;struct.metadata&quot;&gt; &lt;code&gt;Metadata&lt;/code&gt; &lt;/a&gt;结构。该&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;功能如下符号链接，所以&lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt;总是会返回 &lt;code&gt;false&lt;/code&gt; 目标文件。</target>
        </trans-unit>
        <trans-unit id="5ba52bb287979fcbe21a62414e5cba80ede6c6c5" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can never be mutably borrowed from again and will always appear already immutably borrowed. It is not a good idea to leak more than a constant number of references. The &lt;code&gt;RefCell&lt;/code&gt; can be immutably borrowed again if only a smaller number of leaks have occurred in total.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16573dc48843cb6201240052d6b60dde180482de" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can not be borrowed from again and will always appear already mutably borrowed, making the returned reference the only to the interior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485a92064bc4fcb63908fa7e1b3b1ad970b9f88b" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; will remain mutably borrowed until both returned &lt;code&gt;RefMut&lt;/code&gt;s go out of scope.</source>
          <target state="translated">基础 &lt;code&gt;RefCell&lt;/code&gt; 将保持可变借用状态，直到返回的两个 &lt;code&gt;RefMut&lt;/code&gt; 都超出范围。</target>
        </trans-unit>
        <trans-unit id="9efa2c9dbfc51e4660e725c77fd7efb185f3f6ff" translate="yes" xml:space="preserve">
          <source>The underlying value can be retrieved through the &lt;code&gt;.0&lt;/code&gt; index of the &lt;code&gt;Wrapping&lt;/code&gt; tuple.</source>
          <target state="translated">可以通过 &lt;code&gt;Wrapping&lt;/code&gt; 元组的 &lt;code&gt;.0&lt;/code&gt; 索引检索基础值。</target>
        </trans-unit>
        <trans-unit id="1be4ec15824529c7ce6527861e8c2980ac38212f" translate="yes" xml:space="preserve">
          <source>The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to &lt;code&gt;_&lt;/code&gt; imports. For example, the following should not produce an error:</source>
          <target state="translated">宏扩展后会创建唯一的，无法命名的符号，以便宏可以安全地发出对 &lt;code&gt;_&lt;/code&gt; 导入的多个引用。例如，以下内容不应产生错误：</target>
        </trans-unit>
        <trans-unit id="f4f440ca9518cd96f0fe9c31f85a61d77e18e0f3" translate="yes" xml:space="preserve">
          <source>The unsafe counterpart of this macro is the &lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;unreachable_unchecked&lt;/code&gt;&lt;/a&gt; function, which will cause undefined behavior if the code is reached.</source>
          <target state="translated">此宏的不安全对应项是&lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;unreachable_unchecked&lt;/code&gt; &lt;/a&gt;函数，如果到达代码，它将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c1a83814a7bcbd2091dc90767bec8f24c5d3f1e3" translate="yes" xml:space="preserve">
          <source>The unsigned integer types consist of:</source>
          <target state="translated">无符号整数类型包括:</target>
        </trans-unit>
        <trans-unit id="2d2ce136339d709e77fd2d67b03ff1b69af40d44" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (exclusive).</source>
          <target state="translated">幅度的上界(不含)。</target>
        </trans-unit>
        <trans-unit id="20d82b105410f2577709f06e6539062262a0ca81" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (inclusive)</source>
          <target state="translated">幅度的上限(包括)</target>
        </trans-unit>
        <trans-unit id="e68185f2e9603472a1563c4f776b66b2c6a3b822" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; keyword in this position allows the function writer to hide the concrete type as an implementation detail which can change without breaking user's code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cef1794b05feb8ec892ea4cd89efe908da35c8" translate="yes" xml:space="preserve">
          <source>The user could always interrupt the program by using the keyboard shortcut ctrl-c. But there&amp;rsquo;s another way to escape this insatiable monster, as mentioned in the &lt;code&gt;parse&lt;/code&gt; discussion in &lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt;: if the user enters a non-number answer, the program will crash. The user can take advantage of that in order to quit, as shown here:</source>
          <target state="translated">用户可以始终使用键盘快捷键ctrl-c中断程序。但是，还有另一种逃避这种无法满足的怪物的方法，如&lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;将猜测与秘密数字进行比较&amp;rdquo;&lt;/a&gt;的 &lt;code&gt;parse&lt;/code&gt; 讨论中所提到的：如果用户输入非数字答案，则程序将崩溃。用户可以利用它来退出，如下所示：</target>
        </trans-unit>
        <trans-unit id="e62c088fdd6cf7f93babb9263d9008d71eaadccf" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to perform &lt;code&gt;metadata&lt;/code&gt; call on &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">用户缺乏在 &lt;code&gt;path&lt;/code&gt; 上执行 &lt;code&gt;metadata&lt;/code&gt; 调用的权限。</target>
        </trans-unit>
        <trans-unit id="0dc65bb53b7876e2a52ec0de6c50b31a471724ba" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the directory at the provided &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">用户没有权限在提供的 &lt;code&gt;path&lt;/code&gt; 删除目录。</target>
        </trans-unit>
        <trans-unit id="4ed8999bb1ca133f6f343fbba9eb07d31db22560" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the file.</source>
          <target state="translated">该用户缺乏删除文件的权限。</target>
        </trans-unit>
        <trans-unit id="da243dceea5f741ec03e2474a95470f701358e02" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to view contents.</source>
          <target state="translated">用户没有查看内容的权限。</target>
        </trans-unit>
        <trans-unit id="a0ceecf91cf3de088e4866146d667401fc9825c7" translate="yes" xml:space="preserve">
          <source>The user lacks the permission to change attributes of the file.</source>
          <target state="translated">用户缺乏改变文件属性的权限。</target>
        </trans-unit>
        <trans-unit id="0728943e3f9e2dd60ac0860b5efc3c86277bbcf8" translate="yes" xml:space="preserve">
          <source>The user of &lt;code&gt;from_raw&lt;/code&gt; has to make sure a specific value of &lt;code&gt;T&lt;/code&gt; is only dropped once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc0d661ff73b2e7b2da5a4e28c09493dbabbf98" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;to_drop&lt;/code&gt; points to must be valid for dropping, which may mean it must uphold additional invariants - this is type-dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef61ff6808c20e3aee33111c7be00b7f9eb3ce9" translate="yes" xml:space="preserve">
          <source>The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.</source>
          <target state="translated">被胁迫的值是实际参数,它被胁迫到形式参数的类型。</target>
        </trans-unit>
        <trans-unit id="a4543ae96f3c210a98b1abf8fa6e1fffb99a3a60" translate="yes" xml:space="preserve">
          <source>The value contained in the &lt;code&gt;Result::Err&lt;/code&gt; variant is the value the thread panicked with; that is, the argument the &lt;code&gt;panic!&lt;/code&gt; macro was called with. Unlike with normal errors, this value doesn't implement the &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5a7553814237ff25467a69b929b269b579c5c7" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;push&lt;/code&gt; is an expected cost; the method documentation gives a more detailed analysis.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 的价值是预期成本；方法文档提供了更详细的分析。</target>
        </trans-unit>
        <trans-unit id="7655c33f10da48be510d779b36c1473fc0c444da" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by adding a postfix &lt;code&gt;$&lt;/code&gt;, indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7971e26c81d228c6b498e7c0267b27f63e3a2f0" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by using the dollar syntax indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width, for example:</source>
          <target state="translated">对于宽度的值也可以被提供为&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;通过使用指示所述第二参数是一个美元语法中的参数列表&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;指定宽度，例如：</target>
        </trans-unit>
        <trans-unit id="a708656013343fb0ab99fafd8d21e4229d39b962" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">该值可以是集合值类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与该值类型的值匹配。</target>
        </trans-unit>
        <trans-unit id="6f10fa6eb368dac898013f2276c185e31dd968d4" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">该值可以是集合值类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与该值类型的值匹配。</target>
        </trans-unit>
        <trans-unit id="cc1bf7113b6ffebee8a5cbda9953ce0f46aa8389" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the value type.</source>
          <target state="translated">该值可以是集合值类型的任何借位形式，但是借位形式上的顺序&lt;em&gt;必须&lt;/em&gt;与值类型上的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="5386004ae808f6aad83668aa6e791c4916959b45" translate="yes" xml:space="preserve">
          <source>The value must not be zero.</source>
          <target state="translated">该值不得为零。</target>
        </trans-unit>
        <trans-unit id="72b7ccc4c541479713442aeb6f9117133107de5e" translate="yes" xml:space="preserve">
          <source>The value must:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1619fc66fbf6e80510234756b7616df221cbcc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;N&lt;/code&gt; that was specified for &lt;code&gt;repr(align(N))&lt;/code&gt; was not a power of two, or was greater than 2^29.</source>
          <target state="translated">为 &lt;code&gt;repr(align(N))&lt;/code&gt; 指定的 &lt;code&gt;N&lt;/code&gt; 的值不是2的幂，或者大于2 ^ 29。</target>
        </trans-unit>
        <trans-unit id="744a6000b03885b8f256f7629c96527779c5f909" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;upper_i&lt;/code&gt; here relies on the language of the text: if we're in &lt;code&gt;en-US&lt;/code&gt;, it should be &lt;code&gt;&quot;I&quot;&lt;/code&gt;, but if we're in &lt;code&gt;tr_TR&lt;/code&gt;, it should be &lt;code&gt;&quot;İ&quot;&lt;/code&gt;. &lt;code&gt;to_uppercase()&lt;/code&gt; does not take this into account, and so:</source>
          <target state="translated">这里的 &lt;code&gt;upper_i&lt;/code&gt; 的值取决于文本的语言：如果我们在 &lt;code&gt;en-US&lt;/code&gt; 中，则应为 &lt;code&gt;&quot;I&quot;&lt;/code&gt; ，但如果我们在 &lt;code&gt;tr_TR&lt;/code&gt; 中，则应为 &lt;code&gt;&quot;İ&quot;&lt;/code&gt; 。 &lt;code&gt;to_uppercase()&lt;/code&gt; 没有考虑到这一点，因此：</target>
        </trans-unit>
        <trans-unit id="5ddda6614ea7e3e67438b2aae41a24ac0eb3ff50" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b739d6552c67cec966b03a294f348b71a38926c7" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time. Erroneous code example:</source>
          <target state="translated">静态和常量的值必须在编译时知道,它们在程序的整个生命周期中都是存在的。创建一个框定值会在运行时在堆上分配内存,因此不能在编译时进行。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="4b2ff9e347c3c08ba8e806ad69a147ed48871d42" translate="yes" xml:space="preserve">
          <source>The value returned is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; but does not flush the internal buffer. Due to this optimization the function does not guarantee that calling &lt;code&gt;.into_inner()&lt;/code&gt; immediately afterwards will yield the underlying reader at the same position. Use &lt;a href=&quot;struct.bufreader#method.seek&quot;&gt;&lt;code&gt;BufReader::seek&lt;/code&gt;&lt;/a&gt; instead if you require that guarantee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c061cf746d3ba8e95a5a5598de09efb58fb7b8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; has type &lt;code&gt;String&lt;/code&gt;, and its use in the guard is as a variable of type &lt;code&gt;String&lt;/code&gt;. The guard code effectively executes in a separate scope to the body of the arm, so the value would be moved into this anonymous scope and therefore becomes unavailable in the body of the arm.</source>
          <target state="translated">变量 &lt;code&gt;s&lt;/code&gt; 的类型为 &lt;code&gt;String&lt;/code&gt; ，它在防护中的用途为 &lt;code&gt;String&lt;/code&gt; 类型的变量。保护代码有效地在手臂主体的单独范围内执行，因此该值将移至该匿名范围，因此在手臂主体中变得不可用。</target>
        </trans-unit>
        <trans-unit id="8e557a8691f00e33607a16e96773df5a29940a13" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it&amp;rsquo;s declared until the end of the current &lt;em&gt;scope&lt;/em&gt;. Listing 4-1 has comments annotating where the variable &lt;code&gt;s&lt;/code&gt; is valid.</source>
          <target state="translated">变量 &lt;code&gt;s&lt;/code&gt; 表示字符串文字，其中字符串的值被硬编码到程序的文本中。从声明变量到当前&lt;em&gt;范围&lt;/em&gt;的结尾，变量一直有效。清单4-1带有注释，说明变量 &lt;code&gt;s&lt;/code&gt; 在何处有效。</target>
        </trans-unit>
        <trans-unit id="5e699bc2ac5d00c87b2c7f3b8e3a9da4a553a5d0" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;tup&lt;/code&gt; binds to the entire tuple, because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</source>
          <target state="translated">变量 &lt;code&gt;tup&lt;/code&gt; 绑定到整个元组，因为元组被视为单个复合元素。为了从元组中取出单个值，我们可以使用模式匹配来破坏元组值，如下所示：</target>
        </trans-unit>
        <trans-unit id="b81aa2b0402a0e499f7595712bef15edfd23e380" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; doesn&amp;rsquo;t &amp;ldquo;live long enough.&amp;rdquo; The reason is that &lt;code&gt;x&lt;/code&gt; will be out of scope when the inner scope ends on line 7. But &lt;code&gt;r&lt;/code&gt; is still valid for the outer scope; because its scope is larger, we say that it &amp;ldquo;lives longer.&amp;rdquo; If Rust allowed this code to work, &lt;code&gt;r&lt;/code&gt; would be referencing memory that was deallocated when &lt;code&gt;x&lt;/code&gt; went out of scope, and anything we tried to do with &lt;code&gt;r&lt;/code&gt; wouldn&amp;rsquo;t work correctly. So how does Rust determine that this code is invalid? It uses a borrow checker.</source>
          <target state="translated">变量 &lt;code&gt;x&lt;/code&gt; 的寿命不足。原因是当内部范围在第7行结束时， &lt;code&gt;x&lt;/code&gt; 将不在范围内。但是 &lt;code&gt;r&lt;/code&gt; 对于外部范围仍然有效；因为它的范围更大，所以我们说它的寿命更长。如果Rust允许此代码工作，则 &lt;code&gt;r&lt;/code&gt; 将引用 &lt;code&gt;x&lt;/code&gt; 超出范围时已释放的内存，而我们尝试使用 &lt;code&gt;r&lt;/code&gt; 进行的任何操作均将无法正常工作。那么Rust如何确定该代码无效呢？它使用借阅检查器。</target>
        </trans-unit>
        <trans-unit id="b4588e360f79d1cb0e5f79f31bf6e7bc2ece8336" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; holds an &lt;code&gt;i32&lt;/code&gt; value, &lt;code&gt;5&lt;/code&gt;. We set &lt;code&gt;y&lt;/code&gt; equal to a reference to &lt;code&gt;x&lt;/code&gt;. We can assert that &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;5&lt;/code&gt;. However, if we want to make an assertion about the value in &lt;code&gt;y&lt;/code&gt;, we have to use &lt;code&gt;*y&lt;/code&gt; to follow the reference to the value it&amp;rsquo;s pointing to (hence &lt;em&gt;dereference&lt;/em&gt;). Once we dereference &lt;code&gt;y&lt;/code&gt;, we have access to the integer value &lt;code&gt;y&lt;/code&gt; is pointing to that we can compare with &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">变量 &lt;code&gt;x&lt;/code&gt; 拥有 &lt;code&gt;i32&lt;/code&gt; 值 &lt;code&gt;5&lt;/code&gt; 。我们将 &lt;code&gt;y&lt;/code&gt; 设置为等于 &lt;code&gt;x&lt;/code&gt; 的引用。我们可以断言 &lt;code&gt;x&lt;/code&gt; 等于 &lt;code&gt;5&lt;/code&gt; 。但是，如果要对 &lt;code&gt;y&lt;/code&gt; 中的值进行断言，则必须使用 &lt;code&gt;*y&lt;/code&gt; 跟随对它指向的值的&lt;em&gt;引用&lt;/em&gt;（因此&lt;em&gt;取消引用&lt;/em&gt;）。一旦取消引用 &lt;code&gt;y&lt;/code&gt; ，就可以访问 &lt;code&gt;y&lt;/code&gt; 所指向的整数，该整数可以与 &lt;code&gt;5&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="b7511a7213b8989f428e5bec2c5234f95d46bda2" translate="yes" xml:space="preserve">
          <source>The variables that a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; captures by move are dropped in an unspecified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f517012aa2f18b099c9314a6c9154f5976be9a45" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">其他 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;enum&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 和tuple类型的方差是通过查看其字段类型的方差来确定的。如果参数用于具有不同方差的位置，则参数是不变的。例如，以下结构在 &lt;code&gt;'a&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 中是协变的，而在 &lt;code&gt;'b&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 中是不变的。</target>
        </trans-unit>
        <trans-unit id="edea3e36560d105a970958779d2fd8e9db94e633" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0eb1ade80b4414ebb3db98e5e4492d2cfa8b829" translate="yes" xml:space="preserve">
          <source>The vector used to create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a9da86bd97667912e395039b2e850ba36a8d1a" translate="yes" xml:space="preserve">
          <source>The vector will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the vector will not allocate.</source>
          <target state="translated">该向量将能够精确地 &lt;code&gt;capacity&lt;/code&gt; 元素而无需重新分配。如果 &lt;code&gt;capacity&lt;/code&gt; 为0，则不会分配向量。</target>
        </trans-unit>
        <trans-unit id="4a1a063010e523349572dfe2f3d4599fdbf7faf0" translate="yes" xml:space="preserve">
          <source>The vector will not allocate until elements are pushed onto it.</source>
          <target state="translated">在元素被推送到向量上之前,向量不会进行分配。</target>
        </trans-unit>
        <trans-unit id="4d0b594b3c2a18ead8ab96882d29be04515f3b55" translate="yes" xml:space="preserve">
          <source>The version numbering scheme is explained in &lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;Unicode 11.0 or later, Section 3.1 Versions of the Unicode Standard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be7c75604b320ccdf03b29c2cf5dc9816b16f93" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;http://www.unicode.org/&quot;&gt;Unicode&lt;/a&gt; that the Unicode parts of &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods are based on.</source>
          <target state="translated">版本&lt;a href=&quot;http://www.unicode.org/&quot;&gt;的Unicode&lt;/a&gt;说的Unicode部分 &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 方法基础上的。</target>
        </trans-unit>
        <trans-unit id="2e7d7937a98ae8b5db75096586d34257981a3b35" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a by-value receiver.</source>
          <target state="translated">呼叫运营商的版本,采取按值接收。</target>
        </trans-unit>
        <trans-unit id="98bb0c84eb64933810db44150740704106b58e5b" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a mutable receiver.</source>
          <target state="translated">调用操作符的版本,接受一个可变的接收器。</target>
        </trans-unit>
        <trans-unit id="a10ea779af62c4002732377426c5466fd9b100f8" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes an immutable receiver.</source>
          <target state="translated">呼叫运营商的版本,采取的是不可更改的接收机。</target>
        </trans-unit>
        <trans-unit id="69df36660018fe57f4bfd6fa17c4ad5d9397540f" translate="yes" xml:space="preserve">
          <source>The volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt;].</source>
          <target state="translated">易失性内在函数提供旨在作用于I / O内存的操作，这些操作保证编译器不会跨其他易失性内在函数对它们进行重新排序。请参阅[ &lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt; ] 上的LLVM文档。</target>
        </trans-unit>
        <trans-unit id="3879e8ab569a056c97968189092bda667116aee8" translate="yes" xml:space="preserve">
          <source>The volatile parameter is set to &lt;code&gt;true&lt;/code&gt;, so it will not be optimized out unless size is equal to zero.</source>
          <target state="translated">volatile参数设置为 &lt;code&gt;true&lt;/code&gt; ，因此除非大小等于零，否则不会对其进行优化。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
