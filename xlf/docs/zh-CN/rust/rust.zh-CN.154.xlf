<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="5927f0d5ac8801b4254d8379327d991a701a80da" translate="yes" xml:space="preserve">
          <source>Truncates or extends the underlying file, updating the size of this file to become &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">截断或扩展基础文件，将该文件的大小更新为 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2702cfbf0e58f8f82fb23e8d650e499d7cc927c5" translate="yes" xml:space="preserve">
          <source>Truncates the &lt;code&gt;OsString&lt;/code&gt; to zero length.</source>
          <target state="translated">将 &lt;code&gt;OsString&lt;/code&gt; 截断为零长度。</target>
        </trans-unit>
        <trans-unit id="ed28d8bdecc758ddcef76eed8b86ffa1d4ea3181" translate="yes" xml:space="preserve">
          <source>Truncates this &lt;code&gt;String&lt;/code&gt;, removing all contents.</source>
          <target state="translated">截断此 &lt;code&gt;String&lt;/code&gt; ，删除所有内容。</target>
        </trans-unit>
        <trans-unit id="5474aa5946c713a1f6e7a033ad591db623edd6d3" translate="yes" xml:space="preserve">
          <source>Truncating a five element vector to two elements:</source>
          <target state="translated">将一个五元素向量截断为两个元素。</target>
        </trans-unit>
        <trans-unit id="743f01c9ef69fe480785553858265deba678132e" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">当 &lt;code&gt;len == 0&lt;/code&gt; 时截断等效于调用&lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7b9f4a78a76c6893e05b1ff011a47211505551b2" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">当 &lt;code&gt;len == 0&lt;/code&gt; 时截断等效于调用&lt;a href=&quot;struct.vec#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="63908c3dcfc457f07a333b89f52c763024b846da" translate="yes" xml:space="preserve">
          <source>TrustedLen</source>
          <target state="translated">TrustedLen</target>
        </trans-unit>
        <trans-unit id="72677028b4d0d41af475041fdbe030f7c7146d2c" translate="yes" xml:space="preserve">
          <source>Try</source>
          <target state="translated">Try</target>
        </trans-unit>
        <trans-unit id="93cacc9f6a162523f52bc4401526c741faac95a0" translate="yes" xml:space="preserve">
          <source>Try designing more experiments that vary the values and lifetimes of the references passed in to the &lt;code&gt;longest&lt;/code&gt; function and how the returned reference is used. Make hypotheses about whether or not your experiments will pass the borrow checker before you compile; then check to see if you&amp;rsquo;re right!</source>
          <target state="translated">尝试设计更多的实验，以改变传递给 &lt;code&gt;longest&lt;/code&gt; 函数的引用的值和生存期，以及如何使用返回的引用。假设您的实验在编译之前是否会通过借阅检查器；然后检查您是否正确！</target>
        </trans-unit>
        <trans-unit id="b25651affa48a09fef804a246293a9441327deef" translate="yes" xml:space="preserve">
          <source>Try making a request from a different browser or asking for a different address, such as &lt;em&gt;127.0.0.1:7878/test&lt;/em&gt;, to see how the request data changes.</source>
          <target state="translated">尝试从其他浏览器发出请求或请求其他地址，例如&lt;em&gt;127.0.0.1:7878/test&lt;/em&gt;，以查看请求数据的变化。</target>
        </trans-unit>
        <trans-unit id="3cdedf03df7f2d7ff7f62a3fe4c0233e49c2605a" translate="yes" xml:space="preserve">
          <source>Try modifying &lt;code&gt;Cacher&lt;/code&gt; to hold a hash map rather than a single value. The keys of the hash map will be the &lt;code&gt;arg&lt;/code&gt; values that are passed in, and the values of the hash map will be the result of calling the closure on that key. Instead of looking at whether &lt;code&gt;self.value&lt;/code&gt; directly has a &lt;code&gt;Some&lt;/code&gt; or a &lt;code&gt;None&lt;/code&gt; value, the &lt;code&gt;value&lt;/code&gt; function will look up the &lt;code&gt;arg&lt;/code&gt; in the hash map and return the value if it&amp;rsquo;s present. If it&amp;rsquo;s not present, the &lt;code&gt;Cacher&lt;/code&gt; will call the closure and save the resulting value in the hash map associated with its &lt;code&gt;arg&lt;/code&gt; value.</source>
          <target state="translated">尝试修改 &lt;code&gt;Cacher&lt;/code&gt; 以保存哈希图，而不是单个值。哈希图的键将是传入的 &lt;code&gt;arg&lt;/code&gt; 值，哈希图的值将是对该键调用闭包的结果。而不是查看 &lt;code&gt;self.value&lt;/code&gt; 是否直接具有 &lt;code&gt;Some&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; 值， &lt;code&gt;value&lt;/code&gt; 函数将在哈希映射中查找 &lt;code&gt;arg&lt;/code&gt; 并返回该值（如果存在）。如果不存在，则 &lt;code&gt;Cacher&lt;/code&gt; 将调用该闭包，并将结果值保存在与其 &lt;code&gt;arg&lt;/code&gt; 值关联的哈希图中。</target>
        </trans-unit>
        <trans-unit id="746db25e46725d2a25a5be38541b8fd90c0e318e" translate="yes" xml:space="preserve">
          <source>Try running the program a few times:</source>
          <target state="translated">试着运行该程序几次。</target>
        </trans-unit>
        <trans-unit id="40db21ca976b20c4f1a37614a766d7e0fedff356" translate="yes" xml:space="preserve">
          <source>Try running this code; you should see the following output:</source>
          <target state="translated">试着运行这段代码;你应该看到以下输出。</target>
        </trans-unit>
        <trans-unit id="0c704dff8c8947b24bdb19d42ed1933021fa9b51" translate="yes" xml:space="preserve">
          <source>Try running this program with the &lt;code&gt;main&lt;/code&gt; function from Listing 13-2. Change the values in the &lt;code&gt;simulated_user_specified_value&lt;/code&gt; and &lt;code&gt;simulated_random_number&lt;/code&gt; variables to verify that in all the cases in the various &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks, &lt;code&gt;calculating slowly...&lt;/code&gt; appears only once and only when needed. The &lt;code&gt;Cacher&lt;/code&gt; takes care of the logic necessary to ensure we aren&amp;rsquo;t calling the expensive calculation more than we need to so &lt;code&gt;generate_workout&lt;/code&gt; can focus on the business logic.</source>
          <target state="translated">尝试使用清单13-2中的 &lt;code&gt;main&lt;/code&gt; 函数运行该程序。更改 &lt;code&gt;simulated_user_specified_value&lt;/code&gt; 和 &lt;code&gt;simulated_random_number&lt;/code&gt; 变量中的值，以验证在各种情况下，在各种 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块中， &lt;code&gt;calculating slowly...&lt;/code&gt; 仅在需要时才出现一次。该 &lt;code&gt;Cacher&lt;/code&gt; 采取必要的逻辑的谨慎，以确保我们不是要求昂贵的计算比我们更需要这样 &lt;code&gt;generate_workout&lt;/code&gt; 可以专注于业务逻辑。</target>
        </trans-unit>
        <trans-unit id="f64954535b22680cee23c59284f0821d313912c5" translate="yes" xml:space="preserve">
          <source>Try running this program; you should get the following output:</source>
          <target state="translated">试着运行这个程序,你应该得到以下输出。</target>
        </trans-unit>
        <trans-unit id="4e2f79e768da3d333677b7768aba6698b9473abe" translate="yes" xml:space="preserve">
          <source>Try the tasks suggested for additional requirements that we mentioned at the start of this section on the &lt;code&gt;blog&lt;/code&gt; crate as it is after Listing 17-20 to see what you think about the design of this version of the code. Note that some of the tasks might be completed already in this design.</source>
          <target state="translated">在清单17-20之后，尝试在 &lt;code&gt;blog&lt;/code&gt; 板箱本节开头提到的建议的任务，以了解其他要求，以了解您对该版本代码的设计有何看法。请注意，某些任务可能已在此设计中完成。</target>
        </trans-unit>
        <trans-unit id="bea7aa5241bc934fb93d73fbe72c3c92fd9cb391" translate="yes" xml:space="preserve">
          <source>Try this instead:</source>
          <target state="translated">试试这个吧</target>
        </trans-unit>
        <trans-unit id="cf4dffd1f17e87d4131fe9dbd6ed3566366e3295" translate="yes" xml:space="preserve">
          <source>Try to avoid moving the variable.</source>
          <target state="translated">尽量避免移动变量。</target>
        </trans-unit>
        <trans-unit id="708f496ce718cad5f2bfb9c2203cb73e375d06e0" translate="yes" xml:space="preserve">
          <source>Try to create the target number type from a source number type. This returns an error if the source value is outside of the range of the target type.</source>
          <target state="translated">尝试从源数字类型创建目标数字类型。如果源值在目标类型的范围之外,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="d7bb54d91c5813615d6b6445e2ebf488e82cdc0c" translate="yes" xml:space="preserve">
          <source>Try using &lt;code&gt;{}&lt;/code&gt; instead:</source>
          <target state="translated">尝试改用 &lt;code&gt;{}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8a1eb6a4114d62537aa281f5d03abf55ba6e9e3" translate="yes" xml:space="preserve">
          <source>Try using type inference instead. Example:</source>
          <target state="translated">尝试使用类型推理来代替。例如:</target>
        </trans-unit>
        <trans-unit id="ea0079401a89dd04fe8291c0c734d4aa5a8c7177" translate="yes" xml:space="preserve">
          <source>Try::from_error</source>
          <target state="translated">Try::from_error</target>
        </trans-unit>
        <trans-unit id="bde6f44b7e04bd6491a07ffb037c4fa48b882a33" translate="yes" xml:space="preserve">
          <source>Try::from_ok</source>
          <target state="translated">Try::from_ok</target>
        </trans-unit>
        <trans-unit id="809111dd75695d75905fa1c8b4bad5d14691a30e" translate="yes" xml:space="preserve">
          <source>Try::into_result</source>
          <target state="translated">Try::into_result</target>
        </trans-unit>
        <trans-unit id="18e77d4b44ff639060d9a2fa2960f190781f7859" translate="yes" xml:space="preserve">
          <source>TryFrom</source>
          <target state="translated">TryFrom</target>
        </trans-unit>
        <trans-unit id="4acc1ac1c58ab4ae6724001d461baf2c8b8dbc3a" translate="yes" xml:space="preserve">
          <source>TryFrom::try_from</source>
          <target state="translated">TryFrom::try_from</target>
        </trans-unit>
        <trans-unit id="ad96c601815ad5f050e0b6351dd0b189e48a31a9" translate="yes" xml:space="preserve">
          <source>TryFromIntError</source>
          <target state="translated">TryFromIntError</target>
        </trans-unit>
        <trans-unit id="f81061adcf59a4b18f6432dc500e16b9a793d0e6" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow</source>
          <target state="translated">TryFromIntError::borrow</target>
        </trans-unit>
        <trans-unit id="4d5e6ded3e6e6a7b69de27e74b52df8d33085625" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow_mut</source>
          <target state="translated">TryFromIntError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8c6ac7bc7b08a0164c28c84e181d07ac7264caa1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::cause</source>
          <target state="translated">TryFromIntError::cause</target>
        </trans-unit>
        <trans-unit id="f0da83cb703ff9ab478400076f17fb3b6df58453" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone</source>
          <target state="translated">TryFromIntError::clone</target>
        </trans-unit>
        <trans-unit id="21c991dfc7c9f46d0f223e9ada6bbb1b3ddc0419" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_from</source>
          <target state="translated">TryFromIntError::clone_from</target>
        </trans-unit>
        <trans-unit id="611f56282230f313fea840ae9d1b4022b318faec" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_into</source>
          <target state="translated">TryFromIntError::clone_into</target>
        </trans-unit>
        <trans-unit id="05df18eb5e5e51ad418c603a8c9e45f939b7afa0" translate="yes" xml:space="preserve">
          <source>TryFromIntError::description</source>
          <target state="translated">TryFromIntError::description</target>
        </trans-unit>
        <trans-unit id="cffa72c79f028d8b2b67ac3b5a88fa8e893445f1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::eq</source>
          <target state="translated">TryFromIntError::eq</target>
        </trans-unit>
        <trans-unit id="7ec29ac29b26af4ad4e22c908d20f04e34123009" translate="yes" xml:space="preserve">
          <source>TryFromIntError::fmt</source>
          <target state="translated">TryFromIntError::fmt</target>
        </trans-unit>
        <trans-unit id="27af3cbe1fc043a4ba2263a1ddb04f43ed3341d8" translate="yes" xml:space="preserve">
          <source>TryFromIntError::from</source>
          <target state="translated">TryFromIntError::from</target>
        </trans-unit>
        <trans-unit id="88b0ca4bd6e97295df88042c17da3bc4ad1d1e49" translate="yes" xml:space="preserve">
          <source>TryFromIntError::into</source>
          <target state="translated">TryFromIntError::into</target>
        </trans-unit>
        <trans-unit id="b590493dab8454ef91bc8263edc4d90474ae7585" translate="yes" xml:space="preserve">
          <source>TryFromIntError::ne</source>
          <target state="translated">TryFromIntError::ne</target>
        </trans-unit>
        <trans-unit id="34bc40cbf452f309c77160c0bc046a559d512c4c" translate="yes" xml:space="preserve">
          <source>TryFromIntError::source</source>
          <target state="translated">TryFromIntError::source</target>
        </trans-unit>
        <trans-unit id="4650111711913011245aed1cfd4e401bf80b92bd" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_owned</source>
          <target state="translated">TryFromIntError::to_owned</target>
        </trans-unit>
        <trans-unit id="145d38c6294ea7b0b18a9beaf5c2ba62d71c6d31" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_string</source>
          <target state="translated">TryFromIntError::to_string</target>
        </trans-unit>
        <trans-unit id="3bd074fd7b824eb16d5c009603fefee21d967354" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_from</source>
          <target state="translated">TryFromIntError::try_from</target>
        </trans-unit>
        <trans-unit id="2a66975e8a4a9df97b01eea79b97edba1ce4fc13" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_into</source>
          <target state="translated">TryFromIntError::try_into</target>
        </trans-unit>
        <trans-unit id="853b95e029b9b10b04426ea41bce22a33cadfde3" translate="yes" xml:space="preserve">
          <source>TryFromIntError::type_id</source>
          <target state="translated">TryFromIntError::type_id</target>
        </trans-unit>
        <trans-unit id="f7ae979f3e3e5c6883cf562acec4a3d8911ff6b7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError</source>
          <target state="translated">TryFromSliceError</target>
        </trans-unit>
        <trans-unit id="08abda7dda4132c13ad2de215a8116ad1c512693" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow</source>
          <target state="translated">TryFromSliceError::borrow</target>
        </trans-unit>
        <trans-unit id="a42a16b656b3e78ad3c1fba788c25cca8562aa04" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow_mut</source>
          <target state="translated">TryFromSliceError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6b154dc43d23a695abe3c26c810c9600a10bbfc7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::cause</source>
          <target state="translated">TryFromSliceError::cause</target>
        </trans-unit>
        <trans-unit id="06c3cdee5b115341587a81b7640e380fd15333ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone</source>
          <target state="translated">TryFromSliceError::clone</target>
        </trans-unit>
        <trans-unit id="a4d48a9b9f7dd5e07e2bb398d2d1029a5b1eb76b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_from</source>
          <target state="translated">TryFromSliceError::clone_from</target>
        </trans-unit>
        <trans-unit id="faf3d5f757e37a47d1e58275eb48efaa726218ad" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_into</source>
          <target state="translated">TryFromSliceError::clone_into</target>
        </trans-unit>
        <trans-unit id="49619f8bf5df143f7d9e552904f6a84fca8093ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::description</source>
          <target state="translated">TryFromSliceError::description</target>
        </trans-unit>
        <trans-unit id="fc484006f6aa38bffa40eb517d8b4b32091a5671" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::fmt</source>
          <target state="translated">TryFromSliceError::fmt</target>
        </trans-unit>
        <trans-unit id="630dd1955f1b733df02d2f1446cd6b9ba9cd293b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::from</source>
          <target state="translated">TryFromSliceError::from</target>
        </trans-unit>
        <trans-unit id="2a5519380aabe238e175f9b6849d0a2d7f53c5a8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::into</source>
          <target state="translated">TryFromSliceError::into</target>
        </trans-unit>
        <trans-unit id="b1ef9a7f4941a7c7fc1ee4d269c0be752b4049c1" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::source</source>
          <target state="translated">TryFromSliceError::source</target>
        </trans-unit>
        <trans-unit id="46b791fdfec792bbb13fbb3115a245caecffc0d8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_owned</source>
          <target state="translated">TryFromSliceError::to_owned</target>
        </trans-unit>
        <trans-unit id="04f8529255b3a3ba17e31837ca350fb03a1837a0" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_string</source>
          <target state="translated">TryFromSliceError::to_string</target>
        </trans-unit>
        <trans-unit id="d39f8030ca01a81b1eedd289678e98a9a8c6374d" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_from</source>
          <target state="translated">TryFromSliceError::try_from</target>
        </trans-unit>
        <trans-unit id="87b56d5270282ca8cea8f2ae22fb393b6ef2e185" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_into</source>
          <target state="translated">TryFromSliceError::try_into</target>
        </trans-unit>
        <trans-unit id="273ef45502220a3e82cc6cd2ff47d1b967ced192" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::type_id</source>
          <target state="translated">TryFromSliceError::type_id</target>
        </trans-unit>
        <trans-unit id="eb91bb9edb358310d1de44ff46dcb50ed3d4dbf6" translate="yes" xml:space="preserve">
          <source>TryInto</source>
          <target state="translated">TryInto</target>
        </trans-unit>
        <trans-unit id="d4782bb6e82830853df5d390b765742f2ed433ce" translate="yes" xml:space="preserve">
          <source>TryInto::try_into</source>
          <target state="translated">TryInto::try_into</target>
        </trans-unit>
        <trans-unit id="d550a8f93a6fe62cffc66481db4e53166b4de9e5" translate="yes" xml:space="preserve">
          <source>TryIter</source>
          <target state="translated">TryIter</target>
        </trans-unit>
        <trans-unit id="b4f81b18947056193693e5cce08cae5bcc996cf1" translate="yes" xml:space="preserve">
          <source>TryLockError</source>
          <target state="translated">TryLockError</target>
        </trans-unit>
        <trans-unit id="6408d526dcb04978c761f176b4b48253f6e2b3a3" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow</source>
          <target state="translated">TryLockError::borrow</target>
        </trans-unit>
        <trans-unit id="c1162b670a7e56c24667fd355cb74c01579b66f6" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow_mut</source>
          <target state="translated">TryLockError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="645caaf83340c9e36066d5283df40d2289f0c56a" translate="yes" xml:space="preserve">
          <source>TryLockError::cause</source>
          <target state="translated">TryLockError::cause</target>
        </trans-unit>
        <trans-unit id="edc35be2771c53d502f5e8aaee878dd2e15d3b5a" translate="yes" xml:space="preserve">
          <source>TryLockError::description</source>
          <target state="translated">TryLockError::description</target>
        </trans-unit>
        <trans-unit id="c6f2c000c844249e646527b009bb44e488eef5e5" translate="yes" xml:space="preserve">
          <source>TryLockError::fmt</source>
          <target state="translated">TryLockError::fmt</target>
        </trans-unit>
        <trans-unit id="9001bf82d878e70373f04e6654b0f776179b2f53" translate="yes" xml:space="preserve">
          <source>TryLockError::from</source>
          <target state="translated">TryLockError::from</target>
        </trans-unit>
        <trans-unit id="655a2e7bdf752d14f5354358dacab8b46b5c1b0d" translate="yes" xml:space="preserve">
          <source>TryLockError::into</source>
          <target state="translated">TryLockError::into</target>
        </trans-unit>
        <trans-unit id="e4ccb09bacf6984439f523c7aecac39df9844058" translate="yes" xml:space="preserve">
          <source>TryLockError::source</source>
          <target state="translated">TryLockError::source</target>
        </trans-unit>
        <trans-unit id="c61e09fc91fbcfa81bcf718beb714ea63719b4eb" translate="yes" xml:space="preserve">
          <source>TryLockError::to_string</source>
          <target state="translated">TryLockError::to_string</target>
        </trans-unit>
        <trans-unit id="ebcde8097671e82bd0e812397421ce3e5f83aa6a" translate="yes" xml:space="preserve">
          <source>TryLockError::try_from</source>
          <target state="translated">TryLockError::try_from</target>
        </trans-unit>
        <trans-unit id="7b92cc07d0ee9b28099cb947d6053805d66baac1" translate="yes" xml:space="preserve">
          <source>TryLockError::try_into</source>
          <target state="translated">TryLockError::try_into</target>
        </trans-unit>
        <trans-unit id="904eaeeceb270dd726f594af3ac7324866060774" translate="yes" xml:space="preserve">
          <source>TryLockError::type_id</source>
          <target state="translated">TryLockError::type_id</target>
        </trans-unit>
        <trans-unit id="7d779fd6e34ddc3c9ecd145e12eaab2707fb88f2" translate="yes" xml:space="preserve">
          <source>TryLockResult</source>
          <target state="translated">TryLockResult</target>
        </trans-unit>
        <trans-unit id="b00cb1382a524b91c7b6f872f909018a2ba2fcdb" translate="yes" xml:space="preserve">
          <source>TryRecvError</source>
          <target state="translated">TryRecvError</target>
        </trans-unit>
        <trans-unit id="ffa19b2195d0c15e9339c99460878fe4f010d76d" translate="yes" xml:space="preserve">
          <source>TryReserveError</source>
          <target state="translated">TryReserveError</target>
        </trans-unit>
        <trans-unit id="7b782adc98cd68cba60f49733fd7fc4e8ce78c2c" translate="yes" xml:space="preserve">
          <source>TrySendError</source>
          <target state="translated">TrySendError</target>
        </trans-unit>
        <trans-unit id="bb111acc067364e9c3571b77d0ce5c4a9c6b3124" translate="yes" xml:space="preserve">
          <source>Trying to implement this scenario using our definition of &lt;code&gt;List&lt;/code&gt; with &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; won&amp;rsquo;t work, as shown in Listing 15-17:</source>
          <target state="translated">尝试使用我们的定义来实现这个场景 &lt;code&gt;List&lt;/code&gt; 与 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 将无法正常工作，如清单15-17：</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="5518f0873d902287241e5e83188a303861d5a9e6" translate="yes" xml:space="preserve">
          <source>Tuple Layout</source>
          <target state="translated">元组布局</target>
        </trans-unit>
        <trans-unit id="11dd41e6851bdf449646a773272c37c50a284fc9" translate="yes" xml:space="preserve">
          <source>Tuple and tuple indexing expressions</source>
          <target state="translated">元组和元组索引表达式</target>
        </trans-unit>
        <trans-unit id="6bdf2a89da03771b9bc590f650c8c5b6c77c5197" translate="yes" xml:space="preserve">
          <source>Tuple expression</source>
          <target state="translated">元组表达式</target>
        </trans-unit>
        <trans-unit id="a63a11d9cdfd9d84d9c0b5569d554b9e83dcf1cc" translate="yes" xml:space="preserve">
          <source>Tuple expression attributes</source>
          <target state="translated">元组表达式属性</target>
        </trans-unit>
        <trans-unit id="e822aa7ad790f9164d76dd24bd82039b2ac65758" translate="yes" xml:space="preserve">
          <source>Tuple expressions</source>
          <target state="translated">元组表达式</target>
        </trans-unit>
        <trans-unit id="49e52f54a16d5e893978d9d7c233cca906e4a8cd" translate="yes" xml:space="preserve">
          <source>Tuple expressions are written by listing the &lt;a href=&quot;../expressions&quot;&gt;operands&lt;/a&gt; in a parenthesized, comma-separated list. 1-ary tuple expressions require a comma after their operand to be disambiguated with a &lt;a href=&quot;grouped-expr&quot;&gt;parenthetical expression&lt;/a&gt;.</source>
          <target state="translated">通过在括号括起来的逗号分隔列表中列出&lt;a href=&quot;../expressions&quot;&gt;操作数&lt;/a&gt;来编写元组表达式。1进制元组的表达式需要一个逗号之后与一个被消除歧义操作数的&lt;a href=&quot;grouped-expr&quot;&gt;括号表达&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65e413cd44223377d7cfb3699dad2f2341e4e6ba" translate="yes" xml:space="preserve">
          <source>Tuple expressions evaluate into &lt;a href=&quot;../types/tuple&quot;&gt;tuple values&lt;/a&gt; with the operands initializing the elements of the tuple.</source>
          <target state="translated">元组表达式通过将&lt;a href=&quot;../types/tuple&quot;&gt;元组&lt;/a&gt;的元素初始化为操作数来求值成元组值。</target>
        </trans-unit>
        <trans-unit id="f601e94cafc9d12d8593dd02c6d703d40de35c4d" translate="yes" xml:space="preserve">
          <source>Tuple index</source>
          <target state="translated">元组索引</target>
        </trans-unit>
        <trans-unit id="b17e1ada42d80816617817c68a5ec792352c6c67" translate="yes" xml:space="preserve">
          <source>Tuple index expressions are written as an operand, &lt;code&gt;.&lt;/code&gt;, and a tuple index. The index must be written as a &lt;a href=&quot;../tokens#integer-literals&quot;&gt;decimal literal&lt;/a&gt; with no leading zeros, underscores, or suffix. The operand must have the type of a tuple or tuple struct. If the tuple index is not an element of the tuple or tuple struct, it is a compiler error.</source>
          <target state="translated">元组索引表达式被写为操作数 &lt;code&gt;.&lt;/code&gt; ，以及元组索引。索引必须写成&lt;a href=&quot;../tokens#integer-literals&quot;&gt;十进制文字&lt;/a&gt;，没有前导零，下划线或后缀。操作数必须具有元组或元组结构的类型。如果元组索引不是元组或元组结构的元素，则是编译器错误。</target>
        </trans-unit>
        <trans-unit id="fe6c1f43b44b32fa35dca7937a6775d19792506c" translate="yes" xml:space="preserve">
          <source>Tuple indexing</source>
          <target state="translated">元组索引</target>
        </trans-unit>
        <trans-unit id="44dc4b3b01b16ad2661df0966d7c7a1cf905b8b9" translate="yes" xml:space="preserve">
          <source>Tuple indexing expressions</source>
          <target state="translated">元组索引表达式</target>
        </trans-unit>
        <trans-unit id="9e4c13ade8d660c6335dcf428421b9b28b1656d1" translate="yes" xml:space="preserve">
          <source>Tuple indexing expressions evaluate like &lt;a href=&quot;field-expr#field-access-expressions&quot;&gt;field access expressions&lt;/a&gt;, but access elements of &lt;a href=&quot;../types/tuple&quot;&gt;tuples&lt;/a&gt; or &lt;a href=&quot;../types/struct&quot;&gt;tuple structs&lt;/a&gt;.</source>
          <target state="translated">元组索引表达式的计算方式类似于&lt;a href=&quot;field-expr#field-access-expressions&quot;&gt;字段访问表达式&lt;/a&gt;，但是&lt;a href=&quot;../types/tuple&quot;&gt;元组&lt;/a&gt;或&lt;a href=&quot;../types/struct&quot;&gt;元组结构的&lt;/a&gt;访问元素。</target>
        </trans-unit>
        <trans-unit id="b8a1d058f14f452a93d10da089ec69f4c32d794e" translate="yes" xml:space="preserve">
          <source>Tuple indices are compared with the literal token directly. Tuple indices start with &lt;code&gt;0&lt;/code&gt; and each successive index increments the value by &lt;code&gt;1&lt;/code&gt; as a decimal value. Thus, only decimal values will match, and the value must not have any extra &lt;code&gt;0&lt;/code&gt; prefix characters.</source>
          <target state="translated">将元组索引直接与文字标记进行比较。元组索引以 &lt;code&gt;0&lt;/code&gt; 开头，每个后续索引将值增加 &lt;code&gt;1&lt;/code&gt; 作为十进制值。因此，仅十进制值将匹配，并且该值不得包含任何额外的 &lt;code&gt;0&lt;/code&gt; 前缀字符。</target>
        </trans-unit>
        <trans-unit id="f28c59e960977888e94a3c34b0278e6e00c6936d" translate="yes" xml:space="preserve">
          <source>Tuple patterns</source>
          <target state="translated">元组模式</target>
        </trans-unit>
        <trans-unit id="49d48b16cda97c82ccd41f82c8b675a2db8b4116" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="translated">元组模式匹配元组值，该元组值匹配其子模式定义的所有条件。它们还用于&lt;a href=&quot;#destructuring&quot;&gt;破坏&lt;/a&gt;元组。</target>
        </trans-unit>
        <trans-unit id="0d60a4a77a7ad9b86665dc5ec42ea14f2698ee75" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="translated">元组模式匹配的元组值与其子模式定义的所有条件均匹配。它们还用于&lt;a href=&quot;patterns#destructuring&quot;&gt;破坏&lt;/a&gt;元组。</target>
        </trans-unit>
        <trans-unit id="f4691e7b0b597791c415f166cd1397c0daec1163" translate="yes" xml:space="preserve">
          <source>Tuple struct expression</source>
          <target state="translated">元组结构表达式</target>
        </trans-unit>
        <trans-unit id="ea9f0838dcbcc88a01e222d90f53e8f39880136f" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns</source>
          <target state="translated">元组结构模式</target>
        </trans-unit>
        <trans-unit id="91a08356932d9cf1d09320f96dfca3ba26d2fc8a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="translated">元组结构模式与元组结构和枚举值匹配，该值与由其子模式定义的所有条件匹配。它们还用于&lt;a href=&quot;#destructuring&quot;&gt;解构&lt;/a&gt;元组结构或枚举值。</target>
        </trans-unit>
        <trans-unit id="6ce23bf97599891184ee6af65a034650dc03427a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="translated">元组结构模式匹配元组结构和枚举值，该值与由其子模式定义的所有条件匹配。它们还用于&lt;a href=&quot;patterns#destructuring&quot;&gt;解构&lt;/a&gt;元组结构或枚举值。</target>
        </trans-unit>
        <trans-unit id="dd28158a620f360ba4aa0c759eb104e4dede6329" translate="yes" xml:space="preserve">
          <source>Tuple structs are instantiated in the same way as tuples themselves, except with the struct's name as a prefix: &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt;.</source>
          <target state="translated">用元组本身的实例化元组结构，除了以结构名作为前缀： &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="985c4283e220405d4d0ac504a38671b8b680d3c5" translate="yes" xml:space="preserve">
          <source>Tuple structs are similar to regular structs, but its fields have no names. They are used like tuples, with deconstruction possible via &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; syntax. For accessing individual variables, the same syntax is used as with regular tuples, namely &lt;code&gt;foo.0&lt;/code&gt;, &lt;code&gt;foo.1&lt;/code&gt;, etc, starting at zero.</source>
          <target state="translated">元组结构与常规结构相似，但是其字段没有名称。它们就像元组一样使用，可以通过 &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; 解构。句法。为了访问各个变量，使用与常规元组相同的语法，即 &lt;code&gt;foo.0&lt;/code&gt; ， &lt;code&gt;foo.1&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="405d7b4bc4604c6657b54f4846e0560006e9fc0e" translate="yes" xml:space="preserve">
          <source>Tuple type</source>
          <target state="translated">元组类型</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">元组类型</target>
        </trans-unit>
        <trans-unit id="5e273646744d8620cb13d8fba10b333bc84bed1e" translate="yes" xml:space="preserve">
          <source>Tuple types and values are denoted by listing the types or values of their elements, respectively, in a parenthesized, comma-separated list.</source>
          <target state="translated">元组类型和值是通过将其元素的类型或值分别列在一个用括号、逗号分隔的列表中来表示的。</target>
        </trans-unit>
        <trans-unit id="a1babd8f3b1a5b3b8804a04ea58994b24b061e4b" translate="yes" xml:space="preserve">
          <source>Tuple types are written by listing the types of their elements in a parenthesized, comma-separated list. 1-ary tuples require a comma after their element type to be disambiguated with a &lt;a href=&quot;../types#parenthesized-types&quot;&gt;parenthesized type&lt;/a&gt;.</source>
          <target state="translated">通过在带括号的逗号分隔列表中列出其元素的类型来编写元组类型。一元组在其元素类型后需要用逗号&lt;a href=&quot;../types#parenthesized-types&quot;&gt;括起来的类型&lt;/a&gt;来消除歧义。</target>
        </trans-unit>
        <trans-unit id="3fbd57dd63bac7c82834159ddc9ea56e1515ece9" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="translated">元组类型，如果每个组件还实现 &lt;code&gt;Clone&lt;/code&gt; （例如 &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;(i32, bool)&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="bd89c408cfdec88fd6d8e898f3566b701ea35d3a" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="translated">的元组类型，如果每个部件还实现 &lt;code&gt;Copy&lt;/code&gt; （例如， &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;(i32, bool)&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="56d624bd930abb83c2a720d48bf858a7d49eb690" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;finite&lt;/em&gt;. In other words, a tuple has a length. Here's a tuple of length &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">元组是&lt;em&gt;有限的&lt;/em&gt;。换句话说，元组具有长度。这是一个长度为 &lt;code&gt;3&lt;/code&gt; 的元组：</target>
        </trans-unit>
        <trans-unit id="4da05b6b2dc1fb19e334d246d97430b523feb378" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;heterogeneous&lt;/em&gt;. This means that each element of the tuple can have a different type. In that tuple above, it has the type:</source>
          <target state="translated">元组是&lt;em&gt;异构的&lt;/em&gt;。这意味着元组的每个元素可以具有不同的类型。在上面的元组中，其类型为：</target>
        </trans-unit>
        <trans-unit id="567f8079007690271f5a29cda47d067992841b99" translate="yes" xml:space="preserve">
          <source>Tuples are a &lt;em&gt;sequence&lt;/em&gt;. This means that they can be accessed by position; this is called 'tuple indexing', and it looks like this:</source>
          <target state="translated">元组是一个&lt;em&gt;序列&lt;/em&gt;。这意味着可以按位置访问它们；这称为&amp;ldquo;元组索引&amp;rdquo;，看起来像这样：</target>
        </trans-unit>
        <trans-unit id="e91ee0fad8731c0386a059fa3bf0652dd08c64d3" translate="yes" xml:space="preserve">
          <source>Tuples are often used as a return type when you want to return more than one value:</source>
          <target state="translated">当你想返回多个值时,Tuple通常被用作返回类型。</target>
        </trans-unit>
        <trans-unit id="d7ee3ba750e08e0013c45b2b001ce78e8459fa90" translate="yes" xml:space="preserve">
          <source>Tuples are written by enclosing zero or more comma-separated expressions in parentheses. They are used to create &lt;a href=&quot;../types/tuple&quot;&gt;tuple-typed&lt;/a&gt; values.</source>
          <target state="translated">通过将零个或多个逗号分隔的表达式括在括号中来编写元组。它们用于创建&lt;a href=&quot;../types/tuple&quot;&gt;元组类型的&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="5fb8ee22cf29120bf8f87bd0e3ee7ebd9949b96b" translate="yes" xml:space="preserve">
          <source>Tuples do not have any guarantees about their layout.</source>
          <target state="translated">图元组对其布局没有任何保证。</target>
        </trans-unit>
        <trans-unit id="e0a1a935961bff4d0e0f65eae726bdf533b1fbc7" translate="yes" xml:space="preserve">
          <source>Tuples, if they only contain types that also implement &lt;code&gt;Copy&lt;/code&gt;. For example, &lt;code&gt;(i32, i32)&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, but &lt;code&gt;(i32, String)&lt;/code&gt; does not.</source>
          <target state="translated">元组（如果它们仅包含也实现 &lt;code&gt;Copy&lt;/code&gt; 的类型）。例如， &lt;code&gt;(i32, i32)&lt;/code&gt; 实现 &lt;code&gt;Copy&lt;/code&gt; ，而 &lt;code&gt;(i32, String)&lt;/code&gt; 不实现。</target>
        </trans-unit>
        <trans-unit id="cf3ce6296bd35ecede807c2ca855fee144afacb9" translate="yes" xml:space="preserve">
          <source>Tuples, if they only contain types that are also &lt;code&gt;Copy&lt;/code&gt;. For example, &lt;code&gt;(i32, i32)&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, but &lt;code&gt;(i32, String)&lt;/code&gt; is not.</source>
          <target state="translated">元组（如果它们仅包含也是 &lt;code&gt;Copy&lt;/code&gt; 的类型）。例如， &lt;code&gt;(i32, i32)&lt;/code&gt; 是 &lt;code&gt;Copy&lt;/code&gt; ，但 &lt;code&gt;(i32, String)&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="f9c67af2890eabc2460069a200a1d4229437528f" translate="yes" xml:space="preserve">
          <source>Tuples, where a tuple is a coercion site to type &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt;. Each sub-expression is a coercion site to the respective type, e.g. the zeroth sub-expression is a coercion site to type &lt;code&gt;U_0&lt;/code&gt;.</source>
          <target state="translated">元组，其中元组是要键入的强制站点 &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt; 。每个子表达式是相应类型的强制站点，例如，第零子表达式是类型 &lt;code&gt;U_0&lt;/code&gt; 的强制站点。</target>
        </trans-unit>
        <trans-unit id="c9853aa9de5add5fa51a4530e193cc7279fd6159" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;../../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;转换为&lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e89ab8db9a13e916878d1aff18816e183dfae8d6" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;变成&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7311ea0eb58a505bdf5f01b88b3339c4b7cd8b3" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;变成&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b38a71dfcaefc79a39b01d00754205648079aa2" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;变成&lt;a href=&quot;../../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fe97f664cc043b9cae686cc00711fc73ef1df08" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;转换为&lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fbea64da5a5f06d75e0a8af0090b3b0e2a08380" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;转换为&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4669fd8f77a02ec1c266c7fe545791bb7885dad1" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;转换为&lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b09625451991a5b8e805da34776aaedc90525fbd" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;变成&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54437abef1f3840afb67899d2d515749e44d9fef" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="translated">将[ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ]转换为[ &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="e6b58be63cc031a2c0fb9a41ef4a5c4c544f30d9" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="translated">将[ &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; ]转换为[ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="68fccb5986b95d1769fe3ac2f5db1e4528fbe17a" translate="yes" xml:space="preserve">
          <source>Turning Our Single-Threaded Server into a Multithreaded Server</source>
          <target state="translated">将我们的单线程服务器变成多线程服务器</target>
        </trans-unit>
        <trans-unit id="b859b7ff96007e824952102a2b6cf7f2532bb6f5" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;*mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut T&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;*mut T&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="92f32c54d91cd32dab86c92433ff5bf59fbe670a" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 变成 &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="25f375d70a4ba87d59382df0fccc95f55dd8020a" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;fn&lt;/code&gt; into a &lt;code&gt;const fn&lt;/code&gt; has no effect on run-time uses of that function.</source>
          <target state="translated">将 &lt;code&gt;fn&lt;/code&gt; 转换为 &lt;code&gt;const fn&lt;/code&gt; 不会对该函数在运行时的使用产生影响。</target>
        </trans-unit>
        <trans-unit id="ddddd1c6a422bfc2e73b1e1e06d4513f4b671ef3" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="translated">将指针变成 &lt;code&gt;usize&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0cfcb75a89ff8f3d42e0969a81b68c58ff41ffed" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a function pointer. This is &lt;em&gt;not&lt;/em&gt; portable to machines where function pointers and data pointers have different sizes.</source>
          <target state="translated">将指针变成函数指针。这对于函数指针和数据指针具有不同大小的机器是&lt;em&gt;不可&lt;/em&gt;移植的。</target>
        </trans-unit>
        <trans-unit id="406e60e2392b6e162c75155bdd0eec0802166101" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut U&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;mut U&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b7709a825d906324651f42904d312bfc3d9cfdce" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;str&lt;/code&gt; into an &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;str&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8fe665706a3a9d23c3f80f786fb6f659e7dafb3b" translate="yes" xml:space="preserve">
          <source>Turning raw bytes(&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;) to &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;f64&lt;/code&gt;, etc.:</source>
          <target state="translated">转到原始字节（ &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; ）至 &lt;code&gt;u32&lt;/code&gt; ， &lt;code&gt;f64&lt;/code&gt; ，等：</target>
        </trans-unit>
        <trans-unit id="45cfabf1744551752d0d316f8226b7949182c80d" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal, even if they are stored in different allocation.</source>
          <target state="translated">即使两个 &lt;code&gt;Arc&lt;/code&gt; 的内部值相等，即使它们存储在不同的分配中，它们也相等。</target>
        </trans-unit>
        <trans-unit id="1e4a5ffe0d58bc942e71a31a403ac137dbf193dd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="translated">如果两个 &lt;code&gt;Arc&lt;/code&gt; 的内部值相等，则它们相等。</target>
        </trans-unit>
        <trans-unit id="3b0340dc9882895d2ed9f18ec41d4ee9ceaf4e0c" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="translated">如果两个 &lt;code&gt;Arc&lt;/code&gt; 的内部值不相等，则它们不相等。</target>
        </trans-unit>
        <trans-unit id="77c963714f423503919254b2ffd83b6fa90a298e" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal, even if they are stored in different allocation.</source>
          <target state="translated">如果两个 &lt;code&gt;Rc&lt;/code&gt; 的内部值相等，则即使它们存储在不同的分配中，它们也是相等的。</target>
        </trans-unit>
        <trans-unit id="d6a2d18514777aaae37a7ce067b908310bbd6b4b" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="translated">如果两个 &lt;code&gt;Rc&lt;/code&gt; 的内部值相等，则它们相等。</target>
        </trans-unit>
        <trans-unit id="2fa5c112e4e91cdb91570c34d930cf27ff1cdefa" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="translated">如果两个 &lt;code&gt;Rc&lt;/code&gt; 的内部值不相等，则它们不相等。</target>
        </trans-unit>
        <trans-unit id="2b4b2f527e82e5d4b1ed0e9743d509787616d686" translate="yes" xml:space="preserve">
          <source>Two associated items (like methods, associated types, associated functions, etc.) were defined with the same identifier.</source>
          <target state="translated">两个关联项(如方法、关联类型、关联函数等)用同一个标识符定义。</target>
        </trans-unit>
        <trans-unit id="f479794ce7a491842f3bc3c9a27aca16db4ad3d3" translate="yes" xml:space="preserve">
          <source>Two empty sequences are lexicographically equal.</source>
          <target state="translated">两个空序列在词法上是相等的。</target>
        </trans-unit>
        <trans-unit id="026acb3ca4aa61acf271a2918c10ebc97e741248" translate="yes" xml:space="preserve">
          <source>Two examples of simple paths consisting of only identifier segments:</source>
          <target state="translated">两个仅由标识符段组成的简单路径的例子。</target>
        </trans-unit>
        <trans-unit id="0cd83d672a615733082e8ee7f56c39b0af561a3e" translate="yes" xml:space="preserve">
          <source>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</source>
          <target state="translated">如果不将其中一个项目重新绑定在新的本地名称下,则无法导入两个同名的项目。</target>
        </trans-unit>
        <trans-unit id="cbb02c3e2b1b62256b2dccb2ec1aec1fddd7391c" translate="yes" xml:space="preserve">
          <source>Two kind of item &lt;em&gt;declarations&lt;/em&gt; are allowed in external blocks: &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt; and &lt;a href=&quot;static-items&quot;&gt;statics&lt;/a&gt;. Calling functions or accessing statics that are declared in external blocks is only allowed in an &lt;code&gt;unsafe&lt;/code&gt; context.</source>
          <target state="translated">外部块中允许使用两种项目&lt;em&gt;声明&lt;/em&gt;：&lt;a href=&quot;functions&quot;&gt;function&lt;/a&gt;和&lt;a href=&quot;static-items&quot;&gt;statics&lt;/a&gt;。仅在 &lt;code&gt;unsafe&lt;/code&gt; 上下文中才允许调用函数或访问在外部块中声明的静态变量。</target>
        </trans-unit>
        <trans-unit id="f6d0f0b6138243f294ae08264cc55ed1bd1ca167" translate="yes" xml:space="preserve">
          <source>Two lifetimes cannot have the same name. To fix this example, change the second &lt;code&gt;'a&lt;/code&gt; lifetime into something else (&lt;code&gt;'c&lt;/code&gt; for example):</source>
          <target state="translated">两个生命周期不能使用相同的名称。要解决此示例，请将第二个 &lt;code&gt;'a&lt;/code&gt; 生存期&amp;rdquo;更改为其他内容（例如， &lt;code&gt;'c&lt;/code&gt; &amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="30c944c513e67b8c4ff5047db8e7ab8f3c379bad" translate="yes" xml:space="preserve">
          <source>Two or more pointers access the same data at the same time.</source>
          <target state="translated">两个或多个指针同时访问同一数据。</target>
        </trans-unit>
        <trans-unit id="ea818e0ad4fe2dcf3d6dd4c02bacf808745d38d6" translate="yes" xml:space="preserve">
          <source>Two possibilities are available to solve this issue:</source>
          <target state="translated">解决这个问题有两种可能。</target>
        </trans-unit>
        <trans-unit id="00651d0b6fd0e23f3452ef97aaddc1cda2303a0d" translate="yes" xml:space="preserve">
          <source>Two sequences are compared element by element.</source>
          <target state="translated">两个序列逐元素进行比较。</target>
        </trans-unit>
        <trans-unit id="9e61db6f0549ccd99ae56429864c2f4cbe98bb50" translate="yes" xml:space="preserve">
          <source>Two such examples are macros and &lt;code&gt;#[cfg]&lt;/code&gt; environments.</source>
          <target state="translated">两个这样的示例是宏和 &lt;code&gt;#[cfg]&lt;/code&gt; 环境。</target>
        </trans-unit>
        <trans-unit id="9d8a406e3a91b6f18f7fee9fffccd411cd7bea0e" translate="yes" xml:space="preserve">
          <source>Two tests that pass! Now let&amp;rsquo;s see what happens to our test results when we introduce a bug in our code. Let&amp;rsquo;s change the implementation of the &lt;code&gt;can_hold&lt;/code&gt; method by replacing the greater than sign with a less than sign when it compares the widths:</source>
          <target state="translated">两项测试通过！现在，让我们看看在代码中引入错误后测试结果会如何变化。让我们在比较宽度时，通过将大于号替换为小于号来更改 &lt;code&gt;can_hold&lt;/code&gt; 方法的实现：</target>
        </trans-unit>
        <trans-unit id="6831c93d3c0041ecff78583892f51cefdc18f74a" translate="yes" xml:space="preserve">
          <source>Two things are important to note about this function:</source>
          <target state="translated">关于这个功能,有两点需要注意。</target>
        </trans-unit>
        <trans-unit id="d73651bf2df8af467f41b29a872952ef24a40245" translate="yes" xml:space="preserve">
          <source>Two trait implementations overlap when there is a non-empty intersection of the traits the implementation is for, the implementations can be instantiated with the same type.</source>
          <target state="translated">当两个特质实现重叠时,当该实现所针对的特质有非空的交集时,可以用相同的类型实例化该实现。</target>
        </trans-unit>
        <trans-unit id="45049ec7ea97abec9bd8269a665797ccca478bf9" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + UnwindSafe + Send&lt;/code&gt;.</source>
          <target state="translated">如果基本特征互为别名，并且自动特征的集合相同且生存期范围相同，则两种特征对象类型互为别名。例如， &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; 与 &lt;code&gt;dyn Trait + UnwindSafe + Send&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b6094fd54b67e7d276ce315b3b79ffc2dd18ae2" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt;.</source>
          <target state="translated">如果基本特征彼此别名，并且自动特征集相同且生命周期范围相同，则两种特征对象类型彼此互斥。例如， &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; 与 &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d078a0dedfa986439265f5fefabc817ba279445" translate="yes" xml:space="preserve">
          <source>Two traits, &lt;a href=&quot;../std/marker/trait.unsize&quot;&gt;&lt;code&gt;Unsize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt;, are used to assist in this process and expose it for library use. The following coercions are built-ins and, if &lt;code&gt;T&lt;/code&gt; can be coerced to &lt;code&gt;U&lt;/code&gt; with one of them, then an implementation of &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; will be provided:</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.unsize&quot;&gt; &lt;code&gt;Unsize&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt;两个特征用于协助此过程，并将其公开以供库使用。以下强制是内置的，如果可以使用其中之一将 &lt;code&gt;T&lt;/code&gt; 强制为 &lt;code&gt;U&lt;/code&gt; ，则将为 &lt;code&gt;T&lt;/code&gt; 提供 &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; 实现：</target>
        </trans-unit>
        <trans-unit id="0c40881391e5533daaab739e69ccda2bb7bda270" translate="yes" xml:space="preserve">
          <source>TyCtor(&lt;code&gt;T&lt;/code&gt;) to TyCtor(&lt;code&gt;U&lt;/code&gt;), where TyCtor(&lt;code&gt;T&lt;/code&gt;) is one of</source>
          <target state="translated">TyCtor（ &lt;code&gt;T&lt;/code&gt; ）到TyCtor（ &lt;code&gt;U&lt;/code&gt; ），其中TyCtor（ &lt;code&gt;T&lt;/code&gt; ）是以下之一</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="8893ac4ddfe0ea4688a44afc0ddfe4ebc76a84ef" translate="yes" xml:space="preserve">
          <source>Type &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; represents an optional value: every &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is either &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; and contains a value, or &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, and does not. &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; types are very common in Rust code, as they have a number of uses:</source>
          <target state="translated">Type &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;代表一个可选值：每个&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;要么是&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;且包含一个值，要么是&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，但没有。&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;类型在Rust代码中非常常见，因为它们具有多种用途：</target>
        </trans-unit>
        <trans-unit id="e705c5fc187594d957e6b2868fc24eb8ee56f315" translate="yes" xml:space="preserve">
          <source>Type Definition std::alloc::LayoutErr</source>
          <target state="translated">类型定义 std::alloc::LayoutErr</target>
        </trans-unit>
        <trans-unit id="5a34cc9264aacb6462265b18d25bcf726faf398f" translate="yes" xml:space="preserve">
          <source>Type Definition std::fmt::Result</source>
          <target state="translated">类型定义 std::fmt::Result</target>
        </trans-unit>
        <trans-unit id="34dd3e846f6d75301a90ce0c190a60bbb2f75015" translate="yes" xml:space="preserve">
          <source>Type Definition std::io::Result</source>
          <target state="translated">类型定义 std::io::Result</target>
        </trans-unit>
        <trans-unit id="46f6920a49ecfbe5727cafe69a86a93c6dc323b4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blkcnt_t</source>
          <target state="translated">类型定义 std::os::linux::raw::blkcnt_t</target>
        </trans-unit>
        <trans-unit id="85fbcc37c53b78d2794e588bd5f55d25d53b121b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blksize_t</source>
          <target state="translated">类型定义 std::os::linux::raw::blksize_t</target>
        </trans-unit>
        <trans-unit id="e2606fd8324f1985d42d98f82ef97532070eae3e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::dev_t</source>
          <target state="translated">类型定义 std::os::linux::raw::dev_t</target>
        </trans-unit>
        <trans-unit id="1a0725c0d449cfcc82b033154c822ab6aa94cb70" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::ino_t</source>
          <target state="translated">类型定义 std::os::linux::raw::ini_t</target>
        </trans-unit>
        <trans-unit id="96a7fc18b0419da7fc9a515e767bed1bfbc9562c" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::mode_t</source>
          <target state="translated">类型定义 std::os::linux::raw::mode_t</target>
        </trans-unit>
        <trans-unit id="75a060e0f5140a7dabbcb1ba8000909c3c0378d8" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::nlink_t</source>
          <target state="translated">类型定义 std::os::linux::raw::nlink_t</target>
        </trans-unit>
        <trans-unit id="7ae7bb16976469a8ad4e67f2c0d76a2afe6847e7" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::off_t</source>
          <target state="translated">类型定义 std::os::linux::raw::off_t</target>
        </trans-unit>
        <trans-unit id="76556b9aa9b1d76aecac20fd90dee8158aed1fa4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::pthread_t</source>
          <target state="translated">类型定义 std::os::linux::raw::pthread_t</target>
        </trans-unit>
        <trans-unit id="c8140af217e68caacdab8d2aaef2318b6e02ba66" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::time_t</source>
          <target state="translated">类型定义 std::os::linux::raw::time_t</target>
        </trans-unit>
        <trans-unit id="d80e70a5e9f44648db2fa12eba538e96a084706b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_char</source>
          <target state="translated">类型定义 std::os::raw::c_char</target>
        </trans-unit>
        <trans-unit id="47268ec268f5e51266c8c9b25e903a966387595d" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_double</source>
          <target state="translated">类型定义 std::os::raw::c_double</target>
        </trans-unit>
        <trans-unit id="167acfa92657a06bc69cb3f91777f380110e4dc9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_float</source>
          <target state="translated">类型定义 std::os::raw::c_float</target>
        </trans-unit>
        <trans-unit id="c27fd9199e90c2472f965bdc0cca23d6c8c570f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_int</source>
          <target state="translated">类型定义 std::os::raw::c_int</target>
        </trans-unit>
        <trans-unit id="19f693eccac3c497abf741d0f8baed1d19e53f4b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_long</source>
          <target state="translated">类型定义 std::os::raw::c_long</target>
        </trans-unit>
        <trans-unit id="8600d6f2d9a4b023e7037b70faa22dc15e66388f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_longlong</source>
          <target state="translated">类型定义 std::os::raw::c_longlong</target>
        </trans-unit>
        <trans-unit id="38fbb377e146c43dbf57e7ef0b9149de46dd63ee" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_schar</source>
          <target state="translated">类型定义 std::os::raw::c_schar</target>
        </trans-unit>
        <trans-unit id="24f91247eef9f189a56e0d26eb63e94174545d18" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_short</source>
          <target state="translated">类型定义 std::os::raw::c_short</target>
        </trans-unit>
        <trans-unit id="8fd264b0559dbbedb815b835dcd8dc23c60e3e46" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uchar</source>
          <target state="translated">类型定义 std::os::raw::c_uchar</target>
        </trans-unit>
        <trans-unit id="73ae8275dba1734adb8dd3eb79d165dfd8926f8e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uint</source>
          <target state="translated">类型定义 std::os::raw::c_uint</target>
        </trans-unit>
        <trans-unit id="963d890a0fa816ac69f7b2a91122d42f47482af6" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulong</source>
          <target state="translated">类型定义 std::os::raw::c_ulong</target>
        </trans-unit>
        <trans-unit id="9529b81e31c700d29c794b44439c31236befee6e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulonglong</source>
          <target state="translated">类型定义 std::os::raw::c_ulonglong</target>
        </trans-unit>
        <trans-unit id="2add572706fcd5310850bb5c41c263a68becd701" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ushort</source>
          <target state="translated">类型定义 std::os::raw::c_ushort</target>
        </trans-unit>
        <trans-unit id="af576d5699684e5ccc6dd3bdda06f283b79646ba" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::io::RawFd</source>
          <target state="translated">类型定义 std::os::unix::io::RawFd</target>
        </trans-unit>
        <trans-unit id="54df1b972115ebdb7492ee1ec118ad059c5b96b9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blkcnt_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::blkcnt_t</target>
        </trans-unit>
        <trans-unit id="24cf96c7673dcafd447d654adb8e4cf01b30bb6f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blksize_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::blksize_t</target>
        </trans-unit>
        <trans-unit id="27da02afd4df0cefb0f36b07dc40fb05a497c94e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::dev_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::dev_t</target>
        </trans-unit>
        <trans-unit id="73d1317f78cb687f50d63c8e6d4ee01bdba096f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::gid_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::gid_t</target>
        </trans-unit>
        <trans-unit id="f1c61da35b3b5a8948934b0c33b08607e17ab49a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::ino_t</source>
          <target state="translated">类型定义 std::os::unix::raw::ino_t</target>
        </trans-unit>
        <trans-unit id="f57f89ce06fb76c13960558bcf6af72b48025b0a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::mode_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::mode_t</target>
        </trans-unit>
        <trans-unit id="6efe4bc154c56731d72a72033b5e96f1e8e776fa" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::nlink_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::nlink_t</target>
        </trans-unit>
        <trans-unit id="16d41f66ea53de25694ff8008809453896212992" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::off_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::off_t</target>
        </trans-unit>
        <trans-unit id="7fcd1c7c7d47846aeea79e3b67b951552799ecac" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pid_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::pid_t</target>
        </trans-unit>
        <trans-unit id="15394730cd6adf60683b03d0f547388ed732a617" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pthread_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::pthread_t</target>
        </trans-unit>
        <trans-unit id="f5866aac0842b4a721a91364de015f0e36fbc706" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::time_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::time_t</target>
        </trans-unit>
        <trans-unit id="c10ba42310b44320213f70095552a73e406c10bc" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::uid_t</source>
          <target state="translated">类型 定义 std::os::unix::raw::uid_t</target>
        </trans-unit>
        <trans-unit id="ccfd242450d8d8e764c541c183e48c95060db965" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::thread::RawPthread</source>
          <target state="translated">类型 定义 std::os::unix::thread::RawPthread</target>
        </trans-unit>
        <trans-unit id="43663035c10bc49312c1bd0f80dfefc8e89294c1" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::io::RawHandle</source>
          <target state="translated">类型定义 std::os::windows::io::RawHandle</target>
        </trans-unit>
        <trans-unit id="3c2575150d67f1e23972163c0fc5f2c5d673b3e4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::io::RawSocket</source>
          <target state="translated">类型定义 std::os::windows::io::RawSocket</target>
        </trans-unit>
        <trans-unit id="05dc66459d6d8527de01519647dff10489bc279b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::raw::HANDLE</source>
          <target state="translated">类型定义 std::os::windows::raw::HANDLE</target>
        </trans-unit>
        <trans-unit id="e2a21128c36897e8cf2791477ca7f265a71b8679" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::raw::SOCKET</source>
          <target state="translated">类型定义 std::os::windows::raw::SOCKET</target>
        </trans-unit>
        <trans-unit id="f0f25e562f1eacf92009b3b9edd31757a9d568ee" translate="yes" xml:space="preserve">
          <source>Type Definition std::string::ParseError</source>
          <target state="translated">类型 定义 std::string::ParseError</target>
        </trans-unit>
        <trans-unit id="2cb5d5fbdf79715e3b849f3194ff3e1783dcc241" translate="yes" xml:space="preserve">
          <source>Type Definition std::sync::LockResult</source>
          <target state="translated">类型定义 std::sync::LockResult</target>
        </trans-unit>
        <trans-unit id="a007682d472492c4b8b35e81f42caebf855855fb" translate="yes" xml:space="preserve">
          <source>Type Definition std::sync::TryLockResult</source>
          <target state="translated">类型 定义 std::sync::TryLockResult</target>
        </trans-unit>
        <trans-unit id="0fbaa33419fbed78ef077708914d095867001a9d" translate="yes" xml:space="preserve">
          <source>Type Definition std::thread::Result</source>
          <target state="translated">类型定义 std::thread::Result</target>
        </trans-unit>
        <trans-unit id="3ba69662a63352acd45295d8a4cf929df3f97fd7" translate="yes" xml:space="preserve">
          <source>Type Definitions</source>
          <target state="translated">类型定义</target>
        </trans-unit>
        <trans-unit id="9037feed073eee5a9272aeaba9be605266f5d249" translate="yes" xml:space="preserve">
          <source>Type Layout</source>
          <target state="translated">类型布局</target>
        </trans-unit>
        <trans-unit id="7433446286e8e2d16c8a5d667b180309a3d0c3b1" translate="yes" xml:space="preserve">
          <source>Type System</source>
          <target state="translated">类型系统</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="46e484c635b0e4d4b2d73cd209e4672f43ad07bf" translate="yes" xml:space="preserve">
          <source>Type aliases are also commonly used with the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type for reducing repetition. Consider the &lt;code&gt;std::io&lt;/code&gt; module in the standard library. I/O operations often return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; to handle situations when operations fail to work. This library has a &lt;code&gt;std::io::Error&lt;/code&gt; struct that represents all possible I/O errors. Many of the functions in &lt;code&gt;std::io&lt;/code&gt; will be returning &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; where the &lt;code&gt;E&lt;/code&gt; is &lt;code&gt;std::io::Error&lt;/code&gt;, such as these functions in the &lt;code&gt;Write&lt;/code&gt; trait:</source>
          <target state="translated">类型别名也通常与 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 类型一起使用，以减少重复。考虑标准库中的 &lt;code&gt;std::io&lt;/code&gt; 模块。 I / O操作通常返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 来处理操作无法正常工作的情况。该库具有一个 &lt;code&gt;std::io::Error&lt;/code&gt; 结构，该结构表示所有可能的I / O错误。 &lt;code&gt;std::io&lt;/code&gt; 许多函数将返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;E&lt;/code&gt; 为 &lt;code&gt;std::io::Error&lt;/code&gt; ，例如 &lt;code&gt;Write&lt;/code&gt; trait 中的这些函数：</target>
        </trans-unit>
        <trans-unit id="6d5463932cf5afab710bceb8f1d7684735a25ccf" translate="yes" xml:space="preserve">
          <source>Type and Lifetime Parameters</source>
          <target state="translated">类型和寿命参数</target>
        </trans-unit>
        <trans-unit id="46505cd1622c8bbcf00ce8fef2ff0cd36549954e" translate="yes" xml:space="preserve">
          <source>Type bounds may be &lt;em&gt;higher ranked&lt;/em&gt; over lifetimes. These bounds specify a bound is true &lt;em&gt;for all&lt;/em&gt; lifetimes. For example, a bound such as &lt;code&gt;for&amp;lt;'a&amp;gt; &amp;amp;'a T: PartialEq&amp;lt;i32&amp;gt;&lt;/code&gt; would require an implementation like</source>
          <target state="translated">&lt;em&gt;在&lt;/em&gt;整个生命周期中，类型界限的&lt;em&gt;排名&lt;/em&gt;可能&lt;em&gt;更高&lt;/em&gt;。这些界限指定一个界限&lt;em&gt;在所有&lt;/em&gt;生命周期内均为真。例如，诸如 &lt;code&gt;for&amp;lt;'a&amp;gt; &amp;amp;'a T: PartialEq&amp;lt;i32&amp;gt;&lt;/code&gt; 将需要类似的实现</target>
        </trans-unit>
        <trans-unit id="ee004d162350a5b317e1dbaab9ce920a6f34a9cb" translate="yes" xml:space="preserve">
          <source>Type cast expressions</source>
          <target state="translated">类型转换表达式</target>
        </trans-unit>
        <trans-unit id="7b7e747774abb621d3a39f39c2761d3405b325bb" translate="yes" xml:space="preserve">
          <source>Type coercions</source>
          <target state="translated">强制类型</target>
        </trans-unit>
        <trans-unit id="b6d852132e2d9e31234c0b7e2d2b2f126e521734" translate="yes" xml:space="preserve">
          <source>Type expressions</source>
          <target state="translated">类型表达式</target>
        </trans-unit>
        <trans-unit id="00e950510855acd161003d11973afbcccbd1f3d1" translate="yes" xml:space="preserve">
          <source>Type inference typically proceeds from the top of the function to the bottom, figuring out types as it goes. In some cases -- notably method calls and overloadable operators like &lt;code&gt;*&lt;/code&gt; -- the type checker may not have enough information &lt;em&gt;yet&lt;/em&gt; to make progress. This can be true even if the rest of the function provides enough context (because the type-checker hasn't looked that far ahead yet). In this case, type annotations can be used to help it along.</source>
          <target state="translated">类型推断通常从函数顶部到底部进行，从而确定类型。在某些情况下-特别是方法调用和重载运营商如 &lt;code&gt;*&lt;/code&gt; -类型检查可能没有足够的信息&lt;em&gt;尚未&lt;/em&gt;取得进展。即使函数的其余部分提供了足够的上下文，这也可能是正确的（因为类型检查器还没有那么遥远）。在这种情况下，可以使用类型注释来帮助它。</target>
        </trans-unit>
        <trans-unit id="c11526a8c75cf7eda7350bd42de65837b525d024" translate="yes" xml:space="preserve">
          <source>Type information must be provided if a pointer type being cast from/into another type which cannot be inferred:</source>
          <target state="translated">如果一个指针类型被从另一个类型投射到另一个不能推断的类型,必须提供类型信息。</target>
        </trans-unit>
        <trans-unit id="a230d1816e8c1575c2c45ae6cf6a3850545e094f" translate="yes" xml:space="preserve">
          <source>Type layout can be changed with each compilation. Instead of trying to document exactly what is done, we only document what is guaranteed today.</source>
          <target state="translated">类型布局可以随着每次编译而改变。我们不试图准确地记录所做的事情,而只记录今天所保证的事情。</target>
        </trans-unit>
        <trans-unit id="421e94d5ad1cf070315124ce8a70fe7342de0094" translate="yes" xml:space="preserve">
          <source>Type of &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="483996222a68497be8a52e043163c1b07da634c0" translate="yes" xml:space="preserve">
          <source>Type of the hasher that will be created.</source>
          <target state="translated">将要创建的哈希类型。</target>
        </trans-unit>
        <trans-unit id="90d41d3e02c3a5714dfb49c0b53d465ea95595cd" translate="yes" xml:space="preserve">
          <source>Type parameter defaults can only use parameters that occur before them. Erroneous code example:</source>
          <target state="translated">类型参数默认只能使用在其之前出现的参数。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="610a43f90945887f546fa9894dbf887213eca6c4" translate="yes" xml:space="preserve">
          <source>Type parameter defaults can only use parameters that occur before them. Since type parameters are evaluated in-order, this issue could be fixed by doing:</source>
          <target state="translated">类型参数默认只能使用在其之前出现的参数。由于类型参数是按顺序评估的,这个问题可以通过以下方式来解决。</target>
        </trans-unit>
        <trans-unit id="dac2f87deb7b8641c81a7d19aab25baf97b67f2a" translate="yes" xml:space="preserve">
          <source>Type parameter defaults cannot use &lt;code&gt;Self&lt;/code&gt; on structs, enums, or unions.</source>
          <target state="translated">类型参数默认值不能在结构，枚举或联合上使用 &lt;code&gt;Self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9a3646a7ac556f56d25e93e18f2d2b1583d0264" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
          <target state="translated">类型参数</target>
        </trans-unit>
        <trans-unit id="4a3ece058bb3ba65db202bc18df133e4b49391e3" translate="yes" xml:space="preserve">
          <source>Type parameters can be specified for a trait to make it generic. These appear after the trait name, using the same syntax used in &lt;a href=&quot;functions#generic-functions&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="translated">可以为特征指定类型参数以使其通用。它们使用&lt;a href=&quot;functions#generic-functions&quot;&gt;通用函数中&lt;/a&gt;使用的相同语法出现在特征名称之后。</target>
        </trans-unit>
        <trans-unit id="8de0a3ce745cf3e1cf2895f8f92a4c1b4a8865b7" translate="yes" xml:space="preserve">
          <source>Type parameters for &lt;code&gt;impl Trait&lt;/code&gt; types must be explicitly defined as named generic parameters:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 类型参数必须显式定义为命名的通用参数：</target>
        </trans-unit>
        <trans-unit id="788f8ff13becde924812f48a846332da2dde1b3b" translate="yes" xml:space="preserve">
          <source>Type parameters in an associated item also cannot shadow parameters from the containing item:</source>
          <target state="translated">关联项中的类型参数也不能影射包含项中的参数。</target>
        </trans-unit>
        <trans-unit id="d2b6a64cfc2d2019725a350386f952f6ea964501" translate="yes" xml:space="preserve">
          <source>Type parameters in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</source>
          <target state="translated">类型定义中的类型参数有与之相关的寿命,它代表了存储在其中的数据被保证能活多久。这个寿命必须与数据需要存活的时间一样长,缺少表示这个寿命的约束将导致这个错误。</target>
        </trans-unit>
        <trans-unit id="635a70628fcb4cdf2545b82d9a213017cf1ec1dc" translate="yes" xml:space="preserve">
          <source>Type parameters where the parameters only have any &lt;a href=&quot;../trait-bounds&quot;&gt;trait bounds&lt;/a&gt; of the following kind:</source>
          <target state="translated">键入参数，其中参数仅具有以下类型的任何&lt;a href=&quot;../trait-bounds&quot;&gt;特征范围&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f5436dd7df5cce78281ac167ac45b8ad046b6808" translate="yes" xml:space="preserve">
          <source>Type paths are used within type definitions, trait bounds, type parameter bounds, and qualified paths.</source>
          <target state="translated">类型路径在类型定义、特征边界、类型参数边界和限定路径中使用。</target>
        </trans-unit>
        <trans-unit id="0fc5390ca69aecade222ecf85ac47ee15fecaa1e" translate="yes" xml:space="preserve">
          <source>Type system</source>
          <target state="translated">类型系统</target>
        </trans-unit>
        <trans-unit id="40294f1b1dbbecd786588c1ac7a98f52d1946633" translate="yes" xml:space="preserve">
          <source>Type system attributes</source>
          <target state="translated">系统属性类型</target>
        </trans-unit>
        <trans-unit id="e6b05abe4f4f396debd3f7c7c7a457e652381139" translate="yes" xml:space="preserve">
          <source>TypeId</source>
          <target state="translated">TypeId</target>
        </trans-unit>
        <trans-unit id="6174852658dcb07e66221cdda0d47c6a79955026" translate="yes" xml:space="preserve">
          <source>TypeId::borrow</source>
          <target state="translated">TypeId::borrow</target>
        </trans-unit>
        <trans-unit id="9240a6191da03dd3e162b4d594573c014ae637e8" translate="yes" xml:space="preserve">
          <source>TypeId::borrow_mut</source>
          <target state="translated">TypeId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1e830f38943c98994765e5634b28fc734e6d131b" translate="yes" xml:space="preserve">
          <source>TypeId::clamp</source>
          <target state="translated">TypeId::clamp</target>
        </trans-unit>
        <trans-unit id="716fa011ef15618f6c39d058d78de9fd5d26d8a4" translate="yes" xml:space="preserve">
          <source>TypeId::clone</source>
          <target state="translated">TypeId::clone</target>
        </trans-unit>
        <trans-unit id="d206fca55570d1ee7222250a6099efa3eefe5378" translate="yes" xml:space="preserve">
          <source>TypeId::clone_from</source>
          <target state="translated">TypeId::clone_from</target>
        </trans-unit>
        <trans-unit id="795523e4b3053e8ae487bb7ffbfed98163be00e1" translate="yes" xml:space="preserve">
          <source>TypeId::clone_into</source>
          <target state="translated">TypeId::clone_into</target>
        </trans-unit>
        <trans-unit id="ddba09636ddf2c450efd47bdbd5c1086798641ce" translate="yes" xml:space="preserve">
          <source>TypeId::cmp</source>
          <target state="translated">TypeId::cmp</target>
        </trans-unit>
        <trans-unit id="3f0565a2054d47ca089c9dd28d09f714cfe255a6" translate="yes" xml:space="preserve">
          <source>TypeId::eq</source>
          <target state="translated">TypeId::eq</target>
        </trans-unit>
        <trans-unit id="3b66ed765f5e07da8b6a35c0796de577d880004a" translate="yes" xml:space="preserve">
          <source>TypeId::fmt</source>
          <target state="translated">TypeId::fmt</target>
        </trans-unit>
        <trans-unit id="a6d534f62ff1c6a2b12bb6ea7101f9db8f3b6a65" translate="yes" xml:space="preserve">
          <source>TypeId::from</source>
          <target state="translated">TypeId::from</target>
        </trans-unit>
        <trans-unit id="0ad8421f49348cec9c5c0ea27504bddf46f46746" translate="yes" xml:space="preserve">
          <source>TypeId::ge</source>
          <target state="translated">TypeId::ge</target>
        </trans-unit>
        <trans-unit id="98d12bbe982cc4e9feaef864de49f327eade548c" translate="yes" xml:space="preserve">
          <source>TypeId::gt</source>
          <target state="translated">TypeId::gt</target>
        </trans-unit>
        <trans-unit id="e1dea7697f9d16fe9585b0146b54ef1ba2595a7c" translate="yes" xml:space="preserve">
          <source>TypeId::hash</source>
          <target state="translated">TypeId::hash</target>
        </trans-unit>
        <trans-unit id="d7a9744fc39a0fe544964e9b703ad9db8ff88413" translate="yes" xml:space="preserve">
          <source>TypeId::hash_slice</source>
          <target state="translated">TypeId::hash_slice</target>
        </trans-unit>
        <trans-unit id="8f7e7f7b59fc95161e5efd4c331382bf506c5fe2" translate="yes" xml:space="preserve">
          <source>TypeId::into</source>
          <target state="translated">TypeId::into</target>
        </trans-unit>
        <trans-unit id="02f386a913763d6012a9e28821eacb6458ea8546" translate="yes" xml:space="preserve">
          <source>TypeId::le</source>
          <target state="translated">TypeId::le</target>
        </trans-unit>
        <trans-unit id="578f87bf8b84d3b8635f212a617fcec0f23b5476" translate="yes" xml:space="preserve">
          <source>TypeId::lt</source>
          <target state="translated">TypeId::lt</target>
        </trans-unit>
        <trans-unit id="6c7811e3962847e55153d132edc379a97aeab156" translate="yes" xml:space="preserve">
          <source>TypeId::max</source>
          <target state="translated">TypeId::max</target>
        </trans-unit>
        <trans-unit id="5de1024eb47140ae18a0b9ef6b7abda00f5ebc42" translate="yes" xml:space="preserve">
          <source>TypeId::min</source>
          <target state="translated">TypeId::min</target>
        </trans-unit>
        <trans-unit id="19a1b2382c162a3deb2660f8d535151330c4dd68" translate="yes" xml:space="preserve">
          <source>TypeId::ne</source>
          <target state="translated">TypeId::ne</target>
        </trans-unit>
        <trans-unit id="57bbf815ae3734582141e6c3d94d16d795b42238" translate="yes" xml:space="preserve">
          <source>TypeId::of</source>
          <target state="translated">TypeId::of</target>
        </trans-unit>
        <trans-unit id="9387d6c30cfc43859bbce0cd6a9e882f482aa548" translate="yes" xml:space="preserve">
          <source>TypeId::partial_cmp</source>
          <target state="translated">TypeId::partial_cmp</target>
        </trans-unit>
        <trans-unit id="275a8a5c8970873ed0f6e5f7be025d1d88c24b17" translate="yes" xml:space="preserve">
          <source>TypeId::to_owned</source>
          <target state="translated">TypeId::to_owned</target>
        </trans-unit>
        <trans-unit id="b305d0eb27c70d75d6581a7bb24fd3b0cabb8713" translate="yes" xml:space="preserve">
          <source>TypeId::try_from</source>
          <target state="translated">TypeId::try_from</target>
        </trans-unit>
        <trans-unit id="ab6bd512f140c02836e01449097676127e0b1727" translate="yes" xml:space="preserve">
          <source>TypeId::try_into</source>
          <target state="translated">TypeId::try_into</target>
        </trans-unit>
        <trans-unit id="b7aa84284f56989bd040008a9a1842dc034ac075" translate="yes" xml:space="preserve">
          <source>TypeId::type_id</source>
          <target state="translated">TypeId::type_id</target>
        </trans-unit>
        <trans-unit id="ca804ab74bf9fa2667ceb8c95926b696eb69be50" translate="yes" xml:space="preserve">
          <source>Typedefs</source>
          <target state="translated">Typedefs</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="51920e55843cc4f1f030d29bb9494f870acf0911" translate="yes" xml:space="preserve">
          <source>Types and Traits for working with asynchronous tasks.</source>
          <target state="translated">用于处理异步任务的类型和特征。</target>
        </trans-unit>
        <trans-unit id="eb96b9196c6d15505da132a08c116566f7a5d2bc" translate="yes" xml:space="preserve">
          <source>Types express that they can be borrowed as some type &lt;code&gt;T&lt;/code&gt; by implementing &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;, providing a reference to a &lt;code&gt;T&lt;/code&gt; in the trait&amp;rsquo;s &lt;a href=&quot;#tymethod.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt; method. A type is free to borrow as several different types. If it wishes to mutably borrow as the type &amp;ndash; allowing the underlying data to be modified, it can additionally implement &lt;a href=&quot;trait.borrowmut&quot;&gt;&lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类型表示通过实现 &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; 可以将它们作为 &lt;code&gt;T&lt;/code&gt; 类型借用，从而在trait的&lt;a href=&quot;#tymethod.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt;方法中提供对 &lt;code&gt;T&lt;/code&gt; 的引用。一个类型可以自由借用几种不同的类型。如果希望可变地借用该类型-允许修改基础数据，则可以另外实现&lt;a href=&quot;trait.borrowmut&quot;&gt; &lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6aef87c840bd9c8d6b5be21927a32724dcebf8ad" translate="yes" xml:space="preserve">
          <source>Types express that they can be borrowed as some type &lt;code&gt;T&lt;/code&gt; by implementing &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;, providing a reference to a &lt;code&gt;T&lt;/code&gt; in the trait&amp;rsquo;s &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt; method. A type is free to borrow as several different types. If it wishes to mutably borrow as the type &amp;ndash; allowing the underlying data to be modified, it can additionally implement &lt;a href=&quot;trait.borrowmut&quot;&gt;&lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类型表示通过实现 &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; 可以将它们作为 &lt;code&gt;T&lt;/code&gt; 类型借用，从而在trait的&lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt;方法中提供对 &lt;code&gt;T&lt;/code&gt; 的引用。一种类型可以自由借用几种不同的类型。如果希望可变地借用该类型-允许修改基础数据，则可以另外实现&lt;a href=&quot;trait.borrowmut&quot;&gt; &lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a53d10bc9765156a98cd22298d0dddb08f16d1f" translate="yes" xml:space="preserve">
          <source>Types for which it is safe to share references between threads.</source>
          <target state="translated">线程之间可以安全共享引用的类型。</target>
        </trans-unit>
        <trans-unit id="98c95794e6189dee1201d1bd443780e1c531d39b" translate="yes" xml:space="preserve">
          <source>Types implementing &lt;code&gt;Hash&lt;/code&gt; are able to be &lt;a href=&quot;#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt;ed with an instance of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;实例对实现 &lt;code&gt;Hash&lt;/code&gt; 的类型进行&lt;a href=&quot;#tymethod.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt;处理。</target>
        </trans-unit>
        <trans-unit id="e63cf5842f436d926f1be87d5535f3c61b75dd54" translate="yes" xml:space="preserve">
          <source>Types implementing &lt;code&gt;Hash&lt;/code&gt; are able to be &lt;a href=&quot;trait.hash#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt;ed with an instance of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现 &lt;code&gt;Hash&lt;/code&gt; 类型可以使用&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;的实例进行&lt;a href=&quot;trait.hash#tymethod.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f882465e79764914f835cc19a5911f31e45f796b" translate="yes" xml:space="preserve">
          <source>Types in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to be live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</source>
          <target state="translated">类型定义中的类型有与之相关的寿命,它代表了存储在其中的数据被保证存活的时间。这个寿命必须是数据需要存活的时间,如果缺少表示这个的约束,就会导致这个错误。</target>
        </trans-unit>
        <trans-unit id="777921b6f1b475c9ffaa77c98a5d17f39e3660e5" translate="yes" xml:space="preserve">
          <source>Types like &lt;code&gt;&amp;amp;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, however, are unwind safe because they implement poisoning by default. They still allow witnessing a broken invariant, but they already provide their own &quot;speed bumps&quot; to do so.</source>
          <target state="translated">但是，像 &lt;code&gt;&amp;amp;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 这样的类型是不安全的，因为它们默认实现中毒。他们仍然可以见证破碎的不变式，但是他们已经提供了自己的&amp;ldquo;减速带&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b83d85bf5da8e86595350c0dcf9e419a4d654c49" translate="yes" xml:space="preserve">
          <source>Types like Vec therefore just &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; without using &lt;code&gt;needs_drop&lt;/code&gt; explicitly. Types like &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, on the other hand, have to drop values one at a time and should use this API.</source>
          <target state="translated">因此，像Vec这样的类型只需 &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; 而无需显式使用 &lt;code&gt;needs_drop&lt;/code&gt; 。另一方面，像&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;这样的类型必须一次删除一个值，并且应使用此API。</target>
        </trans-unit>
        <trans-unit id="a8a83f5b2fb6977b69a3feef08ecd269c85a9244" translate="yes" xml:space="preserve">
          <source>Types like Vec therefore just &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; without using needs_drop explicitly. Types like &lt;code&gt;HashMap&lt;/code&gt;, on the other hand, have to drop values one at a time and should use this API.</source>
          <target state="translated">因此，像Vec这样的类型只需 &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; 而无需显式使用needs_drop。另一方面，像 &lt;code&gt;HashMap&lt;/code&gt; 这样的类型必须一次删除一个值，并且应该使用此API。</target>
        </trans-unit>
        <trans-unit id="7478d20240bfc3f122030bf28d31bd62139a2c2b" translate="yes" xml:space="preserve">
          <source>Types of paths</source>
          <target state="translated">路径类型</target>
        </trans-unit>
        <trans-unit id="927769adc55a691f31ed2d50893e6b26e3a7e1f3" translate="yes" xml:space="preserve">
          <source>Types such as &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; are examples which are &lt;strong&gt;not&lt;/strong&gt; unwind safe. The general idea is that any mutable state which can be shared across &lt;code&gt;catch_unwind&lt;/code&gt; is not unwind safe by default. This is because it is very easy to witness a broken invariant outside of &lt;code&gt;catch_unwind&lt;/code&gt; as the data is simply accessed as usual.</source>
          <target state="translated">诸如 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类的类型&lt;strong&gt;不是&lt;/strong&gt;展开安全的示例。通常的想法是，默认情况下，可以跨 &lt;code&gt;catch_unwind&lt;/code&gt; 共享的任何可变状态都不安全。这是因为很容易看到 &lt;code&gt;catch_unwind&lt;/code&gt; 之外的残破不变式，因为像往常一样简单地访问了数据。</target>
        </trans-unit>
        <trans-unit id="c3195172a47cd29103a9c049d30b8fbf3e8b1360" translate="yes" xml:space="preserve">
          <source>Types that are &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; should have a trivial implementation of &lt;code&gt;Clone&lt;/code&gt;. More formally: if &lt;code&gt;T: Copy&lt;/code&gt;, &lt;code&gt;x: T&lt;/code&gt;, and &lt;code&gt;y: &amp;amp;T&lt;/code&gt;, then &lt;code&gt;let x = y.clone();&lt;/code&gt; is equivalent to &lt;code&gt;let x = *y;&lt;/code&gt;. Manual implementations should be careful to uphold this invariant; however, unsafe code must not rely on it to ensure memory safety.</source>
          <target state="translated">&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;类型应具有 &lt;code&gt;Clone&lt;/code&gt; 的简单实现。更正式地讲：如果 &lt;code&gt;T: Copy&lt;/code&gt; ， &lt;code&gt;x: T&lt;/code&gt; 和 &lt;code&gt;y: &amp;amp;T&lt;/code&gt; ，则 &lt;code&gt;let x = y.clone();&lt;/code&gt; 等于 &lt;code&gt;let x = *y;&lt;/code&gt; 。手动执行时应注意保持不变。但是，不安全的代码一定不能依靠它来确保内存安全。</target>
        </trans-unit>
        <trans-unit id="f0ac37d244c8fc744b51cd8122917f397c819f37" translate="yes" xml:space="preserve">
          <source>Types that are not &lt;code&gt;Sync&lt;/code&gt; are those that have &quot;interior mutability&quot; in a non-thread-safe form, such as &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;. These types allow for mutation of their contents even through an immutable, shared reference. For example the &lt;code&gt;set&lt;/code&gt; method on &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, so it requires only a shared reference &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The method performs no synchronization, thus &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; cannot be &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">不是 &lt;code&gt;Sync&lt;/code&gt; 的类型是具有非线程安全形式的&amp;ldquo;内部可变性&amp;rdquo;的类型，例如&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;。这些类型甚至允许通过不可变的共享引用来更改其内容。例如，&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;上的 &lt;code&gt;set&lt;/code&gt; 方法采用 &lt;code&gt;&amp;amp;self&lt;/code&gt; ，因此只需要一个共享引用&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。该方法不执行同步，因此&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;不能为 &lt;code&gt;Sync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="052471a32eb0536b190d6178524500a9ab363d4b" translate="yes" xml:space="preserve">
          <source>Types that are not &lt;code&gt;Sync&lt;/code&gt; are those that have &quot;interior mutability&quot; in a non-thread-safe form, such as &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;cell::Cell&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;cell::RefCell&lt;/code&gt;&lt;/a&gt;. These types allow for mutation of their contents even through an immutable, shared reference. For example the &lt;code&gt;set&lt;/code&gt; method on &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, so it requires only a shared reference &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The method performs no synchronization, thus &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; cannot be &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">不 &lt;code&gt;Sync&lt;/code&gt; 类型是具有非线程安全形式的&amp;ldquo;内部可变性&amp;rdquo;的类型，例如&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;cell::Cell&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;cell::RefCell&lt;/code&gt; &lt;/a&gt;。这些类型甚至允许通过不可变的共享引用来更改其内容。例如，&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;上的 &lt;code&gt;set&lt;/code&gt; 方法采用 &lt;code&gt;&amp;amp;self&lt;/code&gt; ，因此仅需要共享引用&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。该方法不执行同步，因此&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;不能为 &lt;code&gt;Sync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a93bcdad638deb7c786807f08f731b7cc346d96e" translate="yes" xml:space="preserve">
          <source>Types that can be &quot;unsized&quot; to a dynamically-sized type.</source>
          <target state="translated">可以 &quot;无大小 &quot;到动态大小的类型。</target>
        </trans-unit>
        <trans-unit id="cb55fa05185a6907e8b5c6521da0fcc611e7870b" translate="yes" xml:space="preserve">
          <source>Types that can be referred to by a path directly. Specifically &lt;a href=&quot;items/enumerations&quot;&gt;enums&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;items/unions&quot;&gt;unions&lt;/a&gt;, and &lt;a href=&quot;types/trait-object&quot;&gt;trait objects&lt;/a&gt;.</source>
          <target state="translated">路径可以直接引用的类型。特别是&lt;a href=&quot;items/enumerations&quot;&gt;枚举&lt;/a&gt;，&lt;a href=&quot;items/structs&quot;&gt;结构&lt;/a&gt;，&lt;a href=&quot;items/unions&quot;&gt;联合&lt;/a&gt;和&lt;a href=&quot;types/trait-object&quot;&gt;特征对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25ee853941e3e88ccc68136bde43188a34e9bb72" translate="yes" xml:space="preserve">
          <source>Types that can be safely moved after being pinned.</source>
          <target state="translated">销后可以安全移动的类型。</target>
        </trans-unit>
        <trans-unit id="1ac756fd205dd639ca5e2fd93c5deef27d4364ad" translate="yes" xml:space="preserve">
          <source>Types that can be transferred across thread boundaries.</source>
          <target state="translated">可以跨线程边界传输的类型。</target>
        </trans-unit>
        <trans-unit id="320fc78d266da1348d0700937ff111e53e935f29" translate="yes" xml:space="preserve">
          <source>Types that pin data to its location in memory.</source>
          <target state="translated">类型,将数据引脚到其在内存中的位置。</target>
        </trans-unit>
        <trans-unit id="76aa938f99526e648196d0e632e37d9cfcfbe64a" translate="yes" xml:space="preserve">
          <source>Types where all values have the same size and alignment known at compile time implement the &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait and can be checked with the &lt;a href=&quot;../std/mem/fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/mem/fn.align_of&quot;&gt;&lt;code&gt;align_of&lt;/code&gt;&lt;/a&gt; functions. Types that are not &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; are known as &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;. Since all values of a &lt;code&gt;Sized&lt;/code&gt; type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.</source>
          <target state="translated">所有值具有相同大小和对齐方式（在编译时已知）的类型将实现&lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;特征，并且可以使用&lt;a href=&quot;../std/mem/fn.size_of&quot;&gt; &lt;code&gt;size_of&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/mem/fn.align_of&quot;&gt; &lt;code&gt;align_of&lt;/code&gt; &lt;/a&gt;函数进行检查。不属于类型&lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;被称为&lt;a href=&quot;dynamically-sized-types&quot;&gt;动态调整大小类型&lt;/a&gt;。由于 &lt;code&gt;Sized&lt;/code&gt; 类型的所有值共享相同的大小和对齐方式，因此我们将这些共享的值分别称为类型的大小和类型的对齐方式。</target>
        </trans-unit>
        <trans-unit id="4c5a249120cc9cc75ac3bb033531eaa8e4965e16" translate="yes" xml:space="preserve">
          <source>Types where all values have the same size and alignment, and both are known at compile time, implement the &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait and can be checked with the &lt;a href=&quot;../std/mem/fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/mem/fn.align_of&quot;&gt;&lt;code&gt;align_of&lt;/code&gt;&lt;/a&gt; functions. Types that are not &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; are known as &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;. Since all values of a &lt;code&gt;Sized&lt;/code&gt; type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.</source>
          <target state="translated">所有值的大小和对齐方式都相同且在编译时都已知的类型将实现&lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;特征，并可以使用&lt;a href=&quot;../std/mem/fn.size_of&quot;&gt; &lt;code&gt;size_of&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/mem/fn.align_of&quot;&gt; &lt;code&gt;align_of&lt;/code&gt; &lt;/a&gt;函数进行检查。不属于类型&lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;被称为&lt;a href=&quot;dynamically-sized-types&quot;&gt;动态调整大小类型&lt;/a&gt;。由于 &lt;code&gt;Sized&lt;/code&gt; 类型的所有值共享相同的大小和对齐方式，因此我们将这些共享的值分别称为类型的大小和类型的对齐方式。</target>
        </trans-unit>
        <trans-unit id="3210f89648e92f030dff845af33244c5ff84d48b" translate="yes" xml:space="preserve">
          <source>Types which can be safely moved after being pinned.</source>
          <target state="translated">销后可安全移动的类型。</target>
        </trans-unit>
        <trans-unit id="2f9fa3c4c8befc1e893d11ac3d1acf505f4ef9f3" translate="yes" xml:space="preserve">
          <source>Types whose values can be duplicated simply by copying bits.</source>
          <target state="translated">其值可以简单地通过复制位进行复制的类型。</target>
        </trans-unit>
        <trans-unit id="184223af25e77a5fba4124f5c744634bac8d8134" translate="yes" xml:space="preserve">
          <source>Types with a built-in &lt;code&gt;Copy&lt;/code&gt; implementation (see above)</source>
          <target state="translated">具有内置 &lt;code&gt;Copy&lt;/code&gt; 实现的类型（请参见上文）</target>
        </trans-unit>
        <trans-unit id="484e89278738e43bbfac83c89cf041e830b0fa33" translate="yes" xml:space="preserve">
          <source>Types with a constant size known at compile time.</source>
          <target state="translated">在编译时已知大小不变的类型。</target>
        </trans-unit>
        <trans-unit id="c606776082303165b5e8cc822f677d6b3746b68d" translate="yes" xml:space="preserve">
          <source>Typically in Rust, it is difficult to perform step (2) because catching a panic involves either spawning a thread (which in turns makes it difficult to later witness broken invariants) or using the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module. Additionally, even if an invariant is witnessed, it typically isn't a problem in Rust because there are no uninitialized values (like in C or C++).</source>
          <target state="translated">通常，在Rust中，很难执行步骤（2），因为捕获恐慌涉及到生成线程（这又使以后很难看到损坏的不变式）或在此模块中使用 &lt;code&gt;catch_unwind&lt;/code&gt; 函数。另外，即使见证了一个不变式，在Rust中通常也不是问题，因为没有未初始化的值（例如在C或C ++中）。</target>
        </trans-unit>
        <trans-unit id="cb301c3b538136ec6b1f761774f64171df868f5f" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;quit&lt;/code&gt; actually quits the game, but so will any other non-number input. However, this is suboptimal to say the least. We want the game to automatically stop when the correct number is guessed.</source>
          <target state="translated">键入 &lt;code&gt;quit&lt;/code&gt; 实际上会退出游戏，但是其他任何非数字输入也会退出游戏。但是，至少可以说这不是最理想的。我们希望游戏在猜到正确的数字后自动停止。</target>
        </trans-unit>
        <trans-unit id="a153700f851859e0ff4a79a843433857f27950a3" translate="yes" xml:space="preserve">
          <source>U+0021 ..= U+002F &lt;code&gt;! &quot; # $ % &amp;amp; ' ( ) * + , - . /&lt;/code&gt;, or</source>
          <target state="translated">U + 0021 .. = U + 002F &lt;code&gt;! &quot; # $ % &amp;amp; ' ( ) * + , - . /&lt;/code&gt; 或</target>
        </trans-unit>
        <trans-unit id="9a3efbcf50b26fb17c75edefb4d0573be03644e1" translate="yes" xml:space="preserve">
          <source>U+0030 '0' ..= U+0039 '9', or</source>
          <target state="translated">U+0030 '0' ...=U+0039 '9',或</target>
        </trans-unit>
        <trans-unit id="974d5e574e1e2bc13b31d24cc4a60ea2f16fa049" translate="yes" xml:space="preserve">
          <source>U+0030 '0' ..= U+0039 '9'.</source>
          <target state="translated">U+0030 '0' ...=U+0039 '9'。</target>
        </trans-unit>
        <trans-unit id="fc0e8044fa37810bc4ad961db684088868f06aba" translate="yes" xml:space="preserve">
          <source>U+003A ..= U+0040 &lt;code&gt;: ; &amp;lt; = &amp;gt; ? @&lt;/code&gt;, or</source>
          <target state="translated">U + 003A .. = U + 0040 &lt;code&gt;: ; &amp;lt; = &amp;gt; ? @&lt;/code&gt; 或</target>
        </trans-unit>
        <trans-unit id="302310fbdc6543d9d3ceaffa2ea8c3882849e20a" translate="yes" xml:space="preserve">
          <source>U+0041 'A' ..= U+0046 'F', or</source>
          <target state="translated">U+0041 'A' ...=U+0046 'F',或</target>
        </trans-unit>
        <trans-unit id="0736721e1e5a1d0311260bd3b8011dcd68e67375" translate="yes" xml:space="preserve">
          <source>U+0041 'A' ..= U+005A 'Z', or</source>
          <target state="translated">U+0041 'A' ...=U+005A 'Z',或</target>
        </trans-unit>
        <trans-unit id="db2fb3a2a6da1a41f13ef4503845f3b0b40f0c2e" translate="yes" xml:space="preserve">
          <source>U+005B ..= U+0060 &lt;code&gt;[ \ ] ^ _ ` &lt;/code&gt;, or</source>
          <target state="translated">U + 005B .. = U + 0060 &lt;code&gt;[ \ ] ^ _ ` &lt;/code&gt; _` ，或</target>
        </trans-unit>
        <trans-unit id="d8cc906d3074f1fb9435c008fb8f60999129ec67" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+0066 'f'.</source>
          <target state="translated">U+0061 'a' ...=U+0066 'f'。</target>
        </trans-unit>
        <trans-unit id="c1d839fcec5226b8d1bd246357b031dd87454f54" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+007A 'z', or</source>
          <target state="translated">U+0061 'a' ...=U+007A 'z' ,或</target>
        </trans-unit>
        <trans-unit id="94a61fd70b1e7aaf895ebbced86d7174cebf3cb2" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+007A 'z'.</source>
          <target state="translated">U+0061 'a' .=U+007A 'z'。</target>
        </trans-unit>
        <trans-unit id="2bed9fc1e2abd580e2aa130399315d68f08afda9" translate="yes" xml:space="preserve">
          <source>U+007B ..= U+007E &lt;code&gt;{ | } ~&lt;/code&gt;</source>
          <target state="translated">U + 007B .. = U + 007E &lt;code&gt;{ | } ~&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6732b9263430ba9b754d7ce4c99335950d3da8b" translate="yes" xml:space="preserve">
          <source>UCred</source>
          <target state="translated">UCred</target>
        </trans-unit>
        <trans-unit id="0dd9df57e9839a1ea6ed560675b576be4884654a" translate="yes" xml:space="preserve">
          <source>UNC prefixes consist of the server's hostname and a share name.</source>
          <target state="translated">UNC前缀由服务器的主机名和共享名组成。</target>
        </trans-unit>
        <trans-unit id="08e32e0a7cca1165daa904dec1d1f04e68736d5e" translate="yes" xml:space="preserve">
          <source>UNICODE_ESCAPE :</source>
          <target state="translated">UNICODE_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="a22641b9fc9c9910a6cdbff4d4c69eb3d13192f7" translate="yes" xml:space="preserve">
          <source>UNICODE_VERSION</source>
          <target state="translated">UNICODE_VERSION</target>
        </trans-unit>
        <trans-unit id="039571ef60c9b1a6527c96a684dccfc0e4f32a75" translate="yes" xml:space="preserve">
          <source>UNIX</source>
          <target state="translated">UNIX</target>
        </trans-unit>
        <trans-unit id="82e26360ac87e10e1e21c7c1d4d889a8777bad06" translate="yes" xml:space="preserve">
          <source>UNIX_EPOCH</source>
          <target state="translated">UNIX_EPOCH</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="ff463dac21cfe2cbf8ee41ca3cd6ef5584048c23" translate="yes" xml:space="preserve">
          <source>UTF8BOM : &lt;code&gt;\uFEFF&lt;/code&gt;</source>
          <target state="translated">UTF8BOM： &lt;code&gt;\uFEFF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bc8e71f3f5fe8f28cf7f67493cc988d6461307a" translate="yes" xml:space="preserve">
          <source>UTF8BOM&lt;sup&gt;?&lt;/sup&gt;</source>
          <target state="translated">UTF8BOM&lt;sup&gt;?&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f301189dd0e6ecd6aa5f6cd826f3ac3660574f9f" translate="yes" xml:space="preserve">
          <source>UdpSocket</source>
          <target state="translated">UdpSocket</target>
        </trans-unit>
        <trans-unit id="eef9838e551c21ad60465337cf4a411d0bc3c3b0" translate="yes" xml:space="preserve">
          <source>UdpSocket::as_raw_fd</source>
          <target state="translated">UdpSocket::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="3dead55d6e23751656153f593bd69532bbdd74b4" translate="yes" xml:space="preserve">
          <source>UdpSocket::as_raw_socket</source>
          <target state="translated">UdpSocket::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="e711eb64b283a492f76bc94de05d5beae4ce3446" translate="yes" xml:space="preserve">
          <source>UdpSocket::bind</source>
          <target state="translated">UdpSocket::bind</target>
        </trans-unit>
        <trans-unit id="bd6abe4ecc1b7a3998504825b222c78c7397b977" translate="yes" xml:space="preserve">
          <source>UdpSocket::borrow</source>
          <target state="translated">UdpSocket::borrow</target>
        </trans-unit>
        <trans-unit id="d6dfaba170b099d4935948d95be3a9b2d44c1b67" translate="yes" xml:space="preserve">
          <source>UdpSocket::borrow_mut</source>
          <target state="translated">UdpSocket::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c7601afb8a1f8cbf9600b90ec208697e7f31bb37" translate="yes" xml:space="preserve">
          <source>UdpSocket::broadcast</source>
          <target state="translated">UdpSocket::broadcast</target>
        </trans-unit>
        <trans-unit id="b5425c83fcfa16a56bdac78f93d426c4d76de0d0" translate="yes" xml:space="preserve">
          <source>UdpSocket::connect</source>
          <target state="translated">UdpSocket::connect</target>
        </trans-unit>
        <trans-unit id="4ef0111b75ab32121f2408b7d5f05ebfa5b6081d" translate="yes" xml:space="preserve">
          <source>UdpSocket::fmt</source>
          <target state="translated">UdpSocket::fmt</target>
        </trans-unit>
        <trans-unit id="6967c776a7bd3c84521bc241c391c1e849c635bd" translate="yes" xml:space="preserve">
          <source>UdpSocket::from</source>
          <target state="translated">UdpSocket::from</target>
        </trans-unit>
        <trans-unit id="bb5a7c0a1436e4ab18aa912a9f605f7b18ee8765" translate="yes" xml:space="preserve">
          <source>UdpSocket::from_raw_fd</source>
          <target state="translated">UdpSocket::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="f80335b07809af571cc3df35b472a55569fb682a" translate="yes" xml:space="preserve">
          <source>UdpSocket::from_raw_socket</source>
          <target state="translated">UdpSocket::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="9027e17e6ff5173579151cfa12fc5dbe9441694f" translate="yes" xml:space="preserve">
          <source>UdpSocket::into</source>
          <target state="translated">UdpSocket::into</target>
        </trans-unit>
        <trans-unit id="a803dafad8d15d21084fc92907391bd1b059ddfd" translate="yes" xml:space="preserve">
          <source>UdpSocket::into_raw_fd</source>
          <target state="translated">UdpSocket::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="9cf9f423f72726c7578e2b5f5e2920796c1f2793" translate="yes" xml:space="preserve">
          <source>UdpSocket::into_raw_socket</source>
          <target state="translated">UdpSocket::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="3f8673b9aaf4671a169334c3798e42c1cef61195" translate="yes" xml:space="preserve">
          <source>UdpSocket::join_multicast_v4</source>
          <target state="translated">UdpSocket::join_multicast_v4</target>
        </trans-unit>
        <trans-unit id="fdb0ef8819eb18c412a260ee8e4e9ed4c176ee44" translate="yes" xml:space="preserve">
          <source>UdpSocket::join_multicast_v6</source>
          <target state="translated">UdpSocket::join_multicast_v6</target>
        </trans-unit>
        <trans-unit id="daf0d0331de8a89e9e07829bd3f8f62b73e26c9f" translate="yes" xml:space="preserve">
          <source>UdpSocket::leave_multicast_v4</source>
          <target state="translated">UdpSocket::leave_multicast_v4</target>
        </trans-unit>
        <trans-unit id="19e7ef348410341be9e9f87a0c453576eeabf4f2" translate="yes" xml:space="preserve">
          <source>UdpSocket::leave_multicast_v6</source>
          <target state="translated">UdpSocket::leave_multicast_v6</target>
        </trans-unit>
        <trans-unit id="4541378b6e55fa1b6ff0ecd59a93caf5944114ce" translate="yes" xml:space="preserve">
          <source>UdpSocket::local_addr</source>
          <target state="translated">UdpSocket::local_addr</target>
        </trans-unit>
        <trans-unit id="e1d4fbc9e9ee16f13b25d7e15d3094bef922be02" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_loop_v4</source>
          <target state="translated">UdpSocket::multicast_loop_v4</target>
        </trans-unit>
        <trans-unit id="47fea5b479b31e88d1e71ca6bcfb3bb1110ffa70" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_loop_v6</source>
          <target state="translated">UdpSocket::multicast_loop_v6</target>
        </trans-unit>
        <trans-unit id="af0afd1673286058b665d369d31b395392204948" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_ttl_v4</source>
          <target state="translated">UdpSocket::multicast_ttl_v4</target>
        </trans-unit>
        <trans-unit id="7ea92dd593f0d5cfd6700064620321c00b369e37" translate="yes" xml:space="preserve">
          <source>UdpSocket::peek</source>
          <target state="translated">UdpSocket::peek</target>
        </trans-unit>
        <trans-unit id="618b3359f531c1676b89a79683f9f10d7d9e63d6" translate="yes" xml:space="preserve">
          <source>UdpSocket::peek_from</source>
          <target state="translated">UdpSocket::peek_from</target>
        </trans-unit>
        <trans-unit id="ed605d1f943615e31a607bcc21bab5caa4744d32" translate="yes" xml:space="preserve">
          <source>UdpSocket::peer_addr</source>
          <target state="translated">UdpSocket::peer_addr</target>
        </trans-unit>
        <trans-unit id="e623079f9fa431b1604c2d3e586552e0f51cec43" translate="yes" xml:space="preserve">
          <source>UdpSocket::read_timeout</source>
          <target state="translated">UdpSocket::read_timeout</target>
        </trans-unit>
        <trans-unit id="117a240778e6d7c73d9190f8661f261267ed1dce" translate="yes" xml:space="preserve">
          <source>UdpSocket::recv</source>
          <target state="translated">UdpSocket::recv</target>
        </trans-unit>
        <trans-unit id="6b5d35c54deb341c259817d88dd2d0d29fec7a61" translate="yes" xml:space="preserve">
          <source>UdpSocket::recv_from</source>
          <target state="translated">UdpSocket::recv_from</target>
        </trans-unit>
        <trans-unit id="342543bea1d10360d53cdb0e77dc5cb9afda6331" translate="yes" xml:space="preserve">
          <source>UdpSocket::send</source>
          <target state="translated">UdpSocket::send</target>
        </trans-unit>
        <trans-unit id="22d3f7e464f346e514fa3986fce3b3f1e2571e5b" translate="yes" xml:space="preserve">
          <source>UdpSocket::send_to</source>
          <target state="translated">UdpSocket::send_to</target>
        </trans-unit>
        <trans-unit id="9e2a55f7f7b4b48356483d8d2fb5b602fa0f3530" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_broadcast</source>
          <target state="translated">UdpSocket::set_broadcast</target>
        </trans-unit>
        <trans-unit id="3f47efd4587a1a296613dd09d826c04823707540" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_loop_v4</source>
          <target state="translated">UdpSocket::set_multicast_loop_v4</target>
        </trans-unit>
        <trans-unit id="e20ba27d970b370c3419b1aeb14d08d71bc56a8c" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_loop_v6</source>
          <target state="translated">UdpSocket::set_multicast_loop_v6</target>
        </trans-unit>
        <trans-unit id="9cd522d20aa030dbf9138752a7e810a44b5efb38" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_ttl_v4</source>
          <target state="translated">UdpSocket::set_multicast_ttl_v4</target>
        </trans-unit>
        <trans-unit id="03074d339b260baa1ad044577238a1336825ab4b" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_nonblocking</source>
          <target state="translated">UdpSocket::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="d915caa0f42d8eb7576e0424ad1fb96ff110018c" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_read_timeout</source>
          <target state="translated">UdpSocket::set_read_timeout</target>
        </trans-unit>
        <trans-unit id="00311ef46c51fae7556414d73e84c73f1d7812ff" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_ttl</source>
          <target state="translated">UdpSocket::set_ttl</target>
        </trans-unit>
        <trans-unit id="febfbd7ca83810329de07b88d8fb3393c6ca4798" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_write_timeout</source>
          <target state="translated">UdpSocket::set_write_timeout</target>
        </trans-unit>
        <trans-unit id="9d7c771c5a45977006ca3dfa60a86af6dd8ee823" translate="yes" xml:space="preserve">
          <source>UdpSocket::take_error</source>
          <target state="translated">UdpSocket::take_error</target>
        </trans-unit>
        <trans-unit id="9f4ec7ded42c7be9420f00ecf5a43baac427f3a2" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_clone</source>
          <target state="translated">UdpSocket::try_clone</target>
        </trans-unit>
        <trans-unit id="124c70e6a48a5f998f83b2f8f60af01be757111c" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_from</source>
          <target state="translated">UdpSocket::try_from</target>
        </trans-unit>
        <trans-unit id="419d8221e876e08ccc71dcef9e30956e6a2336ce" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_into</source>
          <target state="translated">UdpSocket::try_into</target>
        </trans-unit>
        <trans-unit id="179be00cc6604f24b28a0eaa033c371e9b537141" translate="yes" xml:space="preserve">
          <source>UdpSocket::ttl</source>
          <target state="translated">UdpSocket::ttl</target>
        </trans-unit>
        <trans-unit id="2e57927ff8f0f2d0d53c88f359b91dce0a9fac1a" translate="yes" xml:space="preserve">
          <source>UdpSocket::type_id</source>
          <target state="translated">UdpSocket::type_id</target>
        </trans-unit>
        <trans-unit id="6e4a0fe28e49c9f074eb8b5bf8aa033213c911d5" translate="yes" xml:space="preserve">
          <source>UdpSocket::write_timeout</source>
          <target state="translated">UdpSocket::write_timeout</target>
        </trans-unit>
        <trans-unit id="ad739a773605a26e0e278e2e21fb10279a5b2fe3" translate="yes" xml:space="preserve">
          <source>Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they&amp;rsquo;re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.</source>
          <target state="translated">最终，生存期语法与连接各种参数的生存期和函数的返回值有关。连接后，Rust具有足够的信息以允许进行内存安全的操作，并禁止可能会创建悬挂指针或违反内存安全性的操作。</target>
        </trans-unit>
        <trans-unit id="4eb578990ad7468d516f19c1a212e616f769fb7d" translate="yes" xml:space="preserve">
          <source>Ultimately, we want to convert the &lt;code&gt;String&lt;/code&gt; the program reads as input into a real number type so we can compare it numerically to the secret number. We can do that by adding another line to the &lt;code&gt;main&lt;/code&gt; function body:</source>
          <target state="translated">最终，我们希望将程序作为输入读取的 &lt;code&gt;String&lt;/code&gt; 转换为实数类型，以便我们可以将其与机密数字进行比较。我们可以通过在 &lt;code&gt;main&lt;/code&gt; 函数体中添加另一行来做到这一点：</target>
        </trans-unit>
        <trans-unit id="4c83e690d015c2dda5615d91434e066248316e35" translate="yes" xml:space="preserve">
          <source>Ultimately, we want to convert the &lt;code&gt;String&lt;/code&gt; the program reads as input into a real number type so we can compare it numerically to the secret number. We can do that by adding the following two lines to the &lt;code&gt;main&lt;/code&gt; function body:</source>
          <target state="translated">最终，我们希望将程序作为输入读取的 &lt;code&gt;String&lt;/code&gt; 转换为实数类型，以便我们可以将其与机密数字进行比较。我们可以通过在 &lt;code&gt;main&lt;/code&gt; 函数主体中添加以下两行来做到这一点：</target>
        </trans-unit>
        <trans-unit id="f65abf2396d9d0e3036b5edd214ba0117f22347c" translate="yes" xml:space="preserve">
          <source>Unaligned pointer reading and writing outside of &lt;a href=&quot;../std/ptr/fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ptr/fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;../std/ptr/fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/ptr/fn.write_unaligned&quot;&gt; &lt;code&gt;write_unaligned&lt;/code&gt; &lt;/a&gt;之外的未对齐指针读写。</target>
        </trans-unit>
        <trans-unit id="7e740f17c2c4678005ceef9e2ecf547507892500" translate="yes" xml:space="preserve">
          <source>Unaligned values cannot be dropped in place, they must be copied to an aligned location first using &lt;a href=&quot;../ptr/fn.read_unaligned&quot;&gt;&lt;code&gt;ptr::read_unaligned&lt;/code&gt;&lt;/a&gt;. For packed structs, this move is done automatically by the compiler. This means the fields of packed structs are not dropped in-place.</source>
          <target state="translated">未对齐的值不能放在适当的位置，必须先使用&lt;a href=&quot;../ptr/fn.read_unaligned&quot;&gt; &lt;code&gt;ptr::read_unaligned&lt;/code&gt; &lt;/a&gt;将它们复制到对齐的位置。对于打包的结构，此移动由编译器自动完成。这意味着打包结构的字段不会就地放置。</target>
        </trans-unit>
        <trans-unit id="de8646776b21ba1fa4fa08017bad8f9f8fd98a56" translate="yes" xml:space="preserve">
          <source>Unaligned values cannot be dropped in place, they must be copied to an aligned location first using &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;ptr::read_unaligned&lt;/code&gt;&lt;/a&gt;. For packed structs, this move is done automatically by the compiler. This means the fields of packed structs are not dropped in-place.</source>
          <target state="translated">未对齐的值不能放在适当的位置，必须先使用&lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;ptr::read_unaligned&lt;/code&gt; &lt;/a&gt;将它们复制到对齐的位置。对于打包的结构，此移动由编译器自动完成。这意味着打包结构的字段不会就地放置。</target>
        </trans-unit>
        <trans-unit id="a19c02a20defb4e5a19ad20ddc9f198b595912c2" translate="yes" xml:space="preserve">
          <source>Unaligned values cannot be dropped in place, they must be copied to an aligned location first:</source>
          <target state="translated">不对齐的值不能原地放弃,必须先复制到对齐的位置。</target>
        </trans-unit>
        <trans-unit id="06561b17b729c80e40714208c692221607fb499c" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;!&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt;</source>
          <target state="translated">一元 &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;!&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;mut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eaeaaeab2b8c39fed19b6ad2f8f02ca13156250d" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i128::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i128::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; i128::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; i128::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="bf60089baa8e1b12ead76beae70eb523584bfcff" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i16::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i16::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; i16::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; i16::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="57d2d3f2c8b1f0f83b5c8311b2489a069d73a68e" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i32::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i32::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; i32::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; i32::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="04a73576177ebee5f439e851247328471bb0c25a" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i64::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i64::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; i64::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; i64::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="98456ae98d27b023cd6297deba77970fa8fe5737" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i8::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i8::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; i8::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; i8::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="181cfbbcfa7badb7116e737475005644ef4b02af" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; isize::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; isize::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; isize::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; isize::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="6e7dffee5ddf31f6bb308589f3d1034539c1ed44" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u128::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u128::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; u128::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; u128::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="f17243b2da1ec0e37d5c613451d7b628005e7af8" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u16::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u16::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; u16::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; u16::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="e8a542644a4285f9d7b2a44c5f2775b79db39a7b" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u32::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u32::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; u32::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; u32::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="bae0a8aba40c37aa489fd12e7bd803aa59ab9b06" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u64::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u64::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; u64::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; u64::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="217823d7931de445dbac4c7c600ba231f5d01a32" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u8::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u8::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; u8::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; u8::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="3784f542c08995d9da31ec918116bee7959049c6" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; usize::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; usize::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数加法。假设不会发生溢出，则计算 &lt;code&gt;self + rhs&lt;/code&gt; 。当 &lt;code&gt;self + rhs &amp;gt; usize::MAX&lt;/code&gt; 或 &lt;code&gt;self + rhs &amp;lt; usize::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="e46989e35b2cb886206f7735df0231524fbe7ccd" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i128::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i128::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; i128::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; i128::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="e25f8da52dbbff157dca4617b3f1a59b2bfc36a7" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i16::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i16::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; i16::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; i16::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="35f739b4aaf5e35f8f41b2fc34c5c1af364fd56e" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i32::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i32::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; i32::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; i32::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="68857c1be152e69874bd8a3d7df9e0082927641b" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i64::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i64::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; i64::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; i64::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="43ba5e2f667a70448c2bc30e68127889e33fbcb0" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i8::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i8::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; i8::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; i8::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="2d8ea5bd84cde0d4b308a1762db7027c570a55b6" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; isize::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; isize::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; isize::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; isize::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="b9ddf676d896b37ebffa48cd9f6ff3ee28c7f039" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u128::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u128::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; u128::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; u128::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="a3bb62e69c1601ccfe0ef959e2a876a22790ef04" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u16::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u16::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; u16::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; u16::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="e65b8aaadedff35c0a62f7a135254f90f4ccab0a" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u32::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u32::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; u32::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; u32::MIN&lt;/code&gt; 时，这将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="111c8c208814caa52463838dcecbd292a0ff4bce" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u64::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u64::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; u64::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; u64::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="fa225d3efab56513dbab5c9b4e8a9843ef6fdaf6" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u8::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u8::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; u8::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; u8::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="357967f063fbfe8af622e52b6f92d48adbffb3ef" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; usize::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; usize::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数乘法。假设不会发生溢出，则计算 &lt;code&gt;self * rhs&lt;/code&gt; 。当 &lt;code&gt;self * rhs &amp;gt; usize::MAX&lt;/code&gt; 或 &lt;code&gt;self * rhs &amp;lt; usize::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="fe8dd13c5dff45f9d9fade7c23010632d824bbc5" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i128::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i128::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; i128::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; i128::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="4f796122fc9def8df4649d0b2d125dd1cd6e291b" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i16::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i16::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; i16::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; i16::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="84c8864cef260c48a4e59f2b70d655fdf389430b" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i32::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i32::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; i32::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; i32::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="31a325f491fcfe3291d440373b764f580c3f0582" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i64::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i64::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; i64::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; i64::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="c6cd990380c2a0d5b9b2454a9569e6e2c5a42f96" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i8::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i8::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; i8::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; i8::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="af189c7306f2089208258aece688aaa4cbb8ac02" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; isize::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; isize::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; isize::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; isize::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="ba6ec2a37ff7eb25e8c786febab4ab98bbd27660" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u128::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u128::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; u128::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; u128::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="baacb800b9617663d503dd16c499fbf3c18d485b" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u16::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u16::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; u16::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; u16::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="026df7825e54c4d4d1564e862d070306e0b0ad6b" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u32::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u32::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; u32::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; u32::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="7acb45d177f4b13e2bbada8a1a7786dfd123ebb3" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u64::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u64::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; u64::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; u64::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="474d17a8d47d3b421384881d2bc565471dac82d4" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u8::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u8::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; u8::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; u8::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="f27d966c87f4516cf43f8b199f1a37517f69d9bb" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; usize::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; usize::MIN&lt;/code&gt;.</source>
          <target state="translated">未经检查的整数减法。假设不会发生溢出，则计算 &lt;code&gt;self - rhs&lt;/code&gt; 。当 &lt;code&gt;self - rhs &amp;gt; usize::MAX&lt;/code&gt; 或 &lt;code&gt;self - rhs &amp;lt; usize::MIN&lt;/code&gt; 时，这将导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="1c9a7a4592fa01f0c87a973312a3417b3c758e1e" translate="yes" xml:space="preserve">
          <source>Uncovered type</source>
          <target state="translated">未覆盖型</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">未定义的行为</target>
        </trans-unit>
        <trans-unit id="370c58f039e07727be3fca997e7473eb72b353e5" translate="yes" xml:space="preserve">
          <source>Under the &lt;a href=&quot;../type-layout#the-default-representation&quot;&gt;default representation&lt;/a&gt;, the specified discriminant is interpreted as an &lt;code&gt;isize&lt;/code&gt; value although the compiler is allowed to use a smaller type in the actual memory layout. The size and thus acceptable values can be changed by using a &lt;a href=&quot;../type-layout#primitive-representations&quot;&gt;primitive representation&lt;/a&gt; or the &lt;a href=&quot;../type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt; representation&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;../type-layout#the-default-representation&quot;&gt;默认表示形式下&lt;/a&gt;，尽管允许编译器在实际的内存布局中使用较小的类型，但指定的判别式将解释为 &lt;code&gt;isize&lt;/code&gt; 值。大小和可接受的值可以通过使用&lt;a href=&quot;../type-layout#primitive-representations&quot;&gt;原始表示形式&lt;/a&gt;或&lt;a href=&quot;../type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; 表示形式&lt;/a&gt;进行更改。</target>
        </trans-unit>
        <trans-unit id="934025592a349e0ccdf3fcea702e3b4fab1b4701" translate="yes" xml:space="preserve">
          <source>Under the surface, the &lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; macros use the operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Debug&lt;/code&gt; traits. All the primitive types and most of the standard library types implement these traits. For structs and enums that you define, you&amp;rsquo;ll need to implement &lt;code&gt;PartialEq&lt;/code&gt; to assert that values of those types are equal or not equal. You&amp;rsquo;ll need to implement &lt;code&gt;Debug&lt;/code&gt; to print the values when the assertion fails. Because both traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward as adding the &lt;code&gt;#[derive(PartialEq, Debug)]&lt;/code&gt; annotation to your struct or enum definition. See Appendix C, &lt;a href=&quot;appendix-03-derivable-traits&quot;&gt;&amp;ldquo;Derivable Traits,&amp;rdquo;&lt;/a&gt; for more details about these and other derivable traits.</source>
          <target state="translated">在表面之下， &lt;code&gt;assert_eq!&lt;/code&gt; 和 &lt;code&gt;assert_ne!&lt;/code&gt; 宏分别使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符。当断言失败时，这些宏将使用调试格式打印其参数，这意味着要比较的值必须实现 &lt;code&gt;PartialEq&lt;/code&gt; 和 &lt;code&gt;Debug&lt;/code&gt; 特性。所有原始类型和大多数标准库类型都实现了这些特征。对于您定义的结构和枚举，您需要实现 &lt;code&gt;PartialEq&lt;/code&gt; 来断言那些类型的值相等或不相等。您需要实现 &lt;code&gt;Debug&lt;/code&gt; 在断言失败时打印值。因为这两个特征都是可衍生特征，如第5章中的清单5-12所述，这通常很简单，就像在结构或枚举定义中添加 &lt;code&gt;#[derive(PartialEq, Debug)]&lt;/code&gt; 批注一样简单。有关这些及其他衍生特征的更多详细信息&lt;a href=&quot;appendix-03-derivable-traits&quot;&gt;，&lt;/a&gt;请参见附录C，&amp;ldquo;衍生特征&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c52b1bbb83c6ff68ef901a5b3c68e708f2da78aa" translate="yes" xml:space="preserve">
          <source>Underlying System calls</source>
          <target state="translated">基本系统调用</target>
        </trans-unit>
        <trans-unit id="ca035a5ce4c3df59c37ddda21e0189a6380e3b1f" translate="yes" xml:space="preserve">
          <source>Underscore</source>
          <target state="translated">Underscore</target>
        </trans-unit>
        <trans-unit id="7bd1424f9d38ad3f094e622e30f38d61cffee843" translate="yes" xml:space="preserve">
          <source>Underscore Imports</source>
          <target state="translated">下划线进口</target>
        </trans-unit>
        <trans-unit id="e31df2c04ec1e4b0b36bedd38e82d9eeb2726bb3" translate="yes" xml:space="preserve">
          <source>Understanding Ownership</source>
          <target state="translated">了解所有权</target>
        </trans-unit>
        <trans-unit id="f50d8069b5b46a2b00b55d627b937dadef8d4c8b" translate="yes" xml:space="preserve">
          <source>Undo the effect of leaked guards on the borrow state of the &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="translated">撤消泄漏的防护对 &lt;code&gt;RefCell&lt;/code&gt; 的借用状态的影响。</target>
        </trans-unit>
        <trans-unit id="2bd6a0012c9128bdcdb48f1df7a5232a746b1dd8" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is not safe to share across threads. When &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; manages the reference count, it adds to the count for each call to &lt;code&gt;clone&lt;/code&gt; and subtracts from the count when each clone is dropped. But it doesn&amp;rsquo;t use any concurrency primitives to make sure that changes to the count can&amp;rsquo;t be interrupted by another thread. This could lead to wrong counts&amp;mdash;subtle bugs that could in turn lead to memory leaks or a value being dropped before we&amp;rsquo;re done with it. What we need is a type exactly like &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; but one that makes changes to the reference count in a thread-safe way.</source>
          <target state="translated">不幸的是， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 在线程之间共享是不安全的。当 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 管理参考计数时，它将添加到每个 &lt;code&gt;clone&lt;/code&gt; 调用的计数中，并在删除每个克隆时从计数中减去。但是它不使用任何并发原语来确保对计数的更改不会被另一个线程中断。这可能会导致错误的计数-细微的错误可能会导致内存泄漏或在我们完成此操作之前丢弃值。我们需要的是一种与 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 完全相同的类型，但是需要以线程安全的方式更改引用计数的类型。</target>
        </trans-unit>
        <trans-unit id="ccb18a8dd577d217916f372c4de88677ea8361fc" translate="yes" xml:space="preserve">
          <source>Unfortunately, it&amp;rsquo;s not straightforward to disable the automatic &lt;code&gt;drop&lt;/code&gt; functionality. Disabling &lt;code&gt;drop&lt;/code&gt; isn&amp;rsquo;t usually necessary; the whole point of the &lt;code&gt;Drop&lt;/code&gt; trait is that it&amp;rsquo;s taken care of automatically. Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the &lt;code&gt;drop&lt;/code&gt; method that releases the lock so that other code in the same scope can acquire the lock. Rust doesn&amp;rsquo;t let you call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually; instead you have to call the &lt;code&gt;std::mem::drop&lt;/code&gt; function provided by the standard library if you want to force a value to be dropped before the end of its scope.</source>
          <target state="translated">不幸的是，禁用自动 &lt;code&gt;drop&lt;/code&gt; 功能并非易事。禁用 &lt;code&gt;drop&lt;/code&gt; 通常是不必要的; &lt;code&gt;Drop&lt;/code&gt; 特性的全部要点是它会自动得到照顾。但是，有时您可能希望提早清理值。一个示例是使用管理锁的智能指针时：您可能要强制执行释放该锁的 &lt;code&gt;drop&lt;/code&gt; 方法，以便同一作用域中的其他代码可以获取该锁。Rust不允许您手动调用 &lt;code&gt;Drop&lt;/code&gt; 特性的 &lt;code&gt;drop&lt;/code&gt; 方法。相反，您必须调用 &lt;code&gt;std::mem::drop&lt;/code&gt; 如果要强制在值范围结束之前删除值，则由标准库提供的函数。</target>
        </trans-unit>
        <trans-unit id="1444761777045d9a10886b422e6940c76965059f" translate="yes" xml:space="preserve">
          <source>Unfortunately, it&amp;rsquo;s not straightforward to disable the automatic &lt;code&gt;drop&lt;/code&gt; functionality. Disabling &lt;code&gt;drop&lt;/code&gt; isn&amp;rsquo;t usually necessary; the whole point of the &lt;code&gt;Drop&lt;/code&gt; trait is that it&amp;rsquo;s taken care of automatically. Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the &lt;code&gt;drop&lt;/code&gt; method that releases the lock to run so other code in the same scope can acquire the lock. Rust doesn&amp;rsquo;t let you call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually; instead you have to call the &lt;code&gt;std::mem::drop&lt;/code&gt; function provided by the standard library if you want to force a value to be dropped before the end of its scope.</source>
          <target state="translated">不幸的是，禁用自动 &lt;code&gt;drop&lt;/code&gt; 功能并非易事。禁用 &lt;code&gt;drop&lt;/code&gt; 通常是不必要的; &lt;code&gt;Drop&lt;/code&gt; 特性的全部要点是它会自动得到照顾。但是，有时您可能希望提早清理值。一个示例是使用管理锁的智能指针时：您可能要强制释放释放锁的 &lt;code&gt;drop&lt;/code&gt; 方法运行，以便同一作用域中的其他代码可以获取该锁。Rust不允许您手动调用 &lt;code&gt;Drop&lt;/code&gt; 特性的 &lt;code&gt;drop&lt;/code&gt; 方法。相反，您必须调用 &lt;code&gt;std::mem::drop&lt;/code&gt; 如果要强制在值范围结束之前删除值，则由标准库提供的函数。</target>
        </trans-unit>
        <trans-unit id="1a531b7898235009a0cc7b2eec486ea25b9d6d2f" translate="yes" xml:space="preserve">
          <source>Unfortunately, the code in Listing 7-5 still results in an error, as shown in Listing 7-6.</source>
          <target state="translated">不幸的是,清单7-5中的代码仍然导致了一个错误,如清单7-6所示。</target>
        </trans-unit>
        <trans-unit id="be79a988f81db8bfcf6945f3ba47d61010546fc9" translate="yes" xml:space="preserve">
          <source>Unicode escapes</source>
          <target state="translated">统一码逃逸</target>
        </trans-unit>
        <trans-unit id="ae0d9cce1182bdae15059a991a47bf01218e3825" translate="yes" xml:space="preserve">
          <source>Unicode escapes are never generated by this function.</source>
          <target state="translated">该函数不会产生Unicode转义。</target>
        </trans-unit>
        <trans-unit id="049c2f43b308773f947249e6515dfdd4cc3c35a2" translate="yes" xml:space="preserve">
          <source>Unicode is designed such that this effectively decodes bytes with the character encoding that IANA calls ISO-8859-1. This encoding is compatible with ASCII.</source>
          <target state="translated">Unicode的设计使它能有效地用IANA称为ISO-8859-1的字符编码解码字节。这种编码与ASCII兼容。</target>
        </trans-unit>
        <trans-unit id="045e4620605ab61ee2d00d3c61380dde56a437e0" translate="yes" xml:space="preserve">
          <source>Unicode string slices.</source>
          <target state="translated">Unicode字符串切片。</target>
        </trans-unit>
        <trans-unit id="ea8b0aa9835ad896a48c3cd1f5107ad4d8a0d9e1" translate="yes" xml:space="preserve">
          <source>UnicodeVersion</source>
          <target state="translated">UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="2e2480da297a5a795e54a8b1e8174027d5cb3056" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::borrow</source>
          <target state="translated">UnicodeVersion::borrow</target>
        </trans-unit>
        <trans-unit id="89b51103925ce314bbcaaf20a8fe1cadc3924003" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::borrow_mut</source>
          <target state="translated">UnicodeVersion::borrow_mut</target>
        </trans-unit>
        <trans-unit id="88a2e4badb33e94ea8a5b499e6fc153387a0beb3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clamp</source>
          <target state="translated">UnicodeVersion::clamp</target>
        </trans-unit>
        <trans-unit id="d17cdcafd0174814c16b4f219e4fed72e9bd469a" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone</source>
          <target state="translated">UnicodeVersion::clone</target>
        </trans-unit>
        <trans-unit id="47b2336d0c0eb30610891e9aeb66476192776d1f" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone_from</source>
          <target state="translated">UnicodeVersion::clone_from</target>
        </trans-unit>
        <trans-unit id="df3118b48825d7934a06fa42be12de85a41743a3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone_into</source>
          <target state="translated">UnicodeVersion::clone_into</target>
        </trans-unit>
        <trans-unit id="a501e28c8f674e6c8775cd5763a1269e58854a95" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::cmp</source>
          <target state="translated">UnicodeVersion::cmp</target>
        </trans-unit>
        <trans-unit id="eb0f8f28b23626496734a42b66b3d04fceab6e15" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::eq</source>
          <target state="translated">UnicodeVersion::eq</target>
        </trans-unit>
        <trans-unit id="d50614eac8572f390490b398b9df8d2ee6162d01" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::fmt</source>
          <target state="translated">UnicodeVersion::fmt</target>
        </trans-unit>
        <trans-unit id="870f165e6cd936b143cbc0dbc14afac1093420d0" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::from</source>
          <target state="translated">UnicodeVersion::from</target>
        </trans-unit>
        <trans-unit id="2bad969f3e70b400e54b881fe8536995db1f2994" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::ge</source>
          <target state="translated">UnicodeVersion::ge</target>
        </trans-unit>
        <trans-unit id="08f3a8d2999b98ac5f6c67691d5bdd1bc1a0e145" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::gt</source>
          <target state="translated">UnicodeVersion::gt</target>
        </trans-unit>
        <trans-unit id="b5a9d9239e831f7ef74e7e53b12fa0fd62d71a97" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::into</source>
          <target state="translated">UnicodeVersion::into</target>
        </trans-unit>
        <trans-unit id="1ea14b2a7575169ecf16f30acb48c3409c34b763" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::le</source>
          <target state="translated">UnicodeVersion::le</target>
        </trans-unit>
        <trans-unit id="eb08588571d008fa3a48093f6cad0aa8209e47e3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::lt</source>
          <target state="translated">UnicodeVersion::lt</target>
        </trans-unit>
        <trans-unit id="809dd77e054b744c6372ff89e0b31e14994e27e7" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::max</source>
          <target state="translated">UnicodeVersion::max</target>
        </trans-unit>
        <trans-unit id="1c035e39a67ae5609815950cc75aebf117385e95" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::min</source>
          <target state="translated">UnicodeVersion::min</target>
        </trans-unit>
        <trans-unit id="064f84b6703cb5f6f68f68e7fc2c4d251f631296" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::ne</source>
          <target state="translated">UnicodeVersion::ne</target>
        </trans-unit>
        <trans-unit id="7c59df82b034e552f2c3f4f3995f283f8463f626" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::partial_cmp</source>
          <target state="translated">UnicodeVersion::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cd2d6e2e056d2c57e62b0e2e433f8281504be6b4" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::to_owned</source>
          <target state="translated">UnicodeVersion::to_owned</target>
        </trans-unit>
        <trans-unit id="c51cc398d26afae848ea754f781315242ac4e979" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::try_from</source>
          <target state="translated">UnicodeVersion::try_from</target>
        </trans-unit>
        <trans-unit id="a8b18a0ff13e1e11bb861c761bf0dc70df4c71e0" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::try_into</source>
          <target state="translated">UnicodeVersion::try_into</target>
        </trans-unit>
        <trans-unit id="eecb3bfce19f7a3ae0d89e37123a7c922b8eeab9" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::type_id</source>
          <target state="translated">UnicodeVersion::type_id</target>
        </trans-unit>
        <trans-unit id="6ec76a97b7c965b8294c7506df62a1b9b03c72be" translate="yes" xml:space="preserve">
          <source>Uninhabited</source>
          <target state="translated">Uninhabited</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="431e2898d7b9070b1bc9e3d0e0fac72fa778d000" translate="yes" xml:space="preserve">
          <source>Union std::mem::MaybeUninit</source>
          <target state="translated">Union std::mem::MaybeUninit(联盟)</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="translated">联盟类型</target>
        </trans-unit>
        <trans-unit id="00002b164c08859d5a15579e55c8f17ce6478546" translate="yes" xml:space="preserve">
          <source>Unions</source>
          <target state="translated">Unions</target>
        </trans-unit>
        <trans-unit id="0b4b57a2ff8ee5597f14593b11685d486d14ac1f" translate="yes" xml:space="preserve">
          <source>Unions and &lt;code id=&quot;unions-and-drop&quot;&gt;Drop&lt;/code&gt;</source>
          <target state="translated">联合与 &lt;code id=&quot;unions-and-drop&quot;&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70ff5b52f206cf593da36650b6dcc3e0e0087048" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access just interprets the storage at the type of the field used for the access. Reading a union field reads the bits of the union at the field's type. Fields might have a non-zero offset (except when &lt;code&gt;#[repr(C)]&lt;/code&gt; is used); in that case the bits starting at the offset of the fields are read. It is the programmer's responsibility to make sure that the data is valid at the field's type. Failing to do so results in undefined behavior. For example, reading the value &lt;code&gt;3&lt;/code&gt; at type &lt;code&gt;bool&lt;/code&gt; is undefined behavior. Effectively, writing to and then reading from a &lt;code&gt;#[repr(C)]&lt;/code&gt; union is analogous to a &lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt; from the type used for writing to the type used for reading.</source>
          <target state="translated">工会没有&amp;ldquo;活跃领域&amp;rdquo;的概念。取而代之的是，每个联合访问都只是根据访问所使用的字段类型来解释存储。读取并集字段会读取该字段类型的并集位。字段的偏移量可能为非零（使用 &lt;code&gt;#[repr(C)]&lt;/code&gt; 时除外）；在这种情况下，将读取从字段偏移量开始的位。程序员有责任确保数据对字段类型有效。否则，将导致未定义的行为。例如，在 &lt;code&gt;bool&lt;/code&gt; 类型上读取值 &lt;code&gt;3&lt;/code&gt; 是未定义的行为。有效地，写入并随后从读 &lt;code&gt;#[repr(C)]&lt;/code&gt; 工会类似于一个&lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt; 从用于写入的类型到用于读取的类型。</target>
        </trans-unit>
        <trans-unit id="9ee9dda7ec1e961b1ea8bab0ad66f79036feccce" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access just interprets the storage at the type of the field used for the access. Reading a union field reads the bits of the union at the field's type. It is the programmer's responsibility to make sure that the data is valid at that type. Failing to do so results in undefined behavior. For example, reading the value &lt;code&gt;3&lt;/code&gt; at type &lt;code&gt;bool&lt;/code&gt; is undefined behavior. Effectively, writing to and then reading from a union is analogous to a &lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt; from the type used for writing to the type used for reading.</source>
          <target state="translated">工会没有&amp;ldquo;活跃领域&amp;rdquo;的概念。取而代之的是，每个联合访问都只是按访问所使用的字段类型来解释存储。读取并集字段将读取该字段类型的并集位。程序员有责任确保该类型的数据有效。否则，将导致未定义的行为。例如，在 &lt;code&gt;bool&lt;/code&gt; 类型上读取值 &lt;code&gt;3&lt;/code&gt; 是未定义的行为。有效地，写入，然后从联合读取类似于一个&lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt;从用于写入用于读取的类型的类型。</target>
        </trans-unit>
        <trans-unit id="5078dc66c307401e9db5997fdb77c1b9baee7912" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access transmutes parts of the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../items/unions&quot;&gt;item&lt;/a&gt; documentation for further details.</source>
          <target state="translated">工会没有&amp;ldquo;活跃领域&amp;rdquo;的概念。取而代之的是，每个联合访问将联合内容的部分内容转换为被访问字段的类型。由于转换会导致意外或不确定的行为，因此从联合字段读取或写入未实现&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;的字段要求 &lt;code&gt;unsafe&lt;/code&gt; 。有关更多详细信息，请参阅&lt;a href=&quot;../items/unions&quot;&gt;项目&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1f74eae91f9cc29430ec662dac7122d37bb39e1b" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access transmutes parts of the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field, or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; or has a &lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; type. See the &lt;a href=&quot;../items/unions&quot;&gt;item&lt;/a&gt; documentation for further details.</source>
          <target state="translated">工会没有&amp;ldquo;活跃领域&amp;rdquo;的概念。取而代之的是，每个联合访问将联合内容的部分内容转换为被访问字段的类型。由于转换会导致意外或不确定的行为，因此从联合字段读取或向未实现&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;或具有&lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;ManuallyDrop&lt;/code&gt; &lt;/a&gt;类型的字段写入数据将要求 &lt;code&gt;unsafe&lt;/code&gt; 。有关更多详细信息，请参阅&lt;a href=&quot;../items/unions&quot;&gt;项目&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="fa92690b772357d1ef06b6b63773a7916e701512" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access transmutes parts of the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field, or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../items/unions&quot;&gt;item&lt;/a&gt; documentation for further details.</source>
          <target state="translated">工会没有&amp;ldquo;活跃领域&amp;rdquo;的概念。取而代之的是，每个联合访问将联合内容的部分内容转换为被访问字段的类型。由于转换会导致意外或不确定的行为，因此从联合字段读取或写入未实现&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;的字段要求 &lt;code&gt;unsafe&lt;/code&gt; 。有关更多详细信息，请参阅&lt;a href=&quot;../items/unions&quot;&gt;项目&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="cb2b3efb0aed2e9062949d0d6efb28c840e4bdd0" translate="yes" xml:space="preserve">
          <source>Unique immutable borrows in captures</source>
          <target state="translated">捕获中独特的不可改变的借用。</target>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="translated">单元测试</target>
        </trans-unit>
        <trans-unit id="fc4dd0d2f506c2585198c093fe3355566c69c50a" translate="yes" xml:space="preserve">
          <source>Unit struct expression</source>
          <target state="translated">单位结构表达式</target>
        </trans-unit>
        <trans-unit id="43b9bb5cd29f3ad5aabe2057140ec12468595ac3" translate="yes" xml:space="preserve">
          <source>Unit structs are most commonly used as marker. They have a size of zero bytes, but unlike empty enums they can be instantiated, making them isomorphic to the unit type &lt;code&gt;()&lt;/code&gt;. Unit structs are useful when you need to implement a trait on something, but don't need to store any data inside it.</source>
          <target state="translated">单元结构最常用作标记。它们的大小为零字节，但是与空枚举不同，它们可以实例化，使其与单元类型 &lt;code&gt;()&lt;/code&gt; 同构。当您需要在某物上实现特征但不需要在其中存储任何数据时，单元结构很有用。</target>
        </trans-unit>
        <trans-unit id="29ad46d73653a34f4423b5d45017917794627b45" translate="yes" xml:space="preserve">
          <source>Unit-Like Structs Without Any Fields</source>
          <target state="translated">无字段的类单元结构</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="5ebca32071333343f0c708c52c532da98a8cd4f1" translate="yes" xml:space="preserve">
          <source>Unix credential.</source>
          <target state="translated">Unix证书。</target>
        </trans-unit>
        <trans-unit id="b00eb2991ece231ee34e1193574afcc6b4379e47" translate="yes" xml:space="preserve">
          <source>Unix peer credentials.</source>
          <target state="translated">Unix同行凭证。</target>
        </trans-unit>
        <trans-unit id="122365e7dc1f75db94d30ca063c2e50b567c06af" translate="yes" xml:space="preserve">
          <source>Unix-specific extension methods for &lt;a href=&quot;../../../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.direntry&quot;&gt; &lt;code&gt;fs::DirEntry&lt;/code&gt; &lt;/a&gt;的特定于Unix的扩展方法。</target>
        </trans-unit>
        <trans-unit id="40290eba8741a7fb561802cc4fd7a5f03fc12be7" translate="yes" xml:space="preserve">
          <source>Unix-specific extension to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module</source>
          <target state="translated">特定于Unix的 &lt;code&gt;std::ffi&lt;/code&gt; 模块中的原语扩展</target>
        </trans-unit>
        <trans-unit id="abb9e72437d43bc0a2c9b376ba3ef37ee9f0016a" translate="yes" xml:space="preserve">
          <source>Unix-specific extension to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="translated">特定于Unix的 &lt;code&gt;std::ffi&lt;/code&gt; 模块中的原语扩展。</target>
        </trans-unit>
        <trans-unit id="7d8456cebfaf04274630f018fe98c85f0928fd59" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions for &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">特定于Unix的&lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="1f656dcd59d506e815045da5be6675c4c9594d4c" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions for &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;fs::FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;fs::FileType&lt;/code&gt; &lt;/a&gt;的特定于Unix的扩展名。</target>
        </trans-unit>
        <trans-unit id="44ae3204adf61398987a8d1c1ea0cc0ee7054526" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.dirbuilder&quot;&gt;&lt;code&gt;fs::DirBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix的&lt;a href=&quot;../../../fs/struct.dirbuilder&quot;&gt; &lt;code&gt;fs::DirBuilder&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="5c055cc3e8d38d074a1699c2467aa73f8a67ec8b" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix特定于&lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 的&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="edc026b1b59822f06029958a23a0df330b02c688" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;fs::File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">特定于Unix的&lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;fs::File&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="f808e6d0f3cef15729ba995896155633f9c4e702" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix的&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="a398ee8c4edc244dd48383efb674694800d11b42" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix的&lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt; &lt;code&gt;fs::OpenOptions&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="5c3e2254255ed122649ef706ca6351a05878a982" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.permissions&quot;&gt;&lt;code&gt;fs::Permissions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix的&lt;a href=&quot;../../../fs/struct.permissions&quot;&gt; &lt;code&gt;fs::Permissions&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="debd12446f93bf566a622bdf802607a7783bf6af" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">特定于Unix的扩展来&lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt; &lt;code&gt;process::ExitStatus&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04090d3e2df7580a6d7cec986c08600c0473b452" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">特定于Unix的&lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="a44e2e0da5854a8ebdf4095318d97783ef5ced71" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt;&lt;code&gt;thread::JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix特定于&lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt; &lt;code&gt;thread::JoinHandle&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="d0f569dc194098f87c8bc0882017a7d0c963c955" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to general I/O primitives</source>
          <target state="translated">通用I/O基元的Unix特定扩展</target>
        </trans-unit>
        <trans-unit id="8e6df3ed34620f11bd872bbbdadc0905f4158426" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to general I/O primitives.</source>
          <target state="translated">通用I/O基元的Unix专用扩展。</target>
        </trans-unit>
        <trans-unit id="3789837939ff4014248adcb7118252ef4bacad14" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="translated">特定于Unix的 &lt;code&gt;std::fs&lt;/code&gt; 模块中的原语扩展。</target>
        </trans-unit>
        <trans-unit id="b4f34673a7f1203fc92e8429aa07449552c09698" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::process&lt;/code&gt; module.</source>
          <target state="translated">特定于Unix的 &lt;code&gt;std::process&lt;/code&gt; 模块中的原语扩展。</target>
        </trans-unit>
        <trans-unit id="60cfd734bf76c756b8e059f4a9d1700ff9a4713c" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::thread&lt;/code&gt; module.</source>
          <target state="translated">特定于Unix的 &lt;code&gt;std::thread&lt;/code&gt; 模块中的原语扩展。</target>
        </trans-unit>
        <trans-unit id="2ffca9f4f9cc7c8dd85f78563efe7167f6d2b47d" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="translated">特定于Unix的&lt;a href=&quot;../../../process/struct.command&quot;&gt; &lt;code&gt;process::Command&lt;/code&gt; &lt;/a&gt;构建器扩展。</target>
        </trans-unit>
        <trans-unit id="e0d68049fb554c75225dfe9c03296f580e460278" translate="yes" xml:space="preserve">
          <source>Unix-specific networking functionality</source>
          <target state="translated">Unix特有的网络功能</target>
        </trans-unit>
        <trans-unit id="547d566a755a9f281512ec4438e2afbe2e8555f4" translate="yes" xml:space="preserve">
          <source>Unix-specific networking functionality.</source>
          <target state="translated">Unix特有的网络功能。</target>
        </trans-unit>
        <trans-unit id="6dc7e1fbf723c58f49b9c7b7c9486e8910ff303f" translate="yes" xml:space="preserve">
          <source>Unix-specific primitives available on all unix platforms</source>
          <target state="translated">适用于所有unix平台的Unix专用基元</target>
        </trans-unit>
        <trans-unit id="5d6c2bdf64d7b2867f336fc3ecf7da3868d50a13" translate="yes" xml:space="preserve">
          <source>Unix-specific primitives available on all unix platforms.</source>
          <target state="translated">所有unix平台上的Unix专用基元。</target>
        </trans-unit>
        <trans-unit id="559d58e1a8d746d91fa3600f29dbbb56c9ca25cd" translate="yes" xml:space="preserve">
          <source>UnixDatagram</source>
          <target state="translated">UnixDatagram</target>
        </trans-unit>
        <trans-unit id="67d62a4911bb1e0d83beb3b448aab6df455a9a7a" translate="yes" xml:space="preserve">
          <source>UnixListener</source>
          <target state="translated">UnixListener</target>
        </trans-unit>
        <trans-unit id="941c06c80eb53ce02937637ee16d42217c4f223a" translate="yes" xml:space="preserve">
          <source>UnixStream</source>
          <target state="translated">UnixStream</target>
        </trans-unit>
        <trans-unit id="55add9bdacff5201b17fde89c00c759c2cb86e1e" translate="yes" xml:space="preserve">
          <source>Unless you are in such a situation, higher-level and more foolproof APIs like &lt;code&gt;get&lt;/code&gt; should be preferred.</source>
          <target state="translated">除非您处于这种情况下，否则应首选更高级别且更简单的API（例如 &lt;code&gt;get&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="a444b89922afd7135047b0a62b434579bde022e6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.compare_exchange&quot;&gt;&lt;code&gt;compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;#method.compare_exchange&quot;&gt; &lt;code&gt;compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假地失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="6e589b43f3082da98ca0e4f046ea8ace2906bf51" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="translated">与&lt;a href=&quot;#method.from_utf8_lossy&quot;&gt; &lt;code&gt;from_utf8_lossy&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;from_utf16_lossy&lt;/code&gt; 返回 &lt;code&gt;String&lt;/code&gt; ,因为从UTF-16到UTF-8的转换需要分配内存。</target>
        </trans-unit>
        <trans-unit id="1e5e6606c716b7d8ea23880ff26dd47bb4cb772b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="translated">与&lt;a href=&quot;#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt;不同，这通常意味着操作参数有效，但是错误是由格式错误的输入数据引起的。</target>
        </trans-unit>
        <trans-unit id="42150160f2ba583b7d6c6990db7fe7b9390515b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../convert/fn.identity&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="translated">与&lt;a href=&quot;../convert/fn.identity&quot;&gt; &lt;code&gt;std::convert::identity&lt;/code&gt; &lt;/a&gt;，鼓励Rust编译器假设 &lt;code&gt;black_box&lt;/code&gt; 可以使用允许Rust代码的任何可能有效方式使用 &lt;code&gt;dummy&lt;/code&gt; ，而不会在调用代码中引入未定义的行为。此属性使 &lt;code&gt;black_box&lt;/code&gt; 对于编写不需要进行某些优化（例如基准测试）的代码很有用。</target>
        </trans-unit>
        <trans-unit id="e8fe9eebd36a2bd7140bc3ec3fdc0c32e569dabf" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted allocations between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="translated">与&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 使用原子运算进行引用计数。这意味着它是线程安全的。缺点是原子操作比普通的内存访问更昂贵。如果您不在线程之间共享引用计数的分配，请考虑使用&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;来降低开销。&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;是安全的默认值，因为编译器将捕获在线程之间发送&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;任何尝试。但是，图书馆可能会选择 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 以便为图书馆使用者提供更大的灵活性。</target>
        </trans-unit>
        <trans-unit id="398c5c34b191e4676dc6961558a4a76db9314267" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted values between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="translated">与&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 使用原子运算进行引用计数。这意味着它是线程安全的。缺点是原子操作比普通的内存访问更昂贵。如果不在线程之间共享引用计数的值，请考虑使用&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;来降低开销。&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;是安全的默认设置，因为编译器将捕获在线程之间发送&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;任何尝试。但是，图书馆可能选择 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 以便为图书馆使用者提供更大的灵活性。</target>
        </trans-unit>
        <trans-unit id="e29ce9f9179b04ed1ae04e60eaff67bddb9bd1a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.errorkind#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="translated">与&lt;a href=&quot;enum.errorkind#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt;不同，这通常意味着操作参数有效，但是错误是由格式错误的输入数据引起的。</target>
        </trans-unit>
        <trans-unit id="977087ec8c6cc227ec1b23f036b52a53ba5572b7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;, this method is known to never panic on the result types it is implemented for. Therefore, it can be used instead of &lt;code&gt;unwrap&lt;/code&gt; as a maintainability safeguard that will fail to compile if the error type of the &lt;code&gt;Result&lt;/code&gt; is later changed to an error that can actually occur.</source>
          <target state="translated">与&lt;a href=&quot;enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt;不同，已知此方法永远不会对实现该方法的结果类型感到恐慌。因此，它可以代替 &lt;code&gt;unwrap&lt;/code&gt; 使用，作为可维护性的保障措施，如果 &lt;code&gt;Result&lt;/code&gt; 的错误类型后来更改为实际可能发生的错误，则它将无法编译。</target>
        </trans-unit>
        <trans-unit id="4f0ba302caf06a67df91ba9d9ffb499576009fcd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once()&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="translated">与&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once()&lt;/code&gt; &lt;/a&gt;不同，此函数将根据请求延迟生成值。</target>
        </trans-unit>
        <trans-unit id="d18aaa1337521f474ebf73b2e843073b1e6c1a48" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="translated">与&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once&lt;/code&gt; &lt;/a&gt;不同，此函数将根据要求延迟生成值。</target>
        </trans-unit>
        <trans-unit id="f9a90d0a5de7f0a5dcb5f54e9d3e2cfa25b0db2a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; works with unaligned pointers.</source>
          <target state="translated">与&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;read_unaligned&lt;/code&gt; 使用未对齐的指针。</target>
        </trans-unit>
        <trans-unit id="45376ed6cd7ba7a1378a0b53a56bfa0037e236a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="translated">与&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;不同，指针可能未对齐。</target>
        </trans-unit>
        <trans-unit id="f193c98cf25a325eda25618a82a356c0b0cf6349" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="translated">与&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;不同，指针可能未对齐。</target>
        </trans-unit>
        <trans-unit id="6eb0fda1ae28c8f30f8d9d31bf06172d448763b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://doc.rust-lang.org/core/convert/fn.identity.html&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="translated">与&lt;a href=&quot;https://doc.rust-lang.org/core/convert/fn.identity.html&quot;&gt; &lt;code&gt;std::convert::identity&lt;/code&gt; &lt;/a&gt;，鼓励Rust编译器假设 &lt;code&gt;black_box&lt;/code&gt; 可以使用允许Rust代码的任何可能有效方式使用 &lt;code&gt;dummy&lt;/code&gt; ，而不会在调用代码中引入未定义的行为。此属性使 &lt;code&gt;black_box&lt;/code&gt; 对于编写不需要进行某些优化（例如基准测试）的代码很有用。</target>
        </trans-unit>
        <trans-unit id="91d4ccc7c19b4e12670ef1bb1f42a0a03d42f849" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert!&lt;/code&gt; is always type checked.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将不执行 &lt;code&gt;debug_assert!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert!&lt;/code&gt; 对于检查成本太高而无法在发行版本中提供的检查很有用，但在开发过程中可能会有所帮助。扩展 &lt;code&gt;debug_assert!&lt;/code&gt; 的结果！始终进行类型检查。</target>
        </trans-unit>
        <trans-unit id="c003bf6ddb754586528cac314e476dba52106915" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将省略所有 &lt;code&gt;debug_assert!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert!&lt;/code&gt; 对于检查成本太高而无法在发行版本中进行显示的检查很有用，但在开发过程中可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="c7b2f5bacfdb6fe8fd35fce9254ebaf2411b3683" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_eq!&lt;/code&gt; is always type checked.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert_eq&quot;&gt; &lt;code&gt;assert_eq!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert_eq!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将不执行 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 对于检查成本太高而无法在发行版本中提供的检查很有用，但在开发过程中可能会有所帮助。扩展 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 的结果！始终进行类型检查。</target>
        </trans-unit>
        <trans-unit id="3263afd688aea4401eb3df7127fbabe1b1fe028e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert_eq&quot;&gt; &lt;code&gt;assert_eq!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert_eq!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将省略所有 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 对于检查成本太高而无法在发行版本中提供的检查很有用，但在开发过程中可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="dacd029d3cc2c2a10a75c84ef45c21166b5ba90a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_ne!&lt;/code&gt; is always type checked.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert_ne&quot;&gt; &lt;code&gt;assert_ne!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert_ne!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将不执行 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 对于检查成本太高而无法在发行版本中提供的检查很有用，但在开发过程中可能会有所帮助。扩展 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 的结果！始终进行类型检查。</target>
        </trans-unit>
        <trans-unit id="04d1e96304d1bbf7140b253d02ca2ad39e16daa5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert_ne&quot;&gt; &lt;code&gt;assert_ne!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert_ne!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将省略所有 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 对于检查成本太高而无法在发行版本中提供的检查很有用，但在开发过程中可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="6cce36d9c22bd93c2a41b7e0597974f3cee7e7ac" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，该函数也可能会虚假地失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="5c9ddf39955f900e36cc1e90f2b549ad7472a5bd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomici16#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI16::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="d36949a10789f440243db02c27d7a2a4839d4968" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomici32#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI32::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="541167404f49247535e6737ca512feb21f2cf377" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomici64#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI64::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="bac30468509752a4dadb45b544078909afc04dd2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomici8#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI8::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="f1e77b06d8fc7bb242ede2586728e20cd5ec38f2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicisize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicIsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomicisize#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicIsize::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="9c1cb338dee4d9a50fbbd7a4ca8f1d9671b92ea5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicptr#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicPtr::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomicptr#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicPtr::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="fcca6a9c5592b18a67aa751975baab86b8d73470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomicu16#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU16::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，该函数也可能会虚假地失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="8564dc4303f86be3afe445dd42ac378dde93ba88" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomicu32#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU32::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，该函数也可能会虚假地失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="b2f28ad76976058589a61b38b753ee6ff0210850" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomicu64#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU64::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="76887ce7cd48ec3a42bf06e1a6d5d6113a38547a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomicu8#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU8::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，该函数也可能会虚假地失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="beb26d7e8cfff635de8d1457d1dfb96fc541fdd8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicusize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicUsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">与&lt;a href=&quot;struct.atomicusize#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicUsize::compare_exchange&lt;/code&gt; &lt;/a&gt;不同，即使比较成功，此函数也可能会虚假地失败，这可能导致某些平台上的代码效率更高。返回值是指示是否写入了新值并包含先前值的结果。</target>
        </trans-unit>
        <trans-unit id="8e0f6d29be16ce7f6bbb39d8f34d156c5bad7880" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt;, if this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; has been poisoned (i.e., a previous call to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; caused a panic), calling &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will no longer be in a poison state and all future calls to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will be no-ops.</source>
          <target state="translated">与&lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt;不同，如果&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;被中毒（即，先前对&lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; 的&lt;/a&gt;调用引起了恐慌），则调用&lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; &lt;/a&gt;仍将调用闭包 &lt;code&gt;f&lt;/code&gt; ,并且&lt;em&gt;不会&lt;/em&gt;立即导致恐慌。如果 &lt;code&gt;f&lt;/code&gt; 恐慌中，&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;将保持在一个毒状态。如果 &lt;code&gt;f&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;将不再是一剂毒药状态和未来所有的调用&lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; &lt;/a&gt;将是空操作。</target>
        </trans-unit>
        <trans-unit id="97444204f29f9f8d725d9dd412f9b1cb5f20d4e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once&lt;/code&gt;&lt;/a&gt;, if this &lt;code&gt;Once&lt;/code&gt; has been poisoned (i.e., a previous call to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_once_force&lt;/code&gt; caused a panic), calling &lt;code&gt;call_once_force&lt;/code&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;code&gt;Once&lt;/code&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;code&gt;Once&lt;/code&gt; will no longer be in a poison state and all future calls to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_one_force&lt;/code&gt; will be no-ops.</source>
          <target state="translated">与&lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once&lt;/code&gt; &lt;/a&gt;不同，如果 &lt;code&gt;Once&lt;/code&gt; 中毒（即，先前对 &lt;code&gt;call_once&lt;/code&gt; 或 &lt;code&gt;call_once_force&lt;/code&gt; 的调用引起了恐慌），则调用 &lt;code&gt;call_once_force&lt;/code&gt; 仍将调用闭包 &lt;code&gt;f&lt;/code&gt; 并且&lt;em&gt;不会&lt;/em&gt;立即引起恐慌。如果 &lt;code&gt;f&lt;/code&gt; 恐慌中， &lt;code&gt;Once&lt;/code&gt; 将保持在一个毒状态。如果 &lt;code&gt;f&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌， &lt;code&gt;Once&lt;/code&gt; 将不再是一剂毒药状态和所有将来呼叫 &lt;code&gt;call_once&lt;/code&gt; 的或 &lt;code&gt;call_one_force&lt;/code&gt; 将是空操作。</target>
        </trans-unit>
        <trans-unit id="69bf1113333b0a6b470f760044140ccfaef050a0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="translated">与&lt;a href=&quot;struct.string#method.from_utf8_lossy&quot;&gt; &lt;code&gt;from_utf8_lossy&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;from_utf16_lossy&lt;/code&gt; 返回 &lt;code&gt;String&lt;/code&gt; ,因为从UTF-16到UTF-8的转换需要分配内存。</target>
        </trans-unit>
        <trans-unit id="9701139045e2ad48d71d09c86c7eff61381e89c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="translated">与&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;不同，如果缓冲区为空，它将不会尝试填充缓冲区。</target>
        </trans-unit>
        <trans-unit id="cb694c3e76472c257054ea4932b6e425a8976f9f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt;, zero-sized allocations are allowed in &lt;code&gt;AllocRef&lt;/code&gt;. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as &lt;code&gt;libc::malloc&lt;/code&gt;), this must be caught by the implementation.</source>
          <target state="translated">与&lt;a href=&quot;trait.globalalloc&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;AllocRef&lt;/code&gt; 允许零大小的分配。如果基础分配器不支持此功能（例如jemalloc）或返回空指针（例如 &lt;code&gt;libc::malloc&lt;/code&gt; ），则必须由实现捕获。</target>
        </trans-unit>
        <trans-unit id="88f01dda433daf6efa3bd2602e5fc9ccc01477f8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt;, zero-sized allocations are allowed in &lt;code&gt;Allocator&lt;/code&gt;. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as &lt;code&gt;libc::malloc&lt;/code&gt;), this must be caught by the implementation.</source>
          <target state="translated">与&lt;a href=&quot;trait.globalalloc&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;Allocator&lt;/code&gt; 中允许零大小的分配。如果基础分配器不支持此功能（例如jemalloc）或返回空指针（例如 &lt;code&gt;libc::malloc&lt;/code&gt; ），则必须由实现捕获。</target>
        </trans-unit>
        <trans-unit id="e53e5897fa59de78d867c186db4554c739885b98" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_match&quot;&gt;&lt;code&gt;next_match&lt;/code&gt;&lt;/a&gt; will overlap.</source>
          <target state="translated">与&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;不同，不能保证this和&lt;a href=&quot;trait.searcher#method.next_match&quot;&gt; &lt;code&gt;next_match&lt;/code&gt; &lt;/a&gt;的返回范围会重叠。</target>
        </trans-unit>
        <trans-unit id="7d5b411ac352c96a1edc968b7e49d8e28ffb6bde" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_reject&quot;&gt;&lt;code&gt;next_reject&lt;/code&gt;&lt;/a&gt; will overlap. This will return &lt;code&gt;(start_match, end_match)&lt;/code&gt;, where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="translated">与&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;不同，不能保证this和&lt;a href=&quot;trait.searcher#method.next_reject&quot;&gt; &lt;code&gt;next_reject&lt;/code&gt; &lt;/a&gt;的返回范围会重叠。这将返回 &lt;code&gt;(start_match, end_match)&lt;/code&gt; ，其中start_match是比赛开始的索引，end_match是比赛结束后的索引。</target>
        </trans-unit>
        <trans-unit id="b07cc87b6de700e95562f870286c85dae89d1a54" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;, this takes a &lt;em&gt;mutable&lt;/em&gt; reference to a slice of &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s, not an immutable one. That's because we need to modify the slice to keep track of the bytes already written.</source>
          <target state="translated">与&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt;不同，这需要&lt;em&gt;可变&lt;/em&gt;引用&lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt;的一部分，而不是不变的。这是因为我们需要修改切片以跟踪已写入的字节。</target>
        </trans-unit>
        <trans-unit id="eee6890d64168a6d63a327f53d097426ab508e0a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; is covariant over &lt;code&gt;T&lt;/code&gt;. If this is incorrect for your use case, you should include some &lt;a href=&quot;../marker/struct.phantomdata&quot;&gt;&lt;code&gt;PhantomData&lt;/code&gt;&lt;/a&gt; in your type to provide invariance, such as &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt;. Usually this won't be necessary; covariance is correct for most safe abstractions, such as &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt;, &lt;code&gt;Vec&lt;/code&gt;, and &lt;code&gt;LinkedList&lt;/code&gt;. This is the case because they provide a public API that follows the normal shared XOR mutable rules of Rust.</source>
          <target state="translated">与 &lt;code&gt;*mut T&lt;/code&gt; 不同， &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;code&gt;T&lt;/code&gt; 上是协变的。如果这对于您的用例是不正确的，则应在您的类型中包括一些&lt;a href=&quot;../marker/struct.phantomdata&quot;&gt; &lt;code&gt;PhantomData&lt;/code&gt; &lt;/a&gt;以提供不变性，例如 &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt; 。通常这是没有必要的。协方差对于大多数安全抽象都是正确的，例如 &lt;code&gt;Box&lt;/code&gt; ， &lt;code&gt;Rc&lt;/code&gt; ， &lt;code&gt;Arc&lt;/code&gt; ， &lt;code&gt;Vec&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 。之所以如此，是因为它们提供了遵循Rust的常规共享XOR可变规则的公共API。</target>
        </trans-unit>
        <trans-unit id="da5b9cd95305c47f8c2680144fa717b64a77ae08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; has the same size as &lt;code&gt;*mut T&lt;/code&gt;. However the pointer may still dangle if it isn't dereferenced.</source>
          <target state="translated">与 &lt;code&gt;*mut T&lt;/code&gt; 不同，即使从未取消引用指针，指针也必须始终为非null。这样一来，枚举就可以将此禁止值用作判别式 &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 具有与 &lt;code&gt;*mut T&lt;/code&gt; 相同的大小。但是，如果指针未取消引用，它可能仍会悬垂。</target>
        </trans-unit>
        <trans-unit id="2af92ae1d7844362d4deb8a5a097d647449edca7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;a href=&quot;../borrow/trait.borrow&quot;&gt;&lt;code&gt;Borrow&lt;/code&gt;&lt;/a&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="translated">与 &lt;code&gt;AsRef&lt;/code&gt; 不同，&lt;a href=&quot;../borrow/trait.borrow&quot;&gt; &lt;code&gt;Borrow&lt;/code&gt; &lt;/a&gt;对任何 &lt;code&gt;T&lt;/code&gt; 都有一个隐含的暗示，可以用来接受引用或值。</target>
        </trans-unit>
        <trans-unit id="23b18281654acc984643104c10e5e6c721877239" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;code&gt;Borrow&lt;/code&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="translated">与 &lt;code&gt;AsRef&lt;/code&gt; 不同， &lt;code&gt;Borrow&lt;/code&gt; 对任何 &lt;code&gt;T&lt;/code&gt; 都有一个毯子式暗示，可以用来接受引用或值。</target>
        </trans-unit>
        <trans-unit id="5ceb8d46ab7abd8b54416adda315f1d04158fc52" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized structs are not rounded up to one byte in size.</source>
          <target state="translated">与 &lt;code&gt;C&lt;/code&gt; 不同，零大小的结构不会四舍五入为一个字节。</target>
        </trans-unit>
        <trans-unit id="02f8b77aa6c48466699ca8ee968807c87cf6172e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized unions are not rounded up to one byte in size.</source>
          <target state="translated">与 &lt;code&gt;C&lt;/code&gt; 不同，零大小的并集不舍入到一个字节的大小。</target>
        </trans-unit>
        <trans-unit id="af8a23b1549826352efacb218921580838863fd0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, this method is safe because the pointer &lt;code&gt;P&lt;/code&gt; dereferences to an &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; type, which cancels the pinning guarantees.</source>
          <target state="translated">与 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 不同，此方法很安全，因为指针 &lt;code&gt;P&lt;/code&gt; 取消引用了&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;类型，这取消了锁定保证。</target>
        </trans-unit>
        <trans-unit id="f597f0fe6680930140f1186767bedc7add8ce577" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type represents single ownership over the data it holds. So, what makes &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; different from a type like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;? Recall the borrowing rules you learned in Chapter 4:</source>
          <target state="translated">与 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 不同， &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型表示对其拥有的数据的单一所有权。那么，是什么使 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 与 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 类的类型不同呢？回忆一下您在第4章中学到的借用规则：</target>
        </trans-unit>
        <trans-unit id="926eeb30ef8b029d9a554336169dcbfbccf0209b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell::borrow&lt;/code&gt;, this method is unsafe because it does not return a &lt;code&gt;Ref&lt;/code&gt;, thus leaving the borrow flag untouched. Mutably borrowing the &lt;code&gt;RefCell&lt;/code&gt; while the reference returned by this method is alive is undefined behaviour.</source>
          <target state="translated">与 &lt;code&gt;RefCell::borrow&lt;/code&gt; 不同，此方法是不安全的，因为它不返回 &lt;code&gt;Ref&lt;/code&gt; ，从而使借位标志保持不变。在此方法返回的引用处于活动 &lt;code&gt;RefCell&lt;/code&gt; 时，以可变方式借用RefCell是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="42c8dcf936cacded32e38266231efc7d97352aa2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; only provides shared &lt;code&gt;&amp;amp;T&lt;/code&gt; references to its value. Unlike &lt;code&gt;Cell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; doesn't require copying or replacing the value to access it.</source>
          <target state="translated">与 &lt;code&gt;RefCell&lt;/code&gt; 不同， &lt;code&gt;OnceCell&lt;/code&gt; 仅提供对其值的共享 &lt;code&gt;&amp;amp;T&lt;/code&gt; 引用。与 &lt;code&gt;Cell&lt;/code&gt; 不同的是， &lt;code&gt;OnceCell&lt;/code&gt; 不需要复制或替换值即可访问它。</target>
        </trans-unit>
        <trans-unit id="d57c88d683b5f207c6b40e5f43b3334b288246db" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;connect_timeout&lt;/code&gt; takes a single &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; since timeout must be applied to individual addresses.</source>
          <target state="translated">与 &lt;code&gt;connect&lt;/code&gt; 不同， &lt;code&gt;connect_timeout&lt;/code&gt; 需要一个&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; ,&lt;/a&gt;因为必须将超时应用于单个地址。</target>
        </trans-unit>
        <trans-unit id="1ac28d4f87c8eadd078ff1fbd83c69852aa4b470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;fill_buf&lt;/code&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="translated">与 &lt;code&gt;fill_buf&lt;/code&gt; 不同，如果缓冲区为空，它将不会尝试填充缓冲区。</target>
        </trans-unit>
        <trans-unit id="c33686d3ffa81ffa69b98b7573a09c025985a84a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">与 &lt;code&gt;read&lt;/code&gt; 不同，指针可能未对齐。</target>
        </trans-unit>
        <trans-unit id="5074eaba30dfa9d17ab40b89f4a8cde3f2ff28d5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;write&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">与 &lt;code&gt;write&lt;/code&gt; 不同，指针可能未对齐。</target>
        </trans-unit>
        <trans-unit id="0869ce408d434adce2ac58f521663bfd0e76626c" translate="yes" xml:space="preserve">
          <source>Unlike an &lt;a href=&quot;../glossary#associated-item&quot;&gt;associated&lt;/a&gt; constant, a &lt;a href=&quot;../glossary#free-item&quot;&gt;free&lt;/a&gt; constant may be unnamed by using an underscore instead of the name. For example:</source>
          <target state="translated">与&lt;a href=&quot;../glossary#associated-item&quot;&gt;关联的&lt;/a&gt;常量不同，可以使用下划线代替名称来命名&lt;a href=&quot;../glossary#free-item&quot;&gt;自由&lt;/a&gt;常量。例如：</target>
        </trans-unit>
        <trans-unit id="c1df7fba2918a10b0657219d3fc33575209df6ce" translate="yes" xml:space="preserve">
          <source>Unlike arithmetic and logical operators, the traits for overloading the operators the traits for these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety). Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression context&lt;/a&gt;:</source>
          <target state="translated">与算术和逻辑运算符不同，用于重载运算符的特征更普遍地用于显示这些运算符的特征，以显示如何比较类型，并且可能会假定使用这些特征作为边界的函数来定义实际比较。然后，标准库中的许多函数和宏都可以使用该假设（尽管不是为了确保安全性）。与上面的算术和逻辑运算符不同，这些运算符隐式地使用它们的操作数的共享借位，并在&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;位置表达式上下文中&lt;/a&gt;对其进行求值：</target>
        </trans-unit>
        <trans-unit id="121561ea59642cbf851a475739b422a107512b01" translate="yes" xml:space="preserve">
          <source>Unlike closures, &lt;code&gt;fn&lt;/code&gt; is a type rather than a trait, so we specify &lt;code&gt;fn&lt;/code&gt; as the parameter type directly rather than declaring a generic type parameter with one of the &lt;code&gt;Fn&lt;/code&gt; traits as a trait bound.</source>
          <target state="translated">与闭包不同， &lt;code&gt;fn&lt;/code&gt; 是类型而不是特征，因此我们直接将 &lt;code&gt;fn&lt;/code&gt; 指定为参数类型，而不是声明以 &lt;code&gt;Fn&lt;/code&gt; 特征之一作为特征绑定的泛型类型参数。</target>
        </trans-unit>
        <trans-unit id="ddb54f325fe389efa56003444a2d405f87525e97" translate="yes" xml:space="preserve">
          <source>Unlike for structs, local variables are dropped in reverse order:</source>
          <target state="translated">与结构不同的是,局部变量是按相反的顺序丢弃的。</target>
        </trans-unit>
        <trans-unit id="64287ed646615b0f4f1dbe6a0afd166352be3fa4" translate="yes" xml:space="preserve">
          <source>Unlike generic parameters or &lt;code&gt;impl Trait&lt;/code&gt;, the compiler does not know the concrete type that is being passed. That is, the type has been &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_erasure&quot;&gt;erased&lt;/a&gt;. As such, a &lt;code&gt;dyn Trait&lt;/code&gt; reference contains &lt;em&gt;two&lt;/em&gt; pointers. One pointer goes to the data (e.g., an instance of a struct). Another pointer goes to a map of method call names to function pointers (known as a virtual method table or vtable).</source>
          <target state="translated">与通用参数或 &lt;code&gt;impl Trait&lt;/code&gt; 不同，编译器不知道要传递的具体类型。也就是说，该类型已被&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_erasure&quot;&gt;擦除&lt;/a&gt;。这样， &lt;code&gt;dyn Trait&lt;/code&gt; 引用包含&lt;em&gt;两个&lt;/em&gt;指针。一个指针指向该数据（例如，一个结构的实例）。另一个指针指向方法调用名称到函数指针的映射（称为虚拟方法表或vtable）。</target>
        </trans-unit>
        <trans-unit id="7ac0121efe5c81f6ee999aad45c525acd80438be" translate="yes" xml:space="preserve">
          <source>Unlike in the TCP case, passing an array of addresses to the &lt;code&gt;connect&lt;/code&gt; function of a UDP socket is not a useful thing to do: The OS will be unable to determine whether something is listening on the remote address without the application sending data.</source>
          <target state="translated">与TCP情况不同，将地址数组传递给UDP套接字的 &lt;code&gt;connect&lt;/code&gt; 功能不是一件有用的事情：在没有应用程序发送数据的情况下，操作系统将无法确定是否有人在监听远程地址。</target>
        </trans-unit>
        <trans-unit id="a7c8893077e685528bec1188265b9f18660f72cd" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_match will overlap.</source>
          <target state="translated">与next()不同,不能保证this和next_match的返回范围会重叠。</target>
        </trans-unit>
        <trans-unit id="d71db212c677479519bbb6e79cc1b75787a4617d" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_reject will overlap. This will return (start_match, end_match), where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="translated">与 next()不同,不能保证 this 和 next_reject 的返回范围会重叠。这将返回(start_match,end_match),其中start_match是匹配开始的索引,end_match是匹配结束后的索引。</target>
        </trans-unit>
        <trans-unit id="6692903ae621839ab645be72d216172c7413d4a0" translate="yes" xml:space="preserve">
          <source>Unlike normal functions, extern fns have type &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt;. This is the same type as the functions declared in an extern block.</source>
          <target state="translated">与普通函数不同，extern fns具有类型 &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt; 。这与extern块中声明的函数的类型相同。</target>
        </trans-unit>
        <trans-unit id="36f4ada6278b2f8caced444ea3301e8d71339c65" translate="yes" xml:space="preserve">
          <source>Unlike other methods on &lt;code&gt;TcpStream&lt;/code&gt;, this does not correspond to a single system call. It instead calls &lt;code&gt;connect&lt;/code&gt; in nonblocking mode and then uses an OS-specific mechanism to await the completion of the connection request.</source>
          <target state="translated">与 &lt;code&gt;TcpStream&lt;/code&gt; 上的其他方法不同，这并不对应于单个系统调用。相反，它以非阻塞模式调用 &lt;code&gt;connect&lt;/code&gt; ，然后使用特定于OS的机制来等待连接请求的完成。</target>
        </trans-unit>
        <trans-unit id="d70fcfde3feb0ab38dc2fc9e1a50deff87be8c12" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; free function, this method yields an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to capture any failure to create the thread at the OS level.</source>
          <target state="translated">不同于免费&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;功能，此方法产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;来捕获在操作系统级别创建线程的任何失败。</target>
        </trans-unit>
        <trans-unit id="f0b436366c65f5f44a2751625381a1b624985a04" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;offset&lt;/code&gt; intrinsic, this intrinsic does not restrict the resulting pointer to point into or one byte past the end of an allocated object, and it wraps with two's complement arithmetic. The resulting value is not necessarily valid to be used to actually access memory.</source>
          <target state="translated">与 &lt;code&gt;offset&lt;/code&gt; 内在函数不同，此内在函数不会限制结果指针指向已分配对象的末尾或末尾一个字节，并且使用二进制补码算法进行换行。结果值不一定有效地用于实际访问内存。</target>
        </trans-unit>
        <trans-unit id="6faf47afea7f3d6a44a9251fcf64aa5fc01a6de0" translate="yes" xml:space="preserve">
          <source>Unlike the other kinds of loops in Rust (&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;while let&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;), loops can be used as expressions that return values via &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">与Rust中其他类型的循环（ &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;while let&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; ）不同，循环可以用作通过 &lt;code&gt;break&lt;/code&gt; 返回值的表达式。</target>
        </trans-unit>
        <trans-unit id="3c816b7f283c34ee4cf6d4ad3a434746ee09b413" translate="yes" xml:space="preserve">
          <source>Unnamed constant</source>
          <target state="translated">未命名常数</target>
        </trans-unit>
        <trans-unit id="2eba6a03b89a9ddb19e9cb15699a8737f8bab076" translate="yes" xml:space="preserve">
          <source>Unpin</source>
          <target state="translated">Unpin</target>
        </trans-unit>
        <trans-unit id="5ea7d63651b5ab2fca876bb44555b1ae728096be" translate="yes" xml:space="preserve">
          <source>Unqualified path patterns can refer to:</source>
          <target state="translated">非限定路径模式可以指:</target>
        </trans-unit>
        <trans-unit id="76194078e8e620ab2e92b2710e1b86b55aa19577" translate="yes" xml:space="preserve">
          <source>Unrecoverable Errors with &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</source>
          <target state="translated">不可挽回的错误与 &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70558ee42c96fb4886d205abf6563d627dc6cb30" translate="yes" xml:space="preserve">
          <source>Unregisters the current allocation error hook, returning it.</source>
          <target state="translated">解除对当前分配错误钩子的注册,返回它。</target>
        </trans-unit>
        <trans-unit id="0b233b52323b31980ad438994ac81379bf159f10" translate="yes" xml:space="preserve">
          <source>Unregisters the current panic hook, returning it.</source>
          <target state="translated">解除注册当前的恐慌钩,将其返回。</target>
        </trans-unit>
        <trans-unit id="4ad2c25804ae1c9519924b3333558a84852f9759" translate="yes" xml:space="preserve">
          <source>Unsafe Rust</source>
          <target state="translated">不安全的铁锈</target>
        </trans-unit>
        <trans-unit id="2bf8239af3f464752ec2490794f409624c78c660" translate="yes" xml:space="preserve">
          <source>Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it&amp;rsquo;s better for it to reject some valid programs rather than accept some invalid programs. Although the code might be okay, as far as Rust is able to tell, it&amp;rsquo;s not! In these cases, you can use unsafe code to tell the compiler, &amp;ldquo;Trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</source>
          <target state="translated">存在不安全Rust的原因是，从本质上讲，静态分析是保守的。当编译器试图确定代码是否遵守保证时，最好拒绝一些有效程序，而不是接受一些无效程序。尽管代码可能还不错，但就Rust所能证明的来说，不是！在这种情况下，您可以使用不安全的代码告诉编译器：&amp;ldquo;相信我，我知道我在做什么。&amp;rdquo; 缺点是使用它的风险自负：如果错误地使用了不安全的代码，则可能会发生由于内存不安全而引起的问题，例如空指针取消引用。</target>
        </trans-unit>
        <trans-unit id="b6d976facee53ef7685c3c2e196f51896ea84263" translate="yes" xml:space="preserve">
          <source>Unsafe Rust: how to opt out of some of Rust&amp;rsquo;s guarantees and take responsibility for manually upholding those guarantees</source>
          <target state="translated">不安全的Rust：如何选择退出Rust的某些保证并承担手动维护这些保证的责任</target>
        </trans-unit>
        <trans-unit id="fe954ab5c7d2bf81229af474f3df1f82baf2452e" translate="yes" xml:space="preserve">
          <source>Unsafe Superpowers</source>
          <target state="translated">不安全的超能力</target>
        </trans-unit>
        <trans-unit id="213dd70d91f9e41a9bf1846e9c631a99cd907b6a" translate="yes" xml:space="preserve">
          <source>Unsafe abilities</source>
          <target state="translated">不安全能力</target>
        </trans-unit>
        <trans-unit id="baac6e0b0340f8475119715946cbe8c2961f1b1b" translate="yes" xml:space="preserve">
          <source>Unsafe blocks</source>
          <target state="translated">不安全区块</target>
        </trans-unit>
        <trans-unit id="14b175946b1bbc439b9bcf446b898eb6bb255e29" translate="yes" xml:space="preserve">
          <source>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language. For example, Rust provides the language features necessary to implement memory-safe concurrency in the language but the implementation of threads and message passing is in the standard library.</source>
          <target state="translated">不安全区块用于包裹外来库,直接使用硬件或实现语言中不直接存在的功能。例如,Rust提供了在语言中实现内存安全并发所需的语言特性,但线程和消息传递的实现是在标准库中。</target>
        </trans-unit>
        <trans-unit id="22664c4ba89e060c3e51b8ae88cd58e9bfacca10" translate="yes" xml:space="preserve">
          <source>Unsafe code may rely on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="translated">不安全的代码可能依赖于 &lt;code&gt;assert!&lt;/code&gt; 强制执行运行时不变式，如果违反该规定可能会导致不安全。</target>
        </trans-unit>
        <trans-unit id="c67e2a049687812f1b206c18f80d4f4b930977c1" translate="yes" xml:space="preserve">
          <source>Unsafe code relies on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="translated">不安全的代码依赖于 &lt;code&gt;assert!&lt;/code&gt; 强制执行运行时不变式，如果违反该规定可能会导致不安全。</target>
        </trans-unit>
        <trans-unit id="4155a1ec65a094fcbe134a0c2768d51a34c574a8" translate="yes" xml:space="preserve">
          <source>Unsafe code should not rely on the correctness of behavior after overflow.</source>
          <target state="translated">不安全的代码不应依赖溢出后行为的正确性。</target>
        </trans-unit>
        <trans-unit id="c53274f3a611843db2cae74ec90f381fafeb9213" translate="yes" xml:space="preserve">
          <source>Unsafe code was used outside of an unsafe function or block.</source>
          <target state="translated">在不安全函数或代码块之外使用了不安全代码。</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">不安全功能</target>
        </trans-unit>
        <trans-unit id="10b765166af116817c2643c79030e41920ee70d7" translate="yes" xml:space="preserve">
          <source>Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. Such a function must be prefixed with the keyword &lt;code&gt;unsafe&lt;/code&gt; and can only be called from an &lt;code&gt;unsafe&lt;/code&gt; block or another &lt;code&gt;unsafe&lt;/code&gt; function.</source>
          <target state="translated">不安全功能是指在所有情况下和/或所有可能的输入中都不安全的功能。这样的函数必须以关键字 &lt;code&gt;unsafe&lt;/code&gt; 开头，并且只能从不 &lt;code&gt;unsafe&lt;/code&gt; 块或另一个 &lt;code&gt;unsafe&lt;/code&gt; 函数中调用。</target>
        </trans-unit>
        <trans-unit id="d33167b0116d560739d43b19ab027e220d852053" translate="yes" xml:space="preserve">
          <source>Unsafe is used on an async function in precisely the same way that it is used on other functions: it indicates that the function imposes some additional obligations on its caller to ensure soundness. As in any other unsafe function, these conditions may extend beyond the initial call itself -- in the snippet above, for example, the &lt;code&gt;unsafe_example&lt;/code&gt; function took a pointer &lt;code&gt;x&lt;/code&gt; as argument, and then (when awaited) dereferenced that pointer. This implies that &lt;code&gt;x&lt;/code&gt; would have to be valid until the future is finished executing, and it is the callers responsibility to ensure that.</source>
          <target state="translated">不安全性在异步功能上的使用方式与在其他功能上完全相同：表示该功能对其调用者施加了一些附加义务，以确保其健全性。与其他任何不安全的函数一样，这些条件可能会超出初始调用本身的范围，例如，在上面的代码段中， &lt;code&gt;unsafe_example&lt;/code&gt; 函数将指针 &lt;code&gt;x&lt;/code&gt; 作为参数，然后（在等待时）取消了对该指针的引用。这意味着 &lt;code&gt;x&lt;/code&gt; 必须是有效的，直到将来完成执行为止，并且调用者有责任确保这一点。</target>
        </trans-unit>
        <trans-unit id="44d7f0c36d2323b4760c5854a9da5e93bff496e9" translate="yes" xml:space="preserve">
          <source>Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust's static semantics.</source>
          <target state="translated">不安全的操作是指那些有可能违反Rust静态语义的内存安全保证的操作。</target>
        </trans-unit>
        <trans-unit id="bf164d180d2c3d60fa72dcb8309415b858fb3ef4" translate="yes" xml:space="preserve">
          <source>Unsafe traits</source>
          <target state="translated">不安全的特征</target>
        </trans-unit>
        <trans-unit id="3f92b08e3c34ebb357bc1ad626c86bb44dccf639" translate="yes" xml:space="preserve">
          <source>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</source>
          <target state="translated">不安全的特质必须有不安全的实现。当一个不安全性状的实现没有标记为不安全时,就会出现这个错误。这可以通过将不安全实现标记为不安全来解决。</target>
        </trans-unit>
        <trans-unit id="5115d7bdd1417d736db11b27ea37e8ee82718f27" translate="yes" xml:space="preserve">
          <source>UnsafeCell</source>
          <target state="translated">UnsafeCell</target>
        </trans-unit>
        <trans-unit id="2c35a285bb852cf3e62f32e3633426c0ef4631a3" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow</source>
          <target state="translated">UnsafeCell::borrow</target>
        </trans-unit>
        <trans-unit id="75bc0d417d751ed027f53b28049e848ca0749b51" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow_mut</source>
          <target state="translated">UnsafeCell::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a881f13247abe21c6a44c037b8dd96d764dbe3f6" translate="yes" xml:space="preserve">
          <source>UnsafeCell::default</source>
          <target state="translated">UnsafeCell::default</target>
        </trans-unit>
        <trans-unit id="dff2508a0e8759e4bdb101a66e3d4f193575af5f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::fmt</source>
          <target state="translated">UnsafeCell::fmt</target>
        </trans-unit>
        <trans-unit id="fdaf457db9ff90155c2c22c46f8d7d84bbcf495e" translate="yes" xml:space="preserve">
          <source>UnsafeCell::from</source>
          <target state="translated">UnsafeCell::from</target>
        </trans-unit>
        <trans-unit id="3345a29406bcc11d2b5b8b2bbebd7e4e0bd82ec5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::get</source>
          <target state="translated">UnsafeCell::get</target>
        </trans-unit>
        <trans-unit id="c9466ca2fc8e49b6dbd92183423a4c8fa163622c" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into</source>
          <target state="translated">UnsafeCell::into</target>
        </trans-unit>
        <trans-unit id="f93e09df9c8216c70f11ba4964e183b8a07e1fb7" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into_inner</source>
          <target state="translated">UnsafeCell::into_inner</target>
        </trans-unit>
        <trans-unit id="b09cd160b3ecd626dee4e6ef60b717116e682ae5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::new</source>
          <target state="translated">UnsafeCell::new</target>
        </trans-unit>
        <trans-unit id="4a93c833e143a391e62488b530430f04d10a5b76" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_from</source>
          <target state="translated">UnsafeCell::try_from</target>
        </trans-unit>
        <trans-unit id="cde666e236559ffd66009b3fdec4a7ed6f2c1d9f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_into</source>
          <target state="translated">UnsafeCell::try_into</target>
        </trans-unit>
        <trans-unit id="3b8d314be6e0f9f234457b987c6cbb99be6adc66" translate="yes" xml:space="preserve">
          <source>UnsafeCell::type_id</source>
          <target state="translated">UnsafeCell::type_id</target>
        </trans-unit>
        <trans-unit id="e0539de3e0de023b7e2dd1485ffa3c4a0acc8d49" translate="yes" xml:space="preserve">
          <source>Unsafely creates a C string wrapper from a byte slice.</source>
          <target state="translated">不安全地从一个字节分片创建一个C字符串包装器。</target>
        </trans-unit>
        <trans-unit id="80d75cb6c5a344f6eadb72b7d847c31a12dc80ca" translate="yes" xml:space="preserve">
          <source>Unsafety</source>
          <target state="translated">Unsafety</target>
        </trans-unit>
        <trans-unit id="e91344ea16120944c87d0e0635826ca2b1e1956c" translate="yes" xml:space="preserve">
          <source>Unsigned</source>
          <target state="translated">Unsigned</target>
        </trans-unit>
        <trans-unit id="ec69039d9aace16bc0675cab4f4e5d7118fc67b0" translate="yes" xml:space="preserve">
          <source>Unsize</source>
          <target state="translated">Unsize</target>
        </trans-unit>
        <trans-unit id="8702197dc32e4fc5986508c97d9597351056f2bf" translate="yes" xml:space="preserve">
          <source>Unsized Coercions</source>
          <target state="translated">无规模的胁迫</target>
        </trans-unit>
        <trans-unit id="a090334da83d2c5e2a98abcbd42c6af2bf5571a1" translate="yes" xml:space="preserve">
          <source>Unsized data:</source>
          <target state="translated">不大的数据。</target>
        </trans-unit>
        <trans-unit id="ea2569aaa33eada2280795d75f286bd6771924fe" translate="yes" xml:space="preserve">
          <source>Unstable Features</source>
          <target state="translated">不稳定的特点</target>
        </trans-unit>
        <trans-unit id="92ffa7782162b2b301a0b11d2aefb00ca2f2a2f0" translate="yes" xml:space="preserve">
          <source>Until now, all our examples have been matching structs or enums that were one level deep. Matching can work on nested items too!</source>
          <target state="translated">到目前为止,我们所有的例子都是在匹配一层深的结构或枚举。匹配也可以在嵌套的项目上工作。</target>
        </trans-unit>
        <trans-unit id="9a0d085fdd50abbdcb3c17611b8692b87c3b02d5" translate="yes" xml:space="preserve">
          <source>Until now, we&amp;rsquo;ve not talked about &lt;em&gt;global variables&lt;/em&gt;, which Rust does support but can be problematic with Rust&amp;rsquo;s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</source>
          <target state="translated">到目前为止，我们还没有讨论过Rust所支持的&lt;em&gt;全局变量&lt;/em&gt;，但是对于Rust的所有权规则可能会出现问题。如果两个线程正在访问相同的可变全局变量，则可能导致数据争用。</target>
        </trans-unit>
        <trans-unit id="bef75503876861f1652d24e0b101fc042661d7b5" translate="yes" xml:space="preserve">
          <source>Until these issues are resolved, you can use the &lt;a href=&quot;https://crates.io/crates/async-trait&quot;&gt;&lt;code&gt;async-trait&lt;/code&gt; crate&lt;/a&gt;, allowing you to use &lt;code&gt;async fn&lt;/code&gt; in traits by desugaring to &quot;boxed futures&quot; (&lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future + Send + 'async&amp;gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">在解决这些问题之前，您可以使用&lt;a href=&quot;https://crates.io/crates/async-trait&quot;&gt; &lt;code&gt;async-trait&lt;/code&gt; 板条箱&lt;/a&gt;，允许您通过限制使用&amp;ldquo;装箱的期货&amp;rdquo;（ &lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future + Send + 'async&amp;gt;&amp;gt;&lt;/code&gt; ）在特征中使用 &lt;code&gt;async fn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a466dbcb07d272a4827d08399fcc579473f95bac" translate="yes" xml:space="preserve">
          <source>Unused lifetime parameters</source>
          <target state="translated">未使用的寿命参数</target>
        </trans-unit>
        <trans-unit id="67f29d2fd70384a80fd94676bef420c60ec02613" translate="yes" xml:space="preserve">
          <source>Unused type parameters</source>
          <target state="translated">未使用的类型参数</target>
        </trans-unit>
        <trans-unit id="4309bf93c467874d67ac366ea9fc690edd209fc3" translate="yes" xml:space="preserve">
          <source>UnwindSafe</source>
          <target state="translated">UnwindSafe</target>
        </trans-unit>
        <trans-unit id="cbc02d75adc1ffc39fd3a16b3b4074d157341ccf" translate="yes" xml:space="preserve">
          <source>Unwinding the Stack or Aborting in Response to a Panic</source>
          <target state="translated">解除堆栈或因慌乱而中止操作</target>
        </trans-unit>
        <trans-unit id="2789441f00b1b852b1abc369acfc06188469d312" translate="yes" xml:space="preserve">
          <source>Unwraps a result or propagates its error.</source>
          <target state="translated">解开一个结果或传播其错误。</target>
        </trans-unit>
        <trans-unit id="bf154983f21c606f5ed175df0a60de13c896591a" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解开结果，得到&lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;的内容。</target>
        </trans-unit>
        <trans-unit id="88ae872ed59ebfa48f0864e25ba0455dd8b90e15" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解开结果，产生&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;的内容。</target>
        </trans-unit>
        <trans-unit id="f6bb0d8e70fa6dd56dc1322239dbf82a2df0a4ac" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. Else, it returns &lt;code&gt;optb&lt;/code&gt;.</source>
          <target state="translated">解开结果，产生&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;的内容。否则，它返回 &lt;code&gt;optb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="117016b46649ef00153af6f7350c9138ecc67dda" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. If the value is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; then it calls &lt;code&gt;op&lt;/code&gt; with its value.</source>
          <target state="translated">解开结果，产生&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;的内容。如果该值为&lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt;则使用其值调用 &lt;code&gt;op&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d656a32648587effa39921eb330f108c0675d59" translate="yes" xml:space="preserve">
          <source>Unwraps an option, yielding the content of a &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解开一个选项，产生&lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;的内容。</target>
        </trans-unit>
        <trans-unit id="44e46942e6b3560b76547c4068197f656ff8557f" translate="yes" xml:space="preserve">
          <source>Unwraps the value.</source>
          <target state="translated">解开值。</target>
        </trans-unit>
        <trans-unit id="cbbcbd99f909cf5773cc2f8cf87cdd95f999143d" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;, returning the underlying reader.</source>
          <target state="translated">解开此 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; ，返回基础阅读器。</target>
        </trans-unit>
        <trans-unit id="45c0f60884f81c191ed8a1499ae68b62ce7e7ea6" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&lt;/code&gt;, returning the underlying reader.</source>
          <target state="translated">解开此 &lt;code&gt;BufReader&lt;/code&gt; ，返回基础阅读器。</target>
        </trans-unit>
        <trans-unit id="d79f711284b065af6b4e74f8652871df33141f21" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">解开此 &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; ，返回基础编写器。</target>
        </trans-unit>
        <trans-unit id="69524452be5afea8f11639be9af1a3cd4b2bfb03" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">解开此 &lt;code&gt;BufWriter&lt;/code&gt; ，返回基础编写器。</target>
        </trans-unit>
        <trans-unit id="935d143678423728d032f85b20c66b89ea1e5a53" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;LineWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">解包此 &lt;code&gt;LineWriter&lt;/code&gt; ，返回基础编写器。</target>
        </trans-unit>
        <trans-unit id="2e3b12243482f11a01fe101039b067f041f66124" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; returning the underlying pointer.</source>
          <target state="translated">解开此 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 并返回基础指针。</target>
        </trans-unit>
        <trans-unit id="9b17789b43e82ba91c88e4d986c1f5d5ba8289b4" translate="yes" xml:space="preserve">
          <source>Update the two instances of duplicated code to call the function instead.</source>
          <target state="translated">更新两个重复的代码实例来代替调用函数。</target>
        </trans-unit>
        <trans-unit id="9d8edb0cba2f3c71c929550f878ec6f1ab95a982" translate="yes" xml:space="preserve">
          <source>Update to a newer Rust version</source>
          <target state="translated">更新到更新的Rust版本</target>
        </trans-unit>
        <trans-unit id="a37ad606755c045819fc66433cff2f591c85b628" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="translated">将&lt;a href=&quot;struct.path#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt;更新为 &lt;code&gt;extension&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b39de9c5b81e5a6bb6d85d389439d91c0bfb9619" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">将&lt;a href=&quot;struct.path#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt;更新为 &lt;code&gt;file_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="383cb3a84b0a57cded7c0258c7e1a49880c35c95" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="translated">将&lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt;更新为 &lt;code&gt;extension&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3c4a6fdd4244e071cb1f5b4ee0c1015487b2074" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">将&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt;更新为 &lt;code&gt;file_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="499d5f0f7c8875ae92624d65ec97b14c16b89ea7" translate="yes" xml:space="preserve">
          <source>Updates the contained value using a function and returns the new value.</source>
          <target state="translated">使用函数更新包含的值并返回新的值。</target>
        </trans-unit>
        <trans-unit id="54c400ee034681ba4f94547c1f9e6d6c6ae60547" translate="yes" xml:space="preserve">
          <source>Updating a Crate to Get a New Version</source>
          <target state="translated">更新箱子以获得新版本</target>
        </trans-unit>
        <trans-unit id="230bbf8ccb89f28d643435c51ba717b409f87480" translate="yes" xml:space="preserve">
          <source>Updating a Hash Map</source>
          <target state="translated">更新哈希图</target>
        </trans-unit>
        <trans-unit id="83885ba9f035a9010b4b1ccae0e7e7d6ed9f8e1e" translate="yes" xml:space="preserve">
          <source>Updating a String</source>
          <target state="translated">更新一个字符串</target>
        </trans-unit>
        <trans-unit id="d2ba6d88a1646ea3bcd8516dafee00edcea72844" translate="yes" xml:space="preserve">
          <source>Updating a Value Based on the Old Value</source>
          <target state="translated">更新基于旧值的值</target>
        </trans-unit>
        <trans-unit id="923fa3af760fbaa62e4ad240ccab4df3cf7cd0e1" translate="yes" xml:space="preserve">
          <source>Updating a Vector</source>
          <target state="translated">更新向量</target>
        </trans-unit>
        <trans-unit id="e383c87cdb72887f6744a78bd78fa459e44a666d" translate="yes" xml:space="preserve">
          <source>Updating and Uninstalling</source>
          <target state="translated">更新和卸载</target>
        </trans-unit>
        <trans-unit id="874862d7b95e02718d554f979aec41adae9c4cee" translate="yes" xml:space="preserve">
          <source>Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="translated">在接收到自旋环信号后,处理器可以通过诸如省电或切换超线程来优化其行为。</target>
        </trans-unit>
        <trans-unit id="a0b0bd731b8e15bb23bd7cc76d2aa724aa6bbacd" translate="yes" xml:space="preserve">
          <source>Upon receiving the spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="translated">在接收到自旋环信号后,处理器可以通过例如节省功耗或切换超线程来优化其行为。</target>
        </trans-unit>
        <trans-unit id="22415b6a3d0c513d757498ec107592efc88cd6e4" translate="yes" xml:space="preserve">
          <source>UpperExp</source>
          <target state="translated">UpperExp</target>
        </trans-unit>
        <trans-unit id="fcfc7b5ea59d907143490b4156e6805ce49d5515" translate="yes" xml:space="preserve">
          <source>UpperExp::fmt</source>
          <target state="translated">UpperExp::fmt</target>
        </trans-unit>
        <trans-unit id="f690e8510e34f299255dfcc6523578488db8db3e" translate="yes" xml:space="preserve">
          <source>UpperHex</source>
          <target state="translated">UpperHex</target>
        </trans-unit>
        <trans-unit id="2bafd282159acd4fe944a3d1a0e5e2492ec2091e" translate="yes" xml:space="preserve">
          <source>UpperHex::fmt</source>
          <target state="translated">UpperHex::fmt</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="8139f3704cf1ae8bc1b831776ef1b322f4905331" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">为此行为使用&lt;a href=&quot;#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31c647ca0e64548e5df242f616757ada55c0dfbe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">为此行为使用&lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="687f0dae29440086643b86ae5972f2641cdbdfdb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;park_timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;park_timeout&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebca8bdf54e76e24d82dc68f6b0bc04c50c7f47f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">为此行为使用&lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e960174a6840a72333f0c4af39164868fd34c4f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;struct.vec#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vec#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in the &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">如果要检查索引是否在 &lt;code&gt;Vec&lt;/code&gt; 中，请使用&lt;a href=&quot;struct.vec#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.vec#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88bbc8b66ff470f012eb3c0cc67e657fee2b3c01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Fn&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly and without mutating state (e.g., when calling it concurrently). If you do not need such strict requirements, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as bounds.</source>
          <target state="translated">当您要接受类似函数的类型的参数并且需要重复调​​用且不改变状态（例如，同时调用它）时，请使用 &lt;code&gt;Fn&lt;/code&gt; 作为绑定。如果不需要严格的要求，请使用&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;作为边界。</target>
        </trans-unit>
        <trans-unit id="606e32d3718b3ad9261ab53d0c58fffdae2c3eb7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnMut&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly, while allowing it to mutate state. If you don't want the parameter to mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a bound; if you don't need to call it repeatedly, use &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当您要接受类似函数类型的参数并需要反复调用它，同时允许其改变状态时，请使用 &lt;code&gt;FnMut&lt;/code&gt; 作为绑定。如果您不希望参数改变状态，请使用&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;作为绑定；如果您不需要重复调​​用它，请使用&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0490417243191fd2b7e8ec23e8ffa3dcdc8fa81b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnOnce&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and only need to call it once. If you need to call the parameter repeatedly, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a bound; if you also need it to not mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当您想接受类似函数的类型的参数并且只需要调用一次时，可以使用 &lt;code&gt;FnOnce&lt;/code&gt; 作为绑定。如果需要重复调​​用该参数，请使用&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;作为绑定；如果还需要它不改变状态，请使用&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58e9a37a75f6d151dc00d0d282a3a92ae64a1400" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ThreadPool&lt;/code&gt; to perform some task other than serving web requests.</source>
          <target state="translated">使用 &lt;code&gt;ThreadPool&lt;/code&gt; 来执行某些任务，而不是处理Web请求。</target>
        </trans-unit>
        <trans-unit id="d84e22d164ffb7c941231da29582df4847d529a7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;async&lt;/code&gt; in front of &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;closure&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; to turn the marked code into a &lt;code&gt;Future&lt;/code&gt;. As such the code will not be run immediately, but will only be evaluated when the returned future is &lt;code&gt;.await&lt;/code&gt;ed.</source>
          <target state="translated">在 &lt;code&gt;fn&lt;/code&gt; ， &lt;code&gt;closure&lt;/code&gt; 或 &lt;code&gt;block&lt;/code&gt; 前面使用 &lt;code&gt;async&lt;/code&gt; 将标记的代码转换为 &lt;code&gt;Future&lt;/code&gt; 。因此，该代码不会立即运行，而只会在 &lt;code&gt;.await&lt;/code&gt; 返回的future时进行评估。</target>
        </trans-unit>
        <trans-unit id="78610f1f9c97f303d12e27f1de6220faa88beddc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;compare_exchange&lt;/code&gt; or &lt;code&gt;compare_exchange_weak&lt;/code&gt; instead</source>
          <target state="translated">使用 &lt;code&gt;compare_exchange&lt;/code&gt; 或 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 代替</target>
        </trans-unit>
        <trans-unit id="b14f208baffea7d1c86f95f732b3ef39c695038a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprint!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;print!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">使用 &lt;code&gt;eprint!&lt;/code&gt; 仅用于错误和进度消息。使用 &lt;code&gt;print!&lt;/code&gt; 而是用于程序的主要输出。</target>
        </trans-unit>
        <trans-unit id="22665c8a7bbb569c824fae1113f4c37d6c60b38a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprintln!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;println!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">使用 &lt;code&gt;eprintln!&lt;/code&gt; 仅用于错误和进度消息。使用 &lt;code&gt;println!&lt;/code&gt; 而是用于程序的主要输出。</target>
        </trans-unit>
        <trans-unit id="c5580c57c536b501604c5a18501909570a4f8755" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mod&lt;/code&gt; to create new &lt;a href=&quot;../reference/items/modules&quot;&gt;modules&lt;/a&gt; to encapsulate code, including other modules:</source>
          <target state="translated">使用 &lt;code&gt;mod&lt;/code&gt; 创建新&lt;a href=&quot;../reference/items/modules&quot;&gt;模块&lt;/a&gt;以封装代码，包括其他模块：</target>
        </trans-unit>
        <trans-unit id="2ead4795448020930657e9470aadfc30b6e379b7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;print!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">使用 &lt;code&gt;print!&lt;/code&gt; 仅用于程序的主要输出。使用&lt;a href=&quot;macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt;而是打印错误和进度消息。</target>
        </trans-unit>
        <trans-unit id="8622f52bbce3eafc5d53c96e1ec31dc91867c0d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;println!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">使用 &lt;code&gt;println!&lt;/code&gt; 仅用于程序的主要输出。使用&lt;a href=&quot;macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt;而是打印错误和进度消息。</target>
        </trans-unit>
        <trans-unit id="4a325d56085ed8734f6810e0ff71ad595b95fd50" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BTreeMap&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;BTreeMap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c5b8b83e450ccf5b057f6e9cdd558c50e56abe87" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BinaryHeap&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;BinaryHeap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c44210c4cd02de7b469e04353c99013251f0bdb6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;HashMap&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;HashMap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="461b6ce24b45cd8f2525e7819f63e5f3b7e5d4c8" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;LinkedList&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;LinkedList&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f8effe57e9b8b3183f9d4a4c43ec54816a50215a" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:</source>
          <target state="translated">使用 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 作为有效的堆栈：</target>
        </trans-unit>
        <trans-unit id="18acad408e22b76af330889473712392d945f0e6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;Vec&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="610593fe7c0408bbb0f35796499627c6f2245b92" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;VecDeque&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;VecDeque&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="928e71deb9616cde37637c874eca1ef7178b77b4" translate="yes" xml:space="preserve">
          <source>Use a slice.</source>
          <target state="translated">用一片。</target>
        </trans-unit>
        <trans-unit id="37c1eb662164587065262615f820c57ffe90b9ef" translate="yes" xml:space="preserve">
          <source>Use an array with a fixed length.</source>
          <target state="translated">使用一个固定长度的数组。</target>
        </trans-unit>
        <trans-unit id="aa019f3006a2c79cffd1cb8f757987c40c32ebd5" translate="yes" xml:space="preserve">
          <source>Use declarations</source>
          <target state="translated">使用声明</target>
        </trans-unit>
        <trans-unit id="4285ed0690ab255637e0ac148f5c792cd6b8149b" translate="yes" xml:space="preserve">
          <source>Use declarations support a number of convenient shortcuts:</source>
          <target state="translated">使用声明支持一些方便的快捷方式。</target>
        </trans-unit>
        <trans-unit id="1d940a95921bf352b68ae08ab069e2750541ca02" translate="yes" xml:space="preserve">
          <source>Use of a &lt;code&gt;str&lt;/code&gt; whose contents are not valid UTF-8 is undefined behavior.</source>
          <target state="translated">使用内容无效的 &lt;code&gt;str&lt;/code&gt; 的UTF-8是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="d154502a3f5f6795f896efa6e13908d9370d8f9a" translate="yes" xml:space="preserve">
          <source>Use of generic parameters.</source>
          <target state="translated">使用通用参数;</target>
        </trans-unit>
        <trans-unit id="5c5acc62e88ff47e84c111044c30c66db333ca88" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax to write data to the standard output. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">使用&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;将数据写入标准输出的语法。有关更多信息，请参见&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fbe9e80ba417914254163793e464ee62322f093" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ptr/fn.null_mut&quot;&gt;&lt;code&gt;null_mut&lt;/code&gt;&lt;/a&gt; functions to create null pointers, and the &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt;&lt;code&gt;is_null&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types to check for null. The &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types also define the &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; method, for pointer math.</source>
          <target state="translated">使用&lt;a href=&quot;ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ptr/fn.null_mut&quot;&gt; &lt;code&gt;null_mut&lt;/code&gt; &lt;/a&gt;函数创建空指针，并使用 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 类型的&lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt; &lt;code&gt;is_null&lt;/code&gt; &lt;/a&gt;方法检查空值。的 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 类型还定义了&lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;法中，指针数学。</target>
        </trans-unit>
        <trans-unit id="2e570be59fc7fd5ff7530405783a29f5828f0fe8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Set&lt;/code&gt; variant of any of these &lt;code&gt;Map&lt;/code&gt;s when:</source>
          <target state="translated">在以下情况下，请使用任何这些 &lt;code&gt;Map&lt;/code&gt; 的 &lt;code&gt;Set&lt;/code&gt; 变体：</target>
        </trans-unit>
        <trans-unit id="e80c04da83a86a4ecbf94ec7503d652753e12266" translate="yes" xml:space="preserve">
          <source>Use the code in Listing 12-1 to allow your &lt;code&gt;minigrep&lt;/code&gt; program to read any command line arguments passed to it and then collect the values into a vector.</source>
          <target state="translated">使用清单12-1中的代码，您的 &lt;code&gt;minigrep&lt;/code&gt; 程序可以读取传递给它的任何命令行参数，然后将值收集到向量中。</target>
        </trans-unit>
        <trans-unit id="b7e242e19e576b066c1fbe08cfb0b75455ae8cac" translate="yes" xml:space="preserve">
          <source>Use the same lifetime requirement for both input and output values.</source>
          <target state="translated">对输入和输出值使用相同的寿命要求。</target>
        </trans-unit>
        <trans-unit id="45a96fe96ad1c2ec9146b51dd14fea6aa97e8389" translate="yes" xml:space="preserve">
          <source>Use this function only when you can prove that the code will never call it. Otherwise, consider using the &lt;a href=&quot;../macro.unreachable&quot;&gt;&lt;code&gt;unreachable!&lt;/code&gt;&lt;/a&gt; macro, which does not allow optimizations but will panic when executed.</source>
          <target state="translated">仅在可以证明代码永远不会调用它时，才使用此函数。否则，请考虑使用&lt;a href=&quot;../macro.unreachable&quot;&gt; &lt;code&gt;unreachable!&lt;/code&gt; &lt;/a&gt;宏，该宏不允许进行优化，但在执行时会出现恐慌。</target>
        </trans-unit>
        <trans-unit id="d6a3c9f03120ec47a98d4a452b1e2127aae8581a" translate="yes" xml:space="preserve">
          <source>Used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeFull&lt;/code&gt; produces the full array as a slice.</source>
          <target state="translated">用作&lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;切片索引时&lt;/a&gt;， &lt;code&gt;RangeFull&lt;/code&gt; 产生完整的数组作为切片。</target>
        </trans-unit>
        <trans-unit id="0ee0968c281548e8c4956da0bb80d17ce6a46d94" translate="yes" xml:space="preserve">
          <source>Used for immutable dereferencing operations, like &lt;code&gt;*v&lt;/code&gt;.</source>
          <target state="translated">用于不可变的取消引用操作，例如 &lt;code&gt;*v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4b9aeea072b24e3f199cbe699727a85aca473bd" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in immutable contexts.</source>
          <target state="translated">用于不可变上下文中的索引操作（ &lt;code&gt;container[index]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6a6db850fe7a0893deca48224e890877525cf009" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in mutable contexts.</source>
          <target state="translated">用于可变上下文中的索引操作（ &lt;code&gt;container[index]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b8ea53757bb98a6b5189506b4ea7e3a3e9a3ec16" translate="yes" xml:space="preserve">
          <source>Used for mutable dereferencing operations, like in &lt;code&gt;*v = 1;&lt;/code&gt;.</source>
          <target state="translated">用于可变的解除引用操作，例如 &lt;code&gt;*v = 1;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fe043543944b7d7b206d45160cd5299a8af93e5" translate="yes" xml:space="preserve">
          <source>Used to create a default &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; instance for types that implement &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于为实现&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; 的&lt;/a&gt;类型创建默认的&lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="8e28b1efed767d7b3e60d0a7700706d6642dda67" translate="yes" xml:space="preserve">
          <source>Used to do a cheap mutable-to-mutable reference conversion.</source>
          <target state="translated">用来做廉价的可变到可变的参考转换。</target>
        </trans-unit>
        <trans-unit id="f1b7626a3b6465a294975154f6e043096ec5995f" translate="yes" xml:space="preserve">
          <source>Used to do a cheap reference-to-reference conversion.</source>
          <target state="translated">用来做廉价的参考文献到参考文献的转换。</target>
        </trans-unit>
        <trans-unit id="14c0b7ffa101db42d6f394a0ed0a2a772e18316c" translate="yes" xml:space="preserve">
          <source>Used to do value-to-value conversions while consuming the input value. It is the reciprocal of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于在消耗输入值的同时进行值到值的转换。这是&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;的倒数。</target>
        </trans-unit>
        <trans-unit id="87832790df189d88ca8070bb6de895ef1d392b7c" translate="yes" xml:space="preserve">
          <source>Used to make try_fold closures more like normal loops</source>
          <target state="translated">用来使try_fold闭合更像普通循环。</target>
        </trans-unit>
        <trans-unit id="3e26b00e1661d4c5dea648883f63653b80651f39" translate="yes" xml:space="preserve">
          <source>Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.</source>
          <target state="translated">当一个值超出范围时,用来运行一些代码。这有时被称为 &quot;destructor&quot;。</target>
        </trans-unit>
        <trans-unit id="5dc9662fcc8a7efba76268741a2aa91414af229f" translate="yes" xml:space="preserve">
          <source>Useful synchronization primitives.</source>
          <target state="translated">有用的同步基元。</target>
        </trans-unit>
        <trans-unit id="b05cb9060bef7e9cf540890d5647fd3ffbac6f9d" translate="yes" xml:space="preserve">
          <source>User lacks permissions to create directory at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">用户缺乏在 &lt;code&gt;path&lt;/code&gt; 创建目录的权限。</target>
        </trans-unit>
        <trans-unit id="01ed5872aedec24d23d900d1581e6ff53ed21665" translate="yes" xml:space="preserve">
          <source>User-defined types:</source>
          <target state="translated">用户定义的类型。</target>
        </trans-unit>
        <trans-unit id="62be4731dedfbbc70aa7fa30d6649d816af8ca4b" translate="yes" xml:space="preserve">
          <source>Uses</source>
          <target state="translated">Uses</target>
        </trans-unit>
        <trans-unit id="55cf66299b4b2f9f7eb9ea6abdf809a42de50634" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning.</source>
          <target state="translated">使用借来的数据来替换拥有的数据,通常是通过克隆。</target>
        </trans-unit>
        <trans-unit id="01c085ac9a4eda7ad0e1fc8b863d1b23ac3713d3" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1a7e308c9ce8c72dc79594fe592d8ac0e474a60" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41f5a93c96209d01bd88a54a350a97a8859d2caf" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="527bd4367972a752863741d60fd99d8435d00fca" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb87bc230d96c818f8f39be65a97f0f0c56ca879" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e92ce0c09d5d2c377945a784545c389cc7e9354" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt;&lt;/a&gt;, a.k.a. the &lt;code&gt;memcpy32&lt;/code&gt;and &lt;code&gt;memcpy64&lt;/code&gt; intrinsics, on overlapping buffers.</source>
          <target state="translated">在重叠缓冲区上使用&lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt; &lt;/a&gt;，也称为 &lt;code&gt;memcpy32&lt;/code&gt; 和 &lt;code&gt;memcpy64&lt;/code&gt; 内部函数。</target>
        </trans-unit>
        <trans-unit id="6e1dcc3d8137ddd7e3681f9bc104f285826b7f48" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; as success ordering makes the store part of this operation &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;, and using &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; makes the final successful load &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;. The (failed) load ordering can only be &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; and must be equivalent to or weaker than the success ordering.</source>
          <target state="translated">利用&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;的成功订货，使该操作的商店部分&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;，并利用&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;使得最终成功加载&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;。（失败）负载排序只能是&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; ,&lt;/a&gt;并且必须等于或弱于成功排序。</target>
        </trans-unit>
        <trans-unit id="7a6e8bfcb648c037a665b572caa617368582e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;Iterator::collect()&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;Iterator::collect()&lt;/code&gt; &lt;/a&gt;隐式使用 &lt;code&gt;FromIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f6057ce3700db1903febbd4571a9030f98dccb52" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;隐式使用 &lt;code&gt;FromIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8581b668b89dc42d1d55734cab92752391e678b" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; Like a Reference</source>
          <target state="translated">像参考一样使用 &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2786f97dc365e66bda997868734cec33ef9fcf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Get a Recursive Type with a Known Size</source>
          <target state="translated">使用 &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 获取已知大小的递归类型</target>
        </trans-unit>
        <trans-unit id="8300c99c1ff66e26c9f9b017e5522a93d571ce81" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Point to Data on the Heap</source>
          <target state="translated">使用 &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 指向堆上的数据</target>
        </trans-unit>
        <trans-unit id="c4104bedba70839a84674c526e20638655c760d0" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; Functions to Call External Code</source>
          <target state="translated">使用 &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; 函数调用外部代码</target>
        </trans-unit>
        <trans-unit id="39a61fb39b0b2c2b47e27003fb9ca80ee4d7ca24" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; in a &lt;code&gt;let&lt;/code&gt; Statement</source>
          <target state="translated">在 &lt;code&gt;let&lt;/code&gt; 语句中使用 &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17f21cd4682f3498e05d46c9ba5f0db1ecf73ca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; Trait Methods Instead of Indexing</source>
          <target state="translated">使用 &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; 特征方法代替索引</target>
        </trans-unit>
        <trans-unit id="cd4dbe3102cc8a86458c21a6edcf0745a3880b2c" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; Closures with Threads</source>
          <target state="translated">在线程中使用 &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; 闭包</target>
        </trans-unit>
        <trans-unit id="bcb24e74610f11ffcd8b36fc02251143626de877" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to Share Data</source>
          <target state="translated">使用 &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 共享数据</target>
        </trans-unit>
        <trans-unit id="4bedcde0cd8963bedfb716621a284a40e61ba006" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in Tests</source>
          <target state="translated">在测试中使用 &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d4e8a0abd2628d1463a51e66037adf55b78b3eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;#[repr(C)]&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;#[repr(C)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfc71d2f097570894eba309d1d3e23fc1440f195" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ，其中右手参数大于或等于左手参数类型中的位数，或者为负数。</target>
        </trans-unit>
        <trans-unit id="b645209e67cee4f9f92c20f0e033dab698fba2f2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; ，其中左手参数是有符号整数类型的最小整数，右手参数为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d0998ec9f168a2eeef48fd713f566a42f1d1993" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@&lt;/code&gt; lets us test a value and save it in a variable within one pattern.</source>
          <target state="translated">使用 &lt;code&gt;@&lt;/code&gt; 让我们测试一个值并将其保存在一个模式内的变量中。</target>
        </trans-unit>
        <trans-unit id="1ae9824a370d1fed45ea9444f749e0c2d3a71823" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;AsMut&lt;/code&gt; as trait bound for a generic function we can accept all mutable references that can be converted to type &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; we can write a function &lt;code&gt;add_one&lt;/code&gt; that takes all arguments that can be converted to &lt;code&gt;&amp;amp;mut u64&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;add_one&lt;/code&gt; accepts arguments of type &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; as well:</source>
          <target state="translated">使用 &lt;code&gt;AsMut&lt;/code&gt; 作为通用函数的特征绑定，我们可以接受所有可以转换为 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 类型的可变引用。因为&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;实现了 &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; 我们可以编写一个函数 &lt;code&gt;add_one&lt;/code&gt; ，该函数接受可以转换为 &lt;code&gt;&amp;amp;mut u64&lt;/code&gt; 的所有参数。因为&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;add_one&lt;/code&gt; 接受 &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; 类型的参数：</target>
        </trans-unit>
        <trans-unit id="e5f61609aec29d1aa58bf125645b7b8bf1c8648b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BuildHasherDefault&lt;/code&gt; to specify a custom &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 为&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;指定自定义&lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="741ce1478263e946f77de5614872f7257f7d9bd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;TcpListener&lt;/code&gt;, we can listen for TCP connections at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt;. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn&amp;rsquo;t represent the authors&amp;rsquo; computer specifically), and &lt;code&gt;7878&lt;/code&gt; is the port. We&amp;rsquo;ve chosen this port for two reasons: HTTP is normally accepted on this port, and 7878 is &lt;em&gt;rust&lt;/em&gt; typed on a telephone.</source>
          <target state="translated">使用 &lt;code&gt;TcpListener&lt;/code&gt; ，我们可以在地址 &lt;code&gt;127.0.0.1:7878&lt;/code&gt; 侦听TCP连接。在地址中，冒号前的部分是代表您的计算机的IP地址（每台计算机上的IP地址都相同，并且并不特别代表作者的计算机），端口 &lt;code&gt;7878&lt;/code&gt; 是该端口。我们选择此端口的原因有两个：通常在此端口上接受HTTP，而在电话上键入7878则为&lt;em&gt;rust&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9d282af0a0db5a0f3935d90926c6551a24490d56" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cargo&lt;/code&gt;, Rust&amp;rsquo;s package manager and build system</source>
          <target state="translated">使用 &lt;code&gt;cargo&lt;/code&gt; ，Rust的包裹管理器和构建系统</target>
        </trans-unit>
        <trans-unit id="063f2ebb8c76224924321e7e9857525474aed57a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用 &lt;code&gt;collect()&lt;/code&gt; 创建一个&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="781d7dd79f196f5deffe456d6e4de88c8628e79c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths()&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">使用 &lt;code&gt;env::join_paths()&lt;/code&gt; 与&lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths()&lt;/code&gt; &lt;/a&gt;追加到该项目 &lt;code&gt;PATH&lt;/code&gt; 环境变量：</target>
        </trans-unit>
        <trans-unit id="efb72794ee8412b2ec8c4ed130b77aa3fe94a4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">结合使用 &lt;code&gt;env::join_paths&lt;/code&gt; 和&lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths&lt;/code&gt; &lt;/a&gt;可以将项目附加到 &lt;code&gt;PATH&lt;/code&gt; 环境变量中：</target>
        </trans-unit>
        <trans-unit id="883e296f0933a9796d7609478617eb9fc57e41d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; as a &quot;do nothing&quot; base case in a conditional:</source>
          <target state="translated">在以下情况下将 &lt;code&gt;identity&lt;/code&gt; 用作&amp;ldquo;不执行任何操作&amp;rdquo;的基本情况：</target>
        </trans-unit>
        <trans-unit id="145643f8069cc90bb1d66393cde6c665263c5694" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing among other interesting functions:</source>
          <target state="translated">在其他有趣的功能中，使用 &lt;code&gt;identity&lt;/code&gt; 不做任何事情：</target>
        </trans-unit>
        <trans-unit id="f1235a5ac3f06cf39c5a154506b55894e72fe10a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing in a sequence of other, interesting, functions:</source>
          <target state="translated">使用 &lt;code&gt;identity&lt;/code&gt; 在一系列其他有趣的功能中什么也不做：</target>
        </trans-unit>
        <trans-unit id="c0c92b7b9d3a5d2fd97452ae43966326ca17955c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to get a function that changes nothing in a conditional:</source>
          <target state="translated">使用 &lt;code&gt;identity&lt;/code&gt; 获取在条件中不变的函数：</target>
        </trans-unit>
        <trans-unit id="8a03c63b02cfcec88b468a3f0a4f356859de8742" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to keep the &lt;code&gt;Some&lt;/code&gt; variants of an iterator of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;identity&lt;/code&gt; 保留 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 的迭代器的 &lt;code&gt;Some&lt;/code&gt; 变体：</target>
        </trans-unit>
        <trans-unit id="b86b145b4aec4479f3e7888989e9c6f53ce3db7d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;if let&lt;/code&gt; means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that &lt;code&gt;match&lt;/code&gt; enforces. Choosing between &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;if let&lt;/code&gt; depends on what you&amp;rsquo;re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</source>
          <target state="translated">使用 &lt;code&gt;if let&lt;/code&gt; 意味着更少的键入，更少的缩进和更少的样板代码。但是，您将丢失 &lt;code&gt;match&lt;/code&gt; 实施的详尽检查。在 &lt;code&gt;match&lt;/code&gt; 和 &lt;code&gt;if let&lt;/code&gt; 进行比赛之间进行选择取决于您在特定情况下的工作方式以及是否获得简洁性是失去详尽检查的适当权衡。</target>
        </trans-unit>
        <trans-unit id="7b98e766b3b912d79bb4b0c519c379c12d658619" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;match&lt;/code&gt; works well enough, but it can be a bit verbose and doesn&amp;rsquo;t always communicate intent well. The &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many helper methods defined on it to do various tasks. One of those methods, called &lt;code&gt;unwrap&lt;/code&gt;, is a shortcut method that is implemented just like the &lt;code&gt;match&lt;/code&gt; expression we wrote in Listing 9-4. If the &lt;code&gt;Result&lt;/code&gt; value is the &lt;code&gt;Ok&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will return the value inside the &lt;code&gt;Ok&lt;/code&gt;. If the &lt;code&gt;Result&lt;/code&gt; is the &lt;code&gt;Err&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will call the &lt;code&gt;panic!&lt;/code&gt; macro for us. Here is an example of &lt;code&gt;unwrap&lt;/code&gt; in action:</source>
          <target state="translated">使用 &lt;code&gt;match&lt;/code&gt; 效果很好，但是可能有点冗长，而且不一定总是很好地传达意图。该 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 类型上定义执行各种任务的许多辅助方法。其中一种方法称为 &lt;code&gt;unwrap&lt;/code&gt; ，是一种快捷方法，其实现方式 &lt;code&gt;match&lt;/code&gt; 清单9-4中编写的match表达式相同。如果 &lt;code&gt;Result&lt;/code&gt; 值是 &lt;code&gt;Ok&lt;/code&gt; 变量，则 &lt;code&gt;unwrap&lt;/code&gt; 将在 &lt;code&gt;Ok&lt;/code&gt; 内部返回值。如果 &lt;code&gt;Result&lt;/code&gt; 是 &lt;code&gt;Err&lt;/code&gt; 变体，则 &lt;code&gt;unwrap&lt;/code&gt; 将引起 &lt;code&gt;panic!&lt;/code&gt; 对我们来说是宏。这里是一个例子 &lt;code&gt;unwrap&lt;/code&gt; 实际上：</target>
        </trans-unit>
        <trans-unit id="716d3b2c36a0e8f26b1196bb5c8509c4d656cdaa" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mul_add&lt;/code&gt; can be more performant than an unfused multiply-add if the target architecture has a dedicated &lt;code&gt;fma&lt;/code&gt; CPU instruction.</source>
          <target state="translated">如果目标体系结构具有专用的 &lt;code&gt;fma&lt;/code&gt; CPU指令，则使用 &lt;code&gt;mul_add&lt;/code&gt; 会比未融合的乘法加法更具性能。</target>
        </trans-unit>
        <trans-unit id="1150ca9c0c5f9cb7d33fb3908d78558b0edfddac" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mul_add&lt;/code&gt;&lt;em&gt;may&lt;/em&gt; be more performant than an unfused multiply-add if the target architecture has a dedicated &lt;code&gt;fma&lt;/code&gt; CPU instruction. However, this is not always true, and will be heavily dependant on designing algorithms with specific target hardware in mind.</source>
          <target state="translated">如果目标体系结构具有专用的 &lt;code&gt;fma&lt;/code&gt; CPU指令，则使用 &lt;code&gt;mul_add&lt;/code&gt; &lt;em&gt;可能&lt;/em&gt;比未融合的乘法加法性能更高。但是，这并不总是正确的，并且在很大程度上取决于设计算法时要考虑特定的目标硬件。</target>
        </trans-unit>
        <trans-unit id="b8c91e11b4f888f4c592a35e44ac17004a0fb755" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;println!&lt;/code&gt; directly:</source>
          <target state="translated">使用 &lt;code&gt;println!&lt;/code&gt; 直：</target>
        </trans-unit>
        <trans-unit id="4e19595061858aceb197932ab33548b4e2d9024e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;to_string&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;to_string&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9355d5eaee5786ccc5834b09b61c0a558e231c8f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe {}&lt;/code&gt; blocks and &lt;code&gt;impl&lt;/code&gt;s</source>
          <target state="translated">使用 &lt;code&gt;unsafe {}&lt;/code&gt; 块， &lt;code&gt;impl&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="ddd1e2fb0a495ca1deedb73f663b2b41b48287c3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the five actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems when they occur.</source>
          <target state="translated">用 &lt;code&gt;unsafe&lt;/code&gt; 手段采取上述五个行动（超级大国）之一是没有错的，甚至没有皱眉。但是正确获取 &lt;code&gt;unsafe&lt;/code&gt; 代码比较困难，因为编译器无法帮助维护内存安全性。当您有理由使用 &lt;code&gt;unsafe&lt;/code&gt; 代码时，可以这样做，并且拥有显式的 &lt;code&gt;unsafe&lt;/code&gt; 注释可以更轻松地查找问题发生的原因。</target>
        </trans-unit>
        <trans-unit id="23e77887900c6717f9133b9abc150eed86948327" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the four actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems if they occur.</source>
          <target state="translated">使用 &lt;code&gt;unsafe&lt;/code&gt; 行为采取上述四个动作（超级大国）之一并没有错，甚至没有皱眉。但是正确获取 &lt;code&gt;unsafe&lt;/code&gt; 代码比较棘手，因为编译器无法帮助维护内存安全性。当您有理由使用 &lt;code&gt;unsafe&lt;/code&gt; 代码时，可以这样做，并且拥有显式的 &lt;code&gt;unsafe&lt;/code&gt; 注释可以更容易地找出问题的根源。</target>
        </trans-unit>
        <trans-unit id="079ef6902b572fab1f5b45933254dfd23aa7b9b5" translate="yes" xml:space="preserve">
          <source>Using Closures that Capture Their Environment</source>
          <target state="translated">使用能捕捉环境的闭合装置</target>
        </trans-unit>
        <trans-unit id="356483451b80563e823eec07c158f3c0e2a19756" translate="yes" xml:space="preserve">
          <source>Using External Packages</source>
          <target state="translated">使用外部包</target>
        </trans-unit>
        <trans-unit id="195ec6c54d68d4bc74c1c0e9e4aa71e8ed1d66dc" translate="yes" xml:space="preserve">
          <source>Using Message Passing to Transfer Data Between Threads</source>
          <target state="translated">使用消息传递在线程之间传输数据。</target>
        </trans-unit>
        <trans-unit id="1f1119d00f411f28a788c634b094f7830af90354" translate="yes" xml:space="preserve">
          <source>Using Mutexes to Allow Access to Data from One Thread at a Time</source>
          <target state="translated">使用互斥允许一次访问一个线程的数据</target>
        </trans-unit>
        <trans-unit id="0f71d9d6c5e4eb6b3d84f4f1645f9d37c7834e08" translate="yes" xml:space="preserve">
          <source>Using Nested Paths to Clean Up Large &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; Lists</source>
          <target state="translated">使用嵌套路径清理大型 &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; 列表</target>
        </trans-unit>
        <trans-unit id="d061dfad64af5ced98da4099941d9962a4cf4ab6" translate="yes" xml:space="preserve">
          <source>Using Other &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; Trait Methods</source>
          <target state="translated">使用其他 &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; 特征方法</target>
        </trans-unit>
        <trans-unit id="90caab8414681ad380cd72175835d7d3a714a974" translate="yes" xml:space="preserve">
          <source>Using Our &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; Iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">使用我们的 &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; 迭代器的 &lt;code&gt;next&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="4a36ca6063affef138895d5e70695435940c7941" translate="yes" xml:space="preserve">
          <source>Using Statics or Consts</source>
          <target state="translated">使用静态或静态</target>
        </trans-unit>
        <trans-unit id="1d80a86fe9446545a29df6fe583694b8305fad7f" translate="yes" xml:space="preserve">
          <source>Using Structs to Structure Related Data</source>
          <target state="translated">使用Structs来构建相关数据</target>
        </trans-unit>
        <trans-unit id="1725c7720c6951cb5321da47bdec76e1efb5b498" translate="yes" xml:space="preserve">
          <source>Using Supertraits to Require One Trait&amp;rsquo;s Functionality Within Another Trait</source>
          <target state="translated">使用超性要求一个特质在另一个特质内的功能</target>
        </trans-unit>
        <trans-unit id="e5f7eb8898bb60910740832d2142728eab94b626" translate="yes" xml:space="preserve">
          <source>Using Threads to Run Code Simultaneously</source>
          <target state="translated">使用线程同时运行代码</target>
        </trans-unit>
        <trans-unit id="9c88360016895ec6069e43a4e277e7bdb51ba9ed" translate="yes" xml:space="preserve">
          <source>Using Trait Bounds to Conditionally Implement Methods</source>
          <target state="translated">使用特质边界来有条件地实现方法</target>
        </trans-unit>
        <trans-unit id="b4544e80831327296977b0f0c1bed06cd890a1fd" translate="yes" xml:space="preserve">
          <source>Using Trait Objects That Allow for Values of Different Types</source>
          <target state="translated">使用允许不同类型值的特征对象。</target>
        </trans-unit>
        <trans-unit id="735958a37951062c949a84a063e5b1d398369b00" translate="yes" xml:space="preserve">
          <source>Using Tuple Structs without Named Fields to Create Different Types</source>
          <target state="translated">使用没有命名字段的元组结构来创建不同的类型。</target>
        </trans-unit>
        <trans-unit id="675231858eb84206141ae12e664714cc21d2c19b" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Store Data on the Heap</source>
          <target state="translated">使用 &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 将数据存储在堆上</target>
        </trans-unit>
        <trans-unit id="f84a17c2b7b640800d3c95a6c6874936d40e4172" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; Backtrace</source>
          <target state="translated">使用 &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; 回溯</target>
        </trans-unit>
        <trans-unit id="fa90ed41bcf90ab01a0c0386a65d7892a205380d" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Fn&lt;/code&gt; parameter</source>
          <target state="translated">使用 &lt;code&gt;Fn&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="c233f257ce2f61e1743d09ba4202b368e77eac25" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnMut&lt;/code&gt; parameter</source>
          <target state="translated">使用 &lt;code&gt;FnMut&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="c47fce11968d69df2be1beb510ac309f7cc7fe1c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnOnce&lt;/code&gt; parameter</source>
          <target state="translated">使用 &lt;code&gt;FnOnce&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="eaa2ddbdb2af4f1c7b600386f3ab5d07fb639266" translate="yes" xml:space="preserve">
          <source>Using a Crate to Get More Functionality</source>
          <target state="translated">使用木箱获得更多功能</target>
        </trans-unit>
        <trans-unit id="5490ba3cbb37583be424e7381702b1ad23cc8d1f" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在将争用锁由在不同CPU上执行的另一个线程持有竞争锁并且等待时间相对较短的情况下，理想地使用带有 &lt;code&gt;spin_loop&lt;/code&gt; 的繁忙等待自旋循环。因为进入忙等待自旋循环不会触发系统的调度程序，所以切换线程不会产生任何开销。但是，如果持有竞争锁的线程在同一CPU上运行，则自旋循环可能会在切换到持有锁的线程之前占据整个CPU片。如果竞争锁由同一CPU上的线程持有，或者获取锁的等待时间较长，则通常最好使用&lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c1ce34ae6a3ca80d5e3bf4a0b0c41abaf191eae" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop_hint&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">理想情况下，将忙等待自旋循环与 &lt;code&gt;spin_loop_hint&lt;/code&gt; 一起使用时，争执的锁由在不同CPU上执行的另一个线程持有，并且等待时间相对较短。由于进入忙等待自旋循环不会触发系统的调度程序，因此不会发生切换线程的开销。但是，如果持有竞争锁的线程在同一CPU上运行，则自旋循环可能会在切换到持有锁的线程之前占据整个CPU片。如果竞争锁由同一CPU上的线程持有，或者获取锁的等待时间较长，则通常最好使用&lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b1ac01f9a3840dc6d78887aac134760ed5ceafe" translate="yes" xml:space="preserve">
          <source>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, &amp;ldquo;Add Sally to Engineering&amp;rdquo; or &amp;ldquo;Add Amir to Sales.&amp;rdquo; Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</source>
          <target state="translated">使用哈希图和向量创建一个文本界面，以允许用户将员工姓名添加到公司的部门中。例如，&amp;ldquo;将Sally添加到工程&amp;rdquo;或&amp;ldquo;将Amir添加到销售&amp;rdquo;。然后让用户检索部门中所有人员或部门中公司所有人员的列表，并按字母顺序排序。</target>
        </trans-unit>
        <trans-unit id="09dacd7c78dbd0bf44dabf88b33b52973a393ac8" translate="yes" xml:space="preserve">
          <source>Using a primitive representation in addition to &lt;code&gt;repr(C)&lt;/code&gt; can change the size of an enum from the &lt;code&gt;repr(C)&lt;/code&gt; form:</source>
          <target state="translated">除了 &lt;code&gt;repr(C)&lt;/code&gt; 以外，还使用基本表示形式可以从 &lt;code&gt;repr(C)&lt;/code&gt; 形式更改枚举的大小：</target>
        </trans-unit>
        <trans-unit id="d4c37907d281b1198f03324a18111844e539d53d" translate="yes" xml:space="preserve">
          <source>Using a search key that doesn't work with the Borrow trait</source>
          <target state="translated">使用搜索键不能与 &quot;借用 &quot;特性一起使用。</target>
        </trans-unit>
        <trans-unit id="cd14ecb207f28002c37a4e53dc6c1cebfa5f2ee9" translate="yes" xml:space="preserve">
          <source>Using a semicolon after &lt;code&gt;mod front_of_house&lt;/code&gt; rather than using a block tells Rust to load the contents of the module from another file with the same name as the module. To continue with our example and extract the &lt;code&gt;hosting&lt;/code&gt; module to its own file as well, we change &lt;em&gt;src/front_of_house.rs&lt;/em&gt; to contain only the declaration of the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="translated">在 &lt;code&gt;mod front_of_house&lt;/code&gt; 之后使用分号（而不是使用块）会告诉Rust从另一个与模块同名的文件中加载模块的内容。为了继续我们的示例并将 &lt;code&gt;hosting&lt;/code&gt; 模块也提取到其自己的文件中，我们将&lt;em&gt;src / front_of_house.rs&lt;/em&gt;更改为仅包含 &lt;code&gt;hosting&lt;/code&gt; 模块的声明：</target>
        </trans-unit>
        <trans-unit id="fe93078130b3109ad5108e782dba78cf01903057" translate="yes" xml:space="preserve">
          <source>Using a tuple of &lt;code&gt;Bound&lt;/code&gt;s as an argument to &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt;&lt;code&gt;BTreeMap::range&lt;/code&gt;&lt;/a&gt;. Note that in most cases, it's better to use range syntax (&lt;code&gt;1..5&lt;/code&gt;) instead.</source>
          <target state="translated">使用 &lt;code&gt;Bound&lt;/code&gt; 的元组作为&lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt; &lt;code&gt;BTreeMap::range&lt;/code&gt; &lt;/a&gt;的参数。请注意，在大多数情况下，最好使用范围语法（ &lt;code&gt;1..5&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="015c01b29f1c8ebb6c4c8943a2dc3adcbae06181" translate="yes" xml:space="preserve">
          <source>Using an Enum to Store Multiple Types</source>
          <target state="translated">使用一个枚举来存储多个类型</target>
        </trans-unit>
        <trans-unit id="b5882a2dc057a0d8d156ec2e30b99dd996e5bdcc" translate="yes" xml:space="preserve">
          <source>Using built-in default values:</source>
          <target state="translated">使用内置的默认值。</target>
        </trans-unit>
        <trans-unit id="f3dacd0d875f3e763ce98391694ffe59eeffec43" translate="yes" xml:space="preserve">
          <source>Using custom comparison logic without newtype wrappers</source>
          <target state="translated">使用自定义比较逻辑而不使用新类型包装器</target>
        </trans-unit>
        <trans-unit id="a4db67f6f9b0784800ae988e7704553e6de06b09" translate="yes" xml:space="preserve">
          <source>Using default values:</source>
          <target state="translated">使用默认值。</target>
        </trans-unit>
        <trans-unit id="8ec600b0ec907749b0fdd372e79b0c70b7b0dce0" translate="yes" xml:space="preserve">
          <source>Using enums has even more advantages. Thinking more about our IP address type, at the moment we don&amp;rsquo;t have a way to store the actual IP address &lt;em&gt;data&lt;/em&gt;; we only know what &lt;em&gt;kind&lt;/em&gt; it is. Given that you just learned about structs in Chapter 5, you might tackle this problem as shown in Listing 6-1.</source>
          <target state="translated">使用枚举具有更多优势。考虑更多关于我们的IP地址类型的信息，目前我们还没有办法存储实际的IP地址&lt;em&gt;数据&lt;/em&gt;；我们只知道什么&lt;em&gt;样&lt;/em&gt;是。既然您刚刚在第5章中了解了结构，就可以解决此问题，如清单6-1所示。</target>
        </trans-unit>
        <trans-unit id="3e92abb62f29a9ab743c0868201fc7c6f7cc104c" translate="yes" xml:space="preserve">
          <source>Using explicit synchronization:</source>
          <target state="translated">使用显性同步。</target>
        </trans-unit>
        <trans-unit id="26140a4b00b6db68bc5c08aa7b59f4de9a496d44" translate="yes" xml:space="preserve">
          <source>Using implicit synchronization:</source>
          <target state="translated">使用隐性同步。</target>
        </trans-unit>
        <trans-unit id="0964494ac4fd47f86d6e1abd134d8f88a80450c7" translate="yes" xml:space="preserve">
          <source>Using mutation and going finite:</source>
          <target state="translated">利用突变和去有限。</target>
        </trans-unit>
        <trans-unit id="c5cfc67f6bee08fd41a46b1d08f1ad9861c6e196" translate="yes" xml:space="preserve">
          <source>Using path qualifiers like &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword.super&quot;&gt;&lt;code&gt;super&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.self&quot;&gt;&lt;code&gt;self&lt;/code&gt;&lt;/a&gt; is supported: &lt;code&gt;use crate::a::b;&lt;/code&gt;.</source>
          <target state="translated">支持使用诸如&lt;a href=&quot;keyword.crate&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;keyword.super&quot;&gt; &lt;code&gt;super&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;keyword.self&quot;&gt; &lt;code&gt;self&lt;/code&gt; 之&lt;/a&gt;类的路径限定符： &lt;code&gt;use crate::a::b;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff5b3892671b9cc1bcba84f83ea8ba99412282b3" translate="yes" xml:space="preserve">
          <source>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax &lt;code&gt;..&lt;/code&gt; specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</source>
          <target state="translated">使用struct update语法，我们可以用更少的代码来达到相同的效果，如清单5-7所示。语法 &lt;code&gt;..&lt;/code&gt; 指定未明确设置的其余字段应与给定实例中的字段具有相同的值。</target>
        </trans-unit>
        <trans-unit id="149131436ae6fcc58b9d3b44704c0a4f62b58b80" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:</source>
          <target state="translated">使用&amp;ldquo; turbofish&amp;rdquo;而不是注释 &lt;code&gt;doubled&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1fee5723d61f0a87e52c62c70350b33d4a2c1211" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;four&lt;/code&gt;:</source>
          <target state="translated">使用&amp;ldquo; turbofish&amp;rdquo;而不是注释 &lt;code&gt;four&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8dca1dfea48258776a757d0e7fdd52e32ddc6d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; Function in the &lt;code&gt;run&lt;/code&gt; Function</source>
          <target state="translated">在 &lt;code&gt;run&lt;/code&gt; 功能中使用 &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="73cb7c6eceba8574fdab292dc3c5b0a2f2322727" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&lt;/code&gt; type to store the list &lt;code&gt;1, 2, 3&lt;/code&gt; would look like the code in Listing 15-3:</source>
          <target state="translated">使用 &lt;code&gt;List&lt;/code&gt; 类型存储列表 &lt;code&gt;1, 2, 3&lt;/code&gt; 类似于清单15-3中的代码：</target>
        </trans-unit>
        <trans-unit id="707e73f8481ac39cdfa5e294240c14e577bab80b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;ref&lt;/code&gt; keyword, the value is only borrowed, not moved, making it available for use after the &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">使用 &lt;code&gt;ref&lt;/code&gt; 关键字，该值仅被借用，而不移动，从而使其在&lt;a href=&quot;keyword.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;语句后可用：</target>
        </trans-unit>
        <trans-unit id="e2545ef2f465dd4b2bb1fca4f7b62b633439903e" translate="yes" xml:space="preserve">
          <source>Using the Field Init Shorthand when Variables and Fields Have the Same Name</source>
          <target state="translated">当变量和字段名称相同时,使用字段初始化速记。</target>
        </trans-unit>
        <trans-unit id="527c6fc37f2c7ff511bb334d8bc01dfd4d796198" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern for Type Safety and Abstraction</source>
          <target state="translated">使用Newtype模式实现类型安全和抽象化</target>
        </trans-unit>
        <trans-unit id="0445dab15f95bbaf439f12315a2f6c2606b64d6c" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern to Implement External Traits on External Types</source>
          <target state="translated">使用Newtype模式在外部类型上实现外部特征。</target>
        </trans-unit>
        <trans-unit id="6efe08dd70627a6ae791a8f3c7e219c91abdce73" translate="yes" xml:space="preserve">
          <source>Using the Returned Iterator Directly</source>
          <target state="translated">直接使用返回的迭代器</target>
        </trans-unit>
        <trans-unit id="bfe1a641af30e378f1440126b6876e787e3aeb21" translate="yes" xml:space="preserve">
          <source>Using the state pattern means when the business requirements of the program change, we won&amp;rsquo;t need to change the code of the value holding the state or the code that uses the value. We&amp;rsquo;ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects. Let&amp;rsquo;s look at an example of the state design pattern and how to use it in Rust.</source>
          <target state="translated">使用状态模式意味着当程序的业务需求发生变化时，我们不需要更改保存状态的值的代码或使用该值的代码。我们只需要更新其中一个状态对象中的代码即可更改其规则或添加更多状态对象。让我们看一下状态设计模式的示例以及如何在Rust中使用它。</target>
        </trans-unit>
        <trans-unit id="f27958ea70e4427546613b6470c7b4a627139188" translate="yes" xml:space="preserve">
          <source>Using this declaration, it must be called with at least one argument, so simply calling &lt;code&gt;printf()&lt;/code&gt; is invalid. But the following uses are allowed:</source>
          <target state="translated">使用此声明，必须使用至少一个参数来调用它，因此简单地调用 &lt;code&gt;printf()&lt;/code&gt; 是无效的。但是允许以下用途：</target>
        </trans-unit>
        <trans-unit id="3febf8421408faebfe197da05a42aac2ff47af45" translate="yes" xml:space="preserve">
          <source>Using this definition, Rust is object oriented: structs and enums have data, and &lt;code&gt;impl&lt;/code&gt; blocks provide methods on structs and enums. Even though structs and enums with methods aren&amp;rsquo;t &lt;em&gt;called&lt;/em&gt; objects, they provide the same functionality, according to the Gang of Four&amp;rsquo;s definition of objects.</source>
          <target state="translated">使用此定义，Rust是面向对象的：结构和枚举具有数据，而 &lt;code&gt;impl&lt;/code&gt; 块提供有关结构和枚举的方法。根据&amp;ldquo;四人帮&amp;rdquo;对对象的定义，即使带有方法的结构和枚举不&lt;em&gt;被称为&lt;/em&gt;对象，它们也提供相同的功能。</target>
        </trans-unit>
        <trans-unit id="4bd35f75969eee3d765cd1e9dcbd0cf13c21dc8a" translate="yes" xml:space="preserve">
          <source>Using this function is generally faster than using &lt;code&gt;powf&lt;/code&gt;</source>
          <target state="translated">使用此功能通常比使用 &lt;code&gt;powf&lt;/code&gt; 更快</target>
        </trans-unit>
        <trans-unit id="c548fba9d029d6e16cb5aeebbb487347aada0fef" translate="yes" xml:space="preserve">
          <source>Using this macro is often a bad idea, because if the file is parsed as an expression, it is going to be placed in the surrounding code unhygienically. This could result in variables or functions being different from what the file expected if there are variables or functions that have the same name in the current file.</source>
          <target state="translated">使用这个宏通常是一个坏主意,因为如果文件被解析为表达式,它将被不卫生地放在周围的代码中。如果当前文件中存在名称相同的变量或函数,这可能会导致变量或函数与文件的预期不同。</target>
        </trans-unit>
        <trans-unit id="a7c45efccaaa01e2feb082b19ddba5a32324e6fa" translate="yes" xml:space="preserve">
          <source>Using this method is equivalent to the following code:</source>
          <target state="translated">使用这种方法相当于下面的代码。</target>
        </trans-unit>
        <trans-unit id="15e11a1b79c37f9d667f56c8b714852cef36b238" translate="yes" xml:space="preserve">
          <source>Using too many &lt;code&gt;else if&lt;/code&gt; expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called &lt;code&gt;match&lt;/code&gt; for these cases.</source>
          <target state="translated">&lt;code&gt;else if&lt;/code&gt; 表达式太多，可能会使代码混乱，因此如果使用多个表达式，则可能需要重构代码。第6章介绍了针对这些情况的功能强大的Rust分支构造，称为 &lt;code&gt;match&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e52bd27c5d26825ad08651412fd660a16f020f77" translate="yes" xml:space="preserve">
          <source>Using too many trait bounds has its downsides. Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function&amp;rsquo;s name and its parameter list, making the function signature hard to read. For this reason, Rust has alternate syntax for specifying trait bounds inside a &lt;code&gt;where&lt;/code&gt; clause after the function signature. So instead of writing this:</source>
          <target state="translated">使用太多特质界限有其缺点。每个泛型都有其自己的特征范围，因此具有多个泛型类型参数的函数可以在函数名称与其参数列表之间包含许多特征绑定信息，从而使函数签名难以阅读。因此，Rust具有备用语法，用于在函数签名后的 &lt;code&gt;where&lt;/code&gt; 子句中指定特征范围。所以不用写这个：</target>
        </trans-unit>
        <trans-unit id="e8270120e8e5872b95f691e94134c3c38cbe49b0" translate="yes" xml:space="preserve">
          <source>Using traits and lifetimes where appropriate (&lt;a href=&quot;ch10-00-generics&quot;&gt;Chapter 10&lt;/a&gt;)</source>
          <target state="translated">在适当的地方使用特征和寿命（&lt;a href=&quot;ch10-00-generics&quot;&gt;第10章&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1c8fe76861637e35d40bd85f3825d619bc84eadf" translate="yes" xml:space="preserve">
          <source>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</source>
          <target state="translated">使用不安全的功能有潜在的危险性,是安全检查所不允许的。例如:</target>
        </trans-unit>
        <trans-unit id="f903dfb928504d5e71a1ab430366f1a7eae7e14e" translate="yes" xml:space="preserve">
          <source>Using vectors and strings (collections, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;Chapter 8&lt;/a&gt;)</source>
          <target state="translated">使用向量和字符串（集合，&lt;a href=&quot;ch08-00-common-collections&quot;&gt;第8章&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="d6513e8f7510d42121946e2407ba6c2011fc2c1c" translate="yes" xml:space="preserve">
          <source>Usually a &lt;code&gt;use&lt;/code&gt; keyword is used to shorten the path required to refer to a module item. The keyword may appear in modules, blocks and even functions, usually at the top.</source>
          <target state="translated">通常， &lt;code&gt;use&lt;/code&gt; 关键字用于缩短引用模块项所需的路径。关键字可能出现在模块，块甚至功能中，通常在顶部。</target>
        </trans-unit>
        <trans-unit id="d83a4fba159bee344e91cbe040d6123421c523d3" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't literally use &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; from Rust, but C APIs hand out a lot of pointers generally, so are a common source of raw pointers in Rust.</source>
          <target state="translated">通常，您实际上不会使用 &lt;code&gt;malloc&lt;/code&gt; 并从Rust中 &lt;code&gt;free&lt;/code&gt; 出来，但是C API通常会发出很多指针，因此Rust中的原始指针也很常见。</target>
        </trans-unit>
        <trans-unit id="906d4775d8872c7dc79527063674165dda2ccbc0" translate="yes" xml:space="preserve">
          <source>Usually, generic parameters get &lt;em&gt;monomorphized&lt;/em&gt;. For example, if I have</source>
          <target state="translated">通常，通用参数会&lt;em&gt;被单态化&lt;/em&gt;。例如，如果我有</target>
        </trans-unit>
        <trans-unit id="d259bb65f469f691c60fbc1cce6f48ae71721980" translate="yes" xml:space="preserve">
          <source>Usually, iterators iterate from left to right. After using &lt;code&gt;rev()&lt;/code&gt;, an iterator will instead iterate from right to left.</source>
          <target state="translated">通常，迭代器从左到右进行迭代。使用 &lt;code&gt;rev()&lt;/code&gt; 之后，迭代器将改为从右向左迭代。</target>
        </trans-unit>
        <trans-unit id="71c8b88aacf28ce47b0a58b2d2bc8a3fb05b911b" translate="yes" xml:space="preserve">
          <source>Utf8Error</source>
          <target state="translated">Utf8Error</target>
        </trans-unit>
        <trans-unit id="0dc56eae851492c66ecabf78d1bbaf00296acfbe" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow</source>
          <target state="translated">Utf8Error::borrow</target>
        </trans-unit>
        <trans-unit id="62c9947a079483bdf0d15d01617213826dc02f38" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow_mut</source>
          <target state="translated">Utf8Error::borrow_mut</target>
        </trans-unit>
        <trans-unit id="3f5e10da6a480e49a740c45c14fd97e4e299d73d" translate="yes" xml:space="preserve">
          <source>Utf8Error::cause</source>
          <target state="translated">Utf8Error::cause</target>
        </trans-unit>
        <trans-unit id="aba276798126f3d9e88abbf114717adc671724b0" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone</source>
          <target state="translated">Utf8Error::clone</target>
        </trans-unit>
        <trans-unit id="d9f741fd3eb062e41262e053f0eb1a689e8b68c8" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_from</source>
          <target state="translated">Utf8Error::clone_from</target>
        </trans-unit>
        <trans-unit id="6fb618053c3a87e8372bf0b005ef3aee33a2be29" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_into</source>
          <target state="translated">Utf8Error::clone_into</target>
        </trans-unit>
        <trans-unit id="5eb848f299ba96b5c68a3de5bf02961b034fb439" translate="yes" xml:space="preserve">
          <source>Utf8Error::description</source>
          <target state="translated">Utf8Error::description</target>
        </trans-unit>
        <trans-unit id="1e357eccf69d01f74bf39edbfab63655804a87a8" translate="yes" xml:space="preserve">
          <source>Utf8Error::eq</source>
          <target state="translated">Utf8Error::eq</target>
        </trans-unit>
        <trans-unit id="88f730d875142fa4beddb68ae32ca749e55c5da0" translate="yes" xml:space="preserve">
          <source>Utf8Error::error_len</source>
          <target state="translated">Utf8Error::error_len</target>
        </trans-unit>
        <trans-unit id="81707f4d43116cddc3b6180c7d1812770aa6aabd" translate="yes" xml:space="preserve">
          <source>Utf8Error::fmt</source>
          <target state="translated">Utf8Error::fmt</target>
        </trans-unit>
        <trans-unit id="80d9f3c5cc9b436bfc54741853eb348edcd31923" translate="yes" xml:space="preserve">
          <source>Utf8Error::from</source>
          <target state="translated">Utf8Error::from</target>
        </trans-unit>
        <trans-unit id="186ae2f6ff2c38ceed80692f48587dd9073b281b" translate="yes" xml:space="preserve">
          <source>Utf8Error::into</source>
          <target state="translated">Utf8Error::into</target>
        </trans-unit>
        <trans-unit id="da5d217600f498b06be2479022d36a4a5c15449b" translate="yes" xml:space="preserve">
          <source>Utf8Error::ne</source>
          <target state="translated">Utf8Error::ne</target>
        </trans-unit>
        <trans-unit id="65ff32fff52c3afe8fd1470fd4590b2fae222e96" translate="yes" xml:space="preserve">
          <source>Utf8Error::source</source>
          <target state="translated">Utf8Error::source</target>
        </trans-unit>
        <trans-unit id="d542954047d8755ad1a4e9a853bcf03561cdf1c9" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_owned</source>
          <target state="translated">Utf8Error::to_owned</target>
        </trans-unit>
        <trans-unit id="ef5e78b58ef441d19d975802cc905ce882b752c7" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_string</source>
          <target state="translated">Utf8Error::to_string</target>
        </trans-unit>
        <trans-unit id="eb1790431a34016d236cceca893cabedf79794fa" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_from</source>
          <target state="translated">Utf8Error::try_from</target>
        </trans-unit>
        <trans-unit id="d78057a09376f581ad70dcf23d55b916b4ec76d6" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_into</source>
          <target state="translated">Utf8Error::try_into</target>
        </trans-unit>
        <trans-unit id="77455bd6cede93b6937284b56ca0ee7128f3fcd5" translate="yes" xml:space="preserve">
          <source>Utf8Error::type_id</source>
          <target state="translated">Utf8Error::type_id</target>
        </trans-unit>
        <trans-unit id="061f930ae2881081028ec6f4738788ea0386348a" translate="yes" xml:space="preserve">
          <source>Utf8Error::valid_up_to</source>
          <target state="translated">Utf8Error::valid_up_to</target>
        </trans-unit>
        <trans-unit id="098996f33abfeafe0fd0a1060966a3bd981c2d4c" translate="yes" xml:space="preserve">
          <source>Utilities for formatting and printing &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">格式化和打印 &lt;code&gt;String&lt;/code&gt; 的实用程序。</target>
        </trans-unit>
        <trans-unit id="bbf05f92621e129ba6a9d6d71f520f94619321a3" translate="yes" xml:space="preserve">
          <source>Utilities related to FFI bindings.</source>
          <target state="translated">与FFI绑定有关的实用程序。</target>
        </trans-unit>
        <trans-unit id="2cfce7b7e1bbf22d999dd679513efd8dd1774d5b" translate="yes" xml:space="preserve">
          <source>Utility trait implemented only on arrays of fixed size</source>
          <target state="translated">仅在固定大小的数组上实现实用性特征。</target>
        </trans-unit>
        <trans-unit id="f4dc02e287a9f4de99799a5c31108f51723830a7" translate="yes" xml:space="preserve">
          <source>VXWorks</source>
          <target state="translated">VXWorks</target>
        </trans-unit>
        <trans-unit id="2a62ae9e6e10d5b4d844ad431e3d12dd6181892a" translate="yes" xml:space="preserve">
          <source>VaList</source>
          <target state="translated">VaList</target>
        </trans-unit>
        <trans-unit id="d3dc417a5e809aff4e928e1c2ccc9e1476eea745" translate="yes" xml:space="preserve">
          <source>VaList::arg</source>
          <target state="translated">VaList::arg</target>
        </trans-unit>
        <trans-unit id="e56bcc6610b1a8196319373f5b202bf4d9783931" translate="yes" xml:space="preserve">
          <source>VaList::as_va_list</source>
          <target state="translated">VaList::as_va_list</target>
        </trans-unit>
        <trans-unit id="93ccd0479992f30997a13f7a0291305d4a7bcf8f" translate="yes" xml:space="preserve">
          <source>VaList::borrow</source>
          <target state="translated">VaList::borrow</target>
        </trans-unit>
        <trans-unit id="14c647375c9b8191c6015d7e9763130b93ea3cb0" translate="yes" xml:space="preserve">
          <source>VaList::borrow_mut</source>
          <target state="translated">VaList::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c8adb5d15703c32cb6620339a1ad3a830f1ad937" translate="yes" xml:space="preserve">
          <source>VaList::deref</source>
          <target state="translated">VaList::deref</target>
        </trans-unit>
        <trans-unit id="ef4f8c0aefca94cf0351ab804dcb1192072b3317" translate="yes" xml:space="preserve">
          <source>VaList::deref_mut</source>
          <target state="translated">VaList::deref_mut</target>
        </trans-unit>
        <trans-unit id="4df0a82f8196ee6c8e34acaf7e521f5043ecc3f2" translate="yes" xml:space="preserve">
          <source>VaList::fmt</source>
          <target state="translated">VaList::fmt</target>
        </trans-unit>
        <trans-unit id="03cb0ba45ef46a478c6e89bd3b44e1281a4d5eb6" translate="yes" xml:space="preserve">
          <source>VaList::from</source>
          <target state="translated">VaList::from</target>
        </trans-unit>
        <trans-unit id="2b7cbe3710d07592cd359bf917b0387f4e9e9c5d" translate="yes" xml:space="preserve">
          <source>VaList::into</source>
          <target state="translated">VaList::into</target>
        </trans-unit>
        <trans-unit id="006354eed9f82fbe26fc29d15037b46b80c2b68d" translate="yes" xml:space="preserve">
          <source>VaList::try_from</source>
          <target state="translated">VaList::try_from</target>
        </trans-unit>
        <trans-unit id="cb8a2fefa105254fc69713249a582cf152da5fab" translate="yes" xml:space="preserve">
          <source>VaList::try_into</source>
          <target state="translated">VaList::try_into</target>
        </trans-unit>
        <trans-unit id="00466fb65a3743839a76ad49fc45873af21ac5b5" translate="yes" xml:space="preserve">
          <source>VaList::type_id</source>
          <target state="translated">VaList::type_id</target>
        </trans-unit>
        <trans-unit id="c8012d496381feb2e9a104eb4daca8ce56213794" translate="yes" xml:space="preserve">
          <source>VaList::with_copy</source>
          <target state="translated">VaList::with_copy</target>
        </trans-unit>
        <trans-unit id="cda940b5210ef6c9c3a6f85409e7dfeabc36a58a" translate="yes" xml:space="preserve">
          <source>VaListImpl</source>
          <target state="translated">VaListImpl</target>
        </trans-unit>
        <trans-unit id="3ca16b32106de1b77aafe6c23653b3844b349ae2" translate="yes" xml:space="preserve">
          <source>VaListImpl::arg</source>
          <target state="translated">VaListImpl::arg</target>
        </trans-unit>
        <trans-unit id="f4173f47c545e4746400db7076f692fc8d564b6d" translate="yes" xml:space="preserve">
          <source>VaListImpl::as_va_list</source>
          <target state="translated">VaListImpl::as_va_list</target>
        </trans-unit>
        <trans-unit id="d4f4feeb2f49c83d41fa723579047ba246044ff7" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow</source>
          <target state="translated">VaListImpl::borrow</target>
        </trans-unit>
        <trans-unit id="12efac9fbc832f37c148aabeed63349a1f5126dd" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow_mut</source>
          <target state="translated">VaListImpl::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3f6404a6c3b18f2e79cb5750c66a38cba6e8a6c" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone</source>
          <target state="translated">VaListImpl::clone</target>
        </trans-unit>
        <trans-unit id="c95d8d0d76cdd92d3789595b002435cb8b173ba3" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_from</source>
          <target state="translated">VaListImpl::clone_from</target>
        </trans-unit>
        <trans-unit id="b7e21123ef8eeecb128af522573adb35c0d73ae7" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_into</source>
          <target state="translated">VaListImpl::clone_into</target>
        </trans-unit>
        <trans-unit id="8cc867e3d0ec9d7fb9edb3f064cbe3324e06efce" translate="yes" xml:space="preserve">
          <source>VaListImpl::drop</source>
          <target state="translated">VaListImpl::drop</target>
        </trans-unit>
        <trans-unit id="c61984180c1cbdf98ccebd337221adae24339007" translate="yes" xml:space="preserve">
          <source>VaListImpl::fmt</source>
          <target state="translated">VaListImpl::fmt</target>
        </trans-unit>
        <trans-unit id="5914da98901e40d1b7387569cc8698d5354eda2d" translate="yes" xml:space="preserve">
          <source>VaListImpl::from</source>
          <target state="translated">VaListImpl::from</target>
        </trans-unit>
        <trans-unit id="69d61c23655b32b3d7479d5b9b6a68338cf35be2" translate="yes" xml:space="preserve">
          <source>VaListImpl::into</source>
          <target state="translated">VaListImpl::into</target>
        </trans-unit>
        <trans-unit id="5bfd2cfab7029ef58c310f856c3da54cb4b8f66b" translate="yes" xml:space="preserve">
          <source>VaListImpl::to_owned</source>
          <target state="translated">VaListImpl::to_owned</target>
        </trans-unit>
        <trans-unit id="2a010a2b25dc2ad1ab26cc514156dc9263f6a636" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_from</source>
          <target state="translated">VaListImpl::try_from</target>
        </trans-unit>
        <trans-unit id="d69de8fd6c5d1bc620b9f394404b1608c17d118f" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_into</source>
          <target state="translated">VaListImpl::try_into</target>
        </trans-unit>
        <trans-unit id="d07770d2e23a78895791cb1ceaf87ef62f25d60c" translate="yes" xml:space="preserve">
          <source>VaListImpl::type_id</source>
          <target state="translated">VaListImpl::type_id</target>
        </trans-unit>
        <trans-unit id="d2fa0e7319df7d0644b9ea0a44af083d4b6e723c" translate="yes" xml:space="preserve">
          <source>VaListImpl::with_copy</source>
          <target state="translated">VaListImpl::with_copy</target>
        </trans-unit>
        <trans-unit id="4e28dc650ae01219c2816ac14486f89634c8fc55" translate="yes" xml:space="preserve">
          <source>VacantEntry</source>
          <target state="translated">VacantEntry</target>
        </trans-unit>
        <trans-unit id="c96052bd94ad047ad8849208c48bf71c8e89ef7c" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">宏定义中的有效模式语法与第18章中介绍的模式语法不同，因为宏模式是针对Rust代码结构而不是值进行匹配的。让我们看一下清单19-28中的模式含义。有关完整的宏模式语法，请参见&lt;a href=&quot;../reference/macros&quot;&gt;参考资料&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7af7dd6d571b7430a0f3a804a2823ff5e3b34175" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros-by-example&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">宏定义中的有效模式语法与第18章中介绍的模式语法不同，因为宏模式是针对Rust代码结构而不是值进行匹配的。让我们看一下清单19-28中的模式片段的含义；有关完整的宏模式语法，请参见&lt;a href=&quot;../reference/macros-by-example&quot;&gt;参考资料&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06e50fbff8c8b7744c52b295c7fbf72559544494" translate="yes" xml:space="preserve">
          <source>Valid raw pointers as defined above are not necessarily properly aligned (where &quot;proper&quot; alignment is defined by the pointee type, i.e., &lt;code&gt;*const T&lt;/code&gt; must be aligned to &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt;). However, most functions require their arguments to be properly aligned, and will explicitly state this requirement in their documentation. Notable exceptions to this are &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">上面定义的有效原始指针不一定正确对齐（其中&amp;ldquo;适当的&amp;rdquo;对齐是由pointee类型定义的，即 &lt;code&gt;*const T&lt;/code&gt; 必须与 &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 对齐）。但是，大多数函数要求其参数正确对齐，并将在其文档中明确说明此要求。值得注意的例外是&lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.write_unaligned&quot;&gt; &lt;code&gt;write_unaligned&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c48f78e987c312ef821adcc0d7ee75c56d9144ac" translate="yes" xml:space="preserve">
          <source>Validating References with Lifetimes</source>
          <target state="translated">用寿命验证引用</target>
        </trans-unit>
        <trans-unit id="9bbb454d5a41c8f26ec9fb9b367e97c6b19c2f83" translate="yes" xml:space="preserve">
          <source>Validating the Number of Threads in &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt;</source>
          <target state="translated">验证 &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt; 线程数</target>
        </trans-unit>
        <trans-unit id="b5528864ad5f1464447c6381f31faab679eb55d8" translate="yes" xml:space="preserve">
          <source>Validating the Request and Selectively Responding</source>
          <target state="translated">验证请求和有选择的响应</target>
        </trans-unit>
        <trans-unit id="c4d75c989017ceaea555b5cb2f965e9a31a0f2ae" translate="yes" xml:space="preserve">
          <source>Value being parsed is empty.</source>
          <target state="translated">被解析的值为空。</target>
        </trans-unit>
        <trans-unit id="202eac546e1cca5cc40fbd1aa3d448b11c2717ed" translate="yes" xml:space="preserve">
          <source>Value was Zero</source>
          <target state="translated">价值为零</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="0c9f5af2d57c101875a9c09b9e64f7ab67e3fee1" translate="yes" xml:space="preserve">
          <source>Values larger than the maximum integer value will saturate to the maximum value of the integer type.</source>
          <target state="translated">大于最大整数值的值将饱和到整数类型的最大值。</target>
        </trans-unit>
        <trans-unit id="1cb37a0444183e3bd07455b2f462b02a3823b4ce" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; types may be mutated through shared references (i.e. the common &lt;code&gt;&amp;amp;T&lt;/code&gt; type), whereas most Rust types can only be mutated through unique (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) references. We say that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.</source>
          <target state="translated">所述的值 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型可以通过共享引用被突变（即，共同 &lt;code&gt;&amp;amp;T&lt;/code&gt; 型），而大多数锈病类型只能通过独特的（被突变 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）的引用。我们说 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 提供了&amp;ldquo;内部可变性&amp;rdquo;，而典型的Rust类型则表现出&amp;ldquo;继承的可变性&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="df0b0235c50fdaa3c200fefa43bc29bd936a024f" translate="yes" xml:space="preserve">
          <source>Values of this type are constructed using a &lt;a href=&quot;../expressions/tuple-expr#tuple-expressions&quot;&gt;tuple expression&lt;/a&gt;. Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to. Tuple elements can be accessed by either a &lt;a href=&quot;../expressions/tuple-expr#tuple-indexing-expressions&quot;&gt;tuple index expression&lt;/a&gt; or &lt;a href=&quot;../patterns#tuple-patterns&quot;&gt;pattern matching&lt;/a&gt;.</source>
          <target state="translated">这种类型的值是使用&lt;a href=&quot;../expressions/tuple-expr#tuple-expressions&quot;&gt;元组表达式&lt;/a&gt;构造的。此外，如果没有其他有意义的值可用于计算，则各种表达式将产生单位值。元组元素可以通过&lt;a href=&quot;../expressions/tuple-expr#tuple-indexing-expressions&quot;&gt;元组索引表达式&lt;/a&gt;或&lt;a href=&quot;../patterns#tuple-patterns&quot;&gt;模式匹配&lt;/a&gt;来访问。</target>
        </trans-unit>
        <trans-unit id="4ead0c6d8884038da5a1c37b81bd9ecdfeb765f5" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;U&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;T&lt;/code&gt; 类型的值被强制为 &lt;code&gt;&amp;amp;U&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="dd64aa37983b87ea2f61bdac9618cf696e12dc47" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</source>
          <target state="translated">类型的值 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 被强制为类型的值 &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e8a037908d83b45e7c8a2c2c4fe0fb372c4e345" translate="yes" xml:space="preserve">
          <source>Values returned by the iterator are returned in ascending order:</source>
          <target state="translated">迭代器返回的值按升序返回。</target>
        </trans-unit>
        <trans-unit id="7d470a568e8e665e2abbc283ee00bd48e19164d9" translate="yes" xml:space="preserve">
          <source>Values smaller than the minimum integer value will saturate to the minimum value of the integer type.</source>
          <target state="translated">小于最小整数值的值将饱和到整数类型的最小值。</target>
        </trans-unit>
        <trans-unit id="7afb9932010efa26617ba00942998437043da478" translate="yes" xml:space="preserve">
          <source>ValuesMut</source>
          <target state="translated">ValuesMut</target>
        </trans-unit>
        <trans-unit id="6f7df0e9c5abd887cbbca9fb8a84f3706f71be4d" translate="yes" xml:space="preserve">
          <source>VarError</source>
          <target state="translated">VarError</target>
        </trans-unit>
        <trans-unit id="b2249943fec1979f3539ebcd42bc0163bc44ee0a" translate="yes" xml:space="preserve">
          <source>VarError::borrow</source>
          <target state="translated">VarError::borrow</target>
        </trans-unit>
        <trans-unit id="e76b4c157350bd5d1faf74dc1a04fc95858ad1b0" translate="yes" xml:space="preserve">
          <source>VarError::borrow_mut</source>
          <target state="translated">VarError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8102864035147256ef0e364c15593289f8d64dc2" translate="yes" xml:space="preserve">
          <source>VarError::cause</source>
          <target state="translated">VarError::cause</target>
        </trans-unit>
        <trans-unit id="7077379d5b4387ff8ef4d01332e0c9cb99aeba54" translate="yes" xml:space="preserve">
          <source>VarError::clone</source>
          <target state="translated">VarError::clone</target>
        </trans-unit>
        <trans-unit id="0632068939784835c82259892b18fa3851d349ae" translate="yes" xml:space="preserve">
          <source>VarError::clone_from</source>
          <target state="translated">VarError::clone_from</target>
        </trans-unit>
        <trans-unit id="3e4c81dcadc33c305fcb9909e431adbde92a23e1" translate="yes" xml:space="preserve">
          <source>VarError::clone_into</source>
          <target state="translated">VarError::clone_into</target>
        </trans-unit>
        <trans-unit id="ec42cb6e55e02863f7703ec026731824032ed4c6" translate="yes" xml:space="preserve">
          <source>VarError::description</source>
          <target state="translated">VarError::description</target>
        </trans-unit>
        <trans-unit id="8d65ad24989288d2260d520733e5b865bcae5729" translate="yes" xml:space="preserve">
          <source>VarError::eq</source>
          <target state="translated">VarError::eq</target>
        </trans-unit>
        <trans-unit id="467b0e136a5d88a16831d064cfef40627edbdee5" translate="yes" xml:space="preserve">
          <source>VarError::fmt</source>
          <target state="translated">VarError::fmt</target>
        </trans-unit>
        <trans-unit id="5122b46ea820b54b6d938c3fc817b38fbb3551ec" translate="yes" xml:space="preserve">
          <source>VarError::from</source>
          <target state="translated">VarError::from</target>
        </trans-unit>
        <trans-unit id="489e1a123c276c2da9ec69dea9020703001650ca" translate="yes" xml:space="preserve">
          <source>VarError::into</source>
          <target state="translated">VarError::into</target>
        </trans-unit>
        <trans-unit id="77f840cd95edf89f75e8cbd45132b08b456a0812" translate="yes" xml:space="preserve">
          <source>VarError::ne</source>
          <target state="translated">VarError::ne</target>
        </trans-unit>
        <trans-unit id="0c18e774293ad67a8f9a9531c4cd7c614981cf63" translate="yes" xml:space="preserve">
          <source>VarError::source</source>
          <target state="translated">VarError::source</target>
        </trans-unit>
        <trans-unit id="e8289e8f0efbef22ac2ef6d43d6c953e17d68e73" translate="yes" xml:space="preserve">
          <source>VarError::to_owned</source>
          <target state="translated">VarError::to_owned</target>
        </trans-unit>
        <trans-unit id="3b34bb1f1ce27eec8b875707ed1773dc9147c967" translate="yes" xml:space="preserve">
          <source>VarError::to_string</source>
          <target state="translated">VarError::to_string</target>
        </trans-unit>
        <trans-unit id="2d14c21b020fdc28d154a0e06cc4cefbc03f8bd7" translate="yes" xml:space="preserve">
          <source>VarError::try_from</source>
          <target state="translated">VarError::try_from</target>
        </trans-unit>
        <trans-unit id="20dfa7580a9574a0ffa43df49fcb51fd1edef1e7" translate="yes" xml:space="preserve">
          <source>VarError::try_into</source>
          <target state="translated">VarError::try_into</target>
        </trans-unit>
        <trans-unit id="67e6d907fb202086a0226ec13ebdeab6dee225b8" translate="yes" xml:space="preserve">
          <source>VarError::type_id</source>
          <target state="translated">VarError::type_id</target>
        </trans-unit>
        <trans-unit id="b280dc1f4f1b58422609af96e60af9910ffc1aac" translate="yes" xml:space="preserve">
          <source>Variable Scope</source>
          <target state="translated">可变范围</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="732411588a5167f463feab941a8f9ac01a5767df" translate="yes" xml:space="preserve">
          <source>Variables and Mutability</source>
          <target state="translated">变量和变异性</target>
        </trans-unit>
        <trans-unit id="3aa41db4c47f6adb669361c7bd5c456d22e65ea3" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration</source>
          <target state="translated">变量按声明的相反顺序删除</target>
        </trans-unit>
        <trans-unit id="be65562327a4b52bee54dc313d949d1238b35a3e" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration. Variables declared in the same pattern drop in an unspecified ordered.</source>
          <target state="translated">变量按声明的相反顺序掉落。在同一模式下声明的变量按不指定的顺序放弃。</target>
        </trans-unit>
        <trans-unit id="098937ab2cfb527e074d853750f7a28c47a33f35" translate="yes" xml:space="preserve">
          <source>Variables bound within the pattern are scoped to the match guard and the arm's expression. The &lt;a href=&quot;../patterns#binding-modes&quot;&gt;binding mode&lt;/a&gt; (move, copy, or reference) depends on the pattern.</source>
          <target state="translated">绑定在模式中的变量的范围仅限于比赛防护装置和手臂的表情。的&lt;a href=&quot;../patterns#binding-modes&quot;&gt;结合模式&lt;/a&gt;（移动，复制，或参考）取决于图案。</target>
        </trans-unit>
        <trans-unit id="3c4d82fabad7ffdf2edb09b215e05fb61c4a456f" translate="yes" xml:space="preserve">
          <source>Variables in Rust are immutable by default, and require the &lt;code&gt;mut&lt;/code&gt; keyword to be made mutable.</source>
          <target state="translated">默认情况下，Rust中的变量是不可变的，并且需要使 &lt;code&gt;mut&lt;/code&gt; 关键字可变。</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">变量函数</target>
        </trans-unit>
        <trans-unit id="09181b83bd980777906a8422efadb22af2c263db" translate="yes" xml:space="preserve">
          <source>Variadic parameters can only be specified with &lt;a href=&quot;../items/external-blocks&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; function types with the &lt;code&gt;&quot;C&quot;&lt;/code&gt; or &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; calling convention.</source>
          <target state="translated">可变参数只能使用带有 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; 调用约定的&lt;a href=&quot;../items/external-blocks&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt;函数类型指定。</target>
        </trans-unit>
        <trans-unit id="4c86f67a7083ae244751a61c00202e2c7bd69682" translate="yes" xml:space="preserve">
          <source>Variadic parameters have been used on a non-C ABI function.</source>
          <target state="translated">变量参数已用于非C ABI函数上。</target>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="8a62a01b810204975c3451044bb90c7a71ef1cde" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;'a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 的差异</target>
        </trans-unit>
        <trans-unit id="34a3731e86c04bcba14d808de4b083ba9ec18ab8" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的方差</target>
        </trans-unit>
        <trans-unit id="13ea9443937d9e6015e5a5cffcafae425d987b1a" translate="yes" xml:space="preserve">
          <source>Variance is a property that generic types have with respect to their arguments. A generic type's &lt;em&gt;variance&lt;/em&gt; in a parameter is how the subtyping of the parameter affects the subtyping of the type.</source>
          <target state="translated">差异是泛型类型对其参数具有的属性。泛型类型在参数中的&lt;em&gt;差异&lt;/em&gt;在于参数的子类型如何影响类型的子类型。</target>
        </trans-unit>
        <trans-unit id="9c74b0f6448f867bdf1be672d84dbe75d3a10d26" translate="yes" xml:space="preserve">
          <source>Variance of types is automatically determined as follows</source>
          <target state="translated">类型的差异自动确定如下</target>
        </trans-unit>
        <trans-unit id="59640c3e0b061bd7062f06a5f01816c4cfbcbe86" translate="yes" xml:space="preserve">
          <source>Variant visibility</source>
          <target state="translated">差异可见性</target>
        </trans-unit>
        <trans-unit id="1bc3d368f8ad61e91648458829240a7efefcd2c1" translate="yes" xml:space="preserve">
          <source>Variants</source>
          <target state="translated">Variants</target>
        </trans-unit>
        <trans-unit id="1cec834cdc1b08e2f3ed59d65a8026d0864fc5b4" translate="yes" xml:space="preserve">
          <source>Variants (Non-exhaustive)</source>
          <target state="translated">差异(非详尽)</target>
        </trans-unit>
        <trans-unit id="b3fbdc730db8eecbbf239ec3967489785ffcc13f" translate="yes" xml:space="preserve">
          <source>Various built-in attributes use different subsets of the meta item syntax to specify their inputs. The following grammar rules show some commonly used forms:</source>
          <target state="translated">各种内置属性使用元项语法的不同子集来指定它们的输入。下面的语法规则显示了一些常用的形式。</target>
        </trans-unit>
        <trans-unit id="18d5bf7e0fee25c311080dec74d574b65c4b0764" translate="yes" xml:space="preserve">
          <source>Various separators</source>
          <target state="translated">各种分离器</target>
        </trans-unit>
        <trans-unit id="d4251864c293c17029bfa74793ffa95136fcec6d" translate="yes" xml:space="preserve">
          <source>Various things in the standard library may implement one or more of the three, where appropriate.</source>
          <target state="translated">标准库中的各种事物可以在适当的情况下实现三者中的一种或多种。</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="1c47de6b16a76ec820d60a85839ecc1cbf5e4457" translate="yes" xml:space="preserve">
          <source>Vars::all</source>
          <target state="translated">Vars::all</target>
        </trans-unit>
        <trans-unit id="b398eaf22edd2ef7aed1c4f858c613d773d5dd59" translate="yes" xml:space="preserve">
          <source>Vars::any</source>
          <target state="translated">Vars::any</target>
        </trans-unit>
        <trans-unit id="80450fe90037366e6900e0207a00a0ff5399c353" translate="yes" xml:space="preserve">
          <source>Vars::borrow</source>
          <target state="translated">Vars::borrow</target>
        </trans-unit>
        <trans-unit id="21a23559330914e11672cfb421023160c25aceab" translate="yes" xml:space="preserve">
          <source>Vars::borrow_mut</source>
          <target state="translated">Vars::borrow_mut</target>
        </trans-unit>
        <trans-unit id="781b07302eb0ba1fcc3cf935ec319d0ab20b1f65" translate="yes" xml:space="preserve">
          <source>Vars::by_ref</source>
          <target state="translated">Vars::by_ref</target>
        </trans-unit>
        <trans-unit id="9951d905bdeb385924f734897456db259730b15b" translate="yes" xml:space="preserve">
          <source>Vars::chain</source>
          <target state="translated">Vars::chain</target>
        </trans-unit>
        <trans-unit id="b7b0b3926db3e290b2a0c4b07b1ac73606da0d40" translate="yes" xml:space="preserve">
          <source>Vars::cloned</source>
          <target state="translated">Vars::cloned</target>
        </trans-unit>
        <trans-unit id="af8d7407e3b763504a144307a7303f5603d6229f" translate="yes" xml:space="preserve">
          <source>Vars::cmp</source>
          <target state="translated">Vars::cmp</target>
        </trans-unit>
        <trans-unit id="5a55a34bc63ca6a0899a5379932cae28b637a085" translate="yes" xml:space="preserve">
          <source>Vars::collect</source>
          <target state="translated">Vars::collect</target>
        </trans-unit>
        <trans-unit id="4eb06a4620fc01558a8bd2f2bf2b0ca80dc89a4b" translate="yes" xml:space="preserve">
          <source>Vars::copied</source>
          <target state="translated">Vars::copied</target>
        </trans-unit>
        <trans-unit id="bfb7648d61e3607bf3caff921735ae88f75f92ef" translate="yes" xml:space="preserve">
          <source>Vars::count</source>
          <target state="translated">Vars::count</target>
        </trans-unit>
        <trans-unit id="f6b7790787f62ef8a6724b8647c199f3e9fc0e6f" translate="yes" xml:space="preserve">
          <source>Vars::cycle</source>
          <target state="translated">Vars::cycle</target>
        </trans-unit>
        <trans-unit id="c728f5f416f691b01f40cd87af7f9137219eb03f" translate="yes" xml:space="preserve">
          <source>Vars::enumerate</source>
          <target state="translated">Vars::enumerate</target>
        </trans-unit>
        <trans-unit id="0a270124e47b9e2828a920edca2e2e533038569f" translate="yes" xml:space="preserve">
          <source>Vars::eq</source>
          <target state="translated">Vars::eq</target>
        </trans-unit>
        <trans-unit id="7080a20dc333e44166a8558123ba98d85eb6ded3" translate="yes" xml:space="preserve">
          <source>Vars::filter</source>
          <target state="translated">Vars::filter</target>
        </trans-unit>
        <trans-unit id="d41dd539031344f9e7e7bb6171c556fc42ef1957" translate="yes" xml:space="preserve">
          <source>Vars::filter_map</source>
          <target state="translated">Vars::filter_map</target>
        </trans-unit>
        <trans-unit id="78b0b6d5abfd7026b83ef665a619f46c392d69ed" translate="yes" xml:space="preserve">
          <source>Vars::find</source>
          <target state="translated">Vars::find</target>
        </trans-unit>
        <trans-unit id="7044c163171ec6f76f077a2bec8324df3677eec1" translate="yes" xml:space="preserve">
          <source>Vars::find_map</source>
          <target state="translated">Vars::find_map</target>
        </trans-unit>
        <trans-unit id="3b73b80a39e593c77029fbb50e77a9c267cde8cd" translate="yes" xml:space="preserve">
          <source>Vars::flat_map</source>
          <target state="translated">Vars::flat_map</target>
        </trans-unit>
        <trans-unit id="804f30eccc2a282312bcb332187a328e639337a6" translate="yes" xml:space="preserve">
          <source>Vars::flatten</source>
          <target state="translated">Vars::flatten</target>
        </trans-unit>
        <trans-unit id="4534d320518c99c9f5ec34ac48943387ea6be6eb" translate="yes" xml:space="preserve">
          <source>Vars::fmt</source>
          <target state="translated">Vars::fmt</target>
        </trans-unit>
        <trans-unit id="dcbe8ef4d0dae4b0a34ef3131b548dcabe7f720d" translate="yes" xml:space="preserve">
          <source>Vars::fold</source>
          <target state="translated">Vars::fold</target>
        </trans-unit>
        <trans-unit id="c0ce61b83b4e9c664534b8dfbab835e7e489b655" translate="yes" xml:space="preserve">
          <source>Vars::for_each</source>
          <target state="translated">Vars::for_each</target>
        </trans-unit>
        <trans-unit id="5dd1e805808b1f032c733423cbf4ac8a4c5a6981" translate="yes" xml:space="preserve">
          <source>Vars::from</source>
          <target state="translated">Vars::from</target>
        </trans-unit>
        <trans-unit id="af8c15b94b4468f337a1725be34d5554460f0a04" translate="yes" xml:space="preserve">
          <source>Vars::fuse</source>
          <target state="translated">Vars::fuse</target>
        </trans-unit>
        <trans-unit id="51bb1a81fecead1d604391ae02d739a62889b8ac" translate="yes" xml:space="preserve">
          <source>Vars::ge</source>
          <target state="translated">Vars::ge</target>
        </trans-unit>
        <trans-unit id="5b570a759e39ddbf689c5b76c7875f777d223503" translate="yes" xml:space="preserve">
          <source>Vars::gt</source>
          <target state="translated">Vars::gt</target>
        </trans-unit>
        <trans-unit id="e0b5b9d9e5ab4d21c95b05a37ba730388417d6b6" translate="yes" xml:space="preserve">
          <source>Vars::inspect</source>
          <target state="translated">Vars::inspect</target>
        </trans-unit>
        <trans-unit id="b8b6b4992b9eef91d9d506454c1498ee57011e6a" translate="yes" xml:space="preserve">
          <source>Vars::into</source>
          <target state="translated">Vars::into</target>
        </trans-unit>
        <trans-unit id="c48afb05fd046801df4e6edbf9f840dd304b60e1" translate="yes" xml:space="preserve">
          <source>Vars::into_iter</source>
          <target state="translated">Vars::into_iter</target>
        </trans-unit>
        <trans-unit id="e0ccc72484b281423161007f22d8a9293e1ba907" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted</source>
          <target state="translated">Vars::is_sorted</target>
        </trans-unit>
        <trans-unit id="e191fd1f8c7ce00d777cb35f9c5c82504bbe7781" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by</source>
          <target state="translated">Vars::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="eb9ca2ba30c83815b850a09d3feb972dfdc158e2" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by_key</source>
          <target state="translated">Vars::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6141318cc3ccabd5ae05e4611a7c5181f6046637" translate="yes" xml:space="preserve">
          <source>Vars::last</source>
          <target state="translated">Vars::last</target>
        </trans-unit>
        <trans-unit id="eecce1750e26f1ae1d749a4bae2b92eade287d53" translate="yes" xml:space="preserve">
          <source>Vars::le</source>
          <target state="translated">Vars::le</target>
        </trans-unit>
        <trans-unit id="b0904ac784f88af599fae6febadea78be6bd22be" translate="yes" xml:space="preserve">
          <source>Vars::lt</source>
          <target state="translated">Vars::lt</target>
        </trans-unit>
        <trans-unit id="aed51bf24598897e8d0ea447d651f3de39248cdc" translate="yes" xml:space="preserve">
          <source>Vars::map</source>
          <target state="translated">Vars::map</target>
        </trans-unit>
        <trans-unit id="8ab4e4308d5f56473c748138761d5bb14402ca33" translate="yes" xml:space="preserve">
          <source>Vars::max</source>
          <target state="translated">Vars::max</target>
        </trans-unit>
        <trans-unit id="5fbff539f6d31b21ce7158f6c6c1edd461357314" translate="yes" xml:space="preserve">
          <source>Vars::max_by</source>
          <target state="translated">Vars::max_by</target>
        </trans-unit>
        <trans-unit id="09ad51f2df0437fa8ff5bd6b68362c0cd8c5cfca" translate="yes" xml:space="preserve">
          <source>Vars::max_by_key</source>
          <target state="translated">Vars::max_by_key</target>
        </trans-unit>
        <trans-unit id="0ea5634589a7714b3ce13a9b994859ddc43c1472" translate="yes" xml:space="preserve">
          <source>Vars::min</source>
          <target state="translated">Vars::min</target>
        </trans-unit>
        <trans-unit id="84ccbe5bb178770383b19523a56c94a1a328c579" translate="yes" xml:space="preserve">
          <source>Vars::min_by</source>
          <target state="translated">Vars::min_by</target>
        </trans-unit>
        <trans-unit id="ef0e80e93b2480afa1eef5654b1d44253416e329" translate="yes" xml:space="preserve">
          <source>Vars::min_by_key</source>
          <target state="translated">Vars::min_by_key</target>
        </trans-unit>
        <trans-unit id="ed5f11b0702d02069bbdec987cd8231701e2f83d" translate="yes" xml:space="preserve">
          <source>Vars::ne</source>
          <target state="translated">Vars::ne</target>
        </trans-unit>
        <trans-unit id="5507ff5e66b6d746ac06bacbd6adfad687952f9d" translate="yes" xml:space="preserve">
          <source>Vars::next</source>
          <target state="translated">Vars::next</target>
        </trans-unit>
        <trans-unit id="aec94ecfda5dc5e8fd928e072a549d3135f6ad84" translate="yes" xml:space="preserve">
          <source>Vars::nth</source>
          <target state="translated">Vars::nth</target>
        </trans-unit>
        <trans-unit id="7b9faff88b13bea2403bdb806528b1b03e775923" translate="yes" xml:space="preserve">
          <source>Vars::partial_cmp</source>
          <target state="translated">Vars::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2c2aef1b9bc3af83507c48a9bec747732d905de4" translate="yes" xml:space="preserve">
          <source>Vars::partition</source>
          <target state="translated">Vars::partition</target>
        </trans-unit>
        <trans-unit id="86900414ba1e745a10275dfdac62d2d9717049f6" translate="yes" xml:space="preserve">
          <source>Vars::peekable</source>
          <target state="translated">Vars::peekable</target>
        </trans-unit>
        <trans-unit id="20b949f960f581abec205874631185ffb7bb5fa1" translate="yes" xml:space="preserve">
          <source>Vars::position</source>
          <target state="translated">Vars::position</target>
        </trans-unit>
        <trans-unit id="8f8bd9d5815bdec99dfe7927fb90687bd92fab9b" translate="yes" xml:space="preserve">
          <source>Vars::product</source>
          <target state="translated">Vars::product</target>
        </trans-unit>
        <trans-unit id="9f0f47f9e4c4906312f7cde7ba18939a86f5931f" translate="yes" xml:space="preserve">
          <source>Vars::rev</source>
          <target state="translated">Vars::rev</target>
        </trans-unit>
        <trans-unit id="4a55d6ece90a2e102e6248bacf85b746657dbf67" translate="yes" xml:space="preserve">
          <source>Vars::rposition</source>
          <target state="translated">Vars::rposition</target>
        </trans-unit>
        <trans-unit id="ef63b4a7e167047c985114917f57fd0d737537fe" translate="yes" xml:space="preserve">
          <source>Vars::scan</source>
          <target state="translated">Vars::scan</target>
        </trans-unit>
        <trans-unit id="3551c9199efbcf81653d617970dabf0cd9ed3d99" translate="yes" xml:space="preserve">
          <source>Vars::size_hint</source>
          <target state="translated">Vars::size_hint</target>
        </trans-unit>
        <trans-unit id="7943d6f84fa998209693b43046c7975775eb51cd" translate="yes" xml:space="preserve">
          <source>Vars::skip</source>
          <target state="translated">Vars::skip</target>
        </trans-unit>
        <trans-unit id="2d1337e0ea678c9a71cefd99de6b48cd2e8b1203" translate="yes" xml:space="preserve">
          <source>Vars::skip_while</source>
          <target state="translated">Vars::skip_while</target>
        </trans-unit>
        <trans-unit id="9ad1eaaaf974f3fa2bff01f61e628ff1dd93b8e7" translate="yes" xml:space="preserve">
          <source>Vars::step_by</source>
          <target state="translated">Vars::step_by</target>
        </trans-unit>
        <trans-unit id="3cfd4ab54ebdd5fc54ce1f5c5cd82d3493150512" translate="yes" xml:space="preserve">
          <source>Vars::sum</source>
          <target state="translated">Vars::sum</target>
        </trans-unit>
        <trans-unit id="b11b3042c11657cd454ca8548f85ff8aeb32a4fd" translate="yes" xml:space="preserve">
          <source>Vars::take</source>
          <target state="translated">Vars::take</target>
        </trans-unit>
        <trans-unit id="70f8ea67196cc23888fa00b81267afd9a27d3c32" translate="yes" xml:space="preserve">
          <source>Vars::take_while</source>
          <target state="translated">Vars::take_while</target>
        </trans-unit>
        <trans-unit id="288b6c944d7368cdf54e313b28e14e5725efaa9b" translate="yes" xml:space="preserve">
          <source>Vars::try_fold</source>
          <target state="translated">Vars::try_fold</target>
        </trans-unit>
        <trans-unit id="cf043e48c60478e52e24f6c062f28fb96fba6f9d" translate="yes" xml:space="preserve">
          <source>Vars::try_for_each</source>
          <target state="translated">Vars::try_for_each</target>
        </trans-unit>
        <trans-unit id="b4fd24921ed57ce691083c1322eaf0856a89e518" translate="yes" xml:space="preserve">
          <source>Vars::try_from</source>
          <target state="translated">Vars::try_from</target>
        </trans-unit>
        <trans-unit id="1daadb045ef158df87f592275c11205ecf5af378" translate="yes" xml:space="preserve">
          <source>Vars::try_into</source>
          <target state="translated">Vars::try_into</target>
        </trans-unit>
        <trans-unit id="2e2cb28cd54a254643d5c8595fc8be18813e9b3a" translate="yes" xml:space="preserve">
          <source>Vars::type_id</source>
          <target state="translated">Vars::type_id</target>
        </trans-unit>
        <trans-unit id="6b38c485c26bfb440ab87bcbfba50961f6cb40d6" translate="yes" xml:space="preserve">
          <source>Vars::unzip</source>
          <target state="translated">Vars::unzip</target>
        </trans-unit>
        <trans-unit id="bbe99efeecd60ccb331cf47e045d9299f8d35e6e" translate="yes" xml:space="preserve">
          <source>Vars::zip</source>
          <target state="translated">Vars::zip</target>
        </trans-unit>
        <trans-unit id="b3dd49122e36d39473d927caf75a7a1efe1ad95f" translate="yes" xml:space="preserve">
          <source>VarsOs</source>
          <target state="translated">VarsOs</target>
        </trans-unit>
        <trans-unit id="0be42997f9c0fa87236d029096ab1f10b322e7b9" translate="yes" xml:space="preserve">
          <source>VarsOs::all</source>
          <target state="translated">VarsOs::all</target>
        </trans-unit>
        <trans-unit id="2f3479491bf53557e01f4e76c184381ed836098b" translate="yes" xml:space="preserve">
          <source>VarsOs::any</source>
          <target state="translated">VarsOs::any</target>
        </trans-unit>
        <trans-unit id="434053241a0ce77b4a57a19b617f9cd0e0d5e814" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow</source>
          <target state="translated">VarsOs::borrow</target>
        </trans-unit>
        <trans-unit id="2d141f266e89d234f18a990d5d607d1646f48aee" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow_mut</source>
          <target state="translated">VarsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="425cc86c692b838ef921c23811c4e3302d1bdfc4" translate="yes" xml:space="preserve">
          <source>VarsOs::by_ref</source>
          <target state="translated">VarsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="2ea472498ef341c6fb344b9d8ee413b4e6235be7" translate="yes" xml:space="preserve">
          <source>VarsOs::chain</source>
          <target state="translated">VarsOs::chain</target>
        </trans-unit>
        <trans-unit id="a8c6d8c806adad2da3dacb9238da96bf328655bd" translate="yes" xml:space="preserve">
          <source>VarsOs::cloned</source>
          <target state="translated">VarsOs::cloned</target>
        </trans-unit>
        <trans-unit id="fda36a1ed84216068b1296731249e671c956362c" translate="yes" xml:space="preserve">
          <source>VarsOs::cmp</source>
          <target state="translated">VarsOs::cmp</target>
        </trans-unit>
        <trans-unit id="2db35bab4983e6e4d87a02ad263efa15ddb43d0d" translate="yes" xml:space="preserve">
          <source>VarsOs::collect</source>
          <target state="translated">VarsOs::collect</target>
        </trans-unit>
        <trans-unit id="e1850e83c9e256bacb297e01d179d1197cc0db06" translate="yes" xml:space="preserve">
          <source>VarsOs::copied</source>
          <target state="translated">VarsOs::copied</target>
        </trans-unit>
        <trans-unit id="5c6630d2555a45d97d28a5536655aff9f9e9d3b8" translate="yes" xml:space="preserve">
          <source>VarsOs::count</source>
          <target state="translated">VarsOs::count</target>
        </trans-unit>
        <trans-unit id="f0ac502bdac4e93b09bdc50516564d5e56dc7727" translate="yes" xml:space="preserve">
          <source>VarsOs::cycle</source>
          <target state="translated">VarsOs::cycle</target>
        </trans-unit>
        <trans-unit id="a5e0728a5c9381105cc966f06f76ab6ed5f65903" translate="yes" xml:space="preserve">
          <source>VarsOs::enumerate</source>
          <target state="translated">VarsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="0d4efb3a8d96184d450211631b5b79b1a60ab789" translate="yes" xml:space="preserve">
          <source>VarsOs::eq</source>
          <target state="translated">VarsOs::eq</target>
        </trans-unit>
        <trans-unit id="31db361add8338260d55916657c39337f09b86d7" translate="yes" xml:space="preserve">
          <source>VarsOs::filter</source>
          <target state="translated">VarsOs::filter</target>
        </trans-unit>
        <trans-unit id="0d0a62d2dca8a37393e2c92243786aaf41313690" translate="yes" xml:space="preserve">
          <source>VarsOs::filter_map</source>
          <target state="translated">VarsOs::filter_map</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
