<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="fe6abd0552b2b40662057338eb474072bfd467ab" translate="yes" xml:space="preserve">
          <source>It can be implemented very efficiently on many platforms.</source>
          <target state="translated">它可以在很多平台上非常有效地实现。</target>
        </trans-unit>
        <trans-unit id="1742a20f108d58ed46034272510180c651908ea6" translate="yes" xml:space="preserve">
          <source>It can be more efficient to read the contents of a file with a buffered &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;er. This can be accomplished with &lt;a href=&quot;../io/struct.bufreader&quot;&gt;&lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用缓冲的&lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;文件的内容可能会更有效。这可以通过&lt;a href=&quot;../io/struct.bufreader&quot;&gt; &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="66395a368b8513422e9376d626f808ed1f8bf32e" translate="yes" xml:space="preserve">
          <source>It can be used to drop &lt;a href=&quot;../pin/index&quot;&gt;pinned&lt;/a&gt; data when &lt;code&gt;T&lt;/code&gt; is not &lt;code&gt;repr(packed)&lt;/code&gt; (pinned data must not be moved before it is dropped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a115494bb139f55de5b0b3f70529477957a7f61" translate="yes" xml:space="preserve">
          <source>It can occur, for example, when giving ill-formed UTF-8 bytes to &lt;a href=&quot;../string/struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;String::from_utf8_lossy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">例如，当给&lt;a href=&quot;../string/struct.string#method.from_utf8_lossy&quot;&gt; &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; &lt;/a&gt; UTF-8字节时，可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="99e2bcf85c866fbb510069805b1b10aa2dbd5078" translate="yes" xml:space="preserve">
          <source>It can occur, for example, when giving ill-formed UTF-8 bytes to &lt;a href=&quot;string/struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;String::from_utf8_lossy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865ab19a4feb80b70039c9bd315636afdebb41d4" translate="yes" xml:space="preserve">
          <source>It compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fe0776828801d6e4d2d0000fdfe545e88338bd" translate="yes" xml:space="preserve">
          <source>It consists of a data pointer and a &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot;&gt;virtual function pointer table (vtable)&lt;/a&gt; that customizes the behavior of the &lt;code&gt;RawWaker&lt;/code&gt;.</source>
          <target state="translated">它由一个数据指针和一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot;&gt;虚拟函数指针表（vtable）组成&lt;/a&gt;，该表可自定义 &lt;code&gt;RawWaker&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="304308a190fdf4f0822058e40b620979e500ac31" translate="yes" xml:space="preserve">
          <source>It could also be that the browser is trying to connect to the server multiple times because the server isn&amp;rsquo;t responding with any data. When &lt;code&gt;stream&lt;/code&gt; goes out of scope and is dropped at the end of the loop, the connection is closed as part of the &lt;code&gt;drop&lt;/code&gt; implementation. Browsers sometimes deal with closed connections by retrying, because the problem might be temporary. The important factor is that we&amp;rsquo;ve successfully gotten a handle to a TCP connection!</source>
          <target state="translated">也可能是浏览器试图多次连接到服务器，因为服务器没有响应任何数据。当 &lt;code&gt;stream&lt;/code&gt; 超出范围并在循环结束时被丢弃时，连接将作为 &lt;code&gt;drop&lt;/code&gt; 实现的一部分关闭。浏览器有时会通过重试来处理关闭的连接，因为问题可能是暂时的。重要的因素是我们已经成功掌握了TCP连接！</target>
        </trans-unit>
        <trans-unit id="ade427f6a9f3a1335d386816dffbf2fdc2034717" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; give you:</source>
          <target state="translated">它并&lt;em&gt;没有&lt;/em&gt;给你：</target>
        </trans-unit>
        <trans-unit id="794a6ddebef5a3a25c88c1d2d823ee0600bddf9c" translate="yes" xml:space="preserve">
          <source>It does not have an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation, so you can't use it in a &lt;code&gt;for&lt;/code&gt; loop directly. This won't compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb73bdc252e7f6e26b2827c67cb797c04a45c79" translate="yes" xml:space="preserve">
          <source>It does not have an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation, so you can't use it in a &lt;code&gt;for&lt;/code&gt; loop directly. This won't compile:</source>
          <target state="translated">它没有&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;实现，因此您不能直接在 &lt;code&gt;for&lt;/code&gt; 循环中使用它。这不会编译：</target>
        </trans-unit>
        <trans-unit id="74bec73f805593fee91ebe017ac47c318ef63b70" translate="yes" xml:space="preserve">
          <source>It does pass! Let&amp;rsquo;s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:</source>
          <target state="translated">它确实通过了！让我们添加另一个测试，这次断言较小的矩形不能容纳较大的矩形：</target>
        </trans-unit>
        <trans-unit id="e2bf564d4c76feec85879b21bc874b8175ee437c" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t matter if we mix up width and height for the area calculation, but if we want to draw the rectangle on the screen, it would matter! We would have to keep in mind that &lt;code&gt;width&lt;/code&gt; is the tuple index &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is the tuple index &lt;code&gt;1&lt;/code&gt;. If someone else worked on this code, they would have to figure this out and keep it in mind as well. It would be easy to forget or mix up these values and cause errors, because we haven&amp;rsquo;t conveyed the meaning of our data in our code.</source>
          <target state="translated">混合宽度和高度以进行面积计算并不重要，但是如果我们想在屏幕上绘制矩形，那将很重要！我们必须记住， &lt;code&gt;width&lt;/code&gt; 是元组索引 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;height&lt;/code&gt; 是元组索引 &lt;code&gt;1&lt;/code&gt; 。如果其他人正在编写此代码，则他们必须弄清楚这一点并牢记在心。忘记或混淆这些值并导致错误很容易，因为我们没有在代码中传达数据的含义。</target>
        </trans-unit>
        <trans-unit id="d52b4ba1c15e44e888e3928ea17d62d2f1924cb8" translate="yes" xml:space="preserve">
          <source>It exposes more ways to deal with platform-specific strings (&lt;code&gt;OsStr&lt;/code&gt;, &lt;code&gt;OsString&lt;/code&gt;), allows to set permissions more granularly, extract low-level file descriptors from files and sockets, and has platform-specific helpers for spawning processes.</source>
          <target state="translated">它提供了更多方法来处理特定于平台的字符串（ &lt;code&gt;OsStr&lt;/code&gt; ， &lt;code&gt;OsString&lt;/code&gt; ），允许更精细地设置权限，从文件和套接字中提取低级文件描述符，并具有用于生成程序的特定于平台的助手。</target>
        </trans-unit>
        <trans-unit id="7b00fd960002cfd9909fc9bce365f904914da1b7" translate="yes" xml:space="preserve">
          <source>It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file. Git files won&amp;rsquo;t be generated if you run &lt;code&gt;cargo new&lt;/code&gt; within an existing Git repository; you can override this behavior by using &lt;code&gt;cargo new --vcs=git&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11abb8c04f2668a58f566442bd95936d3058b5af" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; to call a function that is compiled with a feature that is not supported on the current platform the code is running on.</source>
          <target state="translated">调用使用当前代码在其上的当前平台不支持的功能编译的函数是&lt;a href=&quot;../behavior-considered-undefined&quot;&gt;未定义的行为&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14b8fe5823c3e0b4ead46dab65d150ba97815143" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;unsafe&lt;/code&gt; to access a static item declared in an extern block, whether or not it's mutable.</source>
          <target state="translated">不管是否可变，访问在extern块中声明的静态项目都是 &lt;code&gt;unsafe&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="789a56605a4c0fc94024c04229e1954360379606" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;required&lt;/em&gt; to use &lt;code&gt;drop_in_place&lt;/code&gt; to drop unsized types like trait objects, because they can't be read out onto the stack and dropped normally.</source>
          <target state="translated">它&lt;em&gt;要求&lt;/em&gt;在使用 &lt;code&gt;drop_in_place&lt;/code&gt; 下降未分级的类型，如特质的对象，因为它们不能被读出到堆栈和正常下降。</target>
        </trans-unit>
        <trans-unit id="122d47e267f58dbf245d83bbd151c9d835be4c42" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; considered an error if the entire buffer could not be written to this writer.</source>
          <target state="translated">如果&lt;strong&gt;无法&lt;/strong&gt;将整个缓冲区写入此写入器，则不会将其视为错误。</target>
        </trans-unit>
        <trans-unit id="bf8bf34a5d274735d5f3f6b75aeb9079259905f3" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; recommended to use this function for a general try/catch mechanism. The &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type is more appropriate to use for functions that can fail on a regular basis. Additionally, this function is not guaranteed to catch all panics, see the &quot;Notes&quot; section below.</source>
          <target state="translated">这是&lt;strong&gt;不&lt;/strong&gt;推荐使用此功能对于一般的try / catch机制。该&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;类型更适合用于可定期失败的功能。此外，不能保证此功能可以捕获所有紧急情况，请参阅下面的&amp;ldquo;注意&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b1a810a5051116223295807560408c5af68cd37c" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; recommended to use this function for a general try/catch mechanism. The &lt;a href=&quot;../thread/type.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type is more appropriate to use for functions that can fail on a regular basis. Additionally, this function is not guaranteed to catch all panics, see the &quot;Notes&quot; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44c0918ab46b70725b0bcd2ecf83b8a768d4eb5" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's hash, as determined by the &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">以某种方式修改键是一种逻辑错误，即键的哈希值（由&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性确定）或相等性（由&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;特性确定）在映射中时会发生变化。通常这只能通过&lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="d5c36c17020650b28936fe4d1b2ab87233144be8" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's hash, as determined by the &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">以某种方式修改键是一种逻辑错误，即键的哈希值（由&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性确定）或相等性（由&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;特性确定）在映射中时会发生变化。通常这只能通过&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="46331dafb0153e4395d3531f25654f92dc26340b" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's ordering relative to any other key, as determined by the &lt;a href=&quot;../../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">以某种方式修改密钥是一种逻辑错误，即，密钥相对于任何其他密钥的顺序（由&lt;a href=&quot;../../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt;特性决定）在映射中时会发生变化。通常这只能通过&lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="85493dfb2b8e297a25b008cf35e5fe74ede0c214" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's ordering relative to any other key, as determined by the &lt;a href=&quot;../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">以某种方式修改密钥是一种逻辑错误，即，密钥相对于任何其他密钥的顺序（由&lt;a href=&quot;../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt;特性决定）在映射中时会发生变化。通常这只能通过&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="3a06bdad2097a07f5094016d13cc933d3f72af47" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's hash, as determined by the &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">以某种方式修改项目是一种逻辑错误，即该项目的哈希值（由&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性决定）或其相等性（由&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;特性决定）会在其位于集合中时发生变化。通常这只能通过&lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="d42ef3a74bef90b249465c06d2f032ccefb653f1" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's hash, as determined by the &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">以某种方式修改项目是一种逻辑错误，即该项目的哈希值（由&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性决定）或其相等性（由&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;特性决定）会在其位于集合中时发生变化。通常这只能通过&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="3ab5c67b79a448ca7bc9aba52ab29aac6f49d326" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;a href=&quot;../../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">逻辑上的错误是，要对商品进行修改，使该商品相对于任何其他商品的排序（由&lt;a href=&quot;../../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt;特性决定）在设置时会发生变化。通常这只能通过&lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="81558e504ca17a10e655e3f35b43a6c2e19151af" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;a href=&quot;../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">逻辑上的错误是，要对商品进行修改，使该商品相对于任何其他商品的排序（由&lt;a href=&quot;../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt;特性决定）在设置时会发生变化。通常这只能通过&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="5e476b6f2887551b48a3be2ee9ea6d582ce86836" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;code&gt;Ord&lt;/code&gt; trait, changes while it is in the heap. This is normally only possible through &lt;code&gt;Cell&lt;/code&gt;, &lt;code&gt;RefCell&lt;/code&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">以某种方式修改项目是一种逻辑错误，即该项目相对于任何其他项目的排序（由 &lt;code&gt;Ord&lt;/code&gt; 特性决定）在堆中时会发生变化。通常这只能通过 &lt;code&gt;Cell&lt;/code&gt; ， &lt;code&gt;RefCell&lt;/code&gt; ，全局状态，I / O或不安全的代码来实现。</target>
        </trans-unit>
        <trans-unit id="a1fecc95182812f5ebb362d1bac59ac94dc2f98d" translate="yes" xml:space="preserve">
          <source>It is a multiple of the alignment, including zero. The size can change depending on compiler version (as new optimizations are made) and target platform (similar to how &lt;code&gt;usize&lt;/code&gt; varies per-platform).</source>
          <target state="translated">它是对齐方式的倍数，包括零。大小可以根据编译器版本（随着进行新的优化）和目标平台（类似于每个平台的使用 &lt;code&gt;usize&lt;/code&gt; 而变化）而变化。</target>
        </trans-unit>
        <trans-unit id="78d00f7fd123a3c3fdf75cbae3233ae2e6e3470e" translate="yes" xml:space="preserve">
          <source>It is allowed for the strong count to be 0 at the time of calling this. Nevertheless, this takes ownership of one weak reference currently represented as a raw pointer (the weak count is not modified by this operation) and therefore it must be paired with a previous call to &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f9d3e3312ad57e5a6d3bcdd50a937a22f832b6" translate="yes" xml:space="preserve">
          <source>It is also an error to have an unspecified discriminant where the previous discriminant is the maximum value for the size of the discriminant.</source>
          <target state="translated">如果有一个未指定的判别器,前一个判别器是判别器大小的最大值,这也是一个错误。</target>
        </trans-unit>
        <trans-unit id="2aaa72db942d7c7ea290053204f195dee9198e63" translate="yes" xml:space="preserve">
          <source>It is also possible that immediately after &lt;code&gt;is_completed&lt;/code&gt; returns false, some other thread finishes executing &lt;code&gt;call_once&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;is_completed&lt;/code&gt; 返回false之后，其他线程也有可能立即完成执行 &lt;code&gt;call_once&lt;/code&gt; 的可能。</target>
        </trans-unit>
        <trans-unit id="19ceccce9e9543f68e6cf0b82b34ef37c7f04824" translate="yes" xml:space="preserve">
          <source>It is also possible to manually transmute:</source>
          <target state="translated">也可以手动转生。</target>
        </trans-unit>
        <trans-unit id="b9152c587c216123563f72b60e624fb7b37150c7" translate="yes" xml:space="preserve">
          <source>It is also possible to overload most operators for your own type by implementing the &lt;code&gt;[OP]Assign&lt;/code&gt; traits from &lt;code&gt;std::ops&lt;/code&gt;.</source>
          <target state="translated">通过实现 &lt;code&gt;std::ops&lt;/code&gt; 的 &lt;code&gt;[OP]Assign&lt;/code&gt; 特征，也可以为您自己的类型重载大多数运算符。</target>
        </trans-unit>
        <trans-unit id="9c720012a3e805c9d62f2435d313e2b4c97a82fa" translate="yes" xml:space="preserve">
          <source>It is also possible to overload most operators for your own type by implementing traits from &lt;code&gt;std::ops&lt;/code&gt;.</source>
          <target state="translated">通过实现 &lt;code&gt;std::ops&lt;/code&gt; 特征，也可以为您自己的类型重载大多数运算符。</target>
        </trans-unit>
        <trans-unit id="665d59482618a683a851550ec2845d9aceb97fe9" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;code&gt;super&lt;/code&gt; multiple times: &lt;code&gt;super::super::foo&lt;/code&gt;, going up the ancestor chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a0c387e81a8235a99c7d165954f2002b18f388" translate="yes" xml:space="preserve">
          <source>It is an error for &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enumerations&lt;/a&gt; to have a primitive representation.</source>
          <target state="translated">&lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;零变量枚举&lt;/a&gt;具有原始表示形式是一个错误。</target>
        </trans-unit>
        <trans-unit id="8b8784e54718e2a6d91bae7b9a9deae29e0d7cb7" translate="yes" xml:space="preserve">
          <source>It is an error for &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enumerations&lt;/a&gt; to have the &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">&lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;零变量枚举&lt;/a&gt;具有 &lt;code&gt;C&lt;/code&gt; 表示形式是一个错误。</target>
        </trans-unit>
        <trans-unit id="c5e73da35c291d17423e4b430565c57bff241da2" translate="yes" xml:space="preserve">
          <source>It is an error to define two associated items (like methods, associated types, associated functions, etc.) with the same identifier.</source>
          <target state="translated">用同一个标识符定义两个关联项(如方法、关联类型、关联函数等)是错误的。</target>
        </trans-unit>
        <trans-unit id="1ecd71d2b66919da6bca2d4ca4f7a151af58acc5" translate="yes" xml:space="preserve">
          <source>It is an error to pass a zero &lt;code&gt;Duration&lt;/code&gt; to this function.</source>
          <target state="translated">将零 &lt;code&gt;Duration&lt;/code&gt; 传递给此函数是错误的。</target>
        </trans-unit>
        <trans-unit id="c705f9525d896b896f63b638e17d43664425dcf5" translate="yes" xml:space="preserve">
          <source>It is an error when two variants share the same discriminant.</source>
          <target state="translated">当两个变体具有相同的判别力时,这是一个错误。</target>
        </trans-unit>
        <trans-unit id="2f90cd6ec421d6e869d99b74e53a91895af9c5d9" translate="yes" xml:space="preserve">
          <source>It is available for use in stable rust from version 1.39 onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e066ad57d2ce7768c716de2f11bbba9cfbc5ef3" translate="yes" xml:space="preserve">
          <source>It is common to forget the trailing &lt;code&gt;!&lt;/code&gt; on macro invocations, which would also yield this error:</source>
          <target state="translated">忘记尾随是很常见的 &lt;code&gt;!&lt;/code&gt; 在宏调用上，这也会产生此错误：</target>
        </trans-unit>
        <trans-unit id="ab682946a2c7b0a4e860227b119766dc69c7e1ad" translate="yes" xml:space="preserve">
          <source>It is common to use &lt;code&gt;IntoIterator&lt;/code&gt; as a trait bound. This allows the input collection type to change, so long as it is still an iterator. Additional bounds can be specified by restricting on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">通常将 &lt;code&gt;IntoIterator&lt;/code&gt; 用作特征绑定。只要输入集合类型仍然是迭代器，它就可以更改。可以通过限制 &lt;code&gt;Item&lt;/code&gt; 来指定其他范围：</target>
        </trans-unit>
        <trans-unit id="24d52c7dd0ec99d9a6af7862341acee02c183bdc" translate="yes" xml:space="preserve">
          <source>It is common to use the &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; iterator adapter to turn an infinite iterator into a finite one:</source>
          <target state="translated">通常使用&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;迭代器适配器将无限迭代器转换为有限迭代器：</target>
        </trans-unit>
        <trans-unit id="c95bb9f004735a87f727f19d983aa3691d7d3210" translate="yes" xml:space="preserve">
          <source>It is considered an error if not all bytes could be written due to I/O errors or EOF being reached.</source>
          <target state="translated">如果由于I/O错误或达到EOF,不能写入所有字节,则视为错误。</target>
        </trans-unit>
        <trans-unit id="3bd73943cb17deb4f2b3ccabad843f693f98447d" translate="yes" xml:space="preserve">
          <source>It is considered an error if the directory already exists unless recursive mode is enabled.</source>
          <target state="translated">如果该目录已经存在,除非启用递归模式,否则将被视为错误。</target>
        </trans-unit>
        <trans-unit id="537243f1f25a0d4711910325fd3d083b4262a463" translate="yes" xml:space="preserve">
          <source>It is critical to call &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; is dropped. Though dropping will attempt to flush the contents of the buffer, any errors that happen in the process of dropping will be ignored. Calling &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; ensures that the buffer is empty and thus dropping will not even attempt file operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b8c7a920e8c6cdcbcebde2d4eda5f284d3bbea" translate="yes" xml:space="preserve">
          <source>It is currently impossible to create raw pointers to unaligned fields of a packed struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c36c5e7602baf3c3616b07cef1f3665caf1d22" translate="yes" xml:space="preserve">
          <source>It is currently undefined behavior to unwind from Rust code into foreign code, so this function is particularly useful when Rust is called from another language (normally C). This can run arbitrary Rust code, capturing a panic and allowing a graceful handling of the error.</source>
          <target state="translated">目前,从Rust代码到外国代码的解卷是未定义的行为,所以当从另一种语言(通常是C语言)调用Rust时,这个函数特别有用。这可以运行任意的Rust代码,捕捉到一个恐慌,并允许优雅地处理错误。</target>
        </trans-unit>
        <trans-unit id="5c66ccca042f9b01dffd3651727dd1995756e7b3" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;OpenOptions::new()&lt;/code&gt; but allows you to write more readable code. Instead of &lt;code&gt;OpenOptions::new().read(true).open(&quot;foo.txt&quot;)&lt;/code&gt; you can write &lt;code&gt;File::with_options().read(true).open(&quot;foo.txt&quot;)&lt;/code&gt;. This also avoids the need to import &lt;code&gt;OpenOptions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae5ff64ed07894b48692747efd0c02dda81558f" translate="yes" xml:space="preserve">
          <source>It is fine only if you put something back. &lt;code&gt;mem::replace&lt;/code&gt; can be used for that:</source>
          <target state="translated">仅当您放回一些东西时这才是好的。 &lt;code&gt;mem::replace&lt;/code&gt; 可用于：</target>
        </trans-unit>
        <trans-unit id="c557fd6825bdb89ba5f031ec165be0dd6a26ff58" translate="yes" xml:space="preserve">
          <source>It is friendlier to the optimizer to do this over &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; when dropping manually allocated memory (e.g., when writing Box/Rc/Vec), as the compiler doesn't need to prove that it's sound to elide the copy.</source>
          <target state="translated">在删除手动分配的内存时（例如，在编写Box / Rc / Vec时），通过&lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt;进行此操作对优化器更友好，因为编译器不需要证明删除副本是合理的。</target>
        </trans-unit>
        <trans-unit id="98cf066d0eeb6931da37108448f70da379f6d2ff" translate="yes" xml:space="preserve">
          <source>It is friendlier to the optimizer to do this over &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; when dropping manually allocated memory (e.g., when writing Box/Rc/Vec), as the compiler doesn't need to prove that it's sound to elide the copy.</source>
          <target state="translated">在删除手动分配的内存时（例如，在编写Box / Rc / Vec时），通过&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt;进行此操作对优化器更友好，因为编译器不需要证明删除副本是合理的。</target>
        </trans-unit>
        <trans-unit id="ed685795cf4962708592336505a9a35be53c890e" translate="yes" xml:space="preserve">
          <source>It is further guaranteed that, for the cases above, one can &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; from all valid values of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and from &lt;code&gt;Some::&amp;lt;T&amp;gt;(_)&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt; (but transmuting &lt;code&gt;None::&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt; is undefined behaviour).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a482eb06332931aa49748cd7170635733f6d060d" translate="yes" xml:space="preserve">
          <source>It is important to note that although the returned vector has the &lt;em&gt;capacity&lt;/em&gt; specified, the vector will have a zero &lt;em&gt;length&lt;/em&gt;. For an explanation of the difference between length and capacity, see &lt;em&gt;&lt;a href=&quot;#capacity-and-reallocation&quot;&gt;Capacity and reallocation&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">重要的是要注意，尽管返回的向量具有指定的&lt;em&gt;容量&lt;/em&gt;，但是向量的&lt;em&gt;长度&lt;/em&gt;为零。有关长度和容量之间差异的说明，请参见&lt;em&gt;&lt;a href=&quot;#capacity-and-reallocation&quot;&gt;容量和重新分配&lt;/a&gt;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c3de289a473969bb492d7f49323becca72758c15" translate="yes" xml:space="preserve">
          <source>It is important to note that both back and forth work on the same range, and do not cross: iteration is over when they meet in the middle.</source>
          <target state="translated">需要注意的是,前后两者都是在同一个范围内工作,并不交叉:当它们在中间相遇时,迭代就结束了。</target>
        </trans-unit>
        <trans-unit id="688443f49dee6c57698fbe38d0a4fd0c6b98badb" translate="yes" xml:space="preserve">
          <source>It is important to understand that &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; does not provide a &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; implementation (as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; does with &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;). Therefore, you should always try to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and then fall back to &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; can't be implemented.</source>
          <target state="translated">重要的是要了解&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;不提供&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;实现（就像&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;对&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; 一样&lt;/a&gt;）。因此，你应该总是尝试实施&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;，然后回落到&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;如果&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;无法实施。</target>
        </trans-unit>
        <trans-unit id="0b60eba4804f29ceedf6d48ba368778e00e21367" translate="yes" xml:space="preserve">
          <source>It is impossible to define an integer type to be used to represent zero-variant enum values because there are no zero-variant enum values. There is no way to construct an instance of the following type using only safe code. So you have two solutions. Either you add variants in your enum:</source>
          <target state="translated">不可能定义一个整数类型用来表示零变量枚举值,因为不存在零变量枚举值。没有办法只用安全代码来构造下面类型的实例。所以你有两种解决方案。要么你在你的枚举中添加变体。</target>
        </trans-unit>
        <trans-unit id="4d5291d52684a5eab8a4aab9333d7cc4b2cb958b" translate="yes" xml:space="preserve">
          <source>It is inadvisable to directly read from the underlying reader.</source>
          <target state="translated">不宜直接从底层读者中读取。</target>
        </trans-unit>
        <trans-unit id="f3c4bfe06953b97ae05b73dab70d1d3859db96ce" translate="yes" xml:space="preserve">
          <source>It is inadvisable to directly write to the underlying writer.</source>
          <target state="translated">直接写给底层作者是不可取的。</target>
        </trans-unit>
        <trans-unit id="8ec3e32d91034e8ec262cdcaaa5495ade82532d3" translate="yes" xml:space="preserve">
          <source>It is legal to declare a function that is both async and unsafe. The resulting function is unsafe to call and (like any async function) returns a future. This future is just an ordinary future and thus an &lt;code&gt;unsafe&lt;/code&gt; context is not required to &quot;await&quot; it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dbb1246b199ac521c8acb1693aa5061246652a" translate="yes" xml:space="preserve">
          <source>It is not a compile-time error if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have different sizes, but it is highly encouraged to only invoke this function where &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size. This function triggers &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; if &lt;code&gt;U&lt;/code&gt; is larger than &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 具有不同的大小，这不是编译时错误，但是强烈建议仅在 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 具有相同的大小时调用此函数。如果 &lt;code&gt;U&lt;/code&gt; 大于 &lt;code&gt;T&lt;/code&gt; ,此函数将触发&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义的行为&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8633689304bc80e12157956bafdee7aa5571ef8" translate="yes" xml:space="preserve">
          <source>It is not allowed to cast to a bool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804904553c24d5c3119a2a373f46ee3afe1e1bcf" translate="yes" xml:space="preserve">
          <source>It is not allowed to cast to a bool. If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="translated">它不允许投射到一个bool上。如果你试图将一个数字类型投向一个bool,你可以用零来代替它。</target>
        </trans-unit>
        <trans-unit id="3fc97c498b6845f6dd515270a06b8fc333df6ada" translate="yes" xml:space="preserve">
          <source>It is not allowed to manually call destructors in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c9437daa5a5b2d54fcaf5cf82931c13dd48503" translate="yes" xml:space="preserve">
          <source>It is not allowed to manually call destructors in Rust. It is also not necessary to do this since &lt;code&gt;drop&lt;/code&gt; is called automatically whenever a value goes out of scope.</source>
          <target state="translated">不允许在Rust中手动调用析构函数。也不需要这样做，因为只要值超出范围，就会自动调用 &lt;code&gt;drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0af3651d21c13332936be1aeb070069427b04863" translate="yes" xml:space="preserve">
          <source>It is not allowed to use or capture an uninitialized variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7767b89b540932cb942c6e1844049703b82b847b" translate="yes" xml:space="preserve">
          <source>It is not allowed to use or capture an uninitialized variable. For example:</source>
          <target state="translated">它不允许使用或捕获一个未初始化的变量。例如:</target>
        </trans-unit>
        <trans-unit id="9ec565a6be063138e105edece3d9609dbd23ba59" translate="yes" xml:space="preserve">
          <source>It is not always equivalent to a closure like &lt;code&gt;|x| x&lt;/code&gt; since the closure may coerce &lt;code&gt;x&lt;/code&gt; into a different type.</source>
          <target state="translated">它并不总是等效于 &lt;code&gt;|x| x&lt;/code&gt; 类的闭包。x，因为闭包可以将 &lt;code&gt;x&lt;/code&gt; 强制转换为其他类型。</target>
        </trans-unit>
        <trans-unit id="d85afe6ee8d10535dc66c9e1b7be7b3cdd688a64" translate="yes" xml:space="preserve">
          <source>It is not always equivalent to a closure like &lt;code&gt;|x| x&lt;/code&gt;, since the closure may coerce &lt;code&gt;x&lt;/code&gt; into a different type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1671d6fa1d906f29299a5bc6eb309657467bdad" translate="yes" xml:space="preserve">
          <source>It is not an error if the returned value &lt;code&gt;n&lt;/code&gt; is smaller than the buffer size, even when the reader is not at the end of the stream yet. This may happen for example because fewer bytes are actually available right now (e. g. being close to end-of-file) or because read() was interrupted by a signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7dcfb4170b72e2facf78d57d95eed97b2a6250" translate="yes" xml:space="preserve">
          <source>It is not an error to define a macro multiple times; the most recent declaration will shadow the previous one unless it has gone out of scope.</source>
          <target state="translated">多次定义一个宏并不会出错;最近的声明会影响之前的声明,除非它已经超出了范围。</target>
        </trans-unit>
        <trans-unit id="fe10caafa0ee23dcebc8469f9e22713be6e1455c" translate="yes" xml:space="preserve">
          <source>It is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.</source>
          <target state="translated">迭代器的实现并不强制要求产生声明的元素数。一个错误的迭代器可能产生的元素数量少于下限或多于上限。</target>
        </trans-unit>
        <trans-unit id="b8f822d10fd7f248875122ae295429f7075d08d7" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that the memory pointed by &lt;code&gt;ptr&lt;/code&gt; won't change before the &lt;code&gt;CStr&lt;/code&gt; has been destroyed.</source>
          <target state="translated">不能保证 &lt;code&gt;ptr&lt;/code&gt; 指向的内存在 &lt;code&gt;CStr&lt;/code&gt; 被销毁之前不会改变。</target>
        </trans-unit>
        <trans-unit id="63ef7dab9cc8c89ff48dae3884d5439039407f4c" translate="yes" xml:space="preserve">
          <source>It is not intended that most types or functions need to worry about this trait. It is only used as a bound on the &lt;code&gt;catch_unwind&lt;/code&gt; function and as mentioned above, the lack of &lt;code&gt;unsafe&lt;/code&gt; means it is mostly an advisory. The &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to force this trait to be implemented for any closed over variables passed to &lt;code&gt;catch_unwind&lt;/code&gt;.</source>
          <target state="translated">并非意味着大多数类型或函数都需要担心此特征。它仅用作 &lt;code&gt;catch_unwind&lt;/code&gt; 函数的绑定，并且如上所述，缺少 &lt;code&gt;unsafe&lt;/code&gt; 意味着它主要是建议。该&lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt;封装结构可用于强制这个特质传递给任何关闭了变数中实现 &lt;code&gt;catch_unwind&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34f3040279fd242d13257751040f971829001939" translate="yes" xml:space="preserve">
          <source>It is not necessary to annotate the full type. Once the ambiguity is resolved, the compiler can infer the rest:</source>
          <target state="translated">没有必要注释完整的类型。一旦解决了歧义,编译器就可以推断出其余的内容。</target>
        </trans-unit>
        <trans-unit id="79ac203d9d8f6d2d15f792ef9b54266d902c1bf2" translate="yes" xml:space="preserve">
          <source>It is not possible to declare type parameters on a function that has the &lt;code&gt;start&lt;/code&gt; attribute. Such a function must have the following type signature (for more information, view &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib&quot;&gt;the unstable book&lt;/a&gt;):</source>
          <target state="translated">不能在具有 &lt;code&gt;start&lt;/code&gt; 属性的函数上声明类型参数。这样的函数必须具有以下类型签名（有关更多信息，&lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib&quot;&gt;请参见不稳定的书&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="de00175d000048a3ab2db1da305a9746730281d2" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with a where clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5f5303b9508d3572ecb0aabe587d9c97215e2a" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with a where clause. Erroneous code example:</source>
          <target state="translated">用where子句定义 &lt;code&gt;main&lt;/code&gt; 是不可能的。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="d0b1c5c12eac01beb248497b03a0ab70e561e5a5" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with generic parameters. When &lt;code&gt;main&lt;/code&gt; is present, it must take no arguments and return &lt;code&gt;()&lt;/code&gt;. Erroneous code example:</source>
          <target state="translated">用通用参数定义 &lt;code&gt;main&lt;/code&gt; 是不可能的。当 &lt;code&gt;main&lt;/code&gt; 存在时，它必须不接受任何参数并返回 &lt;code&gt;()&lt;/code&gt; 。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="dac867cdafaa004a57591e1391a5068dc6cc6e4a" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;start&lt;/code&gt; with a where clause. Erroneous code example:</source>
          <target state="translated">不能以where子句定义 &lt;code&gt;start&lt;/code&gt; 。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="77edaee193e2b26f0dc132c04fc983d7a3f09123" translate="yes" xml:space="preserve">
          <source>It is not possible to define the &lt;code&gt;main&lt;/code&gt; function with generic parameters. It must not take any arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e4484b8793e84f3d96cf9d91150a25ddc1b027" translate="yes" xml:space="preserve">
          <source>It is not possible to use stability attributes outside of the standard library. Also, for now, it is not possible to write deprecation messages either.</source>
          <target state="translated">在标准库之外,无法使用稳定性属性。另外,目前也不能写废弃信息。</target>
        </trans-unit>
        <trans-unit id="a4bacc3cad49d167308e0fdf3be52c1450a1de33" translate="yes" xml:space="preserve">
          <source>It is not valid to put positional parameters (those without names) after arguments that have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babf4563d827f22cdca258081ab4debae3695f91" translate="yes" xml:space="preserve">
          <source>It is not valid to put positional parameters (those without names) after arguments which have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.</source>
          <target state="translated">把位置参数(没有名字的参数)放在有名字的参数后面是无效的。与位置参数一样,提供格式字符串未使用的命名参数是无效的。</target>
        </trans-unit>
        <trans-unit id="d3ba3f42fb0bf8686407f3cf8b99f8a8d970d5d7" translate="yes" xml:space="preserve">
          <source>It is often seen in its borrowed forms, either mutable or shared. The shared slice type is &lt;code&gt;&amp;amp;[T]&lt;/code&gt;, while the mutable slice type is &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; represents the element type.</source>
          <target state="translated">它经常以借用的形式出现，可以是可变的也可以是共享的。共享切片类型为 &lt;code&gt;&amp;amp;[T]&lt;/code&gt; ，可变切片类型为 &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 表示元素类型。</target>
        </trans-unit>
        <trans-unit id="2fab516d94cc4b051eccfa289cd47f35b51a6906" translate="yes" xml:space="preserve">
          <source>It is possible for &lt;code&gt;addr&lt;/code&gt; to yield multiple addresses, but &lt;code&gt;send_to&lt;/code&gt; will only send data to the first address yielded by &lt;code&gt;addr&lt;/code&gt;.</source>
          <target state="translated">这是可能的 &lt;code&gt;addr&lt;/code&gt; ，以产生多个地址，但 &lt;code&gt;send_to&lt;/code&gt; 将只发送数据到受产生的第一个地址 &lt;code&gt;addr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6369907ebe6b468b9a2ca85d26bcb0993424305d" translate="yes" xml:space="preserve">
          <source>It is possible to seek beyond the end of an object, but it's an error to seek before byte 0.</source>
          <target state="translated">可以在对象的末端之外寻找,但在字节0之前寻找是错误的。</target>
        </trans-unit>
        <trans-unit id="fdaed3dad08dda198d1195920589e6980812bcbd" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;ManuallyDrop&lt;/code&gt; to control the drop order, but this requires unsafe code and is hard to do correctly in the presence of unwinding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2042bff8db30718f4be68e6828fc24e384458a" translate="yes" xml:space="preserve">
          <source>It is possible to use pattern matching on &lt;code&gt;union&lt;/code&gt;s. A single field name must be used and it must match the name of one of the &lt;code&gt;union&lt;/code&gt;'s field. Like reading from a &lt;code&gt;union&lt;/code&gt;, pattern matching on a &lt;code&gt;union&lt;/code&gt; requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecc5cbf610b50fb9b85dc5d9562253999d191e2" translate="yes" xml:space="preserve">
          <source>It is possible, however, for &lt;strong&gt;logical&lt;/strong&gt; invariants to be broken in Rust, which can end up causing behavioral bugs. Another key aspect of unwind safety in Rust is that, in the absence of &lt;code&gt;unsafe&lt;/code&gt; code, a panic cannot lead to memory unsafety.</source>
          <target state="translated">但是，可能会在Rust中破坏&lt;strong&gt;逻辑&lt;/strong&gt;不变式，最终导致行为错误。Rust中取消安全性的另一个关键方面是，在没有 &lt;code&gt;unsafe&lt;/code&gt; 代码的情况下，紧急情况不会导致内存不安全。</target>
        </trans-unit>
        <trans-unit id="da80bba13418a2462cda990927908d8ad7892c41" translate="yes" xml:space="preserve">
          <source>It is recommended that you look for a &lt;code&gt;new&lt;/code&gt; function or equivalent in the crate's documentation.</source>
          <target state="translated">建议您在包装箱的文档中寻找 &lt;code&gt;new&lt;/code&gt; 功能或等效功能。</target>
        </trans-unit>
        <trans-unit id="158d82d49dddadcae62bf58b7e9d48850c1ba3f3" translate="yes" xml:space="preserve">
          <source>It is required that the keys implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">尽管通常可以使用 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 来实现键，但要求键实现&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性。如果您自己实现这些，那么拥有以下属性非常重要：</target>
        </trans-unit>
        <trans-unit id="1c5f8488f4eecd7c3ca6dd6e0c4ceb285589eb45" translate="yes" xml:space="preserve">
          <source>It is required that the keys implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">尽管通常可以使用 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 来实现键，但要求键实现&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性。如果您自己实现这些，那么拥有以下属性非常重要：</target>
        </trans-unit>
        <trans-unit id="9e65409691544dfbd0d6482536ef748a0086ee53" translate="yes" xml:space="preserve">
          <source>It is returned by the &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">它由&lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt;方法返回。</target>
        </trans-unit>
        <trans-unit id="43f6a5e55fbbfc805831e83b9b3a4f775c58ea12" translate="yes" xml:space="preserve">
          <source>It is roughly equal to a duration of 584,942,417,355 years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e22d2249ea3cf1183d26c8fb6b0c9e7619f06c9" translate="yes" xml:space="preserve">
          <source>It is semantically a wrapper around an &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;, but is guaranteed to be ABI compatible with the &lt;code&gt;iovec&lt;/code&gt; type on Unix platforms and &lt;code&gt;WSABUF&lt;/code&gt; on Windows.</source>
          <target state="translated">从语义上来说，它是 &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; 的包装，但可以保证与Unix平台上的 &lt;code&gt;iovec&lt;/code&gt; 类型和Windows上的 &lt;code&gt;WSABUF&lt;/code&gt; 兼容。</target>
        </trans-unit>
        <trans-unit id="310066900f319893888448530eda337cc1113b35" translate="yes" xml:space="preserve">
          <source>It is semantically a wrapper around an &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;, but is guaranteed to be ABI compatible with the &lt;code&gt;iovec&lt;/code&gt; type on Unix platforms and &lt;code&gt;WSABUF&lt;/code&gt; on Windows.</source>
          <target state="translated">从语义上来说，它是 &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; 的包装，但是可以保证与Unix平台上的 &lt;code&gt;iovec&lt;/code&gt; 类型和Windows上的 &lt;code&gt;WSABUF&lt;/code&gt; 兼容ABI 。</target>
        </trans-unit>
        <trans-unit id="d5c70546718e8bec6af4968356db7e36252be3a4" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to manually drop the mutex guard to unlock it sooner than the end of the enclosing scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e8beb4413ce9188f6c9ea8439432ef5b9611d2" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to have objects that are guaranteed not to move, in the sense that their placement in memory does not change, and can thus be relied upon. A prime example of such a scenario would be building self-referential structs, as moving an object with pointers to itself will invalidate them, which could cause undefined behavior.</source>
          <target state="translated">有时,保证对象不移动是很有用的,因为它们在内存中的位置不会改变,因此可以信赖。这种情况的一个典型例子是构建自引用结构,因为移动一个带有指向自身的指针的对象会使其无效,这可能会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="4371e8f3f7450e76f6a242238c801628a1cbf06b" translate="yes" xml:space="preserve">
          <source>It is the declarations that make up the contract of traits and what is available on generic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37c9a79672120af34904e218ec499be2dd86aef" translate="yes" xml:space="preserve">
          <source>It is the declarations that make up the contract of traits and what it available on generic types.</source>
          <target state="translated">它是由性状的契约和它在通用类型上可用的声明组成的。</target>
        </trans-unit>
        <trans-unit id="0b7557ddb14fd9cccc6582df092ab6f10becd5d9" translate="yes" xml:space="preserve">
          <source>It is the maximum index such that &lt;code&gt;from_utf8(&amp;amp;input[..index])&lt;/code&gt; would return &lt;code&gt;Ok(_)&lt;/code&gt;.</source>
          <target state="translated">这是最大索引，这样 &lt;code&gt;from_utf8(&amp;amp;input[..index])&lt;/code&gt; 将返回 &lt;code&gt;Ok(_)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b264294fdd4a01382c3aea7e168cfb7358441c48" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility when writing &lt;code&gt;unsafe&lt;/code&gt; code to ensure that any safe code interacting with the &lt;code&gt;unsafe&lt;/code&gt; code cannot trigger these behaviors. &lt;code&gt;unsafe&lt;/code&gt; code that satisfies this property for any safe client is called &lt;em&gt;sound&lt;/em&gt;; if &lt;code&gt;unsafe&lt;/code&gt; code can be misused by safe code to exhibit undefined behavior, it is &lt;em&gt;unsound&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ade12a490d1fb2caaede62e82d953ed5a36f49" translate="yes" xml:space="preserve">
          <source>It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated sorted sequences.</source>
          <target state="translated">它的速度通常比稳定排序快,除了少数特殊情况,例如,当分片由几个连贯的排序序列组成时。</target>
        </trans-unit>
        <trans-unit id="a75ff90de5ca8eff04b8583b7bb1f33e14e7d147" translate="yes" xml:space="preserve">
          <source>It is undefined behavior for this operation to overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;. If you cannot guarantee that this will not overflow, use &lt;code&gt;backward&lt;/code&gt; or &lt;code&gt;backward_checked&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8054d51290c5e837766cf36b3dc8b91cb98821" translate="yes" xml:space="preserve">
          <source>It is undefined behavior for this operation to overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;. If you cannot guarantee that this will not overflow, use &lt;code&gt;forward&lt;/code&gt; or &lt;code&gt;forward_checked&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acc32d24d7d6395cf0c7d59cd524a48233ae10a" translate="yes" xml:space="preserve">
          <source>It is unnecessary to do this since &lt;code&gt;drop&lt;/code&gt; is called automatically whenever a value goes out of scope. However, if you really need to drop a value by hand, you can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e547b1d483f3958a2447866fe3c4d46a3e009d" translate="yes" xml:space="preserve">
          <source>It is unspecified how many elements are removed from the vector if the &lt;code&gt;Splice&lt;/code&gt; value is leaked.</source>
          <target state="translated">如果 &lt;code&gt;Splice&lt;/code&gt; 值泄漏，则未指定从向量中删除多少个元素。</target>
        </trans-unit>
        <trans-unit id="295705b2fa436290d781c9b500c921db48521039" translate="yes" xml:space="preserve">
          <source>It is unspecified how many more elements will be subjected to the closure if a panic occurs in the closure, or a panic occurs while dropping an element, or if the &lt;code&gt;DrainFilter&lt;/code&gt; value is leaked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e979093f4634e70883c1e6b5d99af22f995783" translate="yes" xml:space="preserve">
          <source>It is unspecified how many more values will be subjected to the closure if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the &lt;code&gt;DrainFilter&lt;/code&gt; itself is leaked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cad4b99027fa4acf9843034ac2fdd309a68ec9" translate="yes" xml:space="preserve">
          <source>It is up to the caller to ensure that the object is still alive when accessing it through the pointer.</source>
          <target state="translated">在通过指针访问对象时,调用者要确保对象还活着。</target>
        </trans-unit>
        <trans-unit id="98956152124bb7bc80eb86d315a85b9b45c037d0" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; elements really are in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa61fcbe3608674ea2f0e3a8facadbaeb00b9db0" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior. The &lt;a href=&quot;#initialization-invariant&quot;&gt;type-level documentation&lt;/a&gt; contains more information about this initialization invariant.</source>
          <target state="translated">调用方可以确保 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 确实处于初始化状态。在内容尚未完全初始化时调用此方法会立即导致未定义的行为。该&lt;a href=&quot;#initialization-invariant&quot;&gt;类型层次的文件&lt;/a&gt;包含有关此初始化不变的更多信息。</target>
        </trans-unit>
        <trans-unit id="e90618210aeb35b7fbf1d0dce959c7d288e195c5" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.</source>
          <target state="translated">调用方可以确保 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 确实处于初始化状态。在内容尚未完全初始化时调用此方法将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="1cc21693b6059e6e8119cffad058e61a70eeecf5" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior. The &lt;a href=&quot;#initialization-invariant&quot;&gt;type-level documentation&lt;/a&gt; contains more information about this initialization invariant.</source>
          <target state="translated">调用方可以确保 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 确实处于初始化状态。在内容尚未完全初始化时调用此方法将导致未定义的行为。该&lt;a href=&quot;#initialization-invariant&quot;&gt;类型层次的文件&lt;/a&gt;包含有关此初始化不变的更多信息。</target>
        </trans-unit>
        <trans-unit id="ea0a0e4346d92e82b2088690613099c2bf07dc7c" translate="yes" xml:space="preserve">
          <source>It is used by the &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">&lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;特性使用它。</target>
        </trans-unit>
        <trans-unit id="76aa244bb958db0a4b9e995026430044d057625c" translate="yes" xml:space="preserve">
          <source>It is used with the &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">它与&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt;类型一起使用。</target>
        </trans-unit>
        <trans-unit id="2f1ece6b57f7a1f8dc31198244f231a713dd3042" translate="yes" xml:space="preserve">
          <source>It is valid to add the &lt;code&gt;link&lt;/code&gt; attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block.</source>
          <target state="translated">将 &lt;code&gt;link&lt;/code&gt; 属性添加到空的外部块上是有效的。您可以使用它来满足代码中其他地方（包括上游包装箱）的外部块的链接要求，而不是将属性添加到每个外部块。</target>
        </trans-unit>
        <trans-unit id="d3e90c3943be0d42f62f18b3f27da88ff78617f2" translate="yes" xml:space="preserve">
          <source>It is worth reiterating that &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; change the fact that a Rust compiler considers all types movable. &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; remains callable for any &lt;code&gt;T&lt;/code&gt;. Instead, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; prevents certain &lt;em&gt;values&lt;/em&gt; (pointed to by pointers wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;) from being moved by making it impossible to call methods that require &lt;code&gt;&amp;amp;mut T&lt;/code&gt; on them (like &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6738e5c58c6dd95792620faa63b8d5cc231a8b6d" translate="yes" xml:space="preserve">
          <source>It is worth reiterating that &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; change the fact that a Rust compiler considers all types movable. &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; remains callable for any &lt;code&gt;T&lt;/code&gt;. Instead, &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; prevents certain &lt;em&gt;values&lt;/em&gt; (pointed to by pointers wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;) from being moved by making it impossible to call methods that require &lt;code&gt;&amp;amp;mut T&lt;/code&gt; on them (like &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">值得重申的是&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;并&lt;em&gt;没有&lt;/em&gt;改变防锈编译器会将所有各类动产的事实。&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;对于任何 &lt;code&gt;T&lt;/code&gt; 仍然可以调用。相反， &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 通过使无法调用需要 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 的方法（例如&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;）来防止某些&lt;em&gt;值&lt;/em&gt;（由包装在 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 的指针指向）移动。</target>
        </trans-unit>
        <trans-unit id="0497668f013a73ed21db051aa84713bf2b2c56fa" translate="yes" xml:space="preserve">
          <source>It is written as &lt;code&gt;cfg&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, a configuration predicate, and finally &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">它被写为 &lt;code&gt;cfg&lt;/code&gt; ， &lt;code&gt;(&lt;/code&gt; ，一个配置谓词，最后是 &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff3c5f08953486f2ebadb5983fbdd75f91d8e664" translate="yes" xml:space="preserve">
          <source>It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8.</source>
          <target state="translated">你有责任确保字符串分片的修改方式是有效的UTF-8。</target>
        </trans-unit>
        <trans-unit id="e9c82e577605ff32cb90a4cd85e5d6c96aa90577" translate="yes" xml:space="preserve">
          <source>It is your responsibility to make sure that the underlying memory is not freed too early. For example, the following code will cause undefined behavior when &lt;code&gt;ptr&lt;/code&gt; is used inside the &lt;code&gt;unsafe&lt;/code&gt; block:</source>
          <target state="translated">您有责任确保底层内存不会过早释放。例如，当在 &lt;code&gt;unsafe&lt;/code&gt; 块内使用 &lt;code&gt;ptr&lt;/code&gt; 时，以下代码将导致未定义的行为：</target>
        </trans-unit>
        <trans-unit id="0e3a6e91bbdb9a45516082a07a40a29592b3f0cb" translate="yes" xml:space="preserve">
          <source>It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, there&amp;rsquo;s a convenient shorthand!</source>
          <target state="translated">用与struct字段相同的名称来命名函数参数是有意义的，但是必须重复 &lt;code&gt;email&lt;/code&gt; 和 &lt;code&gt;username&lt;/code&gt; 名字段的名称和变量有点乏味。如果该结构具有更多字段，则重复每个名称将变得更加烦人。幸运的是，这里有一个便捷的简写！</target>
        </trans-unit>
        <trans-unit id="d6943ba68e7fe9f38375bc9f4ece082b476fd104" translate="yes" xml:space="preserve">
          <source>It matches! There&amp;rsquo;s no value to add to, so the program stops and returns the &lt;code&gt;None&lt;/code&gt; value on the right side of &lt;code&gt;=&amp;gt;&lt;/code&gt;. Because the first arm matched, no other arms are compared.</source>
          <target state="translated">它匹配！没有要添加的值，因此程序停止并返回 &lt;code&gt;=&amp;gt;&lt;/code&gt; 右侧的 &lt;code&gt;None&lt;/code&gt; 值。因为第一个手臂匹配，所以没有其他手臂被比较。</target>
        </trans-unit>
        <trans-unit id="843b41eaa3d5b0c22ed8a08ff3f89c4230955bbd" translate="yes" xml:space="preserve">
          <source>It may be possible to define the closure later:</source>
          <target state="translated">后面可能会定义封闭。</target>
        </trans-unit>
        <trans-unit id="37366d1499bbe80dc60f80cfc9ff38beb421f588" translate="yes" xml:space="preserve">
          <source>It may seem counter-intuitive that the field of a pinned struct might not be pinned, but that is actually the easiest choice: if a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; is never created, nothing can go wrong! So, if you decide that some field does not have structural pinning, all you have to ensure is that you never create a pinned reference to that field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7626a2cf86a0ef32fb36f30c95b230833af23f10" translate="yes" xml:space="preserve">
          <source>It may seem counter-intuitive that the field of a pinned struct might not be pinned, but that is actually the easiest choice: if a &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; is never created, nothing can go wrong! So, if you decide that some field does not have structural pinning, all you have to ensure is that you never create a pinned reference to that field.</source>
          <target state="translated">固定结构的字段可能未固定似乎是违反直觉的，但这实际上是最简单的选择：如果从不创建 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 则不会出错！因此，如果您确定某个字段没有结构固定，则只需确保您从未创建对该字段的固定引用即可。</target>
        </trans-unit>
        <trans-unit id="1bb0d24f6b4149955502e6e8ad32374412376163" translate="yes" xml:space="preserve">
          <source>It might seem like the paths we&amp;rsquo;ve written to call functions so far are inconveniently long and repetitive. For example, in Listing 7-7, whether we chose the absolute or relative path to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, every time we wanted to call &lt;code&gt;add_to_waitlist&lt;/code&gt; we had to specify &lt;code&gt;front_of_house&lt;/code&gt; and &lt;code&gt;hosting&lt;/code&gt; too. Fortunately, there&amp;rsquo;s a way to simplify this process. We can bring a path into a scope once and then call the items in that path as if they&amp;rsquo;re local items with the &lt;code&gt;use&lt;/code&gt; keyword.</source>
          <target state="translated">到目前为止，我们编写的用于调用函数的路径似乎很长且重复。例如，在清单7-7中，无论我们选择 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数的绝对路径还是相对路径，每次我们想要调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 时，都必须指定 &lt;code&gt;front_of_house&lt;/code&gt; 和 &lt;code&gt;hosting&lt;/code&gt; 。幸运的是，有一种方法可以简化此过程。我们可以一次将一个路径带入一个范围，然后 &lt;code&gt;use&lt;/code&gt; 关键字将该路径中的项视为本地项。</target>
        </trans-unit>
        <trans-unit id="805aa02c515eaa318de6b78a094bce98b8c53d4d" translate="yes" xml:space="preserve">
          <source>It moves the input &lt;code&gt;x&lt;/code&gt; passed to the function.</source>
          <target state="translated">它将输入 &lt;code&gt;x&lt;/code&gt; 传递给函数。</target>
        </trans-unit>
        <trans-unit id="5eebbaa7bc3cdd0a56ef1daa1103d4c78b76f258" translate="yes" xml:space="preserve">
          <source>It must be &quot;dereferencable&quot; in the sense defined in &lt;a href=&quot;index#safety&quot;&gt;the module documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a5c10c251d6c8327aa492d2913739597d4a71f" translate="yes" xml:space="preserve">
          <source>It must be &quot;dereferencable&quot; in the sense defined in &lt;a href=&quot;ptr/index#safety&quot;&gt;the module documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e5a16652e3acc5312ad5ba06a9e285d4162164" translate="yes" xml:space="preserve">
          <source>It must not have any associated constants.</source>
          <target state="translated">它必须没有任何相关的常量。</target>
        </trans-unit>
        <trans-unit id="2ed9fe4f614f6746c16c9c39cbffbf6f903c7ae2" translate="yes" xml:space="preserve">
          <source>It must not require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">它一定不需要 &lt;code&gt;Self: Sized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f3447254df95470f3130af039bc15cf58155424" translate="yes" xml:space="preserve">
          <source>It operates on raw pointers instead of references. When references are available, &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; should be preferred.</source>
          <target state="translated">它对原始指针（而不是引用）进行操作。当引用可用时，应首选&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15a360bcd6063536513f56852862c8efa63c2070" translate="yes" xml:space="preserve">
          <source>It remains valid until it goes &lt;em&gt;out of scope&lt;/em&gt;.</source>
          <target state="translated">它保持有效，直到&lt;em&gt;超出范围&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="28129f615360627e84e6c1c9dbfcb777498ce57b" translate="yes" xml:space="preserve">
          <source>It replaces this:</source>
          <target state="translated">它取代了这个。</target>
        </trans-unit>
        <trans-unit id="a96e5b042b30c122375f53b68b92a35b6c66cd8b" translate="yes" xml:space="preserve">
          <source>It represents a separator that designates that a path starts from root.</source>
          <target state="translated">它代表一个分隔符,表示一个路径从根开始。</target>
        </trans-unit>
        <trans-unit id="813494512097c4629c56611a8d3205233aba9f55" translate="yes" xml:space="preserve">
          <source>It should be noted that the length isn't just &quot;recomputed,&quot; but that the recomputed length must match the original length from the &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt; call. This means the &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;from_raw&lt;/code&gt; methods should not be used when passing the string to C functions that can modify the string's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110275e5135057ece97674a5c23f292001714824" translate="yes" xml:space="preserve">
          <source>It sometimes happens that you have unused type parameters which indicate what type of data a struct is &quot;tied&quot; to, even though that data is not actually found in the struct itself. Here is an example where this arises with &lt;a href=&quot;../../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code&quot;&gt;FFI&lt;/a&gt;. The foreign interface uses handles of type &lt;code&gt;*mut ()&lt;/code&gt; to refer to Rust values of different types. We track the Rust type using a phantom type parameter on the struct &lt;code&gt;ExternalResource&lt;/code&gt; which wraps a handle.</source>
          <target state="translated">有时，您会遇到未使用的类型参数，这些参数指示结构&amp;ldquo;绑定&amp;rdquo;到的数据类型，即使该数据实际上不在结构本身中也没有找到。这是&lt;a href=&quot;../../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code&quot;&gt;FFI&lt;/a&gt;出现的一个示例。外部接口使用 &lt;code&gt;*mut ()&lt;/code&gt; 类型的句柄来引用不同类型的Rust值。我们使用包裹 &lt;code&gt;ExternalResource&lt;/code&gt; 句柄的struct ExternalResource结构上的幻像类型参数来跟踪Rust类型。</target>
        </trans-unit>
        <trans-unit id="c8a5407ac4250c5a13730093f7af0747e49f3547" translate="yes" xml:space="preserve">
          <source>It takes ownership of one weak count. In case a &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; is passed, a dangling &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">它需要一个弱项的所有权。如果传递了&lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt;，则返回悬空的&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc57f2847f6e3b461b4b48ae401fd449efb6afda" translate="yes" xml:space="preserve">
          <source>It takes ownership of one weak reference (with the exception of pointers created by &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;, as these don't own anything; the method still works on them).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556eed10e4ddb25bae7da43fa1a61a57fb93be86" translate="yes" xml:space="preserve">
          <source>It turns out that it is actually up to the author of the data structure to decide whether the pinned projection for a particular field turns &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;. There are some constraints though, and the most important constraint is &lt;em&gt;consistency&lt;/em&gt;: every field can be &lt;em&gt;either&lt;/em&gt; projected to a pinned reference, &lt;em&gt;or&lt;/em&gt; have pinning removed as part of the projection. If both are done for the same field, that will likely be unsound!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e869ff63d6d4b946c2cdd219b436de253a41746" translate="yes" xml:space="preserve">
          <source>It turns out that it is actually up to the author of the data structure to decide whether the pinned projection for a particular field turns &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;. There are some constraints though, and the most important constraint is &lt;em&gt;consistency&lt;/em&gt;: every field can be &lt;em&gt;either&lt;/em&gt; projected to a pinned reference, &lt;em&gt;or&lt;/em&gt; have pinning removed as part of the projection. If both are done for the same field, that will likely be unsound!</source>
          <target state="translated">事实证明，实际上是由数据结构的作者来决定特定字段的固定投影是将 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 变为 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 还是 &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; 。有虽然有些限制，以及最重要的约束是&lt;em&gt;一致性&lt;/em&gt;：每个字段可被&lt;em&gt;任一&lt;/em&gt;投射到被钉扎的参考，&lt;em&gt;或&lt;/em&gt;作为投影的一部分已除去钉扎。如果两个都在同一个领域完成，那将是不正确的！</target>
        </trans-unit>
        <trans-unit id="43f35f0c065fabfd41f89d1318ce0f42a18d0c80" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t always so clear, but the Rust programming language is fundamentally about &lt;em&gt;empowerment&lt;/em&gt;: no matter what kind of code you are writing now, Rust empowers you to reach farther, to program with confidence in a wider variety of domains than you did before.</source>
          <target state="translated">并非总是那么清晰，但是Rust编程语言从根本上讲就是关于&lt;em&gt;授权的&lt;/em&gt;：无论您现在正在编写哪种代码，Rust都使您能够走得更远，对与以前相比更广泛的领域充满信心地进行编程。</target>
        </trans-unit>
        <trans-unit id="e5c52d18214990d951c10878c00ac04808b86559" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;, or if the contents of the file are not valid UTF-8.</source>
          <target state="translated">如果在读取&lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;以外的其他类型的错误时遇到错误，或者文件的内容不是有效的UTF-8，它也会返回错误。</target>
        </trans-unit>
        <trans-unit id="88d7df68d5037684c00152095cea66d62196594d" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在读取&lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;以外的其他类型的错误时遇到错误，它也会返回错误。</target>
        </trans-unit>
        <trans-unit id="b634d15305e7f67a78aa8cca8e62aa2565532e97" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;, or if the contents of the file are not valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94bfac984e5cdabffa566b75c8486ad84a9f63a" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4977950c4a1247296e8ff0c58adfe3a8ef825061" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; types of the &lt;a href=&quot;trait.pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; trait if the pattern supports searching for it from the back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c79069ef32a54734e3b8b3c591b459a403a4fa" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;a href=&quot;trait.pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8e67a12d7988664bc05e18e9798989cd3eb135" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;code&gt;Pattern&lt;/code&gt; trait if the pattern supports searching for it from the back.</source>
          <target state="translated">如果模式支持从背面搜索，则将通过 &lt;code&gt;Pattern&lt;/code&gt; 特征的关联 &lt;code&gt;Searcher&lt;/code&gt; 类型实现。</target>
        </trans-unit>
        <trans-unit id="9f81a8ca5067c3c3b4399b6129a830805c0cc0ff" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;code&gt;Pattern&lt;/code&gt; trait.</source>
          <target state="translated">它将由 &lt;code&gt;Pattern&lt;/code&gt; trait的关联 &lt;code&gt;Searcher&lt;/code&gt; 类型实现。</target>
        </trans-unit>
        <trans-unit id="6ec53dce211a7944d162428d571097183435ce6f" translate="yes" xml:space="preserve">
          <source>It will drop down as close as possible to the length but the allocator may still inform the &lt;code&gt;VecDeque&lt;/code&gt; that there is space for a few more elements.</source>
          <target state="translated">它将尽可能接近长度下降，但是分配器仍可以通知 &lt;code&gt;VecDeque&lt;/code&gt; 还有更多元素的空间。</target>
        </trans-unit>
        <trans-unit id="5d0e16f9adb2110bbd3e927ea4577168391e9b74" translate="yes" xml:space="preserve">
          <source>It will drop down as close as possible to the length but the allocator may still inform the vector that there is space for a few more elements.</source>
          <target state="translated">它将尽可能地下降到接近长度的位置,但分配器仍然可能会通知向量还有几个元素的空间。</target>
        </trans-unit>
        <trans-unit id="583613916c43b1fe106e05c39ca4ce6da47ce68b" translate="yes" xml:space="preserve">
          <source>It will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它永远不会返回&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38d1d8fbd49b71b116c5d704cf7c49ee955c939a" translate="yes" xml:space="preserve">
          <source>It would also be appropriate to call &lt;code&gt;unwrap&lt;/code&gt; when you have some other logic that ensures the &lt;code&gt;Result&lt;/code&gt; will have an &lt;code&gt;Ok&lt;/code&gt; value, but the logic isn&amp;rsquo;t something the compiler understands. You&amp;rsquo;ll still have a &lt;code&gt;Result&lt;/code&gt; value that you need to handle: whatever operation you&amp;rsquo;re calling still has the possibility of failing in general, even though it&amp;rsquo;s logically impossible in your particular situation. If you can ensure by manually inspecting the code that you&amp;rsquo;ll never have an &lt;code&gt;Err&lt;/code&gt; variant, it&amp;rsquo;s perfectly acceptable to call &lt;code&gt;unwrap&lt;/code&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">当您拥有其他一些确保 &lt;code&gt;Result&lt;/code&gt; 的 &lt;code&gt;Ok&lt;/code&gt; 值的逻辑时，调用 &lt;code&gt;unwrap&lt;/code&gt; 也很合适，但是编译器无法理解该逻辑。您仍然需要处理一个 &lt;code&gt;Result&lt;/code&gt; 值：您正在调用的任何操作通常都可能会失败，即使在特定情况下从逻辑上讲也是不可能的。如果您可以通过手动检查代码来确保自己永远不会有 &lt;code&gt;Err&lt;/code&gt; 变体，那么调用 &lt;code&gt;unwrap&lt;/code&gt; 是完全可以接受的。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="281e22ba57501fc7d3d70b8f1f8f4bfbc5dcf1a5" translate="yes" xml:space="preserve">
          <source>It would make it more difficult for unsafe code to correctly manipulate a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had actually allocated memory.</source>
          <target state="translated">对于不安全的代码而言，正确操作 &lt;code&gt;Vec&lt;/code&gt; 会更加困难。如果仅移动 &lt;code&gt;Vec&lt;/code&gt; 的内容，它的地址就不会稳定，因此，确定 &lt;code&gt;Vec&lt;/code&gt; 是否实际分配了内存将更加困难。</target>
        </trans-unit>
        <trans-unit id="8927c51bfbab721165d17b97848a237b8ec4da60" translate="yes" xml:space="preserve">
          <source>It would penalize the general case, incurring an additional branch on every access.</source>
          <target state="translated">这将惩罚一般情况下,每一次访问都会招致一个额外的分支。</target>
        </trans-unit>
        <trans-unit id="0a1ec3ed4f97e53ed39cbe77eeb33099668d0775" translate="yes" xml:space="preserve">
          <source>It wouldn't work. This is because the size of a &lt;code&gt;List&lt;/code&gt; depends on how many elements are in the list, and so we don't know how much memory to allocate for a &lt;code&gt;Cons&lt;/code&gt;. By introducing a &lt;a href=&quot;struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, which has a defined size, we know how big &lt;code&gt;Cons&lt;/code&gt; needs to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6be8378a582020df10360545b9470cc00244ca7" translate="yes" xml:space="preserve">
          <source>It wouldn't work. This is because the size of a &lt;code&gt;List&lt;/code&gt; depends on how many elements are in the list, and so we don't know how much memory to allocate for a &lt;code&gt;Cons&lt;/code&gt;. By introducing a &lt;code&gt;Box&lt;/code&gt;, which has a defined size, we know how big &lt;code&gt;Cons&lt;/code&gt; needs to be.</source>
          <target state="translated">这行不通。这是因为 &lt;code&gt;List&lt;/code&gt; 的大小取决于列表中有多少个元素，因此我们不知道为 &lt;code&gt;Cons&lt;/code&gt; 分配多少内存。通过引入具有定义大小的 &lt;code&gt;Box&lt;/code&gt; ，我们知道需要多大的 &lt;code&gt;Cons&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4998da21c6a9914c8ce4ea9184bccf6c0873e7d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;d be nice to be able to print an instance of &lt;code&gt;Rectangle&lt;/code&gt; while we&amp;rsquo;re debugging our program and see the values for all its fields. Listing 5-11 tries using the &lt;code&gt;println!&lt;/code&gt; macro as we have used in previous chapters. This won&amp;rsquo;t work, however.</source>
          <target state="translated">能够在调试程序的同时打印 &lt;code&gt;Rectangle&lt;/code&gt; 的实例并查看其所有字段的值，这是很好的。清单5-11尝试使用 &lt;code&gt;println!&lt;/code&gt; 宏，正如我们在前几章中所使用的。但是，这不起作用。</target>
        </trans-unit>
        <trans-unit id="9fd4ff89cd3ed9767f9bb50021655606612821c0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a panoply of Rust features with something for everyone! Let&amp;rsquo;s dive in!</source>
          <target state="translated">这是Rust功能的全集，适合所有人！让我们潜入吧！</target>
        </trans-unit>
        <trans-unit id="2f4a91582fca2b4ddf611bb05db0236c35e6a95d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s advisable to have your code panic when it&amp;rsquo;s possible that your code could end up in a bad state. In this context, a &lt;em&gt;bad state&lt;/em&gt; is when some assumption, guarantee, contract, or invariant has been broken, such as when invalid values, contradictory values, or missing values are passed to your code&amp;mdash;plus one or more of the following:</source>
          <target state="translated">如果您的代码可能最终陷入错误状态，建议您让代码感到恐慌。在这种情况下，&lt;em&gt;坏状态&lt;/em&gt;是指某些假设，担保，合同或不变式已被破坏，例如将无效值，矛盾值或缺失值传递给您的代码时，加上以下一项或多项内容：</target>
        </trans-unit>
        <trans-unit id="1d4af836f0cd460a3ac351996453b851549fe52a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also worth noting that the condition in this code &lt;em&gt;must&lt;/em&gt; be a &lt;code&gt;bool&lt;/code&gt;. If the condition isn&amp;rsquo;t a &lt;code&gt;bool&lt;/code&gt;, we&amp;rsquo;ll get an error. For example, try running the following code:</source>
          <target state="translated">还值得注意的是，此代码中的条件&lt;em&gt;必须&lt;/em&gt;为 &lt;code&gt;bool&lt;/code&gt; 。如果条件不是 &lt;code&gt;bool&lt;/code&gt; ，我们将得到一个错误。例如，尝试运行以下代码：</target>
        </trans-unit>
        <trans-unit id="d52fc1028632f974c83efdc9f4200e35b249610e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s been a long journey, but we&amp;rsquo;ve reached the end of the book. In this chapter, we&amp;rsquo;ll build one more project together to demonstrate some of the concepts we covered in the final chapters, as well as recap some earlier lessons.</source>
          <target state="translated">这是一个漫长的旅程，但是我们已经到了本书的结尾。在本章中，我们将一起构建一个项目，以演示最后几章中介绍的一些概念，并回顾一些较早的课程。</target>
        </trans-unit>
        <trans-unit id="1024ef58107465d0b2d166ab80e88f189d22f3a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to check whether a particular key has a value and, if it doesn&amp;rsquo;t, insert a value for it. Hash maps have a special API for this called &lt;code&gt;entry&lt;/code&gt; that takes the key you want to check as a parameter. The return value of the &lt;code&gt;entry&lt;/code&gt; method is an enum called &lt;code&gt;Entry&lt;/code&gt; that represents a value that might or might not exist. Let&amp;rsquo;s say we want to check whether the key for the Yellow team has a value associated with it. If it doesn&amp;rsquo;t, we want to insert the value 50, and the same for the Blue team. Using the &lt;code&gt;entry&lt;/code&gt; API, the code looks like Listing 8-25.</source>
          <target state="translated">通常检查特定键是否具有值，如果没有，则为其插入值。哈希映射为此调用 &lt;code&gt;entry&lt;/code&gt; 提供了特殊的API，该API 将您要检查的密钥作为参数。 &lt;code&gt;entry&lt;/code&gt; 方法的返回值是一个称为 &lt;code&gt;Entry&lt;/code&gt; 的枚举，它表示一个可能存在或可能不存在的值。假设我们要检查Yellow团队的密钥是否具有与其关联的值。如果不是，我们要插入值50，蓝色团队也要插入值50。使用 &lt;code&gt;entry&lt;/code&gt; API，代码类似于清单8-25。</target>
        </trans-unit>
        <trans-unit id="b254f401bbc453696a95036f25cc6c8b9f205677" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important that we get compile-time errors when we attempt to change a value that we previously designated as immutable because this very situation can lead to bugs. If one part of our code operates on the assumption that a value will never change and another part of our code changes that value, it&amp;rsquo;s possible that the first part of the code won&amp;rsquo;t do what it was designed to do. The cause of this kind of bug can be difficult to track down after the fact, especially when the second piece of code changes the value only &lt;em&gt;sometimes&lt;/em&gt;.</source>
          <target state="translated">尝试更改以前指定为不可变的值时，必须获得编译时错误，这一点很重要，因为这种情况可能会导致错误。如果我们的代码的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分则在改变该值，那么代码的第一部分可能不会按照设计的意图进行操作。实际上，此类错误的原因可能很难追查，尤其是在第二段代码&lt;em&gt;有时&lt;/em&gt;仅更改值&lt;em&gt;时&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9ed2c9ced3e236750c87d43ad1072d6e0ed07bbb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that &lt;code&gt;unsafe&lt;/code&gt; doesn&amp;rsquo;t turn off the borrow checker or disable any other of Rust&amp;rsquo;s safety checks: if you use a reference in unsafe code, it will still be checked. The &lt;code&gt;unsafe&lt;/code&gt; keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You&amp;rsquo;ll still get some degree of safety inside of an unsafe block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cdb0b8313d7ae007e7e125bdfd991a30a8e291c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that &lt;code&gt;unsafe&lt;/code&gt; doesn&amp;rsquo;t turn off the borrow checker or disable any other of Rust&amp;rsquo;s safety checks: if you use a reference in unsafe code, it will still be checked. The &lt;code&gt;unsafe&lt;/code&gt; keyword only gives you access to these four features that are then not checked by the compiler for memory safety. You&amp;rsquo;ll still get some degree of safety inside of an unsafe block.</source>
          <target state="translated">重要的是要理解 &lt;code&gt;unsafe&lt;/code&gt; 不会关闭借用检查器或禁用Rust的任何其他安全检查：如果在不安全代码中使用引用，则仍将对其进行检查。在 &lt;code&gt;unsafe&lt;/code&gt; 关键字只给你访问到，然后不是由编译器对内存的安全检查这四个特点。在不安全的区块内，您仍然会获得一定程度的安全性。</target>
        </trans-unit>
        <trans-unit id="8deea23b26cb7cf37f9d9061e806bcfc7feaa092" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible for Rust to determine how many values in the tuple to ignore before matching a value with &lt;code&gt;second&lt;/code&gt; and then how many further values to ignore thereafter. This code could mean that we want to ignore &lt;code&gt;2&lt;/code&gt;, bind &lt;code&gt;second&lt;/code&gt; to &lt;code&gt;4&lt;/code&gt;, and then ignore &lt;code&gt;8&lt;/code&gt;, &lt;code&gt;16&lt;/code&gt;, and &lt;code&gt;32&lt;/code&gt;; or that we want to ignore &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, bind &lt;code&gt;second&lt;/code&gt; to &lt;code&gt;8&lt;/code&gt;, and then ignore &lt;code&gt;16&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt;; and so forth. The variable name &lt;code&gt;second&lt;/code&gt; doesn&amp;rsquo;t mean anything special to Rust, so we get a compiler error because using &lt;code&gt;..&lt;/code&gt; in two places like this is ambiguous.</source>
          <target state="translated">Rust无法确定将元组中的值与 &lt;code&gt;second&lt;/code&gt; 个值匹配之前要忽略的元组，然后再确定要忽略的其他值。此代码可能意味着我们希望忽略 &lt;code&gt;2&lt;/code&gt; ，绑定 &lt;code&gt;second&lt;/code&gt; 至 &lt;code&gt;4&lt;/code&gt; ，然后忽略 &lt;code&gt;8&lt;/code&gt; ， &lt;code&gt;16&lt;/code&gt; ，和 &lt;code&gt;32&lt;/code&gt; ; 或者我们要忽略 &lt;code&gt;2&lt;/code&gt; 和 &lt;code&gt;4&lt;/code&gt; ，将 &lt;code&gt;second&lt;/code&gt; 绑定到 &lt;code&gt;8&lt;/code&gt; ，然后忽略 &lt;code&gt;16&lt;/code&gt; 和 &lt;code&gt;32&lt;/code&gt; ; 等等。变量名 &lt;code&gt;second&lt;/code&gt; 对Rust来说并不意味着什么，因此由于使用 &lt;code&gt;..&lt;/code&gt; 在这样的两个地方模棱两可。</target>
        </trans-unit>
        <trans-unit id="b30b0ad80edd47c563a2e1776ed2c849ecd649e3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful for a program to evaluate a condition within a loop. While the condition is true, the loop runs. When the condition ceases to be true, the program calls &lt;code&gt;break&lt;/code&gt;, stopping the loop. This loop type could be implemented using a combination of &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;; you could try that now in a program, if you&amp;rsquo;d like.</source>
          <target state="translated">对于程序评估循环中的条件通常很有用。当条件为真时，循环运行。当条件不再为真时，程序将调用 &lt;code&gt;break&lt;/code&gt; ，从而停止循环。这个循环型可使用的组合来实现的 &lt;code&gt;loop&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; ，和 &lt;code&gt;break&lt;/code&gt; ; 您可以根据需要在程序中立即尝试。</target>
        </trans-unit>
        <trans-unit id="2a4b6828f8495332d03de5c3d6e1db7c761b6380" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful to create a new instance of a struct that uses most of an old instance&amp;rsquo;s values but changes some. You&amp;rsquo;ll do this using &lt;em&gt;struct update syntax&lt;/em&gt;.</source>
          <target state="translated">创建一个使用大多数旧实例值但更改其中一些值的结构的新实例通常很有用。您将使用&lt;em&gt;struct update语法&lt;/em&gt;执行此操作。</target>
        </trans-unit>
        <trans-unit id="723b901f30cea9edf0e74e2f7413d0b6d6d9f846" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful to execute a block of code more than once. For this task, Rust provides several &lt;em&gt;loops&lt;/em&gt;. A loop runs through the code inside the loop body to the end and then starts immediately back at the beginning. To experiment with loops, let&amp;rsquo;s make a new project called &lt;em&gt;loops&lt;/em&gt;.</source>
          <target state="translated">多次执行一个代码块通常很有用。对于此任务，Rust提供了几个&lt;em&gt;循环&lt;/em&gt;。循环从循环体内的代码一直运行到结束，然后立即从头开始。为了试验循环，让我们创建一个名为&lt;em&gt;loops&lt;/em&gt;的新项目。</target>
        </trans-unit>
        <trans-unit id="753665469cbfa717250694f7de09ac1968d71cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible for structs to store references to data owned by something else, but to do so requires the use of &lt;em&gt;lifetimes&lt;/em&gt;, a Rust feature that we&amp;rsquo;ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. Let&amp;rsquo;s say you try to store a reference in a struct without specifying lifetimes, like this, which won&amp;rsquo;t work:</source>
          <target state="translated">结构可能存储对其他人拥有的数据的引用，但是这样做需要使用&lt;em&gt;lifetimes&lt;/em&gt;，这是我们将在第10章中讨论的Rust功能。生命周期可确保结构所引用的数据在有效期内作为结构。假设您尝试将引用存储在结构中而不指定生存期，例如这样，它将不起作用：</target>
        </trans-unit>
        <trans-unit id="1330d73ba4baef219cde7c8056164e7a0d0b3b12" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to return multiple values using a tuple, as shown in Listing 4-5.</source>
          <target state="translated">可以使用元组返回多个值，如清单4-5所示。</target>
        </trans-unit>
        <trans-unit id="dd54062a6d4a18f88f50f4130b2d691d87e7c906" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s useful to discuss strings in the context of collections because strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text. In this section, we&amp;rsquo;ll talk about the operations on &lt;code&gt;String&lt;/code&gt; that every collection type has, such as creating, updating, and reading. We&amp;rsquo;ll also discuss the ways in which &lt;code&gt;String&lt;/code&gt; is different from the other collections, namely how indexing into a &lt;code&gt;String&lt;/code&gt; is complicated by the differences between how people and computers interpret &lt;code&gt;String&lt;/code&gt; data.</source>
          <target state="translated">在集合的上下文中讨论字符串很有用，因为字符串是作为字节的集合实现的，另外还有一些在这些字节被解释为文本时提供有用功能的方法。在本节中，我们将讨论每种集合类型对 &lt;code&gt;String&lt;/code&gt; 的操作，例如创建，更新和读取。我们还将讨论 &lt;code&gt;String&lt;/code&gt; 与其他集合不同的方式，即人与计算机解释 &lt;code&gt;String&lt;/code&gt; 数据之间的差异如何使索引到 &lt;code&gt;String&lt;/code&gt; 变得复杂。</target>
        </trans-unit>
        <trans-unit id="08a5c61453f5e990492626e9bb6d14bf2f43a9aa" translate="yes" xml:space="preserve">
          <source>It's also important to note that the Rust compiler can generally determine the lifetime by itself. Example:</source>
          <target state="translated">还需要注意的是,Rust编译器一般可以自己确定寿命。例如</target>
        </trans-unit>
        <trans-unit id="33ba7241cc90a10e5fee095fa049c987fe61e308" translate="yes" xml:space="preserve">
          <source>It's common for people who haven't used iterators a lot to use a &lt;code&gt;for&lt;/code&gt; loop with a list of things to build up a result. Those can be turned into &lt;code&gt;fold()&lt;/code&gt;s:</source>
          <target state="translated">对于那些不经常使用迭代器的人来说，通常使用 &lt;code&gt;for&lt;/code&gt; 循环和一系列东西来建立结果。那些可以变成 &lt;code&gt;fold()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba017d93d6349943ce3ed0d06f842a0f9c987ffa" translate="yes" xml:space="preserve">
          <source>It's common to instead use destructuring on the argument to strip away one:</source>
          <target state="translated">常见的是,而是在参数上使用destructuring来剥离一个参数。</target>
        </trans-unit>
        <trans-unit id="686ffc7f644232912f8eff3ec52197d230c78db4" translate="yes" xml:space="preserve">
          <source>It's important to note that in these two examples, the only difference is whether you are allowed to access &lt;code&gt;x&lt;/code&gt; after the assignment. Under the hood, both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away.</source>
          <target state="translated">重要的是要注意，在这两个示例中，唯一的区别是分配后是否允许您访问 &lt;code&gt;x&lt;/code&gt; 。在后台，复制和移动都可能导致将位复制到内存中，尽管有时会对其进行优化。</target>
        </trans-unit>
        <trans-unit id="bf0d2bc6515048c1222c1faf89f4b7dfbf926400" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want.</source>
          <target state="translated">重要的是要记住，&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;代表Unicode标量值，可能与您对&amp;ldquo;字符&amp;rdquo;的概念不符。字素簇的迭代可能是您真正想要的。</target>
        </trans-unit>
        <trans-unit id="a89bf255278a9fcad7529f6bfd4c6a49b45cb147" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust's standard library, check crates.io instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4da28ef521125e0c1be74a0e5b5fccf5a9444a6" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want.</source>
          <target state="translated">重要的是要记住，&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;代表Unicode标量值，可能与您对&amp;ldquo;字符&amp;rdquo;的概念不符。字素簇的迭代可能是您真正想要的。</target>
        </trans-unit>
        <trans-unit id="21dabe83c3c9b91d37de871b20d8a3fe9aea8d87" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust's standard library, check crates.io instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34560c82a9fb0dc71d1acee3f7d70c175383bc7b" translate="yes" xml:space="preserve">
          <source>It's invalid to directly import methods belonging to a trait or concrete type.</source>
          <target state="translated">直接导入属于特质或具体类型的方法是无效的。</target>
        </trans-unit>
        <trans-unit id="c4ea1a04986d9525398a48411915463d79b08630" translate="yes" xml:space="preserve">
          <source>It's more common for &lt;code&gt;inspect()&lt;/code&gt; to be used as a debugging tool than to exist in your final code, but applications may find it useful in certain situations when errors need to be logged before being discarded.</source>
          <target state="translated">与最终代码中不存在的情况相比，将 &lt;code&gt;inspect()&lt;/code&gt; 用作调试工具更为常见，但是在某些情况下，如果需要先记录错误然后丢弃错误，应用程序可能会发现它很有用。</target>
        </trans-unit>
        <trans-unit id="2f6fd4d024f3a27229b0326aaec954fc7e7267f9" translate="yes" xml:space="preserve">
          <source>It's only possible to directly instantiate a struct using struct literal syntax when all of its fields are visible to you.</source>
          <target state="translated">只有当一个结构的所有字段都对你可见时,才有可能使用结构文字语法直接实例化一个结构。</target>
        </trans-unit>
        <trans-unit id="bc2a391a320094b486e218290333929f21b82924" translate="yes" xml:space="preserve">
          <source>It's undefined behavior if global allocators unwind. This restriction may be lifted in the future, but currently a panic from any of these functions may lead to memory unsafety.</source>
          <target state="translated">如果全局分配器松开,这是未定义的行为。这个限制将来可能会被取消,但目前这些函数中的任何一个函数的恐慌都可能导致内存不安全。</target>
        </trans-unit>
        <trans-unit id="90d66c69bdab0c4f62a7abada1a3e2fdee354d75" translate="yes" xml:space="preserve">
          <source>It's very common then to put a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; inside shared pointer types to reintroduce mutability:</source>
          <target state="translated">然后将 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 放在共享指针类型中以重新引入可变性是很常见的：</target>
        </trans-unit>
        <trans-unit id="21df73947a06d77d2ad5fe166c8ddfcdc53a6fdb" translate="yes" xml:space="preserve">
          <source>Italiano</source>
          <target state="translated">Italiano</target>
        </trans-unit>
        <trans-unit id="1927b99b7203a5d61bb78b1a858edbf1a4446227" translate="yes" xml:space="preserve">
          <source>Item declarations</source>
          <target state="translated">项目申报</target>
        </trans-unit>
        <trans-unit id="052ff2f8a72886a3883816a6bea2ff5da9ae8dcc" translate="yes" xml:space="preserve">
          <source>Item visibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="e94f4a33f00d601e0668e3316c1f5baec10b371b" translate="yes" xml:space="preserve">
          <source>Items are entirely determined at compile-time, generally remain fixed during execution, and may reside in read-only memory.</source>
          <target state="translated">项目完全是在编译时确定的,一般在执行过程中保持固定,并可能驻留在只读存储器中。</target>
        </trans-unit>
        <trans-unit id="d65bc9662d384da5396d0c23266596b91dc5d76b" translate="yes" xml:space="preserve">
          <source>Items are missing in a trait implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf93f2b738152017441b72f8223700a6c86d570" translate="yes" xml:space="preserve">
          <source>Items are missing in a trait implementation. Erroneous code example:</source>
          <target state="translated">特质实现中缺少项目。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="e8b3f0ebaa39e2f70c17e1cb57e9f0ef34b2a7cd" translate="yes" xml:space="preserve">
          <source>Items associated with a trait do not need to be defined in the trait, but they may be. If the trait provides a definition, then this definition acts as a default for any implementation which does not override it. If it does not, then any implementation must provide a definition.</source>
          <target state="translated">与特质相关的项目不需要在特质中定义,但可以定义。如果trait提供了一个定义,那么这个定义对于任何没有覆盖它的实现来说都是默认的。如果没有,那么任何实现都必须提供一个定义。</target>
        </trans-unit>
        <trans-unit id="d525f8eb402a25c60f5c5ba9759986177ee5a851" translate="yes" xml:space="preserve">
          <source>Items can be imported without binding to a name by using an underscore with the form &lt;code&gt;use path as _&lt;/code&gt;. This is particularly useful to import a trait so that its methods may be used without importing the trait's symbol, for example if the trait's symbol may conflict with another symbol. Another example is to link an external crate without importing its name.</source>
          <target state="translated">通过使用形式为 &lt;code&gt;use path as _&lt;/code&gt; 的下划线，可以导入项目而无需绑定名称。这对于导入特征特别有用，因此可以在不导入特征符号的情况下使用其方法，例如，如果特征符号可能与另一个符号冲突。另一个示例是链接外部板条箱而不导入其名称。</target>
        </trans-unit>
        <trans-unit id="d80427c3d2c84e1095c0f47d752a2b536590da04" translate="yes" xml:space="preserve">
          <source>Items defined in a module or implementation have a &lt;em&gt;canonical path&lt;/em&gt; that corresponds to where within its crate it is defined. All other paths to these items are aliases. The canonical path is defined as a &lt;em&gt;path prefix&lt;/em&gt; appended by the path segment the item itself defines.</source>
          <target state="translated">在模块或实现中定义的项目具有&lt;em&gt;规范的路径&lt;/em&gt;，该&lt;em&gt;路径&lt;/em&gt;与其在其板条箱中定义的位置相对应。这些项目的所有其他路径都是别名。规范路径定义为项目本身定义的路径段附加的&lt;em&gt;路径前缀&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="dff50658b0fc9891bf43ec3aa222a12df699a4f5" translate="yes" xml:space="preserve">
          <source>Items inside functions are basically just like top-level items, except that they can only be used from the function they are in.</source>
          <target state="translated">函数里面的项目基本上和顶层项目一样,只是只能从它们所在的函数中使用。</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="562356f4191fd96292159c9a51f1502a656a766d" translate="yes" xml:space="preserve">
          <source>Iter::all</source>
          <target state="translated">Iter::all</target>
        </trans-unit>
        <trans-unit id="598e9d1442d2d90b30d41f52dc9f35d312a9ea85" translate="yes" xml:space="preserve">
          <source>Iter::any</source>
          <target state="translated">Iter::any</target>
        </trans-unit>
        <trans-unit id="11c24b7b71f44b4c32bd475993cf94651f69ef7b" translate="yes" xml:space="preserve">
          <source>Iter::as_path</source>
          <target state="translated">Iter::as_path</target>
        </trans-unit>
        <trans-unit id="b00470be46e8b1319d806bf1fedc19612d599118" translate="yes" xml:space="preserve">
          <source>Iter::as_ref</source>
          <target state="translated">Iter::as_ref</target>
        </trans-unit>
        <trans-unit id="1c4a85c9060fc0533851d2ebb18b0944dec20504" translate="yes" xml:space="preserve">
          <source>Iter::as_slice</source>
          <target state="translated">Iter::as_slice</target>
        </trans-unit>
        <trans-unit id="cd753ac2ff5d2f5e373d6da3f28eb6cc4f4a12da" translate="yes" xml:space="preserve">
          <source>Iter::borrow</source>
          <target state="translated">Iter::borrow</target>
        </trans-unit>
        <trans-unit id="ccae721db6c0b80ead456e39e15a574d91f05503" translate="yes" xml:space="preserve">
          <source>Iter::borrow_mut</source>
          <target state="translated">Iter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="9e9e1cc006a1a0c230f182d60dc3ae25867fa96b" translate="yes" xml:space="preserve">
          <source>Iter::by_ref</source>
          <target state="translated">Iter::by_ref</target>
        </trans-unit>
        <trans-unit id="40958308a6a00b30f0186ac470a90b4263782276" translate="yes" xml:space="preserve">
          <source>Iter::chain</source>
          <target state="translated">Iter::chain</target>
        </trans-unit>
        <trans-unit id="a16e2afb6a204e2c61484cc43715d2838e449cea" translate="yes" xml:space="preserve">
          <source>Iter::clone</source>
          <target state="translated">Iter::clone</target>
        </trans-unit>
        <trans-unit id="d33632634125b5bfb914d7696031de5e4050211f" translate="yes" xml:space="preserve">
          <source>Iter::clone_from</source>
          <target state="translated">Iter::clone_from</target>
        </trans-unit>
        <trans-unit id="c521a7d4341dba591b54fa4bc0805ada3d50f399" translate="yes" xml:space="preserve">
          <source>Iter::clone_into</source>
          <target state="translated">Iter::clone_into</target>
        </trans-unit>
        <trans-unit id="566bebbe7d115865fba84687df984d4d09e626cd" translate="yes" xml:space="preserve">
          <source>Iter::cloned</source>
          <target state="translated">Iter::cloned</target>
        </trans-unit>
        <trans-unit id="49fa3b568d34193bae851426004f13121d5dfbf5" translate="yes" xml:space="preserve">
          <source>Iter::cmp</source>
          <target state="translated">Iter::cmp</target>
        </trans-unit>
        <trans-unit id="8a894f2ab589ed2151abc86111334156ce8c99e0" translate="yes" xml:space="preserve">
          <source>Iter::collect</source>
          <target state="translated">Iter::collect</target>
        </trans-unit>
        <trans-unit id="d84a1dc76269ab42456219572352b77058751d5b" translate="yes" xml:space="preserve">
          <source>Iter::copied</source>
          <target state="translated">Iter::copied</target>
        </trans-unit>
        <trans-unit id="e3337214a7610ab020e239ae370944a464cce517" translate="yes" xml:space="preserve">
          <source>Iter::count</source>
          <target state="translated">Iter::count</target>
        </trans-unit>
        <trans-unit id="e2ed51e9cb2227202dee5fc9ebaab5c5c44fe8c9" translate="yes" xml:space="preserve">
          <source>Iter::cycle</source>
          <target state="translated">Iter::cycle</target>
        </trans-unit>
        <trans-unit id="b1eb95f6c453fe7f1cf4909e898eaf13d79e9e40" translate="yes" xml:space="preserve">
          <source>Iter::enumerate</source>
          <target state="translated">Iter::enumerate</target>
        </trans-unit>
        <trans-unit id="f2edb3630485a9830839e0b2bd5394c408a64499" translate="yes" xml:space="preserve">
          <source>Iter::eq</source>
          <target state="translated">Iter::eq</target>
        </trans-unit>
        <trans-unit id="f27a886f8dd8072bf872054aa4fa798de4583d5b" translate="yes" xml:space="preserve">
          <source>Iter::filter</source>
          <target state="translated">Iter::filter</target>
        </trans-unit>
        <trans-unit id="9f085b504d73e51e20340f0c14d7d3ec20d8c09e" translate="yes" xml:space="preserve">
          <source>Iter::filter_map</source>
          <target state="translated">Iter::filter_map</target>
        </trans-unit>
        <trans-unit id="482d391704ccfc6551b38406a5c7e4a07c0b7dc9" translate="yes" xml:space="preserve">
          <source>Iter::find</source>
          <target state="translated">Iter::find</target>
        </trans-unit>
        <trans-unit id="cf9a0662f2645651e697db323db99571753cf8fe" translate="yes" xml:space="preserve">
          <source>Iter::find_map</source>
          <target state="translated">Iter::find_map</target>
        </trans-unit>
        <trans-unit id="1afb3fc5d230f5ed3a998d62e9235b71e0c70e53" translate="yes" xml:space="preserve">
          <source>Iter::flat_map</source>
          <target state="translated">Iter::flat_map</target>
        </trans-unit>
        <trans-unit id="233b4826a12d699f0512cb0d95df19aaab9dd4ca" translate="yes" xml:space="preserve">
          <source>Iter::flatten</source>
          <target state="translated">Iter::flatten</target>
        </trans-unit>
        <trans-unit id="7f47a4f5f722efa8de94b21b465ada55ddfa53c5" translate="yes" xml:space="preserve">
          <source>Iter::fmt</source>
          <target state="translated">Iter::fmt</target>
        </trans-unit>
        <trans-unit id="2d150a20937e50aeb5fc3c33739f77c30ca57b98" translate="yes" xml:space="preserve">
          <source>Iter::fold</source>
          <target state="translated">Iter::fold</target>
        </trans-unit>
        <trans-unit id="9ee0b5e31b874c88b499b0f63ac35f2da29dcbb1" translate="yes" xml:space="preserve">
          <source>Iter::for_each</source>
          <target state="translated">Iter::for_each</target>
        </trans-unit>
        <trans-unit id="fb5570128f1baf2cde42d918eac6ebeb0e442ac8" translate="yes" xml:space="preserve">
          <source>Iter::from</source>
          <target state="translated">Iter::from</target>
        </trans-unit>
        <trans-unit id="840450e607dae83abf8fa2b370c6fb1be77c898b" translate="yes" xml:space="preserve">
          <source>Iter::fuse</source>
          <target state="translated">Iter::fuse</target>
        </trans-unit>
        <trans-unit id="23bdea91405b4acdaeed6b4d07b8c58d93cbd9ee" translate="yes" xml:space="preserve">
          <source>Iter::ge</source>
          <target state="translated">Iter::ge</target>
        </trans-unit>
        <trans-unit id="47e26389513b5fb9c312c18d98dfcb98e224fec9" translate="yes" xml:space="preserve">
          <source>Iter::gt</source>
          <target state="translated">Iter::gt</target>
        </trans-unit>
        <trans-unit id="ce4e0788e86ba75e4d44e53b0367cc1f2f04da63" translate="yes" xml:space="preserve">
          <source>Iter::inspect</source>
          <target state="translated">Iter::inspect</target>
        </trans-unit>
        <trans-unit id="84b381fb810d521e23ba1af41b818ce7d2699ac5" translate="yes" xml:space="preserve">
          <source>Iter::into</source>
          <target state="translated">Iter::into</target>
        </trans-unit>
        <trans-unit id="0ec8b2c7e9866e4932264828ae5ae53473579659" translate="yes" xml:space="preserve">
          <source>Iter::into_iter</source>
          <target state="translated">Iter::into_iter</target>
        </trans-unit>
        <trans-unit id="fef12e1b5037aa29137e1d32a9384c2c3b1a9d46" translate="yes" xml:space="preserve">
          <source>Iter::is_empty</source>
          <target state="translated">Iter::is_empty</target>
        </trans-unit>
        <trans-unit id="c845a405850165bfe2d3ee71bdc1256c40185ebf" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted</source>
          <target state="translated">Iter::is_sorted</target>
        </trans-unit>
        <trans-unit id="12877f076c9cd1f4b18bb0043ef86e4ecaae9828" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted_by</source>
          <target state="translated">Iter::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="20997a51f1e8798fb3f3c383fb60434b3e8cb926" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted_by_key</source>
          <target state="translated">Iter::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b86d7151989059491e48352d38e9c3a298578cd1" translate="yes" xml:space="preserve">
          <source>Iter::last</source>
          <target state="translated">Iter::last</target>
        </trans-unit>
        <trans-unit id="be8b408760eecdbf28c58c97d461c17d4700ffae" translate="yes" xml:space="preserve">
          <source>Iter::le</source>
          <target state="translated">Iter::le</target>
        </trans-unit>
        <trans-unit id="0c6655f000bb8d852e4c2ebc7d52bd9826150f55" translate="yes" xml:space="preserve">
          <source>Iter::len</source>
          <target state="translated">Iter::len</target>
        </trans-unit>
        <trans-unit id="f5f969c8865a706d946ba8d9640ca2c5a0bcf40e" translate="yes" xml:space="preserve">
          <source>Iter::lt</source>
          <target state="translated">Iter::lt</target>
        </trans-unit>
        <trans-unit id="bc0be7886235deb5cb7d836720591efa37538450" translate="yes" xml:space="preserve">
          <source>Iter::map</source>
          <target state="translated">Iter::map</target>
        </trans-unit>
        <trans-unit id="d7746cc600a78a4b80fd8b858ffaf0fe418f31a5" translate="yes" xml:space="preserve">
          <source>Iter::max</source>
          <target state="translated">Iter::max</target>
        </trans-unit>
        <trans-unit id="bdd59dfbd93f93e5159fb6bb4b959f6208971864" translate="yes" xml:space="preserve">
          <source>Iter::max_by</source>
          <target state="translated">Iter::max_by</target>
        </trans-unit>
        <trans-unit id="f2c43a9070f91fd7b274911cb1767f64abad6d73" translate="yes" xml:space="preserve">
          <source>Iter::max_by_key</source>
          <target state="translated">Iter::max_by_key</target>
        </trans-unit>
        <trans-unit id="4953889b3e4b5985acf4e330c37581c731343efb" translate="yes" xml:space="preserve">
          <source>Iter::min</source>
          <target state="translated">Iter::min</target>
        </trans-unit>
        <trans-unit id="a4a384bc464b64ebda76930693b161019c57569b" translate="yes" xml:space="preserve">
          <source>Iter::min_by</source>
          <target state="translated">Iter::min_by</target>
        </trans-unit>
        <trans-unit id="c1b4af4d4490229831ed89e5d2564fd1a077b311" translate="yes" xml:space="preserve">
          <source>Iter::min_by_key</source>
          <target state="translated">Iter::min_by_key</target>
        </trans-unit>
        <trans-unit id="16cc992c33d00ce5220249a5220c02b65f8e4e1b" translate="yes" xml:space="preserve">
          <source>Iter::ne</source>
          <target state="translated">Iter::ne</target>
        </trans-unit>
        <trans-unit id="5726d1319a6927ed8641e6153ccd76700e05b49d" translate="yes" xml:space="preserve">
          <source>Iter::next</source>
          <target state="translated">Iter::next</target>
        </trans-unit>
        <trans-unit id="73c0a4abe0cf04469092e41f4f2fe0440e2dba4e" translate="yes" xml:space="preserve">
          <source>Iter::next_back</source>
          <target state="translated">Iter::next_back</target>
        </trans-unit>
        <trans-unit id="71ecfc9eea70a0501cbf73f369a815090a015495" translate="yes" xml:space="preserve">
          <source>Iter::nth</source>
          <target state="translated">Iter::nth</target>
        </trans-unit>
        <trans-unit id="c585764b69dade897771dda3b24e4c7fa05c8894" translate="yes" xml:space="preserve">
          <source>Iter::nth_back</source>
          <target state="translated">Iter::nth_back</target>
        </trans-unit>
        <trans-unit id="f0d7a323f948a119f8ad33ad48acc983a8d68fd3" translate="yes" xml:space="preserve">
          <source>Iter::partial_cmp</source>
          <target state="translated">Iter::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d508da27672fef4e1401a3134f511ffdb76349df" translate="yes" xml:space="preserve">
          <source>Iter::partition</source>
          <target state="translated">Iter::partition</target>
        </trans-unit>
        <trans-unit id="b7e23f6eab45233e924f47870e7155a7d93ac461" translate="yes" xml:space="preserve">
          <source>Iter::peekable</source>
          <target state="translated">Iter::peekable</target>
        </trans-unit>
        <trans-unit id="c6069463aa7c4524fc50e7f8524606571f2479a2" translate="yes" xml:space="preserve">
          <source>Iter::position</source>
          <target state="translated">Iter::position</target>
        </trans-unit>
        <trans-unit id="49a5d1c1b47f8042ecc9f92065cab6ee7c7e1cc2" translate="yes" xml:space="preserve">
          <source>Iter::product</source>
          <target state="translated">Iter::product</target>
        </trans-unit>
        <trans-unit id="226d371b07f791bdc3b75f6182aa99ed768f3c2f" translate="yes" xml:space="preserve">
          <source>Iter::rev</source>
          <target state="translated">Iter::rev</target>
        </trans-unit>
        <trans-unit id="0e61327392e92ba0988cedb744e914baec8d327a" translate="yes" xml:space="preserve">
          <source>Iter::rfind</source>
          <target state="translated">Iter::rfind</target>
        </trans-unit>
        <trans-unit id="436b05314063cdc717e75ffae43d2197b71db43d" translate="yes" xml:space="preserve">
          <source>Iter::rfold</source>
          <target state="translated">Iter::rfold</target>
        </trans-unit>
        <trans-unit id="ff90d1def598911fc5bfcb191f5cc4a07e4d1561" translate="yes" xml:space="preserve">
          <source>Iter::rposition</source>
          <target state="translated">Iter::rposition</target>
        </trans-unit>
        <trans-unit id="e85d8810cc5f5069c23f9a8039d15b9337b41c52" translate="yes" xml:space="preserve">
          <source>Iter::scan</source>
          <target state="translated">Iter::scan</target>
        </trans-unit>
        <trans-unit id="02418ffbb8d48f42372da15dae730f8a6afc35b5" translate="yes" xml:space="preserve">
          <source>Iter::size_hint</source>
          <target state="translated">Iter::size_hint</target>
        </trans-unit>
        <trans-unit id="4369939a1ce2e9f84ffb9bdab8e42a905e51bdaa" translate="yes" xml:space="preserve">
          <source>Iter::skip</source>
          <target state="translated">Iter::skip</target>
        </trans-unit>
        <trans-unit id="366d06ce202700d06e1162480b372fb9fe5f9f48" translate="yes" xml:space="preserve">
          <source>Iter::skip_while</source>
          <target state="translated">Iter::skip_while</target>
        </trans-unit>
        <trans-unit id="32cde76eb29f240c9e4df839757b9c8dee038962" translate="yes" xml:space="preserve">
          <source>Iter::step_by</source>
          <target state="translated">Iter::step_by</target>
        </trans-unit>
        <trans-unit id="17f9c830155902444763f7911cd38ce5759e0af8" translate="yes" xml:space="preserve">
          <source>Iter::sum</source>
          <target state="translated">Iter::sum</target>
        </trans-unit>
        <trans-unit id="dcb50b3349dc76f0b288cc8da46262ff9851d3ff" translate="yes" xml:space="preserve">
          <source>Iter::take</source>
          <target state="translated">Iter::take</target>
        </trans-unit>
        <trans-unit id="cde2481711540ccdcb763463f9a8e48ead5b8c11" translate="yes" xml:space="preserve">
          <source>Iter::take_while</source>
          <target state="translated">Iter::take_while</target>
        </trans-unit>
        <trans-unit id="7be8f868236c0bacde7fa60a245f689dbd73f4b1" translate="yes" xml:space="preserve">
          <source>Iter::to_owned</source>
          <target state="translated">Iter::to_owned</target>
        </trans-unit>
        <trans-unit id="a61b9bdc8bf2d65e849104ea9f9ddb34b2e438f1" translate="yes" xml:space="preserve">
          <source>Iter::try_fold</source>
          <target state="translated">Iter::try_fold</target>
        </trans-unit>
        <trans-unit id="a376d6605801d1f94fdc5bc8378bfb7d3bf0f291" translate="yes" xml:space="preserve">
          <source>Iter::try_for_each</source>
          <target state="translated">Iter::try_for_each</target>
        </trans-unit>
        <trans-unit id="4742b7e7ce2dc63b3cde1feac9ff7841b386d97b" translate="yes" xml:space="preserve">
          <source>Iter::try_from</source>
          <target state="translated">Iter::try_from</target>
        </trans-unit>
        <trans-unit id="305f66fe9d6f3bd4da9108c4fb964e6d3d7ae558" translate="yes" xml:space="preserve">
          <source>Iter::try_into</source>
          <target state="translated">Iter::try_into</target>
        </trans-unit>
        <trans-unit id="28e819d5eb5da6c1ca2f6898d2a9682f6bd3113c" translate="yes" xml:space="preserve">
          <source>Iter::try_rfold</source>
          <target state="translated">Iter::try_rfold</target>
        </trans-unit>
        <trans-unit id="5431b8f7a2f8d57a1b9712ca70970d17da1898b4" translate="yes" xml:space="preserve">
          <source>Iter::type_id</source>
          <target state="translated">Iter::type_id</target>
        </trans-unit>
        <trans-unit id="ba93aa487eb63805115eee9259cd946bbcc81dc7" translate="yes" xml:space="preserve">
          <source>Iter::unzip</source>
          <target state="translated">Iter::unzip</target>
        </trans-unit>
        <trans-unit id="2eb63393ea4d4a003b71033749175816e8e34fdf" translate="yes" xml:space="preserve">
          <source>Iter::zip</source>
          <target state="translated">Iter::zip</target>
        </trans-unit>
        <trans-unit id="685f18edffd1064c20f2b29242001a402ffdb3fc" translate="yes" xml:space="preserve">
          <source>IterMut</source>
          <target state="translated">IterMut</target>
        </trans-unit>
        <trans-unit id="d15ac12246998b60e4436683e1d97cc9ae701e03" translate="yes" xml:space="preserve">
          <source>IterMut::all</source>
          <target state="translated">IterMut::all</target>
        </trans-unit>
        <trans-unit id="c1e555b3dfd69f8056e360cb14a2a01feb0013e6" translate="yes" xml:space="preserve">
          <source>IterMut::any</source>
          <target state="translated">IterMut::any</target>
        </trans-unit>
        <trans-unit id="fbe3dac2bb3b890d1d56cbc2f3fa0126fa2d43e8" translate="yes" xml:space="preserve">
          <source>IterMut::as_slice</source>
          <target state="translated">IterMut::as_slice</target>
        </trans-unit>
        <trans-unit id="0a947d1a8be02e41fa37714da075d627e9a6d6da" translate="yes" xml:space="preserve">
          <source>IterMut::borrow</source>
          <target state="translated">IterMut::borrow</target>
        </trans-unit>
        <trans-unit id="f88bb4554293b88f8dc1c8bb69415e923325b965" translate="yes" xml:space="preserve">
          <source>IterMut::borrow_mut</source>
          <target state="translated">IterMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="48fa60a837a6bc036bd0c7d9497e19c4f719ec84" translate="yes" xml:space="preserve">
          <source>IterMut::by_ref</source>
          <target state="translated">IterMut::by_ref</target>
        </trans-unit>
        <trans-unit id="f5d9bc35cc15ce8be47292ce1998b21d7b90f454" translate="yes" xml:space="preserve">
          <source>IterMut::chain</source>
          <target state="translated">IterMut::chain</target>
        </trans-unit>
        <trans-unit id="4859f67bc45d1cfa5be5d41026dcf3b89772eceb" translate="yes" xml:space="preserve">
          <source>IterMut::cloned</source>
          <target state="translated">IterMut::cloned</target>
        </trans-unit>
        <trans-unit id="0680e13c44f187b2e2903bd2e1023ab5334923ea" translate="yes" xml:space="preserve">
          <source>IterMut::cmp</source>
          <target state="translated">IterMut::cmp</target>
        </trans-unit>
        <trans-unit id="a0e64fc534b3756ecdc15f5f8acaf539397a5145" translate="yes" xml:space="preserve">
          <source>IterMut::collect</source>
          <target state="translated">IterMut::collect</target>
        </trans-unit>
        <trans-unit id="95a4dd4c3dfd61737eaad683762b0bc7a7f9e7fc" translate="yes" xml:space="preserve">
          <source>IterMut::copied</source>
          <target state="translated">IterMut::copied</target>
        </trans-unit>
        <trans-unit id="5766f26143f5bcf6f3046a585e17bcfe339aad1e" translate="yes" xml:space="preserve">
          <source>IterMut::count</source>
          <target state="translated">IterMut::count</target>
        </trans-unit>
        <trans-unit id="b687092d76c8cc05745b7269130d0abfdaca355d" translate="yes" xml:space="preserve">
          <source>IterMut::cycle</source>
          <target state="translated">IterMut::cycle</target>
        </trans-unit>
        <trans-unit id="6d2db6ed0889c67bb6b498f2b3f67091fe29b968" translate="yes" xml:space="preserve">
          <source>IterMut::enumerate</source>
          <target state="translated">IterMut::enumerate</target>
        </trans-unit>
        <trans-unit id="fb228b5c55ad8378b706b298cb18e19a8d1b92e0" translate="yes" xml:space="preserve">
          <source>IterMut::eq</source>
          <target state="translated">IterMut::eq</target>
        </trans-unit>
        <trans-unit id="10b9735610da183bc0904cfcdc41b325717c5fa4" translate="yes" xml:space="preserve">
          <source>IterMut::filter</source>
          <target state="translated">IterMut::filter</target>
        </trans-unit>
        <trans-unit id="50b5344a605daa6db154682749d39063c82b3aa3" translate="yes" xml:space="preserve">
          <source>IterMut::filter_map</source>
          <target state="translated">IterMut::filter_map</target>
        </trans-unit>
        <trans-unit id="bc7ee8167e059bacfd966b6012e519970cd73008" translate="yes" xml:space="preserve">
          <source>IterMut::find</source>
          <target state="translated">IterMut::find</target>
        </trans-unit>
        <trans-unit id="410d4ebdc94090e744fedb731647c7ec0d8578cc" translate="yes" xml:space="preserve">
          <source>IterMut::find_map</source>
          <target state="translated">IterMut::find_map</target>
        </trans-unit>
        <trans-unit id="65e5eda673bd31f19324431c366d3dfedb17fb01" translate="yes" xml:space="preserve">
          <source>IterMut::flat_map</source>
          <target state="translated">IterMut::flat_map</target>
        </trans-unit>
        <trans-unit id="b284560776dd5bb1ff4273557604dbb2553c7c07" translate="yes" xml:space="preserve">
          <source>IterMut::flatten</source>
          <target state="translated">IterMut::flatten</target>
        </trans-unit>
        <trans-unit id="ab0f6e0b99bf1433157d69dc73b614b9ae6780fe" translate="yes" xml:space="preserve">
          <source>IterMut::fmt</source>
          <target state="translated">IterMut::fmt</target>
        </trans-unit>
        <trans-unit id="4b759c2db23677552fe4a6582ff9535f267cf416" translate="yes" xml:space="preserve">
          <source>IterMut::fold</source>
          <target state="translated">IterMut::fold</target>
        </trans-unit>
        <trans-unit id="ff2b68bb585bc2eef74e222255298430657bd568" translate="yes" xml:space="preserve">
          <source>IterMut::for_each</source>
          <target state="translated">IterMut::for_each</target>
        </trans-unit>
        <trans-unit id="a33e41fe818af66e485ef7d3667b7d969b562154" translate="yes" xml:space="preserve">
          <source>IterMut::from</source>
          <target state="translated">IterMut::from</target>
        </trans-unit>
        <trans-unit id="b0e6a8de88a1b4c1f800636e965b45722312ad0f" translate="yes" xml:space="preserve">
          <source>IterMut::fuse</source>
          <target state="translated">IterMut::fuse</target>
        </trans-unit>
        <trans-unit id="664fd7bab24c7daac348bb72a1609830e80d691b" translate="yes" xml:space="preserve">
          <source>IterMut::ge</source>
          <target state="translated">IterMut::ge</target>
        </trans-unit>
        <trans-unit id="6bfb9c74b746559572b1cb3b3a42167374cd95d6" translate="yes" xml:space="preserve">
          <source>IterMut::gt</source>
          <target state="translated">IterMut::gt</target>
        </trans-unit>
        <trans-unit id="661eb528c55fa69d49ca565e9e26cfd5ddfff9bb" translate="yes" xml:space="preserve">
          <source>IterMut::inspect</source>
          <target state="translated">IterMut::inspect</target>
        </trans-unit>
        <trans-unit id="0085a0c4d6891c0fa655511a1f17f0c6798fffe3" translate="yes" xml:space="preserve">
          <source>IterMut::into</source>
          <target state="translated">IterMut::into</target>
        </trans-unit>
        <trans-unit id="f9d872a7753c37096516c695a54e36bf555e681e" translate="yes" xml:space="preserve">
          <source>IterMut::into_iter</source>
          <target state="translated">IterMut::into_iter</target>
        </trans-unit>
        <trans-unit id="56c9e9ebed846a8f50f7cd23275cf61e51741490" translate="yes" xml:space="preserve">
          <source>IterMut::into_slice</source>
          <target state="translated">IterMut::into_slice</target>
        </trans-unit>
        <trans-unit id="85db2b71d3d95945de22fd6957284758e551f164" translate="yes" xml:space="preserve">
          <source>IterMut::is_empty</source>
          <target state="translated">IterMut::is_empty</target>
        </trans-unit>
        <trans-unit id="057c3534bd6c2db79908fbeb1a2667df6a91093f" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted</source>
          <target state="translated">IterMut::is_sorted</target>
        </trans-unit>
        <trans-unit id="f6db0e52cbdd1cc2839465c01104f6e07b7e10a1" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted_by</source>
          <target state="translated">IterMut::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="946b50eea7f94363f84f06fd925cc2268637ae6d" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted_by_key</source>
          <target state="translated">IterMut::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="65af3e32ba1cf5aa400435aa3fc4596f2e5a4e39" translate="yes" xml:space="preserve">
          <source>IterMut::last</source>
          <target state="translated">IterMut::last</target>
        </trans-unit>
        <trans-unit id="7443e3959cb51f380b4aef241caca0a305e10720" translate="yes" xml:space="preserve">
          <source>IterMut::le</source>
          <target state="translated">IterMut::le</target>
        </trans-unit>
        <trans-unit id="1762aa132da5d0386a5ab5fa889856d0873e884a" translate="yes" xml:space="preserve">
          <source>IterMut::len</source>
          <target state="translated">IterMut::len</target>
        </trans-unit>
        <trans-unit id="e9d8a70597f6275813f3185cc0aa3025f469551a" translate="yes" xml:space="preserve">
          <source>IterMut::lt</source>
          <target state="translated">IterMut::lt</target>
        </trans-unit>
        <trans-unit id="a21d9b76e7d9ffcd6558423c0bce4cbb10973697" translate="yes" xml:space="preserve">
          <source>IterMut::map</source>
          <target state="translated">IterMut::map</target>
        </trans-unit>
        <trans-unit id="c3e262249b1040974db8d46e55cbdb196ff35924" translate="yes" xml:space="preserve">
          <source>IterMut::max</source>
          <target state="translated">IterMut::max</target>
        </trans-unit>
        <trans-unit id="45f2597a4580057864afc9b38782024b25dbed8f" translate="yes" xml:space="preserve">
          <source>IterMut::max_by</source>
          <target state="translated">IterMut::max_by</target>
        </trans-unit>
        <trans-unit id="4cfc9346f59180a900cadc955b42333b50460424" translate="yes" xml:space="preserve">
          <source>IterMut::max_by_key</source>
          <target state="translated">IterMut::max_by_key</target>
        </trans-unit>
        <trans-unit id="ae960d89241a17cf377151468fe032b6642a741c" translate="yes" xml:space="preserve">
          <source>IterMut::min</source>
          <target state="translated">IterMut::min</target>
        </trans-unit>
        <trans-unit id="6afc2639b644683e7d150f8f0a89926a274e7f5d" translate="yes" xml:space="preserve">
          <source>IterMut::min_by</source>
          <target state="translated">IterMut::min_by</target>
        </trans-unit>
        <trans-unit id="ba1f0877c3ded4eb9fc2eca35f95a34f57a1aa87" translate="yes" xml:space="preserve">
          <source>IterMut::min_by_key</source>
          <target state="translated">IterMut::min_by_key</target>
        </trans-unit>
        <trans-unit id="5c517328108a7b9b0752cdfee41b31e1a02675ed" translate="yes" xml:space="preserve">
          <source>IterMut::ne</source>
          <target state="translated">IterMut::ne</target>
        </trans-unit>
        <trans-unit id="4a2e580d79a7438865d40d31a56726e9127888c8" translate="yes" xml:space="preserve">
          <source>IterMut::next</source>
          <target state="translated">IterMut::next</target>
        </trans-unit>
        <trans-unit id="139a3236402870ecd266bb0a9bc31561280b31bb" translate="yes" xml:space="preserve">
          <source>IterMut::next_back</source>
          <target state="translated">IterMut::next_back</target>
        </trans-unit>
        <trans-unit id="7bbe293cbd53f286fef36815b6c7398d20db404f" translate="yes" xml:space="preserve">
          <source>IterMut::nth</source>
          <target state="translated">IterMut::nth</target>
        </trans-unit>
        <trans-unit id="5772506353380947ff699b52a37feaee46051df3" translate="yes" xml:space="preserve">
          <source>IterMut::nth_back</source>
          <target state="translated">IterMut::nth_back</target>
        </trans-unit>
        <trans-unit id="5668de5a92d85d1071ad1f82e9ef7513d2b7bc31" translate="yes" xml:space="preserve">
          <source>IterMut::partial_cmp</source>
          <target state="translated">IterMut::partial_cmp</target>
        </trans-unit>
        <trans-unit id="a3382b312019633bbea8d455e903695ff7a81f6d" translate="yes" xml:space="preserve">
          <source>IterMut::partition</source>
          <target state="translated">IterMut::partition</target>
        </trans-unit>
        <trans-unit id="def8ddaad6d23f184f1d8f90e47c52e6771c8726" translate="yes" xml:space="preserve">
          <source>IterMut::peekable</source>
          <target state="translated">IterMut::peekable</target>
        </trans-unit>
        <trans-unit id="e4e4bcd4ad39225fe6f1d31a86b7460e74649082" translate="yes" xml:space="preserve">
          <source>IterMut::position</source>
          <target state="translated">IterMut::position</target>
        </trans-unit>
        <trans-unit id="f8e28dca24a6d5cb911b812d63ca4210ad500397" translate="yes" xml:space="preserve">
          <source>IterMut::product</source>
          <target state="translated">IterMut::product</target>
        </trans-unit>
        <trans-unit id="e40a83a0559fe372b3fe052ff00a96a4950cded6" translate="yes" xml:space="preserve">
          <source>IterMut::rev</source>
          <target state="translated">IterMut::rev</target>
        </trans-unit>
        <trans-unit id="1e68d13e84703c21f465d900fde2ea2255c05c3d" translate="yes" xml:space="preserve">
          <source>IterMut::rfind</source>
          <target state="translated">IterMut::rfind</target>
        </trans-unit>
        <trans-unit id="1071e32d4bd9d85b7bb9988ca035b92c220cbc89" translate="yes" xml:space="preserve">
          <source>IterMut::rfold</source>
          <target state="translated">IterMut::rfold</target>
        </trans-unit>
        <trans-unit id="d9ad978343710ca3ac668584e5ec56ee87a41af1" translate="yes" xml:space="preserve">
          <source>IterMut::rposition</source>
          <target state="translated">IterMut::rposition</target>
        </trans-unit>
        <trans-unit id="3d57b99fe3a36a90ffb9f9e83e9da20276fd9a22" translate="yes" xml:space="preserve">
          <source>IterMut::scan</source>
          <target state="translated">IterMut::scan</target>
        </trans-unit>
        <trans-unit id="fae924a614763f37e082883ddaabc2b87b19bf2c" translate="yes" xml:space="preserve">
          <source>IterMut::size_hint</source>
          <target state="translated">IterMut::size_hint</target>
        </trans-unit>
        <trans-unit id="709c8510ff15526b1a9b732e5db04549151388c6" translate="yes" xml:space="preserve">
          <source>IterMut::skip</source>
          <target state="translated">IterMut::skip</target>
        </trans-unit>
        <trans-unit id="c54d538f96fcc47416c4e42ffc8829538ae491ab" translate="yes" xml:space="preserve">
          <source>IterMut::skip_while</source>
          <target state="translated">IterMut::skip_while</target>
        </trans-unit>
        <trans-unit id="38fb28ea29c6bc530e47f9dad6ca847a8308a455" translate="yes" xml:space="preserve">
          <source>IterMut::step_by</source>
          <target state="translated">IterMut::step_by</target>
        </trans-unit>
        <trans-unit id="07bbba43ad63c86d9539b561228e2c22eba74a81" translate="yes" xml:space="preserve">
          <source>IterMut::sum</source>
          <target state="translated">IterMut::sum</target>
        </trans-unit>
        <trans-unit id="e4e5a5c0090d5cac8762c3c6b597e5689d25a27c" translate="yes" xml:space="preserve">
          <source>IterMut::take</source>
          <target state="translated">IterMut::take</target>
        </trans-unit>
        <trans-unit id="33dd2e99d843e213c0ddd91584e7448ac2d4b106" translate="yes" xml:space="preserve">
          <source>IterMut::take_while</source>
          <target state="translated">IterMut::take_while</target>
        </trans-unit>
        <trans-unit id="89c3c4340f9719a145ec3899304b1842903b1e8e" translate="yes" xml:space="preserve">
          <source>IterMut::try_fold</source>
          <target state="translated">IterMut::try_fold</target>
        </trans-unit>
        <trans-unit id="3ecd354292c647432d92da5022d802acbefdaf09" translate="yes" xml:space="preserve">
          <source>IterMut::try_for_each</source>
          <target state="translated">IterMut::try_for_each</target>
        </trans-unit>
        <trans-unit id="07824f2f826e7e718e59741916504b108d880d62" translate="yes" xml:space="preserve">
          <source>IterMut::try_from</source>
          <target state="translated">IterMut::try_from</target>
        </trans-unit>
        <trans-unit id="9a96ea4150cfa217a4f1dd08ae093708354d29eb" translate="yes" xml:space="preserve">
          <source>IterMut::try_into</source>
          <target state="translated">IterMut::try_into</target>
        </trans-unit>
        <trans-unit id="29aff2c0b7bfd47c5d4837ac67638482b835e70d" translate="yes" xml:space="preserve">
          <source>IterMut::try_rfold</source>
          <target state="translated">IterMut::try_rfold</target>
        </trans-unit>
        <trans-unit id="bf0e0921f0da7331cb27e7d17d9e221b70171a7a" translate="yes" xml:space="preserve">
          <source>IterMut::type_id</source>
          <target state="translated">IterMut::type_id</target>
        </trans-unit>
        <trans-unit id="7f6f9babd020f3f6641909fd4a54810ef8d5c98a" translate="yes" xml:space="preserve">
          <source>IterMut::unzip</source>
          <target state="translated">IterMut::unzip</target>
        </trans-unit>
        <trans-unit id="bbedf0cc88bd2517be640465c65b23b15a5a71ba" translate="yes" xml:space="preserve">
          <source>IterMut::zip</source>
          <target state="translated">IterMut::zip</target>
        </trans-unit>
        <trans-unit id="5de97051f4a5bf9656a21f5c9446ab6c961f1d50" translate="yes" xml:space="preserve">
          <source>Iterate over a series of values with &lt;a href=&quot;keyword.for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;keyword.for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;迭代一系列值。</target>
        </trans-unit>
        <trans-unit id="2499260c1be5541b8c3abea5b95c5cff7ca9f173" translate="yes" xml:space="preserve">
          <source>Iterate through each line of the contents.</source>
          <target state="translated">迭代每一行的内容。</target>
        </trans-unit>
        <trans-unit id="ddc1d37b3a6ff7065f6616ad5090d037179310e5" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements</source>
          <target state="translated">遍历整个迭代器,将所有元素相乘。</target>
        </trans-unit>
        <trans-unit id="12f90576d62ee51bcd72346f4eea97d035ff3fbf" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../../../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">遍历整个迭代器，将所有元素相乘&lt;a href=&quot;../../../iter/trait.iterator#method.product&quot;&gt;了解更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e32fff0b6901e0665a7a8c46f77166fe30575d0c" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">遍历整个迭代器，将所有元素相乘&lt;a href=&quot;../../iter/trait.iterator#method.product&quot;&gt;了解更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ba661f58c25c048da380a890db7f86c82d555ed" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">遍历整个迭代器，将所有元素相乘&lt;a href=&quot;../iter/trait.iterator#method.product&quot;&gt;了解更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e40697331454225ecb2ac731fb00044a53174cc1" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">遍历整个迭代器，将所有元素相乘&lt;a href=&quot;iter/trait.iterator#method.product&quot;&gt;了解更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba2858c97778cf6ff78dc3d4e578f6ce94c7f587" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">遍历整个迭代器，将所有元素相乘&lt;a href=&quot;trait.iterator#method.product&quot;&gt;了解更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0dff502cf70a8cb10dd882dfdf098dc4aa48cf1e" translate="yes" xml:space="preserve">
          <source>Iterates over the slice &lt;code&gt;other&lt;/code&gt;, clones each element, and then appends it to this &lt;code&gt;Vec&lt;/code&gt;. The &lt;code&gt;other&lt;/code&gt; vector is traversed in-order.</source>
          <target state="translated">在切片迭代 &lt;code&gt;other&lt;/code&gt; ，克隆各元件，然后将其附加到这个 &lt;code&gt;Vec&lt;/code&gt; 。的 &lt;code&gt;other&lt;/code&gt; 矢量按顺序遍历。</target>
        </trans-unit>
        <trans-unit id="5d265d453acaa19c0ae15ceee2e6a72145e4e232" translate="yes" xml:space="preserve">
          <source>Iterating Through Lines with the &lt;code id=&quot;iterating-through-lines-with-the-lines-method&quot;&gt;lines&lt;/code&gt; Method</source>
          <target state="translated">使用 &lt;code id=&quot;iterating-through-lines-with-the-lines-method&quot;&gt;lines&lt;/code&gt; 方法遍历线路</target>
        </trans-unit>
        <trans-unit id="9232973e4659ad95034977407f818f02bad0423b" translate="yes" xml:space="preserve">
          <source>Iterating over the Values in a Vector</source>
          <target state="translated">迭代向量中的值</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="4bbe26c7d68240e48a823975e3e785a737635548" translate="yes" xml:space="preserve">
          <source>Iteration with &lt;a href=&quot;keyword.in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;, trait implementation with &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../reference/trait-bounds#higher-ranked-trait-bounds&quot;&gt;higher-ranked trait bounds&lt;/a&gt; (&lt;code&gt;for&amp;lt;'a&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">使用&lt;a href=&quot;keyword.in&quot;&gt; &lt;code&gt;in&lt;/code&gt; 进行&lt;/a&gt;迭代，使用&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; 进行&lt;/a&gt;特性实现或使用&lt;a href=&quot;../reference/trait-bounds#higher-ranked-trait-bounds&quot;&gt;更高阶的特性边界&lt;/a&gt;（ &lt;code&gt;for&amp;lt;'a&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="9423090682be31506d3158301d684f4abe89d00e" translate="yes" xml:space="preserve">
          <source>Iterator behavior</source>
          <target state="translated">迭代器行为</target>
        </trans-unit>
        <trans-unit id="bb7528b69192612888be1c4ce8f89b0e0e581862" translate="yes" xml:space="preserve">
          <source>Iterator loops</source>
          <target state="translated">迭代器循环</target>
        </trans-unit>
        <trans-unit id="d19530e5d03b36f27c9d84864c3b65bb57584a79" translate="yes" xml:space="preserve">
          <source>Iterator over the entries in a directory.</source>
          <target state="translated">对目录中的条目进行迭代。</target>
        </trans-unit>
        <trans-unit id="ba33042f2a1b69e3f8c089958f5c5514f1643aee" translate="yes" xml:space="preserve">
          <source>Iterator types</source>
          <target state="translated">迭代器类型</target>
        </trans-unit>
        <trans-unit id="4273ec271075233286703458c7e9ebc00e2e82df" translate="yes" xml:space="preserve">
          <source>Iterator::all</source>
          <target state="translated">Iterator::all</target>
        </trans-unit>
        <trans-unit id="f86c54ca12225c13236cdc3a624968944761ea05" translate="yes" xml:space="preserve">
          <source>Iterator::any</source>
          <target state="translated">Iterator::any</target>
        </trans-unit>
        <trans-unit id="d57ec500fe9ec2bba36378c03fe82c9f66576f38" translate="yes" xml:space="preserve">
          <source>Iterator::by_ref</source>
          <target state="translated">Iterator::by_ref</target>
        </trans-unit>
        <trans-unit id="eee7519010a092f18111fa15dd804b221949785a" translate="yes" xml:space="preserve">
          <source>Iterator::chain</source>
          <target state="translated">Iterator::chain</target>
        </trans-unit>
        <trans-unit id="2737cab8dbd36c284c2d2a04345b6f802d76520e" translate="yes" xml:space="preserve">
          <source>Iterator::cloned</source>
          <target state="translated">Iterator::cloned</target>
        </trans-unit>
        <trans-unit id="4d53642d0597c543ebd99c70d62ee5234be120ee" translate="yes" xml:space="preserve">
          <source>Iterator::cmp</source>
          <target state="translated">Iterator::cmp</target>
        </trans-unit>
        <trans-unit id="6840be4400b24989a5f3ee01f218588655855ede" translate="yes" xml:space="preserve">
          <source>Iterator::collect</source>
          <target state="translated">Iterator::collect</target>
        </trans-unit>
        <trans-unit id="afd3fcee84d868df85114f2c2de87906ba8b73fd" translate="yes" xml:space="preserve">
          <source>Iterator::copied</source>
          <target state="translated">Iterator::copied</target>
        </trans-unit>
        <trans-unit id="65c267a3908408f21f20c7542c580b394c3ac479" translate="yes" xml:space="preserve">
          <source>Iterator::count</source>
          <target state="translated">Iterator::count</target>
        </trans-unit>
        <trans-unit id="a62029a441e5502574f74110e73622b6c124b195" translate="yes" xml:space="preserve">
          <source>Iterator::cycle</source>
          <target state="translated">Iterator::cycle</target>
        </trans-unit>
        <trans-unit id="4cf31dbb9795763807136c75aa5ab726e70ab4da" translate="yes" xml:space="preserve">
          <source>Iterator::enumerate</source>
          <target state="translated">Iterator::enumerate</target>
        </trans-unit>
        <trans-unit id="e54da00842cf3d69c5bb79f7e6ff037be7b7d1eb" translate="yes" xml:space="preserve">
          <source>Iterator::eq</source>
          <target state="translated">Iterator::eq</target>
        </trans-unit>
        <trans-unit id="7cf8c3afdf60282496111d5e9294d886ba58ff32" translate="yes" xml:space="preserve">
          <source>Iterator::filter</source>
          <target state="translated">Iterator::filter</target>
        </trans-unit>
        <trans-unit id="d6f882e7564be02de62cc36c2cb255e404103b69" translate="yes" xml:space="preserve">
          <source>Iterator::filter_map</source>
          <target state="translated">Iterator::filter_map</target>
        </trans-unit>
        <trans-unit id="8bad19b292d0ba35dd2b96e68725fc1ecca7ab20" translate="yes" xml:space="preserve">
          <source>Iterator::find</source>
          <target state="translated">Iterator::find</target>
        </trans-unit>
        <trans-unit id="3ea058ee3e827f8722e557a5ed69196b9d69ffef" translate="yes" xml:space="preserve">
          <source>Iterator::find_map</source>
          <target state="translated">Iterator::find_map</target>
        </trans-unit>
        <trans-unit id="fb5d2f94b065377a6651ac4b6316f941b8a73d83" translate="yes" xml:space="preserve">
          <source>Iterator::flat_map</source>
          <target state="translated">Iterator::flat_map</target>
        </trans-unit>
        <trans-unit id="111068d32ae21f272191794cb73558e1cac98f8c" translate="yes" xml:space="preserve">
          <source>Iterator::flatten</source>
          <target state="translated">Iterator::flatten</target>
        </trans-unit>
        <trans-unit id="43a4b81bd3319dd7c1f643ea1239981100f2bfe0" translate="yes" xml:space="preserve">
          <source>Iterator::fold</source>
          <target state="translated">Iterator::fold</target>
        </trans-unit>
        <trans-unit id="4b6d8e0bb7e0875f730af26e464f2d7f56787c00" translate="yes" xml:space="preserve">
          <source>Iterator::for_each</source>
          <target state="translated">Iterator::for_each</target>
        </trans-unit>
        <trans-unit id="d331641f18373a947667fdd994090cbdbe5e56e3" translate="yes" xml:space="preserve">
          <source>Iterator::fuse</source>
          <target state="translated">Iterator::fuse</target>
        </trans-unit>
        <trans-unit id="a1d0aae8a33bedb12212f917dec98beb3c31719d" translate="yes" xml:space="preserve">
          <source>Iterator::ge</source>
          <target state="translated">Iterator::ge</target>
        </trans-unit>
        <trans-unit id="d02804beda6f63be283b340587c424846986c214" translate="yes" xml:space="preserve">
          <source>Iterator::gt</source>
          <target state="translated">Iterator::gt</target>
        </trans-unit>
        <trans-unit id="f6f98700823020b1af15767f0fd9cf51cc5b3580" translate="yes" xml:space="preserve">
          <source>Iterator::inspect</source>
          <target state="translated">Iterator::inspect</target>
        </trans-unit>
        <trans-unit id="2b970d2781d8419238596de0ecda94a2ec01de0f" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted</source>
          <target state="translated">Iterator::is_sorted</target>
        </trans-unit>
        <trans-unit id="856d4b939b6e2b1172c61d2fab65a6f2f22d06a3" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted_by</source>
          <target state="translated">Iterator::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d2695a4fa6c8f77acecd3c782968648c5c7e47f" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted_by_key</source>
          <target state="translated">Iterator::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="fc7204aa1fca5db78599c8ff71f528a152d2799f" translate="yes" xml:space="preserve">
          <source>Iterator::last</source>
          <target state="translated">Iterator::last</target>
        </trans-unit>
        <trans-unit id="89a83249a4c0370a4e7fe4b445980fe3d4bdb85b" translate="yes" xml:space="preserve">
          <source>Iterator::le</source>
          <target state="translated">Iterator::le</target>
        </trans-unit>
        <trans-unit id="3de38ebedca0b7133046aaeeabbf64a22e912ef4" translate="yes" xml:space="preserve">
          <source>Iterator::lt</source>
          <target state="translated">Iterator::lt</target>
        </trans-unit>
        <trans-unit id="791a1e23f54e2b3d01c25daf21bceda253396401" translate="yes" xml:space="preserve">
          <source>Iterator::map</source>
          <target state="translated">Iterator::map</target>
        </trans-unit>
        <trans-unit id="14ca2127fd3ab1a13326b57f93a743807d4a385a" translate="yes" xml:space="preserve">
          <source>Iterator::max</source>
          <target state="translated">Iterator::max</target>
        </trans-unit>
        <trans-unit id="73c5938125fe2dda5817351036d306957ab62fdf" translate="yes" xml:space="preserve">
          <source>Iterator::max_by</source>
          <target state="translated">Iterator::max_by</target>
        </trans-unit>
        <trans-unit id="0d48dc0112caa2401ba3e6305374cbe9d9f62de6" translate="yes" xml:space="preserve">
          <source>Iterator::max_by_key</source>
          <target state="translated">Iterator::max_by_key</target>
        </trans-unit>
        <trans-unit id="1e915bf62293697842ab0cc1c78d7c4d9247f8a2" translate="yes" xml:space="preserve">
          <source>Iterator::min</source>
          <target state="translated">Iterator::min</target>
        </trans-unit>
        <trans-unit id="350a01c462ad653692ad3d7c81cc7f998b33cc7a" translate="yes" xml:space="preserve">
          <source>Iterator::min_by</source>
          <target state="translated">Iterator::min_by</target>
        </trans-unit>
        <trans-unit id="3fa40a72cbf669f1ff2dd6db52b49bf6e29072d6" translate="yes" xml:space="preserve">
          <source>Iterator::min_by_key</source>
          <target state="translated">Iterator::min_by_key</target>
        </trans-unit>
        <trans-unit id="898579db7c8bd3e1760f9dc45aebef8f31d79de6" translate="yes" xml:space="preserve">
          <source>Iterator::ne</source>
          <target state="translated">Iterator::ne</target>
        </trans-unit>
        <trans-unit id="2d360ad0443fc86aaf713ff8a07e3d0e24910e14" translate="yes" xml:space="preserve">
          <source>Iterator::next</source>
          <target state="translated">Iterator::next</target>
        </trans-unit>
        <trans-unit id="4ef73a468549da918e9ddd255430293b4d475cf4" translate="yes" xml:space="preserve">
          <source>Iterator::nth</source>
          <target state="translated">Iterator::nth</target>
        </trans-unit>
        <trans-unit id="6430563009c292bd461b9dbdbc8efbc87ed667e5" translate="yes" xml:space="preserve">
          <source>Iterator::partial_cmp</source>
          <target state="translated">Iterator::partial_cmp</target>
        </trans-unit>
        <trans-unit id="38feb7e4eded7516cbc44a5b7ae390dbea8a1c5f" translate="yes" xml:space="preserve">
          <source>Iterator::partition</source>
          <target state="translated">Iterator::partition</target>
        </trans-unit>
        <trans-unit id="b1d4b5a349a9bfe583ffe37ec59e50ccad659479" translate="yes" xml:space="preserve">
          <source>Iterator::peekable</source>
          <target state="translated">Iterator::peekable</target>
        </trans-unit>
        <trans-unit id="6ffb8dda5bc3637bf0fea7d50ee2879f36477dbd" translate="yes" xml:space="preserve">
          <source>Iterator::position</source>
          <target state="translated">Iterator::position</target>
        </trans-unit>
        <trans-unit id="ec1b6d5e61cc3a26f25348b0a2e1ad79bbac1c52" translate="yes" xml:space="preserve">
          <source>Iterator::product</source>
          <target state="translated">Iterator::product</target>
        </trans-unit>
        <trans-unit id="48046e9ab82515a6dd4fd7b646f1ce53e8faac3b" translate="yes" xml:space="preserve">
          <source>Iterator::rev</source>
          <target state="translated">Iterator::rev</target>
        </trans-unit>
        <trans-unit id="67f9a990bd064873346b5c9e2d17fe35c839d67c" translate="yes" xml:space="preserve">
          <source>Iterator::rposition</source>
          <target state="translated">Iterator::rposition</target>
        </trans-unit>
        <trans-unit id="ff5bd4337968d7f15fa02188bc9ec8899d066887" translate="yes" xml:space="preserve">
          <source>Iterator::scan</source>
          <target state="translated">Iterator::scan</target>
        </trans-unit>
        <trans-unit id="ecc32183d685c53eedf20225f612a8f2cd0d1e50" translate="yes" xml:space="preserve">
          <source>Iterator::size_hint</source>
          <target state="translated">Iterator::size_hint</target>
        </trans-unit>
        <trans-unit id="5407d981fcc2957741d940d765b5c8aeeb89a7d3" translate="yes" xml:space="preserve">
          <source>Iterator::skip</source>
          <target state="translated">Iterator::skip</target>
        </trans-unit>
        <trans-unit id="b37ac34fd4f971b4431eb07cfed110e756486a69" translate="yes" xml:space="preserve">
          <source>Iterator::skip_while</source>
          <target state="translated">Iterator::skip_while</target>
        </trans-unit>
        <trans-unit id="18e1ae8414f33fb71bfb82df82aa89205f40cf2a" translate="yes" xml:space="preserve">
          <source>Iterator::step_by</source>
          <target state="translated">Iterator::step_by</target>
        </trans-unit>
        <trans-unit id="17eae761d55f0527972d28d8efb13700ff9cd9a8" translate="yes" xml:space="preserve">
          <source>Iterator::sum</source>
          <target state="translated">Iterator::sum</target>
        </trans-unit>
        <trans-unit id="7818fb82bcb2e27b1eaf83bc4a006e1deaa87c61" translate="yes" xml:space="preserve">
          <source>Iterator::take</source>
          <target state="translated">Iterator::take</target>
        </trans-unit>
        <trans-unit id="8585d3ded5bed1eba060e171ff1f8d071aa3c3c0" translate="yes" xml:space="preserve">
          <source>Iterator::take_while</source>
          <target state="translated">Iterator::take_while</target>
        </trans-unit>
        <trans-unit id="f3a0250ddc27ec143683c1a6492e90be2e63cdfb" translate="yes" xml:space="preserve">
          <source>Iterator::try_fold</source>
          <target state="translated">Iterator::try_fold</target>
        </trans-unit>
        <trans-unit id="97ee2ddc3ae8f6722d8aa8a8f03acf882d6fb21c" translate="yes" xml:space="preserve">
          <source>Iterator::try_for_each</source>
          <target state="translated">Iterator::try_for_each</target>
        </trans-unit>
        <trans-unit id="d42112e418ab0fd56186356df14c7791d504e7e2" translate="yes" xml:space="preserve">
          <source>Iterator::unzip</source>
          <target state="translated">Iterator::unzip</target>
        </trans-unit>
        <trans-unit id="2191de9c88e99f9f5438674c00e37989322ce302" translate="yes" xml:space="preserve">
          <source>Iterator::zip</source>
          <target state="translated">Iterator::zip</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="2f934a245522e136eca293cd75a09317df2f2cd7" translate="yes" xml:space="preserve">
          <source>Iterators (and iterator &lt;a href=&quot;#adapters&quot;&gt;adapters&lt;/a&gt;) are &lt;em&gt;lazy&lt;/em&gt;. This means that just creating an iterator doesn't &lt;em&gt;do&lt;/em&gt; a whole lot. Nothing really happens until you call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;. This is sometimes a source of confusion when creating an iterator solely for its side effects. For example, the &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method calls a closure on each element it iterates over:</source>
          <target state="translated">迭代器（和迭代器&lt;a href=&quot;#adapters&quot;&gt;适配器&lt;/a&gt;）是&lt;em&gt;惰性的&lt;/em&gt;。这意味着仅仅创建一个迭代器并不&lt;em&gt;能做&lt;/em&gt;很多事情。除非您打电话给&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;否则什么都不会发生。当仅出于副作用而创建迭代器时，这有时会引起混乱。例如，&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;方法在其迭代的每个元素上调用一个闭包：</target>
        </trans-unit>
        <trans-unit id="bc571c24ac50d6cee6e1818f6a078d2a419abc9e" translate="yes" xml:space="preserve">
          <source>Iterators also provide a series of &lt;em&gt;adapter&lt;/em&gt; methods for performing common threads to sequences. Among the adapters are functional favorites like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt;. Of particular interest to collections is the &lt;code&gt;rev&lt;/code&gt; adapter, that reverses any iterator that supports this operation. Most collections provide reversible iterators as the way to iterate over them in reverse order.</source>
          <target state="translated">迭代器还提供了一系列&lt;em&gt;适配器&lt;/em&gt;方法，用于对序列执行通用线程。在适配器中有功能上的收藏夹，例如 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;fold&lt;/code&gt; ， &lt;code&gt;skip&lt;/code&gt; 和 &lt;code&gt;take&lt;/code&gt; 。集合特别令人感兴趣的是 &lt;code&gt;rev&lt;/code&gt; 适配器，它可以反转支持此操作的所有迭代器。大多数集合提供可逆的迭代器，作为以相反顺序对其进行迭代的方式。</target>
        </trans-unit>
        <trans-unit id="1604a556288e09f94874ae1b1e2b1eb8eabf0eb7" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful and robust mechanism used throughout Rust's standard libraries. Iterators provide a sequence of values in a generic, safe, efficient and convenient way. The contents of an iterator are usually &lt;em&gt;lazily&lt;/em&gt; evaluated, so that only the values that are actually needed are ever actually produced, and no allocation need be done to temporarily store them. Iterators are primarily consumed using a &lt;code&gt;for&lt;/code&gt; loop, although many functions also take iterators where a collection or sequence of values is desired.</source>
          <target state="translated">迭代器是整个Rust标准库中使用的强大而强大的机制。迭代器以通用，安全，高效和便捷的方式提供一系列值。通常对迭代器的内容进行&lt;em&gt;延迟&lt;/em&gt;计算，以便仅实际生成实际需要的值，而无需进行分配即可临时存储它们。迭代器主要是通过 &lt;code&gt;for&lt;/code&gt; 循环使用的，尽管许多函数也将迭代器用于需要集合或值序列的地方。</target>
        </trans-unit>
        <trans-unit id="578d7fdeb01ae2ce26df2699ac5468054a311e64" translate="yes" xml:space="preserve">
          <source>Iterators are also composable, and it's common to chain them together to do more complex forms of processing. See the &lt;a href=&quot;#adapters&quot;&gt;Adapters&lt;/a&gt; section below for more details.</source>
          <target state="translated">迭代器也是可组合的，通常将它们链接在一起以执行更复杂的处理形式。有关更多详细信息，请参见下面的&lt;a href=&quot;#adapters&quot;&gt;适配器&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="73a40f4f406e6b8d805bf4ec3dd55761493e5309" translate="yes" xml:space="preserve">
          <source>Iterators do not have to be finite. As an example, an open-ended range is an infinite iterator:</source>
          <target state="translated">迭代器不一定是有限的。举个例子,一个开放式的范围是一个无限迭代器。</target>
        </trans-unit>
        <trans-unit id="cd7908f9004d53eb6241ef825d90a63188a57756" translate="yes" xml:space="preserve">
          <source>Iterators handle all that logic for you, cutting down on repetitive code you could potentially mess up. Iterators give you more flexibility to use the same logic with many different kinds of sequences, not just data structures you can index into, like vectors. Let&amp;rsquo;s examine how iterators do that.</source>
          <target state="translated">迭代器为您处理所有这些逻辑，从而减少了可能会造成混乱的重复代码。迭代器为您提供了更大的灵活性，可以将相同的逻辑用于许多不同种类的序列，而不仅仅是像矢量这样可以索引到的数据结构。让我们研究一下迭代器是如何做到的。</target>
        </trans-unit>
        <trans-unit id="ef660a43407868b9cb1e9e11d499fe58b2a67f0d" translate="yes" xml:space="preserve">
          <source>Iterators of known length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c70e7513b6f7cfa60a8740edd8f829825ff6ce" translate="yes" xml:space="preserve">
          <source>Iterators produce a series of values, and collections can also be thought of as a series of values. The &lt;code&gt;Extend&lt;/code&gt; trait bridges this gap, allowing you to extend a collection by including the contents of that iterator. When extending a collection with an already existing key, that entry is updated or, in the case of collections that permit multiple entries with equal keys, that entry is inserted.</source>
          <target state="translated">迭代器产生一系列值，集合也可以被视为一系列值。该 &lt;code&gt;Extend&lt;/code&gt; 特质桥梁这一差距，可以让你通过包括该迭代器的内容扩展的集合。使用现有键扩展集合时，将更新该条目；如果集合允许使用相同键的多个条目，则将插入该条目。</target>
        </trans-unit>
        <trans-unit id="36fe73edebcef37071d90c761137d6e576a12835" translate="yes" xml:space="preserve">
          <source>Iterators that dynamically terminate.</source>
          <target state="translated">动态终止的迭代器。</target>
        </trans-unit>
        <trans-unit id="c4a0156a59a95761c105c3a3e41e56a330667ccb" translate="yes" xml:space="preserve">
          <source>Iterators:</source>
          <target state="translated">Iterators:</target>
        </trans-unit>
        <trans-unit id="f0236db9f43733339562b17d0dc2c960dc9c9a8f" translate="yes" xml:space="preserve">
          <source>Its type is &lt;code&gt;'static&lt;/code&gt; duration borrowed string slice, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">它的类型是 &lt;code&gt;'static&lt;/code&gt; 持续时间借用的字符串切片， &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="9c46090b4698309dc6d00e2e6c188ead587a40e9" translate="yes" xml:space="preserve">
          <source>JoinHandle</source>
          <target state="translated">JoinHandle</target>
        </trans-unit>
        <trans-unit id="dbe795c59f1c72343d5a4f517f9ad3b4275e45c2" translate="yes" xml:space="preserve">
          <source>JoinHandle::as_pthread_t</source>
          <target state="translated">JoinHandle::as_pthread_t</target>
        </trans-unit>
        <trans-unit id="412c59894065992ad9701ec7e4a5555a722a3202" translate="yes" xml:space="preserve">
          <source>JoinHandle::as_raw_handle</source>
          <target state="translated">JoinHandle::as_raw_handle</target>
        </trans-unit>
        <trans-unit id="3cec4888e9d7b5ae79106f6aa6dc453c6917c4e8" translate="yes" xml:space="preserve">
          <source>JoinHandle::borrow</source>
          <target state="translated">JoinHandle::borrow</target>
        </trans-unit>
        <trans-unit id="fd2845c5bf15e89eb7f9f69c8adaebecb219c672" translate="yes" xml:space="preserve">
          <source>JoinHandle::borrow_mut</source>
          <target state="translated">JoinHandle::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4c3ce23926add99bcb7d4f4c43a106d00bccac89" translate="yes" xml:space="preserve">
          <source>JoinHandle::fmt</source>
          <target state="translated">JoinHandle::fmt</target>
        </trans-unit>
        <trans-unit id="f7242c7bfb17274370663c2f02ebe9f7d7c96f0f" translate="yes" xml:space="preserve">
          <source>JoinHandle::from</source>
          <target state="translated">JoinHandle::from</target>
        </trans-unit>
        <trans-unit id="d5627903ac6c6fca86247def251096015fffbc5a" translate="yes" xml:space="preserve">
          <source>JoinHandle::into</source>
          <target state="translated">JoinHandle::into</target>
        </trans-unit>
        <trans-unit id="7e1eec403cc018629f136e34f3666787322dd901" translate="yes" xml:space="preserve">
          <source>JoinHandle::into_pthread_t</source>
          <target state="translated">JoinHandle::into_pthread_t</target>
        </trans-unit>
        <trans-unit id="c6314894dabf847146013c8140ba901c5f3fc886" translate="yes" xml:space="preserve">
          <source>JoinHandle::into_raw_handle</source>
          <target state="translated">JoinHandle::into_raw_handle</target>
        </trans-unit>
        <trans-unit id="45b01c0739817e609f8d08e9f75c05ce81644422" translate="yes" xml:space="preserve">
          <source>JoinHandle::join</source>
          <target state="translated">JoinHandle::join</target>
        </trans-unit>
        <trans-unit id="c16676e74c56443eeda553ebfbb33efee8fee2c2" translate="yes" xml:space="preserve">
          <source>JoinHandle::thread</source>
          <target state="translated">JoinHandle::thread</target>
        </trans-unit>
        <trans-unit id="8607545c9c64edf874a5905869af45ed541936fc" translate="yes" xml:space="preserve">
          <source>JoinHandle::try_from</source>
          <target state="translated">JoinHandle::try_from</target>
        </trans-unit>
        <trans-unit id="5b4f897ba8176b628f13a3930ac9376591daff65" translate="yes" xml:space="preserve">
          <source>JoinHandle::try_into</source>
          <target state="translated">JoinHandle::try_into</target>
        </trans-unit>
        <trans-unit id="81095dc64ba5b13ce027669fbb3134aaf6614b5d" translate="yes" xml:space="preserve">
          <source>JoinHandle::type_id</source>
          <target state="translated">JoinHandle::type_id</target>
        </trans-unit>
        <trans-unit id="abb0b2d530b1bed37c520e95e0964bc4442ee134" translate="yes" xml:space="preserve">
          <source>JoinHandleExt</source>
          <target state="translated">JoinHandleExt</target>
        </trans-unit>
        <trans-unit id="c5dafe3d3c39e51618733fd88e0def9741b4e835" translate="yes" xml:space="preserve">
          <source>JoinPathsError</source>
          <target state="translated">JoinPathsError</target>
        </trans-unit>
        <trans-unit id="dec0bd024ba9e43e73fa5ecd613a46a6513fd917" translate="yes" xml:space="preserve">
          <source>JoinPathsError::borrow</source>
          <target state="translated">JoinPathsError::borrow</target>
        </trans-unit>
        <trans-unit id="1f287d847c80825aeaa42f5ff5c4d17823d49d12" translate="yes" xml:space="preserve">
          <source>JoinPathsError::borrow_mut</source>
          <target state="translated">JoinPathsError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="823a4e0b65b65d02ed9c70bea6734955e28b7a64" translate="yes" xml:space="preserve">
          <source>JoinPathsError::cause</source>
          <target state="translated">JoinPathsError::cause</target>
        </trans-unit>
        <trans-unit id="edc1e4fdc91ad7cadf96a809927c8b059c8a1cbe" translate="yes" xml:space="preserve">
          <source>JoinPathsError::description</source>
          <target state="translated">JoinPathsError::description</target>
        </trans-unit>
        <trans-unit id="c6c91db5b7bc4a5beebd630f559897ab6b3cea42" translate="yes" xml:space="preserve">
          <source>JoinPathsError::fmt</source>
          <target state="translated">JoinPathsError::fmt</target>
        </trans-unit>
        <trans-unit id="127ef4e1b3f565f1a2bca65f9de0550244e7bc38" translate="yes" xml:space="preserve">
          <source>JoinPathsError::from</source>
          <target state="translated">JoinPathsError::from</target>
        </trans-unit>
        <trans-unit id="8a0a4301d2f110a8e8ef605ea4bf646ad3a9581c" translate="yes" xml:space="preserve">
          <source>JoinPathsError::into</source>
          <target state="translated">JoinPathsError::into</target>
        </trans-unit>
        <trans-unit id="0693ee59f808878ad8873da2ff694215418c0ee4" translate="yes" xml:space="preserve">
          <source>JoinPathsError::source</source>
          <target state="translated">JoinPathsError::source</target>
        </trans-unit>
        <trans-unit id="b148a85037443dfc7b589e93179ee679cee0e0a2" translate="yes" xml:space="preserve">
          <source>JoinPathsError::to_string</source>
          <target state="translated">JoinPathsError::to_string</target>
        </trans-unit>
        <trans-unit id="e3d928e5001d65eef527b0e798f2ed958d4242d9" translate="yes" xml:space="preserve">
          <source>JoinPathsError::try_from</source>
          <target state="translated">JoinPathsError::try_from</target>
        </trans-unit>
        <trans-unit id="e96758935a84b6c6b7f43135aee06bfbdb4c12b7" translate="yes" xml:space="preserve">
          <source>JoinPathsError::try_into</source>
          <target state="translated">JoinPathsError::try_into</target>
        </trans-unit>
        <trans-unit id="b4849b93731305d8c42c5c2a1a4688106ef4de73" translate="yes" xml:space="preserve">
          <source>JoinPathsError::type_id</source>
          <target state="translated">JoinPathsError::type_id</target>
        </trans-unit>
        <trans-unit id="97c4f7769f9c5e2f4f5b9d5caac54744e0a9f90a" translate="yes" xml:space="preserve">
          <source>Joining a path containing a colon on a Unix-like platform results in an error:</source>
          <target state="translated">在类似Unix的平台上连接一个包含冒号的路径会导致错误。</target>
        </trans-unit>
        <trans-unit id="b4466f438f59f9e3e6b0c11543857ad0cb8e936d" translate="yes" xml:space="preserve">
          <source>Joining paths on a Unix-like platform:</source>
          <target state="translated">在类似Unix的平台上加入路径。</target>
        </trans-unit>
        <trans-unit id="b3a56bf6b2881876f787cf53e3b3c50398570960" translate="yes" xml:space="preserve">
          <source>Joins a collection of &lt;a href=&quot;../path/struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;s appropriately for the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">为 &lt;code&gt;PATH&lt;/code&gt; 环境变量适当地加入&lt;a href=&quot;../path/struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;的集合。</target>
        </trans-unit>
        <trans-unit id="9058cfb3941c57451d031360b87440956e3d0576" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;cargo run&lt;/code&gt; compiles your code and then runs the resulting binary, &lt;code&gt;cargo test&lt;/code&gt; compiles your code in test mode and runs the resulting test binary. You can specify command line options to change the default behavior of &lt;code&gt;cargo test&lt;/code&gt;. For example, the default behavior of the binary produced by &lt;code&gt;cargo test&lt;/code&gt; is to run all the tests in parallel and capture output generated during test runs, preventing the output from being displayed and making it easier to read the output related to the test results.</source>
          <target state="translated">就像 &lt;code&gt;cargo run&lt;/code&gt; 编译您的代码然后运行生成的二进制文件一样， &lt;code&gt;cargo test&lt;/code&gt; 在测试模式下编译您的代码并运行生成的测试二进制文件。您可以指定命令行选项来更改默认状态下的 &lt;code&gt;cargo test&lt;/code&gt; 。例如， &lt;code&gt;cargo test&lt;/code&gt; 生成的二进制文件的默认行为是并行运行所有测试，并捕获测试运行期间生成的输出，从而阻止显示输出，并使读取与测试结果相关的输出更加容易。</target>
        </trans-unit>
        <trans-unit id="001e99c6d562d4610082356bd914b66e7791c6d7" translate="yes" xml:space="preserve">
          <source>Just as variables are immutable by default, so are references. We&amp;rsquo;re not allowed to modify something we have a reference to.</source>
          <target state="translated">正如默认情况下变量是不可变的一样，引用也是如此。我们不允许修改引用的内容。</target>
        </trans-unit>
        <trans-unit id="d60a8e1c1966b92263798202c5f621ad3271182f" translate="yes" xml:space="preserve">
          <source>Just as we might want to refer to a part of a string, we might want to refer to part of an array. We&amp;rsquo;d do so like this:</source>
          <target state="translated">就像我们可能要引用字符串的一部分一样，我们可能要引用数组的一部分。我们会这样：</target>
        </trans-unit>
        <trans-unit id="7ad9184de5a77f6309e9e7ededd89f40f9a37f5e" translate="yes" xml:space="preserve">
          <source>Just as with &lt;a href=&quot;external-blocks&quot;&gt;external block&lt;/a&gt;, when the &lt;code&gt;extern&lt;/code&gt; keyword is used and the &lt;code&gt;&quot;ABI&lt;/code&gt; is omitted, the ABI used defaults to &lt;code&gt;&quot;C&quot;&lt;/code&gt;. That is, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cd0c38914e4f9de946957888fda12a2aef698c" translate="yes" xml:space="preserve">
          <source>Just because a function contains unsafe code doesn&amp;rsquo;t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let&amp;rsquo;s study a function from the standard library, &lt;code&gt;split_at_mut&lt;/code&gt;, that requires some unsafe code and explore how we might implement it. This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 19-4 shows how to use &lt;code&gt;split_at_mut&lt;/code&gt;.</source>
          <target state="translated">仅仅因为一个函数包含不安全的代码并不意味着我们需要将整个函数标记为不安全。实际上，将不安全的代码包装在安全的函数中是一种常见的抽象。例如，让我们研究标准库 &lt;code&gt;split_at_mut&lt;/code&gt; 中的一个函数，该函数需要一些不安全的代码，并探讨如何实现它。此安全方法是在可变切片上定义的：它采用一个切片，然后通过在作为参数给出的索引处分割切片来将其分成两个切片。清单19-4显示了如何使用 &lt;code&gt;split_at_mut&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="687163feff04cea4e68067b5a858f533ad06e05e" translate="yes" xml:space="preserve">
          <source>Just compiling with &lt;code&gt;rustc&lt;/code&gt; is fine for simple programs, but as your project grows, you&amp;rsquo;ll want to manage all the options and make it easy to share your code. Next, we&amp;rsquo;ll introduce you to the Cargo tool, which will help you write real-world Rust programs.</source>
          <target state="translated">对于简单的程序，仅使用 &lt;code&gt;rustc&lt;/code&gt; 进行编译就可以了，但是随着项目的增长，您将需要管理所有选项并使其易于共享代码。接下来，我们将向您介绍货运工具，它将帮助您编写真实的Rust程序。</target>
        </trans-unit>
        <trans-unit id="edf4d5cc727a6c57ca685432668f892eb6c7cbd1" translate="yes" xml:space="preserve">
          <source>Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a &lt;code&gt;read_volatile&lt;/code&gt; and any write operation to the same location is undefined behavior.</source>
          <target state="translated">就像在C语言中一样，操作是否易失性与涉及从多个线程进行并发访问的问题无关。在这方面，易失性访问的行为与非原子访问完全相同。特别是， &lt;code&gt;read_volatile&lt;/code&gt; 和对同一位置的任何写操作之间的竞争是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="317bc7ae9f1ea2d73138794a7e1fffbd3badd2f1" translate="yes" xml:space="preserve">
          <source>Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a &lt;code&gt;write_volatile&lt;/code&gt; and any other operation (reading or writing) on the same location is undefined behavior.</source>
          <target state="translated">就像在C语言中一样，操作是否易失性与涉及从多个线程进行并发访问的问题无关。在这方面，易失性访问的行为与非原子访问完全相同。特别是， &lt;code&gt;write_volatile&lt;/code&gt; 和同一位置上的任何其他操作（读取或写入）之间的竞争是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="4e495fa1d1e849a4610409f46ad4ee2226bcc303" translate="yes" xml:space="preserve">
          <source>Just like static functions, associated constants aren't stored on the method table. If the trait or any subtrait contain an associated constant, they cannot be made into an object.</source>
          <target state="translated">就像静态函数一样,关联常量不存储在方法表上。如果特质或任何子特质包含一个关联常量,它们就不能被制作成一个对象。</target>
        </trans-unit>
        <trans-unit id="f8bf7b98f101ed3ceab4b0a28bb6ad41d9542aea" translate="yes" xml:space="preserve">
          <source>Just like vectors, hash maps store their data on the heap. This &lt;code&gt;HashMap&lt;/code&gt; has keys of type &lt;code&gt;String&lt;/code&gt; and values of type &lt;code&gt;i32&lt;/code&gt;. Like vectors, hash maps are homogeneous: all of the keys must have the same type, and all of the values must have the same type.</source>
          <target state="translated">就像向量一样，哈希映射将其数据存储在堆中。此 &lt;code&gt;HashMap&lt;/code&gt; 具有 &lt;code&gt;String&lt;/code&gt; 类型的键和 &lt;code&gt;i32&lt;/code&gt; 类型的值。像向量一样，哈希映射是同质的：所有键都必须具有相同的类型，并且所有值都必须具有相同的类型。</target>
        </trans-unit>
        <trans-unit id="f4b3ade3597f2a53cd73a47fd91e8d89c9f37a8f" translate="yes" xml:space="preserve">
          <source>Just like you cannot have both &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; representation hints on a same type, a &lt;code&gt;packed&lt;/code&gt; type cannot contain another type with the &lt;code&gt;align&lt;/code&gt; representation hint. However, you can do the opposite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad38c597b8238e8c5ffff5cb9392234534096181" translate="yes" xml:space="preserve">
          <source>KW_ABSTRACT : &lt;code&gt;abstract&lt;/code&gt;</source>
          <target state="translated">KW_ABSTRACT： &lt;code&gt;abstract&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be90ce625c319a7fdfb58a43e5bc5c5d9b71f25a" translate="yes" xml:space="preserve">
          <source>KW_AS : &lt;code&gt;as&lt;/code&gt;</source>
          <target state="translated">KW_AS： &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0173c787da7a615493ad8d7a2cb0a37333dc413" translate="yes" xml:space="preserve">
          <source>KW_ASYNC : &lt;code&gt;async&lt;/code&gt;</source>
          <target state="translated">KW_ASYNC： &lt;code&gt;async&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48849139f33d9b0b0e09242876428fca2f3b32a0" translate="yes" xml:space="preserve">
          <source>KW_AWAIT : &lt;code&gt;await&lt;/code&gt;</source>
          <target state="translated">KW_AWAIT： &lt;code&gt;await&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="faeff081e9c7bb1476ef0597e5745e683e9089ac" translate="yes" xml:space="preserve">
          <source>KW_BECOME : &lt;code&gt;become&lt;/code&gt;</source>
          <target state="translated">KW_BECOME： &lt;code&gt;become&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb5b5f47578617a58162739554c68db1988e5f19" translate="yes" xml:space="preserve">
          <source>KW_BOX : &lt;code&gt;box&lt;/code&gt;</source>
          <target state="translated">KW_BOX： &lt;code&gt;box&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="789f5a93cd563740436ffcc55aa832d91d39e504" translate="yes" xml:space="preserve">
          <source>KW_BREAK : &lt;code&gt;break&lt;/code&gt;</source>
          <target state="translated">KW_BREAK： &lt;code&gt;break&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="646ebf0a8faa491f908a99b63b433e9b938d1d0d" translate="yes" xml:space="preserve">
          <source>KW_CONST : &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">KW_CONST： &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3b44085f94ca57ca2f334704a2a2c477986387b" translate="yes" xml:space="preserve">
          <source>KW_CONTINUE : &lt;code&gt;continue&lt;/code&gt;</source>
          <target state="translated">KW_CONTINUE： &lt;code&gt;continue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e94a62fd0360430796d17226621f22aabfdbae9" translate="yes" xml:space="preserve">
          <source>KW_CRATE : &lt;code&gt;crate&lt;/code&gt;</source>
          <target state="translated">KW_CRATE： &lt;code&gt;crate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e516b0f9399c34f538fa08c26037ff452464083" translate="yes" xml:space="preserve">
          <source>KW_DO : &lt;code&gt;do&lt;/code&gt;</source>
          <target state="translated">KW_DO： &lt;code&gt;do&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a55ecfee6ea0809448ea6f5c0847e66b961b8869" translate="yes" xml:space="preserve">
          <source>KW_DYN : &lt;code&gt;dyn&lt;/code&gt;</source>
          <target state="translated">KW_DYN： &lt;code&gt;dyn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43bd7725cfebb3448607c8a4f8fa78700ac6e981" translate="yes" xml:space="preserve">
          <source>KW_ELSE : &lt;code&gt;else&lt;/code&gt;</source>
          <target state="translated">KW_ELSE： &lt;code&gt;else&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a5b15ab165b8a37f5ca1b5c6cb8b552b4b74656" translate="yes" xml:space="preserve">
          <source>KW_ENUM : &lt;code&gt;enum&lt;/code&gt;</source>
          <target state="translated">KW_ENUM： &lt;code&gt;enum&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ab52e66c553f670a2e4b9deb4214bb9187af23" translate="yes" xml:space="preserve">
          <source>KW_EXTERN : &lt;code&gt;extern&lt;/code&gt;</source>
          <target state="translated">KW_EXTERN： &lt;code&gt;extern&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a82d8ca4b2bfb3195b34b23742e5f65175a92d0" translate="yes" xml:space="preserve">
          <source>KW_FALSE : &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">KW_FALSE： &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c805a2e97aa19bcae5903d9a457908adfeea3d5" translate="yes" xml:space="preserve">
          <source>KW_FINAL : &lt;code&gt;final&lt;/code&gt;</source>
          <target state="translated">KW_FINAL： &lt;code&gt;final&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a1dbe403904f42293db37c4c0873bfb1846c985" translate="yes" xml:space="preserve">
          <source>KW_FN : &lt;code&gt;fn&lt;/code&gt;</source>
          <target state="translated">KW_FN： &lt;code&gt;fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51804441d72df4f1c2711281dfd36ba09d409775" translate="yes" xml:space="preserve">
          <source>KW_FOR : &lt;code&gt;for&lt;/code&gt;</source>
          <target state="translated">KW_FOR： &lt;code&gt;for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ae9f72e482e9a846d12338bb40fabc6e91c7824" translate="yes" xml:space="preserve">
          <source>KW_IF : &lt;code&gt;if&lt;/code&gt;</source>
          <target state="translated">KW_IF： &lt;code&gt;if&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a367c162e2fe29dc4e94c96cbfc7218815660b1" translate="yes" xml:space="preserve">
          <source>KW_IF, INTEGER_LITERAL</source>
          <target state="translated">KW_IF,INTEGER_LITERAL。</target>
        </trans-unit>
        <trans-unit id="73fa9c35080f85eae254306fc02ef20b3a0228db" translate="yes" xml:space="preserve">
          <source>KW_IMPL : &lt;code&gt;impl&lt;/code&gt;</source>
          <target state="translated">KW_IMPL： &lt;code&gt;impl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59c563aec15dd074ead40cd8d2c65822bdb4fef2" translate="yes" xml:space="preserve">
          <source>KW_IN : &lt;code&gt;in&lt;/code&gt;</source>
          <target state="translated">KW_IN： &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10df35e646555ba6a73e442c5fb68654f251460" translate="yes" xml:space="preserve">
          <source>KW_LET : &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">KW_LET： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc99c61ef358b05bbd7856a61981d75499ebec" translate="yes" xml:space="preserve">
          <source>KW_LOOP : &lt;code&gt;loop&lt;/code&gt;</source>
          <target state="translated">KW_LOOP： &lt;code&gt;loop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf074b1962cc7aeed758b10c5e770f59576a496d" translate="yes" xml:space="preserve">
          <source>KW_MACRO : &lt;code&gt;macro&lt;/code&gt;</source>
          <target state="translated">KW_MACRO： &lt;code&gt;macro&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21616e3fdd9348e77ec41feb87c87238b3f4e26c" translate="yes" xml:space="preserve">
          <source>KW_MATCH : &lt;code&gt;match&lt;/code&gt;</source>
          <target state="translated">KW_MATCH： &lt;code&gt;match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cacbc1424997c4e31784ec865a9cf0e227d1f331" translate="yes" xml:space="preserve">
          <source>KW_MOD : &lt;code&gt;mod&lt;/code&gt;</source>
          <target state="translated">KW_MOD： &lt;code&gt;mod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c49906f1ece7b2086399766a4ebb775592dce9" translate="yes" xml:space="preserve">
          <source>KW_MOVE : &lt;code&gt;move&lt;/code&gt;</source>
          <target state="translated">KW_MOVE： &lt;code&gt;move&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e93813d5f885df35d1d34208741cb14417dd32b9" translate="yes" xml:space="preserve">
          <source>KW_MUT : &lt;code&gt;mut&lt;/code&gt;</source>
          <target state="translated">KW_MUT： &lt;code&gt;mut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="986112403ae83ef4c659145d144f9037283438f0" translate="yes" xml:space="preserve">
          <source>KW_OVERRIDE : &lt;code&gt;override&lt;/code&gt;</source>
          <target state="translated">KW_OVERRIDE： &lt;code&gt;override&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="096b897ed7d5ae1c63992283c83f6e0f9013d7f0" translate="yes" xml:space="preserve">
          <source>KW_PRIV : &lt;code&gt;priv&lt;/code&gt;</source>
          <target state="translated">KW_PRIV： &lt;code&gt;priv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f48e0064a9cb22ae594e388e4915e7d88ce3349c" translate="yes" xml:space="preserve">
          <source>KW_PUB : &lt;code&gt;pub&lt;/code&gt;</source>
          <target state="translated">KW_PUB： &lt;code&gt;pub&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ebf55b9ade912097bcab3d0fc356bd22943c572" translate="yes" xml:space="preserve">
          <source>KW_REF : &lt;code&gt;ref&lt;/code&gt;</source>
          <target state="translated">KW_REF： &lt;code&gt;ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4aa1bbded52171e54febc09f265f40e1c0be60b" translate="yes" xml:space="preserve">
          <source>KW_RETURN : &lt;code&gt;return&lt;/code&gt;</source>
          <target state="translated">KW_RETURN： &lt;code&gt;return&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb8c1f081587b4145c8d20e256de8a57807802c8" translate="yes" xml:space="preserve">
          <source>KW_SELFTYPE : &lt;code&gt;Self&lt;/code&gt;</source>
          <target state="translated">KW_SELFTYPE： &lt;code&gt;Self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589c3916c9b199922a8c5503d2f10a38cd602f6d" translate="yes" xml:space="preserve">
          <source>KW_SELFVALUE : &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">KW_SELFVALUE： &lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e97f068c91e52b8ee0bf7536b78346905ff65084" translate="yes" xml:space="preserve">
          <source>KW_STATIC : &lt;code&gt;static&lt;/code&gt;</source>
          <target state="translated">KW_STATIC： &lt;code&gt;static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3f4b78faf33e54502b143b3311dfbbea495dd79" translate="yes" xml:space="preserve">
          <source>KW_STATICLIFETIME : &lt;code&gt;'static&lt;/code&gt;</source>
          <target state="translated">KW_STATICLIFETIME： &lt;code&gt;'static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96f670f49f58217687c9c79e68cbb2ce6b233631" translate="yes" xml:space="preserve">
          <source>KW_STRUCT : &lt;code&gt;struct&lt;/code&gt;</source>
          <target state="translated">KW_STRUCT： &lt;code&gt;struct&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb41d3d257888d3ae68c1492a043887998f5646e" translate="yes" xml:space="preserve">
          <source>KW_SUPER : &lt;code&gt;super&lt;/code&gt;</source>
          <target state="translated">KW_SUPER： &lt;code&gt;super&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d62ea6cea231ded0372e49c12635b034d685a2" translate="yes" xml:space="preserve">
          <source>KW_TRAIT : &lt;code&gt;trait&lt;/code&gt;</source>
          <target state="translated">KW_TRAIT： &lt;code&gt;trait&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2436e51574011f63df503ea8e052114e32b38421" translate="yes" xml:space="preserve">
          <source>KW_TRUE : &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">KW_TRUE： &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33857bab7317b38e930f6e043274e294dfdb0837" translate="yes" xml:space="preserve">
          <source>KW_TRY : &lt;code&gt;try&lt;/code&gt;</source>
          <target state="translated">KW_TRY： &lt;code&gt;try&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b98be3594c838969fbf8e804a3b83125cd8f9164" translate="yes" xml:space="preserve">
          <source>KW_TYPE : &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">KW_TYPE： &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f90893de8264f12555e264daf55d8d3573f648a" translate="yes" xml:space="preserve">
          <source>KW_TYPEOF : &lt;code&gt;typeof&lt;/code&gt;</source>
          <target state="translated">KW_TYPEOF： &lt;code&gt;typeof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="810b6331cc472782bf330b62c25e7caade19a83a" translate="yes" xml:space="preserve">
          <source>KW_UNION : &lt;code&gt;union&lt;/code&gt;</source>
          <target state="translated">KW_UNION： &lt;code&gt;union&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8c046c3fefb22d66beea883f5fe4ae12ff703c3" translate="yes" xml:space="preserve">
          <source>KW_UNSAFE : &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">KW_UNSAFE： &lt;code&gt;unsafe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a504e9e9c867afd9ae5cd6865e04fd6708c18c" translate="yes" xml:space="preserve">
          <source>KW_UNSIZED : &lt;code&gt;unsized&lt;/code&gt;</source>
          <target state="translated">KW_UNSIZED： &lt;code&gt;unsized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a42f6264915b56a563a35b937d40ee2b1092d828" translate="yes" xml:space="preserve">
          <source>KW_USE : &lt;code&gt;use&lt;/code&gt;</source>
          <target state="translated">KW_USE： &lt;code&gt;use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0164d2f9ee89b4ff7027682d51a2a239aa74f90" translate="yes" xml:space="preserve">
          <source>KW_VIRTUAL : &lt;code&gt;virtual&lt;/code&gt;</source>
          <target state="translated">KW_VIRTUAL： &lt;code&gt;virtual&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddbe1f7c29b3f7210557405db5ed34966c662d08" translate="yes" xml:space="preserve">
          <source>KW_WHERE : &lt;code&gt;where&lt;/code&gt;</source>
          <target state="translated">KW_WHERE： &lt;code&gt;where&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c9dfcdf6820da0b224753fce346422cdc8d7ae5" translate="yes" xml:space="preserve">
          <source>KW_WHILE : &lt;code&gt;while&lt;/code&gt;</source>
          <target state="translated">KW_WHILE： &lt;code&gt;while&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98333a752caf854e21271745fd6749b9c1d1a7d1" translate="yes" xml:space="preserve">
          <source>KW_YIELD : &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">KW_YIELD： &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0691b0c7d3cefeeeae3a2289278f41bd8c7c1e6f" translate="yes" xml:space="preserve">
          <source>Keep a global count of live threads:</source>
          <target state="translated">掌握全局的实时线程数。</target>
        </trans-unit>
        <trans-unit id="d2d8fe2c08e017878e56af189be768b49b58a3e4" translate="yes" xml:space="preserve">
          <source>Keep in mind that Rust is a &lt;em&gt;statically typed&lt;/em&gt; language, which means that it must know the types of all variables at compile time. The compiler can usually infer what type we want to use based on the value and how we use it. In cases when many types are possible, such as when we converted a &lt;code&gt;String&lt;/code&gt; to a numeric type using &lt;code&gt;parse&lt;/code&gt; in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we must add a type annotation, like this:</source>
          <target state="translated">请记住，Rust是一种&lt;em&gt;静态类型的&lt;/em&gt;语言，这意味着它必须在编译时知道所有变量的类型。编译器通常可以根据值以及如何使用它来推断我们要使用的类型。在当许多类型是可能的情况下，比如当我们转换一个 &lt;code&gt;String&lt;/code&gt; 到使用数字式 &lt;code&gt;parse&lt;/code&gt; 了在&lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;猜猜相较于秘密号码&amp;rdquo;&lt;/a&gt;一节中第2章中，我们必须添加类型注释，如下所示：</target>
        </trans-unit>
        <trans-unit id="52e9fac3044bab3714b6ee55ecb852540b800b38" translate="yes" xml:space="preserve">
          <source>Keeping Track of Borrows at Runtime with &lt;code id=&quot;keeping-track-of-borrows-at-runtime-with-refcellt&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code id=&quot;keeping-track-of-borrows-at-runtime-with-refcellt&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 在运行时跟踪借入</target>
        </trans-unit>
        <trans-unit id="d3ebbc3717ea52d0fdffcb979b6a75601bc35c26" translate="yes" xml:space="preserve">
          <source>Keeping a crate&amp;rsquo;s functionality in its own scope clarifies whether particular functionality is defined in our crate or the &lt;code&gt;rand&lt;/code&gt; crate and prevents potential conflicts. For example, the &lt;code&gt;rand&lt;/code&gt; crate provides a trait named &lt;code&gt;Rng&lt;/code&gt;. We can also define a &lt;code&gt;struct&lt;/code&gt; named &lt;code&gt;Rng&lt;/code&gt; in our own crate. Because a crate&amp;rsquo;s functionality is namespaced in its own scope, when we add &lt;code&gt;rand&lt;/code&gt; as a dependency, the compiler isn&amp;rsquo;t confused about what the name &lt;code&gt;Rng&lt;/code&gt; refers to. In our crate, it refers to the &lt;code&gt;struct Rng&lt;/code&gt; that we defined. We would access the &lt;code&gt;Rng&lt;/code&gt; trait from the &lt;code&gt;rand&lt;/code&gt; crate as &lt;code&gt;rand::Rng&lt;/code&gt;.</source>
          <target state="translated">在自己的范围内澄清保持特定功能是否在我们的箱子或定义的一个箱子的功能 &lt;code&gt;rand&lt;/code&gt; 箱，并防止潜在的冲突。例如， &lt;code&gt;rand&lt;/code&gt; 箱子提供了一个名为 &lt;code&gt;Rng&lt;/code&gt; 的特征。我们还可以在自己的箱子中定义一个名为 &lt;code&gt;Rng&lt;/code&gt; 的 &lt;code&gt;struct&lt;/code&gt; 。由于板条箱的功能是在其自己的作用域中命名的，因此当我们将 &lt;code&gt;rand&lt;/code&gt; 添加为依赖项时，编译器不会对 &lt;code&gt;Rng&lt;/code&gt; 所指的名称感到困惑。在我们的箱子中，它指的是我们定义的 &lt;code&gt;struct Rng&lt;/code&gt; 。我们可以从 &lt;code&gt;rand&lt;/code&gt; 箱中以 &lt;code&gt;rand::Rng&lt;/code&gt; 形式访问 &lt;code&gt;Rng&lt;/code&gt; 特性。。</target>
        </trans-unit>
        <trans-unit id="e9f12e803a098c99995539cb42f36c9f9739f97e" translate="yes" xml:space="preserve">
          <source>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don&amp;rsquo;t run out of space are all problems that ownership addresses. Once you understand ownership, you won&amp;rsquo;t need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.</source>
          <target state="translated">所有权要解决的所有问题是，跟踪代码的哪些部分正在使用堆上的哪些数据，最大程度地减少堆上的重复数据量以及清理堆上的未使用数据，以免耗尽空间。一旦了解了所有权，您就不必经常考虑堆栈和堆了，但是知道管理堆数据就是所有权存在的原因，可以帮助您解释其工作原理。</target>
        </trans-unit>
        <trans-unit id="cd35d612a134cd358cb5ad1ce1e9e74301067e1d" translate="yes" xml:space="preserve">
          <source>Key-value option set at most once with the target's operating system value.</source>
          <target state="translated">键值选项最多设置一次,目标的操作系统值。</target>
        </trans-unit>
        <trans-unit id="ce96f30fb0633a0de5217c6ddf2318f94830e44b" translate="yes" xml:space="preserve">
          <source>Key-value option set for each platform feature available for the current compilation target.</source>
          <target state="translated">当前编译目标可用的每个平台特性的键值选项集。</target>
        </trans-unit>
        <trans-unit id="ce9ea81e67f13ab1e763fa87e4c0b2168fc63774" translate="yes" xml:space="preserve">
          <source>Key-value option set once with either a value of &quot;little&quot; or &quot;big&quot; depending on the endianness of the target's CPU.</source>
          <target state="translated">键值选项设置一次,其值为 &quot;小 &quot;或 &quot;大&quot;,取决于目标CPU的字节数。</target>
        </trans-unit>
        <trans-unit id="63e95325de8c37181511cb94e0cd4096c6b7d2ef" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's CPU architecture. The value is similar to the first element of the platform's target triple, but not identical.</source>
          <target state="translated">与目标的CPU架构设置一次键值选项。该值与平台的目标三要素的第一要素相似,但不完全相同。</target>
        </trans-unit>
        <trans-unit id="9f535aa6f58b910aacefadf78335cfd96c455f70" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's operating system. This value is similar to the second and third element of the platform's target triple.</source>
          <target state="translated">与目标的操作系统设置一次键值选项。该值类似于平台目标三要素中的第二和第三要素。</target>
        </trans-unit>
        <trans-unit id="21bb65083a0c78de1363d38fcb64deec6c2f621f" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's pointer width in bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ebc4327b545eab4c13648ab9805f30fdc72faa" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's pointer width in bits. For example, for targets with 32-bit pointers, this is set to &lt;code&gt;&quot;32&quot;&lt;/code&gt;. Likewise, it is set to &lt;code&gt;&quot;64&quot;&lt;/code&gt; for targets with 64-bit pointers.</source>
          <target state="translated">使用目标的指针宽度（以位为单位）设置键值选项一次。例如，对于具有32位指针的目标，将其设置为 &lt;code&gt;&quot;32&quot;&lt;/code&gt; 。同样，对于具有64位指针的目标，它设置为 &lt;code&gt;&quot;64&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="919823df75a839f68908ab4a52f685cce0bc3afd" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the vendor of the target.</source>
          <target state="translated">与目标的供应商设置一次键值选项。</target>
        </trans-unit>
        <trans-unit id="11da1ff3fc87f22cc67c02cf8eb624f317fde1c5" translate="yes" xml:space="preserve">
          <source>Key-value option set with further disambiguating information about the target platform with information about the ABI or &lt;code&gt;libc&lt;/code&gt; used. For historical reasons, this value is only defined as not the empty-string when actually needed for disambiguation. Thus, for example, on many GNU platforms, this value will be empty. This value is similar to the fourth element of the platform's target triple. One difference is that embedded ABIs such as &lt;code&gt;gnueabihf&lt;/code&gt; will simply define &lt;code&gt;target_env&lt;/code&gt; as &lt;code&gt;&quot;gnu&quot;&lt;/code&gt;.</source>
          <target state="translated">键值选项集包含有关目标平台的进一步信息和使用的ABI或 &lt;code&gt;libc&lt;/code&gt; 信息的歧义。由于历史原因，仅在实际上需要消除歧义时才将该值定义为空字符串。因此，例如，在许多GNU平台上，此值将为空。该值类似于平台目标三元组的第四个元素。区别在于，嵌入式ABI（如 &lt;code&gt;gnueabihf&lt;/code&gt; )将简单地将 &lt;code&gt;target_env&lt;/code&gt; 定义为 &lt;code&gt;&quot;gnu&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="8f31576d96d60f0abebc904da3b4f2881c89ac5a" translate="yes" xml:space="preserve">
          <source>Keys are not unique in the set of key-value configuration options. For example, both &lt;code&gt;feature = &quot;std&quot;&lt;/code&gt; and &lt;code&gt;feature = &quot;serde&quot;&lt;/code&gt; can be set at the same time.</source>
          <target state="translated">键在键值配置选项集中不是唯一的。例如， &lt;code&gt;feature = &quot;std&quot;&lt;/code&gt; 和 &lt;code&gt;feature = &quot;serde&quot;&lt;/code&gt; 可以同时设置。</target>
        </trans-unit>
        <trans-unit id="6fe4683b112b96ba7631fcdc86fabb26bd695c7d" translate="yes" xml:space="preserve">
          <source>Keyword Self</source>
          <target state="translated">关键字自我</target>
        </trans-unit>
        <trans-unit id="7a05409abe457818d06a7b2a827d071925e3123d" translate="yes" xml:space="preserve">
          <source>Keyword as</source>
          <target state="translated">关键字为</target>
        </trans-unit>
        <trans-unit id="111297ecda21e09bfe2a8317450e29b120adfb90" translate="yes" xml:space="preserve">
          <source>Keyword async</source>
          <target state="translated">关键字 async</target>
        </trans-unit>
        <trans-unit id="2b96f62624a68fd871d5766ca2fa2145d4644a70" translate="yes" xml:space="preserve">
          <source>Keyword await</source>
          <target state="translated">关键字等待</target>
        </trans-unit>
        <trans-unit id="f6c6e1b25bec0a5a14bc88afab261e9a04ec9707" translate="yes" xml:space="preserve">
          <source>Keyword break</source>
          <target state="translated">关键字突破</target>
        </trans-unit>
        <trans-unit id="436846eb0b7f7b9748553b55f55233f3a2e1b42b" translate="yes" xml:space="preserve">
          <source>Keyword const</source>
          <target state="translated">关键字 const</target>
        </trans-unit>
        <trans-unit id="2a3920d65d1221a1de8f19c31f0add5d8fc541dd" translate="yes" xml:space="preserve">
          <source>Keyword continue</source>
          <target state="translated">关键字继续</target>
        </trans-unit>
        <trans-unit id="9eb24d787290917c89c3e8b0eb98d952c8cdf70d" translate="yes" xml:space="preserve">
          <source>Keyword crate</source>
          <target state="translated">关键字板条箱</target>
        </trans-unit>
        <trans-unit id="9274e1d61951bc25e37abafb1a71c5c41800be68" translate="yes" xml:space="preserve">
          <source>Keyword dyn</source>
          <target state="translated">关键字 dyn</target>
        </trans-unit>
        <trans-unit id="377e304b2d1e85347b20ff335b6d99538e6c187b" translate="yes" xml:space="preserve">
          <source>Keyword else</source>
          <target state="translated">关键字其他</target>
        </trans-unit>
        <trans-unit id="7aba16f0afd468040716e09c2ae6718f272a6458" translate="yes" xml:space="preserve">
          <source>Keyword enum</source>
          <target state="translated">关键字枚举</target>
        </trans-unit>
        <trans-unit id="497cef40287ff8c1a00ccb47de8f855e132be344" translate="yes" xml:space="preserve">
          <source>Keyword extern</source>
          <target state="translated">关键字外部</target>
        </trans-unit>
        <trans-unit id="2a6e421aa23f1681fcb97ab460fe75051a3e013b" translate="yes" xml:space="preserve">
          <source>Keyword false</source>
          <target state="translated">关键字假</target>
        </trans-unit>
        <trans-unit id="ad325f8a9f86ad3293235a282313ef21d8bfd594" translate="yes" xml:space="preserve">
          <source>Keyword fn</source>
          <target state="translated">关键字 fn</target>
        </trans-unit>
        <trans-unit id="a25477170e21ac7e2572a740282b4353f075bcfe" translate="yes" xml:space="preserve">
          <source>Keyword for</source>
          <target state="translated">关键字</target>
        </trans-unit>
        <trans-unit id="aa09921301016318d19919d413f46e0991eaa034" translate="yes" xml:space="preserve">
          <source>Keyword if</source>
          <target state="translated">关键字如果</target>
        </trans-unit>
        <trans-unit id="70d230cf570b8b6b9e41e2c04e4b1eecd566cc1c" translate="yes" xml:space="preserve">
          <source>Keyword impl</source>
          <target state="translated">关键字内涵</target>
        </trans-unit>
        <trans-unit id="1d1b8618ebc37a044f2789a54f15fcc89bca4b48" translate="yes" xml:space="preserve">
          <source>Keyword in</source>
          <target state="translated">关键字在</target>
        </trans-unit>
        <trans-unit id="e45321f53ba7f20aaa2734b8d92fce994255c877" translate="yes" xml:space="preserve">
          <source>Keyword let</source>
          <target state="translated">关键字让</target>
        </trans-unit>
        <trans-unit id="b17d0119a3acf3683a3f63c42ae8a1a62b0f2bec" translate="yes" xml:space="preserve">
          <source>Keyword loop</source>
          <target state="translated">关键字循环</target>
        </trans-unit>
        <trans-unit id="08770e678060c19974b3fc3b3f50ffe441004b2d" translate="yes" xml:space="preserve">
          <source>Keyword match</source>
          <target state="translated">关键字匹配</target>
        </trans-unit>
        <trans-unit id="eb89d3478115288bccdf47fcaee875e6e9dec53b" translate="yes" xml:space="preserve">
          <source>Keyword mod</source>
          <target state="translated">关键字model</target>
        </trans-unit>
        <trans-unit id="5fcfe7efe61a879544f9458d60ef298a6eae68ef" translate="yes" xml:space="preserve">
          <source>Keyword move</source>
          <target state="translated">关键字移动</target>
        </trans-unit>
        <trans-unit id="e8f403359a67fdeb4f9a69ff28eebe446a15425c" translate="yes" xml:space="preserve">
          <source>Keyword mut</source>
          <target state="translated">关键字突变</target>
        </trans-unit>
        <trans-unit id="5aad2726454c0cfe99c64b86b5506fbc780aba60" translate="yes" xml:space="preserve">
          <source>Keyword pub</source>
          <target state="translated">关键字 pub</target>
        </trans-unit>
        <trans-unit id="fd01e715bc85516f46378428fd84c2baadd44546" translate="yes" xml:space="preserve">
          <source>Keyword ref</source>
          <target state="translated">关键字参考</target>
        </trans-unit>
        <trans-unit id="0d24ace1f65b53c2f9e03ed8271b08e7fc77ee6d" translate="yes" xml:space="preserve">
          <source>Keyword return</source>
          <target state="translated">关键字返回</target>
        </trans-unit>
        <trans-unit id="17548e2276001357bd22942d19f5cb00544567f5" translate="yes" xml:space="preserve">
          <source>Keyword static</source>
          <target state="translated">关键字静态</target>
        </trans-unit>
        <trans-unit id="05f8b04e053f5e1b453e9b0b93670f8ffca49cf9" translate="yes" xml:space="preserve">
          <source>Keyword struct</source>
          <target state="translated">关键字结构</target>
        </trans-unit>
        <trans-unit id="c230764a5d99ee580877e7cde563c5c1768ec51f" translate="yes" xml:space="preserve">
          <source>Keyword super</source>
          <target state="translated">关键字超级</target>
        </trans-unit>
        <trans-unit id="48effa325ed166316a6e508bc8da17af9983e809" translate="yes" xml:space="preserve">
          <source>Keyword trait</source>
          <target state="translated">关键字特征</target>
        </trans-unit>
        <trans-unit id="3092260b25ab0be886a76ed515be7af36594b34e" translate="yes" xml:space="preserve">
          <source>Keyword true</source>
          <target state="translated">关键字真实</target>
        </trans-unit>
        <trans-unit id="48b8acd5cc92e931fbcf08f4564de6254a3688f3" translate="yes" xml:space="preserve">
          <source>Keyword type</source>
          <target state="translated">关键字类型</target>
        </trans-unit>
        <trans-unit id="df96c1b537e86440f56db5003c98baa08726505b" translate="yes" xml:space="preserve">
          <source>Keyword union</source>
          <target state="translated">关键字联盟</target>
        </trans-unit>
        <trans-unit id="16040d77331d2a3b59872c42f67d3f8a96b1c3dd" translate="yes" xml:space="preserve">
          <source>Keyword unsafe</source>
          <target state="translated">关键字不安全</target>
        </trans-unit>
        <trans-unit id="f29c9f829c3c510995b3f7cdf3202a3d7c402a35" translate="yes" xml:space="preserve">
          <source>Keyword use</source>
          <target state="translated">关键字使用</target>
        </trans-unit>
        <trans-unit id="fe4e85de0c4f74847bd8e598f60609044af0ee40" translate="yes" xml:space="preserve">
          <source>Keyword where</source>
          <target state="translated">关键字在哪里</target>
        </trans-unit>
        <trans-unit id="7d7b00f33afab4f85be61beaf96d76b0462792b9" translate="yes" xml:space="preserve">
          <source>Keyword while</source>
          <target state="translated">关键字而</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e3640301ed0023ff94e08911cc76aa75eb8d7a5e" translate="yes" xml:space="preserve">
          <source>Keywords Currently in Use</source>
          <target state="translated">当前使用的关键词</target>
        </trans-unit>
        <trans-unit id="8a1e43b45921c00d897b3f014078137489061012" translate="yes" xml:space="preserve">
          <source>Keywords Reserved for Future Use</source>
          <target state="translated">保留给未来使用的关键词</target>
        </trans-unit>
        <trans-unit id="8894c6a0dbced6c16c0d9df706a39a96c0879833" translate="yes" xml:space="preserve">
          <source>Knowing that you can take slices of literals and &lt;code&gt;String&lt;/code&gt; values leads us to one more improvement on &lt;code&gt;first_word&lt;/code&gt;, and that&amp;rsquo;s its signature:</source>
          <target state="translated">知道您可以分割文字和 &lt;code&gt;String&lt;/code&gt; 值，这使我们对 &lt;code&gt;first_word&lt;/code&gt; 进行了另一个改进，这就是它的签名：</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="d3ae07e851fde32543939729ee80148fb0ebdf41" translate="yes" xml:space="preserve">
          <source>Known bugs</source>
          <target state="translated">已知的错误</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="7c94d83254a2ffa0762a5bfff0ef000108b0fbf6" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+ g&lt;/code&gt;) = { &lt;code&gt;g&lt;/code&gt; }</source>
          <target state="translated">LAST（ &lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+ g&lt;/code&gt; ）= { &lt;code&gt;g&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="e400fae22d0553b70188e398d3482c7e98a473b0" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+&lt;/code&gt;) = { &lt;code&gt;;&lt;/code&gt; }</source>
          <target state="translated">LAST（ &lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+&lt;/code&gt; ）= { &lt;code&gt;;&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="f4251e0f413cd3f41f3df9bb22d15a8115a98157" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)*&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt;, &amp;epsilon;, &lt;code&gt;h&lt;/code&gt; }</source>
          <target state="translated">LAST（ &lt;code&gt;$( $d:ident $e:expr );* $(h)*&lt;/code&gt; ）= { &lt;code&gt;$e:expr&lt;/code&gt; ，&amp;epsilon;， &lt;code&gt;h&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="7ff61fa787f2c62adc8ee173405366e66cca6711" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );*&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt;, &amp;epsilon; }</source>
          <target state="translated">LAST（ &lt;code&gt;$( $d:ident $e:expr );*&lt;/code&gt; ）= { &lt;code&gt;$e:expr&lt;/code&gt; ，&amp;epsilon;}</target>
        </trans-unit>
        <trans-unit id="37aef063f183280d4f7dc041920c02a28b503744" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$d:ident $e:expr&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt; }</source>
          <target state="translated">LAST（ &lt;code&gt;$d:ident $e:expr&lt;/code&gt; ）= { &lt;code&gt;$e:expr&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="7fab544af8af2c23b62871343f4c928563121b43" translate="yes" xml:space="preserve">
          <source>LAST(M), defined by case analysis on M itself (a sequence of token-trees):</source>
          <target state="translated">LAST(M),由M本身的案例分析定义(token-trees序列)。</target>
        </trans-unit>
        <trans-unit id="f85099a357b111ba1d477f0dbd426a597f6e3435" translate="yes" xml:space="preserve">
          <source>LAST(M): collects the tokens potentially used last when matching a fragment to M.</source>
          <target state="translated">LAST(M):收集在将一个片段与M匹配时可能最后使用的标记。</target>
        </trans-unit>
        <trans-unit id="e8ea6b99f854e01dbe363d86b29cecae5304f225" translate="yes" xml:space="preserve">
          <source>LIFETIME_OR_LABEL</source>
          <target state="translated">LIFETIME_OR_LABEL</target>
        </trans-unit>
        <trans-unit id="40a1fdbb26c080098fc98bb4705851d4859ab4d3" translate="yes" xml:space="preserve">
          <source>LIFETIME_OR_LABEL :</source>
          <target state="translated">LIFETIME_OR_LABEL 。</target>
        </trans-unit>
        <trans-unit id="46318a9c5b3843dedcc74d3eda791e4202987f7e" translate="yes" xml:space="preserve">
          <source>LIFETIME_TOKEN :</source>
          <target state="translated">LIFETIME_TOKEN :</target>
        </trans-unit>
        <trans-unit id="ed2747925f72878526dce1d4b02fb7c509e9b22b" translate="yes" xml:space="preserve">
          <source>LINE_COMMENT :</source>
          <target state="translated">LINE_COMMENT :</target>
        </trans-unit>
        <trans-unit id="f87b1be490e7f2bd1d43aa401d9acb86c892b5d9" translate="yes" xml:space="preserve">
          <source>LLVM checks the validity of the constraints and the assembly string passed to it. This error implies that LLVM seems something wrong with the inline assembly call.</source>
          <target state="translated">LLVM检查约束条件和传递给它的汇编字符串的有效性。这个错误意味着LLVM的内联装配体调用似乎有问题。</target>
        </trans-unit>
        <trans-unit id="9b658c08127be6d116e98bc8876055e873db0602" translate="yes" xml:space="preserve">
          <source>LLVM-style inline assembly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c275bc5d1a4e6d0414829b996cfcec4698e44c4" translate="yes" xml:space="preserve">
          <source>LN_10</source>
          <target state="translated">LN_10</target>
        </trans-unit>
        <trans-unit id="6a259766cb7d3ece474214d8a5b06e89f14ab44c" translate="yes" xml:space="preserve">
          <source>LN_2</source>
          <target state="translated">LN_2</target>
        </trans-unit>
        <trans-unit id="98673bb5e17015cbf16ed84d89d8f970845d818b" translate="yes" xml:space="preserve">
          <source>LOG10_2</source>
          <target state="translated">LOG10_2</target>
        </trans-unit>
        <trans-unit id="66e6842f3da223e16de827da3acf936ddc9d0df5" translate="yes" xml:space="preserve">
          <source>LOG10_E</source>
          <target state="translated">LOG10_E</target>
        </trans-unit>
        <trans-unit id="615a1422d501618265e393e3550ecb5f40f525ea" translate="yes" xml:space="preserve">
          <source>LOG2_10</source>
          <target state="translated">LOG2_10</target>
        </trans-unit>
        <trans-unit id="1e3656097aebf0f10597eae43f1c807651a96817" translate="yes" xml:space="preserve">
          <source>LOG2_E</source>
          <target state="translated">LOG2_E</target>
        </trans-unit>
        <trans-unit id="64b87b109e5db684a74aa921ff29dc63050bf704" translate="yes" xml:space="preserve">
          <source>Lang items are already implemented in the standard library. Unless you are writing a free-standing application (e.g., a kernel), you do not need to provide them yourself.</source>
          <target state="translated">Lang项目已经在标准库中实现了。除非你正在编写一个独立的应用程序(例如,内核),否则你不需要自己提供它们。</target>
        </trans-unit>
        <trans-unit id="ec882b1a036e4071e5191bd244e46720429e3479" translate="yes" xml:space="preserve">
          <source>Languages without case are not changed:</source>
          <target state="translated">没有大小写的语言不改变。</target>
        </trans-unit>
        <trans-unit id="8f3396549fa1fe2041e1f31d203c0b16d63a7207" translate="yes" xml:space="preserve">
          <source>Large amounts of data are being stored</source>
          <target state="translated">大量的数据正在被存储</target>
        </trans-unit>
        <trans-unit id="d3612663cc19e49c3a2d261d922690a9fc7582ed" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f32&lt;/code&gt; value.</source>
          <target state="translated">最大的有限 &lt;code&gt;f32&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="cdef2a389723afff7da4b608a1325e2bd13839b5" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f32&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MAX&quot;&gt;&lt;code&gt;f32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f275a12dc16bf46e1c9b02d6b9bdd0fdd3cd4f44" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f64&lt;/code&gt; value.</source>
          <target state="translated">最大的有限 &lt;code&gt;f64&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="caa7ded1cda53ab540342fa3edd4f2916d1b87b9" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f64&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MAX&quot;&gt;&lt;code&gt;f64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58d72036ad47fa0a1439cec22ee87f753fd7e3f" translate="yes" xml:space="preserve">
          <source>Last, but certainly not least, is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. This type is used as the return type of many &lt;code&gt;std::io&lt;/code&gt; functions that can cause an error, and can be returned from your own functions as well. Many of the examples in this module use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">最后但并非最不重要的是&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;。此类型用作许多 &lt;code&gt;std::io&lt;/code&gt; 函数的返回类型，这些函数可能会导致错误，也可以从您自己的函数中返回。此模块中的许多示例都使用&lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; 。操作员&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="972ad8d8a50397ba8c02433ed8f048eeb4074b85" translate="yes" xml:space="preserve">
          <source>Layout</source>
          <target state="translated">Layout</target>
        </trans-unit>
        <trans-unit id="ae8568d10c64dba6b746ac76005e66dab74cb9ab" translate="yes" xml:space="preserve">
          <source>Layout of a block of memory.</source>
          <target state="translated">一个内存块的布局。</target>
        </trans-unit>
        <trans-unit id="7d4179a87c3ab99e827a9f6e1aa71781644d0b85" translate="yes" xml:space="preserve">
          <source>Layout::align</source>
          <target state="translated">Layout::align</target>
        </trans-unit>
        <trans-unit id="2b7cae98e285326dfa8874cd827b7060dafbb97f" translate="yes" xml:space="preserve">
          <source>Layout::align_to</source>
          <target state="translated">Layout::align_to</target>
        </trans-unit>
        <trans-unit id="6ffbac24ba5cb9cdd880e70819658687db1a163d" translate="yes" xml:space="preserve">
          <source>Layout::array</source>
          <target state="translated">Layout::array</target>
        </trans-unit>
        <trans-unit id="faf545bb524583c428a14d8796fd332e8b1f4538" translate="yes" xml:space="preserve">
          <source>Layout::borrow</source>
          <target state="translated">Layout::borrow</target>
        </trans-unit>
        <trans-unit id="6e7c904826d6356b87a5fd10b67922e27e248f36" translate="yes" xml:space="preserve">
          <source>Layout::borrow_mut</source>
          <target state="translated">Layout::borrow_mut</target>
        </trans-unit>
        <trans-unit id="e98c55355125dbd6a52d2480ae5f678bafc47354" translate="yes" xml:space="preserve">
          <source>Layout::clone</source>
          <target state="translated">Layout::clone</target>
        </trans-unit>
        <trans-unit id="2687d55f8151ff4e3d3dfd56105fc50d005dbef6" translate="yes" xml:space="preserve">
          <source>Layout::clone_from</source>
          <target state="translated">Layout::clone_from</target>
        </trans-unit>
        <trans-unit id="d247f8af0b3641c1febfca5a66104f7e6cd7ae07" translate="yes" xml:space="preserve">
          <source>Layout::clone_into</source>
          <target state="translated">Layout::clone_into</target>
        </trans-unit>
        <trans-unit id="28c4c39a207293b5ac856dadaca01591e69acdf2" translate="yes" xml:space="preserve">
          <source>Layout::eq</source>
          <target state="translated">Layout::eq</target>
        </trans-unit>
        <trans-unit id="807fbd84446164c635ef92d05b4f032e4e469c63" translate="yes" xml:space="preserve">
          <source>Layout::extend</source>
          <target state="translated">Layout::extend</target>
        </trans-unit>
        <trans-unit id="8a66e95e85ef65243dad3fec906d59a444e63307" translate="yes" xml:space="preserve">
          <source>Layout::extend_packed</source>
          <target state="translated">Layout::extend_packed</target>
        </trans-unit>
        <trans-unit id="ebdf1907153114cac58ba5ec846d319f09e3c275" translate="yes" xml:space="preserve">
          <source>Layout::fmt</source>
          <target state="translated">Layout::fmt</target>
        </trans-unit>
        <trans-unit id="aab6fc5da3370994e8eb6ae5619aeb20b2942b01" translate="yes" xml:space="preserve">
          <source>Layout::for_value</source>
          <target state="translated">Layout::for_value</target>
        </trans-unit>
        <trans-unit id="804e6daf71de8cbddc2847d4efac40f08b730f12" translate="yes" xml:space="preserve">
          <source>Layout::from</source>
          <target state="translated">Layout::from</target>
        </trans-unit>
        <trans-unit id="9c52da202dbc1e86eb154e999a408fd8e5fbffba" translate="yes" xml:space="preserve">
          <source>Layout::from_size_align</source>
          <target state="translated">Layout::from_size_align</target>
        </trans-unit>
        <trans-unit id="97f7ac20412edfee9be62fc236598951052b803a" translate="yes" xml:space="preserve">
          <source>Layout::from_size_align_unchecked</source>
          <target state="translated">Layout::from_size_align_unchecked</target>
        </trans-unit>
        <trans-unit id="9cb8530d3128b6bd4c274c8e7e0e34f2f70b863a" translate="yes" xml:space="preserve">
          <source>Layout::into</source>
          <target state="translated">Layout::into</target>
        </trans-unit>
        <trans-unit id="e888b6d02ea4794c5fef327a295c976cc60f99e3" translate="yes" xml:space="preserve">
          <source>Layout::ne</source>
          <target state="translated">Layout::ne</target>
        </trans-unit>
        <trans-unit id="f8038f15aebe6dce4d4de95b3c13e472d2b02064" translate="yes" xml:space="preserve">
          <source>Layout::new</source>
          <target state="translated">Layout::new</target>
        </trans-unit>
        <trans-unit id="c67933e7b53ec19707602158f0983ec3386107e4" translate="yes" xml:space="preserve">
          <source>Layout::pad_to_align</source>
          <target state="translated">Layout::pad_to_align</target>
        </trans-unit>
        <trans-unit id="fb534b2d9180d9c41c85be4f3cc7a5e10900d871" translate="yes" xml:space="preserve">
          <source>Layout::padding_needed_for</source>
          <target state="translated">Layout::padding_needed_for</target>
        </trans-unit>
        <trans-unit id="a53e256b922777e3d8b52ed41502d58861453b8a" translate="yes" xml:space="preserve">
          <source>Layout::repeat</source>
          <target state="translated">Layout::repeat</target>
        </trans-unit>
        <trans-unit id="ac76fcd730f9145d3ef5771a73793f24557f189a" translate="yes" xml:space="preserve">
          <source>Layout::repeat_packed</source>
          <target state="translated">Layout::repeat_packed</target>
        </trans-unit>
        <trans-unit id="39b88a7f119bc78ddb9f4adea7781765100ba7de" translate="yes" xml:space="preserve">
          <source>Layout::size</source>
          <target state="translated">Layout::size</target>
        </trans-unit>
        <trans-unit id="4fc54c6aa1d00c912811a3198ba6c26a31cb141d" translate="yes" xml:space="preserve">
          <source>Layout::to_owned</source>
          <target state="translated">Layout::to_owned</target>
        </trans-unit>
        <trans-unit id="ec3e4dd97b8bdfbb69e8e8a4fe407933742763da" translate="yes" xml:space="preserve">
          <source>Layout::try_from</source>
          <target state="translated">Layout::try_from</target>
        </trans-unit>
        <trans-unit id="e7254c8b2c904f17a579a6512de1c3f53903e338" translate="yes" xml:space="preserve">
          <source>Layout::try_into</source>
          <target state="translated">Layout::try_into</target>
        </trans-unit>
        <trans-unit id="69613b626753f65b515ca28b5fe4fd7436a0a88d" translate="yes" xml:space="preserve">
          <source>Layout::type_id</source>
          <target state="translated">Layout::type_id</target>
        </trans-unit>
        <trans-unit id="6b15514a909ca7b027740ad8a4c4fe6fbfdeead1" translate="yes" xml:space="preserve">
          <source>LayoutErr</source>
          <target state="translated">LayoutErr</target>
        </trans-unit>
        <trans-unit id="18ae5986925972906df162748403c4571a3bd382" translate="yes" xml:space="preserve">
          <source>LayoutErr::borrow</source>
          <target state="translated">LayoutErr::borrow</target>
        </trans-unit>
        <trans-unit id="92579002fabcdb4525eb6353397c1fc960583290" translate="yes" xml:space="preserve">
          <source>LayoutErr::borrow_mut</source>
          <target state="translated">LayoutErr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1c9995b499c2000f5ea89f003f69988ad4d9295a" translate="yes" xml:space="preserve">
          <source>LayoutErr::cause</source>
          <target state="translated">LayoutErr::cause</target>
        </trans-unit>
        <trans-unit id="8694453e9f4b16d83cc25ab2975ab170ff1ad8c9" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone</source>
          <target state="translated">LayoutErr::clone</target>
        </trans-unit>
        <trans-unit id="b630e1b5713feb7087721a06315e5b984a418a6f" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone_from</source>
          <target state="translated">LayoutErr::clone_from</target>
        </trans-unit>
        <trans-unit id="c42cb73e4c87ec15d8bccdf73bd650c9df417b9b" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone_into</source>
          <target state="translated">LayoutErr::clone_into</target>
        </trans-unit>
        <trans-unit id="3d5c517ec7fe54611274ae766b7e9a7911dc4865" translate="yes" xml:space="preserve">
          <source>LayoutErr::description</source>
          <target state="translated">LayoutErr::description</target>
        </trans-unit>
        <trans-unit id="497868f6f797da1325f8a9e9334379ca52fe4d37" translate="yes" xml:space="preserve">
          <source>LayoutErr::eq</source>
          <target state="translated">LayoutErr::eq</target>
        </trans-unit>
        <trans-unit id="3e42ce22d91446434898d46efd3223372301d536" translate="yes" xml:space="preserve">
          <source>LayoutErr::fmt</source>
          <target state="translated">LayoutErr::fmt</target>
        </trans-unit>
        <trans-unit id="73c4ad8234e8ca96453bac67aff91d0248f854d8" translate="yes" xml:space="preserve">
          <source>LayoutErr::from</source>
          <target state="translated">LayoutErr::from</target>
        </trans-unit>
        <trans-unit id="c3349dca57dd20451bc1fb01674dae961d63e9ce" translate="yes" xml:space="preserve">
          <source>LayoutErr::into</source>
          <target state="translated">LayoutErr::into</target>
        </trans-unit>
        <trans-unit id="f0f74e1ec8093e352aa9e8a3fd380fef9597b057" translate="yes" xml:space="preserve">
          <source>LayoutErr::ne</source>
          <target state="translated">LayoutErr::ne</target>
        </trans-unit>
        <trans-unit id="13438de55c63f100651925816f56012c5f1b1197" translate="yes" xml:space="preserve">
          <source>LayoutErr::source</source>
          <target state="translated">LayoutErr::source</target>
        </trans-unit>
        <trans-unit id="3bbdcbefa6e28507c6b0c6c634c7c7dc826a8bf4" translate="yes" xml:space="preserve">
          <source>LayoutErr::to_owned</source>
          <target state="translated">LayoutErr::to_owned</target>
        </trans-unit>
        <trans-unit id="2ec834ea6aa3644afac64a7ad23be1e1d6c10755" translate="yes" xml:space="preserve">
          <source>LayoutErr::to_string</source>
          <target state="translated">LayoutErr::to_string</target>
        </trans-unit>
        <trans-unit id="569d09cda7ad780d06bfd86cc93c53c21d1d507f" translate="yes" xml:space="preserve">
          <source>LayoutErr::try_from</source>
          <target state="translated">LayoutErr::try_from</target>
        </trans-unit>
        <trans-unit id="da95ddd29b8a42941df811e96eda4d3f3b529f15" translate="yes" xml:space="preserve">
          <source>LayoutErr::try_into</source>
          <target state="translated">LayoutErr::try_into</target>
        </trans-unit>
        <trans-unit id="b157e123211e4f6e633b31e52c5a1dcb6f18cc93" translate="yes" xml:space="preserve">
          <source>LayoutErr::type_id</source>
          <target state="translated">LayoutErr::type_id</target>
        </trans-unit>
        <trans-unit id="882d7824546e260d7aecb582ca23a9e9525d35d8" translate="yes" xml:space="preserve">
          <source>Laziness</source>
          <target state="translated">Laziness</target>
        </trans-unit>
        <trans-unit id="1a855a2a58b53f62fc3df50bb4fbd170d6d9104f" translate="yes" xml:space="preserve">
          <source>Lazy boolean operators</source>
          <target state="translated">懒惰的布尔运算符</target>
        </trans-unit>
        <trans-unit id="7e80f065af51812290038b5aef5b515381e7b069" translate="yes" xml:space="preserve">
          <source>Lazy values and one-time initialization of static data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="5c517a3f3609c8f91e1addb0b08b45eb552a8056" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace represent an error.</source>
          <target state="translated">前面和后面的空格代表错误。</target>
        </trans-unit>
        <trans-unit id="171d90f8bc7e44b38d039153f89d2f57be6e9170" translate="yes" xml:space="preserve">
          <source>Leak an I/O object, never closing the file:</source>
          <target state="translated">泄露一个I/O对象,从不关闭文件。</target>
        </trans-unit>
        <trans-unit id="0c87712acc6d428c2446529002e5d51f0d06f2b8" translate="yes" xml:space="preserve">
          <source>Leaks of memory and other resources</source>
          <target state="translated">内存和其他资源的泄漏</target>
        </trans-unit>
        <trans-unit id="4a0f6a000e4abc155c2355349886b493447a871e" translate="yes" xml:space="preserve">
          <source>Learn a bit about TCP and HTTP.</source>
          <target state="translated">了解一下TCP和HTTP。</target>
        </trans-unit>
        <trans-unit id="3b3bf48bce1a18fd95b7ca358e1f16b46d7a4f20" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;reference/attributes#conditional-compilation&quot;&gt;Conditional Compilation&lt;/a&gt; section of the Reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee627fb00174e09c28a9f8c4feb833b6e5f743c" translate="yes" xml:space="preserve">
          <source>Leaves the original &lt;code&gt;Option&lt;/code&gt; in-place, creating a new one containing a mutable reference to the inner type's &lt;code&gt;Deref::Target&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7cf535c3451fcfd6307510b8776e34c835efbed" translate="yes" xml:space="preserve">
          <source>Leaves the original Option in-place, creating a new one with a reference to the original one, additionally coercing the contents via &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c694f6b8cb7b00330c4d48a5ced6de4ae07bc6" translate="yes" xml:space="preserve">
          <source>Leaves the original Option in-place, creating a new one with a reference to the original one, additionally coercing the contents via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">将原始Option &lt;code&gt;Deref&lt;/code&gt; 在原位，创建一个对原始Option的引用，并通过Deref强制执行内容。</target>
        </trans-unit>
        <trans-unit id="fbc8d1a601145e0b8a0f4e2783062a13702a5915" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing both the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; arms of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">将原始Result留在原处，创建一个引用原始Result的引用，另外通过 &lt;code&gt;Deref&lt;/code&gt; 强制 Result 的 &lt;code&gt;Ok&lt;/code&gt; 和 &lt;code&gt;Err&lt;/code&gt; 臂。</target>
        </trans-unit>
        <trans-unit id="35c9a587594a401fda69e05b935e4d8b2ac65ada" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing the &lt;code&gt;Err&lt;/code&gt; arm of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">将原始Result留在原处，创建一个参照原始Result的引用，另外通过 &lt;code&gt;Deref&lt;/code&gt; 强制 Result 的 &lt;code&gt;Err&lt;/code&gt; 臂。</target>
        </trans-unit>
        <trans-unit id="50d3f8b919eb6aee8c76227d9ffbe9d9e4ef3631" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing the &lt;code&gt;Ok&lt;/code&gt; arm of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">将原始Result留在原处，创建一个引用原始Result的引用，另外通过 &lt;code&gt;Deref&lt;/code&gt; 强制 Result 的 &lt;code&gt;Ok&lt;/code&gt; 臂。</target>
        </trans-unit>
        <trans-unit id="494064e70529e54389ad678d759801779c5c72df" translate="yes" xml:space="preserve">
          <source>Left Shift</source>
          <target state="translated">左移</target>
        </trans-unit>
        <trans-unit id="357a167cfbb492462507b9b8569ac04e39500116" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;数组索引&lt;/a&gt;表达式中的左操作数。</target>
        </trans-unit>
        <trans-unit id="802deb5f6a24f0153e1b52a743d60aef22ab93a7" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/call-expr&quot;&gt;调用表达式中的&lt;/a&gt;左操作数。</target>
        </trans-unit>
        <trans-unit id="3463667b7fa2b91f4f33b26ea8c6945778008832" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;expressions/field-expr&quot;&gt;字段&lt;/a&gt;表达式中的左操作数。</target>
        </trans-unit>
        <trans-unit id="604e7ca527ffc17876e5a83a46e96dfa0fc8df57" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method-call&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;expressions/method-call-expr&quot;&gt;方法调用&lt;/a&gt;表达式中的左操作数。</target>
        </trans-unit>
        <trans-unit id="eb226dadb2d69601a2e88f0aff30921d841ff9e2" translate="yes" xml:space="preserve">
          <source>Left operands of the &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;复合赋值的&lt;/a&gt;左操作数。</target>
        </trans-unit>
        <trans-unit id="c80da6a471da3578e154404c086273e1a0815411" translate="yes" xml:space="preserve">
          <source>Left-shift</source>
          <target state="translated">Left-shift</target>
        </trans-unit>
        <trans-unit id="b5ac21daa5921e49b42d9ee7f63e24eef4f4e0f5" translate="yes" xml:space="preserve">
          <source>Left-shift and assignment</source>
          <target state="translated">左移和分配</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">低于</target>
        </trans-unit>
        <trans-unit id="2dd999a5f745b11640e747579b45ca334f6bd164" translate="yes" xml:space="preserve">
          <source>Less than comparison</source>
          <target state="translated">低于比较</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">小于或等于</target>
        </trans-unit>
        <trans-unit id="4c0c7f8feba1a3be504536a32e6253de66037beb" translate="yes" xml:space="preserve">
          <source>Less than or equal to comparison</source>
          <target state="translated">小于或等于比较</target>
        </trans-unit>
        <trans-unit id="2bf9b5b6040aab2674d9953c9b7c713583f20dae" translate="yes" xml:space="preserve">
          <source>Less-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">小于两个 &lt;code&gt;Arc&lt;/code&gt; 的比较。</target>
        </trans-unit>
        <trans-unit id="e86e08a482dea944d87e01c7d1358debb5cc8f8f" translate="yes" xml:space="preserve">
          <source>Less-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">小于两个 &lt;code&gt;Rc&lt;/code&gt; 的比较。</target>
        </trans-unit>
        <trans-unit id="023a23666ee1826dd775c67ffcc792722addcad9" translate="yes" xml:space="preserve">
          <source>Let ALPHA_SET(M) = FIRST(&lt;code&gt;&amp;alpha;&lt;/code&gt;) if OP = &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; and ALPHA_SET(M) = {} if OP = &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">如果OP = &lt;code&gt;\*&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; ,则使ALPHA_SET（M）= FIRST（ &lt;code&gt;&amp;alpha;&lt;/code&gt; ）。如果OP = &lt;code&gt;+&lt;/code&gt; ，则为ALPHA_SET（M）= {} 。</target>
        </trans-unit>
        <trans-unit id="c00ee374b6dc82a14932bb4fd3e12ef63fb5d55f" translate="yes" xml:space="preserve">
          <source>Let SEP_SET(M) = { SEP } if SEP is present and &amp;epsilon; &amp;isin; FIRST(&lt;code&gt;tt ...&lt;/code&gt;); otherwise SEP_SET(M) = {}.</source>
          <target state="translated">如果存在SEP并且&amp;epsilon;&amp;isin;FIRST（ &lt;code&gt;tt ...&lt;/code&gt; ），则令SEP_SET（M）= {SEP} ; 否则SEP_SET（M）= {}。</target>
        </trans-unit>
        <trans-unit id="53530264e4da661c5ecd3e262365a6de39f515ea" translate="yes" xml:space="preserve">
          <source>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</source>
          <target state="translated">让sep_set={SEP },如果SEP存在;否则sep_set={}。</target>
        </trans-unit>
        <trans-unit id="911e3ff1d34feb7b7cd623e6d1a6a2dd2992b8d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add another test, but this time we&amp;rsquo;ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. We talked about the simplest way to cause a panic in Chapter 9, which is to call the &lt;code&gt;panic!&lt;/code&gt; macro. Enter the new test, &lt;code&gt;another&lt;/code&gt;, so your &lt;em&gt;src/lib.rs&lt;/em&gt; file looks like Listing 11-3.</source>
          <target state="translated">让我们添加另一个测试，但是这次我们将进行失败的测试！当测试功能出现紧急情况时，测试将失败。每个测试都在一个新线程中运行，并且当主线程看到某个测试线程已死亡时，该测试将标记为失败。我们在第9章中讨论了引起恐慌的最简单方法，即所谓的 &lt;code&gt;panic!&lt;/code&gt; 宏。输入 &lt;code&gt;another&lt;/code&gt; 新测试，因此您的&lt;em&gt;src / lib.rs&lt;/em&gt;文件类似于清单11-3。</target>
        </trans-unit>
        <trans-unit id="862ded2868716c0b1f9c7eb816092a939af7bcb0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s address the second error, which points to the code at the end of &lt;code&gt;Worker::new&lt;/code&gt;; we need to wrap the &lt;code&gt;thread&lt;/code&gt; value in &lt;code&gt;Some&lt;/code&gt; when we create a new &lt;code&gt;Worker&lt;/code&gt;. Make the following changes to fix this error:</source>
          <target state="translated">让我们解决第二个错误，它指向 &lt;code&gt;Worker::new&lt;/code&gt; 结尾的代码；创建新的 &lt;code&gt;Worker&lt;/code&gt; 时，需要将 &lt;code&gt;thread&lt;/code&gt; 值包装在 &lt;code&gt;Some&lt;/code&gt; 中。进行以下更改以纠正此错误：</target>
        </trans-unit>
        <trans-unit id="2f2efb01063714d86b5480ed1b824b067b1a031d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s address these four problems by refactoring our project.</source>
          <target state="translated">让我们通过重构项目来解决这四个问题。</target>
        </trans-unit>
        <trans-unit id="533040ac56d9f1aa4e4c0e2a9a9719c3755f6d7a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also make the &lt;code&gt;add_to_waitlist&lt;/code&gt; function public by adding the &lt;code&gt;pub&lt;/code&gt; keyword before its definition, as in Listing 7-7.</source>
          <target state="translated">我们还通过在定义之前添加 &lt;code&gt;pub&lt;/code&gt; 关键字来使 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数公开，如清单7-7所示。</target>
        </trans-unit>
        <trans-unit id="ea4a0f30216adf2bf51b73cd6dbecc829205bb86" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s apply the first rule: each parameter gets its own lifetime. This time we have two parameters instead of one, so we have two lifetimes:</source>
          <target state="translated">让我们应用第一个规则：每个参数都有自己的生存期。这次我们有两个参数，而不是一个，因此有两个生存期：</target>
        </trans-unit>
        <trans-unit id="0bfaeb7ed44c7ba50fa8b27070055c189f55db1b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break down the &lt;code&gt;match&lt;/code&gt; in the &lt;code&gt;value_in_cents&lt;/code&gt; function. First, we list the &lt;code&gt;match&lt;/code&gt; keyword followed by an expression, which in this case is the value &lt;code&gt;coin&lt;/code&gt;. This seems very similar to an expression used with &lt;code&gt;if&lt;/code&gt;, but there&amp;rsquo;s a big difference: with &lt;code&gt;if&lt;/code&gt;, the expression needs to return a Boolean value, but here, it can be any type. The type of &lt;code&gt;coin&lt;/code&gt; in this example is the &lt;code&gt;Coin&lt;/code&gt; enum that we defined on line 1.</source>
          <target state="translated">让我们在 &lt;code&gt;value_in_cents&lt;/code&gt; 函数中分解 &lt;code&gt;match&lt;/code&gt; 。首先，我们列出 &lt;code&gt;match&lt;/code&gt; 关键字，后跟一个表达式，在本例中为value &lt;code&gt;coin&lt;/code&gt; 。这似乎与 &lt;code&gt;if&lt;/code&gt; 一起使用的表达式非常相似，但是有一个很大的区别：与 &lt;code&gt;if&lt;/code&gt; 一起，该表达式需要返回一个布尔值，但是在这里，它可以是任何类型。在此示例中， &lt;code&gt;coin&lt;/code&gt; 的类型是我们在第1行中定义的 &lt;code&gt;Coin&lt;/code&gt; 枚举。</target>
        </trans-unit>
        <trans-unit id="f56b403e93973d8ea8cf3d0611a5804ed42ec21f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break down this request data to understand what the browser is asking of our program.</source>
          <target state="translated">让我们分解一下请求数据，以了解浏览器对我们程序的要求。</target>
        </trans-unit>
        <trans-unit id="b36a5ce769815370ab06336595b70e1c5c477b25" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s briefly look at the syntax of specifying generic type parameters, trait bounds, and lifetimes all in one function!</source>
          <target state="translated">让我们简单地看一下在一个函数中指定泛型类型参数，特征范围和生存期的语法！</target>
        </trans-unit>
        <trans-unit id="0b5fe379df9523f20646a85915698650e52f567f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s build a smart pointer similar to the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library to experience how smart pointers behave differently from references by default. Then we&amp;rsquo;ll look at how to add the ability to use the dereference operator.</source>
          <target state="translated">让我们构建一个类似于标准库提供的 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 类型的智能指针，以体验默认情况下智能指针的行为与引用的不同。然后，我们将研究如何添加使用解引用运算符的功能。</target>
        </trans-unit>
        <trans-unit id="a51f4557e798f86ab9a943604a40558633731ed7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s build the workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory!</source>
          <target state="translated">让我们通过在顶级&lt;em&gt;添加&lt;/em&gt;目录中运行 &lt;code&gt;cargo build&lt;/code&gt; 来构建工作区！&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f04507c41a7a28beafb3cead61fdadb3dea0a6f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s call a function that returns a &lt;code&gt;Result&lt;/code&gt; value because the function could fail. In Listing 9-3 we try to open a file.</source>
          <target state="translated">让我们调用一个返回 &lt;code&gt;Result&lt;/code&gt; 值的函数，因为该函数可能会失败。在清单9-3中，我们尝试打开一个文件。</target>
        </trans-unit>
        <trans-unit id="a513da811ee53d6a1f83cac6544789f14693ebd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change our working example in Listing 15-18 so we can see the reference counts changing as we create and drop references to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">让我们改变上市15-18在我们工作的例子，所以我们可以看到引用计数改变，因为我们创造和下降引用 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13b7e2a02ac5f6f1d6e7771973bf7e4e8630f77c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;area&lt;/code&gt; function that has a &lt;code&gt;Rectangle&lt;/code&gt; instance as a parameter and instead make an &lt;code&gt;area&lt;/code&gt; method defined on the &lt;code&gt;Rectangle&lt;/code&gt; struct, as shown in Listing 5-13.</source>
          <target state="translated">让我们更改将 &lt;code&gt;Rectangle&lt;/code&gt; 实例作为参数的 &lt;code&gt;area&lt;/code&gt; 函数，改为在 &lt;code&gt;Rectangle&lt;/code&gt; 结构上定义一个 &lt;code&gt;area&lt;/code&gt; 方法，如清单5-13所示。</target>
        </trans-unit>
        <trans-unit id="a1f781d100edd0654c8707256174d0183b82ca21" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the name of our test to see how that changes the test output. Change the &lt;code&gt;it_works&lt;/code&gt; function to a different name, such as &lt;code&gt;exploration&lt;/code&gt;, like so:</source>
          <target state="translated">让我们更改测试名称，以了解如何更改测试输出。更改 &lt;code&gt;it_works&lt;/code&gt; 功能不同的名称，如 &lt;code&gt;exploration&lt;/code&gt; ，就像这样：</target>
        </trans-unit>
        <trans-unit id="e085a2cf9e4bfbccd609eb67b047befe0756bfad" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check that it passes!</source>
          <target state="translated">让我们检查它是否通过！</target>
        </trans-unit>
        <trans-unit id="6e6584addded7d162e25546426216dd008dbd0f0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check the code again:</source>
          <target state="translated">让我们再次检查代码：</target>
        </trans-unit>
        <trans-unit id="58ec20357926eeae9e87a4ac077cb4fc985ca821" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s combine the knowledge you learned in this chapter and in previous chapters to work on a project!</source>
          <target state="translated">让我们结合您在本章和前几章中学到的知识来进行项目！</target>
        </trans-unit>
        <trans-unit id="7729d445e0c4aa723c02605775741a07569ce3c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the first part of &lt;code&gt;main&lt;/code&gt; in Listing 17-11:</source>
          <target state="translated">让我们考虑清单17-11 中 &lt;code&gt;main&lt;/code&gt; 的第一部分：</target>
        </trans-unit>
        <trans-unit id="9bd7feb2aa1c163d92ba2edc07ccaeec3f556691" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a crate named &lt;code&gt;hello_macro&lt;/code&gt; that defines a trait named &lt;code&gt;HelloMacro&lt;/code&gt; with one associated function named &lt;code&gt;hello_macro&lt;/code&gt;. Rather than making our crate users implement the &lt;code&gt;HelloMacro&lt;/code&gt; trait for each of their types, we&amp;rsquo;ll provide a procedural macro so users can annotate their type with &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; to get a default implementation of the &lt;code&gt;hello_macro&lt;/code&gt; function. The default implementation will print &lt;code&gt;Hello, Macro! My name is TypeName!&lt;/code&gt; where &lt;code&gt;TypeName&lt;/code&gt; is the name of the type on which this trait has been defined. In other words, we&amp;rsquo;ll write a crate that enables another programmer to write code like Listing 19-30 using our crate.</source>
          <target state="translated">让我们创建一个名为 &lt;code&gt;hello_macro&lt;/code&gt; 的包装箱，该包装箱使用一个名为 &lt;code&gt;hello_macro&lt;/code&gt; 的关联函数定义一个名为 &lt;code&gt;HelloMacro&lt;/code&gt; 的特征。而不是让我们的箱子用户实现 &lt;code&gt;HelloMacro&lt;/code&gt; 特质对他们的每一个类型的，我们将提供一个程序宏，以便用户可以使用他们的标注类型 &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; 得到的默认实现 &lt;code&gt;hello_macro&lt;/code&gt; 功能。默认实现将打印 &lt;code&gt;Hello, Macro! My name is TypeName!&lt;/code&gt; 其中 &lt;code&gt;TypeName&lt;/code&gt; 是已定义此特征的类型的名称。换句话说，我们将编写一个包装箱，该包装箱使另一个程序员可以使用我们的包装箱编写清单19-30所示的代码。</target>
        </trans-unit>
        <trans-unit id="9e2142a26e44f4e6756b16f8090c68fc06e7085b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new library project called &lt;code&gt;adder&lt;/code&gt;:</source>
          <target state="translated">让我们创建一个名为 &lt;code&gt;adder&lt;/code&gt; 的新库项目：</target>
        </trans-unit>
        <trans-unit id="9c7399eee11ccb14463b23d58e457c71508e98d8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project using Cargo and look at how it differs from our original &amp;ldquo;Hello, world!&amp;rdquo; project. Navigate back to your &lt;em&gt;projects&lt;/em&gt; directory (or wherever you decided to store your code). Then, on any operating system, run the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d473890aa102e1a8805b09a6342b2b1e9d3dd1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project using Cargo and look at how it differs from our original Hello, world! project. Navigate back to your &lt;em&gt;projects&lt;/em&gt; directory (or wherever you decided to store your code). Then, on any operating system, run the following:</source>
          <target state="translated">让我们使用Cargo创建一个新项目，看看它与我们最初的Hello World有何不同！项目。导航回到您的&lt;em&gt;项目&lt;/em&gt;目录（或您决定存储代码的任何位置）。然后，在任何操作系统上，运行以下命令：</target>
        </trans-unit>
        <trans-unit id="74b1a7e7740baca8e782bfd3b97f4ca92299f7fa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project with, as always, &lt;code&gt;cargo new&lt;/code&gt;. We&amp;rsquo;ll call our project &lt;code&gt;minigrep&lt;/code&gt; to distinguish it from the &lt;code&gt;grep&lt;/code&gt; tool that you might already have on your system.</source>
          <target state="translated">与往常一样，让我们​​创建一个新项目，并添加 &lt;code&gt;cargo new&lt;/code&gt; 。我们将我们的项目 &lt;code&gt;minigrep&lt;/code&gt; 以将其与系统上可能已有的 &lt;code&gt;grep&lt;/code&gt; 工具区分开。</target>
        </trans-unit>
        <trans-unit id="7498e03400c34fc782316cecb8cfae701609c72c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create an integration test. With the code in Listing 11-12 still in the &lt;em&gt;src/lib.rs&lt;/em&gt; file, make a &lt;em&gt;tests&lt;/em&gt; directory, create a new file named &lt;em&gt;tests/integration_test.rs&lt;/em&gt;, and enter the code in Listing 11-13.</source>
          <target state="translated">让我们创建一个集成测试。在清单11-12中的代码仍在&lt;em&gt;src / lib.rs&lt;/em&gt;文件中的情况下，创建一个&lt;em&gt;tests&lt;/em&gt;目录，创建一个名为&lt;em&gt;tests / integration_test.rs&lt;/em&gt;的新文件，然后输入清单11-13中的代码。</target>
        </trans-unit>
        <trans-unit id="76a754330b004eb7ac6a2d3134c0ac997e30ee22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dig into the details of a dynamically sized type called &lt;code&gt;str&lt;/code&gt;, which we&amp;rsquo;ve been using throughout the book. That&amp;rsquo;s right, not &lt;code&gt;&amp;amp;str&lt;/code&gt;, but &lt;code&gt;str&lt;/code&gt; on its own, is a DST. We can&amp;rsquo;t know how long the string is until runtime, meaning we can&amp;rsquo;t create a variable of type &lt;code&gt;str&lt;/code&gt;, nor can we take an argument of type &lt;code&gt;str&lt;/code&gt;. Consider the following code, which does not work:</source>
          <target state="translated">让我们深入研究在整个本书中一直使用的称为 &lt;code&gt;str&lt;/code&gt; 的动态大小类型的细节。没错，不是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，而是 &lt;code&gt;str&lt;/code&gt; 本身就是DST。我们不知道字符串在运行时之前会持续多长时间，这意味着我们无法创建类型为 &lt;code&gt;str&lt;/code&gt; 的变量，也不能采用类型为 &lt;code&gt;str&lt;/code&gt; 的参数。考虑以下代码，该代码不起作用：</target>
        </trans-unit>
        <trans-unit id="135058566e52c47af5c9c244e255bc4ce73db5f0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive in!</source>
          <target state="translated">让我们潜入吧！</target>
        </trans-unit>
        <trans-unit id="5ea067197cecc0dcafe00ab16ce7bc41edb2cce3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s examine the difference between the two concepts with an example from Chapter 13 that implements the &lt;code&gt;Iterator&lt;/code&gt; trait on the &lt;code&gt;Counter&lt;/code&gt; struct. In Listing 13-21, we specified that the &lt;code&gt;Item&lt;/code&gt; type was &lt;code&gt;u32&lt;/code&gt;:</source>
          <target state="translated">让我们用第13章中的示例在 &lt;code&gt;Counter&lt;/code&gt; 结构上实现 &lt;code&gt;Iterator&lt;/code&gt; 特性的例子来研究这两个概念之间的区别。在清单13-21中，我们指定 &lt;code&gt;Item&lt;/code&gt; 类型为 &lt;code&gt;u32&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="51c8e9031bf91446f9115b59a4810cccd5e08ba7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s examine the first execution of &lt;code&gt;plus_one&lt;/code&gt; in more detail. When we call &lt;code&gt;plus_one(five)&lt;/code&gt;, the variable &lt;code&gt;x&lt;/code&gt; in the body of &lt;code&gt;plus_one&lt;/code&gt; will have the value &lt;code&gt;Some(5)&lt;/code&gt;. We then compare that against each match arm.</source>
          <target state="translated">让我们更详细地研究 &lt;code&gt;plus_one&lt;/code&gt; 的第一次执行。当我们调用 &lt;code&gt;plus_one(five)&lt;/code&gt; 时， &lt;code&gt;plus_one&lt;/code&gt; 主体中的变量 &lt;code&gt;x&lt;/code&gt; 的值将为 &lt;code&gt;Some(5)&lt;/code&gt; 。然后，我们将其与每个比赛手臂进行比较。</target>
        </trans-unit>
        <trans-unit id="6e71d1e8c50827371eaf73f583536f9bfaf50c55" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore the &lt;em&gt;cons list&lt;/em&gt;, which is a data type common in functional programming languages, as an example of a recursive type. The cons list type we&amp;rsquo;ll define is straightforward except for the recursion; therefore, the concepts in the example we&amp;rsquo;ll work with will be useful any time you get into more complex situations involving recursive types.</source>
          <target state="translated">让我们探索&lt;em&gt;cons list&lt;/em&gt;，它是函数式编程语言中常见的数据类型，作为递归类型的示例。我们将定义的缺点列表类型很简单，除了递归。因此，当您遇到涉及递归类型的更复杂情况时，我们将使用的示例中的概念将非常有用。</target>
        </trans-unit>
        <trans-unit id="8dd4037a982ed3562f2f33f83b29e377988c8c74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore this concept by looking at the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that follows the interior mutability pattern.</source>
          <target state="translated">让我们通过遵循内部可变性模式的 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型来探索这个概念。</target>
        </trans-unit>
        <trans-unit id="33abe13cd0e5ac2dde5cfd9e196411eace5691ef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s figure this out by simplifying the program. Instead of making 10 threads in a &lt;code&gt;for&lt;/code&gt; loop, let&amp;rsquo;s just make two threads without a loop and see what happens. Replace the first &lt;code&gt;for&lt;/code&gt; loop in Listing 16-13 with this code instead:</source>
          <target state="translated">让我们通过简化程序来解决这个问题。与其在一个 &lt;code&gt;for&lt;/code&gt; 循环中创建10个线程，不如让两个线程不循环地查看发生了什么。用下面的代码替换清单16-13中的第一个 &lt;code&gt;for&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="f074800650aafbfc4673a0db2d7d24603b94e675" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s finally implement the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. We&amp;rsquo;ll also change &lt;code&gt;Job&lt;/code&gt; from a struct to a type alias for a trait object that holds the type of closure that &lt;code&gt;execute&lt;/code&gt; receives. As discussed in the &lt;a href=&quot;ch19-04-advanced-types#creating-type-synonyms-with-type-aliases&quot;&gt;&amp;ldquo;Creating Type Synonyms with Type Aliases&amp;rdquo;&lt;/a&gt; section of Chapter 19, type aliases allow us to make long types shorter. Look at Listing 20-19.</source>
          <target state="translated">最后，让我们在 &lt;code&gt;ThreadPool&lt;/code&gt; 上实现 &lt;code&gt;execute&lt;/code&gt; 方法。我们还将 &lt;code&gt;Job&lt;/code&gt; 的结构从struct 更改为trait对象的类型别名，该对象持有 &lt;code&gt;execute&lt;/code&gt; 接收的闭包类型。如第19章&lt;a href=&quot;ch19-04-advanced-types#creating-type-synonyms-with-type-aliases&quot;&gt;&amp;ldquo;使用类型别名创建类型同义词&amp;rdquo;中&lt;/a&gt;所讨论的，类型别名使我们可以使长类型更短。看清单20-19。</target>
        </trans-unit>
        <trans-unit id="8d1bc217cc494100da333abaf87d765e4a86b4ca" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first look at how the dereference operator works with regular references. Then we&amp;rsquo;ll try to define a custom type that behaves like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and see why the dereference operator doesn&amp;rsquo;t work like a reference on our newly defined type. We&amp;rsquo;ll explore how implementing the &lt;code&gt;Deref&lt;/code&gt; trait makes it possible for smart pointers to work in a similar way as references. Then we&amp;rsquo;ll look at Rust&amp;rsquo;s &lt;em&gt;deref coercion&lt;/em&gt; feature and how it lets us work with either references or smart pointers.</source>
          <target state="translated">首先让我们看一下解除引用运算符如何与常规引用一起使用。然后，我们将尝试定义行为类似于 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 的自定义类型，并查看为什么取消引用运算符不能像对新定义的类型的引用那样工作。我们将探究如何实现 &lt;code&gt;Deref&lt;/code&gt; 特质使智能指针以与引用类似的方式工作。然后，我们将研究Rust的&lt;em&gt;deref强制&lt;/em&gt;功能以及它如何使我们使用引用或智能指针。</target>
        </trans-unit>
        <trans-unit id="16b3f7c211345e679774caea38315635e0c83e2f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first look at how the dereference operator works with regular references. Then we&amp;rsquo;ll try to define a custom type that behaves like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and see why the dereference operator doesn&amp;rsquo;t work like a reference on our newly defined type. We&amp;rsquo;ll explore how implementing the &lt;code&gt;Deref&lt;/code&gt; trait makes it possible for smart pointers to work in ways similar to references. Then we&amp;rsquo;ll look at Rust&amp;rsquo;s &lt;em&gt;deref coercion&lt;/em&gt; feature and how it lets us work with either references or smart pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5282924b8e4ccd503b1b10249bbf09058e192d22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started on the implementation of the library! We know we need a public &lt;code&gt;Post&lt;/code&gt; struct that holds some content, so we&amp;rsquo;ll start with the definition of the struct and an associated public &lt;code&gt;new&lt;/code&gt; function to create an instance of &lt;code&gt;Post&lt;/code&gt;, as shown in Listing 17-12. We&amp;rsquo;ll also make a private &lt;code&gt;State&lt;/code&gt; trait. Then &lt;code&gt;Post&lt;/code&gt; will hold a trait object of &lt;code&gt;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; inside an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; in a private field named &lt;code&gt;state&lt;/code&gt;. You&amp;rsquo;ll see why the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is necessary in a bit.</source>
          <target state="translated">让我们开始执行该库！我们知道我们需要一个包含一些内容的公共 &lt;code&gt;Post&lt;/code&gt; 结构，因此我们将从结构的定义和相关的public &lt;code&gt;new&lt;/code&gt; 函数开始，以创建 &lt;code&gt;Post&lt;/code&gt; 的实例，如清单17-12所示。我们还将制作一个私人 &lt;code&gt;State&lt;/code&gt; 特征。然后 &lt;code&gt;Post&lt;/code&gt; 将在名为 &lt;code&gt;state&lt;/code&gt; 的私有字段中的 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 内保存 &lt;code&gt;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; 的特征对象。您将很快了解为什么需要 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cf0779362e5e6e79905eb41dbbcf314ec8be6ec" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try! First, we&amp;rsquo;ll run our program without the environment variable set and with the query &lt;code&gt;to&lt;/code&gt;, which should match any line that contains the word &amp;ldquo;to&amp;rdquo; in all lowercase:</source>
          <target state="translated">试一试吧！首先，我们将在没有设置环境变量的情况下运行程序，并使用查询 &lt;code&gt;to&lt;/code&gt; ，该查询应匹配所有包含小写字母&amp;ldquo; to&amp;rdquo;的行：</target>
        </trans-unit>
        <trans-unit id="e21e94e46417f5d70be1f74cdc80a0200cf7ab38" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s imagine that a friend of ours is trying to collect all 50 state quarters. While we sort our loose change by coin type, we&amp;rsquo;ll also call out the name of the state associated with each quarter so if it&amp;rsquo;s one our friend doesn&amp;rsquo;t have, they can add it to their collection.</source>
          <target state="translated">假设我们的一个朋友正在尝试收集所有50个州的宿舍。当我们根据硬币类型对零钱进行分类时，我们还将标注与每个季度相关的州的名称，因此，如果这是我们的朋友所没有的状态，他们可以将其添加到他们的收藏中。</target>
        </trans-unit>
        <trans-unit id="d46ead76362decf8ea1c4631f151578daeb7b13e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the functionality for returning more than a blank page. Create a new file, &lt;em&gt;hello.html&lt;/em&gt;, in the root of your project directory, not in the &lt;em&gt;src&lt;/em&gt; directory. You can input any HTML you want; Listing 20-4 shows one possibility.</source>
          <target state="translated">让我们实现返回多个空白页的功能。在项目目录的根目录（而不是&lt;em&gt;src&lt;/em&gt;目录）中创建一个新文件&lt;em&gt;hello.html&lt;/em&gt;。您可以输入所需的任何HTML；清单20-4显示了一种可能性。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="875e251ee421cd235e0091a3ea3fc8e405d04cfd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the functionality to read the request from the browser! To separate the concerns of first getting a connection and then taking some action with the connection, we&amp;rsquo;ll start a new function for processing connections. In this new &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ll read data from the TCP stream and print it so we can see the data being sent from the browser. Change the code to look like Listing 20-2.</source>
          <target state="translated">让我们实现从浏览器读取请求的功能！为了分离首先获得连接然后对连接采取一些措施的关注点，我们将启动一个用于处理连接的新功能。在这个新的 &lt;code&gt;handle_connection&lt;/code&gt; 函数中，我们将从TCP流中读取数据并进行打印，以便可以看到浏览器发送的数据。更改代码，使其类似于清单20-2。</target>
        </trans-unit>
        <trans-unit id="b145c020f35d5cf12c1f16d9ae23adffafb9cf49" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s introduce a bug into our code to see what it looks like when a test that uses &lt;code&gt;assert_eq!&lt;/code&gt; fails. Change the implementation of the &lt;code&gt;add_two&lt;/code&gt; function to instead add &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">让我们在代码中引入一个错误，看看使用 &lt;code&gt;assert_eq!&lt;/code&gt; 进行测试时的外观！失败。将 &lt;code&gt;add_two&lt;/code&gt; 函数的实现更改为添加 &lt;code&gt;3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1a740028676c8b0002977c98fe2eec37d0bee51d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s introduce a bug into this code by changing &lt;code&gt;greeting&lt;/code&gt; to not include &lt;code&gt;name&lt;/code&gt; to see what this test failure looks like:</source>
          <target state="translated">让我们通过更改 &lt;code&gt;greeting&lt;/code&gt; 以不包含 &lt;code&gt;name&lt;/code&gt; 在此代码中引入错误，以查看此测试失败的样子：</target>
        </trans-unit>
        <trans-unit id="19083fee6a8cc87ffd6b0d04bb94a51935ddddce" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s jump into Rust by working through a hands-on project together! This chapter introduces you to a few common Rust concepts by showing you how to use them in a real program. You&amp;rsquo;ll learn about &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, using external crates, and more! The following chapters will explore these ideas in more detail. In this chapter, you&amp;rsquo;ll practice the fundamentals.</source>
          <target state="translated">让我们一起完成一个动手项目，进入Rust！本章通过向您展示如何在实际程序中使用它们，向您介绍了一些Rust的常见概念。您将学习 &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;match&lt;/code&gt; ，方法，关联函数，使用外部包装箱等！以下各章将更详细地探讨这些想法。在本章中，您将练习基础知识。</target>
        </trans-unit>
        <trans-unit id="63819f186c88b0330ee047bed09e478063cb1dae" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. These are the only possibilities for an IP address that our program will come across: we can &lt;em&gt;enumerate&lt;/em&gt; all possible values, which is where enumeration gets its name.</source>
          <target state="translated">让我们看一下我们可能想在代码中表达的情况，并查看在这种情况下为什么枚举比结构有用且更合适。假设我们需要使用IP地址。当前，IP地址使用两种主要标准：第四版和第六版。这些是程序遇到的IP地址的唯一可能性：我们可以&lt;em&gt;枚举&lt;/em&gt;所有可能的值，这就是枚举的名称。</target>
        </trans-unit>
        <trans-unit id="983a8ae99cfeef9a151c58849d32ffe20aab79f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. These are the only possibilities for an IP address that our program will come across: we can &lt;em&gt;enumerate&lt;/em&gt; all possible variants, which is where enumeration gets its name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b455b737e0cc051701700c07362ed0b4be96ade0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example of what happens when we try to use a refutable pattern where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a &lt;code&gt;let&lt;/code&gt; statement, but for the pattern we&amp;rsquo;ve specified &lt;code&gt;Some(x)&lt;/code&gt;, a refutable pattern. As you might expect, this code will not compile.</source>
          <target state="translated">让我们看一个示例，当我们尝试使用可重提模式时，Rust需要一个不可重提模式，反之亦然。清单18-8显示了一个 &lt;code&gt;let&lt;/code&gt; 语句，但是对于模式我们指定了 &lt;code&gt;Some(x)&lt;/code&gt; ，这是一个可重提的模式。如您所料，此代码将无法编译。</target>
        </trans-unit>
        <trans-unit id="18ece25ab1e94beac903ba47f460140cd6525deb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another enum in the standard library that is very common and useful: &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">让我们看一下标准库中另一个非常常见且有用的枚举： &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c5a86e48ba4d029ee5e559b44f91369e39297f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.</source>
          <target state="translated">让我们看一下清单6-2中的另一个枚举示例：该枚举的变量中嵌入了多种类型。</target>
        </trans-unit>
        <trans-unit id="eb252b4c369cd56d53d91f13fd045947d1bc97a2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example to see what it&amp;rsquo;s like when a &lt;code&gt;panic!&lt;/code&gt; call comes from a library because of a bug in our code instead of from our code calling the macro directly. Listing 9-1 has some code that attempts to access an element by index in a vector.</source>
          <target state="translated">让我们看另一个例子，看看发生 &lt;code&gt;panic!&lt;/code&gt; 时的感觉！调用来自库是因为我们的代码存在错误，而不是因为我们的代码直接调用了宏。清单9-1中的一些代码试图通过向量中的索引访问元素。</target>
        </trans-unit>
        <trans-unit id="6282a087fac47a7a9f015495370791f1a001baba" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example, this time using the &lt;code&gt;longest&lt;/code&gt; function that had no lifetime parameters when we started working with it in Listing 10-21:</source>
          <target state="translated">让我们来看另一个示例，这次使用清单10-21中开始使用的 &lt;code&gt;longest&lt;/code&gt; 函数，该函数没有生命周期参数：</target>
        </trans-unit>
        <trans-unit id="79d263a7d612b559cee379001fac98bd72d76b84" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example:</source>
          <target state="translated">让我们看另一个例子：</target>
        </trans-unit>
        <trans-unit id="4d45845f16951bf95eef2bf35703a5d1765d659f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at each of the five unsafe superpowers in turn. We&amp;rsquo;ll also look at some abstractions that provide a safe interface to unsafe code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8b25580ad4eac065cdf4b9269d34a342f40133" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at each of the four unsafe superpowers in turn. We&amp;rsquo;ll also look at some abstractions that provide a safe interface to unsafe code.</source>
          <target state="translated">让我们依次看一下四个不安全的超级大国。我们还将研究一些为不安全代码提供安全接口的抽象。</target>
        </trans-unit>
        <trans-unit id="df2bdcb8a48c5ab6b335860afc48b8bc078015c4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how a reference cycle might happen and how to prevent it, starting with the definition of the &lt;code&gt;List&lt;/code&gt; enum and a &lt;code&gt;tail&lt;/code&gt; method in Listing 15-25:</source>
          <target state="translated">让我们从清单15-25 中的 &lt;code&gt;List&lt;/code&gt; 枚举和 &lt;code&gt;tail&lt;/code&gt; 方法的定义开始，看一下参考循环如何发生以及如何防止它：</target>
        </trans-unit>
        <trans-unit id="0944037c3cfba2d633f74e95d90cd2030445a3ef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how the &lt;code&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt; values of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; instances change by creating a new inner scope and moving the creation of &lt;code&gt;branch&lt;/code&gt; into that scope. By doing so, we can see what happens when &lt;code&gt;branch&lt;/code&gt; is created and then dropped when it goes out of scope. The modifications are shown in Listing 15-29:</source>
          <target state="translated">让我们看看 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 实例的 &lt;code&gt;strong_count&lt;/code&gt; 和 &lt;code&gt;weak_count&lt;/code&gt; 值是如何变化的，方法是创建一个新的内部作用域并将 &lt;code&gt;branch&lt;/code&gt; 的创建移入该作用域。这样，我们可以看到创建 &lt;code&gt;branch&lt;/code&gt; 时发生了什么，然后在超出范围时删除了分支。修改如清单15-29所示：</target>
        </trans-unit>
        <trans-unit id="cefbc5ea6d98c6566c78f52ee80e603c9ecbe131" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how the lifetime annotations restrict the &lt;code&gt;longest&lt;/code&gt; function by passing in references that have different concrete lifetimes. Listing 10-23 is a straightforward example.</source>
          <target state="translated">让我们看一下生命周期注释如何通过传入具有不同具体生命周期的引用来限制 &lt;code&gt;longest&lt;/code&gt; 函数。清单10-23是一个简单的示例。</target>
        </trans-unit>
        <trans-unit id="2d907807641db37c8b548f8e680fff80ec47014d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how this works with an example that uses the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum:</source>
          <target state="translated">让我们看看使用标准库的 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 枚举的示例如何工作：</target>
        </trans-unit>
        <trans-unit id="017d18fbfa7c60f454e03eabc7d8ac1aa92c2937" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at the different kinds of procedural macros. We&amp;rsquo;ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.</source>
          <target state="translated">让我们看一下不同类型的过程宏。我们将从一个自定义的派生宏开始，然后解释使其他形式有所不同的微小差异。</target>
        </trans-unit>
        <trans-unit id="47696a65864265aca3d18b3b28f87964618b9312" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at the features Rust provides specifically for writing tests that take these actions, which include the &lt;code&gt;test&lt;/code&gt; attribute, a few macros, and the &lt;code&gt;should_panic&lt;/code&gt; attribute.</source>
          <target state="translated">让我们看一下Rust专门为编写执行这些操作的测试提供的功能，这些功能包括 &lt;code&gt;test&lt;/code&gt; 属性，一些宏和 &lt;code&gt;should_panic&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="3a9e9db94ec59c60082aa0b5bcf4f78e81ff1885" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at what happens if we use the &lt;code&gt;?&lt;/code&gt; operator in the &lt;code&gt;main&lt;/code&gt; function, which you&amp;rsquo;ll recall has a return type of &lt;code&gt;()&lt;/code&gt;:</source>
          <target state="translated">让我们看看如果使用 &lt;code&gt;?&lt;/code&gt; 会发生什么？ &lt;code&gt;main&lt;/code&gt; 函数中的运算符，您会记得它的返回类型为 &lt;code&gt;()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="994a941f48d3bb1b233dbddd0cea3be0ad22a0a6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make a new binary project with Cargo called &lt;em&gt;rectangles&lt;/em&gt; that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing 5-8 shows a short program with one way of doing exactly that in our project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">让我们用货运创建一个新的二进制项目，称为&lt;em&gt;矩形&lt;/em&gt;，它将采用以像素为单位指定的矩形的宽度和高度，并计算矩形的面积。清单5-8显示了一个简短的程序，该程序在我们的项目&lt;em&gt;src / main.rs中&lt;/em&gt;具有一种完全相同的方法。</target>
        </trans-unit>
        <trans-unit id="c3c6a3325302ea36dd5b079af7f9dcc2a96f2a1b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make the following changes to what happens when we create a &lt;code&gt;ThreadPool&lt;/code&gt;. We&amp;rsquo;ll implement the code that sends the closure to the thread after we have &lt;code&gt;Worker&lt;/code&gt; set up in this way:</source>
          <target state="translated">让我们对创建 &lt;code&gt;ThreadPool&lt;/code&gt; 时发生的情况进行以下更改。在以这种方式设置了 &lt;code&gt;Worker&lt;/code&gt; 之后，我们将实现将闭包发送到线程的代码：</target>
        </trans-unit>
        <trans-unit id="d6f3986ccdbd0c969d703b2cf489c2df505e5f38" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move all the code that isn&amp;rsquo;t the &lt;code&gt;main&lt;/code&gt; function from &lt;em&gt;src/main.rs&lt;/em&gt; to &lt;em&gt;src/lib.rs&lt;/em&gt;:</source>
          <target state="translated">让我们将不是 &lt;code&gt;main&lt;/code&gt; 功能的所有代码从&lt;em&gt;src / main.rs&lt;/em&gt;移到&lt;em&gt;src / lib.rs&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="e0993d86e241fd6659cd1a45b6773ecb8b7a697f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move on and talk about the module system!</source>
          <target state="translated">让我们继续讨论模块系统！</target>
        </trans-unit>
        <trans-unit id="a8ee98777403910d66295d417b2df29ea314fb29" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move the transmitting end into a spawned thread and have it send one string so the spawned thread is communicating with the main thread, as shown in Listing 16-7. This is like putting a rubber duck in the river upstream or sending a chat message from one thread to another.</source>
          <target state="translated">让我们将发送端移动到一个生成的线程中，并让它发送一个字符串，以便生成的线程与主线程通信，如清单16-7所示。这就像在上游河中放一只橡皮鸭，或从一个线程向另一个线程发送聊天消息。</target>
        </trans-unit>
        <trans-unit id="7d7bc5a1faae0876b47946a48ddda878ed24b40e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s practice using methods by implementing a second method on the &lt;code&gt;Rectangle&lt;/code&gt; struct. This time, we want an instance of &lt;code&gt;Rectangle&lt;/code&gt; to take another instance of &lt;code&gt;Rectangle&lt;/code&gt; and return &lt;code&gt;true&lt;/code&gt; if the second &lt;code&gt;Rectangle&lt;/code&gt; can fit completely within &lt;code&gt;self&lt;/code&gt;; otherwise it should return &lt;code&gt;false&lt;/code&gt;. That is, we want to be able to write the program shown in Listing 5-14, once we&amp;rsquo;ve defined the &lt;code&gt;can_hold&lt;/code&gt; method.</source>
          <target state="translated">让我们通过在 &lt;code&gt;Rectangle&lt;/code&gt; 结构上实现第二种方法来练习使用方法。这一次，我们要的实例 &lt;code&gt;Rectangle&lt;/code&gt; 采取的另一个实例， &lt;code&gt;Rectangle&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; 如果第二 &lt;code&gt;Rectangle&lt;/code&gt; 可以在完全贴合 &lt;code&gt;self&lt;/code&gt; ;否则应返回 &lt;code&gt;false&lt;/code&gt; 。也就是说，一旦定义了 &lt;code&gt;can_hold&lt;/code&gt; 方法，我们希望能够编写清单5-14中所示的程序。</target>
        </trans-unit>
        <trans-unit id="2f6a747ae7e60532bbff7c109c117027e46d5672" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s pretend we&amp;rsquo;re the compiler. We&amp;rsquo;ll apply these rules to figure out what the lifetimes of the references in the signature of the &lt;code&gt;first_word&lt;/code&gt; function in Listing 10-26 are. The signature starts without any lifetimes associated with the references:</source>
          <target state="translated">假设我们是编译器。我们将应用这些规则来找出清单10-26中 &lt;code&gt;first_word&lt;/code&gt; 函数签名中引用的生存期。签名开始时没有与引用相关联的任何生存期：</target>
        </trans-unit>
        <trans-unit id="93c702edd44f0391f6b49bca85a25bb1c08f5ed4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s program the game to quit when the user wins by adding a &lt;code&gt;break&lt;/code&gt; statement:</source>
          <target state="translated">让我们通过添加 &lt;code&gt;break&lt;/code&gt; 语句对游戏进行编程，使其在用户获胜时退出：</target>
        </trans-unit>
        <trans-unit id="37e690afeb6a44a19f29feff1bce10a2708fa622" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s re-implement the counter iterator from &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;:</source>
          <target state="translated">让我们从&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;重新实现计数器迭代器：</target>
        </trans-unit>
        <trans-unit id="12315912398a998ea0c31348f27e33b72d707ec2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what we&amp;rsquo;ve discussed about references:</source>
          <target state="translated">让我们回顾一下我们关于引用的讨论：</target>
        </trans-unit>
        <trans-unit id="28953519c0667e1646cf53e71f06f86d4e114c07" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what we&amp;rsquo;ve learned so far about Cargo:</source>
          <target state="translated">让我们来回顾一下到目前为止关于货运的知识：</target>
        </trans-unit>
        <trans-unit id="2c9a7290077df3cf275a9a0becb103de92fc4b1c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our cons list example in Listing 15-5. Recall that we defined it using &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. This time, we&amp;rsquo;ll create two lists that both share ownership of a third list. Conceptually, this looks similar to Figure 15-3:</source>
          <target state="translated">让我们回到清单15-5中的缺点列表示例。回想一下，我们使用 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 对其进行了定义。这次，我们将创建两个共享第三个列表所有权的列表。从概念上讲，这类似于图15-3：</target>
        </trans-unit>
        <trans-unit id="4d5406eb80899f442e99be52053a8af746acbb33" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our example: &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; have the same API, so we fix our program by changing the &lt;code&gt;use&lt;/code&gt; line, the call to &lt;code&gt;new&lt;/code&gt;, and the call to &lt;code&gt;clone&lt;/code&gt;. The code in Listing 16-15 will finally compile and run:</source>
          <target state="translated">让我们回到示例： &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 具有相同的API，因此我们通过更改 &lt;code&gt;use&lt;/code&gt; 行，对 &lt;code&gt;new&lt;/code&gt; 的调用以及对 &lt;code&gt;clone&lt;/code&gt; 的调用来修复程序。清单16-15中的代码将最终编译并运行：</target>
        </trans-unit>
        <trans-unit id="38b65fe4b5d3898a7fcecb397aa7533be4bdc414" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our workout generation app. In Listing 13-6, our code was still calling the expensive calculation closure more times than it needed to. One option to solve this issue is to save the result of the expensive closure in a variable for reuse and use the variable in each place we need the result, instead of calling the closure again. However, this method could result in a lot of repeated code.</source>
          <target state="translated">让我们回到我们的锻炼生成应用程序。在清单13-6中，我们的代码仍在多次调用昂贵的计算闭包，而不是需要多次。解决此问题的一种方法是将昂贵的闭包结果保存在变量中以供重用，并在需要结果的每个位置使用该变量，而不是再次调用闭包。但是，此方法可能导致大量重复代码。</target>
        </trans-unit>
        <trans-unit id="42c033ee17d1839060442674688298fa9208193f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the error in Listing 7-4 that told us the &lt;code&gt;hosting&lt;/code&gt; module is private. We want the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function in the parent module to have access to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in the child module, so we mark the &lt;code&gt;hosting&lt;/code&gt; module with the &lt;code&gt;pub&lt;/code&gt; keyword, as shown in Listing 7-5.</source>
          <target state="translated">让我们回到清单7-4中的错误，告诉我们 &lt;code&gt;hosting&lt;/code&gt; 模块是私有的。我们希望 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 父模块在功能上可以访问 &lt;code&gt;add_to_waitlist&lt;/code&gt; 子模块中的功能，所以我们纪念 &lt;code&gt;hosting&lt;/code&gt; 与模块 &lt;code&gt;pub&lt;/code&gt; 关键字，如清单7-5英寸</target>
        </trans-unit>
        <trans-unit id="f0f51e7669e18c0438bddca7e592dae1d7afb926" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the example in Listing 7-1. How do we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? This is the same as asking, what&amp;rsquo;s the path of the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? In Listing 7-3, we simplified our code a bit by removing some of the modules and functions. We&amp;rsquo;ll show two ways to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function from a new function &lt;code&gt;eat_at_restaurant&lt;/code&gt; defined in the crate root. The &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is part of our library crate&amp;rsquo;s public API, so we mark it with the &lt;code&gt;pub&lt;/code&gt; keyword. In the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;&amp;rdquo;Exposing Paths with the &lt;code&gt;pub&lt;/code&gt; Keyword&amp;rdquo;&lt;/a&gt; section, we&amp;rsquo;ll go into more detail about &lt;code&gt;pub&lt;/code&gt;.</source>
          <target state="translated">让我们回到清单7-1中的示例。我们如何调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数？这与询问相同， &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数的路径是什么？在清单7-3中，我们通过删除一些模块和函数来简化了代码。我们将展示两种从板条 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 定义的新函数eat_at_restaurant调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数的方法。该 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 功能是我们的图书馆箱子的公共API的一部分，所以我们用它标记 &lt;code&gt;pub&lt;/code&gt; 关键字。在&lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;&amp;ldquo;使用&lt;/a&gt; &lt;code&gt;pub&lt;/code&gt; 关键字公开路径&amp;rdquo;部分中，我们将详细介绍 &lt;code&gt;pub&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5708c518fe3a8a47dd6a9247e9757413e4ab26a1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the example in Listing 7-1. How do we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? This is the same as asking, what&amp;rsquo;s the path of the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? In Listing 7-3, we simplified our code a bit by removing some of the modules and functions. We&amp;rsquo;ll show two ways to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function from a new function &lt;code&gt;eat_at_restaurant&lt;/code&gt; defined in the crate root. The &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is part of our library crate&amp;rsquo;s public API, so we mark it with the &lt;code&gt;pub&lt;/code&gt; keyword. In the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;&amp;rdquo;Exposing Paths with the &lt;code&gt;pub&lt;/code&gt; Keyword&amp;rdquo;&lt;/a&gt; section, we&amp;rsquo;ll go into more detail about &lt;code&gt;pub&lt;/code&gt;. Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477b6d3273f07c6abd6b664ce37ceef78d0f7dbb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the guessing game program. You now know that &lt;code&gt;let mut guess&lt;/code&gt; will introduce a mutable variable named &lt;code&gt;guess&lt;/code&gt;. On the other side of the equal sign (&lt;code&gt;=&lt;/code&gt;) is the value that &lt;code&gt;guess&lt;/code&gt; is bound to, which is the result of calling &lt;code&gt;String::new&lt;/code&gt;, a function that returns a new instance of a &lt;code&gt;String&lt;/code&gt;. &lt;a href=&quot;../std/string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a string type provided by the standard library that is a growable, UTF-8 encoded bit of text.</source>
          <target state="translated">让我们回到猜谜游戏程序。您现在知道， &lt;code&gt;let mut guess&lt;/code&gt; 将引入一个可变的变量，名为 &lt;code&gt;guess&lt;/code&gt; 。等号（ &lt;code&gt;=&lt;/code&gt; ）的另一侧是 &lt;code&gt;guess&lt;/code&gt; 绑定的值，这是调用 &lt;code&gt;String::new&lt;/code&gt; 的结果，该函数返回 &lt;code&gt;String&lt;/code&gt; 的新实例。&lt;a href=&quot;../std/string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;是标准库提供的字符串类型，是可扩展的，UTF-8编码的文本位。</target>
        </trans-unit>
        <trans-unit id="1b391440eed0071039b3e089734bb6dbffc57331" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s review in detail what just happened in your &amp;ldquo;Hello, world!&amp;rdquo; program. Here&amp;rsquo;s the first piece of the puzzle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9b8de2d5b44130b83fee9c1ecdc0d98e51930d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s review in detail what just happened in your Hello, world! program. Here&amp;rsquo;s the first piece of the puzzle:</source>
          <target state="translated">让我们详细回顾一下您好世界中发生的一切！程序。这是难题的第一部分：</target>
        </trans-unit>
        <trans-unit id="158e58c1e56ad7bd97dd01d2a60cf00e419cdf7a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the program again with arguments that don&amp;rsquo;t cause an error but still redirect standard output to a file, like so:</source>
          <target state="translated">让我们使用不会引起错误但仍将标准输出重定向到文件的参数再次运行程序，如下所示：</target>
        </trans-unit>
        <trans-unit id="c402a40660ac8a0f30bee1587ae0160a6f7fa3c1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the program now!</source>
          <target state="translated">让我们现在运行程序！</target>
        </trans-unit>
        <trans-unit id="a23620a8daca09feb45d362acea31eb531fda8ce" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run this code with any string as the first command line argument (because we haven&amp;rsquo;t implemented the searching part yet) and the &lt;em&gt;poem.txt&lt;/em&gt; file as the second argument:</source>
          <target state="translated">让我们以任何字符串作为第一个命令行参数（因为我们尚未实现搜索部分）并将&lt;em&gt;poem.txt&lt;/em&gt;文件作为第二个参数运行此代码：</target>
        </trans-unit>
        <trans-unit id="a00a1c9672a401c35b2df73be4edbb0185a8d666" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say a regression is found. Good thing we had some time to test the beta release before the regression snuck into a stable release! The fix is applied to &lt;code&gt;master&lt;/code&gt;, so that nightly is fixed, and then the fix is backported to the &lt;code&gt;beta&lt;/code&gt; branch, and a new release of beta is produced:</source>
          <target state="translated">假设发现了回归。好东西，我们有一些时间测试Beta版本，然后回归到稳定版本！该修复程序适用于 &lt;code&gt;master&lt;/code&gt; ，因此每晚修复一次，然后将该修复程序反向移植到 &lt;code&gt;beta&lt;/code&gt; 分支，并产生一个新的beta版本：</target>
        </trans-unit>
        <trans-unit id="9f9ce6103baa4662da2c83f8f5cc76efdcd0525f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we want to write a function that takes an &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; and, if there&amp;rsquo;s a value inside, adds 1 to that value. If there isn&amp;rsquo;t a value inside, the function should return the &lt;code&gt;None&lt;/code&gt; value and not attempt to perform any operations.</source>
          <target state="translated">假设我们要编写一个使用 &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; 的函数，并且如果其中包含一个值，则将该值加1。如果内部没有值，则该函数应返回 &lt;code&gt;None&lt;/code&gt; 值，并且不要尝试执行任何操作。</target>
        </trans-unit>
        <trans-unit id="2d4331831e839f96e4320b04d84f9d160c78c289" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a variable of type &lt;code&gt;u8&lt;/code&gt; that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, &lt;em&gt;integer overflow&lt;/em&gt; will occur. Rust has some interesting rules involving this behavior. When you&amp;rsquo;re compiling in debug mode, Rust includes checks for integer overflow that cause your program to &lt;em&gt;panic&lt;/em&gt; at runtime if this behavior occurs. Rust uses the term panicking when a program exits with an error; we&amp;rsquo;ll discuss panics in more depth in the &lt;a href=&quot;ch09-01-unrecoverable-errors-with-panic&quot;&gt;&amp;ldquo;Unrecoverable Errors with &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section in Chapter 9.</source>
          <target state="translated">假设您有一个 &lt;code&gt;u8&lt;/code&gt; 类型的变量，可以容纳0到255之间的值。如果尝试将变量更改为该范围之外的值（例如256），则会发生&lt;em&gt;整数溢出&lt;/em&gt;。Rust有一些有趣的规则涉及此行为。在调试模式下进行编译时，Rust包括整数溢出检查，如果发生此行为，整数溢出会使程序在运行时&lt;em&gt;惊慌&lt;/em&gt;。当程序错误退出时，Rust使用惊慌一词。我们将在&lt;a href=&quot;ch09-01-unrecoverable-errors-with-panic&quot;&gt;&amp;ldquo;无法恢复的错误&amp;rdquo; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;中更深入地讨论紧急情况！&amp;rdquo;在第9章中。</target>
        </trans-unit>
        <trans-unit id="f0e1d796103ec14a5789c6d54a9113a4a736b9aa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see if this implementation passes the tests:</source>
          <target state="translated">让我们看看该实现是否通过测试：</target>
        </trans-unit>
        <trans-unit id="e75f56bc99e0b08a29707c986c241848f766cec0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see what happens when we try to implement &lt;code&gt;OutlinePrint&lt;/code&gt; on a type that doesn&amp;rsquo;t implement &lt;code&gt;Display&lt;/code&gt;, such as the &lt;code&gt;Point&lt;/code&gt; struct:</source>
          <target state="translated">让我们看看当尝试在没有实现 &lt;code&gt;Display&lt;/code&gt; 的类型上实现 &lt;code&gt;OutlinePrint&lt;/code&gt; 时会发生什么，例如 &lt;code&gt;Point&lt;/code&gt; struct：</target>
        </trans-unit>
        <trans-unit id="c59bb772f42d6153c276f779685fbcbc51239a51" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new binary project named &lt;em&gt;functions&lt;/em&gt; to explore functions further. Place the &lt;code&gt;another_function&lt;/code&gt; example in &lt;em&gt;src/main.rs&lt;/em&gt; and run it. You should see the following output:</source>
          <target state="translated">让我们开始一个新的名为&lt;em&gt;函数的&lt;/em&gt;二进制项目，以进一步探索函数。将 &lt;code&gt;another_function&lt;/code&gt; 示例放置在&lt;em&gt;src / main.rs中&lt;/em&gt;并运行它。您应该看到以下输出：</target>
        </trans-unit>
        <trans-unit id="97cf07881b2328430539d964be0df2b91b35c6ed" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a channel in &lt;code&gt;ThreadPool::new&lt;/code&gt; and holding the sending side in the &lt;code&gt;ThreadPool&lt;/code&gt; instance, as shown in Listing 20-16. The &lt;code&gt;Job&lt;/code&gt; struct doesn&amp;rsquo;t hold anything for now but will be the type of item we&amp;rsquo;re sending down the channel.</source>
          <target state="translated">首先，在 &lt;code&gt;ThreadPool::new&lt;/code&gt; 创建一个通道，并将发送方保留在 &lt;code&gt;ThreadPool&lt;/code&gt; 实例中，如清单20-16所示。该 &lt;code&gt;Job&lt;/code&gt; 结构不适合现在持有什么，但将是我们发送下降通道项目的类型。</target>
        </trans-unit>
        <trans-unit id="bf13023ab8a50a9cde566fb86f6034b24ede9e80" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with implementing &lt;code&gt;Drop&lt;/code&gt; on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 20-22 shows a first attempt at a &lt;code&gt;Drop&lt;/code&gt; implementation; this code won&amp;rsquo;t quite work yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590a1a269af356fe7eb20ade960ec2172988f407" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with implementing &lt;code&gt;Drop&lt;/code&gt; on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 20-23 shows a first attempt at a &lt;code&gt;Drop&lt;/code&gt; implementation; this code won&amp;rsquo;t quite work yet.</source>
          <target state="translated">让我们从在线程池上实现 &lt;code&gt;Drop&lt;/code&gt; 开始。删除池后，所有线程都应加入以确保它们完成工作。清单20-23显示了首次实现 &lt;code&gt;Drop&lt;/code&gt; 的尝试；该代码还无法正常工作。</target>
        </trans-unit>
        <trans-unit id="17bad3ae86bcd63a6cce044cc99494cc4fff84d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start your Rust journey! There&amp;rsquo;s a lot to learn, but every journey starts somewhere. In this chapter, we&amp;rsquo;ll discuss:</source>
          <target state="translated">让我们开始您的Rust之旅！有很多东西要学习，但是每一次旅程都是从某个地方开始的。在本章中，我们将讨论：</target>
        </trans-unit>
        <trans-unit id="0457bf0b3ac99ac66b1f341140a99488a66fb382" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s switch to something a bit less complex: hash maps!</source>
          <target state="translated">让我们切换到稍微复杂一些的东西：哈希映射！</target>
        </trans-unit>
        <trans-unit id="27749ea9200d1a0f4c7054bf492ec3c0b20e784f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at exactly what&amp;rsquo;s happening at each stage of our &lt;code&gt;dangle&lt;/code&gt; code:</source>
          <target state="translated">让我们仔细研究一下 &lt;code&gt;dangle&lt;/code&gt; 代码的每个阶段到底发生了什么：</target>
        </trans-unit>
        <trans-unit id="7d9a8307e36aca49fe8db4d93f11fe8c7cef9311" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at the function call here:</source>
          <target state="translated">让我们在这里仔细看一下函数调用：</target>
        </trans-unit>
        <trans-unit id="9a0c63ba49eeceb9940e6cb267159151436db7f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take advantage of this newfound modularity by doing something that would have been difficult with the old code but is easy with the new code: we&amp;rsquo;ll write some tests!</source>
          <target state="translated">让我们利用这种新发现的模块性，通过做一些旧代码很难实现但新代码容易实现的事情：我们将编写一些测试！</target>
        </trans-unit>
        <trans-unit id="1e8a01207efa7ffcc3d9fbd6fc8377d0a2bd28de" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the idea of using Rust&amp;rsquo;s type system to ensure we have a valid value one step further and look at creating a custom type for validation. Recall the guessing game in Chapter 2 in which our code asked the user to guess a number between 1 and 100. We never validated that the user&amp;rsquo;s guess was between those numbers before checking it against our secret number; we only validated that the guess was positive. In this case, the consequences were not very dire: our output of &amp;ldquo;Too high&amp;rdquo; or &amp;ldquo;Too low&amp;rdquo; would still be correct. But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when a user guesses a number that&amp;rsquo;s out of range versus when a user types, for example, letters instead.</source>
          <target state="translated">让我们采用使用Rust的类型系统的想法，以确保我们一步一步获得有效值，并着眼于创建用于验证的自定义类型。回想一下第二章中的猜谜游戏，其中我们的代码要求用户猜一个介于1到100之间的数字。我们只验证了猜测是肯定的。在这种情况下，后果不是很严重：我们的&amp;ldquo;太高&amp;rdquo;或&amp;ldquo;太低&amp;rdquo;输出仍然正确。但是，这将是一种有用的增强功能，可以指导用户进行有效的猜测，并在用户猜测超出范围的数字与用户键入例如字母的数字时具有不同的行为。</target>
        </trans-unit>
        <trans-unit id="10bbc468cc51314953c3274a9c50cb0da6662c26" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s test the first part of the guessing game. Run it using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">让我们测试猜谜游戏的第一部分。使用 &lt;code&gt;cargo run&lt;/code&gt; 运行它：</target>
        </trans-unit>
        <trans-unit id="5f2f9297e2dc6cf0f3bff432893229470763f14d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s think about the signature of this function:</source>
          <target state="translated">让我们考虑一下此函数的签名：</target>
        </trans-unit>
        <trans-unit id="0e370a4cd7c7ee7160c1da9e21eeb3426aa051c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try adding the &lt;code&gt;main&lt;/code&gt; function in Listing 15-7 to Listing 15-8 and changing it to use the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;ve defined instead of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. The code in Listing 15-9 won&amp;rsquo;t compile because Rust doesn&amp;rsquo;t know how to dereference &lt;code&gt;MyBox&lt;/code&gt;.</source>
          <target state="translated">让我们尝试将清单15-7中的 &lt;code&gt;main&lt;/code&gt; 函数添加到清单15-8中，并将其更改为使用我们定义的 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 类型而不是 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 。清单15-9中的代码将无法编译，因为Rust不知道如何取消引用 &lt;code&gt;MyBox&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6856c71f770128395912c9e4d84ed22f9c2d61c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try calling &lt;code&gt;panic!&lt;/code&gt; in a simple program:</source>
          <target state="translated">让我们尝试 &lt;code&gt;panic!&lt;/code&gt; 在一个简单的程序中：</target>
        </trans-unit>
        <trans-unit id="495c15a2fcdcf4917d9c1bfab9452d52f6946a12" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try changing the value of &lt;code&gt;number&lt;/code&gt; to a value that makes the condition &lt;code&gt;false&lt;/code&gt; to see what happens:</source>
          <target state="translated">让我们尝试将 &lt;code&gt;number&lt;/code&gt; 的值更改为使条件为 &lt;code&gt;false&lt;/code&gt; 的值，以了解发生了什么：</target>
        </trans-unit>
        <trans-unit id="7e7646ea7f3a1ac4db23658ee4f242a38dc0f2d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try it! The &lt;code&gt;println!&lt;/code&gt; macro call will now look like &lt;code&gt;println!(&quot;rect1 is {:?}&quot;, rect1);&lt;/code&gt;. Putting the specifier &lt;code&gt;:?&lt;/code&gt; inside the curly brackets tells &lt;code&gt;println!&lt;/code&gt; we want to use an output format called &lt;code&gt;Debug&lt;/code&gt;. The &lt;code&gt;Debug&lt;/code&gt; trait enables us to print our struct in a way that is useful for developers so we can see its value while we&amp;rsquo;re debugging our code.</source>
          <target state="translated">试试吧！该 &lt;code&gt;println!&lt;/code&gt; 宏调用现在看起来像 &lt;code&gt;println!(&quot;rect1 is {:?}&quot;, rect1);&lt;/code&gt; 。把说明符 &lt;code&gt;:?&lt;/code&gt; 大括号内的内容告诉 &lt;code&gt;println!&lt;/code&gt; 我们要使用一种称为 &lt;code&gt;Debug&lt;/code&gt; 的输出格式。在 &lt;code&gt;Debug&lt;/code&gt; 特质使我们能够打印我们的结构的方式，对开发人员有用的，所以我们可以看到它的价值的同时，我们正在调试我们的代码。</target>
        </trans-unit>
        <trans-unit id="bd95d7f3d11c94bb095fdce37f40a8188a0a9f0c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try passing a receiving end of the channel into each worker as the thread pool creates the channel. We know we want to use the receiving end in the thread that the workers spawn, so we&amp;rsquo;ll reference the &lt;code&gt;receiver&lt;/code&gt; parameter in the closure. The code in Listing 20-17 won&amp;rsquo;t quite compile yet.</source>
          <target state="translated">让我们尝试在线程池创建通道时将通道的接收端传递给每个工作程序。我们知道我们想在工作者产生的线程中使用接收端，因此我们将在闭包中引用 &lt;code&gt;receiver&lt;/code&gt; 参数。清单20-17中的代码尚未完全编译。</target>
        </trans-unit>
        <trans-unit id="1369c278ca19b1e056ddf12681c203bea51b902a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try running this code! Invoke &lt;code&gt;cargo run&lt;/code&gt; in the terminal and then load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser. The browser should show an error message like &amp;ldquo;Connection reset,&amp;rdquo; because the server isn&amp;rsquo;t currently sending back any data. But when you look at your terminal, you should see several messages that were printed when the browser connected to the server!</source>
          <target state="translated">让我们尝试运行此代码！调用在终端中 &lt;code&gt;cargo run&lt;/code&gt; 的货物，然后在Web浏览器中加载&lt;em&gt;127.0.0.1:7878&lt;/em&gt;。浏览器应显示一条错误消息，如&amp;ldquo;连接重置&amp;rdquo;，因为服务器当前未发回任何数据。但是，当您查看终端时，应该会看到浏览器连接到服务器时打印的几条消息！</target>
        </trans-unit>
        <trans-unit id="b5df448e7bbf55b42cbf4762a517bb598ff93363" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try running this code. Replace the program currently in your &lt;em&gt;functions&lt;/em&gt; project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt; file with the preceding example and run it using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">让我们尝试运行此代码。用前面的示例替换当前在&lt;em&gt;功能&lt;/em&gt;项目的&lt;em&gt;src / main.rs&lt;/em&gt;文件中的程序，然后使用 &lt;code&gt;cargo run&lt;/code&gt; 运行它：</target>
        </trans-unit>
        <trans-unit id="41e20d578122ffb945b15f0ad510b73ca09a5d3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try this code! Start the program and make a request in a web browser again. Note that we&amp;rsquo;ll still get an error page in the browser, but our program&amp;rsquo;s output in the terminal will now look similar to this:</source>
          <target state="translated">让我们试试这个代码！启动该程序，然后再次在Web浏览器中发出请求。请注意，我们仍然会在浏览器中显示一个错误页面，但是终端中程序的输出现在看起来类似于以下内容：</target>
        </trans-unit>
        <trans-unit id="7cc97ca0df32f4fb1eb75d95da6a337fcd334535" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to compile Listing 7-3 and find out why it won&amp;rsquo;t compile yet! The error we get is shown in Listing 7-4.</source>
          <target state="translated">让我们尝试编译清单7-3，找出为什么它还不能编译！清单7-4显示了我们得到的错误。</target>
        </trans-unit>
        <trans-unit id="11ff9da674c818134a4406c35f39622fa04e8cbd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to create a dangling reference, which Rust will prevent with a compile-time error:</source>
          <target state="translated">让我们尝试创建一个悬空的引用，Rust将通过编译时错误防止它：</target>
        </trans-unit>
        <trans-unit id="ad30420ec21f7046e9cdcc78a94ec41a99a4cd28" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through an example of what would happen with the &lt;code&gt;match&lt;/code&gt; expression used here. Say that the user has guessed 50 and the randomly generated secret number this time is 38. When the code compares 50 to 38, the &lt;code&gt;cmp&lt;/code&gt; method will return &lt;code&gt;Ordering::Greater&lt;/code&gt;, because 50 is greater than 38. The &lt;code&gt;match&lt;/code&gt; expression gets the &lt;code&gt;Ordering::Greater&lt;/code&gt; value and starts checking each arm&amp;rsquo;s pattern. It looks at the first arm&amp;rsquo;s pattern, &lt;code&gt;Ordering::Less&lt;/code&gt;, and sees that the value &lt;code&gt;Ordering::Greater&lt;/code&gt; does not match &lt;code&gt;Ordering::Less&lt;/code&gt;, so it ignores the code in that arm and moves to the next arm. The next arm&amp;rsquo;s pattern, &lt;code&gt;Ordering::Greater&lt;/code&gt;, &lt;em&gt;does&lt;/em&gt; match &lt;code&gt;Ordering::Greater&lt;/code&gt;! The associated code in that arm will execute and print &lt;code&gt;Too big!&lt;/code&gt; to the screen. The &lt;code&gt;match&lt;/code&gt; expression ends because it has no need to look at the last arm in this scenario.</source>
          <target state="translated">让我们来看一个使用此处的 &lt;code&gt;match&lt;/code&gt; 表达式会发生什么的示例。说，用户已经猜到50和随机产生的秘密号码此时为38。当码进行比较50至38中， &lt;code&gt;cmp&lt;/code&gt; 方法将返回 &lt;code&gt;Ordering::Greater&lt;/code&gt; ，因为50大于38. &lt;code&gt;match&lt;/code&gt; 表达式获得的 &lt;code&gt;Ordering::Greater&lt;/code&gt; 价值，并开始检查每个手臂的图案。它查看了第一个分支的模式 &lt;code&gt;Ordering::Less&lt;/code&gt; ，并发现 &lt;code&gt;Ordering::Greater&lt;/code&gt; 值与 &lt;code&gt;Ordering::Less&lt;/code&gt; 不匹配，因此它将忽略该分支中的代码并移至下一个分支。下一个手臂的样式， &lt;code&gt;Ordering::Greater&lt;/code&gt; ，&lt;em&gt;不&lt;/em&gt;匹配 &lt;code&gt;Ordering::Greater&lt;/code&gt; ！该分支中的关联代码将执行并打印得 &lt;code&gt;Too big!&lt;/code&gt; 到屏幕。在 &lt;code&gt;match&lt;/code&gt; 表达目的，因为它没有必要看在这种情况下，最后手臂。</target>
        </trans-unit>
        <trans-unit id="7603084911e7c02de0fffb01fc0d07271e8ab207" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through what happens when the &lt;code&gt;match&lt;/code&gt; expression runs. The pattern in the first match arm doesn&amp;rsquo;t match the defined value of &lt;code&gt;x&lt;/code&gt;, so the code continues.</source>
          <target state="translated">让我们看一下运行 &lt;code&gt;match&lt;/code&gt; 表达式时发生的情况。第一个匹配臂中的模式与 &lt;code&gt;x&lt;/code&gt; 的定义值不匹配，因此代码继续。</target>
        </trans-unit>
        <trans-unit id="9dbd7c7d9a346617c48d1fe6e1ab8464dd12c2ee" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through what happens when we create a package. First, we enter the command &lt;code&gt;cargo new&lt;/code&gt;:</source>
          <target state="translated">让我们逐一介绍创建包时发生的情况。首先，我们输入command &lt;code&gt;cargo new&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="85979a5d9f34f3050620ce86eda10daa14a1b88f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work on an example of a situation in which it&amp;rsquo;s useful to store a closure to be executed later. Along the way, we&amp;rsquo;ll talk about the syntax of closures, type inference, and traits.</source>
          <target state="translated">让我们来研究一个情况的示例，在这种情况下，存储闭包以便以后执行非常有用。在此过程中，我们将讨论闭包的语法，类型推断和特征。</target>
        </trans-unit>
        <trans-unit id="dde68cf723b263931fff6274e2649443a376d09e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work through a practical example where we can use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; to mutate an immutable value and see why that is useful.</source>
          <target state="translated">让我们来看一个实际的示例，在该示例中，我们可以使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 来更改不可变值，并查看为什么这样做很有用。</target>
        </trans-unit>
        <trans-unit id="48386f6d1144155006a32871e15dfe1b9ce157fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work through each step, starting with iterating through lines.</source>
          <target state="translated">让我们完成每个步骤，从遍历行开始。</target>
        </trans-unit>
        <trans-unit id="a1a52fb721ec0d05f400a261580d4ddb22293c65" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a function that returns the longer of two string slices. This function will take two string slices and return a string slice. After we&amp;rsquo;ve implemented the &lt;code&gt;longest&lt;/code&gt; function, the code in Listing 10-20 should print &lt;code&gt;The longest string is abcd&lt;/code&gt;.</source>
          <target state="translated">让我们编写一个返回两个字符串片段中较长者的函数。此函数将获取两个字符串切片并返回一个字符串切片。在实现了 &lt;code&gt;longest&lt;/code&gt; 函数之后，清单10-20中的代码应该 &lt;code&gt;The longest string is abcd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31701d3a630b4f1aa08c2b129407ae716eb89b88" translate="yes" xml:space="preserve">
          <source>Let's cover each of those in turn:</source>
          <target state="translated">我们依次介绍一下这些内容。</target>
        </trans-unit>
        <trans-unit id="4c315b125c5927660bb768b8b3fda2b0a5ee7326" translate="yes" xml:space="preserve">
          <source>Let's make an iterator named &lt;code&gt;Counter&lt;/code&gt; which counts from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;:</source>
          <target state="translated">让我们创建一个名为 &lt;code&gt;Counter&lt;/code&gt; 的迭代器，它的计数范围是 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;5&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6c6a4583ed007c9bb1513143277357a280135d4c" translate="yes" xml:space="preserve">
          <source>Let's start with some erroneous code examples:</source>
          <target state="translated">我们先来看看一些错误的代码例子。</target>
        </trans-unit>
        <trans-unit id="de018a296a31a1ffdcd9d1c61756c91e2595cea1" translate="yes" xml:space="preserve">
          <source>Let's walk through each step of the iteration here:</source>
          <target state="translated">在这里,我们来走一遍迭代的每一步。</target>
        </trans-unit>
        <trans-unit id="44815d1f0973ea841fa50391ff27766e7a1e43e1" translate="yes" xml:space="preserve">
          <source>Let's write the numbers one through ten to a &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">让我们将数字1到10写入&lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a46a79428acd36421f88fb475bcbddfbea0e22e5" translate="yes" xml:space="preserve">
          <source>Lexical structure</source>
          <target state="translated">词汇结构</target>
        </trans-unit>
        <trans-unit id="97ced95f3282c2304ccbd2d1176522c359d54ea9" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cca5450332e424d128448475a6775439ff31f6" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0dc7378d16e255ed01aabc2a54a07e3e6629f4" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d55096d24feded547137c63c7a384f3c4c0f255" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bddaf8f2edd0c91cf260c1ac14934d6aa825ae88" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a76c78472395e823b945082e38bc5d303e55719" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d126c71de93d47651f31c95e0aa450c4800fd88" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609c60c9d5603d69bbf35fffd3566a6af30afb36" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c25090a4ef088c71ace7e293566a76c0bb25be" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668bd83da9d322ea78d016864c5ab95e76011dec" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bff3a67247c3882318b7f41ce97184a0411570f" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5c8cdaa83d4509b191af2c71b1b48c60f72b24" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf6b114d1123581ae2c9e4273fca508b0fdbde3" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4ebf62364837d04d562c736d452c744c46f6e4" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3953e041c330441a75e1dfa61d597df8c7d470e" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2ad7e98b8195217ed6030e622bceaccf34c46b" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513ec20a4e8698e9bbbff2e3985a29e06196f05c" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e31f29d209ae250a7a227132954b7d8fe04deb" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3f1a9e4282d09a166c49d84325b88085f57ffa" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f489f2a5cd07e538c7596d152dd9c17e3db469d7" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c8e7753b0c8e6c7481529dc1eff5f203de8fd0" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c64287527264c710512a6ae1c3417e504fcde8" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22f0e1553138efb51680148ef1747ad26c97982" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another.</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。</target>
        </trans-unit>
        <trans-unit id="d38859ceb7b6303a207032995bde9d03c3feea29" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca4735197429808d0efeb2b253fe9bcfce18fe50" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da9611fc3a83516ea2471a2bc5512aa400680e0d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="baa7a6a1172224029d4ace92b0dcc42af5ea43dc" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df2d601aaa116406a1d3ed2d19ce7ccb8eda9f6d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e11c383f8dbc8d0d02a7e4c42f755738eaa3bd8b" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5193c64367cbcdbfcac47602ae539c77c733dbd" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50753dbaf3a4231173ff7ea3444ae3faef6bec15" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a26e03f1b58a87f3e69a164fb32f2308387a9a0d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77268650d6474077dd95b0c1034d89e6138d9c8a" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Lexicographically将此 &lt;code&gt;Iterator&lt;/code&gt; 的元素与另一个Iterator的元素进行比较。&lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7cdfc7b1ef1b25862c1df7bf310283ec505f2f9e" translate="yes" xml:space="preserve">
          <source>Library authors should usually not directly implement this trait, but should prefer implementing the &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; trait, which offers greater flexibility and provides an equivalent &lt;code&gt;TryInto&lt;/code&gt; implementation for free, thanks to a blanket implementation in the standard library. For more information on this, see the documentation for &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">库作者通常不应该直接实现此特征，而应该更喜欢实现&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;特征，该特征提供了更大的灵活性，并免费提供了等效的 &lt;code&gt;TryInto&lt;/code&gt; 实现，这要归功于标准库中的全面实现。有关此的更多信息，请参见&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="4758ec4228804e6ab30fe33d5019e3936dc6e0ac" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.</source>
          <target state="translated">根据Apache许可证,2.0版或MIT许可证授权,由您选择。</target>
        </trans-unit>
        <trans-unit id="5ef0008f25a377dd2d246f55bb6f44f04dd3b9a3" translate="yes" xml:space="preserve">
          <source>Lifetime Annotation Syntax</source>
          <target state="translated">终身注解语法</target>
        </trans-unit>
        <trans-unit id="d684ab1615c80d05a111e3a5d43f3dd40b1f7fc7" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Function Signatures</source>
          <target state="translated">功能签名中的终生注解</target>
        </trans-unit>
        <trans-unit id="ff9298a957239ce20a277b248758f21de5df0edf" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Method Definitions</source>
          <target state="translated">方法定义中的终生注解</target>
        </trans-unit>
        <trans-unit id="bf7eeb5a85880b38a5e28e77bcee94cc13003db0" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Struct Definitions</source>
          <target state="translated">结构定义中的终身注解</target>
        </trans-unit>
        <trans-unit id="674c9a2bca3da0091dd89b55224da7caea179e1f" translate="yes" xml:space="preserve">
          <source>Lifetime Elision</source>
          <target state="translated">终身 Elision</target>
        </trans-unit>
        <trans-unit id="717ff13cd888c9b3f73863d8fc6f55fb70c424ad" translate="yes" xml:space="preserve">
          <source>Lifetime annotations don&amp;rsquo;t change how long any of the references live. Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter. Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.</source>
          <target state="translated">终身注释不会更改任何引用的生存时间。正如签名可以指定泛型类型参数时函数可以接受任何类型一样，通过指定泛型生存期参数，函数可以接受具有任何生存期的引用。生命周期批注描述了多个引用的生命周期彼此之间的关系，而不会影响生命周期。</target>
        </trans-unit>
        <trans-unit id="afdff3576da5c17c6d56a74897ff356724bed98a" translate="yes" xml:space="preserve">
          <source>Lifetime annotations have a slightly unusual syntax: the names of lifetime parameters must start with an apostrophe (&lt;code&gt;'&lt;/code&gt;) and are usually all lowercase and very short, like generic types. Most people use the name &lt;code&gt;'a&lt;/code&gt;. We place lifetime parameter annotations after the &lt;code&gt;&amp;amp;&lt;/code&gt; of a reference, using a space to separate the annotation from the reference&amp;rsquo;s type.</source>
          <target state="translated">生命周期注释的语法略有不同：生命周期参数的名称必须以撇号（ &lt;code&gt;'&lt;/code&gt; ）开头，并且通常都是小写且非常短，就像泛型类型一样。大多数人使用名称 &lt;code&gt;'a&lt;/code&gt; 。我们将生命周期参数注释放置在引用的 &lt;code&gt;&amp;amp;&lt;/code&gt; 后面，并使用空格将注释与引用的类型分开。</target>
        </trans-unit>
        <trans-unit id="1135a93608f0c4c9693be849ed8d4d3c3627b3b8" translate="yes" xml:space="preserve">
          <source>Lifetime bounds</source>
          <target state="translated">终身界限</target>
        </trans-unit>
        <trans-unit id="251f40e2a7cdcbd4967d480a9d96d101163e7557" translate="yes" xml:space="preserve">
          <source>Lifetime bounds can be applied to types or other lifetimes. The bound &lt;code&gt;'a: 'b&lt;/code&gt; is usually read as &lt;code&gt;'a&lt;/code&gt;&lt;em&gt;outlives&lt;/em&gt;&lt;code&gt;'b&lt;/code&gt;. &lt;code&gt;'a: 'b&lt;/code&gt; means that &lt;code&gt;'a&lt;/code&gt; lasts longer than &lt;code&gt;'b&lt;/code&gt;, so a reference &lt;code&gt;&amp;amp;'a ()&lt;/code&gt; is valid whenever &lt;code&gt;&amp;amp;'b ()&lt;/code&gt; is valid.</source>
          <target state="translated">生命周期范围可以应用于类型或其他生命周期。结合的 &lt;code&gt;'a: 'b&lt;/code&gt; 通常读作 &lt;code&gt;'a&lt;/code&gt; &lt;em&gt;会超越&lt;/em&gt; &lt;code&gt;'b&lt;/code&gt; 。 &lt;code&gt;'a: 'b&lt;/code&gt; 表示 &lt;code&gt;'a&lt;/code&gt; 的持续时间长于 &lt;code&gt;'b&lt;/code&gt; ，因此只要 &lt;code&gt;&amp;amp;'b ()&lt;/code&gt; 有效，则引用 &lt;code&gt;&amp;amp;'a ()&lt;/code&gt; 有效。</target>
        </trans-unit>
        <trans-unit id="4dbeb69ffc17e7e2b0614af0534a87d095aeab01" translate="yes" xml:space="preserve">
          <source>Lifetime elision</source>
          <target state="translated">终身磨损</target>
        </trans-unit>
        <trans-unit id="4ed17519ce5dbd6c80c5942b9e801bd65600d677" translate="yes" xml:space="preserve">
          <source>Lifetime elision in functions</source>
          <target state="translated">函数中的终生淘汰</target>
        </trans-unit>
        <trans-unit id="cdf660f0b0e8334138261c27b1ecaed43d9845fb" translate="yes" xml:space="preserve">
          <source>Lifetime elision is a special, limited kind of inference for lifetimes in function signatures which allows you to leave out lifetimes in certain cases. For more background on lifetime elision see &lt;a href=&quot;book/ch10-03-lifetime-syntax#lifetime-elision&quot;&gt;the book&lt;/a&gt;.</source>
          <target state="translated">生存期省略是对函数签名中生存期的一种特殊的，有限的推断，它允许您在某些情况下忽略生存期。有关终生淘汰的更多背景信息，请参见&lt;a href=&quot;book/ch10-03-lifetime-syntax#lifetime-elision&quot;&gt;这本书&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c1728f6f98aaf9465cf90c15cd1b748f66e76ad" translate="yes" xml:space="preserve">
          <source>Lifetime names for struct fields always need to be declared after the &lt;code&gt;impl&lt;/code&gt; keyword and then used after the struct&amp;rsquo;s name, because those lifetimes are part of the struct&amp;rsquo;s type.</source>
          <target state="translated">始终需要在 &lt;code&gt;impl&lt;/code&gt; 关键字之后声明结构字段的生命周期名称，然后在结构名称之后使用，因为这些生命周期是结构类型的一部分。</target>
        </trans-unit>
        <trans-unit id="a900c570930642dfc60a61e8d7bac83d7d6ce835" translate="yes" xml:space="preserve">
          <source>Lifetime parameters and &lt;a href=&quot;expressions/loop-expr&quot;&gt;loop labels&lt;/a&gt; use LIFETIME_OR_LABEL tokens. Any LIFETIME_TOKEN will be accepted by the lexer, and for example, can be used in macros.</source>
          <target state="translated">生命周期参数和&lt;a href=&quot;expressions/loop-expr&quot;&gt;循环标签&lt;/a&gt;使用LIFETIME_OR_LABEL令牌。语法分析器将接受任何LIFETIME_TOKEN，例如，可以在宏中使用。</target>
        </trans-unit>
        <trans-unit id="4ff5a6b571244bea88cc86b164846e047b3ec7b5" translate="yes" xml:space="preserve">
          <source>Lifetime parameters or &lt;a href=&quot;expressions/loop-expr#loop-labels&quot;&gt;loop labels&lt;/a&gt;</source>
          <target state="translated">生命周期参数或&lt;a href=&quot;expressions/loop-expr#loop-labels&quot;&gt;循环标签&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec6b2b953ecf8f329d7e04b783de42bfc3652a53" translate="yes" xml:space="preserve">
          <source>Lifetimes</source>
          <target state="translated">Lifetimes</target>
        </trans-unit>
        <trans-unit id="6e3d4513c00b42e75eeb4d12543903cf3991d567" translate="yes" xml:space="preserve">
          <source>Lifetimes and loop labels</source>
          <target state="translated">寿命和循环标签</target>
        </trans-unit>
        <trans-unit id="44ebe0741417aa78ef5defc6e06797a635cee244" translate="yes" xml:space="preserve">
          <source>Lifetimes on function or method parameters are called &lt;em&gt;input lifetimes&lt;/em&gt;, and lifetimes on return values are called &lt;em&gt;output lifetimes&lt;/em&gt;.</source>
          <target state="translated">函数或方法参数上的&lt;em&gt;生存期&lt;/em&gt;称为&lt;em&gt;输入生存期&lt;/em&gt;，而返回值上的&lt;em&gt;生存期&lt;/em&gt;称为&lt;em&gt;输出生存期&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b0908dfa434be81e3deb0facdeb85bcd33472550" translate="yes" xml:space="preserve">
          <source>Lifetimes used in &lt;code&gt;fn&lt;/code&gt; or &lt;code&gt;Fn&lt;/code&gt; syntax must be explicitly declared using &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; binders. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711484ebabd34c5bee47c2a0196b50ef7c53c764" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="translated">类似于&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;一样，无论是否经过超时，此函数返回时都将重新获取指定的锁。</target>
        </trans-unit>
        <trans-unit id="9143067c5010240235e5098fdd6d0b035ca2de7f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="translated">与&lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;/a&gt;一样，无论是否经过超时，都将在此函数返回时重新获取指定的锁。</target>
        </trans-unit>
        <trans-unit id="841a9a19b58dd6630bdc34ede04fb57fa218eece" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090c127fd35edc1d60b1dabd86f3ca4ea132ca47" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cbabaec83102adcf38ba2f63965f7483dc4ff0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">像&lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;一样， &lt;code&gt;copy&lt;/code&gt; 创建 &lt;code&gt;T&lt;/code&gt; 的按位副本，而不管 &lt;code&gt;T&lt;/code&gt; 是否为&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则同时使用以 &lt;code&gt;*src&lt;/code&gt; 开头的区域和以 &lt;code&gt;*dst&lt;/code&gt; 开头的区域的值都可能&lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;违反内存安全性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6b5f673832d554b3ba278cb3e90ddc20575f12f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf650a829b373e9102813a508f7fe2ddc52356d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">像&lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;一样， &lt;code&gt;copy_nonoverlapping&lt;/code&gt; 会创建 &lt;code&gt;T&lt;/code&gt; 的按位副本，而不管 &lt;code&gt;T&lt;/code&gt; 是否为&lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则同时使用 &lt;code&gt;*src&lt;/code&gt; 开头的区域和 &lt;code&gt;*dst&lt;/code&gt; 开头的区域中的值&lt;em&gt;都&lt;/em&gt;可能&lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;违反内存安全性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="673f6dbc7b8c22dd58a3649d0763e6d47086e689" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; (for load, store, and load-with-store operations, respectively) with the additional guarantee that all threads see all sequentially consistent operations in the same order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf9f8511904c5069b83f4fd094004a94b015444" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.forget&quot;&gt;&lt;code&gt;forget&lt;/code&gt;&lt;/a&gt;, but also accepts unsized values.</source>
          <target state="translated">喜欢&lt;a href=&quot;fn.forget&quot;&gt; &lt;code&gt;forget&lt;/code&gt; &lt;/a&gt;，但也接受大小不一的值。</target>
        </trans-unit>
        <trans-unit id="4b60bd7f4df6aad7fa80856c1bd518eaad347be6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">像&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;一样， &lt;code&gt;copy&lt;/code&gt; 创建 &lt;code&gt;T&lt;/code&gt; 的按位副本，而不管 &lt;code&gt;T&lt;/code&gt; 是否为&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则同时使用以 &lt;code&gt;*src&lt;/code&gt; 开头的区域和以 &lt;code&gt;*dst&lt;/code&gt; 开头的区域的值都可能&lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;违反内存安全性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae45f3009db76dae79642054ed9d2e4707eced76" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfb87516d3e691309e3183e393372085b3eb5c7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">像&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;一样， &lt;code&gt;copy_nonoverlapping&lt;/code&gt; 会创建 &lt;code&gt;T&lt;/code&gt; 的按位副本，而不管 &lt;code&gt;T&lt;/code&gt; 是否为&lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则同时使用 &lt;code&gt;*src&lt;/code&gt; 开头的区域和 &lt;code&gt;*dst&lt;/code&gt; 开头的区域中的值&lt;em&gt;都&lt;/em&gt;可能&lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;违反内存安全性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29fb501f0793a6ba4173aacc2026afb59ff625c1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the returned value and the value at &lt;code&gt;*src&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;一样， &lt;code&gt;read_unaligned&lt;/code&gt; 会创建 &lt;code&gt;T&lt;/code&gt; 的按位副本，而不管 &lt;code&gt;T&lt;/code&gt; 是否为&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则同时使用返回值和 &lt;code&gt;*src&lt;/code&gt; 处的值可能会&lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;违反内存安全性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf95f150b3e045a75caa61fd8dd299e1f6177de4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_volatile&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the returned value and the value at &lt;code&gt;*src&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;. However, storing non-&lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types in volatile memory is almost certainly incorrect.</source>
          <target state="translated">与&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;一样， &lt;code&gt;read_volatile&lt;/code&gt; 会创建 &lt;code&gt;T&lt;/code&gt; 的按位副本，而不管 &lt;code&gt;T&lt;/code&gt; 是否为&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则同时使用返回值和 &lt;code&gt;*src&lt;/code&gt; 处的值可能会&lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;违反内存安全性&lt;/a&gt;。但是，几乎可以肯定地将非&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;类型存储在易失性存储器中。</target>
        </trans-unit>
        <trans-unit id="a2ef8c40adbd6ce1d9e2b9decbefda1339ad636f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; (for load, store, and load-with-store operations, respectively) with the additional guarantee that all threads see all sequentially consistent operations in the same order.</source>
          <target state="translated">与&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt;（分别用于加载，存储和随存储加载操作）类似，并额外保证所有线程以相同的顺序看到所有顺序一致的操作。</target>
        </trans-unit>
        <trans-unit id="10040ebca04aab631b833e06ce9af822e9824086" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb3f2bd27f2c64ea34e80152dae14864b47bd75" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;keyword.enum&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt;s, a module and its content are private by default, unaccessible to code outside of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a2b45437346496bd0f17702b7e91d1466c2799" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, this macro also has a second version, where a custom panic message can be provided.</source>
          <target state="translated">像&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;一样！，此宏还具有第二个版本，可以在其中提供自定义紧急消息。</target>
        </trans-unit>
        <trans-unit id="4a3d6c41c117ef0813067fce9ad6d2c797819f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, this macro has a second form, where a custom panic message can be provided.</source>
          <target state="translated">像&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;一样！，此宏具有第二种形式，可以提供自定义紧急消息。</target>
        </trans-unit>
        <trans-unit id="2f9660f47631acac7f2a52b8ab96514dc036d49e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;LineWriter&lt;/code&gt;&amp;rsquo;s buffer will also be flushed when the &lt;code&gt;LineWriter&lt;/code&gt; goes out of scope or when its internal buffer is full.</source>
          <target state="translated">像&lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; &lt;/a&gt;，一个 &lt;code&gt;LineWriter&lt;/code&gt; 的缓冲区也将被刷新时 &lt;code&gt;LineWriter&lt;/code&gt; 去的范围或在其内部缓冲区已满了。</target>
        </trans-unit>
        <trans-unit id="58df427e5bbce21caf2fe2b837297d163849e77b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c450b5b408d7fbd12d604817a55adc65281b8d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8fc695456a6957ca08bda068f50835ca6480df" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, if there is a value, it is wrapped in a &lt;code&gt;Some(T)&lt;/code&gt;. But if the iteration is over, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">与&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;类似，如果有值，则将其包装在 &lt;code&gt;Some(T)&lt;/code&gt; 中。但是，如果迭代结束， &lt;code&gt;None&lt;/code&gt; 返回None。</target>
        </trans-unit>
        <trans-unit id="375e88d0fb45924c13a3ac3d25d35cc53e0b6dbf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ece68e98c367b427da7eda601344bdda8373dc9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96e1257fda431003f96a740ec957795754307e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; is normally associated with the innermost enclosing loop, but &lt;code&gt;continue 'label&lt;/code&gt; may be used to specify the loop affected. A &lt;code&gt;continue&lt;/code&gt; expression is only permitted in the body of a loop.</source>
          <target state="translated">像 &lt;code&gt;break&lt;/code&gt; 一样， &lt;code&gt;continue&lt;/code&gt; 通常与最内层的循环相关联，但是 &lt;code&gt;continue 'label&lt;/code&gt; 可用于指定受影响的循环。仅在循环体内允许使用 &lt;code&gt;continue&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="4e6414b7dcb2bf632ebca1570eac937be87ca89a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; is normally associated with the innermost enclosing loop, but labels may be used to specify the affected loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088a111a2146143c269622f6720bedf46b4095af" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;ctlz&lt;/code&gt;, but extra-unsafe as it returns &lt;code&gt;undef&lt;/code&gt; when given an &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;ctlz&lt;/code&gt; 一样，但是非常不安全，因为当给定 &lt;code&gt;x&lt;/code&gt; 值为 &lt;code&gt;0&lt;/code&gt; 时，它返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0441e738f2dd6cd8b8b2b78d7c0e5293c433e051" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;cttz&lt;/code&gt;, but extra-unsafe as it returns &lt;code&gt;undef&lt;/code&gt; when given an &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;cttz&lt;/code&gt; 一样，但是非常不安全，因为当给定 &lt;code&gt;x&lt;/code&gt; 值为 &lt;code&gt;0&lt;/code&gt; 时，它返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aafea1bc859a7c488e520cc6c530088c8d2d86f9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;panic!&lt;/code&gt;, this macro has a second form for displaying custom values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af819e7752cc0d0f79bda85b3236f2d4d09b2e2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers.</source>
          <target state="translated">类似于 &lt;code&gt;read&lt;/code&gt; ，除了它读入缓冲区的一部分。</target>
        </trans-unit>
        <trans-unit id="c398915090a8fe75043794195cb2a1010511d11d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;../../../io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于 &lt;code&gt;read&lt;/code&gt; ，除了它读入缓冲区的一部分。&lt;a href=&quot;../../../io/trait.read#method.read_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4193e9abdbffc61433821360262b7ce147ba44be" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;../io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于 &lt;code&gt;read&lt;/code&gt; ，除了它读入缓冲区的一部分。&lt;a href=&quot;../io/trait.read#method.read_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19a11d624c5ac2fd3c32083744114569a63b8be1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于 &lt;code&gt;read&lt;/code&gt; ，除了它读入缓冲区的一部分。&lt;a href=&quot;io/trait.read#method.read_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab91074c2b287fdf8a7b212edaf2da1655891bbf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于 &lt;code&gt;read&lt;/code&gt; ，除了它读入缓冲区的一部分。&lt;a href=&quot;trait.read#method.read_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0c137ee5317a547c2505ef5380b9708644889bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers.</source>
          <target state="translated">类似于 &lt;code&gt;write&lt;/code&gt; ，不同之处在于它从缓冲区的一部分进行写入。</target>
        </trans-unit>
        <trans-unit id="52fa708382c8776f6cbe3b5227e8d830d96b01c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于 &lt;code&gt;write&lt;/code&gt; ，不同之处在于它从缓冲区的一部分进行写入。&lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5724f707420fb63c78e29f6894aa5e96feb279b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于 &lt;code&gt;write&lt;/code&gt; ，不同之处在于它从缓冲区的一部分进行写入。&lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8e23cd5a3cb733eb5eff3ebaeba471859348fb4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于 &lt;code&gt;write&lt;/code&gt; ，不同之处在于它从缓冲区的一部分进行写入。&lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be2823934efbd612499317ea4eb64b49a897e3b9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于 &lt;code&gt;write&lt;/code&gt; ，不同之处在于它从缓冲区的一部分进行写入。&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="902993443cc36d88600a8cb05ef8c36915632034" translate="yes" xml:space="preserve">
          <source>Like all instances of UB, if this assumption turns out to be wrong, i.e., the &lt;code&gt;unreachable_unchecked()&lt;/code&gt; call is actually reachable among all possible control flow, the compiler will apply the wrong optimization strategy, and may sometimes even corrupt seemingly unrelated code, causing difficult-to-debug problems.</source>
          <target state="translated">与UB的所有实例一样，如果这种假设被证明是错误的，即在所有可能的控制流中 &lt;code&gt;unreachable_unchecked()&lt;/code&gt; 调用实际上是可以到达的，则编译器将应用错误的优化策略，有时甚至会破坏看似无关的代码，从而导致难以调试的问题。</target>
        </trans-unit>
        <trans-unit id="649ba6cfd601ba5aca37823d799268a81f5dc250" translate="yes" xml:space="preserve">
          <source>Like all technical books, this book has certain conventions in how it displays information. These conventions are documented here.</source>
          <target state="translated">像所有的技术书籍一样,本书在显示信息方面有一定的惯例。这里记录了这些惯例。</target>
        </trans-unit>
        <trans-unit id="44d26e3390ffce91f282ebeb751d71157005049b" translate="yes" xml:space="preserve">
          <source>Like any literal, an integer literal may be followed (immediately, without any spaces) by an &lt;em&gt;integer suffix&lt;/em&gt;, which forcibly sets the type of the literal. The integer suffix must be the name of one of the integral types: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, or &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">像任何文字一样，整数文字后可以紧跟着&lt;em&gt;整数后缀&lt;/em&gt;（不带任何空格），&lt;em&gt;后缀&lt;/em&gt;强制设置文字的类型。整数后缀必须是整数类型之一的名称： &lt;code&gt;u8&lt;/code&gt; ， &lt;code&gt;i8&lt;/code&gt; ， &lt;code&gt;u16&lt;/code&gt; ， &lt;code&gt;i16&lt;/code&gt; ， &lt;code&gt;u32&lt;/code&gt; ， &lt;code&gt;i32&lt;/code&gt; ， &lt;code&gt;u64&lt;/code&gt; ， &lt;code&gt;i64&lt;/code&gt; ， &lt;code&gt;u128&lt;/code&gt; ， &lt;code&gt;i128&lt;/code&gt; ， &lt;code&gt;usize&lt;/code&gt; ，或 &lt;code&gt;isize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe96ba09f6c5b465c5068945c430d86210b786b4" translate="yes" xml:space="preserve">
          <source>Like any other &lt;code&gt;struct&lt;/code&gt;, a vector is freed when it goes out of scope, as annotated in Listing 8-4.</source>
          <target state="translated">像任何其他 &lt;code&gt;struct&lt;/code&gt; 一样，向量超出范围时将被释放，如清单8-4所示。</target>
        </trans-unit>
        <trans-unit id="05c02c45bd9fe3c41ff9466036864fee28d10e75" translate="yes" xml:space="preserve">
          <source>Like asynchronous channels, if the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, If the &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与异步通道一样，如果在尝试使用&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;时&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;断开连接，则&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;方法将返回&lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt;。同样，如果&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt;试图断开&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;时，&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; 的&lt;/a&gt;方法将返回一个&lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5aebd2c614f88bfe78d840f656119aee198d25e8" translate="yes" xml:space="preserve">
          <source>Like integer literals, a floating-point literal may be followed by a suffix, so long as the pre-suffix part does not end with &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). The suffix forcibly sets the type of the literal. There are two valid &lt;em&gt;floating-point suffixes&lt;/em&gt;, &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt; (the 32-bit and 64-bit floating point types), which explicitly determine the type of the literal.</source>
          <target state="translated">像整数文字一样，浮点文字之后可以加上后缀，只要后缀部分不以 &lt;code&gt;U+002E&lt;/code&gt; （ &lt;code&gt;.&lt;/code&gt; ）结尾。后缀强行设置文字的类型。有两种有效的&lt;em&gt;浮点后缀&lt;/em&gt;， &lt;code&gt;f32&lt;/code&gt; 和 &lt;code&gt;f64&lt;/code&gt; （32位和64位浮点类型），其明确地确定文字的类型。</target>
        </trans-unit>
        <trans-unit id="75d8318497142cc1c07dc08759286ca5f2b7edc7" translate="yes" xml:space="preserve">
          <source>Like items, &lt;code&gt;use&lt;/code&gt; declarations are private to the containing module, by default. Also like items, a &lt;code&gt;use&lt;/code&gt; declaration can be public, if qualified by the &lt;code&gt;pub&lt;/code&gt; keyword. Such a &lt;code&gt;use&lt;/code&gt; declaration serves to &lt;em&gt;re-export&lt;/em&gt; a name. A public &lt;code&gt;use&lt;/code&gt; declaration can therefore &lt;em&gt;redirect&lt;/em&gt; some public name to a different target definition: even a definition with a private canonical path, inside a different module. If a sequence of such redirections form a cycle or cannot be resolved unambiguously, they represent a compile-time error.</source>
          <target state="translated">与项目一样，默认情况下， &lt;code&gt;use&lt;/code&gt; 声明对包含模块是私有的。与项一样，如果通过 &lt;code&gt;pub&lt;/code&gt; 关键字限定，则 &lt;code&gt;use&lt;/code&gt; 声明可以是公共的。这样的 &lt;code&gt;use&lt;/code&gt; 声明用于&lt;em&gt;重新导出&lt;/em&gt;名称。因此，公共 &lt;code&gt;use&lt;/code&gt; 声明可以&lt;em&gt;将&lt;/em&gt;某些公共名称&lt;em&gt;重定向&lt;/em&gt;到不同的目标定义：甚至是在不同模块内具有私有规范路径的定义。如果这样的重定向序列形成一个循环或无法明确解决，则它们表示编译时错误。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4455a5352379b9bfb84306293e10135e6768efff" translate="yes" xml:space="preserve">
          <source>Like most indexing operations, the count starts from zero, so &lt;code&gt;nth(0)&lt;/code&gt; returns the first value, &lt;code&gt;nth(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">像大多数索引操作一样，计数从零开始，因此 &lt;code&gt;nth(0)&lt;/code&gt; 返回第一个值， &lt;code&gt;nth(1)&lt;/code&gt; 返回第二个值，依此类推。</target>
        </trans-unit>
        <trans-unit id="808e2460e25efca05f0265071060604e1e534bac" translate="yes" xml:space="preserve">
          <source>Like references in rust, function pointers are assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type &lt;code&gt;Option&amp;lt;fn()&amp;gt;&lt;/code&gt; with your required signature.</source>
          <target state="translated">像rust中的引用一样，函数指针被假定为不为null，因此，如果您希望通过FFI传递函数指针并能够容纳null指针，请使用所需的签名使 &lt;code&gt;Option&amp;lt;fn()&amp;gt;&lt;/code&gt; 类型成为可能。</target>
        </trans-unit>
        <trans-unit id="8e44ee89e79563bdf5dbc7eeeb4e89ae7df53d96" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;keyword.for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; expression, we can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt;. A &lt;code&gt;while&lt;/code&gt; expression cannot break with a value and always evaluates to &lt;code&gt;()&lt;/code&gt; unlike &lt;a href=&quot;keyword.loop&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdec5b5891f0978d4130ee94d9517ad5371a9c05" translate="yes" xml:space="preserve">
          <source>Likewise, combining the &lt;code&gt;C&lt;/code&gt; representation with a primitive representation, the layout is unspecified.</source>
          <target state="translated">同样，将 &lt;code&gt;C&lt;/code&gt; 表示形式与基本表示形式组合在一起，布局也未指定。</target>
        </trans-unit>
        <trans-unit id="43eac78cc95cdbd3213a6055d8d48f1d53720313" translate="yes" xml:space="preserve">
          <source>Likewise, combining two primitive representations together is unspecified.</source>
          <target state="translated">同样,将两个基元表征组合在一起也是不明确的。</target>
        </trans-unit>
        <trans-unit id="a87f62e5c0ad27b39b657994af4f2f6af6bcd4e4" translate="yes" xml:space="preserve">
          <source>Likewise, the signature of the function uses &lt;code&gt;&amp;amp;&lt;/code&gt; to indicate that the type of the parameter &lt;code&gt;s&lt;/code&gt; is a reference. Let&amp;rsquo;s add some explanatory annotations:</source>
          <target state="translated">同样，函数的签名使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 表示参数 &lt;code&gt;s&lt;/code&gt; 的类型是引用。让我们添加一些解释性注释：</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="01de4d38c5a9265699ce4ab27dfaf087bbe8ecf6" translate="yes" xml:space="preserve">
          <source>Limitations of the &lt;code id=&quot;limitations-of-the-cacher-implementation&quot;&gt;Cacher&lt;/code&gt; Implementation</source>
          <target state="translated">&lt;code id=&quot;limitations-of-the-cacher-implementation&quot;&gt;Cacher&lt;/code&gt; 实施的局限性</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="6374b1b52339bde3abd0bb8e4d466f1af18a84f0" translate="yes" xml:space="preserve">
          <source>Line comment</source>
          <target state="translated">行评论</target>
        </trans-unit>
        <trans-unit id="deea94a5bfb30ea2c7507a3f03c99253e4272a0a" translate="yes" xml:space="preserve">
          <source>Line comments beginning with &lt;code&gt;//!&lt;/code&gt; and block comments &lt;code&gt;/*! ... */&lt;/code&gt; are doc comments that apply to the parent of the comment, rather than the item that follows. That is, they are equivalent to writing &lt;code&gt;#![doc=&quot;...&quot;]&lt;/code&gt; around the body of the comment. &lt;code&gt;//!&lt;/code&gt; comments are usually used to document modules that occupy a source file.</source>
          <target state="translated">行注释以 &lt;code&gt;//!&lt;/code&gt; 开头！并阻止评论 &lt;code&gt;/*! ... */&lt;/code&gt; 是适用于注释父项的doc注释，而不是其后的项目。也就是说，它们等效于在注释主体周围编写 &lt;code&gt;#![doc=&quot;...&quot;]&lt;/code&gt; 。 &lt;code&gt;//!&lt;/code&gt; 注释通常用于记录占用源文件的模块。</target>
        </trans-unit>
        <trans-unit id="762dee2b9cd8a9da4291e16ff13ceac56af56d99" translate="yes" xml:space="preserve">
          <source>Line doc comments beginning with exactly &lt;em&gt;three&lt;/em&gt; slashes (&lt;code&gt;///&lt;/code&gt;), and block doc comments (&lt;code&gt;/** ... */&lt;/code&gt;), both inner doc comments, are interpreted as a special syntax for &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt; attributes&lt;/a&gt;. That is, they are equivalent to writing &lt;code&gt;#[doc=&quot;...&quot;]&lt;/code&gt; around the body of the comment, i.e., &lt;code&gt;/// Foo&lt;/code&gt; turns into &lt;code&gt;#[doc=&quot;Foo&quot;]&lt;/code&gt; and &lt;code&gt;/** Bar */&lt;/code&gt; turns into &lt;code&gt;#[doc=&quot;Bar&quot;]&lt;/code&gt;.</source>
          <target state="translated">行doc注释以正好&lt;em&gt;三个&lt;/em&gt;斜杠（ &lt;code&gt;///&lt;/code&gt; ）开头，而块doc注释（ &lt;code&gt;/** ... */&lt;/code&gt; ）都是内部doc注释，被解释为&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; 属性&lt;/a&gt;的特殊语法。也就是说，它们等效于在注释的主体周围写 &lt;code&gt;#[doc=&quot;...&quot;]&lt;/code&gt; ，即 &lt;code&gt;/// Foo&lt;/code&gt; 变成 &lt;code&gt;#[doc=&quot;Foo&quot;]&lt;/code&gt; 和 &lt;code&gt;/** Bar */&lt;/code&gt; 变成 &lt;code&gt;#[doc=&quot;Bar&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0f09e1a35a919b04916a657dcaf775def02ecc3" translate="yes" xml:space="preserve">
          <source>Line feed is escaped as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">换行符转义为 &lt;code&gt;\n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11a574794cee21df3f3bbe1f9331a0946b02f437" translate="yes" xml:space="preserve">
          <source>Line-break characters are allowed in string literals. Normally they represent themselves (i.e. no translation), but as a special exception, when an unescaped &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;) occurs immediately before the newline (&lt;code&gt;U+000A&lt;/code&gt;), the &lt;code&gt;U+005C&lt;/code&gt; character, the newline, and all whitespace at the beginning of the next line are ignored. Thus &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal:</source>
          <target state="translated">字符串文字中允许使用换行符。通常，它们代表自己（即不进行翻译），但是作为特殊例外，当在换行符（ &lt;code&gt;U+000A&lt;/code&gt; ）， &lt;code&gt;U+005C&lt;/code&gt; 字符，换行符和所有空白处之前出现未转义的 &lt;code&gt;U+005C&lt;/code&gt; 字符（ &lt;code&gt;\&lt;/code&gt; ）时下一行的开头将被忽略。因此 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 相等：</target>
        </trans-unit>
        <trans-unit id="d7a69d21787a597ee70bd4037b342464706e333a" translate="yes" xml:space="preserve">
          <source>Line-breaks are allowed in string literals. A line-break is either a newline (&lt;code&gt;U+000A&lt;/code&gt;) or a pair of carriage return and newline (&lt;code&gt;U+000D&lt;/code&gt;, &lt;code&gt;U+000A&lt;/code&gt;). Both byte sequences are normally translated to &lt;code&gt;U+000A&lt;/code&gt;, but as a special exception, when an unescaped &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;) occurs immediately before the line-break, then the &lt;code&gt;U+005C&lt;/code&gt; character, the line-break, and all whitespace at the beginning of the next line are ignored. Thus &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2830ad93f43cfc81ed338845630996d89e8c3581" translate="yes" xml:space="preserve">
          <source>LineWriter</source>
          <target state="translated">LineWriter</target>
        </trans-unit>
        <trans-unit id="a467a8d1c87cedc92c6a62d00ba608ee83995811" translate="yes" xml:space="preserve">
          <source>LineWriter::borrow</source>
          <target state="translated">LineWriter::borrow</target>
        </trans-unit>
        <trans-unit id="be9800c1f2dec531de8f863888451a1e1e2311ab" translate="yes" xml:space="preserve">
          <source>LineWriter::borrow_mut</source>
          <target state="translated">LineWriter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2c13ce7518167bb16bb38a5b26d00211f5dffbd5" translate="yes" xml:space="preserve">
          <source>LineWriter::by_ref</source>
          <target state="translated">LineWriter::by_ref</target>
        </trans-unit>
        <trans-unit id="ad5e984ff0e6171936808b93fcf31ce4b80c212c" translate="yes" xml:space="preserve">
          <source>LineWriter::flush</source>
          <target state="translated">LineWriter::flush</target>
        </trans-unit>
        <trans-unit id="df10811fc6539a5582a3d6ba85fdf94454c319b5" translate="yes" xml:space="preserve">
          <source>LineWriter::fmt</source>
          <target state="translated">LineWriter::fmt</target>
        </trans-unit>
        <trans-unit id="99043611351dc9ff3e05b31b6386acec9bd4d9f9" translate="yes" xml:space="preserve">
          <source>LineWriter::from</source>
          <target state="translated">LineWriter::from</target>
        </trans-unit>
        <trans-unit id="ac69fff03ab2476a267ab98b2b6890c7cf1cc55d" translate="yes" xml:space="preserve">
          <source>LineWriter::get_mut</source>
          <target state="translated">LineWriter::get_mut</target>
        </trans-unit>
        <trans-unit id="1f40adca93e9d87127f3dcb17bebb2d113f8e8fe" translate="yes" xml:space="preserve">
          <source>LineWriter::get_ref</source>
          <target state="translated">LineWriter::get_ref</target>
        </trans-unit>
        <trans-unit id="e241aca740fc32914d91f0be104b82973eb66e5e" translate="yes" xml:space="preserve">
          <source>LineWriter::into</source>
          <target state="translated">LineWriter::into</target>
        </trans-unit>
        <trans-unit id="775f2c8ae9898d577c81da95ed4fcd902133aac3" translate="yes" xml:space="preserve">
          <source>LineWriter::into_inner</source>
          <target state="translated">LineWriter::into_inner</target>
        </trans-unit>
        <trans-unit id="dc3a9d15cfff5be7e19c52c4a56f2c5757e1f703" translate="yes" xml:space="preserve">
          <source>LineWriter::new</source>
          <target state="translated">LineWriter::new</target>
        </trans-unit>
        <trans-unit id="24e05e7c8c89d11d5f69df6388a9b0041bdc7c12" translate="yes" xml:space="preserve">
          <source>LineWriter::try_from</source>
          <target state="translated">LineWriter::try_from</target>
        </trans-unit>
        <trans-unit id="61eebd307b1c261703d7a99419578cfb8f7603b3" translate="yes" xml:space="preserve">
          <source>LineWriter::try_into</source>
          <target state="translated">LineWriter::try_into</target>
        </trans-unit>
        <trans-unit id="af6ffe50802be602950bd895cf9e0cb854fb1812" translate="yes" xml:space="preserve">
          <source>LineWriter::type_id</source>
          <target state="translated">LineWriter::type_id</target>
        </trans-unit>
        <trans-unit id="554b503c3ba754005e39b90ec87f0d92638d2c6e" translate="yes" xml:space="preserve">
          <source>LineWriter::with_capacity</source>
          <target state="translated">LineWriter::with_capacity</target>
        </trans-unit>
        <trans-unit id="221f080203de74c4a951139b8978acaf6b428212" translate="yes" xml:space="preserve">
          <source>LineWriter::write</source>
          <target state="translated">LineWriter::write</target>
        </trans-unit>
        <trans-unit id="718afa20219fcf1aa652f5865af9a7a30b0cf90f" translate="yes" xml:space="preserve">
          <source>LineWriter::write_all</source>
          <target state="translated">LineWriter::write_all</target>
        </trans-unit>
        <trans-unit id="e92db461a6c35320c65374e4144e5044c1b88bad" translate="yes" xml:space="preserve">
          <source>LineWriter::write_fmt</source>
          <target state="translated">LineWriter::write_fmt</target>
        </trans-unit>
        <trans-unit id="d174a06b1546e4b7fde2c0cdcd5ca37b66ded43b" translate="yes" xml:space="preserve">
          <source>LineWriter::write_vectored</source>
          <target state="translated">LineWriter::write_vectored</target>
        </trans-unit>
        <trans-unit id="c6fd3870c86e7422a0146e1e2a052437fb8e51e2" translate="yes" xml:space="preserve">
          <source>Lines</source>
          <target state="translated">Lines</target>
        </trans-unit>
        <trans-unit id="34d99e5c2f3cbf7a2f6c06ae38bf6f1437170c72" translate="yes" xml:space="preserve">
          <source>Lines are ended with either a newline (&lt;code&gt;\n&lt;/code&gt;) or a carriage return with a line feed (&lt;code&gt;\r\n&lt;/code&gt;).</source>
          <target state="translated">行以换行符（ &lt;code&gt;\n&lt;/code&gt; ）结束，或者以换行符（ &lt;code&gt;\r\n&lt;/code&gt; ）返回回车符。</target>
        </trans-unit>
        <trans-unit id="8372047979cef10f511e256735d06fdb5834080a" translate="yes" xml:space="preserve">
          <source>Lines::all</source>
          <target state="translated">Lines::all</target>
        </trans-unit>
        <trans-unit id="ab3890e2134cb7b243711c9eb9d91f7d2b2bdbb5" translate="yes" xml:space="preserve">
          <source>Lines::any</source>
          <target state="translated">Lines::any</target>
        </trans-unit>
        <trans-unit id="70cb6c67edb194cbf85640b28d5918c1d359d3b1" translate="yes" xml:space="preserve">
          <source>Lines::borrow</source>
          <target state="translated">Lines::borrow</target>
        </trans-unit>
        <trans-unit id="18b3ef85cc38f93f055a82652080b268c1813b05" translate="yes" xml:space="preserve">
          <source>Lines::borrow_mut</source>
          <target state="translated">Lines::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ddcac326a974acb99a5bdd0266258af4cf68f560" translate="yes" xml:space="preserve">
          <source>Lines::by_ref</source>
          <target state="translated">Lines::by_ref</target>
        </trans-unit>
        <trans-unit id="2210ca2bf58eac1157cb91245ab84bdb9fbfa42e" translate="yes" xml:space="preserve">
          <source>Lines::chain</source>
          <target state="translated">Lines::chain</target>
        </trans-unit>
        <trans-unit id="819432c98b0ed8115a058abc108fe41e16c028a7" translate="yes" xml:space="preserve">
          <source>Lines::clone</source>
          <target state="translated">Lines::clone</target>
        </trans-unit>
        <trans-unit id="3a9a20c42d37180cc289d3ed86b67aeef7065926" translate="yes" xml:space="preserve">
          <source>Lines::clone_from</source>
          <target state="translated">Lines::clone_from</target>
        </trans-unit>
        <trans-unit id="6d03cc14ec75314e6e9cd97f6317e2bfc576a512" translate="yes" xml:space="preserve">
          <source>Lines::clone_into</source>
          <target state="translated">Lines::clone_into</target>
        </trans-unit>
        <trans-unit id="2cc7e95a9a252a0e4512584de05d3735eda6c7e4" translate="yes" xml:space="preserve">
          <source>Lines::cloned</source>
          <target state="translated">Lines::cloned</target>
        </trans-unit>
        <trans-unit id="a59dde6acd33a5348665946c0a8673f286d24d8a" translate="yes" xml:space="preserve">
          <source>Lines::cmp</source>
          <target state="translated">Lines::cmp</target>
        </trans-unit>
        <trans-unit id="5fc1ed1cda1fe359bfcd4cfa1c08b06a6870ed72" translate="yes" xml:space="preserve">
          <source>Lines::collect</source>
          <target state="translated">Lines::collect</target>
        </trans-unit>
        <trans-unit id="40c012a06c39d10c7006c0601e73b3570aeddd35" translate="yes" xml:space="preserve">
          <source>Lines::copied</source>
          <target state="translated">Lines::copied</target>
        </trans-unit>
        <trans-unit id="484755e089b99c626b30d970a194b907cb3dceef" translate="yes" xml:space="preserve">
          <source>Lines::count</source>
          <target state="translated">Lines::count</target>
        </trans-unit>
        <trans-unit id="f9088b84e14bdd699a44622c6a8c96e4ac54b67c" translate="yes" xml:space="preserve">
          <source>Lines::cycle</source>
          <target state="translated">Lines::cycle</target>
        </trans-unit>
        <trans-unit id="bb1a7e9933496da163e7e92f98497488344c4b65" translate="yes" xml:space="preserve">
          <source>Lines::enumerate</source>
          <target state="translated">Lines::enumerate</target>
        </trans-unit>
        <trans-unit id="e403dedf91eb2082514d2e5162543f8e68efb7da" translate="yes" xml:space="preserve">
          <source>Lines::eq</source>
          <target state="translated">Lines::eq</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
