<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="ae7d5fede6f36ca665efd08ae94669cbd14b7cc6" translate="yes" xml:space="preserve">
          <source>VarsOs::find</source>
          <target state="translated">VarsOs::find</target>
        </trans-unit>
        <trans-unit id="a97602f19f448bb335f850af073a9ce84cd5d88f" translate="yes" xml:space="preserve">
          <source>VarsOs::find_map</source>
          <target state="translated">VarsOs::find_map</target>
        </trans-unit>
        <trans-unit id="3678c5ef82f2cb08bc3b287c092316a2ada00a18" translate="yes" xml:space="preserve">
          <source>VarsOs::flat_map</source>
          <target state="translated">VarsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="e8a42aa17639bc96d10468e86951b455866c4904" translate="yes" xml:space="preserve">
          <source>VarsOs::flatten</source>
          <target state="translated">VarsOs::flatten</target>
        </trans-unit>
        <trans-unit id="46320ba9ecbf055cb2e56af08cec6e628a336f92" translate="yes" xml:space="preserve">
          <source>VarsOs::fmt</source>
          <target state="translated">VarsOs::fmt</target>
        </trans-unit>
        <trans-unit id="7bcbf2e75da1a46894beb596faa2a485d58f6a2d" translate="yes" xml:space="preserve">
          <source>VarsOs::fold</source>
          <target state="translated">VarsOs::fold</target>
        </trans-unit>
        <trans-unit id="51b69162489f5329a52d08395d177be1d60cb6a5" translate="yes" xml:space="preserve">
          <source>VarsOs::for_each</source>
          <target state="translated">VarsOs::for_each</target>
        </trans-unit>
        <trans-unit id="e06ff647273899d3fd4ea62e139dbf757cf3d8cc" translate="yes" xml:space="preserve">
          <source>VarsOs::from</source>
          <target state="translated">VarsOs::from</target>
        </trans-unit>
        <trans-unit id="0245bbf420434587e8ec6bdf35d9cf62a6cde011" translate="yes" xml:space="preserve">
          <source>VarsOs::fuse</source>
          <target state="translated">VarsOs::fuse</target>
        </trans-unit>
        <trans-unit id="479913c8896a1c5102d2a5ea1234f740bfde2328" translate="yes" xml:space="preserve">
          <source>VarsOs::ge</source>
          <target state="translated">VarsOs::ge</target>
        </trans-unit>
        <trans-unit id="17feba1de0fe9c2331df5c53c185c7617b4b8cc1" translate="yes" xml:space="preserve">
          <source>VarsOs::gt</source>
          <target state="translated">VarsOs::gt</target>
        </trans-unit>
        <trans-unit id="3033c2aeecf938c398013c5ab0852cd122a7d6b0" translate="yes" xml:space="preserve">
          <source>VarsOs::inspect</source>
          <target state="translated">VarsOs::inspect</target>
        </trans-unit>
        <trans-unit id="3f0b3d392367dab2dc143ca178da7b4d778bbd17" translate="yes" xml:space="preserve">
          <source>VarsOs::into</source>
          <target state="translated">VarsOs::into</target>
        </trans-unit>
        <trans-unit id="16fa54e40b1321bab910ef3ac287342748aea056" translate="yes" xml:space="preserve">
          <source>VarsOs::into_iter</source>
          <target state="translated">VarsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="5c63504ce660906345551dba943ce8d045612e95" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted</source>
          <target state="translated">VarsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="0fdd66d1bfafd9226a154278db222c3aee97c735" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by</source>
          <target state="translated">VarsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="204163a740d898b80542e502e7da9a7661337b36" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by_key</source>
          <target state="translated">VarsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="ae35eac698343e1ee4eeec512aed1c16a136d0c7" translate="yes" xml:space="preserve">
          <source>VarsOs::last</source>
          <target state="translated">VarsOs::last</target>
        </trans-unit>
        <trans-unit id="c01f90cf460a2003e266fcb0b34415121c12b736" translate="yes" xml:space="preserve">
          <source>VarsOs::le</source>
          <target state="translated">VarsOs::le</target>
        </trans-unit>
        <trans-unit id="c0cd86a67a36a78ad1451aca611b8fd991760e20" translate="yes" xml:space="preserve">
          <source>VarsOs::lt</source>
          <target state="translated">VarsOs::lt</target>
        </trans-unit>
        <trans-unit id="1cefab93b3f7c14142541eedb899ab5e71be9fc4" translate="yes" xml:space="preserve">
          <source>VarsOs::map</source>
          <target state="translated">VarsOs::map</target>
        </trans-unit>
        <trans-unit id="e6a8c9754fd49b2d51cbf24ecf6d94304e8e64c3" translate="yes" xml:space="preserve">
          <source>VarsOs::max</source>
          <target state="translated">VarsOs::max</target>
        </trans-unit>
        <trans-unit id="1f1f50d119da0ed96c40d44ea09ef96812375781" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by</source>
          <target state="translated">VarsOs::max_by</target>
        </trans-unit>
        <trans-unit id="0f2e6793ee02c5031cf6cc652fab9884db10bbdb" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by_key</source>
          <target state="translated">VarsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="af3d6a04943a8cf3ad8a6978c4e20520bbd7810c" translate="yes" xml:space="preserve">
          <source>VarsOs::min</source>
          <target state="translated">VarsOs::min</target>
        </trans-unit>
        <trans-unit id="65325562c65c7a37d9553910d80a4c50713493e5" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by</source>
          <target state="translated">VarsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce454f9015d8cd8601694fb53b1aac058cf4ec7c" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by_key</source>
          <target state="translated">VarsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="1c7e1099c4b87dd8e83e87ef896a8fe06530c255" translate="yes" xml:space="preserve">
          <source>VarsOs::ne</source>
          <target state="translated">VarsOs::ne</target>
        </trans-unit>
        <trans-unit id="abe200e7a70bbf42fbb261f3d6ecb1a850953161" translate="yes" xml:space="preserve">
          <source>VarsOs::next</source>
          <target state="translated">VarsOs::next</target>
        </trans-unit>
        <trans-unit id="753f8e880e8ece081c8080be088d05ec0d200f80" translate="yes" xml:space="preserve">
          <source>VarsOs::nth</source>
          <target state="translated">VarsOs::nth</target>
        </trans-unit>
        <trans-unit id="b6af18bf99508b4a2d5aac1fbdfad4b5780a6f74" translate="yes" xml:space="preserve">
          <source>VarsOs::partial_cmp</source>
          <target state="translated">VarsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="ba0322e8a281d2965f09dafdfe9b78ec1f84e172" translate="yes" xml:space="preserve">
          <source>VarsOs::partition</source>
          <target state="translated">VarsOs::partition</target>
        </trans-unit>
        <trans-unit id="91938a0453fc3e7b7813e5df0009b7580ef490d3" translate="yes" xml:space="preserve">
          <source>VarsOs::peekable</source>
          <target state="translated">VarsOs::peekable</target>
        </trans-unit>
        <trans-unit id="7a37b0e06b2930dc5a294f234caa4a16804177d0" translate="yes" xml:space="preserve">
          <source>VarsOs::position</source>
          <target state="translated">VarsOs::position</target>
        </trans-unit>
        <trans-unit id="4f098ada18205fbc46f5cd22be9968ee3d7b0363" translate="yes" xml:space="preserve">
          <source>VarsOs::product</source>
          <target state="translated">VarsOs::product</target>
        </trans-unit>
        <trans-unit id="6bf84c68f9daffbf302bd074f0e8be5a6ea7823d" translate="yes" xml:space="preserve">
          <source>VarsOs::rev</source>
          <target state="translated">VarsOs::rev</target>
        </trans-unit>
        <trans-unit id="1c60d42a9413b8a7c101dc83c2565f5d37b81a2a" translate="yes" xml:space="preserve">
          <source>VarsOs::rposition</source>
          <target state="translated">VarsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f65790ae1d5619919415f11aef0fe2aee47448a6" translate="yes" xml:space="preserve">
          <source>VarsOs::scan</source>
          <target state="translated">VarsOs::scan</target>
        </trans-unit>
        <trans-unit id="cb8748c599d4e59ff120199769de64e5786ad929" translate="yes" xml:space="preserve">
          <source>VarsOs::size_hint</source>
          <target state="translated">VarsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="3ea59b4b1aae9dc7c132d58be49e094fc8eaa95f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip</source>
          <target state="translated">VarsOs::skip</target>
        </trans-unit>
        <trans-unit id="02c1e6608b48c61896af2016b5b52d75d023957f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip_while</source>
          <target state="translated">VarsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="a0d6c6ad525cb20f675d004819c2121e056f42c8" translate="yes" xml:space="preserve">
          <source>VarsOs::step_by</source>
          <target state="translated">VarsOs::step_by</target>
        </trans-unit>
        <trans-unit id="6846222d088cefb1075c2f24c4eadbd7aed705eb" translate="yes" xml:space="preserve">
          <source>VarsOs::sum</source>
          <target state="translated">VarsOs::sum</target>
        </trans-unit>
        <trans-unit id="91c3203375fe48ab0d3fa32901ee5de67c77a411" translate="yes" xml:space="preserve">
          <source>VarsOs::take</source>
          <target state="translated">VarsOs::take</target>
        </trans-unit>
        <trans-unit id="144ba83f71bf339d2fc7ce6106d27d858be059f1" translate="yes" xml:space="preserve">
          <source>VarsOs::take_while</source>
          <target state="translated">VarsOs::take_while</target>
        </trans-unit>
        <trans-unit id="330e5de6bdd0923300ee2e19673f82661fe3b5aa" translate="yes" xml:space="preserve">
          <source>VarsOs::try_fold</source>
          <target state="translated">VarsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="7f9b1fb25f2d8dc898d57dd0ad57aa6074d0db25" translate="yes" xml:space="preserve">
          <source>VarsOs::try_for_each</source>
          <target state="translated">VarsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="0371b8d74af891c05681249ef7f32d83f6e8d3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::try_from</source>
          <target state="translated">VarsOs::try_from</target>
        </trans-unit>
        <trans-unit id="45aa3acec5ebcabeaf089da80e453c0f5f80cd2d" translate="yes" xml:space="preserve">
          <source>VarsOs::try_into</source>
          <target state="translated">VarsOs::try_into</target>
        </trans-unit>
        <trans-unit id="24d5d9ef2bba5983d72962681554163d3cc0d7ea" translate="yes" xml:space="preserve">
          <source>VarsOs::type_id</source>
          <target state="translated">VarsOs::type_id</target>
        </trans-unit>
        <trans-unit id="3e592311e132f7aa730baaf56aa5dd0ae220e3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::unzip</source>
          <target state="translated">VarsOs::unzip</target>
        </trans-unit>
        <trans-unit id="e4769bb4e270bd8e779d33f3cae641957c2527b8" translate="yes" xml:space="preserve">
          <source>VarsOs::zip</source>
          <target state="translated">VarsOs::zip</target>
        </trans-unit>
        <trans-unit id="3e8f48ebd55451a20501b45af4a4265976d600b6" translate="yes" xml:space="preserve">
          <source>Vec</source>
          <target state="translated">Vec</target>
        </trans-unit>
        <trans-unit id="9e8ec9d213a0da31ccaaba571b14789e42b08935" translate="yes" xml:space="preserve">
          <source>Vec::align_to</source>
          <target state="translated">Vec::align_to</target>
        </trans-unit>
        <trans-unit id="a6107ed66afb53f802511a5a643ee8656e497b0a" translate="yes" xml:space="preserve">
          <source>Vec::align_to_mut</source>
          <target state="translated">Vec::align_to_mut</target>
        </trans-unit>
        <trans-unit id="f61abeec7dd01f8c47bf83db4b4d0456a9af5e0b" translate="yes" xml:space="preserve">
          <source>Vec::append</source>
          <target state="translated">Vec::append</target>
        </trans-unit>
        <trans-unit id="966721890fa8492f6b4046bd9708da68c72adc73" translate="yes" xml:space="preserve">
          <source>Vec::as_mut</source>
          <target state="translated">Vec::as_mut</target>
        </trans-unit>
        <trans-unit id="831194353af948439212b65f5180ee63686be5ff" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_ptr</source>
          <target state="translated">Vec::as_mut_ptr</target>
        </trans-unit>
        <trans-unit id="2cd229f1c1c1c67e55b523142a4b5506c79ab5e4" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_slice</source>
          <target state="translated">Vec::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="c1e6da016e5f4ce35006127886b4b180eede68b8" translate="yes" xml:space="preserve">
          <source>Vec::as_ptr</source>
          <target state="translated">Vec::as_ptr</target>
        </trans-unit>
        <trans-unit id="8b5099d8e9c3e715862b2b38f181235c7cc24477" translate="yes" xml:space="preserve">
          <source>Vec::as_ref</source>
          <target state="translated">Vec::as_ref</target>
        </trans-unit>
        <trans-unit id="e50619a5c819f0a35e08edd227565f793562e4c8" translate="yes" xml:space="preserve">
          <source>Vec::as_slice</source>
          <target state="translated">Vec::as_slice</target>
        </trans-unit>
        <trans-unit id="0fd5dd3c29cf93dd4e97ef65f08a9644b11adf66" translate="yes" xml:space="preserve">
          <source>Vec::binary_search</source>
          <target state="translated">Vec::binary_search</target>
        </trans-unit>
        <trans-unit id="b52fc5259d9a5986689a231729ba2250dccdf822" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by</source>
          <target state="translated">Vec::binary_search_by</target>
        </trans-unit>
        <trans-unit id="c25875b591cdd49de2d27d47ee6d7ac1e21d9162" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by_key</source>
          <target state="translated">Vec::binary_search_by_key</target>
        </trans-unit>
        <trans-unit id="85bd126983a102e0968ff3a77e6cc098a02d6d2b" translate="yes" xml:space="preserve">
          <source>Vec::borrow</source>
          <target state="translated">Vec::borrow</target>
        </trans-unit>
        <trans-unit id="ce949f50884f71dd9c3bd065b3e9f2fac3e1b9b1" translate="yes" xml:space="preserve">
          <source>Vec::borrow_mut</source>
          <target state="translated">Vec::borrow_mut</target>
        </trans-unit>
        <trans-unit id="adf16c9ee55ed12543d9f09958b2da182d391549" translate="yes" xml:space="preserve">
          <source>Vec::by_ref</source>
          <target state="translated">Vec::by_ref</target>
        </trans-unit>
        <trans-unit id="879e3baf25a9301dece592c8e2fe831ab282b68c" translate="yes" xml:space="preserve">
          <source>Vec::capacity</source>
          <target state="translated">Vec::capacity</target>
        </trans-unit>
        <trans-unit id="0008361e288cf11981ce829d1646ffd8fcfd353d" translate="yes" xml:space="preserve">
          <source>Vec::chunks</source>
          <target state="translated">Vec::chunks</target>
        </trans-unit>
        <trans-unit id="753b8583ee481b3421bba7d981070ec72378a929" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact</source>
          <target state="translated">Vec::chunks_exact</target>
        </trans-unit>
        <trans-unit id="c16f1e8e4bdb33b2b62eb139dbdd695cce8cd9cb" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact_mut</source>
          <target state="translated">Vec::chunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="5129df9df37eeb41ed7c2d7d9a8c46bfb809e00b" translate="yes" xml:space="preserve">
          <source>Vec::chunks_mut</source>
          <target state="translated">Vec::chunks_mut</target>
        </trans-unit>
        <trans-unit id="b0c0c66afeddeab3613458326ddff56179dee6c6" translate="yes" xml:space="preserve">
          <source>Vec::clamp</source>
          <target state="translated">Vec::clamp</target>
        </trans-unit>
        <trans-unit id="2c2fbd7321fb15ce32f39380f1451dd1d8285167" translate="yes" xml:space="preserve">
          <source>Vec::clear</source>
          <target state="translated">Vec::clear</target>
        </trans-unit>
        <trans-unit id="f74617c56b1b4cb0ac739e41c8d386b187a932a0" translate="yes" xml:space="preserve">
          <source>Vec::clone</source>
          <target state="translated">Vec::clone</target>
        </trans-unit>
        <trans-unit id="7d2eba94d2d4e553221edef828d32477a74ec086" translate="yes" xml:space="preserve">
          <source>Vec::clone_from</source>
          <target state="translated">Vec::clone_from</target>
        </trans-unit>
        <trans-unit id="d765a16b06a09ff23e51adef46f6c11da8454339" translate="yes" xml:space="preserve">
          <source>Vec::clone_from_slice</source>
          <target state="translated">Vec::clone_from_slice</target>
        </trans-unit>
        <trans-unit id="33b8cb435611a78c3d465aaa7784c2b37cbb74e7" translate="yes" xml:space="preserve">
          <source>Vec::clone_into</source>
          <target state="translated">Vec::clone_into</target>
        </trans-unit>
        <trans-unit id="54c91e49e772a616e17900001275475155f0db86" translate="yes" xml:space="preserve">
          <source>Vec::cmp</source>
          <target state="translated">Vec::cmp</target>
        </trans-unit>
        <trans-unit id="0a3297559d1b2d0f5e9d86fb8e4f2702a52aed73" translate="yes" xml:space="preserve">
          <source>Vec::contains</source>
          <target state="translated">Vec::contains</target>
        </trans-unit>
        <trans-unit id="15b499228e83cdfe5d9bacf8f2717eb38b48f38b" translate="yes" xml:space="preserve">
          <source>Vec::copy_from_slice</source>
          <target state="translated">Vec::copy_from_slice</target>
        </trans-unit>
        <trans-unit id="b8ba6b02b6ab7d9e4a58c6ff8c4f8ed29c394009" translate="yes" xml:space="preserve">
          <source>Vec::copy_within</source>
          <target state="translated">Vec::copy_within</target>
        </trans-unit>
        <trans-unit id="789846c5e092b1b0a4c096dc5aa2920af554cadf" translate="yes" xml:space="preserve">
          <source>Vec::dedup</source>
          <target state="translated">Vec::dedup</target>
        </trans-unit>
        <trans-unit id="ef8409a58825c28ce8665f515341da99406dc45e" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by</source>
          <target state="translated">Vec::dedup_by</target>
        </trans-unit>
        <trans-unit id="363d4ee344588ea07c6bc5cfb25580f99e4e6fc4" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by_key</source>
          <target state="translated">Vec::dedup_by_key</target>
        </trans-unit>
        <trans-unit id="1a3c24e46d01efcb53b2e47b9f9fe05604eec885" translate="yes" xml:space="preserve">
          <source>Vec::default</source>
          <target state="translated">Vec::default</target>
        </trans-unit>
        <trans-unit id="b1a2319f3d6321033c9832ada871bb0364c41d6d" translate="yes" xml:space="preserve">
          <source>Vec::deref</source>
          <target state="translated">Vec::deref</target>
        </trans-unit>
        <trans-unit id="700ab6732dec0f913d9f30592a8a083e6275f0e9" translate="yes" xml:space="preserve">
          <source>Vec::deref_mut</source>
          <target state="translated">Vec::deref_mut</target>
        </trans-unit>
        <trans-unit id="5b692065705c3002050f3bc84600cd18eab70011" translate="yes" xml:space="preserve">
          <source>Vec::drain</source>
          <target state="translated">Vec::drain</target>
        </trans-unit>
        <trans-unit id="b56f02a07b5d1e06767ba9089e5a26237d2b6e96" translate="yes" xml:space="preserve">
          <source>Vec::drain_filter</source>
          <target state="translated">Vec::drain_filter</target>
        </trans-unit>
        <trans-unit id="1590e7c585be22084bde77caac361ebaa4d26167" translate="yes" xml:space="preserve">
          <source>Vec::drop</source>
          <target state="translated">Vec::drop</target>
        </trans-unit>
        <trans-unit id="c4e9c1a11aab0c3fbaa646a64a22f3069178f1e1" translate="yes" xml:space="preserve">
          <source>Vec::ends_with</source>
          <target state="translated">Vec::ends_with</target>
        </trans-unit>
        <trans-unit id="6460efc15d9228e5937dc4d9b4bb45990d32a27e" translate="yes" xml:space="preserve">
          <source>Vec::eq</source>
          <target state="translated">Vec::eq</target>
        </trans-unit>
        <trans-unit id="8e07e8d35672a19e43e8097f16c00d816c5cbe97" translate="yes" xml:space="preserve">
          <source>Vec::eq_ignore_ascii_case</source>
          <target state="translated">Vec::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="e46b7aa4e045855309d716fccf00cabd75a21e77" translate="yes" xml:space="preserve">
          <source>Vec::extend</source>
          <target state="translated">Vec::extend</target>
        </trans-unit>
        <trans-unit id="bb82f4df3cb27f5fbf87e6541ca1f465f414d3a5" translate="yes" xml:space="preserve">
          <source>Vec::extend_from_slice</source>
          <target state="translated">Vec::extend_from_slice</target>
        </trans-unit>
        <trans-unit id="87732cce3e95948f8d258db19ab24839895b0f76" translate="yes" xml:space="preserve">
          <source>Vec::first</source>
          <target state="translated">Vec::first</target>
        </trans-unit>
        <trans-unit id="fd582f0cbcb6e9f15ed28c1811608a7720bbbf52" translate="yes" xml:space="preserve">
          <source>Vec::first_mut</source>
          <target state="translated">Vec::first_mut</target>
        </trans-unit>
        <trans-unit id="cea112245a192a2715a4ac0d0d4ca6f9f0c88d11" translate="yes" xml:space="preserve">
          <source>Vec::flush</source>
          <target state="translated">Vec::flush</target>
        </trans-unit>
        <trans-unit id="74c0bff699639364b714e18c5e924ebe36d7bbb8" translate="yes" xml:space="preserve">
          <source>Vec::fmt</source>
          <target state="translated">Vec::fmt</target>
        </trans-unit>
        <trans-unit id="3b03e0120686cad397d6fe329718262a73208e9a" translate="yes" xml:space="preserve">
          <source>Vec::from</source>
          <target state="translated">Vec::from</target>
        </trans-unit>
        <trans-unit id="d2409bb7c2f488110f44be1023fc83c93200bfb1" translate="yes" xml:space="preserve">
          <source>Vec::from_iter</source>
          <target state="translated">Vec::from_iter</target>
        </trans-unit>
        <trans-unit id="e5b23b921224c968a51d83bca668d1740812f940" translate="yes" xml:space="preserve">
          <source>Vec::from_raw_parts</source>
          <target state="translated">Vec::from_raw_parts</target>
        </trans-unit>
        <trans-unit id="1b86c87d45b678c05eaedfa482e8e125c09283aa" translate="yes" xml:space="preserve">
          <source>Vec::ge</source>
          <target state="translated">Vec::ge</target>
        </trans-unit>
        <trans-unit id="a36985c63a8174e8d6e9d553daa519abe7ef73a3" translate="yes" xml:space="preserve">
          <source>Vec::get</source>
          <target state="translated">Vec::get</target>
        </trans-unit>
        <trans-unit id="55451d4c9012f0e9dc2705a9a20313c583cbad02" translate="yes" xml:space="preserve">
          <source>Vec::get_mut</source>
          <target state="translated">Vec::get_mut</target>
        </trans-unit>
        <trans-unit id="fbd1dbfc28f1dbf35081eb8a3b624e1ddb17a7d4" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked</source>
          <target state="translated">Vec::get_unchecked</target>
        </trans-unit>
        <trans-unit id="17aa782943cb8ba6f59f4076d63241b08687fe04" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked_mut</source>
          <target state="translated">Vec::get_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="12e2684fc2a72b4cdaf5511139faebcd74106115" translate="yes" xml:space="preserve">
          <source>Vec::gt</source>
          <target state="translated">Vec::gt</target>
        </trans-unit>
        <trans-unit id="3214576db0b2f915d4813a780951e762d0453108" translate="yes" xml:space="preserve">
          <source>Vec::hash</source>
          <target state="translated">Vec::hash</target>
        </trans-unit>
        <trans-unit id="cbad63e4de555a52c1156aacfa7acaa37d288f2d" translate="yes" xml:space="preserve">
          <source>Vec::hash_slice</source>
          <target state="translated">Vec::hash_slice</target>
        </trans-unit>
        <trans-unit id="817acc1f56c6b7266c14b400f36bd6915fc69aa9" translate="yes" xml:space="preserve">
          <source>Vec::index</source>
          <target state="translated">Vec::index</target>
        </trans-unit>
        <trans-unit id="255317cd139deae7b3798accef614b86d687af60" translate="yes" xml:space="preserve">
          <source>Vec::index_mut</source>
          <target state="translated">Vec::index_mut</target>
        </trans-unit>
        <trans-unit id="dae9879e89996749967d788919fd3919726095e5" translate="yes" xml:space="preserve">
          <source>Vec::insert</source>
          <target state="translated">Vec::insert</target>
        </trans-unit>
        <trans-unit id="4607993cbee4135669d2825495742a160937c51e" translate="yes" xml:space="preserve">
          <source>Vec::into</source>
          <target state="translated">Vec::into</target>
        </trans-unit>
        <trans-unit id="349c4bbf0cf7617a82524fff4ab6dd6dc12191ae" translate="yes" xml:space="preserve">
          <source>Vec::into_boxed_slice</source>
          <target state="translated">Vec::into_boxed_slice</target>
        </trans-unit>
        <trans-unit id="a2683d7c8a491dd1d14d82cbf394796000e6a7fa" translate="yes" xml:space="preserve">
          <source>Vec::into_iter</source>
          <target state="translated">Vec::into_iter</target>
        </trans-unit>
        <trans-unit id="0617d70073dd3ee36b70acc3469082e13a466d03" translate="yes" xml:space="preserve">
          <source>Vec::is_ascii</source>
          <target state="translated">Vec::is_ascii</target>
        </trans-unit>
        <trans-unit id="03169a81c036f8a9e76093b58242f30ae578d6e1" translate="yes" xml:space="preserve">
          <source>Vec::is_empty</source>
          <target state="translated">Vec::is_empty</target>
        </trans-unit>
        <trans-unit id="61e088912bf7c1fb5b0f0a806c372825ce419a0f" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted</source>
          <target state="translated">Vec::is_sorted</target>
        </trans-unit>
        <trans-unit id="2f71d97de0d886a25068ec904913d5f995b9ec67" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by</source>
          <target state="translated">Vec::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="13b69e903c4a68fcfe01f0c6f71a43d7cffcb8d2" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by_key</source>
          <target state="translated">Vec::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="67f810a4a6906d879a0e5bcdbd0629cdca0805fc" translate="yes" xml:space="preserve">
          <source>Vec::iter</source>
          <target state="translated">Vec::iter</target>
        </trans-unit>
        <trans-unit id="de14eea28b8af3ebd1fa7277134614ec35bede5f" translate="yes" xml:space="preserve">
          <source>Vec::iter_mut</source>
          <target state="translated">Vec::iter_mut</target>
        </trans-unit>
        <trans-unit id="89cb435951d0739bd80a43fd6eff389c96ea9137" translate="yes" xml:space="preserve">
          <source>Vec::last</source>
          <target state="translated">Vec::last</target>
        </trans-unit>
        <trans-unit id="8ec2cd17a9007516bf67a64facc2086a511ddabc" translate="yes" xml:space="preserve">
          <source>Vec::last_mut</source>
          <target state="translated">Vec::last_mut</target>
        </trans-unit>
        <trans-unit id="fbceeb72cec6860fa83702dbf07c61c0fba92768" translate="yes" xml:space="preserve">
          <source>Vec::le</source>
          <target state="translated">Vec::le</target>
        </trans-unit>
        <trans-unit id="525552cdf64c17bf1df49d77d5e10db05c4a1e65" translate="yes" xml:space="preserve">
          <source>Vec::len</source>
          <target state="translated">Vec::len</target>
        </trans-unit>
        <trans-unit id="1987ee0ae7df89f62926afad448cc8dcba8deb75" translate="yes" xml:space="preserve">
          <source>Vec::lt</source>
          <target state="translated">Vec::lt</target>
        </trans-unit>
        <trans-unit id="d73c1ce0cf0d3ba3f02694929282ef1ce4003f43" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_lowercase</source>
          <target state="translated">Vec::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="c984649eda1457369a83cadb8cb7cced71d85e8a" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_uppercase</source>
          <target state="translated">Vec::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="a14d3f9cce464f0a15bfb1ccdba70544cd9996dc" translate="yes" xml:space="preserve">
          <source>Vec::max</source>
          <target state="translated">Vec::max</target>
        </trans-unit>
        <trans-unit id="b7e2ddaad5a1e72a47531993b322493826992f01" translate="yes" xml:space="preserve">
          <source>Vec::min</source>
          <target state="translated">Vec::min</target>
        </trans-unit>
        <trans-unit id="27ac869c9c4d65022ccbe3db59b454048dac5d01" translate="yes" xml:space="preserve">
          <source>Vec::ne</source>
          <target state="translated">Vec::ne</target>
        </trans-unit>
        <trans-unit id="6fd848867337ba44b23b17c9fe00c94d829ea233" translate="yes" xml:space="preserve">
          <source>Vec::new</source>
          <target state="translated">Vec::new</target>
        </trans-unit>
        <trans-unit id="dcf8d5a328aa406810dabf32cd5ae01b3697decb" translate="yes" xml:space="preserve">
          <source>Vec::partial_cmp</source>
          <target state="translated">Vec::partial_cmp</target>
        </trans-unit>
        <trans-unit id="9694e7862ef0e60d886fd728679d90a8ee9470af" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index</source>
          <target state="translated">Vec::partition_at_index</target>
        </trans-unit>
        <trans-unit id="0bf6ca8cb659d720aa701bffc2851bc20dd39575" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by</source>
          <target state="translated">Vec::partition_at_index_by</target>
        </trans-unit>
        <trans-unit id="e14cd1ff21e7d949dfbecf45a57afb30d74ae935" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by_key</source>
          <target state="translated">Vec::partition_at_index_by_key</target>
        </trans-unit>
        <trans-unit id="a3bcf68a32491f6ce459bed1b83a0728f8d3facb" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup</source>
          <target state="translated">Vec::partition_dedup</target>
        </trans-unit>
        <trans-unit id="b33b907d031cab1a9f82dfabed52b3ec36a0bec7" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by</source>
          <target state="translated">Vec::partition_dedup_by</target>
        </trans-unit>
        <trans-unit id="e9042527cd9f8f7b837ac9979689f102fa5b9413" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by_key</source>
          <target state="translated">Vec::partition_dedup_by_key</target>
        </trans-unit>
        <trans-unit id="bb66cba5fa2c2be8852cc1be9f1f0442c400f3c1" translate="yes" xml:space="preserve">
          <source>Vec::pop</source>
          <target state="translated">Vec::pop</target>
        </trans-unit>
        <trans-unit id="015702c3beb31216ec8635f66c58b2dd6c7ce7d3" translate="yes" xml:space="preserve">
          <source>Vec::push</source>
          <target state="translated">Vec::push</target>
        </trans-unit>
        <trans-unit id="2a4ecb67c06267aff12807a92f7519558492cac3" translate="yes" xml:space="preserve">
          <source>Vec::rchunks</source>
          <target state="translated">Vec::rchunks</target>
        </trans-unit>
        <trans-unit id="2190a180c9e13d2c97a99729fb1cab9822f2b367" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact</source>
          <target state="translated">Vec::rchunks_exact</target>
        </trans-unit>
        <trans-unit id="8817d4c686ebb9e3df7649dc1ef10bbfc99e5a0f" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact_mut</source>
          <target state="translated">Vec::rchunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="d8b31989d0600b79568eabfbd02443e705c374f4" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_mut</source>
          <target state="translated">Vec::rchunks_mut</target>
        </trans-unit>
        <trans-unit id="845831747d56f3eeb00bb35e02809974b407e592" translate="yes" xml:space="preserve">
          <source>Vec::remove</source>
          <target state="translated">Vec::remove</target>
        </trans-unit>
        <trans-unit id="f2019e8c59ea1c039539318392c79102cc50f496" translate="yes" xml:space="preserve">
          <source>Vec::remove_item</source>
          <target state="translated">Vec::remove_item</target>
        </trans-unit>
        <trans-unit id="2a5af4f0d9906283d3505112b8edea1ff6aa8327" translate="yes" xml:space="preserve">
          <source>Vec::repeat</source>
          <target state="translated">Vec::repeat</target>
        </trans-unit>
        <trans-unit id="4030131e8b0f427754fca9b6fc2438b48ee132aa" translate="yes" xml:space="preserve">
          <source>Vec::reserve</source>
          <target state="translated">Vec::reserve</target>
        </trans-unit>
        <trans-unit id="c585b5b6b44dd8ead3846dfe6ff450a1d78b7ca4" translate="yes" xml:space="preserve">
          <source>Vec::reserve_exact</source>
          <target state="translated">Vec::reserve_exact</target>
        </trans-unit>
        <trans-unit id="abcfd065a68ab661075eb65973b1c2983f76906b" translate="yes" xml:space="preserve">
          <source>Vec::resize</source>
          <target state="translated">Vec::resize</target>
        </trans-unit>
        <trans-unit id="f9f7275b35ba8425eb32e3d8e98e0b77a08d75b9" translate="yes" xml:space="preserve">
          <source>Vec::resize_default</source>
          <target state="translated">Vec::resize_default</target>
        </trans-unit>
        <trans-unit id="9f1a1a7d355751c7299454f0938fedf8e60dd549" translate="yes" xml:space="preserve">
          <source>Vec::resize_with</source>
          <target state="translated">Vec::resize_with</target>
        </trans-unit>
        <trans-unit id="fd564ef5b54702a40658f77d501d340f02796c3b" translate="yes" xml:space="preserve">
          <source>Vec::retain</source>
          <target state="translated">Vec::retain</target>
        </trans-unit>
        <trans-unit id="020a2b7b3ef0fc23c178b5a1d57cf3220ce5e5ff" translate="yes" xml:space="preserve">
          <source>Vec::reverse</source>
          <target state="translated">Vec::reverse</target>
        </trans-unit>
        <trans-unit id="b4c1d9424701ec16b3d33474bf2a08c4a985a07b" translate="yes" xml:space="preserve">
          <source>Vec::rotate_left</source>
          <target state="translated">Vec::rotate_left</target>
        </trans-unit>
        <trans-unit id="a21a400e9268e082bb2ce482e8a8dfc6ab09fcf1" translate="yes" xml:space="preserve">
          <source>Vec::rotate_right</source>
          <target state="translated">Vec::rotate_right</target>
        </trans-unit>
        <trans-unit id="230272571f5aeb260545461fbf996bc487081e16" translate="yes" xml:space="preserve">
          <source>Vec::rsplit</source>
          <target state="translated">Vec::rsplit</target>
        </trans-unit>
        <trans-unit id="7588b43de214dc9942b6ec718d4f47a2bcedcba0" translate="yes" xml:space="preserve">
          <source>Vec::rsplit_mut</source>
          <target state="translated">Vec::rsplit_mut</target>
        </trans-unit>
        <trans-unit id="7d1297a0cd4e2ea121ae3252d869a3ab0996a1d6" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn</source>
          <target state="translated">Vec::rsplitn</target>
        </trans-unit>
        <trans-unit id="62a275a0772dd8dc1d1984c12daaf575f3aeeba5" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn_mut</source>
          <target state="translated">Vec::rsplitn_mut</target>
        </trans-unit>
        <trans-unit id="b0b31a5d59982433104183b210cdc7f9a7187cc9" translate="yes" xml:space="preserve">
          <source>Vec::set_len</source>
          <target state="translated">Vec::set_len</target>
        </trans-unit>
        <trans-unit id="dcf4c0bec18deb050ca3760e0ffcb5fbdd9b508d" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to</source>
          <target state="translated">Vec::shrink_to</target>
        </trans-unit>
        <trans-unit id="85ba0030d7417692c1610e814b9b07a58d76e77c" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to_fit</source>
          <target state="translated">Vec::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="16d167d14ba9fe06f16ed99bae2a2c03419b826b" translate="yes" xml:space="preserve">
          <source>Vec::sort</source>
          <target state="translated">Vec::sort</target>
        </trans-unit>
        <trans-unit id="81d8d3adb266cd3ddbf5075796bf792188963e60" translate="yes" xml:space="preserve">
          <source>Vec::sort_by</source>
          <target state="translated">Vec::sort_by</target>
        </trans-unit>
        <trans-unit id="fdaa89a60d5801892ad1d2af91cf732bf0fa3243" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_cached_key</source>
          <target state="translated">Vec::sort_by_cached_key</target>
        </trans-unit>
        <trans-unit id="d7a763e74650730d9254a393db15ca96341ce8b4" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_key</source>
          <target state="translated">Vec::sort_by_key</target>
        </trans-unit>
        <trans-unit id="abf375eb46a47b0a7dc0651c427daa5777cdc87d" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable</source>
          <target state="translated">Vec::sort_unstable</target>
        </trans-unit>
        <trans-unit id="6b1b6c683e214a704567cbb4866e258d5339b1a6" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by</source>
          <target state="translated">Vec::sort_unstable_by</target>
        </trans-unit>
        <trans-unit id="98bc35f1fee62d3c06dfa775a7a509e42577ec92" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by_key</source>
          <target state="translated">Vec::sort_unstable_by_key</target>
        </trans-unit>
        <trans-unit id="32db21414779495d647f8b90a008c9ef3267c648" translate="yes" xml:space="preserve">
          <source>Vec::splice</source>
          <target state="translated">Vec::splice</target>
        </trans-unit>
        <trans-unit id="a29a88b90b2283fcc62467ac92b894872c49e16c" translate="yes" xml:space="preserve">
          <source>Vec::split</source>
          <target state="translated">Vec::split</target>
        </trans-unit>
        <trans-unit id="6850cc7f3a18a5ae8795a517214f52bd03e37d1b" translate="yes" xml:space="preserve">
          <source>Vec::split_at</source>
          <target state="translated">Vec::split_at</target>
        </trans-unit>
        <trans-unit id="fffa7968cc458ceca06542d5bd41cbc6ab30cf0c" translate="yes" xml:space="preserve">
          <source>Vec::split_at_mut</source>
          <target state="translated">Vec::split_at_mut</target>
        </trans-unit>
        <trans-unit id="a158f5776929dc5fa591347c97af279ee6f308b5" translate="yes" xml:space="preserve">
          <source>Vec::split_first</source>
          <target state="translated">Vec::split_first</target>
        </trans-unit>
        <trans-unit id="6bc5d749a8be60dd619275925ca3abe61e1f1d9c" translate="yes" xml:space="preserve">
          <source>Vec::split_first_mut</source>
          <target state="translated">Vec::split_first_mut</target>
        </trans-unit>
        <trans-unit id="37a2c9e4c660e48769312c66dd3af4005f29a265" translate="yes" xml:space="preserve">
          <source>Vec::split_last</source>
          <target state="translated">Vec::split_last</target>
        </trans-unit>
        <trans-unit id="18a1b33cf122a212120639e6c43b624cc50e7d15" translate="yes" xml:space="preserve">
          <source>Vec::split_last_mut</source>
          <target state="translated">Vec::split_last_mut</target>
        </trans-unit>
        <trans-unit id="cf6ca76593d5b57fc21960139169843fb9cd7b00" translate="yes" xml:space="preserve">
          <source>Vec::split_mut</source>
          <target state="translated">Vec::split_mut</target>
        </trans-unit>
        <trans-unit id="03a916c0fcda14cb715141144403e9cf172139de" translate="yes" xml:space="preserve">
          <source>Vec::split_off</source>
          <target state="translated">Vec::split_off</target>
        </trans-unit>
        <trans-unit id="07108e7065deeacdbce3703bf0867dca70e0aa63" translate="yes" xml:space="preserve">
          <source>Vec::splitn</source>
          <target state="translated">Vec::splitn</target>
        </trans-unit>
        <trans-unit id="670a558b46826ad5134c813b4ea72c5f594e6c9a" translate="yes" xml:space="preserve">
          <source>Vec::splitn_mut</source>
          <target state="translated">Vec::splitn_mut</target>
        </trans-unit>
        <trans-unit id="0c0afbd8febc9c5f973424fd46f0e38ed59ccbe9" translate="yes" xml:space="preserve">
          <source>Vec::starts_with</source>
          <target state="translated">Vec::starts_with</target>
        </trans-unit>
        <trans-unit id="ad111eb0f36abc808f9f63d831dd393671b7d60f" translate="yes" xml:space="preserve">
          <source>Vec::swap</source>
          <target state="translated">Vec::swap</target>
        </trans-unit>
        <trans-unit id="c2d87a017cf8d077c99bd71bef846182121ea2f2" translate="yes" xml:space="preserve">
          <source>Vec::swap_remove</source>
          <target state="translated">Vec::swap_remove</target>
        </trans-unit>
        <trans-unit id="65ba4dcc752fbaf145dfc393c0ebd072c03850f4" translate="yes" xml:space="preserve">
          <source>Vec::swap_with_slice</source>
          <target state="translated">Vec::swap_with_slice</target>
        </trans-unit>
        <trans-unit id="187dcbc4c913473ea9ecc0da0ece64f155078f4d" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_lowercase</source>
          <target state="translated">Vec::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="9e994a24d814eaa773517353561f7db1763ba8c8" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_uppercase</source>
          <target state="translated">Vec::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="2d58122faa3b804afda87ac1afe94b0c2cf49a62" translate="yes" xml:space="preserve">
          <source>Vec::to_owned</source>
          <target state="translated">Vec::to_owned</target>
        </trans-unit>
        <trans-unit id="8295dc906018a2b87ebb59e81316a74736c8fba2" translate="yes" xml:space="preserve">
          <source>Vec::to_vec</source>
          <target state="translated">Vec::to_vec</target>
        </trans-unit>
        <trans-unit id="bbcf834cd40bf8d351710e8898b52c0706e47891" translate="yes" xml:space="preserve">
          <source>Vec::truncate</source>
          <target state="translated">Vec::truncate</target>
        </trans-unit>
        <trans-unit id="b539d40fa6817c484aec79eab2f72f8b069cd61a" translate="yes" xml:space="preserve">
          <source>Vec::try_from</source>
          <target state="translated">Vec::try_from</target>
        </trans-unit>
        <trans-unit id="edfbddcc1f5344a46cf8226a51d4480baae3f991" translate="yes" xml:space="preserve">
          <source>Vec::try_into</source>
          <target state="translated">Vec::try_into</target>
        </trans-unit>
        <trans-unit id="5c86c8fb54973c689718f247d2725be10c514476" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve</source>
          <target state="translated">Vec::try_reserve</target>
        </trans-unit>
        <trans-unit id="31147313c7e8fcea891f9a87a61ed1563dcc2831" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve_exact</source>
          <target state="translated">Vec::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="eed582f83a9d0aa9e1d0f2c268a23f8e413a6328" translate="yes" xml:space="preserve">
          <source>Vec::type_id</source>
          <target state="translated">Vec::type_id</target>
        </trans-unit>
        <trans-unit id="464742f01bb0869c25eb2800b7d8db8a1c7aac11" translate="yes" xml:space="preserve">
          <source>Vec::windows</source>
          <target state="translated">Vec::windows</target>
        </trans-unit>
        <trans-unit id="5728e3095df170ba310bd22e53f060f7088cdde8" translate="yes" xml:space="preserve">
          <source>Vec::with_capacity</source>
          <target state="translated">Vec::with_capacity</target>
        </trans-unit>
        <trans-unit id="265d2eb25b96552c36adc69855110dc3fd58c9aa" translate="yes" xml:space="preserve">
          <source>Vec::write</source>
          <target state="translated">Vec::write</target>
        </trans-unit>
        <trans-unit id="aeb1c503a25270fdde3115b7ad8a988a9c161a9d" translate="yes" xml:space="preserve">
          <source>Vec::write_all</source>
          <target state="translated">Vec::write_all</target>
        </trans-unit>
        <trans-unit id="bdef50740c7daaafaaf5156f90836f0887c73803" translate="yes" xml:space="preserve">
          <source>Vec::write_fmt</source>
          <target state="translated">Vec::write_fmt</target>
        </trans-unit>
        <trans-unit id="fb5d72587567483189e25ea2273df15eb40edb69" translate="yes" xml:space="preserve">
          <source>Vec::write_vectored</source>
          <target state="translated">Vec::write_vectored</target>
        </trans-unit>
        <trans-unit id="d8b188dca79494d553b4a25f8e7ba135fd059e06" translate="yes" xml:space="preserve">
          <source>VecDeque</source>
          <target state="translated">VecDeque</target>
        </trans-unit>
        <trans-unit id="daac388a0835b2f7f116ce4b930ba45f24e2d4f5" translate="yes" xml:space="preserve">
          <source>VecDeque::append</source>
          <target state="translated">VecDeque::append</target>
        </trans-unit>
        <trans-unit id="131f1606d9fb60120a570fc56345c3b4206cde68" translate="yes" xml:space="preserve">
          <source>VecDeque::as_mut_slices</source>
          <target state="translated">VecDeque::as_mut_slices</target>
        </trans-unit>
        <trans-unit id="e9e3cfebdd186278d399abad0a429053157088f8" translate="yes" xml:space="preserve">
          <source>VecDeque::as_slices</source>
          <target state="translated">VecDeque::as_slices</target>
        </trans-unit>
        <trans-unit id="0edc19e4ca1884e4aacf2a2a4380274826fb2740" translate="yes" xml:space="preserve">
          <source>VecDeque::back</source>
          <target state="translated">VecDeque::back</target>
        </trans-unit>
        <trans-unit id="ccf30a4382ae9328f9552afa5c5dfcfb35aef1b4" translate="yes" xml:space="preserve">
          <source>VecDeque::back_mut</source>
          <target state="translated">VecDeque::back_mut</target>
        </trans-unit>
        <trans-unit id="1d2610cb9f7282ea37e182a5f5c322a259c73e56" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow</source>
          <target state="translated">VecDeque::borrow</target>
        </trans-unit>
        <trans-unit id="c85001c25549712efa3bc4037af617403882f850" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow_mut</source>
          <target state="translated">VecDeque::borrow_mut</target>
        </trans-unit>
        <trans-unit id="50c2744064aa2c0045027447f96537e071e16754" translate="yes" xml:space="preserve">
          <source>VecDeque::capacity</source>
          <target state="translated">VecDeque::capacity</target>
        </trans-unit>
        <trans-unit id="d9ea40fef888b1aa5e6f0be9bc6eb9c5f0603d26" translate="yes" xml:space="preserve">
          <source>VecDeque::clamp</source>
          <target state="translated">VecDeque::clamp</target>
        </trans-unit>
        <trans-unit id="cef7bd89bf4a4eb9ba33004328fb058621269fe0" translate="yes" xml:space="preserve">
          <source>VecDeque::clear</source>
          <target state="translated">VecDeque::clear</target>
        </trans-unit>
        <trans-unit id="7e47848a7466bf6f810550e555917863d0558598" translate="yes" xml:space="preserve">
          <source>VecDeque::clone</source>
          <target state="translated">VecDeque::clone</target>
        </trans-unit>
        <trans-unit id="b0049440019ab3255550d699f8fa2c7e984241f3" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_from</source>
          <target state="translated">VecDeque::clone_from</target>
        </trans-unit>
        <trans-unit id="5a931f3dab8ce84e0c1498215e0a5ee5c312dbc4" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_into</source>
          <target state="translated">VecDeque::clone_into</target>
        </trans-unit>
        <trans-unit id="fd9dee766072ccb51f39babcce6cdd2ca35cde93" translate="yes" xml:space="preserve">
          <source>VecDeque::cmp</source>
          <target state="translated">VecDeque::cmp</target>
        </trans-unit>
        <trans-unit id="95d4c1d4f7170dca761e595f58227ed371676262" translate="yes" xml:space="preserve">
          <source>VecDeque::contains</source>
          <target state="translated">VecDeque::contains</target>
        </trans-unit>
        <trans-unit id="551608dce97aa0630c90774ad10f52c70cb6f3f6" translate="yes" xml:space="preserve">
          <source>VecDeque::default</source>
          <target state="translated">VecDeque::default</target>
        </trans-unit>
        <trans-unit id="6f86475df434e68c6dc113b2e5b2233f287a6033" translate="yes" xml:space="preserve">
          <source>VecDeque::drain</source>
          <target state="translated">VecDeque::drain</target>
        </trans-unit>
        <trans-unit id="4fddce3df4c9fe156f475165f3f4d5240f0afce4" translate="yes" xml:space="preserve">
          <source>VecDeque::drop</source>
          <target state="translated">VecDeque::drop</target>
        </trans-unit>
        <trans-unit id="0fcb62d0015e3066aec7a6e38e31f65772d5501d" translate="yes" xml:space="preserve">
          <source>VecDeque::eq</source>
          <target state="translated">VecDeque::eq</target>
        </trans-unit>
        <trans-unit id="075a7bfccff36cfa5ad77b2a00e19382093a8565" translate="yes" xml:space="preserve">
          <source>VecDeque::extend</source>
          <target state="translated">VecDeque::extend</target>
        </trans-unit>
        <trans-unit id="e054fa9bced4f47898e926baffbc0c60a08459c0" translate="yes" xml:space="preserve">
          <source>VecDeque::fmt</source>
          <target state="translated">VecDeque::fmt</target>
        </trans-unit>
        <trans-unit id="19d255ee2f123a37e942fb29c84911a9f64f017f" translate="yes" xml:space="preserve">
          <source>VecDeque::from</source>
          <target state="translated">VecDeque::from</target>
        </trans-unit>
        <trans-unit id="242a52440e095905c36864a3c86c19da0f44a3fd" translate="yes" xml:space="preserve">
          <source>VecDeque::from_iter</source>
          <target state="translated">VecDeque::from_iter</target>
        </trans-unit>
        <trans-unit id="29993bead69617ad206973adb616d88cb8d89425" translate="yes" xml:space="preserve">
          <source>VecDeque::front</source>
          <target state="translated">VecDeque::front</target>
        </trans-unit>
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="translated">向量还支持索引（通过&lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../ops/trait.indexmut&quot;&gt; &lt;code&gt;IndexMut&lt;/code&gt; &lt;/a&gt;特性）：</target>
        </trans-unit>
        <trans-unit id="10bd4ec04f26e95aeb5bf4a6ea31710e8b61d3aa" translate="yes" xml:space="preserve">
          <source>Vectors ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="translated">向量确保它们分配的字节数永远不会超过 &lt;code&gt;isize::MAX&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="translated">向量具有 &lt;code&gt;O(1)&lt;/code&gt; 索引，已摊销的 &lt;code&gt;O(1)&lt;/code&gt; 推送（到末尾）和 &lt;code&gt;O(1)&lt;/code&gt; pop（从末尾开始）。</target>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="translated">当你需要存储、访问和修改数据时,矢量、字符串和哈希图将在程序中提供大量必要的功能。下面是一些你现在应该具备解决的练习。</target>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">Verbatim UNC前缀由 &lt;code&gt;\?\UNC\&lt;/code&gt; 组成，后跟服务器的主机名和共享名。</target>
        </trans-unit>
        <trans-unit id="deeec6948b9b0c7f539defff599e2c9119f209e1" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">Verbatim UNC前缀由 &lt;code&gt;\\?\UNC\&lt;/code&gt; 组成，后跟服务器的主机名和共享名。</target>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="translated">逐字磁盘前缀，例如 &lt;code&gt;\?\C:\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc9892a19a8c55087305e1dc4f1a3f3fc14b7bbe" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\\?\C:&lt;/code&gt;.</source>
          <target state="translated">威宝盘前缀，如 &lt;code&gt;\\?\C:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="translated">逐字磁盘前缀由 &lt;code&gt;\?\&lt;/code&gt; 紧随其后的是驱动器号和 &lt;code&gt;:\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbcf31c83c72d79322932f64e5c3a662a2b82084" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">逐字磁盘前缀由 &lt;code&gt;\\?\&lt;/code&gt; 组成，后跟驱动器号和 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">逐字前缀使用Windows' &lt;em&gt;&lt;strong&gt;&amp;uuml;&lt;/strong&gt; niform &lt;strong&gt;&amp;ntilde;&lt;/strong&gt;阿明&lt;strong&gt;&amp;Ccedil;&lt;/strong&gt;年公约&lt;/em&gt;，例如， &lt;code&gt;\?\UNC\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d803e02d9c2966256665f4a37fc515a7b6b0270" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">逐字前缀使用Windows' &lt;em&gt;&lt;strong&gt;&amp;uuml;&lt;/strong&gt; niform &lt;strong&gt;&amp;ntilde;&lt;/strong&gt;阿明&lt;strong&gt;&amp;Ccedil;&lt;/strong&gt;年公约&lt;/em&gt;，例如， &lt;code&gt;\\?\UNC\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">逐字前缀，例如 &lt;code&gt;\?\cat_pics&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec64b930987590c33c18d3b5f5e6cd65655febca" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">逐字前缀，例如 &lt;code&gt;\\?\cat_pics&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">逐字前缀由 &lt;code&gt;\?\&lt;/code&gt; 组成，后跟给定的组件。</target>
        </trans-unit>
        <trans-unit id="6c060304c7d1622fca546ec1708bfccb55b07579" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">逐字前缀由 &lt;code&gt;\\?\&lt;/code&gt; 组成，紧随其后的是给定的组成部分。</target>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="translated">确认你没有拼错字段的名称或字段是否存在。例如:</target>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="translated">通过不可变的引用， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 允许您在程序的多个部分之间共享数据，以供只读。如果 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 允许您具有多个可变引用，则您可能违反了第4章中讨论的借用规则之一：到同一位置的多个可变借用可能导致数据争用和不一致。但是能够变异数据非常有用！在下一节中，我们将讨论内部可变性模式和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型，您可以将它们与 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 结合使用以处理这种不变性限制。</target>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="translated">将底层数据视为原始数据的一个子片。</target>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="translated">违反这些规定可能会导致分配器内部数据结构损坏等问题。</target>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">违反这些规则可能会导致问题，例如破坏分配器的内部数据结构。例如，它是&lt;strong&gt;不&lt;/strong&gt;安全建立一个 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 从一个指针到一个C &lt;code&gt;char&lt;/code&gt; 阵列和一个 &lt;code&gt;size_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f4c0ad7ae3e37221747e827bd3d99a0ac9c1516" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array with length &lt;code&gt;size_t&lt;/code&gt;. It's also not safe to build one from a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; and its length, because the allocator cares about the alignment, and these two types have different alignments. The buffer was allocated with alignment 2 (for &lt;code&gt;u16&lt;/code&gt;), but after turning it into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; it'll be deallocated with alignment 1.</source>
          <target state="translated">违反这些规则可能会导致诸如破坏分配器的内部数据结构之类的问题。例如，它是&lt;strong&gt;不&lt;/strong&gt;安全建立一个 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 从一个指针到一个C &lt;code&gt;char&lt;/code&gt; 阵列与长度 &lt;code&gt;size_t&lt;/code&gt; 。从 &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; 及其长度构建一个也不安全，因为分配器关心对齐方式，并且这两种类型具有不同的对齐方式。缓冲区分配了对齐方式2（用于 &lt;code&gt;u16&lt;/code&gt; ），但是在将其转换为 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 它将以对齐方式1释放。</target>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="translated">可见度和隐私</target>
        </trans-unit>
        <trans-unit id="acf880408a272d86a4dffcc14370fa0e4c75f47e" translate="yes" xml:space="preserve">
          <source>Visibility is restricted to a module which isn't an ancestor of the current item.</source>
          <target state="translated">可见性仅限于非当前项目的祖先的模块。</target>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">访问代表差异的值，即以升序访问 &lt;code&gt;self&lt;/code&gt; 而不是 &lt;code&gt;other&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">访问表示差，即值，是在价值观 &lt;code&gt;self&lt;/code&gt; 而不是在 &lt;code&gt;other&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">访问表示相交的值，即以升序形式同时存在于 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 中的值。</target>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">访问表示相交的值，即 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="translated">访问代表对称差异的值，即以升序出现在 &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 但不是两者中的值。</target>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="translated">访问表示对称差异的值，即， &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 但不是两者都存在的值。</target>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="translated">访问表示并集的值，即，以升序访问 &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 中的所有值，没有重复项。</target>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="translated">访问表示联合的值，即 &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 中的所有值，而不重复。</target>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="translated">可视化对 &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; 和 &lt;code&gt;weak_count&lt;/code&gt; 的更改</target>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="translated">挥发性操作的目的是作用于I/O内存,并保证不会被编译器跨越其他挥发性操作而省略或重新排序。</target>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="84367e806ed16f93cd67aba890fbaef52d16a0b0" translate="yes" xml:space="preserve">
          <source>WASI</source>
          <target state="translated">WASI</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="translated">等待所有线程完成使用 &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; 句柄</target>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="translated">等待超时完全结束。</target>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="translated">等待相关的线程结束。</target>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="translated">等待子函数完全退出,返回它退出时的状态。该函数至少被调用一次后,将继续保持相同的返回值。</target>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="translated">在这个条件变量上等待通知,在指定的持续时间后计时。</target>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="translated">在这个条件变量上等待通知,在指定的持续时间后计时。虚假的唤醒不会导致该函数返回。</target>
        </trans-unit>
        <trans-unit id="d6a3650e37b6043ab9616dfc37b87c0ed505a997" translate="yes" xml:space="preserve">
          <source>Wake</source>
          <target state="translated">Wake</target>
        </trans-unit>
        <trans-unit id="2b6971b8cb619ebe6c9f69185b57e5e06726f961" translate="yes" xml:space="preserve">
          <source>Wake this task without consuming the waker.</source>
          <target state="translated">在不消耗唤醒者的情况下,唤醒这个任务。</target>
        </trans-unit>
        <trans-unit id="05b7b65fb8cc05d38d07b2b178ad74919bff2a82" translate="yes" xml:space="preserve">
          <source>Wake this task.</source>
          <target state="translated">唤醒这个任务。</target>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">唤醒与此 &lt;code&gt;Waker&lt;/code&gt; 相关的任务，而不消耗 &lt;code&gt;Waker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">唤醒与此 &lt;code&gt;Waker&lt;/code&gt; 相关的任务。</target>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="translated">唤醒了这个condvar上所有被屏蔽的线程。</target>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="translated">在这个condvar上醒了一个被封锁的线程。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">警告： &lt;code&gt;hash_builder&lt;/code&gt; 通常是随机生成的，旨在允许HashMap抵御导致许多冲突和非常差的性能的攻击。使用此功能手动设置它可以暴露DoS攻击媒介。</target>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">警告： &lt;code&gt;hasher&lt;/code&gt; 器通常是随机生成的，旨在允许 &lt;code&gt;HashSet&lt;/code&gt; 抵抗导致许多冲突和非常差的性能的攻击。使用此功能手动设置它可以暴露DoS攻击媒介。</target>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="translated">警告：任意设置的配置选项可能与编译器设置的配置选项具有相同的值。例如，可以在编译为Windows目标时执行 &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; ，并同时设置 &lt;code&gt;unix&lt;/code&gt; 和 &lt;code&gt;windows&lt;/code&gt; 配置选项。实际上这样做是不明智的。</target>
        </trans-unit>
        <trans-unit id="953fdee2421f57eef922d79cc862ee6e22ccfc48" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; can only legally hold the discrimnant values, everything else is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. Therefore, using a field-less enum in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">警告：在C语言中的&lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;枚举&lt;/a&gt;与带有此表示形式的Rust的无字段 &lt;code&gt;enum&lt;/code&gt; 之间存在重大区别。C中的 &lt;code&gt;enum&lt;/code&gt; 主要是 &lt;code&gt;typedef&lt;/code&gt; 加上一些命名常量；换句话说， &lt;code&gt;enum&lt;/code&gt; 类型的对象可以保存任何整数值。例如，这通常用于 &lt;code&gt;C&lt;/code&gt; 中的位标志。相比之下，Rust的无&lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;字段枚举&lt;/a&gt;只能合法持有可区分的值，其他所有&lt;a href=&quot;behavior-considered-undefined&quot;&gt;行为&lt;/a&gt;都是未定义的行为。因此，在FFI中使用无字段枚举来建模C &lt;code&gt;enum&lt;/code&gt; 通常是错误的。</target>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">警告：有一间重要区别 &lt;code&gt;enum&lt;/code&gt; 在C语言和锈病的C-像这样表示枚举。C中的 &lt;code&gt;enum&lt;/code&gt; 主要是 &lt;code&gt;typedef&lt;/code&gt; 加上一些命名常量；换句话说， &lt;code&gt;enum&lt;/code&gt; 类型的对象可以保存任何整数值。例如，这通常用于 &lt;code&gt;C&lt;/code&gt; 中的位标志。相比之下，Rust的类C枚举只能合法保留判别式值，其他所有行为都是不确定的。因此，在FFI中使用类似C的枚举来建模C &lt;code&gt;enum&lt;/code&gt; 通常是错误的。</target>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">警告：这本书不完整。记录所有内容需要一段时间。有关本书未记录的内容，请参见&lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1f7ce6b6e1db1f6b36ab4dbe1ad4b6e4aa8f982" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">警告：这本书不完整。记录所有内容需要一段时间。有关本书未记录的内容，请参见&lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="translated">警告:这是一个警告的例子。</target>
        </trans-unit>
        <trans-unit id="0411a6eec332f44831efbc3f9708608318be0eda" translate="yes" xml:space="preserve">
          <source>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">警告：此伪代码使用的是朴素算法，为清楚起见，它会忽略溢出问题。要在实际代码中执行内存布局计算，请使用&lt;a href=&quot;../std/alloc/struct.layout&quot;&gt; &lt;code&gt;Layout&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="translated">警告：使用 &lt;code&gt;no_std&lt;/code&gt; 。并不妨碍标准库在被链接它仍然是有效投入 &lt;code&gt;extern crate std;&lt;/code&gt; 到板条箱中，依赖项也可以将其链接进来。</target>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="translated">在语言中表现出不健全的行为或可能混淆语言特征的相互作用的警告是在一个特殊的警告框中。</target>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="translated">终止是否成功?信号终止不算成功,成功定义为零退出状态。</target>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="translated">变量和数据的交互方式:克隆。</target>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="translated">变量和数据的交互方式:移动</target>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="translated">我们添加一条 &lt;code&gt;use minigrep::Config&lt;/code&gt; 行，以将库箱的 &lt;code&gt;Config&lt;/code&gt; 类型带入二进制箱的作用域，并在 &lt;code&gt;run&lt;/code&gt; 函数前加上箱名。现在，所有功能都应该已连接并且可以正常工作。 &lt;code&gt;cargo run&lt;/code&gt; 运行该程序，并确保一切正常。</target>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="translated">我们为 &lt;code&gt;content&lt;/code&gt; 方法添加了一个默认实现，该方法返回一个空字符串切片。这意味着我们不需要在 &lt;code&gt;Draft&lt;/code&gt; 和 &lt;code&gt;PendingReview&lt;/code&gt; 结构上实现 &lt;code&gt;content&lt;/code&gt; 。该 &lt;code&gt;Published&lt;/code&gt; 结构将覆盖 &lt;code&gt;content&lt;/code&gt; 方法和返回值 &lt;code&gt;post.content&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="translated">我们添加 &lt;code&gt;approve&lt;/code&gt; 法的 &lt;code&gt;State&lt;/code&gt; 特质，并添加一个新的结构，实现 &lt;code&gt;State&lt;/code&gt; 的 &lt;code&gt;Published&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="translated">我们将类型添加到 &lt;code&gt;Fn&lt;/code&gt; 特征绑定以表示参数的类型，并返回闭包必须匹配此特征绑定的值。在这种情况下，闭包的参数类型为 &lt;code&gt;u32&lt;/code&gt; 并返回 &lt;code&gt;u32&lt;/code&gt; ，因此我们指定的特征范围为 &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="translated">我们还需要一种方法来存储包含查询字符串的行。为此，我们可以在 &lt;code&gt;for&lt;/code&gt; 循环之前创建一个可变的向量，然后调用 &lt;code&gt;push&lt;/code&gt; 方法在向量中存储 &lt;code&gt;line&lt;/code&gt; 。在 &lt;code&gt;for&lt;/code&gt; 循环之后，我们返回向量，如清单12-19所示。</target>
        </trans-unit>
        <trans-unit id="57c6613eb86c997fd0269e2246aca212d29bb5d3" translate="yes" xml:space="preserve">
          <source>We also needed to specify that the string slice error type can now only have the &lt;code&gt;'static&lt;/code&gt; lifetime. Because we&amp;rsquo;re only ever returning string literals, this was true before. However, when we had a reference in the parameters, there was the possibility that the reference in the return type could have had the same lifetime as the reference in the parameters. The rules that we discussed in the &lt;a href=&quot;ch10-03-lifetime-syntax#lifetime-elision&quot;&gt;&amp;ldquo;Lifetime Elision&amp;rdquo;&lt;/a&gt; section of Chapter 10 applied, and we weren&amp;rsquo;t required to annotate the lifetime of &lt;code&gt;&amp;amp;str&lt;/code&gt;. With the change to &lt;code&gt;args&lt;/code&gt;, the lifetime elision rules no longer apply, and we must specify the &lt;code&gt;'static&lt;/code&gt; lifetime.</source>
          <target state="translated">我们还需要指定字符串切片错误类型现在只能具有 &lt;code&gt;'static&lt;/code&gt; 生存期&amp;rdquo;。因为我们只返回字符串文字，所以以前是这样。但是，当我们在参数中有引用时，返回类型中的引用可能具有与参数中的引用相同的生存期。我们在第10章的&lt;a href=&quot;ch10-03-lifetime-syntax#lifetime-elision&quot;&gt;&amp;ldquo;生存期淘汰&amp;rdquo;&lt;/a&gt;部分中讨论的规则适用，并且不需要注释 &lt;code&gt;&amp;amp;str&lt;/code&gt; 的生存期。随着 &lt;code&gt;args&lt;/code&gt; 的更改，生存期省略规则不再适用，我们必须指定 &lt;code&gt;'static&lt;/code&gt; 生存期&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="translated">我们无法运行此测试并看到它失败，因为该测试甚至无法编译： &lt;code&gt;search&lt;/code&gt; 功能尚不存在！因此，现在我们通过添加始终返回一个空向量的 &lt;code&gt;search&lt;/code&gt; 函数的定义，来添加足够的代码以使测试得以编译并运行，如清单12-16所示。然后测试应该编译并失败，因为空向量与包含 &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt; 行的向量不匹配。</target>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="translated">将变量 &lt;code&gt;field_name&lt;/code&gt; 和 &lt;code&gt;field_value&lt;/code&gt; 通过调用 &lt;code&gt;insert&lt;/code&gt; 移入哈希映射后，我们将无法使用它们。</target>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="translated">调用 &lt;code&gt;sum&lt;/code&gt; 之后，不允许使用 &lt;code&gt;v1_iter&lt;/code&gt; ，因为 &lt;code&gt;sum&lt;/code&gt; 获得了我们调用它的迭代器的所有权。</target>
        </trans-unit>
        <trans-unit id="03b218b584e4a8c7465d02aa1590edcd7370cd71" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">我们对 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;execute&lt;/code&gt; 的参数不做任何事情。让我们以所需的行为实现这些函数的主体。首先，让我们考虑一下 &lt;code&gt;new&lt;/code&gt; 。之前我们为 &lt;code&gt;size&lt;/code&gt; 参数选择了一个无符号类型，因为线程数为负的池没有意义。但是，具有零线程的池也没有意义，但是零是一个完全有效的 &lt;code&gt;usize&lt;/code&gt; 。在返回 &lt;code&gt;ThreadPool&lt;/code&gt; 实例之前，我们将添加代码以检查 &lt;code&gt;size&lt;/code&gt; 是否大于零，并通过 &lt;code&gt;assert!&lt;/code&gt; 使程序惊慌（如果它收到零）！宏，如清单20-13所示。</target>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="translated">我们直接将数据附加到enum的每个变体上,所以不需要额外的结构。</target>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">我们将 &lt;code&gt;guess&lt;/code&gt; 绑定到表达式 &lt;code&gt;guess.trim().parse()&lt;/code&gt; 。表达式中的 &lt;code&gt;guess&lt;/code&gt; 是指原始 &lt;code&gt;guess&lt;/code&gt; ，它是其中包含输入的 &lt;code&gt;String&lt;/code&gt; 。在 &lt;code&gt;String&lt;/code&gt; 实例上的 &lt;code&gt;trim&lt;/code&gt; 方法将消除开头和结尾的任何空格。尽管 &lt;code&gt;u32&lt;/code&gt; 只能包含数字字符，但用户必须按Enter才能满足 &lt;code&gt;read_line&lt;/code&gt; 的要求。当用户按下Enter键时，会将换行符添加到字符串中。例如，如果用户键入5并按Enter，则 &lt;code&gt;guess&lt;/code&gt; 看起来像这样： &lt;code&gt;5\n&lt;/code&gt; 。该 &lt;code&gt;\n&lt;/code&gt; 代表&amp;ldquo;换行符&amp;rdquo;，即按Enter的结果。该 &lt;code&gt;trim&lt;/code&gt; 方法消除 &lt;code&gt;\n&lt;/code&gt; ，导致只是 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="translated">我们将 &lt;code&gt;std::io::prelude&lt;/code&gt; 带入范围，以访问某些使我们可以从流中读取和写入流的特征。在 &lt;code&gt;main&lt;/code&gt; 函数的 &lt;code&gt;for&lt;/code&gt; 循环中，我们现在不调用新的 &lt;code&gt;handle_connection&lt;/code&gt; 函数，而是将 &lt;code&gt;stream&lt;/code&gt; 递给它，而不是显示一条消息说明已建立连接。</target>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="translated">我们称将引用作为函数参数&lt;em&gt;借用&lt;/em&gt;。与现实生活中一样，如果某人拥有某物，则可以向他们借用。完成后，您必须将其归还。</target>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="translated">我们在 &lt;code&gt;Option&lt;/code&gt; 上调用 &lt;code&gt;as_ref&lt;/code&gt; 方法，因为我们希望引用 &lt;code&gt;Option&lt;/code&gt; 内的值而不是值的所有权。因为 &lt;code&gt;state&lt;/code&gt; 是 &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; ，所以当我们调用 &lt;code&gt;as_ref&lt;/code&gt; 时，将返回 &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; 。如果不调用 &lt;code&gt;as_ref&lt;/code&gt; ，则会收到错误消息，因为我们无法将 &lt;code&gt;state&lt;/code&gt; 从函数参数的借用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 中移出。</target>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="translated">对于任何实现了另一个特征的类型，我们也可以有条件地实现一个特征。满足特征界限的任何类型的特征&lt;em&gt;实现&lt;/em&gt;都称为&lt;em&gt;一揽子实现，&lt;/em&gt;并在Rust标准库中广泛使用。例如，标准库在实现 &lt;code&gt;Display&lt;/code&gt; trait的任何类型上实现 &lt;code&gt;ToString&lt;/code&gt; trait。标准库中的 &lt;code&gt;impl&lt;/code&gt; 块看起来类似于以下代码：</target>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="translated">我们还可以通过在路径的开头使用 &lt;code&gt;super&lt;/code&gt; 来构造从父模块开始的相对路径。这就像使用 &lt;code&gt;..&lt;/code&gt; 语法启动文件系统路径。我们为什么要这样做？</target>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="translated">我们还可以使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 语法将结构定义为在一个或多个字段中使用通用类型参数。清单10-6显示了如何定义 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 结构以容纳任何类型的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 坐标值。</target>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="translated">我们也可以使用字面值作为结构模式的一部分进行重构,而不是为所有字段创建变量。这样做可以让我们测试一些字段的特定值,同时创建变量来反构其他字段。</target>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="translated">我们还可以迭代对可变向量中每个元素的可变引用，以对所有元素进行更改。清单8-9中的 &lt;code&gt;for&lt;/code&gt; 循环将向每个元素添加 &lt;code&gt;50&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="translated">我们还可以通过使用 &lt;code&gt;-p&lt;/code&gt; 标志并指定我们要测试的板条箱的名称，从顶级目录中为工作空间中的特定板条箱运行测试：</target>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">我们还可以指定多个特征绑定。假设我们想 &lt;code&gt;notify&lt;/code&gt; 在使用显示器上格式化 &lt;code&gt;item&lt;/code&gt; 以及在 &lt;code&gt;summarize&lt;/code&gt; 方法：我们指定的 &lt;code&gt;notify&lt;/code&gt; 定义， &lt;code&gt;item&lt;/code&gt; 必须实现 &lt;code&gt;Display&lt;/code&gt; 和 &lt;code&gt;Summary&lt;/code&gt; 。我们可以使用 &lt;code&gt;+&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="translated">我们还可以在I / O项目的 &lt;code&gt;search&lt;/code&gt; 功能中利用迭代器，如清单12-19所示，在清单13-28中复制了迭代器：</target>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="translated">我们还可以在另一个模式内使用 &lt;code&gt;_&lt;/code&gt; 来忽略值的一部分，例如，当我们只想测试值的一部分而对要运行的代码中的其他部分没有用处时。清单18-18显示了负责管理设置值的代码。业务要求是不允许用户覆盖设置的现有自定义设置，但可以取消设置并给它提供值（如果当前未设置）。</target>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="translated">我们还可以使用 &lt;code&gt;extern&lt;/code&gt; 创建一个接口，该接口允许其他语言调用Rust函数。代替 &lt;code&gt;extern&lt;/code&gt; 块，我们添加了 &lt;code&gt;extern&lt;/code&gt; 关键字，并指定要在 &lt;code&gt;fn&lt;/code&gt; 关键字之前使用的ABI 。我们还需要添加 &lt;code&gt;#[no_mangle]&lt;/code&gt; 批注以告知Rust编译器不要破坏该函数的名称。&lt;em&gt;g&lt;/em&gt;就是当编译器更改名称时，我们为函数指定了另一个名称，该名称包含更多信息供编译过程的其他部分使用，但人类可读性较低。每个编程语言编译器对名称的处理都略有不同，因此，要使Rust函数能被其他语言命名，我们必须禁用Rust编译器的名称处理。</target>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="translated">我们还可以使用 &lt;code&gt;pub&lt;/code&gt; 将结构和枚举指定为公共，但还有一些其他细节。如果在结构定义之前使用 &lt;code&gt;pub&lt;/code&gt; ，则将结构公开，但结构的字段仍将是私有的。我们可以根据具体情况公开或不公开每个字段。在清单7-9，我们定义了一个公共 &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 结构与公共 &lt;code&gt;toast&lt;/code&gt; 领域，但私人 &lt;code&gt;seasonal_fruit&lt;/code&gt; 领域。这样可以在一家餐馆中为案例建模，顾客可以选择随餐搭配的面包类型，但是厨师会根据季节和库存来决定随餐搭配哪种水果。可用的水果变化很快，因此客户无法选择水果，甚至看不到会得到哪种水果。</target>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="translated">我们也可以像在函数参数列表中一样,在闭包参数列表中使用模式,因为闭包类似于函数,在第13章中已经讨论过。</target>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="translated">我们还可以使用模式来解构结构，枚举，元组和引用，以使用这些值的不同部分。让我们浏览每个值。</target>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="translated">我们还可以在返回位置使用 &lt;code&gt;impl Trait&lt;/code&gt; 语法返回实现特征的某种类型的值，如下所示：</target>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="translated">我们也可以用函数 &lt;code&gt;String::from&lt;/code&gt; 创建一个 &lt;code&gt;String&lt;/code&gt; 从一个字符串文字。清单8-13中的代码与清单8-12中使用 &lt;code&gt;to_string&lt;/code&gt; 的代码等效。</target>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="translated">我们也可以在一个模式中的多个地方使用下划线来忽略特定的值。清单18-19显示了一个忽略五个项目的元组中的第二个和第四个值的例子。</target>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">我们可以使用 &lt;code&gt;cargo build&lt;/code&gt; 或 &lt;code&gt;cargo check&lt;/code&gt; 来建造项目。</target>
        </trans-unit>
        <trans-unit id="838e973f1067e2cb1c1db7ba741330fcbc0ac60a" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt;.</source>
          <target state="translated">我们可以用 &lt;code&gt;cargo build&lt;/code&gt; 一个项目。</target>
        </trans-unit>
        <trans-unit id="ce64501de0b20285b589ca7f67901cf5515ef19d" translate="yes" xml:space="preserve">
          <source>We can build a project without producing a binary to check for errors using &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">我们可以在不生成二进制文件的情况下构建项目，而无需使用 &lt;code&gt;cargo check&lt;/code&gt; 来检查错误。</target>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="translated">我们可以使用 &lt;code&gt;cargo run&lt;/code&gt; 一步建立并运行一个项目。</target>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="translated">我们可以通过输入其名称后跟一组括号来调用已定义的任何函数。因为 &lt;code&gt;another_function&lt;/code&gt; 是在程序中定义的，所以可以从 &lt;code&gt;main&lt;/code&gt; 函数内部调用它。注意，我们在源代码中的 &lt;code&gt;main&lt;/code&gt; 函数&lt;em&gt;之后&lt;/em&gt;定义了 &lt;code&gt;another_function&lt;/code&gt; ；我们也可以定义它。Rust不在乎您在何处定义函数，只需在某个地方定义它们即可。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="translated">我们可以使用字符串切片作为参数来调用 &lt;code&gt;hello&lt;/code&gt; 函数，例如 &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; 例如。使用Deref强制可以使用对 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 类型的值的引用来调用 &lt;code&gt;hello&lt;/code&gt; ，如清单15-12所示：</target>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="translated">我们可以直接在迭代器上调用 &lt;code&gt;next&lt;/code&gt; 方法。清单13-15展示了从向量创建的迭代器上，对 &lt;code&gt;next&lt;/code&gt; 的重复调用所返回的值。</target>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="translated">我们可以将清单15-2 中的 &lt;code&gt;List&lt;/code&gt; 枚举的定义和清单15-3 中的 &lt;code&gt;List&lt;/code&gt; 的用法更改为清单15-5中的代码，这些代码将进行编译：</target>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="translated">我们可以将 &lt;code&gt;str&lt;/code&gt; 与各种指针结合使用：例如 &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt; 。实际上，您之前已经看到过这种情况，但是具有不同的动态大小类型：特征。每个特征都是动态大小类型，我们可以使用特征名称来引用。在第17章&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;使用允许使用不同类型值的特性对象&amp;rdquo;&lt;/a&gt;一节中，我们提到了要将特性用作特性对象，必须将它们放在指针后面，例如 &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; 或 &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; （ &lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; 也可以）。</target>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="translated">我们可以像这样创建 &lt;code&gt;IpAddrKind&lt;/code&gt; 的两个变体的每一个的实例：</target>
        </trans-unit>
        <trans-unit id="6778f0bff382e98f9e7494c1dbfeeb8d0d54aa88" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte (counting from 1) of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">通过指定 &lt;code&gt;[starting_index..ending_index]&lt;/code&gt; ，我们可以使用方括号内的范围来创建切片，其中， &lt;code&gt;starting_index&lt;/code&gt; 是切片中的第一个位置，而 &lt;code&gt;ending_index&lt;/code&gt; 比切片中的最后一个位置大。在内部，切片数据结构存储切片的起始位置和长度，其对应于 &lt;code&gt;ending_index&lt;/code&gt; 减去 &lt;code&gt;starting_index&lt;/code&gt; 。因此，在 &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; ， &lt;code&gt;world&lt;/code&gt; 将是一个切片，其中包含指向 &lt;code&gt;s&lt;/code&gt; 的第7个字节（从1开始）的指针，其长度值为5。</target>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">通过指定 &lt;code&gt;[starting_index..ending_index]&lt;/code&gt; ，我们可以使用方括号内的范围来创建切片，其中， &lt;code&gt;starting_index&lt;/code&gt; 是切片中的第一个位置，而 &lt;code&gt;ending_index&lt;/code&gt; 比切片中的最后一个位置大。在内部，切片数据结构存储切片的起始位置和长度，其对应于 &lt;code&gt;ending_index&lt;/code&gt; 减去 &lt;code&gt;starting_index&lt;/code&gt; 。因此，在 &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; ， &lt;code&gt;world&lt;/code&gt; 将是一个切片，其中包含指向 &lt;code&gt;s&lt;/code&gt; 的第7个字节的指针，其长度值为5。</target>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="translated">我们可以通过定义 &lt;code&gt;IpAddrKind&lt;/code&gt; 枚举并列出IP地址可能的种类 &lt;code&gt;V4&lt;/code&gt; 和 &lt;code&gt;V6&lt;/code&gt; 来在代码中表达此概念。这些被称为枚举的&lt;em&gt;变体&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="76dc799b358f8c432443282c326218cb637140a7" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are the variants of the enum:</source>
          <target state="translated">我们可以通过定义 &lt;code&gt;IpAddrKind&lt;/code&gt; 枚举并列出IP地址可能的类型 &lt;code&gt;V4&lt;/code&gt; 和 &lt;code&gt;V6&lt;/code&gt; 来在代码中表达此概念。这些是枚举的变体：</target>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="translated">我们只需对清单4-6中的代码稍作调整,就可以解决这个错误。</target>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="translated">通过将 &lt;code&gt;thread::spawn&lt;/code&gt; 的返回值保存在变量中，我们可以解决生成的线程无法运行或无法完全运行的问题。 &lt;code&gt;thread::spawn&lt;/code&gt; 的返回类型为 &lt;code&gt;JoinHandle&lt;/code&gt; 。一个 &lt;code&gt;JoinHandle&lt;/code&gt; 是一家拥有值，当我们调用 &lt;code&gt;join&lt;/code&gt; 方法就可以了，就等待它的线程结束。清单16-2显示了如何使用清单16-1中创建的线程的 &lt;code&gt;JoinHandle&lt;/code&gt; 并调用 &lt;code&gt;join&lt;/code&gt; 来确保生成的线程在 &lt;code&gt;main&lt;/code&gt; 出口之前完成：</target>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="translated">我们可以通过将其值提供给 &lt;code&gt;get&lt;/code&gt; 方法来从哈希图中获取值，如清单8-23所示。</target>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="translated">我们可以使用 &lt;code&gt;push_str&lt;/code&gt; 方法添加字符串切片来增长 &lt;code&gt;String&lt;/code&gt; ，如清单8-15所示。</target>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="translated">我们可以在结构和枚举上实现方法（就像我们在第5章中所做的那样），并且也可以在它们的定义中使用泛型类型。清单10-9显示了我们在清单10-6中定义的 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 结构，并在其上实现了名为 &lt;code&gt;x&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="translated">我们可以在 &lt;code&gt;if let&lt;/code&gt; 中包含 &lt;code&gt;else&lt;/code&gt; 。的代码，与去块 &lt;code&gt;else&lt;/code&gt; 相同的代码块，将与去 &lt;code&gt;_&lt;/code&gt; 的情况下 &lt;code&gt;match&lt;/code&gt; 表达式相当于 &lt;code&gt;if let&lt;/code&gt; 与 &lt;code&gt;else&lt;/code&gt; 。回顾清单6-4中的 &lt;code&gt;Coin&lt;/code&gt; 枚举定义，其中 &lt;code&gt;Quarter&lt;/code&gt; 变体也具有 &lt;code&gt;UsState&lt;/code&gt; 值。如果我们想计算我们看到的所有非四分之一硬币，同时还宣布四分之一硬币的状态，则可以使用以下 &lt;code&gt;match&lt;/code&gt; 表达式来实现：</target>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="translated">相反，我们可以返回一个 &lt;code&gt;Result&lt;/code&gt; 值，该值将在成功的情况下包含一个 &lt;code&gt;Config&lt;/code&gt; 实例，并在错误的情况下描述问题。当 &lt;code&gt;Config::new&lt;/code&gt; 与 &lt;code&gt;main&lt;/code&gt; 通讯时，我们可以使用 &lt;code&gt;Result&lt;/code&gt; 类型来表明存在问题。然后，我们可以更改 &lt;code&gt;main&lt;/code&gt; ,以便为我们的用户将 &lt;code&gt;Err&lt;/code&gt; 变体转换为更实际的错误，而无需包含有关 &lt;code&gt;thread 'main'&lt;/code&gt; 和 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 的周围文本，从而避免出现 &lt;code&gt;panic!&lt;/code&gt; 原因。</target>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">我们可以像使用向量一样，使用 &lt;code&gt;for&lt;/code&gt; 循环对哈希映射中的每个键/值对进行迭代：</target>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="translated">我们可以用更复杂的方式混合、匹配和嵌套解构模式。下面的例子显示了一个复杂的重构,我们在一个元组中嵌套结构和元组,并将所有的基元值重构出来。</target>
        </trans-unit>
        <trans-unit id="e58c028003f62365f91c55798dbc7dd101453a7b" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate. We will get one warning because we aren&amp;rsquo;t referring to the &lt;code&gt;rand&lt;/code&gt; we brought into scope:</source>
          <target state="translated">我们现在可以添加 &lt;code&gt;use rand;&lt;/code&gt; 到&lt;em&gt;add-one / src / lib.rs&lt;/em&gt;文件中，然后通过在&lt;em&gt;add&lt;/em&gt;目录中运行 &lt;code&gt;cargo build&lt;/code&gt; 来构建整个工作区将引入并编译 &lt;code&gt;rand&lt;/code&gt; crate。我们将收到一个警告，因为我们没有提到我们引入范围的 &lt;code&gt;rand&lt;/code&gt; ：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="translated">我们现在可以添加 &lt;code&gt;use rand;&lt;/code&gt; 到&lt;em&gt;add-one / src / lib.rs&lt;/em&gt;文件，并通过在&lt;em&gt;add&lt;/em&gt;目录中运行 &lt;code&gt;cargo build&lt;/code&gt; 来构建整个工作区，将引入并编译 &lt;code&gt;rand&lt;/code&gt; crate：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="translated">我们可以将任何测试函数的名称传递给 &lt;code&gt;cargo test&lt;/code&gt; 以仅运行该测试：</target>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="translated">我们可能会猜到它在做什么：&amp;ldquo;将值 &lt;code&gt;5&lt;/code&gt; 绑定到 &lt;code&gt;x&lt;/code&gt; ；然后在 &lt;code&gt;x&lt;/code&gt; 中复制值并将其绑定到 &lt;code&gt;y&lt;/code&gt; 。&amp;rdquo;现在，我们有两个变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，它们都等于 &lt;code&gt;5&lt;/code&gt; 。确实发生了这种情况，因为整数是具有已知固定大小的简单值，并且这两个 &lt;code&gt;5&lt;/code&gt; 值被压入堆栈。</target>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="translated">通过将数据直接放入每个枚举变量中，我们可以仅使用枚举而不是结构内部的枚举以更简洁的方式表示相同的概念。 &lt;code&gt;IpAddr&lt;/code&gt; 枚举的新定义表明 &lt;code&gt;V4&lt;/code&gt; 和 &lt;code&gt;V6&lt;/code&gt; 变体都将具有关联的 &lt;code&gt;String&lt;/code&gt; 值：</target>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="translated">我们可以重写清单15-6中的代码，以使用 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 代替引用。解除引用运算符的工作方式如清单15-7所示：</target>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="translated">我们可以看到， &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在 &lt;code&gt;a&lt;/code&gt; 具有1的初始参考计数; 然后每次调用 &lt;code&gt;clone&lt;/code&gt; 时，计数都会增加1。当 &lt;code&gt;c&lt;/code&gt; 超出范围时，计数将减少1。我们不必像调用 &lt;code&gt;Rc::clone&lt;/code&gt; 那样调用函数来减少引用计数。克隆以增加引用计数：当 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值超出范围时， &lt;code&gt;Drop&lt;/code&gt; trait 的实现会自动减少引用计数。</target>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="translated">我们可以在测试输出中看到我们实际得到的值,这将帮助我们调试发生了什么,而不是我们期望发生的事情。</target>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="translated">我们可以指定测试名称的一部分，然后运行任何名称与该值匹配的测试。例如，由于我们的两个测试名称包含 &lt;code&gt;add&lt;/code&gt; ，我们可以通过运行 &lt;code&gt;cargo test add&lt;/code&gt; 来运行这两个：</target>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="translated">我们仍然可以做得更好！由于这些都是字符串，因此我们可以使用 &lt;code&gt;From::from&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="translated">通过将测试函数的名称指定为 &lt;code&gt;cargo test&lt;/code&gt; 的参数，我们仍然可以运行特定的集成测试函数。要在特定的集成测试文件中运行所有测试，请使用 &lt;code&gt;cargo test&lt;/code&gt; 的 &lt;code&gt;--test&lt;/code&gt; 参数后跟文件名：</target>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="translated">我们可以采取另一个小步骤来进一步改进 &lt;code&gt;parse_config&lt;/code&gt; 函数。目前，我们正在返回一个元组，但是随后我们立即将该元组再次分解为各个部分。这表明也许我们还没有正确的抽象。</target>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="translated">我们可以使用 &lt;code&gt;LineWriter&lt;/code&gt; 一次写入一行，从而大大减少了实际写入文件的次数。</target>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">我们可以在路径的任何级别上使用嵌套路径，这在组合两个共享一个子路径的 &lt;code&gt;use&lt;/code&gt; 语句时很有用。例如，清单7-19显示了两个 &lt;code&gt;use&lt;/code&gt; 语句：一个将 &lt;code&gt;std::io&lt;/code&gt; 纳入范围，另一个将 &lt;code&gt;std::io::Write&lt;/code&gt; 纳入范围。</target>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="translated">我们可以使用泛型为诸如函数签名或结构之类的项创建定义，然后可以将其用于许多不同的具体数据类型。首先让我们看看如何使用泛型定义函数，结构，枚举和方法。然后，我们将讨论泛型如何影响代码性能。</target>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="translated">我们可以编写测试来断言例如，当我们将 &lt;code&gt;3&lt;/code&gt; 传递给 &lt;code&gt;add_two&lt;/code&gt; 函数时，返回的值为 &lt;code&gt;5&lt;/code&gt; 。只要对代码进行更改，就可以运行这些测试，以确保任何现有的正确行为都没有更改。</target>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="translated">我们可以使用迭代器适配器方法以更简洁的方式编写此代码。这样做还使我们避免了可变的中间 &lt;code&gt;results&lt;/code&gt; 向量。函数式编程风格倾向于将可变状态的数量减到最少，以使代码更清晰。删除可变状态可以使将来的增强功能使搜索并行进行，因为我们不必管理对 &lt;code&gt;results&lt;/code&gt; 向量的并发访问。清单13-29显示了此更改：</target>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="translated">当值超出范围时，我们不能禁用 &lt;code&gt;drop&lt;/code&gt; 的自动插入，也不能显式调用 &lt;code&gt;drop&lt;/code&gt; 方法。因此，如果需要强制早期清除某个值，则可以使用 &lt;code&gt;std::mem::drop&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="translated">我们不能对函数做同样的事情。如果我们尝试下面的示例，我们的代码将无法编译：</target>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">我们不能仅使用安全的Rust来实现此功能。尝试可能类似于清单19-5，但无法编译。为简单起见，我们将实现 &lt;code&gt;split_at_mut&lt;/code&gt; 的功能，而不是一种方法，只对切片 &lt;code&gt;i32&lt;/code&gt; 值，而不是一个泛型类型 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="translated">我们无法修改 &lt;code&gt;MockMessenger&lt;/code&gt; 来跟踪消息，因为 &lt;code&gt;send&lt;/code&gt; 方法对 &lt;code&gt;self&lt;/code&gt; 进行了不可变的引用。我们也不能接受错误文本中的建议来改用 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，因为 &lt;code&gt;send&lt;/code&gt; 的签名与 &lt;code&gt;Messenger&lt;/code&gt; trait定义中的签名不匹配（可以随意尝试并查看收到的错误消息）。</target>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="translated">我们不能以这种方式指定多个测试的名称。仅使用提供给 &lt;code&gt;cargo test&lt;/code&gt; 的第一个值。但是有一种方法可以运行多个测试。</target>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">我们无法创建 &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;Foo&lt;/code&gt; 类型的对象，因为在这种情况下，将不会调整 &lt;code&gt;Self&lt;/code&gt; 的 &lt;code&gt;Sized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">我们选择 &lt;code&gt;usize&lt;/code&gt; 作为 &lt;code&gt;size&lt;/code&gt; 参数的类型，因为我们知道负数的线程没有任何意义。我们也知道我们将使用这4作为线程集合中的元素数量，这就是 &lt;code&gt;usize&lt;/code&gt; 类型的用途，如第3章的&lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;整数类型&amp;rdquo;&lt;/a&gt;部分所述。</target>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="translated">我们克隆 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 在 &lt;code&gt;leaf&lt;/code&gt; 和存储在 &lt;code&gt;branch&lt;/code&gt; ，这意味着 &lt;code&gt;Node&lt;/code&gt; 在 &lt;code&gt;leaf&lt;/code&gt; 现在有两个主人： &lt;code&gt;leaf&lt;/code&gt; 和 &lt;code&gt;branch&lt;/code&gt; 。我们可以从获得 &lt;code&gt;branch&lt;/code&gt; 到 &lt;code&gt;leaf&lt;/code&gt; 通过 &lt;code&gt;branch.children&lt;/code&gt; ，但有没有办法让从 &lt;code&gt;leaf&lt;/code&gt; 到 &lt;code&gt;branch&lt;/code&gt; 。原因是 &lt;code&gt;leaf&lt;/code&gt; 没有对 &lt;code&gt;branch&lt;/code&gt; 引用，也不知道它们之间的关系。我们希望 &lt;code&gt;leaf&lt;/code&gt; 知道 &lt;code&gt;branch&lt;/code&gt; 是其父级。接下来，我们将做。</target>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="translated">我们也可以使用 &lt;code&gt;vec!&lt;/code&gt; 宏以生成两个整数的向量或五个字符串切片的向量。我们将无法使用函数来执行相同的操作，因为我们不预先知道值的数量或类型。</target>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="translated">我们可以改为更改 &lt;code&gt;Cons&lt;/code&gt; 的定义以保留引用，但是随后我们必须指定生存期参数。通过指定生命周期参数，我们将指定列表中的每个元素的寿命至少与整个列表一样长。借位检查器不会让我们编译 &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; 例如，由于暂时 &lt;code&gt;Nil&lt;/code&gt; 值将之前被丢弃 &lt;code&gt;a&lt;/code&gt; 可能需要对它的引用。</target>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="translated">我们可以在这里做更多的事情!如果你想继续加强这个项目,这里有一些想法:如果你想继续加强这个项目,这里有一些想法。</target>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="translated">我们可以调用 &lt;code&gt;a.clone()&lt;/code&gt; 而不是 &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt; ，但是Rust的约定是在这种情况下使用 &lt;code&gt;Rc::clone&lt;/code&gt; 。实施 &lt;code&gt;Rc::clone&lt;/code&gt; 并不能使所有的深层副本最喜欢的类型的实现数据 &lt;code&gt;clone&lt;/code&gt; 做。对 &lt;code&gt;Rc::clone&lt;/code&gt; 的调用只会增加引用计数，而不会花费很多时间。数据的深拷贝可能会花费很多时间。通过使用 &lt;code&gt;Rc::clone&lt;/code&gt; 进行引用计数，我们可以在视觉上区分深复制类型的克隆和增加引用计数的克隆类型。在代码中查找性能问题时，我们只需要考虑深拷贝克隆，就可以忽略对 &lt;code&gt;Rc::clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="translated">我们可以通过许多不同的方法来管理 &lt;code&gt;String&lt;/code&gt; 数据，但是最简单的方法（尽管效率低下）是在值上调用 &lt;code&gt;clone&lt;/code&gt; 方法。这将为 &lt;code&gt;Config&lt;/code&gt; 实例拥有一个完整的数据副本，这比存储对字符串数据的引用要花更多的时间和内存。但是，克隆数据也使我们的代码非常简单，因为我们不必管理引用的生存期。在这种情况下，为了获得简单性而放弃一些性能是一个值得权衡的选择。</target>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="translated">我们可以通过多种方式重组锻炼计划。首先，我们将尝试将对 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 函数的重复调用提取到一个变量中，如清单13-4所示。</target>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">例如，我们可以仅在 &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; 实例上实现方法，而不能在具有任何泛型类型的 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 实例上实现方法。在清单10-10中，我们使用具体类型 &lt;code&gt;f32&lt;/code&gt; ，这意味着我们在 &lt;code&gt;impl&lt;/code&gt; 之后不声明任何类型。</target>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="translated">本章涵盖了很多内容！既然您已经了解了通用类型参数，特征和特征边界以及通用生命周期参数，那么您就可以编写无需重复的代码了，这些代码在许多不同的情况下都有效。通用类型参数使您可以将代码应用于不同类型。特质和特征界限确保即使类型是通用的，它们也将具有代码所需的行为。您学习了如何使用生命周期注释，以确保此灵活的代码不会有任何悬而未决的引用。而且所有这些分析都是在编译时进行的，这不会影响运行时性能！</target>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="translated">我们创建了一个 &lt;code&gt;counter&lt;/code&gt; 变量来将 &lt;code&gt;i32&lt;/code&gt; 容纳在 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ，如清单16-12所示。接下来，我们通过迭代一系列数字来创建10个线程。我们使用 &lt;code&gt;thread::spawn&lt;/code&gt; 并为所有线程赋予相同的闭包，该闭包将计数器移入线程，通过调用 &lt;code&gt;lock&lt;/code&gt; 方法获得 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 的锁，然后将1加到互斥锁中的值上。当一个线程完成其关闭操作后， &lt;code&gt;num&lt;/code&gt; 将超出范围并释放锁，以便另一个线程可以获取它。</target>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="translated">我们在项目目录的顶部&lt;em&gt;src&lt;/em&gt;旁边创建一个&lt;em&gt;测试&lt;/em&gt;目录。 Cargo知道要在此目录中查找集成测试文件。然后，我们可以在此目录中创建任意数量的测试文件，而Cargo会将每个文件作为单独的板条箱进行编译。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="translated">我们使用 &lt;code&gt;mpsc::channel&lt;/code&gt; 函数创建一个新通道； &lt;code&gt;mpsc&lt;/code&gt; 代表&lt;em&gt;多个生产者，一个消费者&lt;/em&gt;。简而言之，Rust的标准库实现通道的方式意味着一个通道可以具有多个产生值的&lt;em&gt;发送&lt;/em&gt;端，但只有一个&lt;em&gt;接收&lt;/em&gt;这些值的&lt;em&gt;接收&lt;/em&gt;端。想象一下，多股河流汇聚成一条大河：从任何一条河中流下来的一切最终都将最终汇入一条河流。现在，我们将从一个生产者开始，但是当我们使此示例运行时，我们将添加多个生产者。</target>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="translated">我们通过在括号内编写逗号分隔的值列表来创建元组。元组中的每个位置都有一个类型，并且元组中不同值的类型不必相同。在此示例中，我们添加了可选的类型注释：</target>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">我们创建一个作为 &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; 实例的值，并将其存储在名为 &lt;code&gt;value&lt;/code&gt; 的变量中，以便以后可以直接访问它。然后，我们在 &lt;code&gt;a&lt;/code&gt; 具有 &lt;code&gt;Cons&lt;/code&gt; 变体的 &lt;code&gt;List&lt;/code&gt; 中创建一个列表，该列表包含 &lt;code&gt;value&lt;/code&gt; 。我们需要克隆 &lt;code&gt;value&lt;/code&gt; 所以无论 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 有内部的所有权 &lt;code&gt;5&lt;/code&gt; 值而不是所有权转让 &lt;code&gt;value&lt;/code&gt; ，以 &lt;code&gt;a&lt;/code&gt; 或有 &lt;code&gt;a&lt;/code&gt; 从借 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="translated">我们创建了一个可变 &lt;code&gt;one_borrow&lt;/code&gt; 为 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 从返回智能指针 &lt;code&gt;borrow_mut&lt;/code&gt; 。然后，我们以相同的方式在变量 &lt;code&gt;two_borrow&lt;/code&gt; 中创建另一个可变借位。这使得两个可变引用在同一范围内，这是不允许的。当我们为库运行测试时，清单15-23中的代码将编译而没有任何错误，但是测试将失败：</target>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="translated">我们创建一个名为 &lt;code&gt;guess&lt;/code&gt; 的变量。但是，等等，程序是否已经没有名为 &lt;code&gt;guess&lt;/code&gt; 的变量？可以，但是Rust允许我们用一个新值来&lt;em&gt;掩盖&lt;/em&gt;以前的 &lt;code&gt;guess&lt;/code&gt; 值。此功能通常用于要将值从一种类型转换为另一种类型的情况。阴影使我们可以重用 &lt;code&gt;guess&lt;/code&gt; 变量名称，而不是强迫我们创建两个唯一变量，例如 &lt;code&gt;guess_str&lt;/code&gt; 和 &lt;code&gt;guess&lt;/code&gt; 。 （第3章将详细介绍阴影。）</target>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">我们创建一个 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 实例，该实例在变量 &lt;code&gt;a&lt;/code&gt; 中保存一个 &lt;code&gt;List&lt;/code&gt; 值，其初始列表为 &lt;code&gt;5, Nil&lt;/code&gt; 。然后，我们创建一个 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 实例保持另一个 &lt;code&gt;List&lt;/code&gt; 中的变量值 &lt;code&gt;b&lt;/code&gt; 包含值10，并指向列表中的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="translated">我们以 &lt;code&gt;mod&lt;/code&gt; 关键字开头定义模块，然后指定模块名称（在本例中为 &lt;code&gt;front_of_house&lt;/code&gt; ），并将大括号放在模块主体周围。在模块内部，我们可以有其他模块，在这种情况下，模块可以是 &lt;code&gt;hosting&lt;/code&gt; 和 &lt;code&gt;serving&lt;/code&gt; 。模块还可以保存其他项的定义，例如结构，枚举，常量，特征或功能（如清单7-1所示）。</target>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="translated">我们定义一个名为 &lt;code&gt;MyBox&lt;/code&gt; 的结构并声明一个泛型参数 &lt;code&gt;T&lt;/code&gt; ，因为我们希望我们的类型保存任何类型的值。所述 &lt;code&gt;MyBox&lt;/code&gt; 类型是一个元组与结构类型的一个元件 &lt;code&gt;T&lt;/code&gt; 。该 &lt;code&gt;MyBox::new&lt;/code&gt; 功能需要一个类型的一个参数 &lt;code&gt;T&lt;/code&gt; ，并返回一个 &lt;code&gt;MyBox&lt;/code&gt; 保存传入的值实例。</target>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="translated">我们定义变量 &lt;code&gt;b&lt;/code&gt; ,使其 &lt;code&gt;Box&lt;/code&gt; 的值指向在堆上分配的值 &lt;code&gt;5&lt;/code&gt; 。该程序将打印 &lt;code&gt;b = 5&lt;/code&gt; ;在这种情况下，我们可以像访问堆栈中的数据一样访问框中的数据。就像任何拥有的值一样，当某个框超出范围时（如 &lt;code&gt;b&lt;/code&gt; 在 &lt;code&gt;main&lt;/code&gt; 的结尾处一样），它将被释放。对该盒（存储在堆栈上）及其指向的数据（存储在堆上）进行释放。</target>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="translated">我们做到了！我们从0到10进行了计数，这似乎并不令人印象深刻，但是它确实为我们提供了很多有关 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 和线程安全性的知识。您还可以使用该程序的结构来执行更复杂的操作，而不仅仅是增加计数器。使用这种策略，您可以将计算分为独立的部分，将这些部分拆分为多个线程，然后使用 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 使每个线程用其部分更新最终结果。</target>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">我们没有处理 &lt;code&gt;None&lt;/code&gt; 情况，因此此代码将导致错误。幸运的是，这是Rust知道如何捕捉的错误。如果我们尝试编译此代码，则会收到此错误：</target>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="translated">我们在第7章中讨论了如何控制封装：我们可以使用 &lt;code&gt;pub&lt;/code&gt; 关键字来确定代码中哪些模块，类型，函数和方法应该是公共的，默认情况下其他所有内容都是私有的。例如，我们可以定义一个结构 &lt;code&gt;AveragedCollection&lt;/code&gt; 具有包含的矢量的场 &lt;code&gt;i32&lt;/code&gt; 值。该结构还可以包含一个包含向量值平均值的字段，这意味着不必在任何时候都需要按需计算平均值。换句话说， &lt;code&gt;AveragedCollection&lt;/code&gt; 将为我们缓存计算的平均值。清单17-1定义了 &lt;code&gt;AveragedCollection&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; ，我们向测试函数添加了另一个属性should_panic。如果函数内部的代码出现紧急情况，则此属性通过测试；如果函数内部的代码没有发生错误，则测试将失败。</target>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="translated">在这种情况下，我们没有得到非常有用的消息，但是当我们查看测试函数时，我们看到它用 &lt;code&gt;#[should_panic]&lt;/code&gt; 进行了注释。我们得到的失败意味着测试功能中的代码没有引起恐慌。</target>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="translated">我们不需要使用 &lt;code&gt;#[cfg(test)]&lt;/code&gt; 注释&lt;em&gt;test / integration_test.rs中的&lt;/em&gt;任何代码。Cargo会特别对待 &lt;code&gt;tests&lt;/code&gt; 目录，仅在我们运行 &lt;code&gt;cargo test&lt;/code&gt; 时才编译该目录中的文件。立即运行 &lt;code&gt;cargo test&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="translated">我们不拥有此任意位置的内存，并且不能保证此代码创建的切片包含有效的 &lt;code&gt;i32&lt;/code&gt; 值。尝试像使用 &lt;code&gt;slice&lt;/code&gt; 一样将其视为有效切片会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="translated">我们不仅需要为 &lt;code&gt;Trait&lt;/code&gt; 所有方法的所有实现创建一个表，还需要为馈给 &lt;code&gt;foo()&lt;/code&gt; 的每种不同类型创建一个这样的表。在这种情况下，结果是（实现 &lt;code&gt;Trait&lt;/code&gt; 10种类型）*（馈给 &lt;code&gt;foo()&lt;/code&gt; 的 3种类型）= 30种实现！</target>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="translated">我们最终会有不同的输出。</target>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="translated">我们用 &lt;code&gt;&amp;amp;self.0&lt;/code&gt; 填充 &lt;code&gt;deref&lt;/code&gt; 方法的主体，因此 &lt;code&gt;deref&lt;/code&gt; 返回对要使用 &lt;code&gt;*&lt;/code&gt; 运算符访问的值的引用。清单15-9中的 &lt;code&gt;main&lt;/code&gt; 函数在 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 值上调用 &lt;code&gt;*&lt;/code&gt; ，现在可以编译，并且断言可以通过！</target>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="translated">我们首先在第10章的&lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;特征：定义共享行为&amp;rdquo;&lt;/a&gt;部分介绍了特征，但与生命周期一样，我们没有讨论更高级的细节。现在，您对Rust有了更多的了解，我们可以深入了解。</target>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="translated">我们修正了全书中的一些小错误和不准确的文字。感谢举报的读者!</target>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="translated">我们使用 &lt;code&gt;ast.ident&lt;/code&gt; 获得了一个 &lt;code&gt;Ident&lt;/code&gt; 结构实例，其中包含带注释类型的名称（标识符）。清单19-32表明，当我们运行中的结构 &lt;code&gt;impl_hello_macro&lt;/code&gt; 对上市19-30中的代码功能， &lt;code&gt;ident&lt;/code&gt; 我们得到的将有 &lt;code&gt;ident&lt;/code&gt; 字段的值 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; 。因此，清单19-33中的 &lt;code&gt;name&lt;/code&gt; 变量将包含一个 &lt;code&gt;Ident&lt;/code&gt; struct实例，该实例在打印时将是字符串 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; ，即清单19-30中该结构的名称。</target>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="translated">我们收到一条错误消息，指出 &lt;code&gt;Display&lt;/code&gt; 是必需的，但尚未实现：</target>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="translated">我们得到一个错误。</target>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="translated">我们用与清单4-7中相同的方法,通过寻找第一次出现的空格来获取词尾的索引。当我们找到一个空格时,我们使用字符串的开始和空格的索引作为开始和结束的索引,返回一个字符串片断。</target>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="translated">我们为 &lt;code&gt;Post&lt;/code&gt; 提供了一个名为 &lt;code&gt;request_review&lt;/code&gt; 的公共方法，该方法将可变引用 &lt;code&gt;self&lt;/code&gt; 。然后，我们在 &lt;code&gt;Post&lt;/code&gt; 的当前状态上调用内部 &lt;code&gt;request_review&lt;/code&gt; 方法，此第二个 &lt;code&gt;request_review&lt;/code&gt; 方法使用当前状态并返回新状态。</target>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="translated">我们有一个特质和它的功能。这时,我们的箱子用户就可以通过实现特质来实现所需的功能,比如这样。</target>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="translated">我们还有另一个有用的模式，该模式利用了元组结构和元组结构枚举变量的实现细节。这些类型使用 &lt;code&gt;()&lt;/code&gt; 作为初始化语法，看起来像一个函数调用。初始化程序实际上是作为返回由其参数构造的实例的函数实现的。我们可以将这些初始化函数用作实现闭包特征的函数指针，这意味着我们可以将初始化函数指定为采用闭包的方法的参数，如下所示：</target>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="translated">现在，我们可以运行大多数游戏，但是用户只能做出一个猜测。让我们通过添加一个循环来改变它！</target>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">我们有两个结构， &lt;code&gt;Millimeters&lt;/code&gt; 和 &lt;code&gt;Meters&lt;/code&gt; ，以不同的单位保存值。我们想要将以毫米为单位的值与以米为单位的值相加，并使 &lt;code&gt;Add&lt;/code&gt; 的实现正确执行转换。我们可以实现 &lt;code&gt;Add&lt;/code&gt; 为 &lt;code&gt;Millimeters&lt;/code&gt; 与 &lt;code&gt;Meters&lt;/code&gt; 的 &lt;code&gt;RHS&lt;/code&gt; ，如清单19-15英寸</target>
        </trans-unit>
        <trans-unit id="d8a3dea7c52bc3f0b1a5887645fbfc3ac18bf504" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;Rhs&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">我们有两个结构，即 &lt;code&gt;Millimeters&lt;/code&gt; 和 &lt;code&gt;Meters&lt;/code&gt; ，它们以不同的单位保存值。我们想要将以毫米为单位的值与以米为单位的值相加，并使 &lt;code&gt;Add&lt;/code&gt; 的实现正确执行转换。我们可以实现 &lt;code&gt;Add&lt;/code&gt; 为 &lt;code&gt;Millimeters&lt;/code&gt; 与 &lt;code&gt;Meters&lt;/code&gt; 的 &lt;code&gt;Rhs&lt;/code&gt; ，如清单19-15英寸</target>
        </trans-unit>
        <trans-unit id="160ceff2ab6cdd2b56a8bbd9402294ab3fbd2021" translate="yes" xml:space="preserve">
          <source>We have written an &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;async book&lt;/a&gt; detailing async/await and trade-offs compared to using threads.</source>
          <target state="translated">我们已经写了一本&lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;异步书，&lt;/a&gt;详细介绍了与使用线程相比的异步/等待和权衡。</target>
        </trans-unit>
        <trans-unit id="0334dcbe551a168678883cc6ef5072f1b77f711d" translate="yes" xml:space="preserve">
          <source>We hinted that this example wouldn&amp;rsquo;t compile. Now let&amp;rsquo;s find out why!</source>
          <target state="translated">我们暗示此示例无法编译。现在让我们找出原因！</target>
        </trans-unit>
        <trans-unit id="1c19907344e59dccc89eee30d7cddf54b21dbd0f" translate="yes" xml:space="preserve">
          <source>We implemented the &lt;code&gt;Iterator&lt;/code&gt; trait by defining the &lt;code&gt;next&lt;/code&gt; method, so we can now use any &lt;code&gt;Iterator&lt;/code&gt; trait method&amp;rsquo;s default implementations as defined in the standard library, because they all use the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s functionality.</source>
          <target state="translated">我们通过定义 &lt;code&gt;next&lt;/code&gt; 方法来实现 &lt;code&gt;Iterator&lt;/code&gt; trait ，因此我们现在可以使用标准库中定义的 &lt;code&gt;Iterator&lt;/code&gt; trait方法的默认实现，因为它们都使用 &lt;code&gt;next&lt;/code&gt; 方法的功能。</target>
        </trans-unit>
        <trans-unit id="0d4561449955c45ad5ebb7f1cf5ff9bb22096f4e" translate="yes" xml:space="preserve">
          <source>We just built a project with &lt;code&gt;cargo build&lt;/code&gt; and ran it with &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt;, but we can also use &lt;code&gt;cargo run&lt;/code&gt; to compile the code and then run the resulting executable all in one command:</source>
          <target state="translated">我们只是使用 &lt;code&gt;cargo build&lt;/code&gt; 构建了一个项目，并使用 &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt; 运行了该项目，但是我们也可以使用 &lt;code&gt;cargo run&lt;/code&gt; 编译代码，然后在一个命令中全部运行生成的可执行文件：</target>
        </trans-unit>
        <trans-unit id="a56bd0b36b29e10cce98f9d35be1f611e5d93adf" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;add&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">我们坚持认为 &lt;code&gt;mid&lt;/code&gt; 索引在切片内。然后我们转到不安全的代码： &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 函数采用原始指针和长度，然后创建一个slice。我们使用此功能创建一个从 &lt;code&gt;ptr&lt;/code&gt; 开始且长度为 &lt;code&gt;mid&lt;/code&gt; 项目的切片。然后，我们调用 &lt;code&gt;add&lt;/code&gt; 的方法 &lt;code&gt;ptr&lt;/code&gt; 与 &lt;code&gt;mid&lt;/code&gt; 作为参数来获得原始指针开始在 &lt;code&gt;mid&lt;/code&gt; ，我们创建一个使用该指针后的剩余数量项目的切片和 &lt;code&gt;mid&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="87ae298deaf2e1fd72117ae5b5eb4b47977e9b52" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;offset&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">我们坚持认为 &lt;code&gt;mid&lt;/code&gt; 索引在切片内。然后我们转到不安全的代码： &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 函数采用原始指针和长度，然后创建一个slice。我们使用此功能创建一个从 &lt;code&gt;ptr&lt;/code&gt; 开始且长度为 &lt;code&gt;mid&lt;/code&gt; 项目的切片。然后，我们调用 &lt;code&gt;offset&lt;/code&gt; 的方法 &lt;code&gt;ptr&lt;/code&gt; 与 &lt;code&gt;mid&lt;/code&gt; 作为参数来获得原始指针开始在 &lt;code&gt;mid&lt;/code&gt; ，我们创建一个使用该指针后的剩余数量项目的切片和 &lt;code&gt;mid&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="240382aa15b940fb356b9ed46bfb7832514ebd3d" translate="yes" xml:space="preserve">
          <source>We know we want to define a method, so it will be within the &lt;code&gt;impl Rectangle&lt;/code&gt; block. The method name will be &lt;code&gt;can_hold&lt;/code&gt;, and it will take an immutable borrow of another &lt;code&gt;Rectangle&lt;/code&gt; as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; passes in &lt;code&gt;&amp;amp;rect2&lt;/code&gt;, which is an immutable borrow to &lt;code&gt;rect2&lt;/code&gt;, an instance of &lt;code&gt;Rectangle&lt;/code&gt;. This makes sense because we only need to read &lt;code&gt;rect2&lt;/code&gt; (rather than write, which would mean we&amp;rsquo;d need a mutable borrow), and we want &lt;code&gt;main&lt;/code&gt; to retain ownership of &lt;code&gt;rect2&lt;/code&gt; so we can use it again after calling the &lt;code&gt;can_hold&lt;/code&gt; method. The return value of &lt;code&gt;can_hold&lt;/code&gt; will be a Boolean, and the implementation will check whether the width and height of &lt;code&gt;self&lt;/code&gt; are both greater than the width and height of the other &lt;code&gt;Rectangle&lt;/code&gt;, respectively. Let&amp;rsquo;s add the new &lt;code&gt;can_hold&lt;/code&gt; method to the &lt;code&gt;impl&lt;/code&gt; block from Listing 5-13, shown in Listing 5-15.</source>
          <target state="translated">我们知道我们想定义一个方法，因此它将位于 &lt;code&gt;impl Rectangle&lt;/code&gt; 块内。方法名称将为 &lt;code&gt;can_hold&lt;/code&gt; ，并且它将另一个 &lt;code&gt;Rectangle&lt;/code&gt; 的不可变借位作为参数。通过查看调用该方法的代码，我们可以知道参数的类型： &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; 传入 &lt;code&gt;&amp;amp;rect2&lt;/code&gt; ，这是对 &lt;code&gt;Rectangle&lt;/code&gt; 实例 &lt;code&gt;rect2&lt;/code&gt; 的不可变借用。这是有道理的，因为我们只需要读取 &lt;code&gt;rect2&lt;/code&gt; （而不是写，这意味着我们需要可变的借用），并且我们希望 &lt;code&gt;main&lt;/code&gt; 保留 &lt;code&gt;rect2&lt;/code&gt; 的所有权。因此我们可以在调用 &lt;code&gt;can_hold&lt;/code&gt; 方法之后再次使用它。 &lt;code&gt;can_hold&lt;/code&gt; 的返回值将是一个布尔值，并且实现将检查 &lt;code&gt;self&lt;/code&gt; 的宽度和高度是否分别大于另一个 &lt;code&gt;Rectangle&lt;/code&gt; 的宽度和高度。让我们向清单5-13中的 &lt;code&gt;impl&lt;/code&gt; 块添加新的 &lt;code&gt;can_hold&lt;/code&gt; 方法，如清单5-15所示。</target>
        </trans-unit>
        <trans-unit id="09720690261d856f42ba9e119c7bca4126dc617c" translate="yes" xml:space="preserve">
          <source>We leave the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; fields private so there is no way for external code to add or remove items to the &lt;code&gt;list&lt;/code&gt; field directly; otherwise, the &lt;code&gt;average&lt;/code&gt; field might become out of sync when the &lt;code&gt;list&lt;/code&gt; changes. The &lt;code&gt;average&lt;/code&gt; method returns the value in the &lt;code&gt;average&lt;/code&gt; field, allowing external code to read the &lt;code&gt;average&lt;/code&gt; but not modify it.</source>
          <target state="translated">我们将 &lt;code&gt;list&lt;/code&gt; 字段和 &lt;code&gt;average&lt;/code&gt; 字段保留为私有，因此外部代码无法直接在 &lt;code&gt;list&lt;/code&gt; 字段中添加或删除项目。否则，当 &lt;code&gt;list&lt;/code&gt; 更改时， &lt;code&gt;average&lt;/code&gt; 字段可能会变得不同步。 &amp;ldquo; &lt;code&gt;average&lt;/code&gt; 方法返回&amp;ldquo; &lt;code&gt;average&lt;/code&gt; 字段中的值，从而允许外部代码读取 &lt;code&gt;average&lt;/code&gt; 但不能修改它。</target>
        </trans-unit>
        <trans-unit id="28901e7633295a79506b9862e703f0c9ec5149e8" translate="yes" xml:space="preserve">
          <source>We left a comment in the &lt;code&gt;for&lt;/code&gt; loop in Listing 20-14 regarding the creation of threads. Here, we&amp;rsquo;ll look at how we actually create threads. The standard library provides &lt;code&gt;thread::spawn&lt;/code&gt; as a way to create threads, and &lt;code&gt;thread::spawn&lt;/code&gt; expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them &lt;em&gt;wait&lt;/em&gt; for code that we&amp;rsquo;ll send later. The standard library&amp;rsquo;s implementation of threads doesn&amp;rsquo;t include any way to do that; we have to implement it manually.</source>
          <target state="translated">我们在清单20-14 的 &lt;code&gt;for&lt;/code&gt; 循环中留下了有关线程创建的注释。在这里，我们将了解如何实际创建线程。标准库提供了 &lt;code&gt;thread::spawn&lt;/code&gt; 作为创建线程的一种方式， &lt;code&gt;thread::spawn&lt;/code&gt; 希望获得一些代码，该线程应在创建线程后立即运行。但是，在我们的情况下，我们想要创建线程并让它们&lt;em&gt;等待&lt;/em&gt;稍后将发送的代码。标准库的线程实现不包含任何实现方法。我们必须手动实施。</target>
        </trans-unit>
        <trans-unit id="e917b5faacb8108bac1660ec1b4c362d8a292e12" translate="yes" xml:space="preserve">
          <source>We list the &lt;code&gt;x&lt;/code&gt; value and then just include the &lt;code&gt;..&lt;/code&gt; pattern. This is quicker than having to list &lt;code&gt;y: _&lt;/code&gt; and &lt;code&gt;z: _&lt;/code&gt;, particularly when we&amp;rsquo;re working with structs that have lots of fields in situations where only one or two fields are relevant.</source>
          <target state="translated">我们列出 &lt;code&gt;x&lt;/code&gt; 值，然后只包含 &lt;code&gt;..&lt;/code&gt; 模式。这比必须列出 &lt;code&gt;y: _&lt;/code&gt; 和 &lt;code&gt;z: _&lt;/code&gt; 更快，尤其是当我们在只有一个或两个字段相关的情况下使用具有很多字段的结构时。</target>
        </trans-unit>
        <trans-unit id="1649278ad2d9cbd95d5bb9721993ae2f4d897594" translate="yes" xml:space="preserve">
          <source>We make two threads and change the variable names used with the second thread to &lt;code&gt;handle2&lt;/code&gt; and &lt;code&gt;num2&lt;/code&gt;. When we run the code this time, compiling gives us the following:</source>
          <target state="translated">我们创建两个线程，并将第二个线程使用的变量名称更改为 &lt;code&gt;handle2&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 。这次运行代码时，编译会为我们提供以下内容：</target>
        </trans-unit>
        <trans-unit id="488b1d1d555af27ea61cdda89514b2dfd138dd29" translate="yes" xml:space="preserve">
          <source>We may want to write bytes to a &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; in our production code, but use an in-memory buffer in our tests. We can do this with &lt;code&gt;Cursor&lt;/code&gt;:</source>
          <target state="translated">我们可能想在生产代码中将字节写入&lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，但在测试中使用内存缓冲区。我们可以使用 &lt;code&gt;Cursor&lt;/code&gt; 做到这一点：</target>
        </trans-unit>
        <trans-unit id="42f5297aad6a8bcbbe769864f90a8b8abdf120a8" translate="yes" xml:space="preserve">
          <source>We modify &lt;code&gt;a&lt;/code&gt; so it points to &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;Nil&lt;/code&gt;, creating a cycle. We do that by using the &lt;code&gt;tail&lt;/code&gt; method to get a reference to the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;, which we put in the variable &lt;code&gt;link&lt;/code&gt;. Then we use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; to change the value inside from an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;Nil&lt;/code&gt; value to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">我们修改 &lt;code&gt;a&lt;/code&gt; 使其指向 &lt;code&gt;b&lt;/code&gt; 而不是 &lt;code&gt;Nil&lt;/code&gt; ，从而创建一个循环。我们通过使用 &lt;code&gt;tail&lt;/code&gt; 方法得到的一个参考 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; 中 &lt;code&gt;a&lt;/code&gt; ，我们把在变量 &lt;code&gt;link&lt;/code&gt; 。然后我们使用 &lt;code&gt;borrow_mut&lt;/code&gt; 上所述方法 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; 以从改变的值的内部 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 保持一个 &lt;code&gt;Nil&lt;/code&gt; 值到 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5a434a5fbccadae9667d94aa729d1d78f20bd90" translate="yes" xml:space="preserve">
          <source>We must call the &lt;code&gt;dangerous&lt;/code&gt; function within a separate &lt;code&gt;unsafe&lt;/code&gt; block. If we try to call &lt;code&gt;dangerous&lt;/code&gt; without the &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;ll get an error:</source>
          <target state="translated">我们必须在单独的 &lt;code&gt;unsafe&lt;/code&gt; 块中调用 &lt;code&gt;dangerous&lt;/code&gt; 函数。如果我们在没有 &lt;code&gt;unsafe&lt;/code&gt; 块的情况下尝试调用 &lt;code&gt;dangerous&lt;/code&gt; ，则会收到错误消息：</target>
        </trans-unit>
        <trans-unit id="4fb4c5141c4cfa6ea474c70142cc893715e15a85" translate="yes" xml:space="preserve">
          <source>We need a mock object that, instead of sending an email or text message when we call &lt;code&gt;send&lt;/code&gt;, will only keep track of the messages it&amp;rsquo;s told to send. We can create a new instance of the mock object, create a &lt;code&gt;LimitTracker&lt;/code&gt; that uses the mock object, call the &lt;code&gt;set_value&lt;/code&gt; method on &lt;code&gt;LimitTracker&lt;/code&gt;, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&amp;rsquo;t allow it:</source>
          <target state="translated">我们需要一个模拟对象，该对象不会在调用 &lt;code&gt;send&lt;/code&gt; 时发送电子邮件或短信，而只会跟踪被告知要发送的消息。我们可以创建模拟对象的新实例，创建一个 &lt;code&gt;LimitTracker&lt;/code&gt; 使用模拟对象，调用 &lt;code&gt;set_value&lt;/code&gt; 方法上 &lt;code&gt;LimitTracker&lt;/code&gt; ，然后检查模拟对象有我们预期的消息。清单15-21显示了尝试实现一个模拟对象来实现此目的的尝试，但是借位检查器不允许这样做：</target>
        </trans-unit>
        <trans-unit id="a110963ca04d0182f8c4f733a600767ec4a8c414" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the allocator when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">完成 &lt;code&gt;String&lt;/code&gt; 之后,我们需要一种将该内存返回给分配器的方法。</target>
        </trans-unit>
        <trans-unit id="7bb260a7277d45c34609007ac1f57ba6424e3b7d" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the operating system when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">完成 &lt;code&gt;String&lt;/code&gt; 后，我们需要一种将该内存返回给操作系统的方法。</target>
        </trans-unit>
        <trans-unit id="20e2cb940baac98dfff4c0ce471d1304226840b2" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;code&gt;use&lt;/code&gt; statement to bring &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into scope because it&amp;rsquo;s not in the prelude. In &lt;code&gt;main&lt;/code&gt;, we create the list holding 5 and 10 and store it in a new &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;. Then when we create &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we call the &lt;code&gt;Rc::clone&lt;/code&gt; function and pass a reference to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as an argument.</source>
          <target state="translated">我们需要添加一条 &lt;code&gt;use&lt;/code&gt; 语句将 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 纳入范围，因为它不在序幕中。在 &lt;code&gt;main&lt;/code&gt; ，我们创建列表保持5和10，并将其存储在一个新 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;a&lt;/code&gt; 。然后当我们创建 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ^，我们称之为 &lt;code&gt;Rc::clone&lt;/code&gt; 函数并传递到一个参考 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在 &lt;code&gt;a&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="20a230dc482759cbcb024d662f9a4b5ff8cb7a21" translate="yes" xml:space="preserve">
          <source>We need to add to the code in Listing 9-3 to take different actions depending on the value &lt;code&gt;File::open&lt;/code&gt; returns. Listing 9-4 shows one way to handle the &lt;code&gt;Result&lt;/code&gt; using a basic tool, the &lt;code&gt;match&lt;/code&gt; expression that we discussed in Chapter 6.</source>
          <target state="translated">我们需要添加到清单9-3中的代码中，以根据 &lt;code&gt;File::open&lt;/code&gt; 返回的值执行不同的操作。清单9-4显示了一种使用基本工具（第6章中讨论过的 &lt;code&gt;match&lt;/code&gt; 表达式）处理 &lt;code&gt;Result&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="1a52300a363f54affc64d905b97b32aef73e0083" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-23.</source>
          <target state="translated">我们需要调整通道以使用类型为 &lt;code&gt;Message&lt;/code&gt; 的值，而不是类型 &lt;code&gt;Job&lt;/code&gt; ，如清单20-23所示。</target>
        </trans-unit>
        <trans-unit id="9771dc4bdc41f5521988ffa4bcbf0d3c0f959de9" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-24.</source>
          <target state="translated">我们需要调整通道以使用 &lt;code&gt;Message&lt;/code&gt; 类型的值而不是 &lt;code&gt;Job&lt;/code&gt; 类型的代码，如清单20-24所示。</target>
        </trans-unit>
        <trans-unit id="9fe42f06f6df7ac68de2d948fcbea1a3d7286a3b" translate="yes" xml:space="preserve">
          <source>We need to declare the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate as a procedural macro crate. We&amp;rsquo;ll also need functionality from the &lt;code&gt;syn&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; crates, as you&amp;rsquo;ll see in a moment, so we need to add them as dependencies. Add the following to the &lt;em&gt;Cargo.toml&lt;/em&gt; file for &lt;code&gt;hello_macro_derive&lt;/code&gt;:</source>
          <target state="translated">我们需要将 &lt;code&gt;hello_macro_derive&lt;/code&gt; 板条箱声明为程序宏板条箱。正如您稍后会看到的那样，我们还将需要 &lt;code&gt;syn&lt;/code&gt; 和 &lt;code&gt;quote&lt;/code&gt; 板条箱中的功能，因此我们需要将它们添加为依赖项。将以下内容添加到&lt;em&gt;Cargo.toml&lt;/em&gt;文件中，用于 &lt;code&gt;hello_macro_derive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d463764f5c2df75db583b72e63eacc4531621bf0" translate="yes" xml:space="preserve">
          <source>We need to set &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; temporarily rather than setting it directly with code like &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; to get ownership of the &lt;code&gt;state&lt;/code&gt; value. This ensures &lt;code&gt;Post&lt;/code&gt; can&amp;rsquo;t use the old &lt;code&gt;state&lt;/code&gt; value after we&amp;rsquo;ve transformed it into a new state.</source>
          <target state="translated">我们需要暂时将 &lt;code&gt;state&lt;/code&gt; 设置为 &lt;code&gt;None&lt;/code&gt; ,而不是像 &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; 这样的代码直接将其设置为 获得 &lt;code&gt;state&lt;/code&gt; 价值的所有权。这可以确保 &lt;code&gt;Post&lt;/code&gt; 在将其转换为新状态后不能使用旧 &lt;code&gt;state&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="7bc24d658a32bb0bbfec91b13ffff10ee769ddc2" translate="yes" xml:space="preserve">
          <source>We needed &lt;code&gt;clone&lt;/code&gt; here because we have a slice with &lt;code&gt;String&lt;/code&gt; elements in the parameter &lt;code&gt;args&lt;/code&gt;, but the &lt;code&gt;new&lt;/code&gt; function doesn&amp;rsquo;t own &lt;code&gt;args&lt;/code&gt;. To return ownership of a &lt;code&gt;Config&lt;/code&gt; instance, we had to clone the values from the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; fields of &lt;code&gt;Config&lt;/code&gt; so the &lt;code&gt;Config&lt;/code&gt; instance can own its values.</source>
          <target state="translated">我们这里需要 &lt;code&gt;clone&lt;/code&gt; ，因为我们在参数 &lt;code&gt;args&lt;/code&gt; 中有一个包含 &lt;code&gt;String&lt;/code&gt; 元素的切片，但是 &lt;code&gt;new&lt;/code&gt; 函数不拥有 &lt;code&gt;args&lt;/code&gt; 。要返回 &lt;code&gt;Config&lt;/code&gt; 实例的所有权，我们必须从 &lt;code&gt;Config&lt;/code&gt; 的 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 段中克隆值，以便 &lt;code&gt;Config&lt;/code&gt; 实例可以拥有其值。</target>
        </trans-unit>
        <trans-unit id="a43e27dbd35abeb15b38b9262e2f49308a9d38c7" translate="yes" xml:space="preserve">
          <source>We now have a straightforward API that&amp;rsquo;s much harder to mess up, because the compiler will ensure the references into the &lt;code&gt;String&lt;/code&gt; remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn&amp;rsquo;t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of &lt;code&gt;first_word&lt;/code&gt; will throw a compile-time error:</source>
          <target state="translated">现在，我们有了一个简单的API，它很难搞乱，因为编译器将确保对 &lt;code&gt;String&lt;/code&gt; 的引用仍然有效。还记得清单4-8中程序中的错误吗？当我们将索引放在第一个单词的末尾但又清除了字符串，因此索引无效时？该代码在逻辑上是不正确的，但没有立即显示任何错误。如果我们继续尝试将第一个单词索引与空字符串一起使用，问题将在稍后出现。切片使此错误变得不可能，并且让我们知道我们的代码早日有问题。使用 &lt;code&gt;first_word&lt;/code&gt; 的切片版本将引发编译时错误：</target>
        </trans-unit>
        <trans-unit id="c7a58a3bc34ccbe75e8ddbc8d069a47ead8d2749" translate="yes" xml:space="preserve">
          <source>We now have a way to find out the index of the end of the first word in the string, but there&amp;rsquo;s a problem. We&amp;rsquo;re returning a &lt;code&gt;usize&lt;/code&gt; on its own, but it&amp;rsquo;s only a meaningful number in the context of the &lt;code&gt;&amp;amp;String&lt;/code&gt;. In other words, because it&amp;rsquo;s a separate value from the &lt;code&gt;String&lt;/code&gt;, there&amp;rsquo;s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the &lt;code&gt;first_word&lt;/code&gt; function from Listing 4-7.</source>
          <target state="translated">现在，我们有一种方法可以找出字符串中第一个单词的末尾的索引，但这是有问题的。我们将自己返回一个 &lt;code&gt;usize&lt;/code&gt; ，但这在 &lt;code&gt;&amp;amp;String&lt;/code&gt; 的上下文中只是一个有意义的数字。换句话说，因为它是与 &lt;code&gt;String&lt;/code&gt; 分开的值，所以不能保证它在将来仍然有效。考虑清单4-8中的程序，该程序使用清单4-7中的 &lt;code&gt;first_word&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="7c5216021536b3c08541f1af93af0172517e8ef7" translate="yes" xml:space="preserve">
          <source>We now need our &lt;code&gt;Job&lt;/code&gt; type alias to be a &lt;code&gt;Box&lt;/code&gt; of anything that implements our new trait &lt;code&gt;FnBox&lt;/code&gt;. This will allow us to use &lt;code&gt;call_box&lt;/code&gt; in &lt;code&gt;Worker&lt;/code&gt; when we get a &lt;code&gt;Job&lt;/code&gt; value instead of invoking the closure directly. Implementing the &lt;code&gt;FnBox&lt;/code&gt; trait for any &lt;code&gt;FnOnce()&lt;/code&gt; closure means we don&amp;rsquo;t have to change anything about the actual values we&amp;rsquo;re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</source>
          <target state="translated">现在，我们需要 &lt;code&gt;Job&lt;/code&gt; 类型别名为实现了我们新特征 &lt;code&gt;FnBox&lt;/code&gt; 的任何东西的 &lt;code&gt;Box&lt;/code&gt; 。当我们获得 &lt;code&gt;Job&lt;/code&gt; 值时，这将允许我们在 &lt;code&gt;Worker&lt;/code&gt; 中使用 &lt;code&gt;call_box&lt;/code&gt; ，而不是直接调用闭包。为任何 &lt;code&gt;FnOnce()&lt;/code&gt; 闭包实现 &lt;code&gt;FnBox&lt;/code&gt; 特质意味着我们不必更改沿通道发送的实际值的任何内容。现在Rust能够识别出我们想要做的很好。</target>
        </trans-unit>
        <trans-unit id="8583c35b022bb0426f8e6796265e5ae06507a412" translate="yes" xml:space="preserve">
          <source>We pass the value in the &lt;code&gt;case_sensitive&lt;/code&gt; variable to the &lt;code&gt;Config&lt;/code&gt; instance so the &lt;code&gt;run&lt;/code&gt; function can read that value and decide whether to call &lt;code&gt;search&lt;/code&gt; or &lt;code&gt;search_case_insensitive&lt;/code&gt;, as we implemented in Listing 12-22.</source>
          <target state="translated">我们将 &lt;code&gt;case_sensitive&lt;/code&gt; 变量中的值传递给 &lt;code&gt;Config&lt;/code&gt; 实例，以便 &lt;code&gt;run&lt;/code&gt; 函数可以读取该值并决定是调用 &lt;code&gt;search&lt;/code&gt; 还是 &lt;code&gt;search_case_insensitive&lt;/code&gt; ，如清单12-22所示。</target>
        </trans-unit>
        <trans-unit id="278796f5b8837b7d0f28d68d910bc02fc27c0a6a" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;#[should_panic]&lt;/code&gt; attribute after the &lt;code&gt;#[test]&lt;/code&gt; attribute and before the test function it applies to. Let&amp;rsquo;s look at the result when this test passes:</source>
          <target state="translated">我们将 &lt;code&gt;#[should_panic]&lt;/code&gt; 属性放在 &lt;code&gt;#[test]&lt;/code&gt; 属性之后，并将其应用到测试函数之前。让我们看一下测试通过时的结果：</target>
        </trans-unit>
        <trans-unit id="2bba2aa85955f56b33ac81b32d1e3abad3ce51a8" translate="yes" xml:space="preserve">
          <source>We ran a benchmark by loading the entire contents of &lt;em&gt;The Adventures of Sherlock Holmes&lt;/em&gt; by Sir Arthur Conan Doyle into a &lt;code&gt;String&lt;/code&gt; and looking for the word &lt;em&gt;the&lt;/em&gt; in the contents. Here are the results of the benchmark on the version of &lt;code&gt;search&lt;/code&gt; using the &lt;code&gt;for&lt;/code&gt; loop and the version using iterators:</source>
          <target state="translated">我们通过的全部内容加载运行基准&lt;em&gt;冒险史&lt;/em&gt;柯南道尔爵士为 &lt;code&gt;String&lt;/code&gt; ，并寻找这个词&lt;em&gt;的&lt;/em&gt;的内容。以下是使用 &lt;code&gt;for&lt;/code&gt; 循环和使用迭代器的 &lt;code&gt;search&lt;/code&gt; 版本的基准测试结果：</target>
        </trans-unit>
        <trans-unit id="3cb4438c8408ae587f40f74c3ab4a85a10a319c0" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a reference to a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">我们将这个定义读为： &lt;code&gt;largest&lt;/code&gt; 函数在某个类型 &lt;code&gt;T&lt;/code&gt; 上是泛型的。此函数有一个名为 &lt;code&gt;list&lt;/code&gt; 的参数，它是 &lt;code&gt;T&lt;/code&gt; 类型的值的一部分。在 &lt;code&gt;largest&lt;/code&gt; 功能将参考返回到相同类型的值 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d90131aacb69308c853c9e012b87bab3eb99486f" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">我们将这个定义读为： &lt;code&gt;largest&lt;/code&gt; 的函数在某些 &lt;code&gt;T&lt;/code&gt; 类型上是泛型的。此函数有一个名为 &lt;code&gt;list&lt;/code&gt; 的参数，它是 &lt;code&gt;T&lt;/code&gt; 类型的值的一部分。在 &lt;code&gt;largest&lt;/code&gt; 函数将返回相同类型的值 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="147f34652912dc5e1cde73ec0858d227ac63c740" translate="yes" xml:space="preserve">
          <source>We receive the following error:</source>
          <target state="translated">我们收到以下错误信息。</target>
        </trans-unit>
        <trans-unit id="7e8e5c0341d305aaf380fa95376adf0a328c5bce" translate="yes" xml:space="preserve">
          <source>We set the associated &lt;code&gt;Item&lt;/code&gt; type for our iterator to &lt;code&gt;u32&lt;/code&gt;, meaning the iterator will return &lt;code&gt;u32&lt;/code&gt; values. Again, don&amp;rsquo;t worry about associated types yet, we&amp;rsquo;ll cover them in Chapter 19.</source>
          <target state="translated">我们将迭代器的关联 &lt;code&gt;Item&lt;/code&gt; 类型设置为 &lt;code&gt;u32&lt;/code&gt; ，这意味着迭代器将返回 &lt;code&gt;u32&lt;/code&gt; 值。同样，不用担心关联类型，我们将在第19章中介绍它们。</target>
        </trans-unit>
        <trans-unit id="758bab9e4ef6994d52233f0c2648d86ae9d96c9c" translate="yes" xml:space="preserve">
          <source>We set the number of test threads to &lt;code&gt;1&lt;/code&gt;, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won&amp;rsquo;t interfere with each other if they share state.</source>
          <target state="translated">我们将测试线程的数量设置为 &lt;code&gt;1&lt;/code&gt; ，告诉程序不要使用任何并行性。使用一个线程运行测试将比并行运行更长的时间，但是如果测试共享状态，则不会相互干扰。</target>
        </trans-unit>
        <trans-unit id="2570e3bb2400d24bff6a3167e41e4cf75ad5c3a8" translate="yes" xml:space="preserve">
          <source>We should get lines that contain &amp;ldquo;to&amp;rdquo; that might have uppercase letters:</source>
          <target state="translated">我们应该得到包含&amp;ldquo; to&amp;rdquo;的行，其中可能包含大写字母：</target>
        </trans-unit>
        <trans-unit id="8d210a202bdd118dd9e0c3872fbd6277ea746c27" translate="yes" xml:space="preserve">
          <source>We still enable the creation of new posts in the draft state using &lt;code&gt;Post::new&lt;/code&gt; and the ability to add text to the post&amp;rsquo;s content. But instead of having a &lt;code&gt;content&lt;/code&gt; method on a draft post that returns an empty string, we&amp;rsquo;ll make it so draft posts don&amp;rsquo;t have the &lt;code&gt;content&lt;/code&gt; method at all. That way, if we try to get a draft post&amp;rsquo;s content, we&amp;rsquo;ll get a compiler error telling us the method doesn&amp;rsquo;t exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&amp;rsquo;t even compile. Listing 17-19 shows the definition of a &lt;code&gt;Post&lt;/code&gt; struct and a &lt;code&gt;DraftPost&lt;/code&gt; struct, as well as methods on each:</source>
          <target state="translated">我们仍然允许使用 &lt;code&gt;Post::new&lt;/code&gt; 在草稿状态下创建新帖子，并能够在帖子内容中添加文本。但是，我们将使草稿帖子根本不具有 &lt;code&gt;content&lt;/code&gt; 方法，而不是在草稿帖子中使用 &lt;code&gt;content&lt;/code&gt; 方法返回空字符串，而是将其设为空。这样，如果我们尝试获取草稿的内容，则会收到编译器错误，告诉我们该方法不存在。结果，我们不可能在生产中意外显示草稿内容，因为该代码甚至无法编译。清单17-19显示了 &lt;code&gt;Post&lt;/code&gt; 结构和 &lt;code&gt;DraftPost&lt;/code&gt; 结构的定义，以及每个结构的方法：</target>
        </trans-unit>
        <trans-unit id="95a2d58046436515ce7947004a7ac4ae33fbaf9a" translate="yes" xml:space="preserve">
          <source>We still have a &lt;code&gt;Post::new&lt;/code&gt; function, but instead of returning an instance of &lt;code&gt;Post&lt;/code&gt;, it returns an instance of &lt;code&gt;DraftPost&lt;/code&gt;. Because &lt;code&gt;content&lt;/code&gt; is private and there aren&amp;rsquo;t any functions that return &lt;code&gt;Post&lt;/code&gt;, it&amp;rsquo;s not possible to create an instance of &lt;code&gt;Post&lt;/code&gt; right now.</source>
          <target state="translated">我们仍然有一个 &lt;code&gt;Post::new&lt;/code&gt; 函数，但是它没有返回 &lt;code&gt;Post&lt;/code&gt; 的实例，而是返回了 &lt;code&gt;DraftPost&lt;/code&gt; 的实例。因为 &lt;code&gt;content&lt;/code&gt; 是私有的，并且没有任何函数返回 &lt;code&gt;Post&lt;/code&gt; ，所以现在无法创建 &lt;code&gt;Post&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="6a14d4ebb9ad3b731ec935502e9ce7735b1d1739" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and doesn&amp;rsquo;t return a value. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">我们仍然在 &lt;code&gt;FnOnce&lt;/code&gt; 之后使用 &lt;code&gt;()&lt;/code&gt; ，因为该 &lt;code&gt;FnOnce&lt;/code&gt; 表示一个不带参数且不返回值的闭包。就像函数定义一样，可以从签名中省略返回类型，但是即使我们没有参数，我们仍然需要括号。</target>
        </trans-unit>
        <trans-unit id="fb6760fff74f1d2184578db32de57a1297acba15" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and returns the unit type &lt;code&gt;()&lt;/code&gt;. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">我们仍然在 &lt;code&gt;FnOnce&lt;/code&gt; 之后使用 &lt;code&gt;()&lt;/code&gt; ，因为该 &lt;code&gt;FnOnce&lt;/code&gt; 表示一个不带参数的闭包，并返回单位类型 &lt;code&gt;()&lt;/code&gt; 。就像函数定义一样，可以从签名中省略返回类型，但是即使我们没有参数，我们仍然需要括号。</target>
        </trans-unit>
        <trans-unit id="2e44b48751025b1860e023a6de0b5d66e3d099ea" translate="yes" xml:space="preserve">
          <source>We still want to have our program stop running if the unimplemented methods are reached.</source>
          <target state="translated">我们还是想让我们的程序在达到未实现的方法时停止运行。</target>
        </trans-unit>
        <trans-unit id="5137b030849ac96f77436fd6551753ef7e79d43f" translate="yes" xml:space="preserve">
          <source>We talked about strings in Chapter 4, but we&amp;rsquo;ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&amp;rsquo;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you&amp;rsquo;re coming from other programming languages.</source>
          <target state="translated">我们在第4章中讨论过字符串，但是现在我们将更深入地研究它们。新的Rustacean通常由于以下三个原因而卡在字符串上：Rust倾向于暴露可能的错误，字符串是比许多程序员认为的更复杂的数据结构以及UTF-8。当您来自其他编程语言时，这些因素的组合似乎很难。</target>
        </trans-unit>
        <trans-unit id="aaadc6667df848db61b7c0773e7ae3fb21446c1d" translate="yes" xml:space="preserve">
          <source>We temporarily print the values of these variables to prove that the code is working as we intend. Let&amp;rsquo;s run this program again with the arguments &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;sample.txt&lt;/code&gt;:</source>
          <target state="translated">我们临时打印这些变量的值，以证明代码按预期工作。让我们再次使用 &lt;code&gt;test&lt;/code&gt; 和 &lt;code&gt;sample.txt&lt;/code&gt; 参数运行该程序：</target>
        </trans-unit>
        <trans-unit id="e19d7657ac4c2d18fdac154ffac8e272b1fa158c" translate="yes" xml:space="preserve">
          <source>We then call the &lt;code&gt;unwrap&lt;/code&gt; method, which we know will never panic, because we know the methods on &lt;code&gt;Post&lt;/code&gt; ensure that &lt;code&gt;state&lt;/code&gt; will always contain a &lt;code&gt;Some&lt;/code&gt; value when those methods are done. This is one of the cases we talked about in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Cases In Which You Have More Information Than the Compiler&amp;rdquo;&lt;/a&gt; section of Chapter 9 when we know that a &lt;code&gt;None&lt;/code&gt; value is never possible, even though the compiler isn&amp;rsquo;t able to understand that.</source>
          <target state="translated">然后我们调用 &lt;code&gt;unwrap&lt;/code&gt; 方法，我们知道它永远不会慌乱，因为我们知道 &lt;code&gt;Post&lt;/code&gt; 方法确保完成这些方法后 &lt;code&gt;state&lt;/code&gt; 始终包含 &lt;code&gt;Some&lt;/code&gt; 值。这是我们在第9章的&lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;需要比编译器提供更多信息的情况&amp;rdquo;&lt;/a&gt;一节中讨论的情况之一，我们知道即使编译器无法理解 &lt;code&gt;None&lt;/code&gt; 值也永远不可能。</target>
        </trans-unit>
        <trans-unit id="90e0dc4d89651b511b21e761c7cecacf78deadb6" translate="yes" xml:space="preserve">
          <source>We then start the macro definition with &lt;code&gt;macro_rules!&lt;/code&gt; and the name of the macro we&amp;rsquo;re defining &lt;em&gt;without&lt;/em&gt; the exclamation mark. The name, in this case &lt;code&gt;vec&lt;/code&gt;, is followed by curly brackets denoting the body of the macro definition.</source>
          <target state="translated">然后，我们从 &lt;code&gt;macro_rules!&lt;/code&gt; 开始宏定义！以及我们定义的&lt;em&gt;不带&lt;/em&gt;感叹号的宏的名称。名称（在本例中为 &lt;code&gt;vec&lt;/code&gt; ）后跟大括号，表示宏定义的正文。</target>
        </trans-unit>
        <trans-unit id="3e635cdf83139712ccc1cd2aa803bc947c37a339" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;ThreadPool::new&lt;/code&gt; to create a new thread pool with a configurable number of threads, in this case four. Then, in the &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;pool.execute&lt;/code&gt; has a similar interface as &lt;code&gt;thread::spawn&lt;/code&gt; in that it takes a closure the pool should run for each stream. We need to implement &lt;code&gt;pool.execute&lt;/code&gt; so it takes the closure and gives it to a thread in the pool to run. This code won&amp;rsquo;t yet compile, but we&amp;rsquo;ll try so the compiler can guide us in how to fix it.</source>
          <target state="translated">我们使用 &lt;code&gt;ThreadPool::new&lt;/code&gt; 来创建一个具有可配置数量的线程的新线程池，在这种情况下为四个。然后，在 &lt;code&gt;for&lt;/code&gt; 循环中， &lt;code&gt;pool.execute&lt;/code&gt; 具有与 &lt;code&gt;thread::spawn&lt;/code&gt; 类似的接口，因为它需要关闭池才能为每个流运行。我们需要实现 &lt;code&gt;pool.execute&lt;/code&gt; ,以便它采取闭包并将其提供给池中的线程来运行。该代码尚未编译，但是我们将尝试使编译器指导我们如何修复它。</target>
        </trans-unit>
        <trans-unit id="00a8575d12353b261846fe413a9059471bbbb3a1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;expect&lt;/code&gt; in the same way as &lt;code&gt;unwrap&lt;/code&gt;: to return the file handle or call the &lt;code&gt;panic!&lt;/code&gt; macro. The error message used by &lt;code&gt;expect&lt;/code&gt; in its call to &lt;code&gt;panic!&lt;/code&gt; will be the parameter that we pass to &lt;code&gt;expect&lt;/code&gt;, rather than the default &lt;code&gt;panic!&lt;/code&gt; message that &lt;code&gt;unwrap&lt;/code&gt; uses. Here&amp;rsquo;s what it looks like:</source>
          <target state="translated">我们用 &lt;code&gt;expect&lt;/code&gt; 的同样的方式 &lt;code&gt;unwrap&lt;/code&gt; ：返回文件句柄或致电 &lt;code&gt;panic!&lt;/code&gt; 宏。 &lt;code&gt;expect&lt;/code&gt; 在 &lt;code&gt;panic!&lt;/code&gt; 使用的错误消息！将是我们传递的 &lt;code&gt;expect&lt;/code&gt; 参数，而不是默认的 &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;unwrap&lt;/code&gt; 使用的消息。看起来是这样的：</target>
        </trans-unit>
        <trans-unit id="c78d1a392741412017cb0bee15d7b3bfa39b4f96" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;if let&lt;/code&gt; rather than &lt;code&gt;unwrap_or_else&lt;/code&gt; to check whether &lt;code&gt;run&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt; value and call &lt;code&gt;process::exit(1)&lt;/code&gt; if it does. The &lt;code&gt;run&lt;/code&gt; function doesn&amp;rsquo;t return a value that we want to &lt;code&gt;unwrap&lt;/code&gt; in the same way that &lt;code&gt;Config::new&lt;/code&gt; returns the &lt;code&gt;Config&lt;/code&gt; instance. Because &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; in the success case, we only care about detecting an error, so we don&amp;rsquo;t need &lt;code&gt;unwrap_or_else&lt;/code&gt; to return the unwrapped value because it would only be &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">我们使用 &lt;code&gt;if let&lt;/code&gt; 而不是 &lt;code&gt;unwrap_or_else&lt;/code&gt; 来检查 &lt;code&gt;run&lt;/code&gt; 是否返回 &lt;code&gt;Err&lt;/code&gt; 值，如果是，则调用 &lt;code&gt;process::exit(1)&lt;/code&gt; 。在 &lt;code&gt;run&lt;/code&gt; 函数不返回一个值，我们要 &lt;code&gt;unwrap&lt;/code&gt; 以同样的方式， &lt;code&gt;Config::new&lt;/code&gt; 收益的 &lt;code&gt;Config&lt;/code&gt; 实例。由于 &lt;code&gt;run&lt;/code&gt; 的回报 &lt;code&gt;()&lt;/code&gt; 在成功的情况下，我们只关心一检测到错误，所以我们不需要 &lt;code&gt;unwrap_or_else&lt;/code&gt; 返回展开的价值，因为它只会是 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ae4452a21a2f1db6f66b2ae014602087da7436" translate="yes" xml:space="preserve">
          <source>We use structs to add meaning by labeling the data. We can transform the tuple we&amp;rsquo;re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</source>
          <target state="translated">我们使用结构通过标记数据来添加含义。我们可以将正在使用的元组转换为具有整体名称和部分名称的数据类型，如清单5-10所示。</target>
        </trans-unit>
        <trans-unit id="588a26e819f938a8daa06969800194e2035e44dd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type when we want to allocate some data on the heap for multiple parts of our program to read and we can&amp;rsquo;t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data&amp;rsquo;s owner, and the normal ownership rules enforced at compile time would take effect.</source>
          <target state="translated">当我们要在堆上分配一些数据以供程序的多个部分读取时，我们使用 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 类型，并且我们无法确定在编译时最后将使用该数据的哪一部分。如果我们知道哪一部分将最后完成，我们可以使该部分成为数据的所有者，并且在编译时强制执行的常规所有权规则将生效。</target>
        </trans-unit>
        <trans-unit id="52b921b4cc68cbe5aa2d7fc1be85a8c378a377ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first call to &lt;code&gt;enumerate&lt;/code&gt; produces the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="translated">我们使用 &lt;code&gt;enumerate&lt;/code&gt; 方法使迭代器适应生成一个值，并将该值在迭代器中的索引放置到元组中。第一次 &lt;code&gt;enumerate&lt;/code&gt; 生成元组 &lt;code&gt;(0, 'a')&lt;/code&gt; 。当此值与模式 &lt;code&gt;(index, value)&lt;/code&gt; 匹配时， &lt;code&gt;index&lt;/code&gt; 将为 &lt;code&gt;0&lt;/code&gt; 且 &lt;code&gt;value&lt;/code&gt; 将为 &lt;code&gt;'a'&lt;/code&gt; ，打印输出的第一行。</target>
        </trans-unit>
        <trans-unit id="89efb5c2080aec4449c36e4ba732d1a629943ccc" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first value produced is the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="translated">我们使用 &lt;code&gt;enumerate&lt;/code&gt; 方法修改迭代器以生成一个值，并将该值在迭代器中的索引放置到元组中。产生的第一个值是元组 &lt;code&gt;(0, 'a')&lt;/code&gt; 。当此值与模式 &lt;code&gt;(index, value)&lt;/code&gt; 匹配时， &lt;code&gt;index&lt;/code&gt; 将为 &lt;code&gt;0&lt;/code&gt; 且 &lt;code&gt;value&lt;/code&gt; 将为 &lt;code&gt;'a'&lt;/code&gt; ，打印输出的第一行。</target>
        </trans-unit>
        <trans-unit id="4b7fed23abc00c81e6f42de18b1f4486c96308f2" translate="yes" xml:space="preserve">
          <source>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</source>
          <target state="translated">我们使用简写ANYTOKEN来表示所有令牌(包括简单的NT)的集合。例如,如果任何令牌在匹配器M之后都是合法的,那么FOLLOW(M)=ANYTOKEN。</target>
        </trans-unit>
        <trans-unit id="e8b8d2725e3d51d9cd1d2d122943d1410209c3b4" translate="yes" xml:space="preserve">
          <source>We used the &lt;code&gt;# Examples&lt;/code&gt; Markdown heading in Listing 14-1 to create a section in the HTML with the title &amp;ldquo;Examples.&amp;rdquo; Here are some other sections that crate authors commonly use in their documentation:</source>
          <target state="translated">我们使用 &lt;code&gt;# Examples&lt;/code&gt; 清单14-1的降价标题来创建与标题的HTML一节&amp;ldquo;的例子。&amp;rdquo; 这是板条箱作者在其文档中常用的其他部分：</target>
        </trans-unit>
        <trans-unit id="0ef9cc2887d688cae816e0aff37ad262f04c5243" translate="yes" xml:space="preserve">
          <source>We want &lt;code&gt;Cacher&lt;/code&gt; to manage the struct fields&amp;rsquo; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</source>
          <target state="translated">我们希望 &lt;code&gt;Cacher&lt;/code&gt; 管理struct字段的值，而不是让调用代码潜在地直接更改这些字段中的值，因此这些字段是私有的。</target>
        </trans-unit>
        <trans-unit id="343cff43eccaf2ff33fadb37476034c08a669197" translate="yes" xml:space="preserve">
          <source>We want a &lt;code&gt;Node&lt;/code&gt; to own its children, and we want to share that ownership with variables so we can access each &lt;code&gt;Node&lt;/code&gt; in the tree directly. To do this, we define the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; items to be values of type &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt;. We also want to modify which nodes are children of another node, so we have a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;children&lt;/code&gt; around the &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">我们希望一个 &lt;code&gt;Node&lt;/code&gt; 拥有其子节点，并希望与变量共享该所有权，以便我们可以直接访问树中的每个 &lt;code&gt;Node&lt;/code&gt; 。为此，我们将 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 项定义为 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 类型的值。我们还希望修改哪些节点是另一个节点的孩子，所以我们有一个 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;code&gt;children&lt;/code&gt; 周围的 &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efe26c37f1d8e8931b2a537169f33a14c01a5d00" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 5, &lt;code&gt;next&lt;/code&gt; will increment &lt;code&gt;count&lt;/code&gt; and return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;. Once &lt;code&gt;count&lt;/code&gt; is 5, our iterator will stop incrementing &lt;code&gt;count&lt;/code&gt; and always return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">我们希望迭代器将1添加到当前状态，因此我们将 &lt;code&gt;count&lt;/code&gt; 初始化为0，这样它将首先返回1。如果 &lt;code&gt;count&lt;/code&gt; 的值小于5，则 &lt;code&gt;next&lt;/code&gt; 将增加 &lt;code&gt;count&lt;/code&gt; 并返回包装在 &lt;code&gt;Some&lt;/code&gt; 中的当前值。一旦 &lt;code&gt;count&lt;/code&gt; 为5，我们的迭代器将停止递增 &lt;code&gt;count&lt;/code&gt; 并始终返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0d37e81b31729b213fcdf893a4673b004b8c84e" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 6, &lt;code&gt;next&lt;/code&gt; will return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;, but if &lt;code&gt;count&lt;/code&gt; is 6 or higher, our iterator will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">我们希望迭代器将1添加到当前状态，因此我们将 &lt;code&gt;count&lt;/code&gt; 初始化为0，这样它将首先返回1。如果 &lt;code&gt;count&lt;/code&gt; 的值小于6，则 &lt;code&gt;next&lt;/code&gt; 将返回包装在 &lt;code&gt;Some&lt;/code&gt; 中的当前值，但如果 &lt;code&gt;count&lt;/code&gt; 为6或更高，则迭代器将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="159b06d9b1bc3efbb438075384303e9f9ce5bdb3" translate="yes" xml:space="preserve">
          <source>We want our procedural macro to generate an implementation of our &lt;code&gt;HelloMacro&lt;/code&gt; trait for the type the user annotated, which we can get by using &lt;code&gt;#name&lt;/code&gt;. The trait implementation has one function, &lt;code&gt;hello_macro&lt;/code&gt;, whose body contains the functionality we want to provide: printing &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; and then the name of the annotated type.</source>
          <target state="translated">我们希望过程宏为用户注释的类型生成 &lt;code&gt;HelloMacro&lt;/code&gt; 特征的实现，可以使用 &lt;code&gt;#name&lt;/code&gt; 来获取。trait实现有一个函数 &lt;code&gt;hello_macro&lt;/code&gt; ，其主体包含我们要提供的功能：打印 &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; ，然后是注释类型的名字。</target>
        </trans-unit>
        <trans-unit id="dcf36cf58e85676915b970d805c54013d2ad222e" translate="yes" xml:space="preserve">
          <source>We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&amp;rsquo;t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a &lt;code&gt;ThreadPool&lt;/code&gt; struct we want to use instead of &lt;code&gt;thread::spawn&lt;/code&gt;.</source>
          <target state="translated">我们希望线程池以类似的熟悉方式工作，因此从线程切换到线程池不需要对使用我们的API的代码进行大量更改。清单20-12显示了我们要使用的 &lt;code&gt;ThreadPool&lt;/code&gt; 结构而不是 &lt;code&gt;thread::spawn&lt;/code&gt; 的假设接口。</target>
        </trans-unit>
        <trans-unit id="fff17d8c2985947122e61a61d15c1a4da390070a" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;Worker&lt;/code&gt; structs that we just created to fetch code to run from a queue held in the &lt;code&gt;ThreadPool&lt;/code&gt; and send that code to its thread to run.</source>
          <target state="translated">我们希望我们刚创建的 &lt;code&gt;Worker&lt;/code&gt; 结构从 &lt;code&gt;ThreadPool&lt;/code&gt; 保存的队列中获取代码以运行代码，并将该代码发送到其线程中以运行。</target>
        </trans-unit>
        <trans-unit id="131c3dfcc453a4966e031008be09ae09bde292da" translate="yes" xml:space="preserve">
          <source>We want to add a new &lt;code&gt;search_case_insensitive&lt;/code&gt; function that we&amp;rsquo;ll call when the environment variable is on. We&amp;rsquo;ll continue to follow the TDD process, so the first step is again to write a failing test. We&amp;rsquo;ll add a new test for the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function and rename our old test from &lt;code&gt;one_result&lt;/code&gt; to &lt;code&gt;case_sensitive&lt;/code&gt; to clarify the differences between the two tests, as shown in Listing 12-20.</source>
          <target state="translated">我们要添加一个新的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数，当环境变量打开时将调用该函数。我们将继续遵循TDD流程，因此第一步再次是编写失败的测试。我们将为新的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数添加一个新测试，并将旧测试从 &lt;code&gt;one_result&lt;/code&gt; 重命名为 &lt;code&gt;case_sensitive&lt;/code&gt; ,以阐明这两个测试之间的差异，如清单12-20所示。</target>
        </trans-unit>
        <trans-unit id="b16d6b885dbd18ae9ca5b7b63f85be38981add63" translate="yes" xml:space="preserve">
          <source>We want to allow the user to create a new draft blog post with &lt;code&gt;Post::new&lt;/code&gt;. Then we want to allow text to be added to the blog post while it&amp;rsquo;s in the draft state. If we try to get the post&amp;rsquo;s content immediately, before approval, nothing should happen because the post is still a draft. We&amp;rsquo;ve added &lt;code&gt;assert_eq!&lt;/code&gt; in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the &lt;code&gt;content&lt;/code&gt; method, but we&amp;rsquo;re not going to write tests for this example.</source>
          <target state="translated">我们希望允许用户使用 &lt;code&gt;Post::new&lt;/code&gt; 创建新的博客文章草稿。然后，我们希望允许文本处于草稿状态时将其添加到博客中。如果我们尝试立即获得帖子的内容，那么在批准之前，什么都不会发生，因为该帖子仍然是草稿。我们添加了 &lt;code&gt;assert_eq!&lt;/code&gt; 在代码中用于演示目的。一个很好的单元测试就是断言博客文章草案从 &lt;code&gt;content&lt;/code&gt; 方法返回一个空字符串，但是我们不会为这个示例编写测试。</target>
        </trans-unit>
        <trans-unit id="7fed3691de8586ef2849a59c359e563892a4dc4c" translate="yes" xml:space="preserve">
          <source>We want to define code in one place in our program, but only &lt;em&gt;execute&lt;/em&gt; that code where we actually need the result. This is a use case for closures!</source>
          <target state="translated">我们希望在程序中的一个位置定义代码，但是仅在实际需要结果的地方&lt;em&gt;执行&lt;/em&gt;该代码。这是关闭的用例！</target>
        </trans-unit>
        <trans-unit id="d18a25187ad631c5a4e827947adecf2aa147cc32" translate="yes" xml:space="preserve">
          <source>We want to do something with the &lt;code&gt;Some(3)&lt;/code&gt; match but do nothing with any other &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; value or the &lt;code&gt;None&lt;/code&gt; value. To satisfy the &lt;code&gt;match&lt;/code&gt; expression, we have to add &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; after processing just one variant, which is a lot of boilerplate code to add.</source>
          <target state="translated">我们想对 &lt;code&gt;Some(3)&lt;/code&gt; 匹配进行操作，而对其他 &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; 值或 &lt;code&gt;None&lt;/code&gt; 值则不执行任何操作。为了满足 &lt;code&gt;match&lt;/code&gt; 表达式，我们只需要处理一个变体就添加 &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; ，这是要添加的许多样板代码。</target>
        </trans-unit>
        <trans-unit id="dc02dbe447e584d5bc7325caffcd6113884e46a0" translate="yes" xml:space="preserve">
          <source>We want to express the constraint that Foo should not outlive &lt;code&gt;'a&lt;/code&gt;, because the data pointed to by &lt;code&gt;T&lt;/code&gt; is only valid for that lifetime. The problem is that there are no actual uses of &lt;code&gt;'a&lt;/code&gt;. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">我们要表达Foo不应超过 &lt;code&gt;'a&lt;/code&gt; 的约束，因为 &lt;code&gt;T&lt;/code&gt; 指向的数据仅在该生存期内有效。问题是 &lt;code&gt;'a&lt;/code&gt; 没有实际使用。可以通过在结构中添加PhantomData类型来解决此问题，并使用它告诉编译器以该结构包含借用引用 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 的方式进行操作：</target>
        </trans-unit>
        <trans-unit id="8096aefade4c17845a6c208281a849237f1210fa" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; for 'MyStruct', but for some reason it only makes sense to implement the &lt;code&gt;bar()&lt;/code&gt; function. &lt;code&gt;baz()&lt;/code&gt; and &lt;code&gt;qux()&lt;/code&gt; will still need to be defined in our implementation of &lt;code&gt;Foo&lt;/code&gt;, but we can use &lt;code&gt;unimplemented!&lt;/code&gt; in their definitions to allow our code to compile.</source>
          <target state="translated">我们想为&amp;ldquo; MyStruct&amp;rdquo;实现 &lt;code&gt;Foo&lt;/code&gt; ，但是由于某些原因，只有实现 &lt;code&gt;bar()&lt;/code&gt; 函数才有意义。在我们的 &lt;code&gt;Foo&lt;/code&gt; 实现中仍然需要定义 &lt;code&gt;baz()&lt;/code&gt; 和 &lt;code&gt;qux()&lt;/code&gt; ，但是我们可以使用 &lt;code&gt;unimplemented!&lt;/code&gt; 在它们的定义中允许我们的代码进行编译。</target>
        </trans-unit>
        <trans-unit id="20c0f35ebffd6903da931ba226fd712a56dd80d9" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;todo!&lt;/code&gt;:</source>
          <target state="translated">我们想对其中一种类型实现 &lt;code&gt;Foo&lt;/code&gt; ，但我们也想先对 &lt;code&gt;bar()&lt;/code&gt; 进行操作。为了编译我们的代码，我们需要实现 &lt;code&gt;baz()&lt;/code&gt; ，所以我们可以使用 &lt;code&gt;todo!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56425053366a107f9b4c0d5cead1a47581ce32c6" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;unimplemented!&lt;/code&gt;:</source>
          <target state="translated">我们想对其中一种类型实现 &lt;code&gt;Foo&lt;/code&gt; ，但我们也想先对 &lt;code&gt;bar()&lt;/code&gt; 进行操作。为了使我们的代码编译，我们需要实现 &lt;code&gt;baz()&lt;/code&gt; ，因此我们可以使用 &lt;code&gt;unimplemented!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2603349a6514abb34f4d8e302a6f486604d53289" translate="yes" xml:space="preserve">
          <source>We want to make a media aggregator library that can display summaries of data that might be stored in a &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt; instance. To do this, we need a summary from each type, and we need to request that summary by calling a &lt;code&gt;summarize&lt;/code&gt; method on an instance. Listing 10-12 shows the definition of a &lt;code&gt;Summary&lt;/code&gt; trait that expresses this behavior.</source>
          <target state="translated">我们想要制作一个媒体聚合器库，以显示可能存储在 &lt;code&gt;NewsArticle&lt;/code&gt; 或 &lt;code&gt;Tweet&lt;/code&gt; 实例中的数据摘要。要做到这一点，我们需要从各个类型的总结，我们需要通过调用来请求总结 &lt;code&gt;summarize&lt;/code&gt; 上一个实例方法。清单10-12显示了表达此行为的 &lt;code&gt;Summary&lt;/code&gt; 特性的定义。</target>
        </trans-unit>
        <trans-unit id="c43cd68edbbfd1b8e1512d94b1171eea5afef79e" translate="yes" xml:space="preserve">
          <source>We want to require that types of consts used in pattern matches have the attribute &lt;code&gt;#[derive(PartialEq, Eq)]&lt;/code&gt;.</source>
          <target state="translated">我们要要求模式匹配中使用的 &lt;code&gt;#[derive(PartialEq, Eq)]&lt;/code&gt; 类型具有属性＃[derive（PartialEq，Eq）]。</target>
        </trans-unit>
        <trans-unit id="ad91bce07f001635901cf680ab9baa3e439ca352" translate="yes" xml:space="preserve">
          <source>We welcome contributions of all kinds.</source>
          <target state="translated">我们欢迎各种形式的贡献。</target>
        </trans-unit>
        <trans-unit id="23a6529743bec69716fd57e6fc32983956eb0107" translate="yes" xml:space="preserve">
          <source>We will tend to use the variable &quot;M&quot; to stand for a matcher, variables &quot;t&quot; and &quot;u&quot; for arbitrary individual tokens, and the variables &quot;tt&quot; and &quot;uu&quot; for arbitrary token trees. (The use of &quot;tt&quot; does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</source>
          <target state="translated">我们倾向于用变量 &quot;M &quot;代表匹配器,用变量 &quot;t &quot;和 &quot;u &quot;代表任意的单个标记,用变量 &quot;tt &quot;和 &quot;uu &quot;代表任意的标记树(使用 &quot;tt &quot;确实会带来潜在的歧义,因为它的额外作用是作为一个片段指定符;但从上下文中可以清楚地看出是指哪种解释)。</target>
        </trans-unit>
        <trans-unit id="83ee5c69c56907ebdffff8aeb268f380fd8205ee" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can&amp;rsquo;t know and define all the types other programmers might want to create. But we do know that &lt;code&gt;gui&lt;/code&gt; needs to keep track of many values of different types, and it needs to call a &lt;code&gt;draw&lt;/code&gt; method on each of these differently typed values. It doesn&amp;rsquo;t need to know exactly what will happen when we call the &lt;code&gt;draw&lt;/code&gt; method, just that the value will have that method available for us to call.</source>
          <target state="translated">在此示例中，我们不会实现完整的GUI库，但会显示各个部分如何组合在一起。在编写库时，我们无法知道和定义其他程序员可能想要创建的所有类型。但是我们确实知道 &lt;code&gt;gui&lt;/code&gt; 需要跟踪许多不同类型的值，并且需要对这些不同类型的值中的每一个调用 &lt;code&gt;draw&lt;/code&gt; 方法。不必确切知道调用 &lt;code&gt;draw&lt;/code&gt; 方法时会发生什么，只需知道值将具有可供我们调用的方法即可。</target>
        </trans-unit>
        <trans-unit id="d21a898dd719bc6dce095fa6d8b7f4dd1c97ae10" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t see any output to the terminal, and &lt;em&gt;output.txt&lt;/em&gt; will contain our results:</source>
          <target state="translated">我们不会在终端看到任何输出，并且&lt;em&gt;output.txt&lt;/em&gt;将包含我们的结果：</target>
        </trans-unit>
        <trans-unit id="1bcf0abfb9f5d1eb6eceeb8401331a69bbdacdc8" translate="yes" xml:space="preserve">
          <source>We would get this error:</source>
          <target state="translated">我们会得到这个错误。</target>
        </trans-unit>
        <trans-unit id="5622bdba3c15431adc562635e894da31c4a2b58c" translate="yes" xml:space="preserve">
          <source>We wrap the list &lt;code&gt;a&lt;/code&gt; in an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; so when we create lists &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, they can both refer to &lt;code&gt;a&lt;/code&gt;, which is what we did in Listing 15-18.</source>
          <target state="translated">我们将列表 &lt;code&gt;a&lt;/code&gt; 包装在 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 因此当创建列表 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 时，它们都可以引用 &lt;code&gt;a&lt;/code&gt; ，这是清单15-18中所做的。</target>
        </trans-unit>
        <trans-unit id="e8c8515d512bf806d32faac4f020e79d1b4ea0b5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also briefly introduce closures, iterators, and trait objects, which Chapters &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; and &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; will cover in detail.</source>
          <target state="translated">我们还将简要介绍倒闭，迭代器和特质的对象，这章&lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt;和&lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt;我们会详细讨论。</target>
        </trans-unit>
        <trans-unit id="bd0d703fb6da707b1fe1894466f6416db96a6796" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll change the start of the &lt;code&gt;main&lt;/code&gt; function that we had in Listing 12-24 to the code in Listing 13-25. This won&amp;rsquo;t compile until we update &lt;code&gt;Config::new&lt;/code&gt; as well.</source>
          <target state="translated">我们将清单12-24 中的 &lt;code&gt;main&lt;/code&gt; 函数的开始更改为清单13-25中的代码。在我们也更新 &lt;code&gt;Config::new&lt;/code&gt; 之前，它不会编译。</target>
        </trans-unit>
        <trans-unit id="d3116613c32b066db53048929e2f72dcbc32c305" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll check for errors and handle them using a technique similar to one we used with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-10, but with a slight difference:</source>
          <target state="translated">我们将检查错误并使用与清单12-10中的 &lt;code&gt;Config::new&lt;/code&gt; 相似的技术来处理错误，但略有不同：</target>
        </trans-unit>
        <trans-unit id="d62b197067e3536d1071880b59f256af5edc6238" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll come back to &lt;code&gt;panic!&lt;/code&gt; and when we should and should not use &lt;code&gt;panic!&lt;/code&gt; to handle error conditions in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section later in this chapter. Next, we&amp;rsquo;ll look at how to recover from an error using &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">我们会 &lt;code&gt;panic!&lt;/code&gt; 以及何时应该和不应该使用 &lt;code&gt;panic!&lt;/code&gt; 处理&lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo; &lt;code&gt;panic!&lt;/code&gt; 还是不要 &lt;code&gt;panic!&lt;/code&gt; &amp;rdquo;&lt;/a&gt;稍后部分节。接下来，我们将研究如何使用 &lt;code&gt;Result&lt;/code&gt; 从错误中恢复。</target>
        </trans-unit>
        <trans-unit id="7c361948b72916d443c2a8639e53ba761429344f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue to get warnings because we aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">我们将继续收到警告，因为我们对 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;execute&lt;/code&gt; 的参数没有做任何事情。让我们以所需的行为实现这些函数的主体。首先，让我们考虑一下 &lt;code&gt;new&lt;/code&gt; 。之前我们为 &lt;code&gt;size&lt;/code&gt; 参数选择了无符号类型，因为线程数为负的池没有意义。但是，具有零线程的池也没有意义，但是零是一个完全有效的 &lt;code&gt;usize&lt;/code&gt; 。我们将添加代码以检查 &lt;code&gt;size&lt;/code&gt; 是否大于零，然后再返回 &lt;code&gt;ThreadPool&lt;/code&gt; 实例，并通过 &lt;code&gt;assert!&lt;/code&gt; 使程序惊慌（如果它收到零）！宏，如清单20-13所示。</target>
        </trans-unit>
        <trans-unit id="51ae0f2c48f47ac8366f3fdf37d10c87f351ab8e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a new &lt;code&gt;Job&lt;/code&gt; struct that will hold the closures we want to send down the channel.</source>
          <target state="translated">我们将创建一个新的 &lt;code&gt;Job&lt;/code&gt; 结构，该结构将保存我们要沿通道发送的闭包。</target>
        </trans-unit>
        <trans-unit id="4bb83dcab86b4aa0381b060ab157833722eb2537" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create list &lt;code&gt;a&lt;/code&gt; that contains 5 and then 10. Then we&amp;rsquo;ll make two more lists: &lt;code&gt;b&lt;/code&gt; that starts with 3 and &lt;code&gt;c&lt;/code&gt; that starts with 4. Both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; lists will then continue on to the first &lt;code&gt;a&lt;/code&gt; list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</source>
          <target state="translated">我们将创建 &lt;code&gt;a&lt;/code&gt; 包含5和10的列表a，然后再创建两个列表： &lt;code&gt;b&lt;/code&gt; 以3开头， &lt;code&gt;c&lt;/code&gt; 以4开头 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 列表都将继续到第 &lt;code&gt;a&lt;/code&gt; 包含5 的列表。和10。换句话说，两个列表将共享包含5和10的第一个列表。</target>
        </trans-unit>
        <trans-unit id="fa20d8056fa921c697f37302e71e0fe1ecb7bea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll define the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; to take a closure as a parameter. Recall from the &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;Storing Closures Using Generic Parameters and the &lt;code&gt;Fn&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 13 that we can take closures as parameters with three different traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;. We need to decide which kind of closure to use here. We know we&amp;rsquo;ll end up doing something similar to the standard library &lt;code&gt;thread::spawn&lt;/code&gt; implementation, so we can look at what bounds the signature of &lt;code&gt;thread::spawn&lt;/code&gt; has on its parameter. The documentation shows us the following:</source>
          <target state="translated">我们将在 &lt;code&gt;ThreadPool&lt;/code&gt; 上定义 &lt;code&gt;execute&lt;/code&gt; 方法，以将闭包作为参数。回想一下第13章的&lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;使用通用参数和&lt;/a&gt; &lt;code&gt;Fn&lt;/code&gt; 特性存储闭包&amp;rdquo;，我们可以将闭包作为具有三个不同特征的参数： &lt;code&gt;Fn&lt;/code&gt; ， &lt;code&gt;FnMut&lt;/code&gt; 和 &lt;code&gt;FnOnce&lt;/code&gt; 。我们需要决定在这里使用哪种闭包。我们知道我们最终将执行与标准库 &lt;code&gt;thread::spawn&lt;/code&gt; 实现类似的操作，因此我们可以查看 &lt;code&gt;thread::spawn&lt;/code&gt; 的签名在其参数上的界限。该文档向我们显示了以下内容：</target>
        </trans-unit>
        <trans-unit id="a2fdbbe18f87451459f008e457c7a300c4999cac" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate the first situation in the &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;Enabling Recursive Types with Boxes&amp;rdquo;&lt;/a&gt; section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a &lt;em&gt;trait object&lt;/em&gt;, and Chapter 17 devotes an entire section, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types,&amp;rdquo;&lt;/a&gt; just to that topic. So what you learn here you&amp;rsquo;ll apply again in Chapter 17!</source>
          <target state="translated">我们将在&lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;使用框启用递归类型&amp;rdquo;&lt;/a&gt;部分中演示第一种情况。在第二种情况下，转移大量数据的所有权可能会花费很长时间，因为数据是在堆栈上四处复制的。为了在这种情况下提高性能，我们可以将大量数据存储在一个盒子中的堆中。然后，只有少量的指针数据被复制到堆栈中，而它所引用的数据则保留在堆中的某个位置。第三种情况称为&lt;em&gt;特质对象&lt;/em&gt;，第17章专门针对该主题专门讨论了&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;使用允许使用不同类型的值的特性对象&amp;rdquo;这一&lt;/a&gt;节。因此，您在这里学到的内容将在第17章中再次应用！</target>
        </trans-unit>
        <trans-unit id="deceb660af9d289cbab49d701f06e3ffa29f7fd4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.</source>
          <target state="translated">我们将讨论如何创建和更新向量，字符串和哈希图，以及使每个特征与众不同的地方。</target>
        </trans-unit>
        <trans-unit id="8ac89a220719114fba008017ccc516ce2a635466" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss iterators in more detail in Chapter 13. For now, know that &lt;code&gt;iter&lt;/code&gt; is a method that returns each element in a collection and that &lt;code&gt;enumerate&lt;/code&gt; wraps the result of &lt;code&gt;iter&lt;/code&gt; and returns each element as part of a tuple instead. The first element of the tuple returned from &lt;code&gt;enumerate&lt;/code&gt; is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.</source>
          <target state="translated">我们将在第13章中更详细地讨论迭代器。现在，知道 &lt;code&gt;iter&lt;/code&gt; 是一种返回集合中每个元素的方法，该方法 &lt;code&gt;enumerate&lt;/code&gt; 包装 &lt;code&gt;iter&lt;/code&gt; 的结果并将每个元素返回为元组的一部分。从 &lt;code&gt;enumerate&lt;/code&gt; 返回的元组的第一个元素是索引，第二个元素是对该元素的引用。这比自己计算索引要方便一些。</target>
        </trans-unit>
        <trans-unit id="624f79a35ccc7ff9109a384a1f2001d1a19900e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore some aspects of how tests work by experimenting with the template test generated for us without actually testing any code. Then we&amp;rsquo;ll write some real-world tests that call some code that we&amp;rsquo;ve written and assert that its behavior is correct.</source>
          <target state="translated">我们将通过试验为我们生成的模板测试而不实际测试任何代码来探索测试工作方式的某些方面。然后，我们将编写一些真实的测试，这些测试将调用我们编写的某些代码，并断言其行为是正确的。</target>
        </trans-unit>
        <trans-unit id="2bdd67fc360b4185f7483b213b4f01b862aebe2c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll extract the functionality for parsing arguments into a function that &lt;code&gt;main&lt;/code&gt; will call to prepare for moving the command line parsing logic to &lt;em&gt;src/lib.rs&lt;/em&gt;. Listing 12-5 shows the new start of &lt;code&gt;main&lt;/code&gt; that calls a new function &lt;code&gt;parse_config&lt;/code&gt;, which we&amp;rsquo;ll define in &lt;em&gt;src/main.rs&lt;/em&gt; for the moment.</source>
          <target state="translated">我们将解析参数成函数提取的功能 &lt;code&gt;main&lt;/code&gt; 会调用到移动命令行解析逻辑准备&lt;em&gt;的src / lib.rs&lt;/em&gt;。清单12-5显示了 &lt;code&gt;main&lt;/code&gt; 的新起点，它调用了一个新函数 &lt;code&gt;parse_config&lt;/code&gt; ，我们现在将在&lt;em&gt;src / main.rs中&lt;/em&gt;定义该函数。</target>
        </trans-unit>
        <trans-unit id="e88c3b3a979bcfce4b1760b46e6bdec4b2d5837b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first define what we mean by the term &lt;em&gt;string&lt;/em&gt;. Rust has only one string type in the core language, which is the string slice &lt;code&gt;str&lt;/code&gt; that is usually seen in its borrowed form &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Chapter 4, we talked about &lt;em&gt;string slices&lt;/em&gt;, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program&amp;rsquo;s binary and are therefore string slices.</source>
          <target state="translated">我们将首先定义术语&lt;em&gt;字符串&lt;/em&gt;的含义。Rust在核心语言中只有一种字符串类型，即字符串切片 &lt;code&gt;str&lt;/code&gt; ，通常以借用形式 &lt;code&gt;&amp;amp;str&lt;/code&gt; 看到。在第4章中，我们讨论了&lt;em&gt;字符串切片&lt;/em&gt;，它是对存储在其他位置的一些UTF-8编码的字符串数据的引用。例如，字符串文字存储在程序的二进制文件中，因此是字符串切片。</target>
        </trans-unit>
        <trans-unit id="e0a42ef337f81f469e74c07a4e57681998929bd2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll get this error because &lt;code&gt;String&lt;/code&gt; doesn&amp;rsquo;t implement the &lt;code&gt;Draw&lt;/code&gt; trait:</source>
          <target state="translated">我们将收到此错误，因为 &lt;code&gt;String&lt;/code&gt; 没有实现 &lt;code&gt;Draw&lt;/code&gt; 特性：</target>
        </trans-unit>
        <trans-unit id="d5a20f154a16497d1d3eb9e39d468647563e6985" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; by the standard library. As always, check the standard library documentation for more information.</source>
          <target state="translated">在本节中，我们将介绍散列图的基本API，但是标准库在 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 上定义的函数中隐藏了更多东西。与往常一样，请查阅标准库文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="eac18c8869068094c6cd67d1df8b09a6dcd85f58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll have more examples of &lt;code&gt;move&lt;/code&gt; closures in Chapter 16 when we talk about concurrency. For now, here&amp;rsquo;s the code from Listing 13-12 with the &lt;code&gt;move&lt;/code&gt; keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</source>
          <target state="translated">在谈到并发时，我们 &lt;code&gt;move&lt;/code&gt; 在第16章中有更多关于移动关闭的示例。现在，这是清单13-12中的代码，在闭包定义中添加了 &lt;code&gt;move&lt;/code&gt; 关键字，并使用了矢量而不是整数，因为可以复制而不是移动整数；请注意，此代码尚未编译。</target>
        </trans-unit>
        <trans-unit id="45660693e231ee73bb1364738b13ef0ef0f19408" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a blog post workflow in an incremental way. The blog&amp;rsquo;s final functionality will look like this:</source>
          <target state="translated">我们将以增量方式实施博客文章工作流程。该博客的最终功能如下所示：</target>
        </trans-unit>
        <trans-unit id="13ede53dc0201795dcdc26b0b93f397bb66c964d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a classic beginner programming problem: a guessing game. Here&amp;rsquo;s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</source>
          <target state="translated">我们将实现一个经典的初学者编程问题：一个猜谜游戏。它是这样工作的：程序将生成一个介于1到100之间的随机整数。然后它将提示玩家输入一个猜测。输入猜测之后，程序将指示猜测是太低还是太高。如果猜测正确，游戏将显示祝贺消息并退出。</target>
        </trans-unit>
        <trans-unit id="048db9a1a62206761ce5925145fa53461a07bbf2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement this behavior by introducing a new data structure between the &lt;code&gt;ThreadPool&lt;/code&gt; and the threads that will manage this new behavior. We&amp;rsquo;ll call this data structure &lt;code&gt;Worker&lt;/code&gt;, which is a common term in pooling implementations. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&amp;rsquo;re responsible for taking those orders and filling them.</source>
          <target state="translated">我们将通过在 &lt;code&gt;ThreadPool&lt;/code&gt; 和将管理此新行为的线程之间引入新的数据结构来实现此行为。我们将这种数据结构称为 &lt;code&gt;Worker&lt;/code&gt; ，这是池实现中的常用术语。想一想在餐厅里的厨房里工作的人：工人等到顾客下订单，然后他们负责接下这些订单并填写订单。</target>
        </trans-unit>
        <trans-unit id="3d83967911dd3c9768c9078b0f1f0230b11c5179" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</source>
          <target state="translated">我们将通过添加一个附加功能来改进 &lt;code&gt;minigrep&lt;/code&gt; ：用户可以通过环境变量打开的不区分大小写搜索选项。我们可以将此功能设置为命令行选项，并要求用户在每次希望应用该功能时都输入该功能，但是我们将使用环境变量。这样做使我们的用户可以一次设置环境变量，并使所有搜索在该终端会话中不区分大小写。</target>
        </trans-unit>
        <trans-unit id="d68f5d386409006cd90ddd8d3bb0c58cf3c62419" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll leave the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; as is, returning an empty string slice. We can now have a &lt;code&gt;Post&lt;/code&gt; in the &lt;code&gt;PendingReview&lt;/code&gt; state as well as in the &lt;code&gt;Draft&lt;/code&gt; state, but we want the same behavior in the &lt;code&gt;PendingReview&lt;/code&gt; state. Listing 17-11 now works up to line 10!</source>
          <target state="translated">我们将 &lt;code&gt;content&lt;/code&gt; 方法保留在 &lt;code&gt;Post&lt;/code&gt; 上，返回一个空字符串切片。现在，我们可以在 &lt;code&gt;PendingReview&lt;/code&gt; 状态和 &lt;code&gt;Draft&lt;/code&gt; 状态下都有一个 &lt;code&gt;Post&lt;/code&gt; ，但是我们希望在 &lt;code&gt;PendingReview&lt;/code&gt; 状态下具有相同的行为。清单17-11现在可以处理第10行！</target>
        </trans-unit>
        <trans-unit id="d54b9a4076624177fb35b9a3dd76036387ec23ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&amp;rsquo;s resources and grinding the processing of requests to a halt.</source>
          <target state="translated">我们将池中的线程数限制为一小部分，以保护我们免受拒绝服务（DoS）攻击；如果我们让程序为传入的每个请求创建一个新线程，那么向服务器发出1000万个请求的人可能会由于耗尽服务器的所有资源并停止处理请求而造成破坏。</target>
        </trans-unit>
        <trans-unit id="c71f00103a62f0c5845aebe33e418eb38eb04404" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to &lt;em&gt;/sleep&lt;/em&gt; with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</source>
          <target state="translated">我们将研究处理缓慢的请求如何影响对当前服务器实现的其他请求。清单20-10实现了使用模拟的慢响应来处理&lt;em&gt;/ sleep&lt;/em&gt;的请求，这将导致服务器在响应之前休眠5秒钟。</target>
        </trans-unit>
        <trans-unit id="63d0e1907454ce3a168d379fb233f059e45940b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll receive an error because the &lt;code&gt;s&lt;/code&gt; value will still be moved into &lt;code&gt;_s&lt;/code&gt;, which prevents us from using &lt;code&gt;s&lt;/code&gt; again. However, using the underscore by itself doesn&amp;rsquo;t ever bind to the value. Listing 18-22 will compile without any errors because &lt;code&gt;s&lt;/code&gt; doesn&amp;rsquo;t get moved into &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">我们将收到一个错误消息，因为 &lt;code&gt;s&lt;/code&gt; 值仍将移至 &lt;code&gt;_s&lt;/code&gt; ，这将阻止我们再次使用 &lt;code&gt;s&lt;/code&gt; 。但是，仅使用下划线不会绑定到该值。清单18-22将编译而没有任何错误，因为 &lt;code&gt;s&lt;/code&gt; 不会移入 &lt;code&gt;_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61f9110a68d84478cf97fc80e4e62fe2b389965b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll round out this chapter by talking about the &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits and how we can use them with custom types.</source>
          <target state="translated">在本章中，我们将讨论&amp;ldquo; &lt;code&gt;Send&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Sync&lt;/code&gt; 特征以及如何将其与自定义类型一起使用。</target>
        </trans-unit>
        <trans-unit id="b07b0f8b9fff1c6b7489d1f03bbaf11c53f92f25" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&amp;rsquo;ll encode the states into different types. Consequently, Rust&amp;rsquo;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</source>
          <target state="translated">我们将向您展示如何重新思考状态模式以获得一组不同的权衡。与其完全封装状态和转换，以使外部代码不了解它们，我们将状态编码为不同的类型。因此，Rust的类型检查系统将通过发出编译器错误来阻止尝试使用仅允许发布的帖子的草稿帖子。</target>
        </trans-unit>
        <trans-unit id="627b700f2567a428c4b498681919e2e69479fc97" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll simulate calling this hypothetical algorithm with the function &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; shown in Listing 13-1, which will print &lt;code&gt;calculating slowly...&lt;/code&gt;, wait for two seconds, and then return whatever number we passed in.</source>
          <target state="translated">我们将使用清单13-1中所示的函数 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 模拟调用此假设算法，该函数将 &lt;code&gt;calculating slowly...&lt;/code&gt; 打印出...，等待两秒钟，然后返回传入的任何数字。</target>
        </trans-unit>
        <trans-unit id="5973b041f6a9740c7e6d85ca07367dbed50852e0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by getting a single-threaded web server working. Before we begin, let&amp;rsquo;s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</source>
          <target state="translated">我们将从使单线程Web服务器开始工作开始。在开始之前，让我们快速了解构建Web服务器所涉及的协议。这些协议的详细信息超出了本书的范围，但是简要概述将为您提供所需的信息。</target>
        </trans-unit>
        <trans-unit id="060170101757c33938356030dc05849b3282e228" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about each of these in turn, but first, let&amp;rsquo;s look at why we even need macros when we already have functions.</source>
          <target state="translated">我们将依次讨论它们中的每一个，但首先，让我们看一下为什么我们已经有了函数时为什么甚至需要宏。</target>
        </trans-unit>
        <trans-unit id="00042b704a4af242dc3eb83d8f9f0adbd9c9c6f2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We&amp;rsquo;ll add this functionality in a function called &lt;code&gt;search&lt;/code&gt;.</source>
          <target state="translated">我们将测试驱动该功能的实现，该功能实际上将在文件内容中搜索查询字符串并生成与查询匹配的行列表。我们将在称为 &lt;code&gt;search&lt;/code&gt; 的函数中添加此功能。</target>
        </trans-unit>
        <trans-unit id="a6a5b07486e18e4aafc4b7efa3b6df52895ecfa1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">我们在这里以 &lt;code&gt;String&lt;/code&gt; 为例，并专注于与所有权有关的 &lt;code&gt;String&lt;/code&gt; 部分。这些方面也适用于标准库提供的以及您创建的其他复杂数据类型。我们将在第8章中更深入地讨论 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f26df7e74655da28655e14a9fc6315701535f09" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">我们将以 &lt;code&gt;String&lt;/code&gt; 作为示例，并专注于与所有权有关的 &lt;code&gt;String&lt;/code&gt; 部分。这些方面也适用于其他复杂数据类型，无论它们是由标准库提供还是由您创建。我们将在第8章中更深入地讨论 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fdb67ce55cd6e4b067c62180346b3dbc3180259" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, &lt;code&gt;main&lt;/code&gt;. The standard library provides the &lt;code&gt;eprintln!&lt;/code&gt; macro that prints to the standard error stream, so let&amp;rsquo;s change the two places we were calling &lt;code&gt;println!&lt;/code&gt; to print errors to use &lt;code&gt;eprintln!&lt;/code&gt; instead.</source>
          <target state="translated">我们将使用清单12-24中的代码来更改错误消息的打印方式。由于我们在本章前面已经进行了重构，所有打印错误消息的代码都在一个函数 &lt;code&gt;main&lt;/code&gt; 中。标准库提供了 &lt;code&gt;eprintln!&lt;/code&gt; 打印到标准错误流的宏，所以让我们更改我们调用 &lt;code&gt;println!&lt;/code&gt; 的两个位置！打印错误以使用 &lt;code&gt;eprintln!&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="7be7c248999b3ea861a86839bb6847251beded8a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re allowed to change the value that &lt;code&gt;x&lt;/code&gt; binds to from &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; when &lt;code&gt;mut&lt;/code&gt; is used. In some cases, you&amp;rsquo;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</source>
          <target state="translated">使用 &lt;code&gt;mut&lt;/code&gt; 时，我们可以将 &lt;code&gt;x&lt;/code&gt; 绑定的值从 &lt;code&gt;5&lt;/code&gt; 更改为 &lt;code&gt;6&lt;/code&gt; 。在某些情况下，您将希望使变量可变，因为与仅具有不可变变量的情况相比，它使代码的编写更加方便。</target>
        </trans-unit>
        <trans-unit id="85a800cd9f89b371e568b4c783baa80e895e6025" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re creating an &lt;code&gt;IpAddr&lt;/code&gt; instance by parsing a hardcoded string. We can see that &lt;code&gt;127.0.0.1&lt;/code&gt; is a valid IP address, so it&amp;rsquo;s acceptable to use &lt;code&gt;unwrap&lt;/code&gt; here. However, having a hardcoded, valid string doesn&amp;rsquo;t change the return type of the &lt;code&gt;parse&lt;/code&gt; method: we still get a &lt;code&gt;Result&lt;/code&gt; value, and the compiler will still make us handle the &lt;code&gt;Result&lt;/code&gt; as if the &lt;code&gt;Err&lt;/code&gt; variant is a possibility because the compiler isn&amp;rsquo;t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore &lt;em&gt;did&lt;/em&gt; have a possibility of failure, we&amp;rsquo;d definitely want to handle the &lt;code&gt;Result&lt;/code&gt; in a more robust way instead.</source>
          <target state="translated">我们通过解析硬编码字符串来创建 &lt;code&gt;IpAddr&lt;/code&gt; 实例。我们可以看到 &lt;code&gt;127.0.0.1&lt;/code&gt; 是有效的IP地址，因此在这里使用 &lt;code&gt;unwrap&lt;/code&gt; 是可以接受的。但是，使用经过硬编码的有效字符串不会更改 &lt;code&gt;parse&lt;/code&gt; 方法的返回类型：我们仍然会获得 &lt;code&gt;Result&lt;/code&gt; 值，并且编译器仍将使我们像 &lt;code&gt;Err&lt;/code&gt; 变体一样处理 &lt;code&gt;Result&lt;/code&gt; ，因为编译器不是。足够聪明，可以看到此字符串始终是有效的IP地址。如果IP地址字符串来自用户而不是硬编码到程序中，因此&lt;em&gt;确实&lt;/em&gt;有失败的可能，我们肯定希望处理&lt;em&gt;&lt;/em&gt; &lt;code&gt;Result&lt;/code&gt; 而是以更可靠的方式得到结果。</target>
        </trans-unit>
        <trans-unit id="7a98461520cf94e325231f61b61fe6b7361a4963" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re getting into more complex programs in which operations can fail, so, it&amp;rsquo;s a perfect time to discuss error handling. We&amp;rsquo;ll do that next!</source>
          <target state="translated">我们正在进入更复杂的程序，在这些程序中操作可能会失败，因此，现在是讨论错误处理的理想时机。接下来，我们会做的！</target>
        </trans-unit>
        <trans-unit id="1bec095d3bfed69e34b314dbfade082c4c12b16b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re not quite done with this line of code. Although what we&amp;rsquo;ve discussed so far is a single line of text, it&amp;rsquo;s only the first part of the single logical line of code. The second part is this method:</source>
          <target state="translated">这行代码还没有完成。尽管到目前为止我们讨论的只是一行文本，但这只是逻辑代码行的第一部分。第二部分是这种方法：</target>
        </trans-unit>
        <trans-unit id="e8fdc745ba3517693a4cefb98c523891480464ad" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re now iterating over the workers twice: once to send one &lt;code&gt;Terminate&lt;/code&gt; message for each worker and once to call &lt;code&gt;join&lt;/code&gt; on each worker&amp;rsquo;s thread. If we tried to send a message and &lt;code&gt;join&lt;/code&gt; immediately in the same loop, we couldn&amp;rsquo;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</source>
          <target state="translated">现在，我们遍历工作线程两次：一次为每个工作线程发送一个 &lt;code&gt;Terminate&lt;/code&gt; 消息，一次在每个工作线程上调用 &lt;code&gt;join&lt;/code&gt; 。如果我们尝试发送消息并立即 &lt;code&gt;join&lt;/code&gt; 同一循环中，则无法保证当前迭代中的工作程序将是从通道中获取消息的工作程序。</target>
        </trans-unit>
        <trans-unit id="3043bedf342450c930adba158d22a65820a93654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the &lt;code&gt;baby_name&lt;/code&gt; method from the &lt;code&gt;Animal&lt;/code&gt; trait as implemented on &lt;code&gt;Dog&lt;/code&gt; by saying that we want to treat the &lt;code&gt;Dog&lt;/code&gt; type as an &lt;code&gt;Animal&lt;/code&gt; for this function call. This code will now print what we want:</source>
          <target state="translated">我们在尖括号内为Rust提供类型注释，这表示我们要通过对 &lt;code&gt;Dog&lt;/code&gt; 实施的 &lt;code&gt;Animal&lt;/code&gt; 特质来调用 &lt;code&gt;baby_name&lt;/code&gt; 方法，方法是说我们希望此函数调用将 &lt;code&gt;Dog&lt;/code&gt; 类型视为 &lt;code&gt;Animal&lt;/code&gt; 。现在，此代码将打印出我们想要的内容：</target>
        </trans-unit>
        <trans-unit id="4ddf3a6c4a7ff9bc3976c2dddb0193cf3c8094f5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re receiving only warnings now, which means it compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="translated">现在我们只收到警告，这意味着它可以编译！但是请注意，如果您尝试 &lt;code&gt;cargo run&lt;/code&gt; 并在浏览器中提出请求，您将在本章开头看到的浏览器中看到错误。我们的库实际上并没有调用传递给 &lt;code&gt;execute&lt;/code&gt; 的闭包！</target>
        </trans-unit>
        <trans-unit id="39e24358659ae04dcbe82e2100b6975e897d6a38" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable &lt;code&gt;query&lt;/code&gt; and the argument value at index 2 to the variable &lt;code&gt;filename&lt;/code&gt; within the &lt;code&gt;main&lt;/code&gt; function, we pass the whole vector to the &lt;code&gt;parse_config&lt;/code&gt; function. The &lt;code&gt;parse_config&lt;/code&gt; function then holds the logic that determines which argument goes in which variable and passes the values back to &lt;code&gt;main&lt;/code&gt;. We still create the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables in &lt;code&gt;main&lt;/code&gt;, but &lt;code&gt;main&lt;/code&gt; no longer has the responsibility of determining how the command line arguments and variables correspond.</source>
          <target state="translated">我们仍将命令行参数收集到向量中，但没有将索引1的参数值分配给变量 &lt;code&gt;query&lt;/code&gt; ，而是将索引2的参数值分配给了 &lt;code&gt;main&lt;/code&gt; 函数中的变量 &lt;code&gt;filename&lt;/code&gt; ，而是将整个向量传递给了 &lt;code&gt;parse_config&lt;/code&gt; 函数。然后， &lt;code&gt;parse_config&lt;/code&gt; 函数包含确定哪个参数进入哪个变量并将值传递回 &lt;code&gt;main&lt;/code&gt; 的逻辑。我们仍然在 &lt;code&gt;main&lt;/code&gt; 中创建 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 变量，但是 &lt;code&gt;main&lt;/code&gt; 不再负责确定命令行参数和变量如何对应。</target>
        </trans-unit>
        <trans-unit id="6a2a09503d50f0f83deb42b9b3c8d235d3d20cd7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still using a &lt;code&gt;for&lt;/code&gt; loop to return each line from &lt;code&gt;search&lt;/code&gt; and print it.</source>
          <target state="translated">我们仍在使用 &lt;code&gt;for&lt;/code&gt; 循环从 &lt;code&gt;search&lt;/code&gt; 返回每一行并打印出来。</target>
        </trans-unit>
        <trans-unit id="704d6708be51c898fd0ee7c005925dabd11417ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still working on this line of code. Although we&amp;rsquo;re now discussing a third line of text, it&amp;rsquo;s still part of a single logical line of code. The next part is this method:</source>
          <target state="translated">我们仍在处理这一行代码。尽管我们现在正在讨论文本的第三行，但它仍然是单逻辑代码行的一部分。下一部分是这种方法：</target>
        </trans-unit>
        <trans-unit id="c5dc7c10dc508f133971e52b437dcfabc8c9d8d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using another variation of the &lt;code&gt;List&lt;/code&gt; definition from Listing 15-5. The second element in the &lt;code&gt;Cons&lt;/code&gt; variant is now &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt;, meaning that instead of having the ability to modify the &lt;code&gt;i32&lt;/code&gt; value as we did in Listing 15-24, we want to modify which &lt;code&gt;List&lt;/code&gt; value a &lt;code&gt;Cons&lt;/code&gt; variant is pointing to. We&amp;rsquo;re also adding a &lt;code&gt;tail&lt;/code&gt; method to make it convenient for us to access the second item if we have a &lt;code&gt;Cons&lt;/code&gt; variant.</source>
          <target state="translated">我们使用清单15-5中 &lt;code&gt;List&lt;/code&gt; 定义的另一个变体。 &lt;code&gt;Cons&lt;/code&gt; 变量中的第二个元素现在是 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; ，这意味着我们不能像清单15-24那样修改 &lt;code&gt;i32&lt;/code&gt; 值，而是要修改 &lt;code&gt;Cons&lt;/code&gt; 变量指向哪个 &lt;code&gt;List&lt;/code&gt; 值。至。如果有 &lt;code&gt;Cons&lt;/code&gt; 变体，我们还添加了 &lt;code&gt;tail&lt;/code&gt; 方法，以方便我们访问第二项。</target>
        </trans-unit>
        <trans-unit id="e0c173af0bd25448bf48e4ff0f52351084a37793" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using the &lt;code&gt;is_err&lt;/code&gt; method on the &lt;code&gt;Result&lt;/code&gt; to check whether it&amp;rsquo;s an error and therefore unset, which means it &lt;em&gt;should&lt;/em&gt; do a case-sensitive search. If the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable is set to anything, &lt;code&gt;is_err&lt;/code&gt; will return false and the program will perform a case-insensitive search. We don&amp;rsquo;t care about the &lt;em&gt;value&lt;/em&gt; of the environment variable, just whether it&amp;rsquo;s set or unset, so we&amp;rsquo;re checking &lt;code&gt;is_err&lt;/code&gt; rather than using &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, or any of the other methods we&amp;rsquo;ve seen on &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">我们在 &lt;code&gt;Result&lt;/code&gt; 上使用 &lt;code&gt;is_err&lt;/code&gt; 方法来检查是否为错误并因此未设置，这意味着它&lt;em&gt;应该&lt;/em&gt;进行区分大小写的搜索。如果将 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 环境变量设置为任何值，则 &lt;code&gt;is_err&lt;/code&gt; 将返回false，并且程序将执行不区分大小写的搜索。我们不关心&lt;em&gt;值&lt;/em&gt;的环境变量，只是无论是设置或取消，所以我们正在检查 &lt;code&gt;is_err&lt;/code&gt; 而不是使用 &lt;code&gt;unwrap&lt;/code&gt; ， &lt;code&gt;expect&lt;/code&gt; 或任何我们所见过的其他方法 &lt;code&gt;Result&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d56b97467af5db84c05cb413a5fabde32de08385" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve actually already used statements and expressions. &lt;em&gt;Statements&lt;/em&gt; are instructions that perform some action and do not return a value. &lt;em&gt;Expressions&lt;/em&gt; evaluate to a resulting value. Let&amp;rsquo;s look at some examples.</source>
          <target state="translated">我们实际上已经使用过语句和表达式。&lt;em&gt;语句&lt;/em&gt;是执行某些操作且不返回值的指令。&lt;em&gt;表达式的&lt;/em&gt;计算结果为结果值。让我们看一些例子。</target>
        </trans-unit>
        <trans-unit id="d8fc6748175101658632d95f9debdd96c25d44d2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each file in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">我们已经在代码的顶部添加了 &lt;code&gt;use adder&lt;/code&gt; ，而在单元测试中则不需要。原因是 &lt;code&gt;tests&lt;/code&gt; 目录中的每个文件都是一个单独的板条箱，因此我们需要将我们的库放入每个测试板条箱的范围内。</target>
        </trans-unit>
        <trans-unit id="c22b2164f8306680aed3e27380f526ec1c6ded84" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each test in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">我们已经在代码的顶部添加了 &lt;code&gt;use adder&lt;/code&gt; ，而在单元测试中则不需要。原因是 &lt;code&gt;tests&lt;/code&gt; 目录中的每个测试都是一个单独的板条箱，因此我们需要将我们的库放入每个测试板条箱的范围内。</target>
        </trans-unit>
        <trans-unit id="584b8b954ee114612008442a8b00d97910ff6eab" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a line at the top to bring the standard library&amp;rsquo;s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.</source>
          <target state="translated">我们在顶部添加了一行，以将标准库的文件系统模块纳入范围。用于将文件内容读取为字符串的代码应该看起来很熟悉；在清单12-4中读取I / O项目文件的内容时，我们在第12章中使用了它。</target>
        </trans-unit>
        <trans-unit id="4c87cb387453e91590c14806fac036a23f89422e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new &lt;code&gt;use&lt;/code&gt; line to bring &lt;code&gt;process&lt;/code&gt; from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the &lt;code&gt;err&lt;/code&gt; value and then call &lt;code&gt;process::exit&lt;/code&gt;. The &lt;code&gt;process::exit&lt;/code&gt; function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the &lt;code&gt;panic!&lt;/code&gt;-based handling we used in Listing 12-8, but we no longer get all the extra output. Let&amp;rsquo;s try it:</source>
          <target state="translated">我们添加了一条新的 &lt;code&gt;use&lt;/code&gt; 线，以将标准库中的 &lt;code&gt;process&lt;/code&gt; 引入范围。在错误情况下将运行的闭包中的代码只有两行：我们打印 &lt;code&gt;err&lt;/code&gt; 值，然后调用 &lt;code&gt;process::exit&lt;/code&gt; 。该 &lt;code&gt;process::exit&lt;/code&gt; 功能将立即停止该程序并返回被作为退出状态代码传递的数量。这类似于 &lt;code&gt;panic!&lt;/code&gt; 清单12-8中使用了基于的处理，但不再获得所有多余的输出。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="7cffa1b480aa410c1dc47385712cedb9b3949a57" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a struct named &lt;code&gt;Config&lt;/code&gt; defined to have fields named &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;. The signature of &lt;code&gt;parse_config&lt;/code&gt; now indicates that it returns a &lt;code&gt;Config&lt;/code&gt; value. In the body of &lt;code&gt;parse_config&lt;/code&gt;, where we used to return string slices that reference &lt;code&gt;String&lt;/code&gt; values in &lt;code&gt;args&lt;/code&gt;, we now define &lt;code&gt;Config&lt;/code&gt; to contain owned &lt;code&gt;String&lt;/code&gt; values. The &lt;code&gt;args&lt;/code&gt; variable in &lt;code&gt;main&lt;/code&gt; is the owner of the argument values and is only letting the &lt;code&gt;parse_config&lt;/code&gt; function borrow them, which means we&amp;rsquo;d violate Rust&amp;rsquo;s borrowing rules if &lt;code&gt;Config&lt;/code&gt; tried to take ownership of the values in &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">我们添加了一个名为 &lt;code&gt;Config&lt;/code&gt; 的结构体，该结构体具有名为 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 的字段。现在， &lt;code&gt;parse_config&lt;/code&gt; 的签名表明它返回了 &lt;code&gt;Config&lt;/code&gt; 值。在 &lt;code&gt;parse_config&lt;/code&gt; 的主体中，我们曾经用来返回引用 &lt;code&gt;args&lt;/code&gt; 中的 &lt;code&gt;String&lt;/code&gt; 值的字符串切片，现在我们将 &lt;code&gt;Config&lt;/code&gt; 定义为包含拥有的 &lt;code&gt;String&lt;/code&gt; 值。 &lt;code&gt;main&lt;/code&gt; 中的 &lt;code&gt;args&lt;/code&gt; 变量是参数值的所有者，并且只允许 &lt;code&gt;parse_config&lt;/code&gt; 函数借用它们，这意味着如果 &lt;code&gt;Config&lt;/code&gt; 违反了Rust的借用规则试图取得 &lt;code&gt;args&lt;/code&gt; 中的值的所有权。</target>
        </trans-unit>
        <trans-unit id="1885fbfa7b60233a91c017c818f49ba0e7b6f717" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added some documentation for our &lt;code&gt;ThreadPool&lt;/code&gt; with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running &lt;code&gt;cargo doc --open&lt;/code&gt; and clicking the &lt;code&gt;ThreadPool&lt;/code&gt; struct to see what the generated docs for &lt;code&gt;new&lt;/code&gt; look like!</source>
          <target state="translated">我们为 &lt;code&gt;ThreadPool&lt;/code&gt; 添加了一些文档注释文档。请注意，我们遵循良好的文档惯例，添加了一节，指出了函数可能出现紧急情况的情况，如第14章中所述。尝试运行 &lt;code&gt;cargo doc --open&lt;/code&gt; 并单击 &lt;code&gt;ThreadPool&lt;/code&gt; 结构，以查看生成的文档具有 &lt;code&gt;new&lt;/code&gt; 外观喜欢！</target>
        </trans-unit>
        <trans-unit id="033bfc676c905568043c961c9b266296859d8c02" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added the &lt;code&gt;request_review&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait; all types that implement the trait will now need to implement the &lt;code&gt;request_review&lt;/code&gt; method. Note that rather than having &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter of the method, we have &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. This syntax means the method is only valid when called on a &lt;code&gt;Box&lt;/code&gt; holding the type. This syntax takes ownership of &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, invalidating the old state so the state value of the &lt;code&gt;Post&lt;/code&gt; can transform into a new state.</source>
          <target state="translated">我们已将 &lt;code&gt;request_review&lt;/code&gt; 方法添加到 &lt;code&gt;State&lt;/code&gt; trait；现在，实现该特征的所有类型都将需要实现 &lt;code&gt;request_review&lt;/code&gt; 方法。请注意，我们没有将 &lt;code&gt;self&lt;/code&gt; ， &lt;code&gt;&amp;amp;self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 作为方法的第一个参数，而是使用了 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 。这种语法意味着该方法仅在持有该类型的 &lt;code&gt;Box&lt;/code&gt; 上调用时才有效。此语法采用 &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; 所有权，从而使旧状态无效，因此 &lt;code&gt;Post&lt;/code&gt; 的状态值可以转换为新状态。</target>
        </trans-unit>
        <trans-unit id="c2d6bca1ece5398cc0aaa45cdd8c28d538813cdf" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already encountered a few smart pointers in this book, such as &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in Chapter 8, although we didn&amp;rsquo;t call them smart pointers at the time. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with &lt;code&gt;String&lt;/code&gt; ensuring its data will always be valid UTF-8).</source>
          <target state="translated">在本书中，我们已经遇到了一些智能指针，例如第8章中的 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，尽管我们当时没有称它们为智能指针。这两种类型都算作智能指针，因为它们拥有一些内存并允许您对其进行操作。它们还具有元数据（例如其容量）和额外的功能或保证（例如使用 &lt;code&gt;String&lt;/code&gt; 来确保其数据始终是有效的UTF-8）。</target>
        </trans-unit>
        <trans-unit id="5f665940216ffe5d50883d2554e20cbd268101e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren&amp;rsquo;t suitable for every situation in which we may want to use text. One reason is that they&amp;rsquo;re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, &lt;code&gt;String&lt;/code&gt;. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a &lt;code&gt;String&lt;/code&gt; from a string literal using the &lt;code&gt;from&lt;/code&gt; function, like so:</source>
          <target state="translated">我们已经看到了字符串文字，其中字符串值被硬编码到我们的程序中。字符串文字很方便，但是它们并不适合我们可能要使用文本的每种情况。原因之一是它们是不可变的。另一个是在编写代码时并不是每个字符串值都可以知道的：例如，如果我们想接受用户输入并存储它，该怎么办？对于这些情况，Rust具有第二个字符串类型 &lt;code&gt;String&lt;/code&gt; 。这种类型在堆上分配，因此能够存储在编译时我们不知道的大量文本。您可以创建一个 &lt;code&gt;String&lt;/code&gt; 字面使用从一个字符串 &lt;code&gt;from&lt;/code&gt; 函数，比如：</target>
        </trans-unit>
        <trans-unit id="afec387c328832d115c9aaceeb2e235c2cecfd8f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve brought &lt;code&gt;std::thread&lt;/code&gt; into scope in the library crate, because we&amp;rsquo;re using &lt;code&gt;thread::JoinHandle&lt;/code&gt; as the type of the items in the vector in &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">我们将 &lt;code&gt;std::thread&lt;/code&gt; 放入库箱的作用域中，因为我们在 &lt;code&gt;ThreadPool&lt;/code&gt; 中使用 &lt;code&gt;thread::JoinHandle&lt;/code&gt; 作为向量中项目的类型。</target>
        </trans-unit>
        <trans-unit id="d06c508a695440c6e3d61967e906e12cd55df3a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve changed the name of the field on &lt;code&gt;ThreadPool&lt;/code&gt; from &lt;code&gt;threads&lt;/code&gt; to &lt;code&gt;workers&lt;/code&gt; because it&amp;rsquo;s now holding &lt;code&gt;Worker&lt;/code&gt; instances instead of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances. We use the counter in the &lt;code&gt;for&lt;/code&gt; loop as an argument to &lt;code&gt;Worker::new&lt;/code&gt;, and we store each new &lt;code&gt;Worker&lt;/code&gt; in the vector named &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">我们已经将 &lt;code&gt;ThreadPool&lt;/code&gt; 上的字段名称从 &lt;code&gt;threads&lt;/code&gt; 更改为 &lt;code&gt;workers&lt;/code&gt; 因为它现在持有 &lt;code&gt;Worker&lt;/code&gt; 实例而不是 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 实例。我们将 &lt;code&gt;for&lt;/code&gt; 循环中的计数器用作 &lt;code&gt;Worker::new&lt;/code&gt; 的参数，并将每个新 &lt;code&gt;Worker&lt;/code&gt; 存储在名为 &lt;code&gt;workers&lt;/code&gt; 的向量中。</target>
        </trans-unit>
        <trans-unit id="b6773f3d57e1c56123d2fb2caa6f401e95f3ea12" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve chosen &lt;code&gt;&amp;amp;self&lt;/code&gt; here for the same reason we used &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; in the function version: we don&amp;rsquo;t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we&amp;rsquo;ve called the method on as part of what the method does, we&amp;rsquo;d use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter. Having a method that takes ownership of the instance by using just &lt;code&gt;self&lt;/code&gt; as the first parameter is rare; this technique is usually used when the method transforms &lt;code&gt;self&lt;/code&gt; into something else and you want to prevent the caller from using the original instance after the transformation.</source>
          <target state="translated">我们在这里选择 &lt;code&gt;&amp;amp;self&lt;/code&gt; 的原因 &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; 在函数版本中使用＆Rectangle的原因相同：我们不想获得所有权，我们只想读取结构中的数据，而不是对其进行写入。如果我们想在方法执行的过程中更改调用该方法的实例，则可以使用 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 作为第一个参数。很少有一种方法只使用 &lt;code&gt;self&lt;/code&gt; 作为第一个参数来获取实例的所有权；该方法通常在方法将 &lt;code&gt;self&lt;/code&gt; 转换为其他形式并且要防止调用者在转换后使用原始实例时使用。</target>
        </trans-unit>
        <trans-unit id="c1db49e2d4e1cde132781769873263a6ad0787ce" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve created raw pointers by using &lt;code&gt;as&lt;/code&gt; to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&amp;rsquo;t make that assumption about just any raw pointer.</source>
          <target state="translated">我们通过使用 &lt;code&gt;as&lt;/code&gt; 将不可变和可变引用转换为相应的原始指针类型来创建原始指针。因为我们直接从保证有效的引用中创建了它们，所以我们知道这些特定的原始指针是有效的，但是我们不能仅对任何原始指针进行假设。</target>
        </trans-unit>
        <trans-unit id="bffcb1376e08b8bdf566e588ca56d6643d86c91b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</source>
          <target state="translated">我们定义了一个宏，该宏可以接受任意数量的任何类型的参数，并且可以生成代码以创建包含指定元素的向量。</target>
        </trans-unit>
        <trans-unit id="51c190acab3ae3b5901bd943815d252d578b8d41" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they&amp;rsquo;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</source>
          <target state="translated">我们已经在本章中描述了大多数高级功能，这些功能很少需要。关联类型位于中间位置：它们比本书其余部分所介绍的功能使用得很少，但比本章中讨论的许多其他功能更常用。</target>
        </trans-unit>
        <trans-unit id="06deefd5074e90766703296697ebf8ccb43b0e5d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve destructured enums earlier in this book, for example, when we destructured &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; in Listing 6-5 in Chapter 6. One detail we haven&amp;rsquo;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the &lt;code&gt;Message&lt;/code&gt; enum from Listing 6-2 and write a &lt;code&gt;match&lt;/code&gt; with patterns that will destructure each inner value.</source>
          <target state="translated">例如，当我们在第6章的清单6-5中对 &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; 进行结构化时，我们已经在本书的前面对结构进行了解构。定义了枚举中存储的数据。例如，在清单18-15中，我们使用清单6-2中的 &lt;code&gt;Message&lt;/code&gt; 枚举，并编写一个具有将破坏每个内部值的模式的 &lt;code&gt;match&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6277ca606742a1b968d8228027cda7b90d3f30" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, it will not compile.</source>
          <target state="translated">我们已经给出了代码！这段代码是完全有效的，尽管它意味着我们不能在没有错误的情况下使用不可辩驳的模式。如果我们给 &lt;code&gt;if let&lt;/code&gt; 一个模式，将总是一致的，如 &lt;code&gt;x&lt;/code&gt; ，如图18-10所示，它不会编译。</target>
        </trans-unit>
        <trans-unit id="78dee02791985c19ffc271569fd60c5a8fc8dade" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, the compiler will give a warning.</source>
          <target state="translated">我们已经给出了代码！这段代码是完全有效的，尽管它意味着我们不能在没有错误的情况下使用不可辩驳的模式。如果我们给出 &lt;code&gt;if let&lt;/code&gt; 来始终匹配的模式，如 &lt;code&gt;x&lt;/code&gt; ，如清单18-10所示，则编译器将发出警告。</target>
        </trans-unit>
        <trans-unit id="9288497ed026aec5cddf626c274f65076b889591" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve hardcoded the variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; as 10 and the variable &lt;code&gt;simulated_random_number&lt;/code&gt; as 7 for simplicity&amp;rsquo;s sake; in an actual program, we&amp;rsquo;d get the intensity number from the app frontend, and we&amp;rsquo;d use the &lt;code&gt;rand&lt;/code&gt; crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The &lt;code&gt;main&lt;/code&gt; function calls a &lt;code&gt;generate_workout&lt;/code&gt; function with the simulated input values.</source>
          <target state="translated">为了简单起见，我们已将变量 &lt;code&gt;simulated_user_specified_value&lt;/code&gt; 硬编码为10，并将变量 &lt;code&gt;simulated_random_number&lt;/code&gt; 硬编码为7。在实际的程序，我们会得到从应用程序前端强度号码，我们会使用 &lt;code&gt;rand&lt;/code&gt; 箱子生成一个随机数字，我们在划拳例如，在第2章所做的 &lt;code&gt;main&lt;/code&gt; 功能调用 &lt;code&gt;generate_workout&lt;/code&gt; 功能与模拟输入值。</target>
        </trans-unit>
        <trans-unit id="5e36cd45124891f0ced7a53981629ff72590f283" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve introduced three new crates: &lt;code&gt;proc_macro&lt;/code&gt;, &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate comes with Rust, so we didn&amp;rsquo;t need to add that to the dependencies in &lt;em&gt;Cargo.toml&lt;/em&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate is the compiler&amp;rsquo;s API that allows us to read and manipulate Rust code from our code.</source>
          <target state="translated">我们引入了三个新的板条箱： &lt;code&gt;proc_macro&lt;/code&gt; ，&lt;a href=&quot;https://crates.io/crates/syn&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://crates.io/crates/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt;。该 &lt;code&gt;proc_macro&lt;/code&gt; 箱带有铁锈，所以我们并不需要将它添加到依赖&lt;em&gt;Cargo.toml&lt;/em&gt;。该 &lt;code&gt;proc_macro&lt;/code&gt; 箱子是编译器的API，使我们能够阅读和我们的代码操作锈病代码。</target>
        </trans-unit>
        <trans-unit id="0ad45439c6472977b496b46c9e8ec344b7d03941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made liberal use of the &lt;code&gt;pub&lt;/code&gt; keyword: on &lt;code&gt;Config&lt;/code&gt;, on its fields and its &lt;code&gt;new&lt;/code&gt; method, and on the &lt;code&gt;run&lt;/code&gt; function. We now have a library crate that has a public API that we can test!</source>
          <target state="translated">我们自由使用了 &lt;code&gt;pub&lt;/code&gt; 关键字： &lt;code&gt;Config&lt;/code&gt; ，其字段及其 &lt;code&gt;new&lt;/code&gt; 方法以及 &lt;code&gt;run&lt;/code&gt; 函数。现在，我们有了一个带有公共API的库箱，我们可以对其进行测试！</target>
        </trans-unit>
        <trans-unit id="93d9e35440edfc2a27a289759d47f3243926cd99" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made some small and straightforward changes: we pass the receiving end of the channel into &lt;code&gt;Worker::new&lt;/code&gt;, and then we use it inside the closure.</source>
          <target state="translated">我们进行了一些小而直接的更改：将通道的接收端传递给 &lt;code&gt;Worker::new&lt;/code&gt; ，然后在闭包内部使用它。</target>
        </trans-unit>
        <trans-unit id="56995a6860da00dba94b79267ee87621a35cfd58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made three significant changes here. First, we changed the return type of the &lt;code&gt;run&lt;/code&gt; function to &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt;. This function previously returned the unit type, &lt;code&gt;()&lt;/code&gt;, and we keep that as the value returned in the &lt;code&gt;Ok&lt;/code&gt; case.</source>
          <target state="translated">我们在这里进行了三项重大更改。首先，我们将 &lt;code&gt;run&lt;/code&gt; 函数的返回类型更改为 &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt; 。该函数先前返回了单位类型 &lt;code&gt;()&lt;/code&gt; ，我们将其保留为 &lt;code&gt;Ok&lt;/code&gt; 情况下返回的值。</target>
        </trans-unit>
        <trans-unit id="7aef292d2641df4649db03b9163b74c003c21be2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made two changes in the body of the &lt;code&gt;new&lt;/code&gt; function: instead of calling &lt;code&gt;panic!&lt;/code&gt; when the user doesn&amp;rsquo;t pass enough arguments, we now return an &lt;code&gt;Err&lt;/code&gt; value, and we&amp;rsquo;ve wrapped the &lt;code&gt;Config&lt;/code&gt; return value in an &lt;code&gt;Ok&lt;/code&gt;. These changes make the function conform to its new type signature.</source>
          <target state="translated">我们在 &lt;code&gt;new&lt;/code&gt; 函数的主体中进行了两项更改：而不是调用 &lt;code&gt;panic!&lt;/code&gt; 当用户未传递足够的参数时，我们现在返回 &lt;code&gt;Err&lt;/code&gt; 值，并将 &lt;code&gt;Config&lt;/code&gt; 返回值包装在 &lt;code&gt;Ok&lt;/code&gt; 中。这些更改使函数符合其新类型签名。</target>
        </trans-unit>
        <trans-unit id="be1fafd103cb85a28b4ca20cff35d635b76880a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve mentioned that in Rust, we refrain from calling structs and enums &amp;ldquo;objects&amp;rdquo; to distinguish them from other languages&amp;rsquo; objects. In a struct or enum, the data in the struct fields and the behavior in &lt;code&gt;impl&lt;/code&gt; blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects &lt;em&gt;are&lt;/em&gt; more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can&amp;rsquo;t add data to a trait object. Trait objects aren&amp;rsquo;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</source>
          <target state="translated">我们已经提到过，在Rust中，我们避免调用结构和枚举&amp;ldquo;对象&amp;rdquo;来将它们与其他语言的对象区分开。在结构或枚举中，结构字段中的数据和 &lt;code&gt;impl&lt;/code&gt; 块中的行为是分开的，而在其他语言中，组合为一个概念的数据和行为通常被标记为对象。然而，特质对象&lt;em&gt;是&lt;/em&gt;更像是在这个意义上其他语言的对象，他们结合数据和行为。但是特征对象与传统对象的不同之处在于我们无法向特征对象添加数据。特性对象通常没有其他语言中的对象有用：它们的特定目的是允许对常见行为进行抽象。</target>
        </trans-unit>
        <trans-unit id="d6a7a8ffdb70b17f8f4c294d0eea3a1bf35ddd50" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve moved the creation of the new &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; to the beginning of the function; that part hasn&amp;rsquo;t changed. Instead of creating a variable &lt;code&gt;f&lt;/code&gt;, we&amp;rsquo;ve chained the call to &lt;code&gt;read_to_string&lt;/code&gt; directly onto the result of &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt;. We still have a &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call, and we still return an &lt;code&gt;Ok&lt;/code&gt; value containing the username in &lt;code&gt;s&lt;/code&gt; when both &lt;code&gt;File::open&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.</source>
          <target state="translated">我们已经搬到新创建 &lt;code&gt;String&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 给函数的开始;那部分没有改变。而不是创建变量 &lt;code&gt;f&lt;/code&gt; ，我们 &lt;code&gt;read_to_string&lt;/code&gt; 的调用直接链接到 &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt; 。我们还有一个 &lt;code&gt;?&lt;/code&gt; 在 &lt;code&gt;read_to_string&lt;/code&gt; 调用的末尾，当 &lt;code&gt;File::open&lt;/code&gt; 和 &lt;code&gt;read_to_string&lt;/code&gt; 都成功而不返回错误时，我们仍然返回一个包含 &lt;code&gt;s&lt;/code&gt; 中用户名的 &lt;code&gt;Ok&lt;/code&gt; 值。功能再次与清单9-6和清单9-7相同；这只是一种不同的，更符合人体工程学的编写方式。</target>
        </trans-unit>
        <trans-unit id="c8159737415ba1d5840c5d1dcfa32d246b649654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve named our test &lt;code&gt;larger_can_hold_smaller&lt;/code&gt;, and we&amp;rsquo;ve created the two &lt;code&gt;Rectangle&lt;/code&gt; instances that we need. Then we called the &lt;code&gt;assert!&lt;/code&gt; macro and passed it the result of calling &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt;. This expression is supposed to return &lt;code&gt;true&lt;/code&gt;, so our test should pass. Let&amp;rsquo;s find out!</source>
          <target state="translated">我们将测试命名为 &lt;code&gt;larger_can_hold_smaller&lt;/code&gt; ，并创建了我们需要的两个 &lt;code&gt;Rectangle&lt;/code&gt; 实例。然后我们叫 &lt;code&gt;assert!&lt;/code&gt; 宏并将其传递给调用 &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt; 。该表达式应该返回 &lt;code&gt;true&lt;/code&gt; ，因此我们的测试应该通过。让我们找出答案！</target>
        </trans-unit>
        <trans-unit id="eb03fca51e0258eda1b9da34ca6053fc2fa793f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We&amp;rsquo;ve shown how the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type helps you use the type system to prevent errors. When enum values have data inside them, you can use &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to extract and use those values, depending on how many cases you need to handle.</source>
          <target state="translated">现在，我们已经介绍了如何使用枚举创建自定义类型，这些自定义类型可以是一组枚举值中的一个。我们已经展示了标准库的 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 类型如何帮助您使用类型系统来防止错误。当枚举值中包含数据时，您可以使用 &lt;code&gt;match&lt;/code&gt; ,或者 &lt;code&gt;if let&lt;/code&gt; 我们提取和使用这些值，具体取决于您需要处理多少种情况。</target>
        </trans-unit>
        <trans-unit id="2ddb2aa6e11b76709deea3ac27493aedd396c368" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&amp;rsquo;s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won&amp;rsquo;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&amp;rsquo;t have.</source>
          <target state="translated">我们已经看到，即使Rust能够实现面向对象的设计模式，Rust中也可以使用其他模式，例如将状态编码到类型系统中。这些模式具有不同的权衡。尽管您可能非常熟悉面向对象的模式，但是重新考虑问题以利用Rust的功能可以带来好处，例如防止在编译时出现一些错误。由于某些功能（例如所有权）是面向对象语言所不具备的，因此面向对象模式并非总是Rust中最好的解决方案。</target>
        </trans-unit>
        <trans-unit id="4a3393f5cdb05fd0ee1656e458d53bb37965c9bd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;the standard library has a definition we can use!&lt;/a&gt; Let&amp;rsquo;s look at how the standard library defines &lt;code&gt;IpAddr&lt;/code&gt;: it has the exact enum and variants that we&amp;rsquo;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</source>
          <target state="translated">我们已经展示了几种不同的方式来定义数据结构以存储第四版和第六版IP地址。然而，事实证明，想要存储IP地址并对其进行编码非常普遍，以至于&lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;标准库有一个我们可以使用的定义！&lt;/a&gt;让我们看一下标准库如何定义 &lt;code&gt;IpAddr&lt;/code&gt; ：它具有我们定义和使用的确切枚举和变量，但它以两种不同的结构形式将地址数据嵌入变量中，每种结构的定义都不同：</target>
        </trans-unit>
        <trans-unit id="29dedc9579ea7a2e3397effb70664bac84882984" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on &lt;code&gt;Post&lt;/code&gt; know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the &lt;code&gt;State&lt;/code&gt; trait on the &lt;code&gt;Published&lt;/code&gt; struct.</source>
          <target state="translated">我们已经证明，Rust能够实现面向对象的状态模式，以封装帖子在每种状态下应该具有的各种行为。 &lt;code&gt;Post&lt;/code&gt; 上的方法对各种行为一无所知。我们组织代码的方式，我们只需要查看一个地方即可知道已发布帖子的不同行为方式：在已 &lt;code&gt;Published&lt;/code&gt; 结构上实现 &lt;code&gt;State&lt;/code&gt; 特质。</target>
        </trans-unit>
        <trans-unit id="ebc522f12982267dfc02e6dcc67a8d4e642dabf5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that you can create an iterator by calling &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;into_iter&lt;/code&gt;, or &lt;code&gt;iter_mut&lt;/code&gt; on a vector. You can create iterators from the other collection types in the standard library, such as hash map. You can also create iterators that do anything you want by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait on your own types. As previously mentioned, the only method you&amp;rsquo;re required to provide a definition for is the &lt;code&gt;next&lt;/code&gt; method. Once you&amp;rsquo;ve done that, you can use all other methods that have default implementations provided by the &lt;code&gt;Iterator&lt;/code&gt; trait!</source>
          <target state="translated">我们已经展示了可以通过在向量上调用 &lt;code&gt;iter&lt;/code&gt; ， &lt;code&gt;into_iter&lt;/code&gt; 或 &lt;code&gt;iter_mut&lt;/code&gt; 来创建迭代器。您可以从标准库中的其他集合类型（例如哈希映射）创建迭代器。您还可以通过在自己的类型上实现 &lt;code&gt;Iterator&lt;/code&gt; 特质来创建可以执行任何操作的迭代器。如前所述，唯一需要提供定义的方法是 &lt;code&gt;next&lt;/code&gt; 方法。完成此操作后，您可以使用具有 &lt;code&gt;Iterator&lt;/code&gt; 特性提供的默认实现的所有其他方法！</target>
        </trans-unit>
        <trans-unit id="b66581e28df90aa77932dec55a52d6260ebfbe34" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you&amp;rsquo;ve already defined rather than defining a new closure. Doing this with function pointers will allow you to use functions as arguments to other functions. Functions coerce to the type &lt;code&gt;fn&lt;/code&gt; (with a lowercase f), not to be confused with the &lt;code&gt;Fn&lt;/code&gt; closure trait. The &lt;code&gt;fn&lt;/code&gt; type is called a &lt;em&gt;function pointer&lt;/em&gt;. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</source>
          <target state="translated">我们已经讨论了如何将闭包传递给函数。您还可以将常规函数传递给函数！当您要传递已经定义的函数而不是定义新的闭包时，此技术很有用。使用函数指针执行此操作将使您可以将函数用作其他函数的参数。函数强制转换为 &lt;code&gt;fn&lt;/code&gt; 类型（带有小写的f），不要与 &lt;code&gt;Fn&lt;/code&gt; 闭包特征相混淆。该 &lt;code&gt;fn&lt;/code&gt; 类型称为&lt;em&gt;函数指针&lt;/em&gt;。用于指定参数为函数指针的语法类似于闭包的语法，如清单19-27所示。</target>
        </trans-unit>
        <trans-unit id="44c2c6bad4c34dbea054ba65f353232e3b4bb941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; so it places the instance of &lt;code&gt;Config&lt;/code&gt; returned by &lt;code&gt;parse_config&lt;/code&gt; into a variable named &lt;code&gt;config&lt;/code&gt;, and we updated the code that previously used the separate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables so it now uses the fields on the &lt;code&gt;Config&lt;/code&gt; struct instead.</source>
          <target state="translated">我们已经更新了 &lt;code&gt;main&lt;/code&gt; ,因此将 &lt;code&gt;parse_config&lt;/code&gt; 返回的 &lt;code&gt;Config&lt;/code&gt; 实例放置到名为 &lt;code&gt;config&lt;/code&gt; 的变量中，并且更新了以前使用单独的 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 变量的代码，因此现在改为使用 &lt;code&gt;Config&lt;/code&gt; 结构上的字段。</target>
        </trans-unit>
        <trans-unit id="d23dd8237d80151639faf67cba12c8d62a94d599" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; where we were calling &lt;code&gt;parse_config&lt;/code&gt; to instead call &lt;code&gt;Config::new&lt;/code&gt;. We&amp;rsquo;ve changed the name of &lt;code&gt;parse_config&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; and moved it within an &lt;code&gt;impl&lt;/code&gt; block, which associates the &lt;code&gt;new&lt;/code&gt; function with &lt;code&gt;Config&lt;/code&gt;. Try compiling this code again to make sure it works.</source>
          <target state="translated">我们已经更新了 &lt;code&gt;main&lt;/code&gt; ，我们分别致电 &lt;code&gt;parse_config&lt;/code&gt; 改为调用 &lt;code&gt;Config::new&lt;/code&gt; 。我们将 &lt;code&gt;parse_config&lt;/code&gt; 的名称更改为 &lt;code&gt;new&lt;/code&gt; ，并将其移动到 &lt;code&gt;impl&lt;/code&gt; 块中，该块将 &lt;code&gt;new&lt;/code&gt; 功能与 &lt;code&gt;Config&lt;/code&gt; 关联。尝试再次编译此代码，以确保它可以工作。</target>
        </trans-unit>
        <trans-unit id="682f1e494883240e497eaf886adabbd3de94d2f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used &lt;code&gt;recv&lt;/code&gt; in this example for simplicity; we don&amp;rsquo;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</source>
          <target state="translated">为了简单起见，我们在此示例中使用了 &lt;code&gt;recv&lt;/code&gt; 。除了等待消息外，我们没有其他任何工作可让主线程执行，因此阻塞主线程是适当的。</target>
        </trans-unit>
        <trans-unit id="09261808e853fe8c1b1cf1c98bcaef67bcdbf69f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used macros like &lt;code&gt;println!&lt;/code&gt; throughout this book, but we haven&amp;rsquo;t fully explored what a macro is and how it works. The term &lt;em&gt;macro&lt;/em&gt; refers to a family of features in Rust: &lt;em&gt;declarative&lt;/em&gt; macros with &lt;code&gt;macro_rules!&lt;/code&gt; and three kinds of &lt;em&gt;procedural&lt;/em&gt; macros:</source>
          <target state="translated">我们使用了诸如 &lt;code&gt;println!&lt;/code&gt; 宏！在本书中，但我们还没有完全探讨宏是什么以及宏如何工作。术语&lt;em&gt;宏&lt;/em&gt;是指Rust中的一系列功能：具有 &lt;code&gt;macro_rules!&lt;/code&gt; &lt;em&gt;声明性&lt;/em&gt;宏！和三种&lt;em&gt;程序&lt;/em&gt;宏：</target>
        </trans-unit>
        <trans-unit id="e2712446812526a53471c1e0383e7a3108a1b4ae" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used packages from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distributes the source code of your packages, so it primarily hosts code that is open source.</source>
          <target state="translated">我们已经使用了&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io中的&lt;/a&gt;程序包作为我们项目的依赖项，但是您也可以通过发布自己的程序包与其他人共享代码。位于&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;的crate注册表分发软件包的源代码，因此它主要托管开放源代码。</target>
        </trans-unit>
        <trans-unit id="ec147c9a441b7f735a89cab0dad06f6138cccde7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used the underscore (&lt;code&gt;_&lt;/code&gt;) as a wildcard pattern that will match any value but not bind to the value. Although the underscore &lt;code&gt;_&lt;/code&gt; pattern is especially useful as the last arm in a &lt;code&gt;match&lt;/code&gt; expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</source>
          <target state="translated">我们使用下划线（ &lt;code&gt;_&lt;/code&gt; ）作为通配符模式，该模式将匹配任何值但不绑定到该值。尽管下划线 &lt;code&gt;_&lt;/code&gt; 模式作为 &lt;code&gt;match&lt;/code&gt; 表达式的最后一臂特别有用，但是我们可以在任何模式中使用它，包括函数参数，如清单18-17所示。</target>
        </trans-unit>
        <trans-unit id="44adc69b5d64c0f01b24575df11e052ec21c4722" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve walked through an example of a Rust program already in Chapter 2. Now that we&amp;rsquo;re past basic syntax, we won&amp;rsquo;t include all the &lt;code&gt;fn main() {&lt;/code&gt; code in examples, so if you&amp;rsquo;re following along, you&amp;rsquo;ll have to put the following examples inside a &lt;code&gt;main&lt;/code&gt; function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</source>
          <target state="translated">我们已经在第2章中介绍了Rust程序的示例。现在，我们已经讲解了基本语法，我们不会在示例中包含所有的 &lt;code&gt;fn main() {&lt;/code&gt; 代码，因此，如果您继续学习，将必须手动将以下示例放入 &lt;code&gt;main&lt;/code&gt; 函数中。结果，我们的示例将更加简洁，让我们专注于实际的细节而不是样板代码。</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="2592fb559c34ba109b261e1e971e0271f723f218" translate="yes" xml:space="preserve">
          <source>Weak keywords</source>
          <target state="translated">弱关键词</target>
        </trans-unit>
        <trans-unit id="b141897801ad64a5c292f85e9b0acea35468d86f" translate="yes" xml:space="preserve">
          <source>Weak::as_raw</source>
          <target state="translated">Weak::as_raw</target>
        </trans-unit>
        <trans-unit id="d422a6274254bfe89623f64408426ee6a4b95d2f" translate="yes" xml:space="preserve">
          <source>Weak::borrow</source>
          <target state="translated">Weak::borrow</target>
        </trans-unit>
        <trans-unit id="e090aeaf0035d47a06522ac573102af7ef03019b" translate="yes" xml:space="preserve">
          <source>Weak::borrow_mut</source>
          <target state="translated">Weak::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31f2cf80409016cb1a54e11bd8e10df114bcff9c" translate="yes" xml:space="preserve">
          <source>Weak::clone</source>
          <target state="translated">Weak::clone</target>
        </trans-unit>
        <trans-unit id="1022360ae57147f43f753c89ffa5b787aa1673ef" translate="yes" xml:space="preserve">
          <source>Weak::clone_from</source>
          <target state="translated">Weak::clone_from</target>
        </trans-unit>
        <trans-unit id="7ffb62a38307a645dc9e4fc1d7f948ab860db2a7" translate="yes" xml:space="preserve">
          <source>Weak::clone_into</source>
          <target state="translated">Weak::clone_into</target>
        </trans-unit>
        <trans-unit id="c865a401afc186e43b4eab7ca361d7638e0b536e" translate="yes" xml:space="preserve">
          <source>Weak::default</source>
          <target state="translated">Weak::default</target>
        </trans-unit>
        <trans-unit id="e57f10f57657469def31fa2d885237f40eb69154" translate="yes" xml:space="preserve">
          <source>Weak::drop</source>
          <target state="translated">Weak::drop</target>
        </trans-unit>
        <trans-unit id="ef51946ab6d84ee6b5287e68325989e298d500bc" translate="yes" xml:space="preserve">
          <source>Weak::fmt</source>
          <target state="translated">Weak::fmt</target>
        </trans-unit>
        <trans-unit id="04990cfad4762bebd1df30cc473af5882f2479cb" translate="yes" xml:space="preserve">
          <source>Weak::from</source>
          <target state="translated">Weak::from</target>
        </trans-unit>
        <trans-unit id="df4c7443eba251c8b78b6539d8ece4de970f301b" translate="yes" xml:space="preserve">
          <source>Weak::from_raw</source>
          <target state="translated">Weak::from_raw</target>
        </trans-unit>
        <trans-unit id="a6076aa76799b24c93bec01d241d277a0659dedb" translate="yes" xml:space="preserve">
          <source>Weak::into</source>
          <target state="translated">Weak::into</target>
        </trans-unit>
        <trans-unit id="0d8046306424b99b930a8b4a94195613e63c8154" translate="yes" xml:space="preserve">
          <source>Weak::into_raw</source>
          <target state="translated">Weak::into_raw</target>
        </trans-unit>
        <trans-unit id="a47f17db375bc704f4e384a38de508a900dfe192" translate="yes" xml:space="preserve">
          <source>Weak::new</source>
          <target state="translated">Weak::new</target>
        </trans-unit>
        <trans-unit id="9bc78ec91050d31c7752a036bdbd22e4063b718e" translate="yes" xml:space="preserve">
          <source>Weak::ptr_eq</source>
          <target state="translated">Weak::ptr_eq</target>
        </trans-unit>
        <trans-unit id="772fd61fe1d60fd5b1beff3bc669c9f17593cd0f" translate="yes" xml:space="preserve">
          <source>Weak::strong_count</source>
          <target state="translated">Weak::strong_count</target>
        </trans-unit>
        <trans-unit id="78b91a1fa2b3787768d39e8c6e94b83a6d3b3355" translate="yes" xml:space="preserve">
          <source>Weak::to_owned</source>
          <target state="translated">Weak::to_owned</target>
        </trans-unit>
        <trans-unit id="a0b4587c121fa0987a33f7acf83c36d1aa760be3" translate="yes" xml:space="preserve">
          <source>Weak::try_from</source>
          <target state="translated">Weak::try_from</target>
        </trans-unit>
        <trans-unit id="dffb26aa2fde976b45f16c5f1b3ec4c3c2236a57" translate="yes" xml:space="preserve">
          <source>Weak::try_into</source>
          <target state="translated">Weak::try_into</target>
        </trans-unit>
        <trans-unit id="66cbdb0ce3c9d445fe02eebbca20dc6699c1e0b8" translate="yes" xml:space="preserve">
          <source>Weak::type_id</source>
          <target state="translated">Weak::type_id</target>
        </trans-unit>
        <trans-unit id="ffffecfd343836cf2781f4e9ad8fe4ab904bdda7" translate="yes" xml:space="preserve">
          <source>Weak::upgrade</source>
          <target state="translated">Weak::upgrade</target>
        </trans-unit>
        <trans-unit id="5eadf7e5be67bb31aac15c710ff80ec7238e0320" translate="yes" xml:space="preserve">
          <source>Weak::weak_count</source>
          <target state="translated">Weak::weak_count</target>
        </trans-unit>
        <trans-unit id="cbd86db606d844ea581cc87e07ebe1432bbeb3e7" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">欢迎&lt;em&gt;使用Rust编程语言&lt;/em&gt;书！此版本的文本假定您在所有项目的&lt;em&gt;Cargo.toml&lt;/em&gt;中使用的是Rust 1.31.0或更高版本，且其 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; ，才能使用Rust 2018 Edition惯用语。请参阅&lt;a href=&quot;book/ch01-01-installation&quot;&gt;第1章&lt;/a&gt;的&amp;ldquo;安装&amp;rdquo;部分以安装或更新Rust，并参阅新的&lt;a href=&quot;book/appendix-05-editions&quot;&gt;附录E&lt;/a&gt;以获取有关Rust版本的信息。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8d0b89eafe83e20d5f86108981d205157dbff45" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">欢迎&lt;em&gt;使用Rust编程语言&lt;/em&gt;书！此版本的文本假定您在所有项目的&lt;em&gt;Cargo.toml&lt;/em&gt;中使用的是Rust 1.31.0或更高版本，且其 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; ，才能使用Rust 2018 Edition惯用语。请参阅&lt;a href=&quot;ch01-01-installation&quot;&gt;第1章&lt;/a&gt;的&amp;ldquo;安装&amp;rdquo;部分以安装或更新Rust，并参阅新的&lt;a href=&quot;appendix-05-editions&quot;&gt;附录E&lt;/a&gt;以获取有关Rust版本的信息。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71aabd16eb59292324e9dfd1470f8e3b8318b16b" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt;, an introductory book about Rust. The Rust programming language helps you write faster, more reliable software. High-level ergonomics and low-level control are often at odds in programming language design; Rust challenges that conflict. Through balancing powerful technical capacity and a great developer experience, Rust gives you the option to control low-level details (such as memory usage) without all the hassle traditionally associated with such control.</source>
          <target state="translated">欢迎&lt;em&gt;使用Rust编程语言&lt;/em&gt;，这是一本有关Rust的入门书籍。 Rust编程语言可帮助您编写更快，更可靠的软件。高级人机工程学和低级控制在编程语言设计中常常是矛盾的。锈病挑战冲突。通过平衡强大的技术能力和出色的开发人员经验，Rust为您提供了控制底层细节（例如内存使用情况）的选项，而无需传统上与此类控制相关的所有麻烦。</target>
        </trans-unit>
        <trans-unit id="def3e0cabaddabefe272409c1a7371052fe52e2f" translate="yes" xml:space="preserve">
          <source>Well done! You&amp;rsquo;ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You&amp;rsquo;re now ready to implement your own Rust projects and help with other peoples&amp;rsquo; projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</source>
          <target state="translated">做得好！您已经完成了这本书的结尾！我们要感谢您加入我们的Rust之旅。现在，您准备实施自己的Rust项目并为其他人的项目提供帮助。请记住，这里有其他Rustaceans的欢迎社区，他们愿意帮助您解决Rust旅途中遇到的任何挑战。</target>
        </trans-unit>
        <trans-unit id="e51a9120a6d90f0f111fa29f2fe00c6bb7da9412" translate="yes" xml:space="preserve">
          <source>What &lt;em id=&quot;what-the-reference-is-not&quot;&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">什么不是&lt;em id=&quot;what-the-reference-is-not&quot;&gt;参考&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9cecc65aff2a51e558a3cf424c55a11b8c31dce1" translate="yes" xml:space="preserve">
          <source>What &lt;em&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">什么不是&lt;em&gt;参考&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f518d8ec17050e8115e7f2ec450de2471cd3f305" translate="yes" xml:space="preserve">
          <source>What Is Ownership?</source>
          <target state="translated">什么是所有权?</target>
        </trans-unit>
        <trans-unit id="70d9b24e457447486228a37f69315f0aa6c48b62" translate="yes" xml:space="preserve">
          <source>What Is a String?</source>
          <target state="translated">什么是字符串?</target>
        </trans-unit>
        <trans-unit id="2368fe52347b12513e40ec057f72fd1310d84880" translate="yes" xml:space="preserve">
          <source>What do I do?</source>
          <target state="translated">我该怎么办?</target>
        </trans-unit>
        <trans-unit id="b31d036160b82937b3f747c02baff101759a7996" translate="yes" xml:space="preserve">
          <source>What expression to evaluate when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition evaluates to &lt;a href=&quot;keyword.false&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;条件为&lt;a href=&quot;keyword.false&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt;时要计算的表达式。</target>
        </trans-unit>
        <trans-unit id="aa2332f8c7d8caf559cd55bda6779e69b9228def" translate="yes" xml:space="preserve">
          <source>What happened? Adding the &lt;code&gt;pub&lt;/code&gt; keyword in front of &lt;code&gt;mod hosting&lt;/code&gt; makes the module public. With this change, if we can access &lt;code&gt;front_of_house&lt;/code&gt;, we can access &lt;code&gt;hosting&lt;/code&gt;. But the &lt;em&gt;contents&lt;/em&gt; of &lt;code&gt;hosting&lt;/code&gt; are still private; making the module public doesn&amp;rsquo;t make its contents public. The &lt;code&gt;pub&lt;/code&gt; keyword on a module only lets code in its ancestor modules refer to it.</source>
          <target state="translated">发生了什么？在 &lt;code&gt;mod hosting&lt;/code&gt; 前面添加 &lt;code&gt;pub&lt;/code&gt; 关键字可使该模块公开。进行此更改后，如果我们可以访问 &lt;code&gt;front_of_house&lt;/code&gt; ，那么我们可以访问 &lt;code&gt;hosting&lt;/code&gt; 。但是，&lt;em&gt;内容&lt;/em&gt;的 &lt;code&gt;hosting&lt;/code&gt; 还是私有的; 公开该模块不会公开其内容。模块上的 &lt;code&gt;pub&lt;/code&gt; 关键字仅允许其祖先模块中的代码引用它。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8765b8c06cc83702c9dbf2bca66a40041316a4f" translate="yes" xml:space="preserve">
          <source>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</source>
          <target state="translated">如果你试图访问一个数组中已经过了数组末尾的元素,会发生什么?假设你把这个例子改成了下面的代码,它可以编译,但运行时却以错误退出。</target>
        </trans-unit>
        <trans-unit id="0903cd7655009ddeab2540796c6a002b16cf56ff" translate="yes" xml:space="preserve">
          <source>What implementing the trait signifies about the type</source>
          <target state="translated">实现特质意味着什么?</target>
        </trans-unit>
        <trans-unit id="a77059cf1db619a698ed5c928ae175c07abb8490" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">什么是 &lt;code&gt;UnwindSafe&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="39c550be471783e69447a16171fe28c441cfa1b6" translate="yes" xml:space="preserve">
          <source>What is in the standard library documentation?</source>
          <target state="translated">标准库文件中有哪些内容?</target>
        </trans-unit>
        <trans-unit id="6be8c40317b2fde07b27b69f6275feba9067a940" translate="yes" xml:space="preserve">
          <source>What is unwind safety?</source>
          <target state="translated">什么是解套安全?</target>
        </trans-unit>
        <trans-unit id="546be1954cedfdfe8c9b6d5ed68a1aba4520048c" translate="yes" xml:space="preserve">
          <source>What operators and methods deriving this trait will enable</source>
          <target state="translated">哪些运算符和方法可以推导出这个特征呢?</target>
        </trans-unit>
        <trans-unit id="8cbcae63b4448efc20dd52bc49133e3cdc73cd42" translate="yes" xml:space="preserve">
          <source>What should the value of &lt;code&gt;answer&lt;/code&gt; be? Should it be &lt;code&gt;З&lt;/code&gt;, the first letter? When encoded in UTF-8, the first byte of &lt;code&gt;З&lt;/code&gt; is &lt;code&gt;208&lt;/code&gt; and the second is &lt;code&gt;151&lt;/code&gt;, so &lt;code&gt;answer&lt;/code&gt; should in fact be &lt;code&gt;208&lt;/code&gt;, but &lt;code&gt;208&lt;/code&gt; is not a valid character on its own. Returning &lt;code&gt;208&lt;/code&gt; is likely not what a user would want if they asked for the first letter of this string; however, that&amp;rsquo;s the only data that Rust has at byte index 0. Users generally don&amp;rsquo;t want the byte value returned, even if the string contains only Latin letters: if &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; were valid code that returned the byte value, it would return &lt;code&gt;104&lt;/code&gt;, not &lt;code&gt;h&lt;/code&gt;. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&amp;rsquo;t compile this code at all and prevents misunderstandings early in the development process.</source>
          <target state="translated">&lt;code&gt;answer&lt;/code&gt; 的价值是什么？应该是 &lt;code&gt;З&lt;/code&gt; ，第一个字母吗？当以UTF-8编码时， &lt;code&gt;З&lt;/code&gt; 的第一个字节为 &lt;code&gt;208&lt;/code&gt; ，第二个字节为 &lt;code&gt;151&lt;/code&gt; ，因此 &lt;code&gt;answer&lt;/code&gt; 实际上应该为 &lt;code&gt;208&lt;/code&gt; ，但 &lt;code&gt;208&lt;/code&gt; 本身不是有效字符。如果用户要求输入此字符串的第一个字母，则返回 &lt;code&gt;208&lt;/code&gt; 可能不是用户想要的。但是，这是Rust拥有字节索引0的唯一数据。即使字符串仅包含拉丁字母，用户也通常不希望返回字节值：如果 &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; 是返回字节值的有效代码，它将返回 &lt;code&gt;104&lt;/code&gt; ，不是 &lt;code&gt;h&lt;/code&gt; 。为了避免返回意外的值并导致可能不会立即发现的错误，Rust完全不编译该代码，并避免了开发过程早期的误解。</target>
        </trans-unit>
        <trans-unit id="104867f147475715b8460879a1886ec236299ab6" translate="yes" xml:space="preserve">
          <source>What the implementation of the trait provided by &lt;code&gt;derive&lt;/code&gt; does</source>
          <target state="translated">什么提供的性状的实施 &lt;code&gt;derive&lt;/code&gt; 呢</target>
        </trans-unit>
        <trans-unit id="813bb1fc77d8fbc02f8d5943beea4d865f45c1f2" translate="yes" xml:space="preserve">
          <source>What this means is that any type of argument which implements the &lt;a href=&quot;trait.binary&quot;&gt;&lt;code&gt;fmt::Binary&lt;/code&gt;&lt;/a&gt; trait can then be formatted with &lt;code&gt;{:b}&lt;/code&gt;. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{:6}&lt;/code&gt;), then the format trait used is the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">这意味着实现&lt;a href=&quot;trait.binary&quot;&gt; &lt;code&gt;fmt::Binary&lt;/code&gt; &lt;/a&gt;特征的任何类型的参数都可以使用 &lt;code&gt;{:b}&lt;/code&gt; 进行格式化。标准库也为许多原始类型提供了针对这些特征的实现。如果未指定格式（如 &lt;code&gt;{}&lt;/code&gt; 或 &lt;code&gt;{:6}&lt;/code&gt; ），则使用的格式特征是&lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;特征。</target>
        </trans-unit>
        <trans-unit id="0093e0ba1575f01e625f11752607bd61339f460b" translate="yes" xml:space="preserve">
          <source>What to do when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition does not hold.</source>
          <target state="translated">&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;条件不成立怎么办。</target>
        </trans-unit>
        <trans-unit id="534b9c0fb827379bcd2c8827a70c556de12f2bc1" translate="yes" xml:space="preserve">
          <source>What we can&amp;rsquo;t see in this example is that when &lt;code&gt;b&lt;/code&gt; and then &lt;code&gt;a&lt;/code&gt; go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, the count is then 0, and the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; is cleaned up completely at that point. Using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</source>
          <target state="translated">我们不能在这个例子中看到的是，当 &lt;code&gt;b&lt;/code&gt; ，然后 &lt;code&gt;a&lt;/code&gt; 在走到底的范围之 &lt;code&gt;main&lt;/code&gt; ，计数为0，然后，和 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在这一点上完全清除。使用 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 允许单个值具有多个所有者，并且计数确保只要任何所有者仍然存在，该值就保持有效。</target>
        </trans-unit>
        <trans-unit id="b08c6969a173d0d359ebf16040e97b732df68a33" translate="yes" xml:space="preserve">
          <source>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?</source>
          <target state="translated">通过共享内存进行交流会是怎样的呢?另外,为什么消息传递爱好者不会使用,反而会反其道而行之呢?</target>
        </trans-unit>
        <trans-unit id="e11dfea032c9cc516196eaa3fe3bafda5d5ff2fa" translate="yes" xml:space="preserve">
          <source>What would happen if we used &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt;? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</source>
          <target state="translated">如果我们使用 &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt; 会发生什么？答案：Rust在运行时会出现恐慌，就像在向量中访问无效索引一样：</target>
        </trans-unit>
        <trans-unit id="3a08543da46101db0a5f909c75d05185352f5e54" translate="yes" xml:space="preserve">
          <source>What would happen to the code in Listing 16-4 where the main thread called &lt;code&gt;drop&lt;/code&gt; if we use a &lt;code&gt;move&lt;/code&gt; closure? Would &lt;code&gt;move&lt;/code&gt; fix that case? Unfortunately, no; we would get a different error because what Listing 16-4 is trying to do isn&amp;rsquo;t allowed for a different reason. If we added &lt;code&gt;move&lt;/code&gt; to the closure, we would move &lt;code&gt;v&lt;/code&gt; into the closure&amp;rsquo;s environment, and we could no longer call &lt;code&gt;drop&lt;/code&gt; on it in the main thread. We would get this compiler error instead:</source>
          <target state="translated">如果使用 &lt;code&gt;move&lt;/code&gt; 闭包，清单16-4中的主线程调用 &lt;code&gt;drop&lt;/code&gt; 的代码会发生什么？将 &lt;code&gt;move&lt;/code&gt; 修正这种情况？抱歉不行; 我们会得到一个不同的错误，因为由于不同的原因，不允许清单16-4试图做的事情。如果将 &lt;code&gt;move&lt;/code&gt; 添加到闭包中，则将 &lt;code&gt;v&lt;/code&gt; 移到闭包的环境中，我们将无法再在主线程中调用 &lt;code&gt;drop&lt;/code&gt; 。我们将得到此编译器错误：</target>
        </trans-unit>
        <trans-unit id="7e42bfeecb6b1e951f9890e0818a295e8fe9a892" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Clone&lt;/code&gt; 什么区别？</target>
        </trans-unit>
        <trans-unit id="c8dcd460b2b3eb060b9c3f227627cad77273bd6e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;extern&quot; Abi?*&lt;/code&gt; is omitted from &lt;code&gt;FunctionQualifiers&lt;/code&gt; in function items, the ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; is assigned. For example:</source>
          <target state="translated">当 &lt;code&gt;&quot;extern&quot; Abi?*&lt;/code&gt; 从省略 &lt;code&gt;FunctionQualifiers&lt;/code&gt; 在功能项中，ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; 被分配。例如：</target>
        </trans-unit>
        <trans-unit id="44cd724105e5ed735f83c23d67c2ff48add6811d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary &lt;code&gt;-&lt;/code&gt; on the smallest value of any signed integer type.</source>
          <target state="translated">当 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 时,创建一个大于最大值或小于可以存储的最小值的值。这包括一元数 &lt;code&gt;-&lt;/code&gt; 任何有符号整数类型的最小值。</target>
        </trans-unit>
        <trans-unit id="aec1ff4fb0f51938e677ce85402d7e6e56fa4124" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait2&lt;/code&gt; is a subtrait of &lt;code&gt;Trait1&lt;/code&gt; (for example, when &lt;code&gt;Trait2&lt;/code&gt; has a definition like &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt;), it is not allowed to implement &lt;code&gt;Trait1&lt;/code&gt; for &lt;code&gt;Trait2&lt;/code&gt;. This is because &lt;code&gt;Trait2&lt;/code&gt; already implements &lt;code&gt;Trait1&lt;/code&gt; by definition, so it is not useful to do this.</source>
          <target state="translated">当 &lt;code&gt;Trait2&lt;/code&gt; 是Trait1的子 &lt;code&gt;Trait1&lt;/code&gt; （例如，当 &lt;code&gt;Trait2&lt;/code&gt; 具有类似 &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt; 的定义）时，不允许为 &lt;code&gt;Trait1&lt;/code&gt; 实现 &lt;code&gt;Trait2&lt;/code&gt; 。这是因为 &lt;code&gt;Trait2&lt;/code&gt; 已经通过定义实现了 &lt;code&gt;Trait1&lt;/code&gt; ，所以这样做没有用。</target>
        </trans-unit>
        <trans-unit id="394708bf787cdb05a4155072af4201796f69da61" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait&lt;/code&gt; is treated as a type, the type does not implement the special &lt;code&gt;Sized&lt;/code&gt; trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</source>
          <target state="translated">将 &lt;code&gt;Trait&lt;/code&gt; 视为类型时，该类型不会实现特殊的 &lt;code&gt;Sized&lt;/code&gt; 特征，因为在编译时该类型的大小未知，并且只能在指针后面进行访问。因此，如果我们具有以下特征：</target>
        </trans-unit>
        <trans-unit id="f4fcd22fdc939d17d3b6f99c714199ea75ee05bf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;bar&lt;/code&gt; is the name of a function, then the expression &lt;code&gt;bar&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a function pointer. Rather, it denotes a value of an unnameable type that uniquely identifies the function &lt;code&gt;bar&lt;/code&gt;. The value is zero-sized because the type already identifies the function. This has the advantage that &quot;calling&quot; the value (it implements the &lt;code&gt;Fn*&lt;/code&gt; traits) does not require dynamic dispatch.</source>
          <target state="translated">当 &lt;code&gt;bar&lt;/code&gt; 是一个函数的名称，则表达式 &lt;code&gt;bar&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;函数指针。相反，它表示唯一标识功能 &lt;code&gt;bar&lt;/code&gt; 的不可命名类型的值。该值的大小为零，因为类型已经标识了该函数。这具有以下优点：&amp;ldquo;调用&amp;rdquo;值（它实现 &lt;code&gt;Fn*&lt;/code&gt; 特征）不需要动态调度。</target>
        </trans-unit>
        <trans-unit id="88bc0dd59ab0b7fc42f69193dff99dc50f4478aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated, for example:</source>
          <target state="translated">当 &lt;code&gt;break&lt;/code&gt; 遇到，相关联的循环体的执行被立即终止，例如：</target>
        </trans-unit>
        <trans-unit id="b790b4f62a35aeedd4f3d63c2da173a7ec837ca2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated.</source>
          <target state="translated">当 &lt;code&gt;break&lt;/code&gt; 时遇到相关的循环体的执行被立即终止。</target>
        </trans-unit>
        <trans-unit id="c791d46f518801c28641842a73515ec8d559a2ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration is terminated, returning control to the loop head, typically continuing with the next iteration.</source>
          <target state="translated">当遇到 &lt;code&gt;continue&lt;/code&gt; 时，当前迭代终止，将控制权返回到循环头，通常继续进行下一个迭代。</target>
        </trans-unit>
        <trans-unit id="595c9458cad4cb9057d8e7fc040fb8866cc8cc3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop &lt;em&gt;head&lt;/em&gt;. In the case of a &lt;code&gt;while&lt;/code&gt; loop, the head is the conditional expression controlling the loop. In the case of a &lt;code&gt;for&lt;/code&gt; loop, the head is the call-expression controlling the loop.</source>
          <target state="translated">当遇到 &lt;code&gt;continue&lt;/code&gt; 时，关联循环主体的当前迭代将立即终止，将控制返回到循环&lt;em&gt;头&lt;/em&gt;。在 &lt;code&gt;while&lt;/code&gt; 循环的情况下，head是控制循环的条件表达式。在 &lt;code&gt;for&lt;/code&gt; 循环的情况下，head是控制循环的调用表达式。</target>
        </trans-unit>
        <trans-unit id="95185630ceafb190a6bbaa449dad38f0bceaa3df" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called by another attributed function &lt;code&gt;g&lt;/code&gt; which is in turn called by &lt;code&gt;calls_g&lt;/code&gt;, code in both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; observes &lt;code&gt;g&lt;/code&gt;'s callsite within &lt;code&gt;calls_g&lt;/code&gt;:</source>
          <target state="translated">当 &lt;code&gt;f&lt;/code&gt; 由另一个属性函数 &lt;code&gt;g&lt;/code&gt; 调用，而 &lt;code&gt;calls_g&lt;/code&gt; 又由calls_g调用时， &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 中的代码都在calls_g内观察 &lt;code&gt;g&lt;/code&gt; 的 &lt;code&gt;calls_g&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4e3d8142d10bdab6df8f2b960ed3b5f595f6be33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called directly by &lt;code&gt;calls_f&lt;/code&gt;, code in &lt;code&gt;f&lt;/code&gt; observes its callsite within &lt;code&gt;calls_f&lt;/code&gt;:</source>
          <target state="translated">当 &lt;code&gt;f&lt;/code&gt; 由 &lt;code&gt;calls_f&lt;/code&gt; 直接调用时， &lt;code&gt;f&lt;/code&gt; 中的代码将在calls_f中观察其调用 &lt;code&gt;calls_f&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0b714a909447f7628d7a5c65a1ec2d8d650053b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;g&lt;/code&gt; is called by another attributed function &lt;code&gt;h&lt;/code&gt; which is in turn called by &lt;code&gt;calls_h&lt;/code&gt;, all code in &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; observes &lt;code&gt;h&lt;/code&gt;'s callsite within &lt;code&gt;calls_h&lt;/code&gt;:</source>
          <target state="translated">当 &lt;code&gt;g&lt;/code&gt; 由另一个属性函数 &lt;code&gt;h&lt;/code&gt; 调用，而 &lt;code&gt;calls_h&lt;/code&gt; 又由calls_h调用时， &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;g&lt;/code&gt; 和 &lt;code&gt;h&lt;/code&gt; 中的所有代码都在calls_h内观察 &lt;code&gt;h&lt;/code&gt; 的 &lt;code&gt;calls_h&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e1a4cd7cb82bb7dfe91312bff7fa4ef245f8f684" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outer&lt;/code&gt; goes out of scope, the &lt;code&gt;drop&lt;/code&gt; method will be called first for &lt;code&gt;Outer&lt;/code&gt;, then for &lt;code&gt;Inner&lt;/code&gt;. Therefore, &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping Outer!&lt;/code&gt; and then &lt;code&gt;Dropping Inner!&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;outer&lt;/code&gt; 去的范围时，该 &lt;code&gt;drop&lt;/code&gt; 方法将首先对被称为 &lt;code&gt;Outer&lt;/code&gt; ，则对于 &lt;code&gt;Inner&lt;/code&gt; 。因此， &lt;code&gt;main&lt;/code&gt; 版画 &lt;code&gt;Dropping Outer!&lt;/code&gt; 然后 &lt;code&gt;Dropping Inner!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a6386c03d530a251bd741f83dfe28d17156802f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s&lt;/code&gt; comes &lt;em&gt;into scope&lt;/em&gt;, it is valid.</source>
          <target state="translated">当 &lt;code&gt;s&lt;/code&gt; 来&lt;em&gt;为范围&lt;/em&gt;，它是有效的。</target>
        </trans-unit>
        <trans-unit id="187902d840e750b40be0f468eec4f29e171a13da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">当未设置 &lt;code&gt;security_qos_flags&lt;/code&gt; 时,恶意程序可以通过诱骗程序打开命名管道来允许其打开用户指定的路径，从而获得特权Rust进程的提升特权。因此可以说在打开任意路径时也应该设置 &lt;code&gt;security_qos_flags&lt;/code&gt; 。但是，这些位可能会与其他标志（特别是 &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; )冲突。</target>
        </trans-unit>
        <trans-unit id="f6050c0d5bfa7ba1d59f28a5f8ace3a1e46fb76d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set, a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">如果未设置 &lt;code&gt;security_qos_flags&lt;/code&gt; ,则恶意程序可以通过诱骗程序打开命名管道来允许其打开用户指定的路径，从而获得特权Rust进程的提升特权。因此可以说，打开任意路径时也应设置 &lt;code&gt;security_qos_flags&lt;/code&gt; 。但是，这些位可能会与其他标志（特别是 &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; )冲突。</target>
        </trans-unit>
        <trans-unit id="ae5e8e8826bd49e5ed65af5663b42f4dcb6bef45" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;can't&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">我什么时候&lt;em&gt;不能&lt;/em&gt;输入&amp;ldquo; &lt;code&gt;Copy&lt;/code&gt; &amp;rdquo;？</target>
        </trans-unit>
        <trans-unit id="1afd27d775db688aa55a7acd7657368f0252621c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;should&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">我什么时候&lt;em&gt;应该&lt;/em&gt;输入&amp;ldquo; &lt;code&gt;Copy&lt;/code&gt; &amp;rdquo;？</target>
        </trans-unit>
        <trans-unit id="eeffd83a46d46ad1d4f4a9906f6344d685f07825" translate="yes" xml:space="preserve">
          <source>When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances and identifies two kinds of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;: one is &lt;code&gt;i32&lt;/code&gt; and the other is &lt;code&gt;f64&lt;/code&gt;. As such, it expands the generic definition of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into &lt;code&gt;Option_i32&lt;/code&gt; and &lt;code&gt;Option_f64&lt;/code&gt;, thereby replacing the generic definition with the specific ones.</source>
          <target state="translated">当Rust编译此代码时，它将执行单态化。在该过程中，编译器读取 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 实例中已使用的值，并标识两种 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ：一种是 &lt;code&gt;i32&lt;/code&gt; ，另一种是 &lt;code&gt;f64&lt;/code&gt; 。这样，它将 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 的通用定义扩展为 &lt;code&gt;Option_i32&lt;/code&gt; 和 &lt;code&gt;Option_f64&lt;/code&gt; ，从而用特定的替换通用定义。</target>
        </trans-unit>
        <trans-unit id="2db72e30aa272b55473c5bb5758326ffc2e81ae7" translate="yes" xml:space="preserve">
          <source>When Should You Use Which Collection?</source>
          <target state="translated">什么时候应该使用哪种系列?</target>
        </trans-unit>
        <trans-unit id="25db746b33ac06b90cb2c2043d4cbfe8648aece7" translate="yes" xml:space="preserve">
          <source>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don&amp;rsquo;t want to pay in more common cases where we want to execute code that doesn&amp;rsquo;t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</source>
          <target state="translated">当闭包从其环境中捕获值时，它将使用内存来存储要在闭包主体中使用的值。这种内存使用是开销，我们不想在更常见的情况下执行不捕获其环境的代码。由于永远不允许函数捕获其环境，因此定义和使用函数绝不会产生这种开销。</target>
        </trans-unit>
        <trans-unit id="497ca50f155974a1532fc87c50b119765598e81c" translate="yes" xml:space="preserve">
          <source>When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched. Consider using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt; in such cases.</source>
          <target state="translated">当一个功能需要正确对齐时，即使访问的大小为0，即即使实际上未触及内存，也需要进行正确的对齐。在这种情况下，请考虑使用&lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8dfc9c0b52337fbeec4162f45c275f5e1ab922f4" translate="yes" xml:space="preserve">
          <source>When a function returns &lt;code&gt;Pending&lt;/code&gt;, the function &lt;em&gt;must&lt;/em&gt; also ensure that the current task is scheduled to be awoken when progress can be made.</source>
          <target state="translated">当函数返回 &lt;code&gt;Pending&lt;/code&gt; 时，该函数还&lt;em&gt;必须&lt;/em&gt;确保可以安排进度使当前任务被唤醒。</target>
        </trans-unit>
        <trans-unit id="df3a37e739621c9131e28f62bb1b9067e261aa43" translate="yes" xml:space="preserve">
          <source>When a future is not ready yet, &lt;code&gt;poll&lt;/code&gt; returns &lt;code&gt;Poll::Pending&lt;/code&gt; and stores a clone of the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; copied from the current &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; is then woken once the future can make progress. For example, a future waiting for a socket to become readable would call &lt;code&gt;.clone()&lt;/code&gt; on the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; and store it. When a signal arrives elsewhere indicating that the socket is readable, &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt;&lt;code&gt;Waker::wake&lt;/code&gt;&lt;/a&gt; is called and the socket future's task is awoken. Once a task has been woken up, it should attempt to &lt;code&gt;poll&lt;/code&gt; the future again, which may or may not produce a final value.</source>
          <target state="translated">当未来还没有准备好时， &lt;code&gt;poll&lt;/code&gt; 返回 &lt;code&gt;Poll::Pending&lt;/code&gt; 并存储从当前&lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;复制的&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; 的&lt;/a&gt;副本。一旦未来可以进步，这个唤醒&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;就会被唤醒。例如，将来等待套接字变得可读的将在&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;上调用 &lt;code&gt;.clone()&lt;/code&gt; 并将其存储。当信号到达其他地方指示该套接字可读时，将调用&lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt; &lt;code&gt;Waker::wake&lt;/code&gt; &lt;/a&gt;，并唤醒套接字future的任务。任务唤醒后，它应尝试再次 &lt;code&gt;poll&lt;/code&gt; 将来，这可能会或可能不会产生最终值。</target>
        </trans-unit>
        <trans-unit id="0a389975a3b1e10203b84d73debfb669c64513a0" translate="yes" xml:space="preserve">
          <source>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the &lt;code&gt;foo&lt;/code&gt; function here:</source>
          <target state="translated">引用泛型函数时，将根据引用的上下文实例化其类型。例如，在此处调用 &lt;code&gt;foo&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="6dd55c7ab400acdd91bba18da1fe8d01823a4e07" translate="yes" xml:space="preserve">
          <source>When a macro is exported, the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute can have the &lt;code&gt;local_inner_macros&lt;/code&gt; keyword added to automatically prefix all contained macro invocations with &lt;code&gt;$crate::&lt;/code&gt;. This is intended primarily as a tool to migrate code written before &lt;code&gt;$crate&lt;/code&gt; was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.</source>
          <target state="translated">导出宏时，可以在 &lt;code&gt;#[macro_export]&lt;/code&gt; 属性中添加 &lt;code&gt;local_inner_macros&lt;/code&gt; 关键字，以自动为所有包含的宏调用加上 &lt;code&gt;$crate::&lt;/code&gt; 前缀。这主要是用作迁移在将 &lt;code&gt;$crate&lt;/code&gt; 添加到语言中之前编写的代码的工具，以与Rust 2018基于路径的宏导入一起使用。在新代码中不鼓励使用它。</target>
        </trans-unit>
        <trans-unit id="5cf6c55b5740990d2d97e584acaf0732444aabf9" translate="yes" xml:space="preserve">
          <source>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.</source>
          <target state="translated">当一个宏被一个非限定标识符(不是多部分路径的一部分)调用时,首先会在文本范围内进行查找。如果这样做没有得到任何结果,那么就用基于路径的作用域来查找。如果宏的名称用路径限定,则只在基于路径的范围内查找。</target>
        </trans-unit>
        <trans-unit id="da106a1de68be7bf6a4528e441dfbcc8cf456544" translate="yes" xml:space="preserve">
          <source>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a &lt;code&gt;)&lt;/code&gt;, even though that would allow it to parse the invocation unambiguously:</source>
          <target state="translated">调用宏时，宏扩展器按名称查找宏调用，然后依次尝试每个宏规则。它记录第一个成功的比赛；如果这导致错误，则不尝试将来的匹配。匹配时，不执行前瞻；如果编译器不能明确确定一次如何解析宏调用，那么这是一个错误。在以下示例中，编译器不会向前看标识符，以查看以下标记是否为 &lt;code&gt;)&lt;/code&gt; ，即使这将使其能够明确解析调用：</target>
        </trans-unit>
        <trans-unit id="db73e8cf8b50208d0fa9d6efe2409269d6d07431" translate="yes" xml:space="preserve">
          <source>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held &lt;em&gt;in&lt;/em&gt; that memory location. If the type of that value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, then the value will be copied. In the remaining situations if that type is &lt;a href=&quot;special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;, then it may be possible to move the value. Only the following place expressions may be moved out of:</source>
          <target state="translated">当一个地方表达的值表达上下文被评估，或者通过值在模式束缚，但是表示所保持的值&lt;em&gt;在&lt;/em&gt;该存储器位置。如果该值的类型实现&lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，那么将复制该值。在其余情况下，如果该类型为&lt;a href=&quot;special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;，则可以移动该值。只能将以下位置表达式移出：</target>
        </trans-unit>
        <trans-unit id="f1166409c8dae55a33ce311312672ddb4f4b9f7d" translate="yes" xml:space="preserve">
          <source>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an &lt;code&gt;unsafe&lt;/code&gt; block. The compiler will consider uses of such code safe, in the surrounding context.</source>
          <target state="translated">当程序员有足够的信心认为一系列潜在的不安全操作实际上是安全的时，他们可以将该序列（整体上）封装在一个 &lt;code&gt;unsafe&lt;/code&gt; 块中。编译器将在周围环境中安全使用此类代码。</target>
        </trans-unit>
        <trans-unit id="37dbbb1590700cff7b3552010c53f0420bf77ff3" translate="yes" xml:space="preserve">
          <source>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</source>
          <target state="translated">当一个堆栈框架被退出时,它的本地分配全部被释放,它对盒子的引用也被丢弃。</target>
        </trans-unit>
        <trans-unit id="9c30511e183a1aabc7ef13d867dc58fb961ffdbb" translate="yes" xml:space="preserve">
          <source>When a temporary value expression is being created that is assigned into a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt;, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt; would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a &lt;code&gt;let&lt;/code&gt; binding, and therefore deserve a longer temporary lifetime.</source>
          <target state="translated">但是，当创建分配给&lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 声明&lt;/a&gt;的临时值表达式时，将使用封闭块的生存期来创建该临时值，因为使用封闭的&lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 声明&lt;/a&gt;将确保出现错误（因为指向临时块的指针会可以存储到变量中，但可以在使用该变量之前将其释放）。编译器使用简单的语法规则来决定将哪些值分配给 &lt;code&gt;let&lt;/code&gt; 绑定，因此应获得更长的临时寿命。</target>
        </trans-unit>
        <trans-unit id="3039f11f165afd56d3c433b69cd1393d96919902" translate="yes" xml:space="preserve">
          <source>When a tool is not in use, the tool's attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</source>
          <target state="translated">当工具未使用时,工具的属性被接受,没有警告。当工具在使用时,工具负责处理和解释其属性。</target>
        </trans-unit>
        <trans-unit id="57dd9a0351b44496fecb16d4596f4a8247328e39" translate="yes" xml:space="preserve">
          <source>When a trait object is used as a type argument of a generic type, Rust will try to infer its lifetime if unspecified. However, this isn't possible when the containing type has more than one lifetime bound.</source>
          <target state="translated">当一个trait对象被用作一个通用类型的类型参数时,如果没有指定,Rust会尝试推断它的寿命。然而,当包含的类型有一个以上的寿命约束时,这是不可能的。</target>
        </trans-unit>
        <trans-unit id="0ed6434b244126fa9e52f60dea8a8d6ab8918d34" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; does not take any argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="translated">当类型实现特征的关联功能时，它必须使用相同的签名。因此，在这种情况下，由于 &lt;code&gt;Foo::foo&lt;/code&gt; 不接受任何参数且不返回任何内容，因此其在 &lt;code&gt;Bar&lt;/code&gt; 上的实现应相同：</target>
        </trans-unit>
        <trans-unit id="746134148fbdc4bec37479d1ea67a6352b384088" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; takes &lt;code&gt;self&lt;/code&gt; as argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="translated">当类型实现特征的关联功能时，它必须使用相同的签名。因此，在这种情况下，由于 &lt;code&gt;Foo::foo&lt;/code&gt; 将 &lt;code&gt;self&lt;/code&gt; 作为参数并且不返回任何内容，因此它在 &lt;code&gt;Bar&lt;/code&gt; 上的实现应相同：</target>
        </trans-unit>
        <trans-unit id="5832f57eccb2fb5a09efa61cb2de8da5f920035f" translate="yes" xml:space="preserve">
          <source>When a union is dropped, it cannot know which of its fields needs to be dropped. For this reason, all union fields must either be of a &lt;a href=&quot;../../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; type or of the shape &lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&amp;lt;_&amp;gt;&lt;/code&gt;&lt;/a&gt;. This ensures that a union does not need to drop anything when it goes out of scope.</source>
          <target state="translated">删除联合时，它无法知道需要删除其哪个字段。因此，所有联合字段都必须是&lt;a href=&quot;../../std/marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;类型或形状为&lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;ManuallyDrop&amp;lt;_&amp;gt;&lt;/code&gt; &lt;/a&gt;。这样可以确保工会在超出范围时无需丢弃任何内容。</target>
        </trans-unit>
        <trans-unit id="fa395a4e08ef9a2a05a0ac466a281cf522ff2172" translate="yes" xml:space="preserve">
          <source>When a union is dropped, it cannot know which of its fields needs to be dropped. For this reason, all union fields must either be of a &lt;code&gt;Copy&lt;/code&gt; type or of the shape &lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&amp;lt;_&amp;gt;&lt;/code&gt;&lt;/a&gt;. This ensures that a union does not need to drop anything when it goes out of scope.</source>
          <target state="translated">删除联合时，它无法知道需要删除其哪个字段。因此，所有联合字段都必须是 &lt;code&gt;Copy&lt;/code&gt; 类型或形状为&lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;ManuallyDrop&amp;lt;_&amp;gt;&lt;/code&gt; &lt;/a&gt;。这样可以确保工会在超出范围时无需丢弃任何内容。</target>
        </trans-unit>
        <trans-unit id="4c9879ea05cdb93dca8c0304f717ae122b1e8ba0" translate="yes" xml:space="preserve">
          <source>When a user calls &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt;, the map will search for the key and then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.</source>
          <target state="translated">当用户调用 &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt; 时，地图将搜索该键，然后生成 &lt;code&gt;Entry&lt;/code&gt; 枚举的变体。</target>
        </trans-unit>
        <trans-unit id="fdd0bd3294966057d48234d31e6f7d296a99309a" translate="yes" xml:space="preserve">
          <source>When a value goes out of scope, it will have its &lt;code&gt;drop&lt;/code&gt; method called if its type implements &lt;code&gt;Drop&lt;/code&gt;. Then, any fields the value contains will also be dropped recursively.</source>
          <target state="translated">当值超出范围时，如果其类型实现 &lt;code&gt;Drop&lt;/code&gt; ，则将调用其 &lt;code&gt;drop&lt;/code&gt; 方法。然后，该值包含的任何字段也将被递归删除。</target>
        </trans-unit>
        <trans-unit id="d7ba61b38031de6106df804542ee455b8b72fed7" translate="yes" xml:space="preserve">
          <source>When a value is no longer needed, Rust will run a &quot;destructor&quot; on that value. The most common way that a value is no longer needed is when it goes out of scope. Destructors may still run in other circumstances, but we're going to focus on scope for the examples here. To learn about some of those other cases, please see &lt;a href=&quot;../../reference/destructors&quot;&gt;the reference&lt;/a&gt; section on destructors.</source>
          <target state="translated">当不再需要某个值时，Rust将对该值运行&amp;ldquo;析构函数&amp;rdquo;。不再需要某个值的最常见方法是超出范围。析构函数可能仍在其他情况下运行，但是在这里我们将重点关注示例的范围。要了解其他一些情况，请参阅析构函数&lt;a href=&quot;../../reference/destructors&quot;&gt;的参考&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="0821834765580ea9c5440213203fcb1c1cbcdd57" translate="yes" xml:space="preserve">
          <source>When a variable is immutable, once a value is bound to a name, you can&amp;rsquo;t change that value. To illustrate this, let&amp;rsquo;s generate a new project called &lt;em&gt;variables&lt;/em&gt; in your &lt;em&gt;projects&lt;/em&gt; directory by using &lt;code&gt;cargo new variables&lt;/code&gt;.</source>
          <target state="translated">如果变量是不可变的，则将值绑定到名称后，就无法再更改该值。为了说明这一点，让我们通过使用 &lt;code&gt;cargo new variables&lt;/code&gt; 在&lt;em&gt;项目&lt;/em&gt;目录中生成一个名为&lt;em&gt;变量&lt;/em&gt;的新项目。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd9a182b7a78038005ce22938a8bdbd281d7f445" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in Rust goes out of scope or a &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt; is no longer needed its &lt;em&gt;destructor&lt;/em&gt; is run. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, unless it's an uninitialized variable. If a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">当Rust中的&lt;a href=&quot;glossary#initialized&quot;&gt;初始化&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;超出范围或不再需要&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;临时&lt;/a&gt;变量时，将运行其&lt;em&gt;析构函数&lt;/em&gt;。&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;赋值&lt;/a&gt;还会运行其左操作数的析构函数，除非它是未初始化的变量。如果&lt;a href=&quot;types/struct&quot;&gt;结构&lt;/a&gt;变量已被部分初始化，则仅删除其初始化字段。</target>
        </trans-unit>
        <trans-unit id="a5a59a643bd12cd60c0f839e9c5140aa3d6d2e23" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; or &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt; goes out of &lt;a href=&quot;#drop-scopes&quot;&gt;scope&lt;/a&gt; its &lt;em&gt;destructor&lt;/em&gt; is run, or it is &lt;em&gt;dropped&lt;/em&gt;. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, if it's initialized. If a variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">当&lt;a href=&quot;glossary#initialized&quot;&gt;初始化的&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;或&lt;a href=&quot;expressions#temporaries&quot;&gt;临时&lt;/a&gt;变量超出&lt;a href=&quot;#drop-scopes&quot;&gt;范围时，&lt;/a&gt;将运行其&lt;em&gt;析构函数&lt;/em&gt;，或将其&lt;em&gt;删除&lt;/em&gt;。&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;如果赋值&lt;/a&gt;已初始化，则它还会运行其左操作数的析构函数。如果变量已被部分初始化，则仅删除其初始化字段。</target>
        </trans-unit>
        <trans-unit id="e8c277e0058026b8160091c9cd27bc3ead387a36" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStderr&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStderr&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">当一个实例 &lt;code&gt;ChildStderr&lt;/code&gt; 被&lt;a href=&quot;../ops/trait.drop&quot;&gt;丢弃&lt;/a&gt;时， &lt;code&gt;ChildStderr&lt;/code&gt; 的底层文件句柄将被关闭。</target>
        </trans-unit>
        <trans-unit id="958df1c2da20bb17df895f86bdedaa3ff7514d03" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdin&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdin&lt;/code&gt;'s underlying file handle will be closed. If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.</source>
          <target state="translated">当一个实例 &lt;code&gt;ChildStdin&lt;/code&gt; 被&lt;a href=&quot;../ops/trait.drop&quot;&gt;丢弃&lt;/a&gt;时， &lt;code&gt;ChildStdin&lt;/code&gt; 的底层文件句柄将被关闭。如果子进程在删除之前已在输入上被阻止，则子进程在删除后将变为未阻止。</target>
        </trans-unit>
        <trans-unit id="7f3df133c5feae9ef4d3689b7485515d7c0d45c0" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdout&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdout&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">当一个实例 &lt;code&gt;ChildStdout&lt;/code&gt; 被&lt;a href=&quot;../ops/trait.drop&quot;&gt;丢弃&lt;/a&gt;时， &lt;code&gt;ChildStdout&lt;/code&gt; 的底层文件句柄将被关闭。</target>
        </trans-unit>
        <trans-unit id="19c24a2b0ecc148719938d64be9c4f9999639c3f" translate="yes" xml:space="preserve">
          <source>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</source>
          <target state="translated">当在函数中注释寿命时,注释要放在函数签名中,而不是函数体中。Rust可以在没有任何帮助的情况下分析函数内的代码。然而,当一个函数有对该函数之外的代码的引用或来自该函数之外的代码时,Rust 几乎不可能自己找出参数或返回值的寿命。每次调用函数时,寿命可能都不同。这就是为什么我们需要手动注释寿命的原因。</target>
        </trans-unit>
        <trans-unit id="5eb36c8197085fe87eab8cbaf9a553875da1cc3a" translate="yes" xml:space="preserve">
          <source>When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of methods can be used to hint to the collection how much room it should make for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of these methods will be specific to the collection of interest.</source>
          <target state="translated">当预计会有大量的元素涌入时，可以使用 &lt;code&gt;reserve&lt;/code&gt; 方法来向馆藏暗示应该为即将到来的物品腾出多少空间。与 &lt;code&gt;with_capacity&lt;/code&gt; 一样，这些方法的精确行为将特定于感兴趣的集合。</target>
        </trans-unit>
        <trans-unit id="5869f8bc191d572958f5cd39be698922927ab6f9" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在适用时，首选不稳定排序，因为它通常比稳定排序快，并且不分配辅助内存。参见&lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d79690f38c03573c4c869dcdef6200c1505551cc" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by&quot;&gt;&lt;code&gt;sort_unstable_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在适用时，首选不稳定排序，因为它通常比稳定排序快，并且不分配辅助内存。参见&lt;a href=&quot;#method.sort_unstable_by&quot;&gt; &lt;code&gt;sort_unstable_by&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1e5b5f3c7b4b4a47f33b2043eea612fc9e4a52c" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt;&lt;code&gt;sort_unstable_by_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在适用时，首选不稳定排序，因为它通常比稳定排序快，并且不分配辅助内存。参见&lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt; &lt;code&gt;sort_unstable_by_key&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9457ac5b05fa1acc97622737a2e6a54db8e47e30" translate="yes" xml:space="preserve">
          <source>When applied to a function in an &lt;code&gt;extern&lt;/code&gt; block the attribute must also be applied to any linked implementations, otherwise undefined behavior results. When applied to a function which is made available to an &lt;code&gt;extern&lt;/code&gt; block, the declaration in the &lt;code&gt;extern&lt;/code&gt; block must also have the attribute, otherwise undefined behavior results.</source>
          <target state="translated">当将其应用于 &lt;code&gt;extern&lt;/code&gt; 块中的函数时，该属性还必须应用于任何链接的实现，否则将导致未定义的行为。当施加到其被提供给一个函数 &lt;code&gt;extern&lt;/code&gt; 块，在声明 &lt;code&gt;extern&lt;/code&gt; 块还必须有属性，否则未定义的行为的结果。</target>
        </trans-unit>
        <trans-unit id="19a16b324a673b29db2da7d4da32ddcedab4170b" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type, it propagates &lt;code&gt;None&lt;/code&gt;s. If the value is &lt;code&gt;None&lt;/code&gt;, then it will return &lt;code&gt;None&lt;/code&gt;. If applied to &lt;code&gt;Some(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">当应用于 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 类型的值时，它将传播 &lt;code&gt;None&lt;/code&gt; 。如果值为 &lt;code&gt;None&lt;/code&gt; ，则它将返回 &lt;code&gt;None&lt;/code&gt; 。如果应用于 &lt;code&gt;Some(x)&lt;/code&gt; ，则它将解开该值以求值为 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6010016322f07bd48e6ab713e2801cda33b2dfbc" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, it propagates errors. If the value is &lt;code&gt;Err(e)&lt;/code&gt;, then it will return &lt;code&gt;Err(From::from(e))&lt;/code&gt; from the enclosing function or closure. If applied to &lt;code&gt;Ok(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">当应用于 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 类型的值时，它将传播错误。如果值为 &lt;code&gt;Err(e)&lt;/code&gt; ，则它将从封闭函数或闭包中返回 &lt;code&gt;Err(From::from(e))&lt;/code&gt; 。如果应用于 &lt;code&gt;Ok(x)&lt;/code&gt; ，则它将解开该值以求值为 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bc7928c8c171d59b0f5be17006fd056745b554a" translate="yes" xml:space="preserve">
          <source>When applied within a crate, downstream users of the crate will need to use the &lt;code&gt;_&lt;/code&gt; pattern when matching enums and use the &lt;code&gt;..&lt;/code&gt; pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</source>
          <target state="translated">当应用在板条箱中时，板条箱的下游用户在匹配枚举时将需要使用 &lt;code&gt;_&lt;/code&gt; 模式，而在与结构体匹配时将使用 &lt;code&gt;..&lt;/code&gt; 模式。下游板条箱无法与非穷举的枚举变量匹配。</target>
        </trans-unit>
        <trans-unit id="7b7ce408de1692c1cce1be5c86062fc2d1aa15ec" translate="yes" xml:space="preserve">
          <source>When are these warnings going to turn into errors?</source>
          <target state="translated">这些警告什么时候才会变成错误?</target>
        </trans-unit>
        <trans-unit id="93dc9e73dc6c00708f0214c1f73e691c8c3e8698" translate="yes" xml:space="preserve">
          <source>When associated with &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop. This is only valid with &lt;code&gt;loop&lt;/code&gt; and not with any other type of loop. If no value is specified, &lt;code&gt;break;&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt;. Every &lt;code&gt;break&lt;/code&gt; within a loop must return the same type.</source>
          <target state="translated">当与 &lt;code&gt;loop&lt;/code&gt; 关联时，break表达式可用于从该循环返回一个值。这仅对 &lt;code&gt;loop&lt;/code&gt; 有效，对任何其他类型的循环均无效。如果未指定任何值，请 &lt;code&gt;break;&lt;/code&gt; 返回 &lt;code&gt;()&lt;/code&gt; 。循环中的每个 &lt;code&gt;break&lt;/code&gt; 必须返回相同的类型。</target>
        </trans-unit>
        <trans-unit id="b0d2ee129e76133ba53a5ea99826864278fbc53d" translate="yes" xml:space="preserve">
          <source>When associated with a &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop, via one of the forms &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;, where &lt;code&gt;EXPR&lt;/code&gt; is an expression whose result is returned from the &lt;code&gt;loop&lt;/code&gt;. For example:</source>
          <target state="translated">当与相关联的 &lt;code&gt;loop&lt;/code&gt; ，一休表达可被用于从该循环返回一个值，通过的形式之一 &lt;code&gt;break EXPR&lt;/code&gt; 或 &lt;code&gt;break 'label EXPR&lt;/code&gt; ，其中 &lt;code&gt;EXPR&lt;/code&gt; 是指其结果是从返回的表达式 &lt;code&gt;loop&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="4a763dfd452f118669800efdde464c1dbe786ee4" translate="yes" xml:space="preserve">
          <source>When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So &lt;code&gt;usize&lt;/code&gt; is &lt;code&gt;32&lt;/code&gt; bits if you are compiling against a &lt;code&gt;32&lt;/code&gt; bit system, irrelevant of whether you are building on a &lt;code&gt;64&lt;/code&gt; bit or a &lt;code&gt;32&lt;/code&gt; bit system.</source>
          <target state="translated">当从const上下文调用时，编译器会在编译时解释该函数。解释发生在编译目标而不是宿主的环境中。因此，如果您是针对 &lt;code&gt;32&lt;/code&gt; 位系统进行编译，则 &lt;code&gt;usize&lt;/code&gt; 是 &lt;code&gt;32&lt;/code&gt; 位，而与您是在 &lt;code&gt;64&lt;/code&gt; 位系统还是 &lt;code&gt;32&lt;/code&gt; 位系统上进行构建无关。</target>
        </trans-unit>
        <trans-unit id="c47843d04159de5ef9116ac80f96bd39967f9187" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;product()&lt;/code&gt; and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">当调用 &lt;code&gt;product()&lt;/code&gt; 并返回原始整数类型时，如果计算溢出并启用了调试断言，则方法将出现恐慌。</target>
        </trans-unit>
        <trans-unit id="e4216881c81bce1d1b8084df44f2b67955efbb5a" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">当调用 &lt;code&gt;sum()&lt;/code&gt; 并返回原始整数类型时，如果计算溢出并且启用了调试断言，则此方法将出现恐慌。</target>
        </trans-unit>
        <trans-unit id="ad8c85712072b3d065a1d9c78cdc29d373ce9764" translate="yes" xml:space="preserve">
          <source>When calling methods with the same name, you&amp;rsquo;ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we&amp;rsquo;ve defined two traits, &lt;code&gt;Pilot&lt;/code&gt; and &lt;code&gt;Wizard&lt;/code&gt;, that both have a method called &lt;code&gt;fly&lt;/code&gt;. We then implement both traits on a type &lt;code&gt;Human&lt;/code&gt; that already has a method named &lt;code&gt;fly&lt;/code&gt; implemented on it. Each &lt;code&gt;fly&lt;/code&gt; method does something different.</source>
          <target state="translated">当调用具有相同名称的方法时，您需要告诉Rust要使用哪个方法。考虑清单19-16中的代码，其中我们定义了两个特性 &lt;code&gt;Pilot&lt;/code&gt; 和 &lt;code&gt;Wizard&lt;/code&gt; ，它们都具有一个称为 &lt;code&gt;fly&lt;/code&gt; 的方法。然后，我们在 &lt;code&gt;Human&lt;/code&gt; 类型上实现这两个特征，该类型已经在其上实现了名为 &lt;code&gt;fly&lt;/code&gt; 的方法。每种 &lt;code&gt;fly&lt;/code&gt; 方法都做不同的事情。</target>
        </trans-unit>
        <trans-unit id="09c7e5de85184f1e292948f95737d163821f3f97" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that &lt;em&gt;either&lt;/em&gt; the pointer is NULL &lt;em&gt;or&lt;/em&gt; all of the following is true:</source>
          <target state="translated">调用此方法时，你必须确保&lt;em&gt;任何&lt;/em&gt;指针为NULL&lt;em&gt;或&lt;/em&gt;以下所有为真：</target>
        </trans-unit>
        <trans-unit id="5922155f29f105357a025f039108b9a7d5336187" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that all of the following is true:</source>
          <target state="translated">当调用这个方法时,你必须确保以下所有内容为真。</target>
        </trans-unit>
        <trans-unit id="58559539ea94cb174e20c16d3a491d3f60daa52c" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">调用此方法时，你必须确保，如果指针非NULL，那么它是正确对齐，dereferencable（对于全尺寸 &lt;code&gt;T&lt;/code&gt; ）和指向的初始化实例 &lt;code&gt;T&lt;/code&gt; 。即使未使用此方法的结果也是如此！ （关于初始化的部分尚未完全确定，但是直到唯一安全的方法是确保它们确实被初始化。）</target>
        </trans-unit>
        <trans-unit id="154fd499f0df8e4395e27a0bd336a9bcab4964e5" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">调用此方法时，你必须确保，如果指针非NULL，那么它是正确对齐，dereferencable（对于全尺寸 &lt;code&gt;T&lt;/code&gt; ）和指向的初始化实例 &lt;code&gt;T&lt;/code&gt; 。即使未使用此方法的结果也是如此！（关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。）</target>
        </trans-unit>
        <trans-unit id="b55e6ba28b9895615b66213ef2f73826e6f58739" translate="yes" xml:space="preserve">
          <source>When can my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">我什么时候可以 &lt;code&gt;Copy&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="cee1d8053db523d0e331e35fb72c4806ed64bb77" translate="yes" xml:space="preserve">
          <source>When casting, keep in mind that only primitive types can be cast into each other. Example:</source>
          <target state="translated">当投射时,请记住,只有基元类型可以相互投射。例如</target>
        </trans-unit>
        <trans-unit id="d4a2dc7caf12d861d68e9e941b267ef0330f899f" translate="yes" xml:space="preserve">
          <source>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their addition data compared.</source>
          <target state="translated">当比较指针时，它们是通过它们的地址而不是它们指向的对象来比较的。当将指针与&lt;a href=&quot;../dynamically-sized-types&quot;&gt;动态大小的类型&lt;/a&gt;进行比较时，它们还将其附加数据进行比较。</target>
        </trans-unit>
        <trans-unit id="f2f745dfedc8e3dcf7cd93386db2954df66d81dc" translate="yes" xml:space="preserve">
          <source>When comparing raw pointers they are compared by their address, rather than by what they point to. When comparing raw pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their additional data compared.</source>
          <target state="translated">比较原始指针时，将通过其地址（而不是它们所指向的地址）对它们进行比较。在将原始指针与&lt;a href=&quot;../dynamically-sized-types&quot;&gt;动态大小的类型&lt;/a&gt;进行比较时，它们还将其附加数据进行比较。</target>
        </trans-unit>
        <trans-unit id="c1a443c0cb167970fd613da945b3f247baaf5ed2" translate="yes" xml:space="preserve">
          <source>When comparison is impossible:</source>
          <target state="translated">当比较是不可能的。</target>
        </trans-unit>
        <trans-unit id="09f829ddc19ecb8dff523da8b6aa0bd5c5c69a9a" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">与加载耦合时，如果加载的值是由具有&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;（或更强）排序的存储操作写入的，则所有后续操作在该存储之后都将变为有序。特别是，所有后续加载将看到在存储之前写入的数据。</target>
        </trans-unit>
        <trans-unit id="042e1556a905fd63df9a9011e6b9eaa088ecbd8b" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">与加载耦合时，如果加载的值是由具有&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;（或更高级）排序的存储操作写入的，则所有后续操作在该存储之后都将被排序。特别是，所有后续加载将看到在存储之前写入的数据。</target>
        </trans-unit>
        <trans-unit id="c91753b6ff7ee275cf69a5dce0e73e0bd2e33946" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">与商店耦合时，所有以前的操作都将在使用&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;（或更强）排序对该值的任何负载之前进行排序。特别是，所有以前的写入操作对执行此值的&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;（或更强）加载的所有线程均可见。</target>
        </trans-unit>
        <trans-unit id="a96f1d52823f389b197a0d9cfba10684464e92e3" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">与商店耦合时，所有以前的操作都将在使用&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;（或更强）排序对该值进行任何加载之前进行排序。特别是，所有以前的写入操作对执行此值的&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;（或更强）加载的所有线程均可见。</target>
        </trans-unit>
        <trans-unit id="c5257416252adc45097a1b4beca1249797335afe" translate="yes" xml:space="preserve">
          <source>When created, cursors start at the front of the list, or the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="translated">创建时,游标从列表的前面开始,如果列表为空,则从 &quot;幽灵 &quot;非元素开始。</target>
        </trans-unit>
        <trans-unit id="91d1a77fcc1e6a3499230bbe1efaa4ab2267c420" translate="yes" xml:space="preserve">
          <source>When creating immutable and mutable references, we use the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; syntax, respectively. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we use the &lt;code&gt;borrow&lt;/code&gt; and &lt;code&gt;borrow_mut&lt;/code&gt; methods, which are part of the safe API that belongs to &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;borrow&lt;/code&gt; method returns the smart pointer type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;borrow_mut&lt;/code&gt; returns the smart pointer type &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt;. Both types implement &lt;code&gt;Deref&lt;/code&gt;, so we can treat them like regular references.</source>
          <target state="translated">创建不可变和可变引用时，我们分别使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 语法。与 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，我们用 &lt;code&gt;borrow&lt;/code&gt; 和 &lt;code&gt;borrow_mut&lt;/code&gt; 方法，这是属于安全API的一部分 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 。的 &lt;code&gt;borrow&lt;/code&gt; 方法返回智能指针类型 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;borrow_mut&lt;/code&gt; 返回智能指针类型 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 。两种类型都实现 &lt;code&gt;Deref&lt;/code&gt; ，因此我们可以将它们视为常规引用。</target>
        </trans-unit>
        <trans-unit id="d153302e6c43d39140a619c03bdcafd574d25849" translate="yes" xml:space="preserve">
          <source>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. Using procedural macros looks like the code in Listing 19-29, where &lt;code&gt;some_attribute&lt;/code&gt; is a placeholder for using a specific macro.</source>
          <target state="translated">创建过程宏时，定义必须驻留在自己的带有特殊板条箱类型的板条箱中。这是由于复杂的技术原因，我们希望将来消除。使用过程宏看起来像清单19-29中的代码，其中 &lt;code&gt;some_attribute&lt;/code&gt; 是使用特定宏的占位符。</target>
        </trans-unit>
        <trans-unit id="ba2b321ad5c05c7fd09164d2ee9abbba93ac268f" translate="yes" xml:space="preserve">
          <source>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</source>
          <target state="translated">在定义一个使用泛型的函数时,我们将泛型放在函数的签名中,通常我们会在这里指定参数和返回值的数据类型。这样做可以使我们的代码更加灵活,为函数的调用者提供更多的功能,同时防止代码重复。</target>
        </trans-unit>
        <trans-unit id="649a6e7ed2c9379226547d6e7e75e552d9d288ba" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">定义递归结构或枚举时，从定义内部定义的类型的任何使用都必须在指针后面（例如 &lt;code&gt;Box&lt;/code&gt; 或 &lt;code&gt;&amp;amp;&lt;/code&gt; ）进行。这是因为结构和枚举必须具有定义良好的大小，并且如果没有指针，则类型的大小将需要不受限制。</target>
        </trans-unit>
        <trans-unit id="54e2930486f06054c79b2d368c2769ebefeaab63" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">在定义递归结构或枚举时，从定义内部定义的类型的任何使用都必须在指针后面进行（例如 &lt;code&gt;Box&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;Rc&lt;/code&gt; ）。这是因为结构和枚举必须具有明确定义的大小，并且如果没有指针，则类型的大小将需要不受限制。</target>
        </trans-unit>
        <trans-unit id="2c7f1bc79b8fb9a6a685b72bb3e271975e8e2732" translate="yes" xml:space="preserve">
          <source>When derived on structs, &lt;code&gt;PartialOrd&lt;/code&gt; compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</source>
          <target state="translated">当从结构派生时， &lt;code&gt;PartialOrd&lt;/code&gt; 通过按字段在结构定义中出现的顺序比较每个字段中的值来比较两个实例。当从枚举派生时，在枚举定义中较早声明的枚举的变体被认为小于后面列出的变体。</target>
        </trans-unit>
        <trans-unit id="f282c8c6369ef0fd139eb8e2fef3f5aed8dab06e" translate="yes" xml:space="preserve">
          <source>When enabled, this socket is allowed to send packets to a broadcast address.</source>
          <target state="translated">启用后,允许该套接字向广播地址发送数据包。</target>
        </trans-unit>
        <trans-unit id="761e5afed23cf69a708babbaebf38541084e7e71" translate="yes" xml:space="preserve">
          <source>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final expression is executed, if given.</source>
          <target state="translated">在评估块表达式时,除了项目声明语句外,每条语句都会依次执行。如果给定,则执行最后的表达式。</target>
        </trans-unit>
        <trans-unit id="ee1fcd0e31ceced99f1f3ec881706ad2610edecf" translate="yes" xml:space="preserve">
          <source>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The &lt;code&gt;ident&lt;/code&gt;, &lt;code&gt;lifetime&lt;/code&gt;, and &lt;code&gt;tt&lt;/code&gt; fragment types are an exception, and &lt;em&gt;can&lt;/em&gt; be matched by literal tokens. The following illustrates this restriction:</source>
          <target state="translated">例如，将匹配的片段转发到另一个宏时，第二个宏中的匹配器将看到片段类型的不透明AST。第二个宏不能使用文字标记来匹配匹配器中的片段，只能使用相同类型的片段说明符。的 &lt;code&gt;ident&lt;/code&gt; ， &lt;code&gt;lifetime&lt;/code&gt; ，和 &lt;code&gt;tt&lt;/code&gt; 的片段类型是一个例外，并且&lt;em&gt;可以&lt;/em&gt;由数字令牌相匹配。以下说明了此限制：</target>
        </trans-unit>
        <trans-unit id="9aca28029ce8b3b95a609b5e4ca6542143135bed" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; implementation).</source>
          <target state="translated">在实现&lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;组合器时，通常需要对嵌套的Future进行结构固定，因为您需要获取对其的固定引用以调用&lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt;。但是，如果您的组合器包含不需要固定的任何其他数据，则可以使那些字段不具有结构性，因此即使您只有&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; （例如，在您自己的&lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt;实现中），也可以使用可变引用自由访问它们。）。</target>
        </trans-unit>
        <trans-unit id="7c0607e7e68ca3e721e6db0ea6bb7b2aa2a0922c" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;code&gt;poll&lt;/code&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;code&gt;poll&lt;/code&gt; implementation).</source>
          <target state="translated">在实现&lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;组合器时，通常需要对嵌套的Future进行结构固定，因为您需要获取对其的固定引用以调用 &lt;code&gt;poll&lt;/code&gt; 。但是，如果您的组合器包含不需要固定的任何其他数据，则可以使这些字段不具有结构性，因此即使您只有 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; （例如，在您自己的 &lt;code&gt;poll&lt;/code&gt; 实现中），也可以使用可变引用自由地访问它们）。</target>
        </trans-unit>
        <trans-unit id="3023d431ee0ca325e5e6237d2618e2a98462263f" translate="yes" xml:space="preserve">
          <source>When implementing a foreign trait for a foreign type, the trait must have one or more type parameters. A type local to your crate must appear before any use of any type parameters.</source>
          <target state="translated">当为一个外来类型实现一个外来特征时,该特征必须有一个或多个类型参数。在使用任何类型参数之前,你的箱子必须有一个本地类型。</target>
        </trans-unit>
        <trans-unit id="83728ab8db088c5c5e2bb91d0aa5ec68f4bff8ed" translate="yes" xml:space="preserve">
          <source>When implementing a format trait for your own type, you will have to implement a method of the signature:</source>
          <target state="translated">在为自己的类型实现格式特征时,你必须实现签名的方法。</target>
        </trans-unit>
        <trans-unit id="f71a495d94aa8ee98863b069031787f4cf122fc5" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">在实现 &lt;code&gt;ExactSizeIterator&lt;/code&gt; 时，还必须实现&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;。这样做时，&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt;的实现&lt;em&gt;必须&lt;/em&gt;返回迭代器的确切大小。</target>
        </trans-unit>
        <trans-unit id="3b12d14018112fa67f152d3bcca4ff8a3cd2e160" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">在实现 &lt;code&gt;ExactSizeIterator&lt;/code&gt; 时，还必须实现&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;。这样做时，&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt;的实现&lt;em&gt;必须&lt;/em&gt;返回迭代器的确切大小。</target>
        </trans-unit>
        <trans-unit id="fc5662685206bca89b1530dcc1f9af41c4eb9eca" translate="yes" xml:space="preserve">
          <source>When implementing both &lt;code&gt;Hash&lt;/code&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;, it is important that the following property holds:</source>
          <target state="translated">同时实现 &lt;code&gt;Hash&lt;/code&gt; 和&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; 时&lt;/a&gt;，重要的是要保留以下属性：</target>
        </trans-unit>
        <trans-unit id="d4e13d31485717c35b3ad17ef91b724897ba5adb" translate="yes" xml:space="preserve">
          <source>When implementing this trait for &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; we need to pick a type for &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. And since converting a string into a string will never result in an error, the appropriate type is &lt;code&gt;!&lt;/code&gt;. (Currently the type actually used is an enum with no variants, though this is only because &lt;code&gt;!&lt;/code&gt; was added to Rust at a later date and it may change in the future.) With an &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type of &lt;code&gt;!&lt;/code&gt;, if we have to call &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;String::from_str&lt;/code&gt;&lt;/a&gt; for some reason the result will be a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt;&lt;/a&gt; which we can unpack like this:</source>
          <target state="translated">在为&lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;实现此特征时，我们需要为&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;选择一个类型。并且由于将字符串转换为字符串永远不会导致错误，因此合适的类型是 &lt;code&gt;!&lt;/code&gt; 。（当前实际使用的类型是没有变体的枚举，尽管这仅是因为 &lt;code&gt;!&lt;/code&gt; 是在以后的日期中添加到Rust的，并且将来可能会更改。）&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;类型为 &lt;code&gt;!&lt;/code&gt; 的，如果由于某种原因我们必须调用&lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;String::from_str&lt;/code&gt; &lt;/a&gt;，结果将是&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt; &lt;/a&gt;，我们可以像这样解压缩：</target>
        </trans-unit>
        <trans-unit id="7aa4b7fd6580c50f7056a94460fc482fde8db6bd" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;code&gt;Slice&lt;/code&gt; you simply provide the value &lt;code&gt;PhantomData&lt;/code&gt; for the field &lt;code&gt;phantom&lt;/code&gt;:</source>
          <target state="translated">初始化 &lt;code&gt;Slice&lt;/code&gt; 时,您只需为 &lt;code&gt;phantom&lt;/code&gt; 字段提供值 &lt;code&gt;PhantomData&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="891072d4b25628183370abc4a215b4cbe1b78b5f" translate="yes" xml:space="preserve">
          <source>When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write &lt;code&gt;fieldname&lt;/code&gt; as a shorthand for &lt;code&gt;fieldname: fieldname&lt;/code&gt;. This allows a compact syntax with less duplication. For example:</source>
          <target state="translated">当使用已命名（但未编号）字段初始化数据结构（struct，enum，union）时，可以将 &lt;code&gt;fieldname&lt;/code&gt; 作为 &lt;code&gt;fieldname: fieldname&lt;/code&gt; 的简写形式。这允许使用较少重复的紧凑语法。例如：</target>
        </trans-unit>
        <trans-unit id="8ecea1e59f3ed90e0cce7be9457c55eec0b2f8dd" translate="yes" xml:space="preserve">
          <source>When invoking closures or other implementations of the function traits &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; using call notation, the number of parameters passed to the function must match its definition.</source>
          <target state="translated">使用调用表示法调用函数特征 &lt;code&gt;Fn&lt;/code&gt; ， &lt;code&gt;FnMut&lt;/code&gt; 或 &lt;code&gt;FnOnce&lt;/code&gt; 的闭包或其他实现时，传递给该函数的参数数量必须与其定义相匹配。</target>
        </trans-unit>
        <trans-unit id="ccc9f327284b4385f76159eac1f35c501745b8a3" translate="yes" xml:space="preserve">
          <source>When looking for the implementation for the trait, the compiler finds both the &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; where T is all types and the &lt;code&gt;impl MyTrait for Foo&lt;/code&gt;. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</source>
          <target state="translated">在寻找特征的实现时，编译器会找到 &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; 的impl &amp;lt;T&amp;gt; MyTrait（其中T是所有类型）和 &lt;code&gt;impl MyTrait for Foo&lt;/code&gt; 的impl MyTrait。由于特征不能多次实现，因此这是一个错误。所以，当你写：</target>
        </trans-unit>
        <trans-unit id="696c7265bd3688072f55c2cbcd990beecd847885" translate="yes" xml:space="preserve">
          <source>When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</source>
          <target state="translated">在查找方法调用时,为了调用一个方法,可能会自动去引用或借用接收器。这就需要一个比其他函数更复杂的查找过程,因为可能有很多可能的方法要调用。采用以下程序。</target>
        </trans-unit>
        <trans-unit id="9b2a422583a7efee3ed72f17d4f2851e1858e60e" translate="yes" xml:space="preserve">
          <source>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</source>
          <target state="translated">当与一个范围匹配时,编译器会验证该范围是非空的。范围模式包括两个端点,所以这相当于要求范围的开始小于或等于范围的结束。</target>
        </trans-unit>
        <trans-unit id="b9653a3e395619856456d73e03e247c655234f5c" translate="yes" xml:space="preserve">
          <source>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</source>
          <target state="translated">当与独占范围匹配时,编译器会验证该范围是非空的。排他性范围模式包括起点但不包括终点,所以这相当于要求范围的起点小于范围的终点。</target>
        </trans-unit>
        <trans-unit id="b0e0c88f0138777df9f95477c6fa805a498782e3" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive.</source>
          <target state="translated">当对一个变量进行匹配时,不能在匹配守卫中进行突变,因为这会导致匹配不详尽。</target>
        </trans-unit>
        <trans-unit id="8087590aa98711c0675fa786398706bd350ddbdc" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</source>
          <target state="translated">当对一个变量进行匹配时,不能在匹配守卫中进行突变,因为这会导致匹配不详尽。</target>
        </trans-unit>
        <trans-unit id="c917207922c15bc47219fc846ecafbebb3833877" translate="yes" xml:space="preserve">
          <source>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when &lt;code&gt;Cargo.toml&lt;/code&gt; doesn't specify a crate name, Cargo will transparently replace &lt;code&gt;-&lt;/code&gt; with &lt;code&gt;_&lt;/code&gt; (Refer to &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; for more details).</source>
          <target state="translated">在命名Rust板条箱时，不允许使用连字符。但是，货物包装可能会利用它们。在这种情况下，当 &lt;code&gt;Cargo.toml&lt;/code&gt; 没有指定箱子的名称，货物将透明代替 &lt;code&gt;-&lt;/code&gt; 用 &lt;code&gt;_&lt;/code&gt; （参见&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt;的更多细节）。</target>
        </trans-unit>
        <trans-unit id="4b84b0246e3a22cc957323594b187a4ee8d486c1" translate="yes" xml:space="preserve">
          <source>When only a single thread is involved, the results are as expected: the line &lt;code&gt;7 4 4&lt;/code&gt; gets printed.</source>
          <target state="translated">当仅涉及单个线程时，结果将达到预期：打印第 &lt;code&gt;7 4 4&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="631b2d61cf855b93c1989c5cb6e1c8291602cdf2" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">在控制台中操作时,该流的Windows实现不支持非UTF-8字节序列。试图读取非有效的UTF-8字节将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="dbaed3bc410762aacbeb0a4e72c167df5ec7b452" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">在控制台中操作时,该流的Windows实现不支持非UTF-8字节序列。试图写入非有效的UTF-8字节将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="6a8905858177aefd0e233b7b17c0d7132a07f2ef" translate="yes" xml:space="preserve">
          <source>When parsing the path, there is a small amount of normalization:</source>
          <target state="translated">在解析路径时,会有少量的归一化。</target>
        </trans-unit>
        <trans-unit id="de65f313906013336610f9ce397839cdfeef65dc" translate="yes" xml:space="preserve">
          <source>When pattern matching on a non-exhaustive &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt;, matching on a variant does not contribute towards the exhaustiveness of the arms.</source>
          <target state="translated">在非穷举&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; &lt;/a&gt;上进行模式匹配时，在变体上进行匹配不会对臂的穷举做出贡献。</target>
        </trans-unit>
        <trans-unit id="dc9f5f5346d0d53afbe7e6c96b99054e854e83d4" translate="yes" xml:space="preserve">
          <source>When pattern matching on a non-exhaustive variant (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; variant&lt;/a&gt;), a &lt;a href=&quot;../patterns#struct-patterns&quot;&gt;&lt;em&gt;StructPattern&lt;/em&gt;&lt;/a&gt; must be used which must include a &lt;code&gt;..&lt;/code&gt;. Tuple variant constructor visibility is lowered to &lt;code&gt;min($vis, pub(crate))&lt;/code&gt;.</source>
          <target state="translated">当在非穷举的变体（模式匹配&lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 变体&lt;/a&gt;），一个&lt;a href=&quot;../patterns#struct-patterns&quot;&gt;&lt;em&gt;StructPattern&lt;/em&gt;&lt;/a&gt;必须使用其中必须包括一个 &lt;code&gt;..&lt;/code&gt; 。元组变体构造函数的可见性降低到 &lt;code&gt;min($vis, pub(crate))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3822f9e7b18bc62d671d8d3984cc7775a10aa571" translate="yes" xml:space="preserve">
          <source>When re-exporting a private item, it can be thought of as allowing the &quot;privacy chain&quot; being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</source>
          <target state="translated">当重新导出一个私有项目时,可以认为是允许 &quot;隐私链 &quot;通过重新导出被短路,而不是像通常那样通过命名空间层次结构。</target>
        </trans-unit>
        <trans-unit id="9af3e2801218bbefe9fcf6ba2cdb6292e76c830f" translate="yes" xml:space="preserve">
          <source>When referred to, a &lt;em&gt;function&lt;/em&gt; yields a first-class &lt;em&gt;value&lt;/em&gt; of the corresponding zero-sized &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;function item type&lt;/em&gt;&lt;/a&gt;, which when called evaluates to a direct call to the function.</source>
          <target state="translated">引用时，&lt;em&gt;函数会&lt;/em&gt;产生相应的零大小&lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;函数项类型&lt;/em&gt;&lt;/a&gt;的第一类&lt;em&gt;值&lt;/em&gt;，当调用该函数时，该值会求直接调用该函数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683091416dacec74442beb6b8e2ae04cddfafa2" translate="yes" xml:space="preserve">
          <source>When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its &lt;em&gt;function item type&lt;/em&gt;. That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</source>
          <target state="translated">引用功能项或类似元组的struct或enum的构造&lt;em&gt;函数时&lt;/em&gt;，其&lt;em&gt;功能项类型&lt;/em&gt;的大小为零。该类型明确标识了该函数-其名称，其类型参数和其早期绑定的生存期参数（但不是其后期绑定的生存期参数，后者仅在调用函数时才分配）-因此，该值不需要包含实际的函数指针，并且在调用函数时不需要间接调用。</target>
        </trans-unit>
        <trans-unit id="242796f19057c3b62462e9cba8dd8c2590aadff7" translate="yes" xml:space="preserve">
          <source>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</source>
          <target state="translated">当涉及重复时,规则适用于所有可能的扩展数,并考虑到分隔符。这意味着:</target>
        </trans-unit>
        <trans-unit id="c3d84541bce134cd9e4b390eb66c9f391f2b9c11" translate="yes" xml:space="preserve">
          <source>When requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via &lt;code&gt;{:x}&lt;/code&gt; (like &lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;). The current mapping of types to traits is:</source>
          <target state="translated">当要求将参数格式化为特定类型时，实际上是在要求参数归因于特定特征。这允许通过 &lt;code&gt;{:x}&lt;/code&gt; 格式化多个实际类型（例如&lt;a href=&quot;../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt;以及&lt;a href=&quot;../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt;）。当前类型到特征的映射为：</target>
        </trans-unit>
        <trans-unit id="172f2234ac85fe1a3605f2a91c946d179cec1a7e" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0).</source>
          <target state="translated">当返回值溢出时（即， &lt;code&gt;uN&lt;/code&gt; 类型的 &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; ），它将在调试模式下崩溃，在释放模式下返回值包装为0（唯一的方法可以返回0的情况） 。</target>
        </trans-unit>
        <trans-unit id="edd8cc343e5de387a9b54e7b83ae697de445cc0a" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), overflows to &lt;code&gt;2^N = 0&lt;/code&gt;.</source>
          <target state="translated">当返回值溢出时（即 &lt;code&gt;uN&lt;/code&gt; 类型的 &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; ），溢出到 &lt;code&gt;2^N = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba5cb533c56f4e80ee649a64f4f48b9916ee9878" translate="yes" xml:space="preserve">
          <source>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does &lt;em&gt;not&lt;/em&gt; refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the &lt;code&gt;longest&lt;/code&gt; function that won&amp;rsquo;t compile:</source>
          <target state="translated">从函数返回引用时，返回类型的有效期参数需要与其中一个参数的有效期参数匹配。如果返回的引用&lt;em&gt;未&lt;/em&gt;引用参数之一，则它必须引用在此函数内创建的值，该值将是悬空引用，因为该值将在函数末尾超出范围。考虑一下 &lt;code&gt;longest&lt;/code&gt; 函数无法编译的这种尝试实现：</target>
        </trans-unit>
        <trans-unit id="9ba5a0cad76ddab0bb154107936aabf9c3bbc80c" translate="yes" xml:space="preserve">
          <source>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</source>
          <target state="translated">当运行清单16-10中的代码时,你应该看到以下输出,每行之间有1秒的停顿。</target>
        </trans-unit>
        <trans-unit id="6b236fc247e64f3c8aa065d156b22dcb57f154a9" translate="yes" xml:space="preserve">
          <source>When searching for a value in the map, however, having to provide a reference to a &lt;code&gt;K&lt;/code&gt; as the key to search for would require to always create such an owned value. For string keys, this would mean a &lt;code&gt;String&lt;/code&gt; value needs to be created just for the search for cases where only a &lt;code&gt;str&lt;/code&gt; is available.</source>
          <target state="translated">但是，当在地图中搜索值时，必须提供对 &lt;code&gt;K&lt;/code&gt; 的引用作为搜索关键字，这将需要始终创建此类拥有的值。对于字符串键，这意味着仅在搜索只有 &lt;code&gt;str&lt;/code&gt; 可用的情况下才需要创建 &lt;code&gt;String&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="b091e7c5109a4bd476e6a41500e0c7dae79d2e20" translate="yes" xml:space="preserve">
          <source>When should &lt;code&gt;UnwindSafe&lt;/code&gt; be used?</source>
          <target state="translated">何时应使用 &lt;code&gt;UnwindSafe&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="e948e1fccd691ef6c810406fc6cc8816126b310a" translate="yes" xml:space="preserve">
          <source>When starting from a slice rather than an array, fallible conversion APIs can be used:</source>
          <target state="translated">当从分片而不是数组开始时,可以使用易错的转换API。</target>
        </trans-unit>
        <trans-unit id="9972ed917e94de2af5e7cf0dfc874ef3575cd482" translate="yes" xml:space="preserve">
          <source>When such a string in &lt;code&gt;monospace&lt;/code&gt; font occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; for more information.</source>
          <target state="translated">当这种 &lt;code&gt;monospace&lt;/code&gt; 字体的字符串出现在语法内部时，它是对这种字符串表产生的单个成员的隐式引用。有关更多信息，请参见&lt;a href=&quot;tokens&quot;&gt;令牌&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a52c1f9d28a81019545579685f71cebe8cd39993" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; on the same stream can cause data loss. Reading from the underlying reader after unwrapping the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.bufreader#method.into_inner&quot;&gt;&lt;code&gt;BufReader::into_inner&lt;/code&gt;&lt;/a&gt; can also cause data loss.</source>
          <target state="translated">当 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 被丢弃，其缓冲器的内容将被丢弃。在同一流上创建 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 多个实例可能会导致数据丢失。用&lt;a href=&quot;struct.bufreader#method.into_inner&quot;&gt; &lt;code&gt;BufReader::into_inner&lt;/code&gt; &lt;/a&gt; &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 后，从基础阅读器读取数据也会导致数据丢失。</target>
        </trans-unit>
        <trans-unit id="954b4d58192a34fc7c83e90ef17c03453e2596e2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&lt;/code&gt; on the same stream can cause data loss.</source>
          <target state="translated">当 &lt;code&gt;BufReader&lt;/code&gt; 被丢弃，其缓冲区的内容将被丢弃。在同 &lt;code&gt;BufReader&lt;/code&gt; 上创建BufReader的多个实例可能会导致数据丢失。</target>
        </trans-unit>
        <trans-unit id="f6535869e34b4050ebcca71930a99c22bd0cf5ef" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufWriter&lt;/code&gt; is dropped, the contents of its buffer will be written out. However, any errors that happen in the process of flushing the buffer when the writer is dropped will be ignored. Code that wishes to handle such errors must manually call &lt;a href=&quot;#method.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before the writer is dropped.</source>
          <target state="translated">当 &lt;code&gt;BufWriter&lt;/code&gt; 被删除，它的缓冲区的内容将被写入了。但是，删除写入器时在刷新缓冲区的过程中发生的任何错误都将被忽略。希望处理此类错误的代码必须在删除&lt;a href=&quot;#method.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;之前手动调用flush。</target>
        </trans-unit>
        <trans-unit id="04aee49349dde3129af240e6a8534c1c64ddefad" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Deref&lt;/code&gt; trait is defined for the types involved, Rust will analyze the types and use &lt;code&gt;Deref::deref&lt;/code&gt; as many times as necessary to get a reference to match the parameter&amp;rsquo;s type. The number of times that &lt;code&gt;Deref::deref&lt;/code&gt; needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</source>
          <target state="translated">当 &lt;code&gt;Deref&lt;/code&gt; 性状所涉及的类型定义，锈病将分析类型和使用 &lt;code&gt;Deref::deref&lt;/code&gt; 多次需要得到一个参考，以匹配参数的类型。需要插入 &lt;code&gt;Deref::deref&lt;/code&gt; 的次数在编译时已解决，因此，利用deref强制不会造成运行时损失！</target>
        </trans-unit>
        <trans-unit id="31fb02d0ce651e092ef0bf35613e23e7b377e4aa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;get&lt;/code&gt; method is passed an index that is outside the vector, it returns &lt;code&gt;None&lt;/code&gt; without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that&amp;rsquo;s too large and the program gets a &lt;code&gt;None&lt;/code&gt; value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!</source>
          <target state="translated">当将 &lt;code&gt;get&lt;/code&gt; 方法传递给向量之外的索引时，它将返回 &lt;code&gt;None&lt;/code&gt; 且不会惊慌。如果在正常情况下偶尔访问超出向量范围的元素，则可以使用此方法。然后，您的代码将具有处理 &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; 的逻辑，如第6章所述。例如，索引可能来自输入数字的人。如果他们不小心输入了一个太大的数字，并且程序获得了 &lt;code&gt;None&lt;/code&gt; 值，则可以告诉用户当前向量中有多少个项目，并给他们另一个输入有效值的机会。这将比由于输入错误而使程序崩溃更人性化！</target>
        </trans-unit>
        <trans-unit id="f59c09946d769635e38aad7d10ee44a827a7f14d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn&amp;rsquo;t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our &lt;code&gt;match&lt;/code&gt; has four arms.</source>
          <target state="translated">当 &lt;code&gt;match&lt;/code&gt; 表达式执行时，它会按顺序将结果值与每个手臂的模式进行比较。如果某个模式与该值匹配，那么将执行与该模式关联的代码。如果该模式与值不匹配，则执行继续到下一个分支，就像在硬币分类机中一样。我们可以根据需要提供任意数量的武器：在清单6-3中，我们的 &lt;code&gt;match&lt;/code&gt; 有4个武器。</target>
        </trans-unit>
        <trans-unit id="35dd3cadb8620e015a10c1b7eff5115846f46fce" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression is done, its scope ends, and so does the scope of the inner &lt;code&gt;y&lt;/code&gt;. The last &lt;code&gt;println!&lt;/code&gt; produces &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;match&lt;/code&gt; 表达式完成时，它的范围的端部，所以确实内的范围 &lt;code&gt;y&lt;/code&gt; 。最后的 &lt;code&gt;println!&lt;/code&gt; 最后产生 &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68d6c3c2b2d97df1f5ec2a0c2cfb150473278b62" translate="yes" xml:space="preserve">
          <source>When the associated function is declared on a trait, the function can also be called with a &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; that is a path to the trait appended by the name of the trait. When this happens, it is substituted for &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt;.</source>
          <target state="translated">在特征上声明关联的函数时，也可以使用&lt;a href=&quot;../paths&quot;&gt;路径&lt;/a&gt;来调用该函数，该路径是到特征的路径后附加特征名称。发生这种情况时，它将用 &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="bd35bbcd5c352ce9d75d44366396e7a4adb6ff6a" translate="yes" xml:space="preserve">
          <source>When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the &lt;code&gt;value&lt;/code&gt; method. This method checks whether we already have a resulting value in &lt;code&gt;self.value&lt;/code&gt; in a &lt;code&gt;Some&lt;/code&gt;; if we do, it returns the value within the &lt;code&gt;Some&lt;/code&gt; without executing the closure again.</source>
          <target state="translated">当调用代码需要评估闭包的结果时，它将直接调用 &lt;code&gt;value&lt;/code&gt; 方法，而不是直接调用闭包。这个方法检查我们是否已经有了一个结果值 &lt;code&gt;self.value&lt;/code&gt; 的 &lt;code&gt;Some&lt;/code&gt; ; 如果这样做，它将返回 &lt;code&gt;Some&lt;/code&gt; 中的值，而无需再次执行关闭操作。</target>
        </trans-unit>
        <trans-unit id="b1a7e675e1dcb1e2ab13e918ca4b37b70a8d5bf1" translate="yes" xml:space="preserve">
          <source>When the command line parsing logic starts getting complicated, extract it from &lt;em&gt;main.rs&lt;/em&gt; and move it to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="translated">当命令行解析逻辑开始越来越复杂，从提取它&lt;em&gt;main.rs&lt;/em&gt;并将其移动到&lt;em&gt;lib.rs&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f005b1e8a05e081cd9cbf74c1d92789005c2778" translate="yes" xml:space="preserve">
          <source>When the configuration predicate is true, this attribute expands out to the attributes listed after the predicate. For example, the following module will either be found at &lt;code&gt;linux.rs&lt;/code&gt; or &lt;code&gt;windows.rs&lt;/code&gt; based on the target.</source>
          <target state="translated">当配置谓词为true时，此属性扩展为该谓词之后列出的属性。例如，将根据目标在 &lt;code&gt;linux.rs&lt;/code&gt; 或 &lt;code&gt;windows.rs&lt;/code&gt; 中找到以下模块。</target>
        </trans-unit>
        <trans-unit id="b2cac43891907079676afac07f98ef2691d9a0f5" translate="yes" xml:space="preserve">
          <source>When the draft is done, a review of the post is requested.</source>
          <target state="translated">稿子写好后,要求审帖。</target>
        </trans-unit>
        <trans-unit id="81c2e18caa886f869f8ca82f7d008cc861e8f29d" translate="yes" xml:space="preserve">
          <source>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</source>
          <target state="translated">当使用空字符串作为分隔符时,它会将字符串中的每个字符以及字符串的开头和结尾分开。</target>
        </trans-unit>
        <trans-unit id="8391463b3513744ada63d41c0e15df2b575fc578" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;../fs/struct.file#method.open&quot;&gt;&lt;code&gt;fs::File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../fs/struct.openoptions#method.open&quot;&gt;&lt;code&gt;fs::OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">如果目标只是读取（或写入）源，则可以读取（或写入）测试源的最可靠方法是打开它。例如，仅在类Unix系统上，使用 &lt;code&gt;is_file&lt;/code&gt; 才能中断 &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; 类的工作流。有关更多信息，请参见&lt;a href=&quot;../fs/struct.file#method.open&quot;&gt; &lt;code&gt;fs::File::open&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../fs/struct.openoptions#method.open&quot;&gt; &lt;code&gt;fs::OpenOptions::open&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8b88e35933dd499afe9dc518b98a0ae7b4608c2" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">如果目标只是读取（或写入）源，则可以读取（或写入）测试源的最可靠方法是打开它。例如，仅在类Unix系统上，使用 &lt;code&gt;is_file&lt;/code&gt; 才能中断 &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; 类的工作流。有关更多信息，请参见&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.openoptions#method.open&quot;&gt; &lt;code&gt;OpenOptions::open&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="993a1dfbbbb04483419f87e35c0750d6b041320f" translate="yes" xml:space="preserve">
          <source>When the inner scope ends, &lt;code&gt;branch&lt;/code&gt; goes out of scope and the strong count of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; decreases to 0, so its &lt;code&gt;Node&lt;/code&gt; is dropped. The weak count of 1 from &lt;code&gt;leaf.parent&lt;/code&gt; has no bearing on whether or not &lt;code&gt;Node&lt;/code&gt; is dropped, so we don&amp;rsquo;t get any memory leaks!</source>
          <target state="translated">当内部作用域结束时， &lt;code&gt;branch&lt;/code&gt; 超出作用域，并且 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 的强计数减少为0，因此其 &lt;code&gt;Node&lt;/code&gt; 被丢弃。 &lt;code&gt;leaf.parent&lt;/code&gt; 的弱计数1与 &lt;code&gt;Node&lt;/code&gt; 是否被删除没有关系，因此我们不会发生任何内存泄漏！</target>
        </trans-unit>
        <trans-unit id="92e09a21380ea98a48f9618974476f27f710a28e" translate="yes" xml:space="preserve">
          <source>When the iterator &lt;strong&gt;is&lt;/strong&gt; dropped, all elements in the range are removed from the vector, even if the iterator was not fully consumed. If the iterator &lt;strong&gt;is not&lt;/strong&gt; dropped (with &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; for example), it is unspecified how many elements are removed.</source>
          <target state="translated">当迭代&lt;strong&gt;的&lt;/strong&gt;下降，将范围内的所有元素从向量删除，即使迭代器并没有完全消耗。如果&lt;strong&gt;未&lt;/strong&gt;删除迭代器（例如，使用&lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt;），则未指定要删除的元素数量。</target>
        </trans-unit>
        <trans-unit id="b42ec8800c3cc9133daaff5ef361d3ea73ec622b" translate="yes" xml:space="preserve">
          <source>When the logic to be performed on the value is more complex, we may simply use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the logic afterwards.</source>
          <target state="translated">当要对值执行的逻辑比较复杂时，我们可以简单地使用 &lt;code&gt;entry&lt;/code&gt; API来确保值已初始化并随后执行逻辑。</target>
        </trans-unit>
        <trans-unit id="43d2b59799e2c6b4bb4b98d12d6f70c1cf49277f" translate="yes" xml:space="preserve">
          <source>When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).</source>
          <target state="translated">当Rust程序的主线程终止时,即使其他线程还在运行,整个程序也会关闭。但是,这个模块提供了方便的设施,可以自动等待子线程的终止(即加入)。</target>
        </trans-unit>
        <trans-unit id="c0dc6f3a5195559f8d12308da2db6f2414d40676" translate="yes" xml:space="preserve">
          <source>When the owner goes out of scope, the value will be dropped.</source>
          <target state="translated">当所有者超出范围时,该值将被放弃。</target>
        </trans-unit>
        <trans-unit id="59190310a1258679f5eb021233a840994f9a99c1" translate="yes" xml:space="preserve">
          <source>When the pattern doesn't match:</source>
          <target state="translated">当图案不匹配时。</target>
        </trans-unit>
        <trans-unit id="ecb20a6a7a7f25d225823e98ccb5c961dba326d7" translate="yes" xml:space="preserve">
          <source>When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. Otherwise, the next pattern, including other matches with the &lt;code&gt;|&lt;/code&gt; operator in the same arm, is tested.</source>
          <target state="translated">模式成功匹配后，将执行模式保护表达式。如果表达式的计算结果为true，则表示模式已成功匹配。否则，下一个模式，包括与 &lt;code&gt;|&lt;/code&gt; 匹配的其他匹配项 同一手臂的操作员，经过测试。</target>
        </trans-unit>
        <trans-unit id="b7f41ee353730e0c1a0a6d3264ef3197cc06c52f" translate="yes" xml:space="preserve">
          <source>When the post is approved, it gets published.</source>
          <target state="translated">当帖子被批准后,它就会被发布。</target>
        </trans-unit>
        <trans-unit id="41bc650167a3c0cb28cbdf2fe35163fe7bda095c" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work if we also try to refer to that element later in the function:</source>
          <target state="translated">当程序具有有效的引用时，借用检查器将执行所有权和借用规则（在第4章中介绍），以确保该引用和对向量内容的任何其他引用保持有效。回想一下规则，该规则规定在同一范围内不能有可变引用和不可变引用。该规则适用于清单8-7，其中我们对向量中的第一个元素持有不可变的引用，并尝试将元素添加到末尾，如果我们稍后还要在函数中引用该元素，则该规则将不起作用：</target>
        </trans-unit>
        <trans-unit id="f7ce9475a843aa2869fe7fade2558fcd95ae51c8" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work.</source>
          <target state="translated">当程序具有有效的引用时，借用检查器将执行所有权和借用规则（在第4章中介绍），以确保该引用和对向量内容的任何其他引用保持有效。回想一下规则，该规则规定在同一范围内不能有可变引用和不可变引用。该规则适用于清单8-7，其中我们对向量中的第一个元素持有不变的引用，并尝试将元素添加到末尾，这是行不通的。</target>
        </trans-unit>
        <trans-unit id="f773a5aea5eb96eca971d71eeb66cfae58b30a5a" translate="yes" xml:space="preserve">
          <source>When the programmer has enabled &lt;code&gt;debug_assert!&lt;/code&gt; assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that &lt;code&gt;panic&lt;/code&gt; on overflow. Other kinds of builds may result in &lt;code&gt;panics&lt;/code&gt; or silently wrapped values on overflow, at the implementation's discretion.</source>
          <target state="translated">当程序员启用 &lt;code&gt;debug_assert!&lt;/code&gt; 断言（例如，通过启用未优化的构建），实现必须插入在溢出时会出现 &lt;code&gt;panic&lt;/code&gt; 动态检查。根据实现的判断，其他类型的构建可能会导致溢出时出现 &lt;code&gt;panics&lt;/code&gt; 或默默包装的值。</target>
        </trans-unit>
        <trans-unit id="ce3f6166f132f399bf38664a6cccbedbde5ef26e" translate="yes" xml:space="preserve">
          <source>When the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</source>
          <target state="translated">当scrutinee表达式是&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place表达式时&lt;/a&gt;，匹配项不会分配临时位置；但是，按值绑定可以从内存位置复制或移动。在可能的情况下，最好在位置表达式上进行匹配，因为这些匹配项的生存期会继承位置表达式的生存期，而不是局限于匹配项内部。</target>
        </trans-unit>
        <trans-unit id="2c72e3065d1cd65994fce834d0430d9416ecec2e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.</source>
          <target state="translated">当分片len没有被分块大小平均分配时,迭代的最后一个分片将是剩余部分。</target>
        </trans-unit>
        <trans-unit id="28062354592a563db8e797c18e0e70b8ef604bb5" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.arraychunks#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">当切片len不均匀地除以块大小时，最后的 &lt;code&gt;N-1&lt;/code&gt; 个元素将被省略，但可以从迭代器的&lt;a href=&quot;struct.arraychunks#method.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt;函数中检索。</target>
        </trans-unit>
        <trans-unit id="da0fda08da1d4cf85762ce95953612e1248e0072" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.arraychunksmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">当切片len不均匀地除以块大小时，最后的 &lt;code&gt;N-1&lt;/code&gt; 个元素将被省略，但可以从迭代器的&lt;a href=&quot;struct.arraychunksmut#method.into_remainder&quot;&gt; &lt;code&gt;into_remainder&lt;/code&gt; &lt;/a&gt;函数中检索。</target>
        </trans-unit>
        <trans-unit id="fff85a9a955873b521d1857eca1f1e9a549be54e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">如果切片len不均匀地除以块大小，则最后一个不超过 &lt;code&gt;chunk_size-1&lt;/code&gt; 个元素将被省略，但可以从迭代器的&lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt;函数中检索。</target>
        </trans-unit>
        <trans-unit id="380f0182bf0446b4645382de4340b8f27ea208b9" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">如果切片len不均匀地除以块大小，则最后一个不超过 &lt;code&gt;chunk_size-1&lt;/code&gt; 个元素将被省略，但可以从迭代器的&lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt; &lt;code&gt;into_remainder&lt;/code&gt; &lt;/a&gt;函数中检索。</target>
        </trans-unit>
        <trans-unit id="c18714384f2b643a8c87f83e941ef77f216c1e30" translate="yes" xml:space="preserve">
          <source>When the source is an owning iterator struct (commonly called &lt;code&gt;IntoIter&lt;/code&gt;) then this can be useful for specializing &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; implementations or recovering the remaining elements after an iterator has been partially exhausted.</source>
          <target state="translated">当源是拥有的迭代器结构（通常称为 &lt;code&gt;IntoIter&lt;/code&gt; ）时，这对于专用于&lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; 的&lt;/a&gt;实现或在迭代器被部分耗尽后恢复其余元素很有用。</target>
        </trans-unit>
        <trans-unit id="0cb68be86a1a45d1f6b54a16fdad69c0443b3e68" translate="yes" xml:space="preserve">
          <source>When the trailing semicolon is omitted, the result must be type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">如果省略尾部分号，则结果必须为type &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c349a820ac0a64039fea25d4cbecfdfad33b558" translate="yes" xml:space="preserve">
          <source>When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let&amp;rsquo;s tackle that next!</source>
          <target state="translated">删除向量时，其所有内容也将被删除，这意味着将清除其拥有的那些整数。这似乎很简单，但是当您开始引入对向量元素的引用时，可能会变得更加复杂。让我们接下来解决这个问题！</target>
        </trans-unit>
        <trans-unit id="d759cfed67550956f3c467a9677f59d40c90a085" translate="yes" xml:space="preserve">
          <source>When there isn't a &lt;code&gt;Self: Sized&lt;/code&gt; bound on a method, the type of a method receiver must be one of the following types:</source>
          <target state="translated">如果在方法上没有&amp;ldquo; &lt;code&gt;Self: Sized&lt;/code&gt; 约束，则方法接收者的类型必须是以下类型之一：</target>
        </trans-unit>
        <trans-unit id="045b65f5d67968ff8801369e1d99fcba44a4e94a" translate="yes" xml:space="preserve">
          <source>When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations may not appear where intended.</source>
          <target state="translated">当这个闭合运行时,诸如stdio文件描述符和工作目录等方面已经被成功地改变了,所以输出到这些位置的结果可能不会出现在预定的地方。</target>
        </trans-unit>
        <trans-unit id="ad7769a3800701a3a043ec20084e499702706111" translate="yes" xml:space="preserve">
          <source>When this function is used during const evaluation, it may return &lt;code&gt;false&lt;/code&gt; for pointers that turn out to be null at runtime. Specifically, when a pointer to some memory is offset beyond its bounds in such a way that the resulting pointer is null, the function will still return &lt;code&gt;false&lt;/code&gt;. There is no way for CTFE to know the absolute position of that memory, so we cannot tell if the pointer is null or not.</source>
          <target state="translated">在const评估期间使用此函数时，对于在运行时结果为null的指针，它可能返回 &lt;code&gt;false&lt;/code&gt; 。具体来说，当指向某个内存的指针超出其范围的偏移量（使结果指针为null）时，该函数仍将返回 &lt;code&gt;false&lt;/code&gt; 。CTFE无法知道该内存的绝对位置，因此我们无法确定指针是否为空。</target>
        </trans-unit>
        <trans-unit id="9f6792fc653fbacaf2b989ced239eb6fa2deec46" translate="yes" xml:space="preserve">
          <source>When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).</source>
          <target state="translated">当这个函数返回时,保证某个初始化已经运行并完成(可能不是指定的闭包)。它还保证被执行的闭包所执行的任何内存写入都可以在此时被其他线程可靠地观察到(在闭包和返回后执行的代码之间有一个发生-之前的关系)。</target>
        </trans-unit>
        <trans-unit id="6272391ae8d142b8a69f4da76b9108341afacf1f" translate="yes" xml:space="preserve">
          <source>When this method has been called, &lt;code&gt;self&lt;/code&gt; has not yet been deallocated. That only happens after the method is over. If this wasn't the case, &lt;code&gt;self&lt;/code&gt; would be a dangling reference.</source>
          <target state="translated">调用此方法后，尚未释放 &lt;code&gt;self&lt;/code&gt; 。这仅在方法结束后才发生。如果不是这种情况， &lt;code&gt;self&lt;/code&gt; 将是一个悬而未决的参考。</target>
        </trans-unit>
        <trans-unit id="9b04566ec85e491e3fa2ae5cb87abb0c8372d784" translate="yes" xml:space="preserve">
          <source>When this program executes, it checks each &lt;code&gt;if&lt;/code&gt; expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don&amp;rsquo;t see the output &lt;code&gt;number is divisible by 2&lt;/code&gt;, nor do we see the &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; text from the &lt;code&gt;else&lt;/code&gt; block. That&amp;rsquo;s because Rust only executes the block for the first true condition, and once it finds one, it doesn&amp;rsquo;t even check the rest.</source>
          <target state="translated">执行此程序时，它将依次检查每个 &lt;code&gt;if&lt;/code&gt; 表达式并执行条件成立的第一个正文。请注意，即使6被2整除，我们也看不到输出 &lt;code&gt;number is divisible by 2&lt;/code&gt; ，也看不到 &lt;code&gt;else&lt;/code&gt; 块中的 &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; 文本整除。这是因为Rust仅在第一个真实条件下执行该块，并且一旦找到一个条件，它甚至不检查其余部分。</target>
        </trans-unit>
        <trans-unit id="f943a1cfdbb4b42ef0aab62b7f7aa8f670763652" translate="yes" xml:space="preserve">
          <source>When to Use Unsafe Code</source>
          <target state="translated">何时使用不安全代码</target>
        </trans-unit>
        <trans-unit id="e49f07ac591b9df3217836c08c55df9a224df807" translate="yes" xml:space="preserve">
          <source>When to choose interior mutability</source>
          <target state="translated">何时选择内部可变性</target>
        </trans-unit>
        <trans-unit id="34bd2ffda436616fa2dd5a24ddce1b15ffc8ed97" translate="yes" xml:space="preserve">
          <source>When trying to make some type implement a trait &lt;code&gt;Foo&lt;/code&gt;, you must, at minimum, provide implementations for all of &lt;code&gt;Foo&lt;/code&gt;'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</source>
          <target state="translated">当试图使某个类型实现特征 &lt;code&gt;Foo&lt;/code&gt; 时，至少必须为 &lt;code&gt;Foo&lt;/code&gt; 的所有必需方法（意味着没有默认实现的方法）以及任何必需的特征项（如关联类型或类型）提供实现。常数。例：</target>
        </trans-unit>
        <trans-unit id="727739e9ec606ff0128888672a6babe668ea6ab8" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeTo&lt;/code&gt; produces a slice of all array elements before the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">当用作&lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;切片索引时&lt;/a&gt;， &lt;code&gt;RangeTo&lt;/code&gt; 生成由 &lt;code&gt;end&lt;/code&gt; 指示的索引之前的所有数组元素的切片。</target>
        </trans-unit>
        <trans-unit id="e81866ba280f233e50444316cfe195129a341859" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeToInclusive&lt;/code&gt; produces a slice of all array elements up to and including the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">当用作&lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;切片索引时&lt;/a&gt;， &lt;code&gt;RangeToInclusive&lt;/code&gt; 会生成一个所有数组元素的切片，直到并包括 &lt;code&gt;end&lt;/code&gt; 指示的索引。</target>
        </trans-unit>
        <trans-unit id="2b45521f0b2908c3126bcf39f34e601db7fa5296" translate="yes" xml:space="preserve">
          <source>When used as an item or a statement, the &lt;em&gt;MacroInvocationSemi&lt;/em&gt; form is used where a semicolon is required at the end when not using curly braces. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Visibility qualifiers&lt;/a&gt; are never allowed before a macro invocation or &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt;&lt;/a&gt; definition.</source>
          <target state="translated">当用作项目或语句时，使用&lt;em&gt;MacroInvocationSemi&lt;/em&gt;表单，其中不使用花括号时最后需要使用分号。在宏调用或&lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;macro_rules&lt;/code&gt; &lt;/a&gt;定义之前，永远不允许&lt;a href=&quot;visibility-and-privacy&quot;&gt;可见性限定符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="142d83eb0488a8e5aa5cd0f7af5b426b99a98c2b" translate="yes" xml:space="preserve">
          <source>When used on a &lt;a href=&quot;../items/traits&quot;&gt;trait declaration&lt;/a&gt;, a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; to a function that returns an &lt;a href=&quot;../types/impl-trait&quot;&gt;impl trait&lt;/a&gt; of that trait violates the &lt;code&gt;unused_must_use&lt;/code&gt; lint.</source>
          <target state="translated">在&lt;a href=&quot;../items/traits&quot;&gt;特征声明&lt;/a&gt;上使用时，对返回该&lt;a href=&quot;../types/impl-trait&quot;&gt;特征&lt;/a&gt;的impl特征的函数的&lt;a href=&quot;../statements#expression-statements&quot;&gt;表达式语句&lt;/a&gt;的&lt;a href=&quot;../expressions/call-expr&quot;&gt;调用表达式&lt;/a&gt;违反了 &lt;code&gt;unused_must_use&lt;/code&gt; lint。</target>
        </trans-unit>
        <trans-unit id="a852fccfd2a27297b4365a331af8dc1c15ac5f5a" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</source>
          <target state="translated">当使用在trait声明中的函数上时,当调用表达式是来自trait实现的函数时,该行为也适用。</target>
        </trans-unit>
        <trans-unit id="88cab39f222cd92692e6d511980bef189805ee7b" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait implementation, the attribute does nothing.</source>
          <target state="translated">当使用在特质实现中的函数上时,这个属性什么都不做。</target>
        </trans-unit>
        <trans-unit id="a38aec53cd57e4a640fb72d4c596595beee7f334" translate="yes" xml:space="preserve">
          <source>When used on a function, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; is a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; to that function, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">当在函数中使用，如果&lt;a href=&quot;../expressions&quot;&gt;表达&lt;/a&gt;的的&lt;a href=&quot;../statements#expression-statements&quot;&gt;表达式语句&lt;/a&gt;是一个&lt;a href=&quot;../expressions/call-expr&quot;&gt;调用表达式&lt;/a&gt;该功能，那么 &lt;code&gt;unused_must_use&lt;/code&gt; 棉绒被违反。</target>
        </trans-unit>
        <trans-unit id="e4d571aee68c6431041b80e34711ac5e77b8cfc0" translate="yes" xml:space="preserve">
          <source>When used on user-defined composite types, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; has that type, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">当用户定义的复合类型使用，如果&lt;a href=&quot;../expressions&quot;&gt;表达&lt;/a&gt;一个的&lt;a href=&quot;../statements#expression-statements&quot;&gt;表达式语句&lt;/a&gt;具有类型，则 &lt;code&gt;unused_must_use&lt;/code&gt; 棉绒被违反。</target>
        </trans-unit>
        <trans-unit id="370602de292c5acf9300ec1049f6d7b0d030d468" translate="yes" xml:space="preserve">
          <source>When used with the alternate format specifier &lt;code&gt;#?&lt;/code&gt;, the output is pretty-printed.</source>
          <target state="translated">与替代格式说明符 &lt;code&gt;#?&lt;/code&gt; ，输出结果漂亮。</target>
        </trans-unit>
        <trans-unit id="e3c7fb67d8df75a586e35884637385ed0d8f23ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; it may be the case that some of the closed over variables are not unwind safe. For example if &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.</source>
          <target state="translated">当使用&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; 时&lt;/a&gt;，可能会发生某些closed over变量不安全的情况。例如，如果捕获了 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ,则编译器将生成一条警告，指出它不是展开安全的。但是，如果专门考虑了&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt;安全性，则由于catch_unwind的特定用法，实际上可能不是问题。该包装器结构可用于快速且轻量级的注释，该注释的确确实是安全的。</target>
        </trans-unit>
        <trans-unit id="b4aaf8ff7f846237ace4f0a059c82e12475ebd13" translate="yes" xml:space="preserve">
          <source>When using a future, you generally won't call &lt;code&gt;poll&lt;/code&gt; directly, but instead &lt;code&gt;.await&lt;/code&gt; the value.</source>
          <target state="translated">使用 &lt;code&gt;.await&lt;/code&gt; ，通常不会直接调用 &lt;code&gt;poll&lt;/code&gt; ，而是.await值。</target>
        </trans-unit>
        <trans-unit id="206af53865bdd4c9d82650ccc0b648e77c1d1339" translate="yes" xml:space="preserve">
          <source>When using a lifetime like &lt;code&gt;'a&lt;/code&gt; in a type, it must be declared before being used.</source>
          <target state="translated">在类型中使用诸如 &lt;code&gt;'a&lt;/code&gt; 之类的生存期时，必须在使用前声明它。</target>
        </trans-unit>
        <trans-unit id="68d4836a866e67a5b4af384a8eb471ccacc77a13" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt; to a &lt;code&gt;static&lt;/code&gt;. The &lt;a href=&quot;destructors#drop-scopes&quot;&gt;drop scope&lt;/a&gt; of the temporary is usually the end of the enclosing statement.</source>
          <target state="translated">在大多数位置表达式上下文中使用值表达式时，会创建一个临时的未命名存储位置，并将其初始化为该值，并且表达式会求值到该位置，除非&lt;a href=&quot;destructors#constant-promotion&quot;&gt;提升&lt;/a&gt;为 &lt;code&gt;static&lt;/code&gt; 。临时对象的&lt;a href=&quot;destructors#drop-scopes&quot;&gt;删除范围&lt;/a&gt;通常是封闭语句的结尾。</target>
        </trans-unit>
        <trans-unit id="783900079b0706a4642035130b0d4e5b4c18d3f8" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if promoted to &lt;code&gt;'static&lt;/code&gt;. Promotion of a value expression to a &lt;code&gt;'static&lt;/code&gt; slot occurs when the expression could be written in a constant, borrowed, and dereferencing that borrow where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain &lt;a href=&quot;interior-mutability&quot;&gt;interior mutability&lt;/a&gt; or &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; (these properties are determined based on the value where possible, e.g. &lt;code&gt;&amp;amp;None&lt;/code&gt; always has the type &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt;, as it contains nothing disallowed). Otherwise, the lifetime of temporary values is typically</source>
          <target state="translated">在大多数场所表达式上下文中使用值表达式时，会创建一个临时的未命名存储位置，并将其初始化为该值，并且表达式会求值到该位置，除非提升为 &lt;code&gt;'static&lt;/code&gt; 。当可以在不更改运行时行为的情况下将表达式以常量写入，借用并取消引用最初写入表达式的位置时，将值表达式提升为 &lt;code&gt;'static&lt;/code&gt; 插槽&amp;rdquo;。也就是说，可以在编译时评估提升后的表达式，并且结果值不包含&lt;a href=&quot;interior-mutability&quot;&gt;内部可变性&lt;/a&gt;或&lt;a href=&quot;destructors&quot;&gt;析构函数&lt;/a&gt;（这些属性是根据可能的值确定的，例如 &lt;code&gt;&amp;amp;None&lt;/code&gt; 始终具有该类型 &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt; ，因为其中不包含任何不允许的内容）。否则，临时值的生存期通常为</target>
        </trans-unit>
        <trans-unit id="7387e6f07d50e4b94b03c5027eaa0a1074379c4f" translate="yes" xml:space="preserve">
          <source>When using an alias over a function type, you cannot e.g. denote a parameter as being mutable.</source>
          <target state="translated">当在函数类型上使用别名时,不能将参数表示为可突变的。</target>
        </trans-unit>
        <trans-unit id="8e391fe57ab900573f61faa4d08b9fd057fe4752" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">当使用包含范围的迭代时，在迭代结束后未指定&lt;a href=&quot;#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;end()&lt;/code&gt; 的值。要确定包含范围是否为空，请使用&lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt;方法，而不是比较 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a518969d6cf8add6a83ea03a0b5649d4f43920f2" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;struct.rangeinclusive#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">当使用包含范围进行迭代时，在迭代结束后未指定&lt;a href=&quot;struct.rangeinclusive#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;end()&lt;/code&gt; 的值。要确定包含范围是否为空，请使用&lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt;方法，而不是比较 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b41ad7fcc2b6f72dd75060937158a4566bb3d48c" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">当使用包含范围的迭代时，在迭代结束后未指定 &lt;code&gt;start()&lt;/code&gt; 和&lt;a href=&quot;#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt;的值。要确定包含范围是否为空，请使用&lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt;方法，而不是比较 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbb0c63c5182e2af20d41eccf36aeeeb95780341" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;struct.rangeinclusive#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">当使用包含范围进行迭代时，在迭代结束后未指定 &lt;code&gt;start()&lt;/code&gt; 和&lt;a href=&quot;struct.rangeinclusive#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt;的值。要确定包含范围是否为空，请使用&lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt;方法，而不是比较 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d88230c170cac7c9979daeb85327371e8fc8933d" translate="yes" xml:space="preserve">
          <source>When using generators (or async) all type variables must be bound so a generator can be constructed.</source>
          <target state="translated">当使用生成器(或异步)时,所有的类型变量必须被绑定,这样才能构造生成器。</target>
        </trans-unit>
        <trans-unit id="eb4afcd059cb498d340016957478dc07a5b0b9cd" translate="yes" xml:space="preserve">
          <source>When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to &lt;code&gt;inspect()&lt;/code&gt;.</source>
          <target state="translated">使用迭代器时，通常会将其中的几个链接在一起。在处理此类代码时，您可能想检查一下管道中各个部分的情况。为此，请插入对 &lt;code&gt;inspect()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="c5b59408fe1f6f4de1643cf5f48d4f5771ac3565" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</source>
          <target state="translated">在元组结构上使用 &lt;code&gt;#[simd]&lt;/code&gt; 属性时，元组结构的组件必须全部为具体的非泛型类型，以便编译器可以推断出如何将SIMD与它们一起使用。如果类型是通用的，则会发生此错误。</target>
        </trans-unit>
        <trans-unit id="39b563bb5da92b14b1bd3b2de6d3ed8ec3f0fd65" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</source>
          <target state="translated">在元组结构上使用 &lt;code&gt;#[simd]&lt;/code&gt; 属性时，元组中的元素必须是机器类型，以便SIMD操作可以应用于它们。</target>
        </trans-unit>
        <trans-unit id="f68c56eaa365c1195d011c5971774cffabbee19c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</source>
          <target state="translated">当使用 &lt;code&gt;#[simd]&lt;/code&gt; 属性在元组结构中自动使用SIMD操作时，该结构中的类型必须全部为同一类型，否则编译器将触发此错误。</target>
        </trans-unit>
        <trans-unit id="8dd63b3b5f84a11f65877d582b3cb17771f94809" translate="yes" xml:space="preserve">
          <source>When using/declaring an item with generic arguments, you must provide the exact same number:</source>
          <target state="translated">当使用/声明一个带有通用参数的项目时,你必须提供完全相同的数字。</target>
        </trans-unit>
        <trans-unit id="875f23e80d105f6373be722e024a688059c93026" translate="yes" xml:space="preserve">
          <source>When we assign &lt;code&gt;s1&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;, the &lt;code&gt;String&lt;/code&gt; data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.</source>
          <target state="translated">当将 &lt;code&gt;s1&lt;/code&gt; 分配给 &lt;code&gt;s2&lt;/code&gt; 时，将复制 &lt;code&gt;String&lt;/code&gt; 数据，这意味着我们将复制堆栈上的指针，长度和容量。我们不将数据复制到指针引用的堆上。换句话说，存储器中的数据表示如图4-2所示。</target>
        </trans-unit>
        <trans-unit id="20dccc7faf7358ddd1e5e9048cb569181ba72e52" translate="yes" xml:space="preserve">
          <source>When we bring a name into scope with the &lt;code&gt;use&lt;/code&gt; keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code&amp;rsquo;s scope, we can combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;. This technique is called &lt;em&gt;re-exporting&lt;/em&gt; because we&amp;rsquo;re bringing an item into scope but also making that item available for others to bring into their scope.</source>
          <target state="translated">当我们 &lt;code&gt;use&lt;/code&gt; 关键字将名称带入范围时，新范围中可用的名称是私有的。为了使调用我们代码的代码能够像在该代码的作用域中定义的那样引用该名称，我们可以结合 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;pub&lt;/code&gt; 和use。这项技术称为&lt;em&gt;重新导出，&lt;/em&gt;因为我们将某个项目放入范围内，同时也使该项目可供其他人进入其范围。</target>
        </trans-unit>
        <trans-unit id="42f15b600972fbcabaccb1f899d3d65cff52600b" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;fly&lt;/code&gt; on an instance of &lt;code&gt;Human&lt;/code&gt;, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</source>
          <target state="translated">当我们在 &lt;code&gt;Human&lt;/code&gt; 的实例上调用 &lt;code&gt;fly&lt;/code&gt; 时，编译器默认调用直接在该类型上实现的方法，如清单19-17所示。</target>
        </trans-unit>
        <trans-unit id="350ebfd5b3bd82b33fcb60d5557f6b4f388aac65" translate="yes" xml:space="preserve">
          <source>When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the &lt;code&gt;$x&lt;/code&gt; pattern matches three times with the three expressions &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">当我们用 &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; 调用此宏时；中， &lt;code&gt;$x&lt;/code&gt; 图案三次与三个表达式匹配 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，和 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e7bba3d9da7852f6359cc6e672864f837a98a14" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get an error with this core message:</source>
          <target state="translated">当我们编译这段代码时,会得到一个错误的核心信息。</target>
        </trans-unit>
        <trans-unit id="9b6bd2715022e06e450780014c7b5af3817cebde" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get the following error message:</source>
          <target state="translated">当我们编译这段代码时,得到以下错误信息。</target>
        </trans-unit>
        <trans-unit id="d7383a66b159cf7464f68ba405d35045b37c0b59" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get this error:</source>
          <target state="translated">当我们编译这段代码时,我们得到了这个错误。</target>
        </trans-unit>
        <trans-unit id="5e8ce4b2651c1cb04164eadfa1df10bcf9bfb1ce" translate="yes" xml:space="preserve">
          <source>When we compile this example, we get this error:</source>
          <target state="translated">当我们编译这个例子时,我们得到这个错误。</target>
        </trans-unit>
        <trans-unit id="54132a8652e951367540a246425bd7e243e44e7e" translate="yes" xml:space="preserve">
          <source>When we create a new &lt;code&gt;Post&lt;/code&gt;, we set its &lt;code&gt;state&lt;/code&gt; field to a &lt;code&gt;Some&lt;/code&gt; value that holds a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; points to a new instance of the &lt;code&gt;Draft&lt;/code&gt; struct. This ensures whenever we create a new instance of &lt;code&gt;Post&lt;/code&gt;, it will start out as a draft. Because the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; is private, there is no way to create a &lt;code&gt;Post&lt;/code&gt; in any other state! In the &lt;code&gt;Post::new&lt;/code&gt; function, we set the &lt;code&gt;content&lt;/code&gt; field to a new, empty &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">当我们创建一个新的 &lt;code&gt;Post&lt;/code&gt; 时，我们将它的 &lt;code&gt;state&lt;/code&gt; 字段设置为保存 &lt;code&gt;Box&lt;/code&gt; 的 &lt;code&gt;Some&lt;/code&gt; 值。该 &lt;code&gt;Box&lt;/code&gt; 指向 &lt;code&gt;Draft&lt;/code&gt; 结构的新实例。这样可以确保每当我们创建 &lt;code&gt;Post&lt;/code&gt; 的新实例时，它都将作为草稿开始。由于 &lt;code&gt;Post&lt;/code&gt; 的 &lt;code&gt;state&lt;/code&gt; 字段是私有的，因此无法在其他任何状态下创建 &lt;code&gt;Post&lt;/code&gt; ！在 &lt;code&gt;Post::new&lt;/code&gt; 函数中，我们将 &lt;code&gt;content&lt;/code&gt; 字段设置为一个新的空 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bdaf316b9ae5f73e74db4dd3cf073c814edc28e" translate="yes" xml:space="preserve">
          <source>When we create the &lt;code&gt;branch&lt;/code&gt; node, it will also have a new &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference in the &lt;code&gt;parent&lt;/code&gt; field, because &lt;code&gt;branch&lt;/code&gt; doesn&amp;rsquo;t have a parent node. We still have &lt;code&gt;leaf&lt;/code&gt; as one of the children of &lt;code&gt;branch&lt;/code&gt;. Once we have the &lt;code&gt;Node&lt;/code&gt; instance in &lt;code&gt;branch&lt;/code&gt;, we can modify &lt;code&gt;leaf&lt;/code&gt; to give it a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to its parent. We use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; in the &lt;code&gt;parent&lt;/code&gt; field of &lt;code&gt;leaf&lt;/code&gt;, and then we use the &lt;code&gt;Rc::downgrade&lt;/code&gt; function to create a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to &lt;code&gt;branch&lt;/code&gt; from the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</source>
          <target state="translated">当我们创建 &lt;code&gt;branch&lt;/code&gt; 节点时，它在 &lt;code&gt;parent&lt;/code&gt; 字段中还将有一个新的 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 引用，因为 &lt;code&gt;branch&lt;/code&gt; 没有父节点。我们仍然把 &lt;code&gt;leaf&lt;/code&gt; 作为 &lt;code&gt;branch&lt;/code&gt; 的子代之一。将 &lt;code&gt;Node&lt;/code&gt; 实例放置在 &lt;code&gt;branch&lt;/code&gt; 中后，我们可以修改 &lt;code&gt;leaf&lt;/code&gt; 以为其对其父级提供 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 引用。我们使用 &lt;code&gt;borrow_mut&lt;/code&gt; 的方法 &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; 在 &lt;code&gt;parent&lt;/code&gt; 的领域 &lt;code&gt;leaf&lt;/code&gt; ，然后我们使用 &lt;code&gt;Rc::downgrade&lt;/code&gt; 函数来创建 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 从 &lt;code&gt;branch&lt;/code&gt; 中的 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 对 &lt;code&gt;branch.&lt;/code&gt; 弱&amp;lt;Node&amp;gt;引用。</target>
        </trans-unit>
        <trans-unit id="b6d475e631798bcfdbe8b5d49b3651bb13f536b5" translate="yes" xml:space="preserve">
          <source>When we entered &lt;code&gt;*y&lt;/code&gt; in Listing 15-9, behind the scenes Rust actually ran this code:</source>
          <target state="translated">当我们在清单15-9中输入 &lt;code&gt;*y&lt;/code&gt; 时，Rust实际上在后台运行了以下代码：</target>
        </trans-unit>
        <trans-unit id="022643a7b2e9e273dbb19c62148637669a0b154f" translate="yes" xml:space="preserve">
          <source>When we entered the command, Cargo created a &lt;em&gt;Cargo.toml&lt;/em&gt; file, giving us a package. Looking at the contents of &lt;em&gt;Cargo.toml&lt;/em&gt;, there&amp;rsquo;s no mention of &lt;em&gt;src/main.rs&lt;/em&gt; because Cargo follows a convention that &lt;em&gt;src/main.rs&lt;/em&gt; is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains &lt;em&gt;src/lib.rs&lt;/em&gt;, the package contains a library crate with the same name as the package, and &lt;em&gt;src/lib.rs&lt;/em&gt; is its crate root. Cargo passes the crate root files to &lt;code&gt;rustc&lt;/code&gt; to build the library or binary.</source>
          <target state="translated">当我们输入命令时，Cargo创建了一个&lt;em&gt;Cargo.toml&lt;/em&gt;文件，为我们提供了一个包。在&lt;em&gt;查看Cargo.toml&lt;/em&gt;的内容时，没有提到&lt;em&gt;src / main.rs，&lt;/em&gt;因为Cargo遵循一个约定，即&lt;em&gt;src / main.rs&lt;/em&gt;是与包同名的二进制包的包根。同样，Cargo知道，如果程序包目录包含&lt;em&gt;src / lib.rs&lt;/em&gt;，则程序包包含与程序包同名的库条板箱，并且&lt;em&gt;src / lib.rs&lt;/em&gt;是其板条箱根。 Cargo将板条箱根文件传递给 &lt;code&gt;rustc&lt;/code&gt; 以构建库或二进制文件。</target>
        </trans-unit>
        <trans-unit id="457abff93dbe5ac6fded48fa1428f69ee83409b3" translate="yes" xml:space="preserve">
          <source>When we have a &lt;code&gt;Some&lt;/code&gt; value, we know that a value is present and the value is held within the &lt;code&gt;Some&lt;/code&gt;. When we have a &lt;code&gt;None&lt;/code&gt; value, in some sense, it means the same thing as null: we don&amp;rsquo;t have a valid value. So why is having &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; any better than having null?</source>
          <target state="translated">当我们具有 &lt;code&gt;Some&lt;/code&gt; 值时，我们知道存在一个值并将该值保存在 &lt;code&gt;Some&lt;/code&gt; 中。从某种意义上讲，当我们拥有 &lt;code&gt;None&lt;/code&gt; 值时，它意味着与null相同：我们没有有效值。那么，为什么拥有 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 比拥有null更好呢？</target>
        </trans-unit>
        <trans-unit id="f020ca74b67fee23ca0497cca95821474c7cc12b" translate="yes" xml:space="preserve">
          <source>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they&amp;rsquo;re related to the struct fields or the method parameters and return values.</source>
          <target state="translated">在具有生命周期的结构上实现方法时，我们使用与清单10-11中所示的泛型类型参数相同的语法。我们声明和使用生命周期参数的位置取决于它们是否与struct字段或方法参数以及返回值相关。</target>
        </trans-unit>
        <trans-unit id="a57e5870f2a33156805f7bdbcc9a94b3975d0971" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;RHS&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;RHS&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">当我们实现 &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; 时，我们将默认值用于 &lt;code&gt;RHS&lt;/code&gt; ,因为我们想添加两个 &lt;code&gt;Point&lt;/code&gt; 实例。让我们看一个实现 &lt;code&gt;Add&lt;/code&gt; trait 的示例，在该示例中我们想要自定义 &lt;code&gt;RHS&lt;/code&gt; 类型而不是使用默认类型。</target>
        </trans-unit>
        <trans-unit id="bbeae0b47ec877c608d0d21b1b80a717b1578283" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;Rhs&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;Rhs&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">当我们实现 &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; 时，我们为 &lt;code&gt;Rhs&lt;/code&gt; 使用了默认值，因为我们想添加两个 &lt;code&gt;Point&lt;/code&gt; 实例。让我们看一个实现 &lt;code&gt;Add&lt;/code&gt; trait的示例，在该示例中我们想要自定义 &lt;code&gt;Rhs&lt;/code&gt; 类型而不是使用默认类型。</target>
        </trans-unit>
        <trans-unit id="59b1449687c25748d2619d5b3c608f432cee9ffd" translate="yes" xml:space="preserve">
          <source>When we look at &lt;em&gt;src/main.rs&lt;/em&gt; again, we&amp;rsquo;ll see that &lt;code&gt;cargo fix&lt;/code&gt; has changed the code:</source>
          <target state="translated">再次查看&lt;em&gt;src / main.rs&lt;/em&gt;时，我们将看到 &lt;code&gt;cargo fix&lt;/code&gt; 已更改代码：</target>
        </trans-unit>
        <trans-unit id="7a54ab2951cd6fff0884c0511bb61b6ab512dff0" translate="yes" xml:space="preserve">
          <source>When we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module helps you start writing your tests so you don&amp;rsquo;t have to look up the exact structure and syntax of test functions every time you start a new project. You can add as many additional test functions and as many test modules as you want!</source>
          <target state="translated">当我们使用Cargo制作一个新的图书馆项目时，会自动为我们生成一个带有测试功能的测试模块。该模块可帮助您开始编写测试，因此您不必在每次启动新项目时都查找测试函数的确切结构和语法。您可以根据需要添加任意数量的其他测试功能和测试模块！</target>
        </trans-unit>
        <trans-unit id="c17714721f7f441933c167091091578db54d0995" translate="yes" xml:space="preserve">
          <source>When we pass concrete references to &lt;code&gt;longest&lt;/code&gt;, the concrete lifetime that is substituted for &lt;code&gt;'a&lt;/code&gt; is the part of the scope of &lt;code&gt;x&lt;/code&gt; that overlaps with the scope of &lt;code&gt;y&lt;/code&gt;. In other words, the generic lifetime &lt;code&gt;'a&lt;/code&gt; will get the concrete lifetime that is equal to the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Because we&amp;rsquo;ve annotated the returned reference with the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;, the returned reference will also be valid for the length of the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">当我们传递 &lt;code&gt;longest&lt;/code&gt; 具体引用时，代替 &lt;code&gt;'a&lt;/code&gt; 的具体寿命是 &lt;code&gt;x&lt;/code&gt; 范围的一部分，与 &lt;code&gt;y&lt;/code&gt; 范围重叠。换句话说，一般寿命 &lt;code&gt;'a&lt;/code&gt; 将获得等于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 中较小者的具体寿命。因为我们已经使用相同的生命周期参数 &lt;code&gt;'a&lt;/code&gt; 注释了返回的引用，所以返回的引用对于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 生命周期中较小者的长度也将有效。</target>
        </trans-unit>
        <trans-unit id="a267d1c9dce3d09c3ccaaec536f47b38cd5559e0" translate="yes" xml:space="preserve">
          <source>When we print &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we can see that they all have the modified value of 15 rather than 5:</source>
          <target state="translated">当我们打印 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 时，我们可以看到它们的修改值为15而不是5：</target>
        </trans-unit>
        <trans-unit id="e6d697346a86084beb1a95157687a62dfdd661aa" translate="yes" xml:space="preserve">
          <source>When we print the parent of &lt;code&gt;leaf&lt;/code&gt; again, this time we&amp;rsquo;ll get a &lt;code&gt;Some&lt;/code&gt; variant holding &lt;code&gt;branch&lt;/code&gt;: now &lt;code&gt;leaf&lt;/code&gt; can access its parent! When we print &lt;code&gt;leaf&lt;/code&gt;, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; references are printed as &lt;code&gt;(Weak)&lt;/code&gt;:</source>
          <target state="translated">当我们再次打印 &lt;code&gt;leaf&lt;/code&gt; 的父级时，这一次，我们将获得 &lt;code&gt;Some&lt;/code&gt; 变异保持 &lt;code&gt;branch&lt;/code&gt; ：现在 &lt;code&gt;leaf&lt;/code&gt; 可以访问其父级了！当我们打印 &lt;code&gt;leaf&lt;/code&gt; 时，我们还避免了像清单15-26那样最终导致堆栈溢出的循环。所述 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 引用被打印为 &lt;code&gt;(Weak)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d6ae0ddb23c20f16f914c98f6cadf070ae827274" translate="yes" xml:space="preserve">
          <source>When we run &lt;code&gt;cargo doc --open&lt;/code&gt;, these comments will display on the front page of the documentation for &lt;code&gt;my_crate&lt;/code&gt; above the list of public items in the crate, as shown in Figure 14-2:</source>
          <target state="translated">当我们运行 &lt;code&gt;cargo doc --open&lt;/code&gt; 时，这些注释将显示在 &lt;code&gt;my_crate&lt;/code&gt; 的文档的首页上，位于板条箱中公共项目列表的上方，如图14-2所示：</target>
        </trans-unit>
        <trans-unit id="e0a9b14cc5672cde13757ff7b922b97b778df10c" translate="yes" xml:space="preserve">
          <source>When we run the code in Listing 16-8, we&amp;rsquo;ll see the value printed from the main thread:</source>
          <target state="translated">运行清单16-8中的代码时，我们将看到从主线程打印的值：</target>
        </trans-unit>
        <trans-unit id="b9d752c4fc202642188fd8ee33a406138a554856" translate="yes" xml:space="preserve">
          <source>When we run the program now, we get this:</source>
          <target state="translated">当我们现在运行程序时,我们得到的是这样的结果。</target>
        </trans-unit>
        <trans-unit id="8c0106d7279651b49f13e37d40b4d1b5d7049633" translate="yes" xml:space="preserve">
          <source>When we run the test in Listing 11-8, it will fail:</source>
          <target state="translated">当我们运行清单11-8中的测试时,会失败。</target>
        </trans-unit>
        <trans-unit id="44d32483b028a29165bad05ab4f3b2f5da955011" translate="yes" xml:space="preserve">
          <source>When we run the tests again, we&amp;rsquo;ll see a new section in the test output for the &lt;em&gt;common.rs&lt;/em&gt; file, even though this file doesn&amp;rsquo;t contain any test functions nor did we call the &lt;code&gt;setup&lt;/code&gt; function from anywhere:</source>
          <target state="translated">当我们再次运行测试时，我们将在&lt;em&gt;common.rs&lt;/em&gt;文件的测试输出中看到一个新部分，即使该文件不包含任何测试函数，也没有在任何地方调用 &lt;code&gt;setup&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="cb3ddc159979bee1d75a46f9ea2d0183358cc97b" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--nocapture&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">当使用 &lt;code&gt;--nocapture&lt;/code&gt; 标志再次运行清单11-10中的测试时，我们看到以下输出：</target>
        </trans-unit>
        <trans-unit id="35bd5db3d4e7561ab5f23e824a5b461601f0023a" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--show-output&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">当我们再次使用 &lt;code&gt;--show-output&lt;/code&gt; 标志运行清单11-10中的测试时，我们看到以下输出：</target>
        </trans-unit>
        <trans-unit id="538d8419c932e242d1adf6db2334731a0ed2c1d0" translate="yes" xml:space="preserve">
          <source>When we run these tests with &lt;code&gt;cargo test&lt;/code&gt;, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">将这些测试与 &lt;code&gt;cargo test&lt;/code&gt; 一起运行时，将看到以下输出：</target>
        </trans-unit>
        <trans-unit id="44da441e6c2b41d33ecf09cf035dd429fd808ba5" translate="yes" xml:space="preserve">
          <source>When we run this code with the &lt;code&gt;main&lt;/code&gt; function in Listing 5-14, we&amp;rsquo;ll get our desired output. Methods can take multiple parameters that we add to the signature after the &lt;code&gt;self&lt;/code&gt; parameter, and those parameters work just like parameters in functions.</source>
          <target state="translated">当使用清单5-14中的 &lt;code&gt;main&lt;/code&gt; 函数运行此代码时，将获得所需的输出。方法可以采用多个参数，这些参数要在 &lt;code&gt;self&lt;/code&gt; 参数之后添加到签名中，并且这些参数的作用就像函数中的参数一样。</target>
        </trans-unit>
        <trans-unit id="53901aa87c2188aaba7aa42fd2554bc7576ce3ee" translate="yes" xml:space="preserve">
          <source>When we run this code, keeping the last &lt;code&gt;println!&lt;/code&gt; commented out for the moment, we&amp;rsquo;ll get this output:</source>
          <target state="translated">当我们运行此代码时，保留最后一个 &lt;code&gt;println!&lt;/code&gt; 暂时将其注释掉，我们将获得以下输出：</target>
        </trans-unit>
        <trans-unit id="5a3726ae54b6ccfb63fe87a5f6a303a012e956de" translate="yes" xml:space="preserve">
          <source>When we run this code, the first &lt;code&gt;[]&lt;/code&gt; method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there&amp;rsquo;s an attempt to access an element past the end of the vector.</source>
          <target state="translated">当我们运行这段代码时，第一个 &lt;code&gt;[]&lt;/code&gt; 方法将导致程序出现恐慌，因为它引用了一个不存在的元素。如果试图访问向量结尾之后的元素，则当您希望程序崩溃时，最好使用此方法。</target>
        </trans-unit>
        <trans-unit id="d8d2da45983d7df0624bea6b1c973bb74ce76aac" translate="yes" xml:space="preserve">
          <source>When we run this code, we get an error with this core message:</source>
          <target state="translated">当我们运行这段代码时,我们得到了一个错误的核心信息。</target>
        </trans-unit>
        <trans-unit id="da6003750d05384524bf31be1adada0eff839f64" translate="yes" xml:space="preserve">
          <source>When we run this code, we&amp;rsquo;ll see the same output as in Listing 3-4. More importantly, we&amp;rsquo;ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</source>
          <target state="translated">运行此代码时，我们将看到与清单3-4相同的输出。更重要的是，我们现在已经提高了代码的安全性，并消除了由于超出数组末尾或距离不够远而丢失某些项目而导致错误的可能性。</target>
        </trans-unit>
        <trans-unit id="0377ef8d6715ac2dafa89aafe2017357ba5bea77" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see &lt;code&gt;again!&lt;/code&gt; printed over and over continuously until we stop the program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is stuck in a continual loop. Give it a try:</source>
          <target state="translated">当我们运行该程序时，我们会 &lt;code&gt;again!&lt;/code&gt; 看到！反复打印，直到我们手动停止程序为止。大多数终端都支持键盘快捷键ctrl-c来中断陷入连续循环的程序。试试看：</target>
        </trans-unit>
        <trans-unit id="17d349051e8f46b1c202c3a4fbf98139c89d6d7a" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">运行该程序时，将看到以下输出：</target>
        </trans-unit>
        <trans-unit id="2f39695d914a0c9b88c38a4702c072cc550001b0" translate="yes" xml:space="preserve">
          <source>When we try to check this code, we get this error:</source>
          <target state="translated">当我们试图检查这段代码时,我们得到了这个错误。</target>
        </trans-unit>
        <trans-unit id="b3d78770e0df06fb7d4eaea2e697443df3c1aa40" translate="yes" xml:space="preserve">
          <source>When we try to compile the code in Listing 19-5, we&amp;rsquo;ll get an error.</source>
          <target state="translated">当我们尝试编译清单19-5中的代码时，会出现错误。</target>
        </trans-unit>
        <trans-unit id="48d690d7f7c7a29675b105185a25b0eb605ff7f0" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get an error. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; arms have value types that are incompatible, and Rust indicates exactly where to find the problem in the program:</source>
          <target state="translated">当我们尝试编译此代码时，我们将得到一个错误。的 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 武器有不兼容的值类型，以及锈准确地指出来查找程序中的问题：</target>
        </trans-unit>
        <trans-unit id="20d9e738eb0bfb3c94a0df139314a2d502044dfc" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">当我们尝试编译此代码时，我们将收到此错误：</target>
        </trans-unit>
        <trans-unit id="382fab0dfc540b6d59e6b19a27e6a865624379ec" translate="yes" xml:space="preserve">
          <source>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic &lt;code&gt;largest&lt;/code&gt; function, place type name declarations inside angle brackets, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, between the name of the function and the parameter list, like this:</source>
          <target state="translated">当在函数主体中使用参数时，必须在签名中声明参数名称，以便编译器知道该名称的含义。同样，当在函数签名中使用类型参数名称时，必须在使用它之前声明类型参数名称。要定义通用的 &lt;code&gt;largest&lt;/code&gt; 函数，请将类型名称声明放在函数名称和参数列表之间的尖括号 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 中，如下所示：</target>
        </trans-unit>
        <trans-unit id="8036c669dac454067b908559831bbcc6af369344" translate="yes" xml:space="preserve">
          <source>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; when declaring the generic type.</source>
          <target state="translated">使用通用类型参数时，可以为通用类型指定默认的具体类型。如果默认类型有效，则无需特征的实现者指定具体类型。声明通用类型时，用于为通用类型指定默认类型的语法为 &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2fd3063d82737c85a4bd4560675bf8f567d4cb1" translate="yes" xml:space="preserve">
          <source>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn&amp;rsquo;t know all the types that might be used with the code that is using trait objects, so it doesn&amp;rsquo;t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn&amp;rsquo;t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method&amp;rsquo;s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&amp;rsquo;s a trade-off to consider.</source>
          <target state="translated">当我们使用特征对象时，Rust必须使用动态分配。编译器不知道使用trait对象的代码可能使用的所有类型，因此它不知道要在哪种类型上实现哪种方法来调用。相反，在运行时，Rust使用trait对象中的指针来知道要调用的方法。当这种查找发生时，这是静态分配所不会发生的运行时成本。动态分派还阻止编译器选择内联方法的代码，从而阻止进行某些优化。但是，我们确实在清单17-5中编写的代码中获得了额外的灵活性，并且能够在清单17-9中提供支持，因此需要权衡取舍。</target>
        </trans-unit>
        <trans-unit id="5fae46f3aefc24b09d40cb2c031a63a93c19cc1f" translate="yes" xml:space="preserve">
          <source>When we wrote the library, we didn&amp;rsquo;t know that someone might add the &lt;code&gt;SelectBox&lt;/code&gt; type, but our &lt;code&gt;Screen&lt;/code&gt; implementation was able to operate on the new type and draw it because &lt;code&gt;SelectBox&lt;/code&gt; implements the &lt;code&gt;Draw&lt;/code&gt; trait, which means it implements the &lt;code&gt;draw&lt;/code&gt; method.</source>
          <target state="translated">在编写库时，我们并不知道有人可以添加 &lt;code&gt;SelectBox&lt;/code&gt; 类型，但是我们的 &lt;code&gt;Screen&lt;/code&gt; 实现能够对新类型进行操作并绘制它，因为 &lt;code&gt;SelectBox&lt;/code&gt; 实现了 &lt;code&gt;Draw&lt;/code&gt; trait，这意味着它实现了 &lt;code&gt;draw&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1835312d71cbb49146dabf1e8972dadabbddcca1" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re defining this function, we don&amp;rsquo;t know the concrete values that will be passed into this function, so we don&amp;rsquo;t know whether the &lt;code&gt;if&lt;/code&gt; case or the &lt;code&gt;else&lt;/code&gt; case will execute. We also don&amp;rsquo;t know the concrete lifetimes of the references that will be passed in, so we can&amp;rsquo;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. The borrow checker can&amp;rsquo;t determine this either, because it doesn&amp;rsquo;t know how the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; relate to the lifetime of the return value. To fix this error, we&amp;rsquo;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</source>
          <target state="translated">定义此函数时，我们不知道将传递给该函数的具体值，因此我们不知道是否执行 &lt;code&gt;if&lt;/code&gt; 情况或 &lt;code&gt;else&lt;/code&gt; 情况。我们还不知道将传递的引用的具体生命周期，因此我们无法像清单10-18和清单10-19那样查看范围，以确定返回的引用是否始终有效。借用检查器也无法确定这一点，因为它不知道 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的生存期与返回值的生存期有何关系。要解决此错误，我们将添加通用的生存期参数，这些参数定义了引用之间的关系，以便借阅检查器可以执行其分析。</target>
        </trans-unit>
        <trans-unit id="2b0ee241a22dde4f8299858560fbc384d292c571" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">当使用固定结构时，会出现一个问题，即如何只使用&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 的方法就可以访问该结构的字段。通常的方法是编写将&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 转换为对该字段的引用的辅助方法（所谓的&lt;em&gt;projections&lt;/em&gt;），但是该引用应具有哪种类型？是&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 还是 &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ？对于 &lt;code&gt;enum&lt;/code&gt; 的字段，以及在考虑容器/包装类型（例如&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;时，也会出现相同的问题。（此问题适用于可变引用和共享引用，我们仅在此处使用可变引用的更常见情况进行说明。）</target>
        </trans-unit>
        <trans-unit id="54afd1d4de630fedf720b910edfe13f2d8fe3dc8" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">当使用固定结构时，会出现一个问题，即如何以仅使用 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 的方法访问该结构的字段。通常的方法是编写将 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 转换为对该字段的引用的辅助方法（所谓的&lt;em&gt;projections&lt;/em&gt;），但是该引用应具有哪种类型？是 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 还是 &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ？对于 &lt;code&gt;enum&lt;/code&gt; 的字段，以及在考虑容器/包装类型（例如&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;时，也会出现相同的问题。（此问题适用于可变引用和共享引用，我们仅在此处使用可变引用的更常见情况进行说明。）</target>
        </trans-unit>
        <trans-unit id="0c51f9b3e20caf1c1713245e1eb2bd51a6ddf835" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.</source>
          <target state="translated">当写入文件结束后,文件适当扩展,中间字节初始化值为0。</target>
        </trans-unit>
        <trans-unit id="debf85ed8f2982fd1ef982135cd5a37e3b932f44" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.</source>
          <target state="translated">当写入文件结束后,文件适当扩展,中间字节不初始化。</target>
        </trans-unit>
        <trans-unit id="4354c2cf3db4bc019d136bbb52f5ec5d3d5bdd0b" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">在编写调用许多返回&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;类型的函数的代码时，错误处理可能很乏味。问号运算符，&lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;，在调用堆栈中隐藏了一些传播错误的样板。</target>
        </trans-unit>
        <trans-unit id="fd3f2291c33fd3018ecb6b461f1a771659ef7d7e" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../ops/trait.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">在编写调用许多返回&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;类型的函数的代码时，错误处理可能很乏味。问号运算符，&lt;a href=&quot;../ops/trait.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;，在调用堆栈中隐藏了一些传播错误的样板。</target>
        </trans-unit>
        <trans-unit id="66253992d5df0f86fdc814938e97de3a70b258a2" translate="yes" xml:space="preserve">
          <source>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named &lt;code&gt;mod test&lt;/code&gt;. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</source>
          <target state="translated">在为模块编写单元测试时，将要测试的模块的直接子代命名为 &lt;code&gt;mod test&lt;/code&gt; 是常见的习惯用法。通过第二种情况，该模块可以访问父模块的任何项，这意味着内部实现细节也可以从子模块中进行无缝测试。</target>
        </trans-unit>
        <trans-unit id="6849dad47894c159da1bb308e92d26a3e924214c" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. As it turns out, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">在编写自己的特征时， &lt;code&gt;!&lt;/code&gt; 只要有明显的 &lt;code&gt;impl&lt;/code&gt; 而不必 &lt;code&gt;panic!&lt;/code&gt; ，就应该有一个 &lt;code&gt;impl&lt;/code&gt; ！。事实证明，多数性状可以有一个 &lt;code&gt;impl&lt;/code&gt; 的 &lt;code&gt;!&lt;/code&gt; 。以&lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;为例：</target>
        </trans-unit>
        <trans-unit id="b06c46c776108f6df59bce40c78afdd8aa807784" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. The reason is that functions returning an &lt;code&gt;impl Trait&lt;/code&gt; where &lt;code&gt;!&lt;/code&gt; does not have an &lt;code&gt;impl&lt;/code&gt; of &lt;code&gt;Trait&lt;/code&gt; cannot diverge as their only possible code path. In other words, they can't return &lt;code&gt;!&lt;/code&gt; from every code path. As an example, this code doesn't compile:</source>
          <target state="translated">在编写自己的特征时， &lt;code&gt;!&lt;/code&gt; 只要有明显的 &lt;code&gt;impl&lt;/code&gt; 而不必 &lt;code&gt;panic!&lt;/code&gt; ，就应该有一个 &lt;code&gt;impl&lt;/code&gt; ！。原因是函数返回了 &lt;code&gt;impl Trait&lt;/code&gt; ，其中 &lt;code&gt;!&lt;/code&gt; 没有一个 &lt;code&gt;impl&lt;/code&gt; 的 &lt;code&gt;Trait&lt;/code&gt; 不能发散作为其唯一可能的代码路径。换句话说，他们无法返回 &lt;code&gt;!&lt;/code&gt; 从每个代码路径。例如，此代码不会编译：</target>
        </trans-unit>
        <trans-unit id="376eed46fc5732c188b64191ceb100503469e764" translate="yes" xml:space="preserve">
          <source>When you &lt;em&gt;do&lt;/em&gt; want to update a crate, Cargo provides another command, &lt;code&gt;update&lt;/code&gt;, which will ignore the &lt;em&gt;Cargo.lock&lt;/em&gt; file and figure out all the latest versions that fit your specifications in &lt;em&gt;Cargo.toml&lt;/em&gt;. If that works, Cargo will write those versions to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">当您&lt;em&gt;确实&lt;/em&gt;要更新包装箱时，Cargo提供了另一个命令 &lt;code&gt;update&lt;/code&gt; ，它将忽略&lt;em&gt;Cargo.lock&lt;/em&gt;文件，并找出符合&lt;em&gt;Cargo.toml&lt;/em&gt;规范的所有最新版本。如果&lt;em&gt;可行&lt;/em&gt;，Cargo会将这些版本写入&lt;em&gt;Cargo.lock&lt;/em&gt;文件。</target>
        </trans-unit>
        <trans-unit id="1ba68f5d231df3408014c574fc5fb4dc7c5f7587" translate="yes" xml:space="preserve">
          <source>When you call a method with the &lt;code&gt;.foo()&lt;/code&gt; syntax, it&amp;rsquo;s often wise to introduce a newline and other whitespace to help break up long lines. We could have written this code as:</source>
          <target state="translated">当使用 &lt;code&gt;.foo()&lt;/code&gt; 语法调用方法时，通常明智的做法是引入换行符和其他空格以帮助分隔长行。我们可以将这段代码编写为：</target>
        </trans-unit>
        <trans-unit id="05246324bae5d78696c081ca3bb969c9b5f76aa9" translate="yes" xml:space="preserve">
          <source>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement &lt;code&gt;FnOnce&lt;/code&gt; because they can all be called at least once. Closures that don&amp;rsquo;t move the captured variables also implement &lt;code&gt;FnMut&lt;/code&gt;, and closures that don&amp;rsquo;t need mutable access to the captured variables also implement &lt;code&gt;Fn&lt;/code&gt;. In Listing 13-12, the &lt;code&gt;equal_to_x&lt;/code&gt; closure borrows &lt;code&gt;x&lt;/code&gt; immutably (so &lt;code&gt;equal_to_x&lt;/code&gt; has the &lt;code&gt;Fn&lt;/code&gt; trait) because the body of the closure only needs to read the value in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">创建闭包时，Rust根据闭包如何使用环境中的值来推断要使用的特征。所有的闭包都实现 &lt;code&gt;FnOnce&lt;/code&gt; ,因为它们至少可以被调用一次。不移动捕获变量的闭包也实现 &lt;code&gt;FnMut&lt;/code&gt; ，不需要对捕获变量进行可变访问的闭包也实现 &lt;code&gt;Fn&lt;/code&gt; 。在清单13-12中， &lt;code&gt;equal_to_x&lt;/code&gt; 闭包不可变地借用 &lt;code&gt;x&lt;/code&gt; （因此 &lt;code&gt;equal_to_x&lt;/code&gt; 具有 &lt;code&gt;Fn&lt;/code&gt; 特性），因为闭包的主体仅需要读取 &lt;code&gt;x&lt;/code&gt; 中的值。</target>
        </trans-unit>
        <trans-unit id="4b225d4c2d0c02a52b23cd1b31dafb9bb8378985" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data and you want to transfer ownership but ensure the data won&amp;rsquo;t be copied when you do so</source>
          <target state="translated">当您拥有大量数据并且想要转移所有权但要确保在执行此操作时不会复制数据</target>
        </trans-unit>
        <trans-unit id="1616d0bcec37e1d1974f0cec040ed2afa3965cea" translate="yes" xml:space="preserve">
          <source>When you have a type whose size can&amp;rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size</source>
          <target state="translated">如果您有一个在编译时无法得知其大小的类型，并且想要在需要精确大小的上下文中使用该类型的值</target>
        </trans-unit>
        <trans-unit id="faaa349bf2d53d10371fecd29ecbff47ff56b1b0" translate="yes" xml:space="preserve">
          <source>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</source>
          <target state="translated">当你在代码中发现有多个结构体或枚举定义的情况,而这些结构体或枚举定义仅在它们所持有的值的类型上有所不同时,你可以通过使用通用类型来避免重复。</target>
        </trans-unit>
        <trans-unit id="679e3b066cfac92df42c0662cfeca1f3e83d745f" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;cargo check&lt;/code&gt; again, you&amp;rsquo;ll get a few more warnings, but it should succeed.</source>
          <target state="translated">再次运行 &lt;code&gt;cargo check&lt;/code&gt; 时，还会收到一些警告，但应该会成功。</target>
        </trans-unit>
        <trans-unit id="6448bbefd235d50e1c725bdf06e891f730d7d66b" translate="yes" xml:space="preserve">
          <source>When you run it, you won&amp;rsquo;t get the path of the original executable, you&amp;rsquo;ll get the path of the hard link:</source>
          <target state="translated">运行它时，您将不会获得原始可执行文件的路径，而会获得硬链接的路径：</target>
        </trans-unit>
        <trans-unit id="30a9b27f023546ce78e3fa8bcc73ea93a891ddb0" translate="yes" xml:space="preserve">
          <source>When you run multiple tests, by default they run in parallel using threads. This means the tests will finish running faster so you can get feedback quicker on whether or not your code is working. Because the tests are running at the same time, make sure your tests don&amp;rsquo;t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</source>
          <target state="translated">当您运行多个测试时，默认情况下它们使用线程并行运行。这意味着测试将更快地完成运行，因此您可以更快地获得有关代码是否正常工作的反馈。由于测试是同时运行的，因此请确保您的测试不相互依赖，也不依赖任何共享状态，包括共享环境，例如当前的工作目录或环境变量。</target>
        </trans-unit>
        <trans-unit id="bdd64a76c4764e34bb256afe510d04a4140ab743" translate="yes" xml:space="preserve">
          <source>When you run the code, your output should look something like this:</source>
          <target state="translated">当你运行这段代码时,你的输出应该是这样的。</target>
        </trans-unit>
        <trans-unit id="56a080f28d7b938e415697722d1eaa5194296964" translate="yes" xml:space="preserve">
          <source>When you run the program, you&amp;rsquo;ll see something like this:</source>
          <target state="translated">当您运行该程序时，您将看到类似以下内容：</target>
        </trans-unit>
        <trans-unit id="9d0f951f7def4bb9ddc934064d83b22842550653" translate="yes" xml:space="preserve">
          <source>When you run this code, it will compile but will display a warning:</source>
          <target state="translated">当你运行这段代码时,它会编译,但会显示一个警告。</target>
        </trans-unit>
        <trans-unit id="cd11ee578beeab8bff18cf7df74988e81ef63b8d" translate="yes" xml:space="preserve">
          <source>When you run this program, the error you&amp;rsquo;ll get looks like this:</source>
          <target state="translated">当您运行该程序时，您将收到如下错误：</target>
        </trans-unit>
        <trans-unit id="88bf968fcfba3ccae7b190e45758bbe17d47d594" translate="yes" xml:space="preserve">
          <source>When you see a call to &lt;code&gt;clone&lt;/code&gt;, you know that some arbitrary code is being executed and that code may be expensive. It&amp;rsquo;s a visual indicator that something different is going on.</source>
          <target state="translated">当您看到对 &lt;code&gt;clone&lt;/code&gt; 的调用时，您知道正在执行一些任意代码，并且这些代码可能会很昂贵。这是一个视觉指示器，表明发生了一些不同的情况。</target>
        </trans-unit>
        <trans-unit id="dba00a225c49d7aad6a4c3e2fefc5b6ad717617e" translate="yes" xml:space="preserve">
          <source>When you understand ownership, you&amp;rsquo;ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you&amp;rsquo;ll learn ownership by working through some examples that focus on a very common data structure: strings.</source>
          <target state="translated">了解所有权后，您将拥有坚实的基础，可以理解使Rust独树一帜的功能。在本章中，您将通过研究一些关注非常常见的数据结构的示例（字符串）来学习所有权。</target>
        </trans-unit>
        <trans-unit id="fb9b6ed06b18947df730bd329065f971ebc43888" translate="yes" xml:space="preserve">
          <source>When you want a function to have multiple parameters, separate the parameter declarations with commas, like this:</source>
          <target state="translated">当你想让一个函数有多个参数时,可以用逗号分隔参数声明,就像这样。</target>
        </trans-unit>
        <trans-unit id="7140942a9e83dd3630a3c0916a44b851e25bd0ab" translate="yes" xml:space="preserve">
          <source>When you want to own a value and you care only that it&amp;rsquo;s a type that implements a particular trait rather than being of a specific type</source>
          <target state="translated">当您想拥有一个值并且只关心它是实现特定特征的类型而不是特定类型时</target>
        </trans-unit>
        <trans-unit id="51634274a504f9b0a7a634216e472b5bef4325d7" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error.</source>
          <target state="translated">当你在释放模式下编译 &lt;code&gt;--release&lt;/code&gt; 标志，锈也&lt;em&gt;未&lt;/em&gt;包括整数溢出是造成恐慌的检查。相反，如果发生溢出，Rust将执行&lt;em&gt;二进制补码&lt;/em&gt;。简而言之，大于该类型可以保持的最大值的值&amp;ldquo;环绕&amp;rdquo;到该类型可以保持的最小值的值。在 &lt;code&gt;u8&lt;/code&gt; 的情况下，256变为0，257变为1，依此类推。该程序不会出现紧急情况，但是该变量的值可能不是您期望的值。依赖整数溢出的包装行为被视为错误。</target>
        </trans-unit>
        <trans-unit id="a38101ccd42a1c4f79b06b155e4e46b8f79f9a7b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error. If you want to wrap explicitly, you can use the standard library type &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt;&lt;code&gt;Wrapping&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当你在释放模式下编译 &lt;code&gt;--release&lt;/code&gt; 标志，锈也&lt;em&gt;未&lt;/em&gt;包括整数溢出是造成恐慌的检查。相反，如果发生溢出，Rust将执行&lt;em&gt;二进制补码&lt;/em&gt;。简而言之，大于类型可以保持的最大值的值&amp;ldquo;环绕&amp;rdquo;到类型可以保持的最小值。在 &lt;code&gt;u8&lt;/code&gt; 的情况下，256变为0，257变为1，依此类推。该程序不会出现紧急情况，但是该变量的值可能不是您期望的值。依赖整数溢出的包装行为被视为错误。如果要显式包装，则可以使用标准库类型&lt;a href=&quot;../std/num/struct.wrapping&quot;&gt; &lt;code&gt;Wrapping&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf6294d1d4938dc2164807d070a9e5a24c528b0b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</source>
          <target state="translated">互斥锁保护的数据处理完毕后，必须解锁数据，以便其他线程可以获取锁定。</target>
        </trans-unit>
        <trans-unit id="87ed8d0c79155dbc381301582c028a0bc87a94b1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to move on, we&amp;rsquo;ll talk about a concept in Rust that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; commonly exist in other programming languages: ownership.</source>
          <target state="translated">当您准备好继续前进时，我们将讨论Rust 中其他编程语言&lt;em&gt;中不&lt;/em&gt;常见的概念：所有权。</target>
        </trans-unit>
        <trans-unit id="338c49418a81c4fe8cdbaa3398a7f70c772eed82" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a function whose implementation calls something that might fail, instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as &lt;em&gt;propagating&lt;/em&gt; the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</source>
          <target state="translated">当您编写一个函数的实现调用可能失败的函数时，可以将错误返回给调用代码，以便它可以决定要做什么，而不是处理该函数中的错误。这被称为&lt;em&gt;传播&lt;/em&gt;错误，并赋予调用代码更多的控制权，那里可能有更多的信息或逻辑来规定应如何处理错误，而不是代码上下文中可用的信息或逻辑。</target>
        </trans-unit>
        <trans-unit id="52116b6d188a2650ef7d8367c1d460637ef198b9" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a program, if you don&amp;rsquo;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&amp;rsquo;t work. Instead, you can use a trait object, which we&amp;rsquo;ll cover in Chapter 17.</source>
          <target state="translated">在编写程序时，如果您不知道程序将在运行时获取的完整类型集以存储在向量中，则枚举技术将不起作用。相反，您可以使用trait对象，我们将在第17章中介绍。</target>
        </trans-unit>
        <trans-unit id="a6c702a723f263e7d6b8ef006b195ad04de8148a" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear. In examples, it&amp;rsquo;s understood that a call to a method like &lt;code&gt;unwrap&lt;/code&gt; that could panic is meant as a placeholder for the way you&amp;rsquo;d want your application to handle errors, which can differ based on what the rest of your code is doing.</source>
          <target state="translated">当您编写示例以说明一些概念时，在示例中也使用健壮的错误处理代码可能会使示例不清楚。在示例中，可以理解的是，对可能引起恐慌的诸如 &lt;code&gt;unwrap&lt;/code&gt; 之类的方法的调用，是作为您希望应用程序处理错误的方式的占位符，该错误可能根据其余代码的执行情况而有所不同。</target>
        </trans-unit>
        <trans-unit id="c42c6bb649d897cae512ccb086d5d0b9efa0b2d4" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;ve made changes to your crate and are ready to release a new version, you change the &lt;code&gt;version&lt;/code&gt; value specified in your &lt;em&gt;Cargo.toml&lt;/em&gt; file and republish. Use the &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning rules&lt;/a&gt; to decide what an appropriate next version number is based on the kinds of changes you&amp;rsquo;ve made. Then run &lt;code&gt;cargo publish&lt;/code&gt; to upload the new version.</source>
          <target state="translated">更改完包装箱并准备发布新版本后，可以更改在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中指定的 &lt;code&gt;version&lt;/code&gt; 值，然后重新发布。使用&amp;ldquo; &lt;a href=&quot;http://semver.org/&quot;&gt;语义版本控制&amp;rdquo;规则&lt;/a&gt;，根据您所做的更改来决定合适的下一版本号。然后运行 &lt;code&gt;cargo publish&lt;/code&gt; 上传新版本。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a63fa0940baafe694284e32babae3f74d6ff198c" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">当您的 &lt;code&gt;Iterator&lt;/code&gt; 实现 &lt;code&gt;TrustedLen&lt;/code&gt; 且大小正确时，将为 &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; 进行一次分配。例如：</target>
        </trans-unit>
        <trans-unit id="10a2affd429f9e55f7202252260760e859abffb5" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">当您的 &lt;code&gt;Iterator&lt;/code&gt; 实现 &lt;code&gt;TrustedLen&lt;/code&gt; 且大小正确时，将为 &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; 进行一次分配。例如：</target>
        </trans-unit>
        <trans-unit id="839440b70c5a7ad1d7e470fedb75657493aedb6e" translate="yes" xml:space="preserve">
          <source>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function&amp;rsquo;s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</source>
          <target state="translated">当您的代码调用函数时，传递给函数的值（可能包括指向堆上数据的指针）和函数的局部变量将被压入堆栈。函数结束后，这些值将从堆栈中弹出。</target>
        </trans-unit>
        <trans-unit id="7fc4ed82b7b946f127718773ea3ac4f397f59537" translate="yes" xml:space="preserve">
          <source>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&amp;rsquo;t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call &lt;code&gt;panic!&lt;/code&gt; if you attempt an out-of-bounds memory access: trying to access memory that doesn&amp;rsquo;t belong to the current data structure is a common security problem. Functions often have &lt;em&gt;contracts&lt;/em&gt;: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&amp;rsquo;s not a kind of error you want the calling code to have to explicitly handle. In fact, there&amp;rsquo;s no reasonable way for calling code to recover; the calling &lt;em&gt;programmers&lt;/em&gt; need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</source>
          <target state="translated">当您的代码对值执行操作时，您的代码应首先验证值有效，如果值无效，则应恐慌。这主要是出于安全原因：尝试对无效数据进行操作会使您的代码容易受到攻击。这是标准库将 &lt;code&gt;panic!&lt;/code&gt; 主要原因！如果您尝试越界访问内存：尝试访问不属于当前数据结构的内存是一个常见的安全问题。功能通常有&lt;em&gt;合同&lt;/em&gt;：仅当输入满足特定要求时，才能保证其行为。违反合同时恐慌是有道理的，因为违反合同总是表示调用方错误，这不是您希望调用代码必须明确处理的错误。实际上，没有合理的方法来调用代码进行恢复。调用&lt;em&gt;程序员&lt;/em&gt;需要修复代码。有关功能的合同，特别是在违规会引起恐慌的情况下，应在该功能的API文档中进行说明。</target>
        </trans-unit>
        <trans-unit id="89c680949e7cd958d9cc4977874667c68a138ea6" translate="yes" xml:space="preserve">
          <source>When your project is finally ready for release, you can use &lt;code&gt;cargo build --release&lt;/code&gt; to compile it with optimizations. This command will create an executable in &lt;em&gt;target/release&lt;/em&gt; instead of &lt;em&gt;target/debug&lt;/em&gt;. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you&amp;rsquo;ll give to a user that won&amp;rsquo;t be rebuilt repeatedly and that will run as fast as possible. If you&amp;rsquo;re benchmarking your code&amp;rsquo;s running time, be sure to run &lt;code&gt;cargo build --release&lt;/code&gt; and benchmark with the executable in &lt;em&gt;target/release&lt;/em&gt;.</source>
          <target state="translated">当项目最终准备好发布时，您可以使用 &lt;code&gt;cargo build --release&lt;/code&gt; 进行优化编译。此命令将在&lt;em&gt;target / release中&lt;/em&gt;创建一个可执行文件，而不是&lt;em&gt;target / debug&lt;/em&gt;。这些优化使您的Rust代码运行得更快，但是打开它们会延长程序编译的时间。这就是为什么要使用两种不同的配置文件的原因：一种用于开发，当您想要快速且经常地进行重建时，另一种用于构建最终程序，您将提供给不会重复重建且运行速度与用户相同的用户可能。如果您要对代码的运行时间进行基准测试，请确保使用&lt;em&gt;目标/ release中&lt;/em&gt;的可执行文件运行 &lt;code&gt;cargo build --release&lt;/code&gt; 和基准测试。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3d1e3a329799ed0876a4d1ad716f19e4a9cec94" translate="yes" xml:space="preserve">
          <source>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the &lt;code&gt;let&lt;/code&gt;. This is illustrated in the example above by showing that &lt;code&gt;tmp&lt;/code&gt; would be freed as we exit the block.</source>
          <target state="translated">每当创建临时文件时，都会根据固定规则自动将其删除（释放）。通常，在包含语句的末尾（在这种情况下，在 &lt;code&gt;let&lt;/code&gt; 之后）删除临时项。在上面的示例中通过显示 &lt;code&gt;tmp&lt;/code&gt; 在退出该块时将被释放来说明了这一点。</target>
        </trans-unit>
        <trans-unit id="0d66101f5b82c22f64225217f832b8e7af03aba9" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">只要有可能，最好改用&lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; &lt;/a&gt;，这样可以避免复制 &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e3c7f91ce843a180fc6f430d195fed72f860109" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在任何可能的情况下，最好都使用&lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt;代替，这可以防止重复 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eed4432a187ec3056ddd9bd907b999948f00874c" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferrable to use &lt;a href=&quot;#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在任何可能的情况下，最好都使用而非&lt;a href=&quot;#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt;方式，它可以防止重复 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4de23a7f6719a7ba57b078ca4ff7e8250001b36" translate="yes" xml:space="preserve">
          <source>Where clauses</source>
          <target state="translated">凡条款</target>
        </trans-unit>
        <trans-unit id="9b0b082cc3c369bcfe0d32cc803440f9644c559a" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s the &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operator?</source>
          <target state="translated">&lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; 运算符在哪里？</target>
        </trans-unit>
        <trans-unit id="d4ea105a6df2620f7975d097e826dec6963287a4" translate="yes" xml:space="preserve">
          <source>Whether or not to evaluate the sub-expressions when evaluating the expression</source>
          <target state="translated">在评价表达式时,是否对子表达式进行评价?</target>
        </trans-unit>
        <trans-unit id="7441400ac9aa4ede2210143836e6a213067deff4" translate="yes" xml:space="preserve">
          <source>Whew! Now you have some Rust features in your toolbox that you won&amp;rsquo;t use often, but you&amp;rsquo;ll know they&amp;rsquo;re available in very particular circumstances. We&amp;rsquo;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&amp;rsquo; code, you&amp;rsquo;ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</source>
          <target state="translated">ew！现在，您的工具箱中有一些不经常使用的Rust功能，但是您会知道它们在非常特殊的情况下可用。我们介绍了几个复杂的主题，因此当您在错误消息建议或其他人的代码中遇到这些主题时，您将能够识别这些概念和语法。使用本章作为参考，以指导您找到解决方案。</target>
        </trans-unit>
        <trans-unit id="ecbdd73494930b04d58d59a497ec54128fcf95a8" translate="yes" xml:space="preserve">
          <source>Whew! That was a lot of work, but we&amp;rsquo;ve set ourselves up for success in the future. Now it&amp;rsquo;s much easier to handle errors, and we&amp;rsquo;ve made the code more modular. Almost all of our work will be done in &lt;em&gt;src/lib.rs&lt;/em&gt; from here on out.</source>
          <target state="translated">ew！那是很多工作，但是我们为将来的成功做好了准备。现在，更容易处理错误，并且我们使代码更加模块化。从现在开始，几乎所有工作都将在&lt;em&gt;src / lib.rs中&lt;/em&gt;完成。</target>
        </trans-unit>
        <trans-unit id="357b219e220334335cb6c179ad0fbd5be62e5879" translate="yes" xml:space="preserve">
          <source>Whew! We &lt;em&gt;also&lt;/em&gt; cannot have a mutable reference while we have an immutable one. Users of an immutable reference don&amp;rsquo;t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&amp;rsquo;s reading of the data.</source>
          <target state="translated">ew！当我们拥有不变的参考时，我们&lt;em&gt;也&lt;/em&gt;不能拥有可变的参考。不变引用的用户不要期望值会突然从它们下面改变！但是，可以使用多个不可变的引用，因为没有人会影响其他任何人对数据的读取。</target>
        </trans-unit>
        <trans-unit id="c4abab176ad04758c7995b5bf1a8ebbc48d27dab" translate="yes" xml:space="preserve">
          <source>Which configuration options are set is determined statically during the compilation of the crate. Certain options are &lt;em&gt;compiler-set&lt;/em&gt; based on data about the compilation. Other options are &lt;em&gt;arbitrarily-set&lt;/em&gt;, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.</source>
          <target state="translated">设置哪些配置选项是在板条箱的编译过程中静态确定的。某些选项是基于有关编译数据的编译&lt;em&gt;器设置&lt;/em&gt;的。其他选项是&lt;em&gt;任意设置&lt;/em&gt;，基于代码外传递给编译器的输入进行设置。无法从正在编译的板条箱的源代码中设置配置选项。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
