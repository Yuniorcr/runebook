<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d4945a59276bcf1f4830f2a8c1b3defd3c68cde5" translate="yes" xml:space="preserve">
          <source>Namespace path</source>
          <target state="translated">命名空间路径</target>
        </trans-unit>
        <trans-unit id="59cb29ad5b08231ec027d2b58b07b4db4094a48e" translate="yes" xml:space="preserve">
          <source>Naming hardcoded values used throughout your program as constants is useful in conveying the meaning of that value to future maintainers of the code. It also helps to have only one place in your code you would need to change if the hardcoded value needed to be updated in the future.</source>
          <target state="translated">将整个程序中使用的硬编码值命名为常量,对于向未来的代码维护者传达该值的含义很有用。这也有助于在将来需要更新硬编码值时,在代码中只有一个地方需要更改。</target>
        </trans-unit>
        <trans-unit id="4ea0a808e9b003709a882c3eda3364c5952aaed6" translate="yes" xml:space="preserve">
          <source>Naming threads</source>
          <target state="translated">命名线程</target>
        </trans-unit>
        <trans-unit id="2773f0d2f9f4e7e59e9c30b201b04dd1a5c30189" translate="yes" xml:space="preserve">
          <source>Native threads.</source>
          <target state="translated">原生线。</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="ad9041802b2ad5cd647573800f68f895c77cc8fe" translate="yes" xml:space="preserve">
          <source>Neg</source>
          <target state="translated">Neg</target>
        </trans-unit>
        <trans-unit id="64377c7ff3fff06094951f56bcf30132ee73161a" translate="yes" xml:space="preserve">
          <source>Neg::neg</source>
          <target state="translated">Neg::neg</target>
        </trans-unit>
        <trans-unit id="2133424c311abcb51295591d17f0ab0ae52b1f1a" translate="yes" xml:space="preserve">
          <source>Negates self in an overflowing fashion.</source>
          <target state="translated">以溢出的方式否定自我。</target>
        </trans-unit>
        <trans-unit id="163f10b84a51abc2d56ad3b9131ea073b011f340" translate="yes" xml:space="preserve">
          <source>Negates self, overflowing if this is equal to the minimum value.</source>
          <target state="translated">自身负值,如果这个等于最小值,则溢出。</target>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="f43c19cc20dec09f56a336941f1748c0f4c49844" translate="yes" xml:space="preserve">
          <source>Negation operators</source>
          <target state="translated">否定运算符</target>
        </trans-unit>
        <trans-unit id="17843c0405b3d56c0f1f2a9c5762b3ce7f769007" translate="yes" xml:space="preserve">
          <source>Negation*</source>
          <target state="translated">Negation*</target>
        </trans-unit>
        <trans-unit id="b07705471769113a1673291a380e793691cb93d8" translate="yes" xml:space="preserve">
          <source>Negative implementations are a promise that the trait will never be implemented for the given types. Therefore, both cannot exists at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b31bd178b9fc5ff620f5314f9aa5aa57ccd4286" translate="yes" xml:space="preserve">
          <source>Negative impls are not allowed to have any items. Negative impls declare that a trait is &lt;strong&gt;not&lt;/strong&gt; implemented (and never will be) and hence there is no need to specify the values for trait methods or other items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e113717082f98a849bcb00740af62ca1b508554b" translate="yes" xml:space="preserve">
          <source>Negative impls are only allowed for auto traits. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">负值仅适用于自动特征。有关更多信息，请参阅&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in内置特征RFC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0615e40800cad75c4988298cdebe16d2bc992b36" translate="yes" xml:space="preserve">
          <source>Negative impls cannot be default impls. A default impl supplies default values for the items within to be used by other impls, whereas a negative impl declares that there are no other impls. Combining it does not make sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075388f0e224328f0ef13d31f89995f6f2c54896" translate="yes" xml:space="preserve">
          <source>Negative infinity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6b7b244457f2bc0330b32b4347438278828967" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31031ada08602da6a93f5f5a6962d2039849eda8" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NEG_INFINITY&quot;&gt;&lt;code&gt;f32::NEG_INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f342b4f8475b808f61b1967602254bedfcdc5688" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NEG_INFINITY&quot;&gt;&lt;code&gt;f64::NEG_INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0bc318765f26abdc2b2efb29b7106a82fb8fb4b" translate="yes" xml:space="preserve">
          <source>Negative infinity (-&amp;infin;).</source>
          <target state="translated">负无穷大（-&amp;infin;）。</target>
        </trans-unit>
        <trans-unit id="0b247e3c8355086599e15be9efdc87a68cb4c92b" translate="yes" xml:space="preserve">
          <source>Negative numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72021c01935802b94d4bcd9c9615be5e2c464ac9" translate="yes" xml:space="preserve">
          <source>Negative quiet NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb8a4159eba393bec0f206dd4b2eb1942475e21" translate="yes" xml:space="preserve">
          <source>Negative signaling NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee7bf9e7ed5622172a82905b10c817e30e7444" translate="yes" xml:space="preserve">
          <source>Negative subnormal numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbee361595328b1b81f0564c184162939e173b0f" translate="yes" xml:space="preserve">
          <source>Negative zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf5959ac45ac960a39abb26044226e763422de4" translate="yes" xml:space="preserve">
          <source>Neither value is dropped.</source>
          <target state="translated">两种数值都不会被丢弃。</target>
        </trans-unit>
        <trans-unit id="4826200965c37ead358d19d4ff8ed0153fd42955" translate="yes" xml:space="preserve">
          <source>Neither will this, which is a syntax error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665ede9ba12690daf481e44869ce86ddcafb335a" translate="yes" xml:space="preserve">
          <source>Nesting groups of the previous features multiple times, such as &lt;code&gt;use a::b::{self as ab, c, d::{*, e::f}};&lt;/code&gt;</source>
          <target state="translated">多次嵌套先前功能的组，例如 &lt;code&gt;use a::b::{self as ab, c, d::{*, e::f}};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4245fc09474f28a0f0142b9ff14b33a73b77c8f" translate="yes" xml:space="preserve">
          <source>Networking primitives for TCP/UDP communication.</source>
          <target state="translated">TCP/UDP通信的网络基元。</target>
        </trans-unit>
        <trans-unit id="0512d9d610f7bd86dbd1ca707603a7ad85ac4816" translate="yes" xml:space="preserve">
          <source>Never type</source>
          <target state="translated">千万不要打</target>
        </trans-unit>
        <trans-unit id="34989675de773cc2985533af4611fcdec5ac0eea" translate="yes" xml:space="preserve">
          <source>New instances of a &lt;code&gt;struct&lt;/code&gt; can be constructed with a &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;../expressions/struct-expr&quot;&gt;结构表达式&lt;/a&gt;构造 &lt;code&gt;struct&lt;/code&gt; 新实例。</target>
        </trans-unit>
        <trans-unit id="474d969a41224d27a052b2157645ae6ea6fdc69d" translate="yes" xml:space="preserve">
          <source>New instances of an &lt;code&gt;enum&lt;/code&gt; can be constructed in an &lt;a href=&quot;../expressions/enum-variant-expr&quot;&gt;enumeration variant expression&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;../expressions/enum-variant-expr&quot;&gt;枚举变量表达式中&lt;/a&gt;构造 &lt;code&gt;enum&lt;/code&gt; 新实例。</target>
        </trans-unit>
        <trans-unit id="83c2612a110d45187eac1c39a648ac614b8c7d56" translate="yes" xml:space="preserve">
          <source>New versions of Unicode are released regularly and subsequently all methods in the standard library depending on Unicode are updated. Therefore the behavior of some &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods and the value of this constant changes over time. This is &lt;em&gt;not&lt;/em&gt; considered to be a breaking change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="d783d54db2abcb54d1f3f2d8b19273a6830adb8c" translate="yes" xml:space="preserve">
          <source>Newsqueak, Alef, Limbo: channels, concurrency</source>
          <target state="translated">Newsqueak、Alef、Limbo:渠道、并发性。</target>
        </trans-unit>
        <trans-unit id="9000cfe362fe35a00622dc16de8a42fe71435817" translate="yes" xml:space="preserve">
          <source>Newtypes can also hide internal implementation. For example, we could provide a &lt;code&gt;People&lt;/code&gt; type to wrap a &lt;code&gt;HashMap&amp;lt;i32, String&amp;gt;&lt;/code&gt; that stores a person&amp;rsquo;s ID associated with their name. Code using &lt;code&gt;People&lt;/code&gt; would only interact with the public API we provide, such as a method to add a name string to the &lt;code&gt;People&lt;/code&gt; collection; that code wouldn&amp;rsquo;t need to know that we assign an &lt;code&gt;i32&lt;/code&gt; ID to names internally. The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the &lt;a href=&quot;ch17-01-what-is-oo#encapsulation-that-hides-implementation-details&quot;&gt;&amp;ldquo;Encapsulation that Hides Implementation Details&amp;rdquo;&lt;/a&gt; section of Chapter 17.</source>
          <target state="translated">新类型还可以隐藏内部实现。例如，我们可以提供一个 &lt;code&gt;People&lt;/code&gt; 类型来包装 &lt;code&gt;HashMap&amp;lt;i32, String&amp;gt;&lt;/code&gt; ，该HashMap &amp;lt;i32，String&amp;gt;存储与姓名相关联的人员ID。使用 &lt;code&gt;People&lt;/code&gt; 的代码只能与我们提供的公共API交互，例如向 &lt;code&gt;People&lt;/code&gt; 集合添加名称字符串的方法；该代码不需要知道我们在内部为名称分配了 &lt;code&gt;i32&lt;/code&gt; ID。新型模式是一种实现封装以隐藏实现细节的轻量级方法，我们在第17章的&lt;a href=&quot;ch17-01-what-is-oo#encapsulation-that-hides-implementation-details&quot;&gt;&amp;ldquo;隐藏实现细节的封装&amp;rdquo;&lt;/a&gt;一节中进行了讨论。</target>
        </trans-unit>
        <trans-unit id="7bae91cced3da7b704f84e06989b7947e80e541e" translate="yes" xml:space="preserve">
          <source>Next are the &lt;code&gt;match&lt;/code&gt; arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value &lt;code&gt;Coin::Penny&lt;/code&gt; and then the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator that separates the pattern and the code to run. The code in this case is just the value &lt;code&gt;1&lt;/code&gt;. Each arm is separated from the next with a comma.</source>
          <target state="translated">接下来是 &lt;code&gt;match&lt;/code&gt; 武器。手臂有两个部分：一个模式和一些代码。这里的第一个分支的模式是值 &lt;code&gt;Coin::Penny&lt;/code&gt; ，然后是 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符，用于分隔模式和要运行的代码。在这种情况下，代码仅为值 &lt;code&gt;1&lt;/code&gt; 。每个手臂都用逗号隔开。</target>
        </trans-unit>
        <trans-unit id="bf7420cff34f7205e5c081be758df804f4a3397f" translate="yes" xml:space="preserve">
          <source>Next is the &lt;code&gt;main&lt;/code&gt; function, which contains the parts of the workout app important for this example. This function represents the code that the app will call when a user asks for a workout plan. Because the interaction with the app&amp;rsquo;s frontend isn&amp;rsquo;t relevant to the use of closures, we&amp;rsquo;ll hardcode values representing inputs to our program and print the outputs.</source>
          <target state="translated">接下来是 &lt;code&gt;main&lt;/code&gt; 功能，其中包含锻炼应用程序对本示例很重要的部分。此功能代表当用户要求锻炼计划时应用将调用的代码。由于与应用程序前端的交互与闭包的使用无关，因此我们将对表示程序输入的值进行硬编码并输出输出。</target>
        </trans-unit>
        <trans-unit id="c65bbe969462e1bc44ee3000579ab22fe481fd4c" translate="yes" xml:space="preserve">
          <source>Next, for the penultimate chapter of the book, we&amp;rsquo;ll look at some advanced aspects of a variety of Rust&amp;rsquo;s features.</source>
          <target state="translated">接下来，对于本书的倒数第二章，我们将研究Rust的各种功能的一些高级方面。</target>
        </trans-unit>
        <trans-unit id="52208e82490358e0e353201224729d0b32e9211f" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;em&gt;add&lt;/em&gt; directory, we create the &lt;em&gt;Cargo.toml&lt;/em&gt; file that will configure the entire workspace. This file won&amp;rsquo;t have a &lt;code&gt;[package]&lt;/code&gt; section or the metadata we&amp;rsquo;ve seen in other &lt;em&gt;Cargo.toml&lt;/em&gt; files. Instead, it will start with a &lt;code&gt;[workspace]&lt;/code&gt; section that will allow us to add members to the workspace by specifying the path to our binary crate; in this case, that path is &lt;em&gt;adder&lt;/em&gt;:</source>
          <target state="translated">接下来，在&lt;em&gt;添加&lt;/em&gt;目录中，我们将创建&lt;em&gt;Cargo.toml&lt;/em&gt;文件，该文件将配置整个工作区。该文件没有 &lt;code&gt;[package]&lt;/code&gt; 部分，也没有我们在其他&lt;em&gt;Cargo.toml&lt;/em&gt;文件中看到的元数据。相反，它将以 &lt;code&gt;[workspace]&lt;/code&gt; 部分开始，该部分允许我们通过指定二进制板条箱的路径将成员添加到工作空间中；在这种情况下，该路径是&lt;em&gt;adder&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="cf3583fbb6ba42fdef61381eb0f22f26cc65cb4c" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;em&gt;add&lt;/em&gt; directory, we create the &lt;em&gt;Cargo.toml&lt;/em&gt; file that will configure the entire workspace. This file won&amp;rsquo;t have a &lt;code&gt;[package]&lt;/code&gt; section or the metadata we&amp;rsquo;ve seen in other &lt;em&gt;Cargo.toml&lt;/em&gt; files. Instead, it will start with a &lt;code&gt;[workspace]&lt;/code&gt; section that will allow us to add members to the workspace by specifying the path to the package with our binary crate; in this case, that path is &lt;em&gt;adder&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5673d4c0782df5e2ab93b6ac7b7285949caf0a" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create another member crate in the workspace and call it &lt;code&gt;add-one&lt;/code&gt;. Change the top-level &lt;em&gt;Cargo.toml&lt;/em&gt; to specify the &lt;em&gt;add-one&lt;/em&gt; path in the &lt;code&gt;members&lt;/code&gt; list:</source>
          <target state="translated">接下来，让我们在工作区中创建另一个成员箱，并将其称为 &lt;code&gt;add-one&lt;/code&gt; 。更改顶级&lt;em&gt;Cargo.toml&lt;/em&gt;以在 &lt;code&gt;members&lt;/code&gt; 列表中指定&lt;em&gt;附加&lt;/em&gt;路径：</target>
        </trans-unit>
        <trans-unit id="9b3259a6676f65921f501e882bdad69e2021df7f" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create another member package in the workspace and call it &lt;code&gt;add-one&lt;/code&gt;. Change the top-level &lt;em&gt;Cargo.toml&lt;/em&gt; to specify the &lt;em&gt;add-one&lt;/em&gt; path in the &lt;code&gt;members&lt;/code&gt; list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba0c012105d9f7e5a4cb08c9812f147ef92fc3f" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s explore how the other kinds of procedural macros differ from custom derive macros.</source>
          <target state="translated">接下来，让我们探讨其他类型的过程宏与自定义派生宏的区别。</target>
        </trans-unit>
        <trans-unit id="7388ce6c4f87a59e05725876ec1ba13ab5a6c132" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s look at macros!</source>
          <target state="translated">接下来，让我们看一下宏！</target>
        </trans-unit>
        <trans-unit id="a41ab1aeb6ce0234b517ca6ca3124ad3db811d40" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s try an example that shows that the lifetime of the reference in &lt;code&gt;result&lt;/code&gt; must be the smaller lifetime of the two arguments. We&amp;rsquo;ll move the declaration of the &lt;code&gt;result&lt;/code&gt; variable outside the inner scope but leave the assignment of the value to the &lt;code&gt;result&lt;/code&gt; variable inside the scope with &lt;code&gt;string2&lt;/code&gt;. Then we&amp;rsquo;ll move the &lt;code&gt;println!&lt;/code&gt; that uses &lt;code&gt;result&lt;/code&gt; outside the inner scope, after the inner scope has ended. The code in Listing 10-24 will not compile.</source>
          <target state="translated">接下来，让我们尝试一个示例，该示例显示 &lt;code&gt;result&lt;/code&gt; 引用的生存期必须是两个参数中较小的生存期。我们将 &lt;code&gt;result&lt;/code&gt; 变量的声明移到内部作用域之外，但将值的赋值保留在范围内的 &lt;code&gt;result&lt;/code&gt; 变量内是 &lt;code&gt;string2&lt;/code&gt; 。然后，我们将移动 &lt;code&gt;println!&lt;/code&gt; 内部范围结束后，使用 &lt;code&gt;result&lt;/code&gt; 超出内部范围的结果。清单10-24中的代码将无法编译。</target>
        </trans-unit>
        <trans-unit id="4cd72ee75b765bce66036759ad44f05bffbba3a1" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s use the &lt;code&gt;add_one&lt;/code&gt; function from the &lt;code&gt;add-one&lt;/code&gt; crate in the &lt;code&gt;adder&lt;/code&gt; crate. Open the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file and add a &lt;code&gt;use&lt;/code&gt; line at the top to bring the new &lt;code&gt;add-one&lt;/code&gt; library crate into scope. Then change the &lt;code&gt;main&lt;/code&gt; function to call the &lt;code&gt;add_one&lt;/code&gt; function, as in Listing 14-7.</source>
          <target state="translated">接下来，让我们在 &lt;code&gt;adder&lt;/code&gt; 板条箱中使用 &lt;code&gt;add-one&lt;/code&gt; 板条箱中的 &lt;code&gt;add_one&lt;/code&gt; 函数。打开&lt;em&gt;adder / src / main.rs&lt;/em&gt;文件，并在顶部添加一条 &lt;code&gt;use&lt;/code&gt; 行，以将新的 &lt;code&gt;add-one&lt;/code&gt; 库箱放入范围内。然后将 &lt;code&gt;main&lt;/code&gt; 函数更改为调用 &lt;code&gt;add_one&lt;/code&gt; 函数，如清单14-7所示。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e1fe2a2a98ce9e857e8667aa0e6390f716cb1d28" translate="yes" xml:space="preserve">
          <source>Next, make a new source file and call it &lt;em&gt;main.rs&lt;/em&gt;. Rust files always end with the &lt;em&gt;.rs&lt;/em&gt; extension. If you&amp;rsquo;re using more than one word in your filename, use an underscore to separate them. For example, use &lt;em&gt;hello_world.rs&lt;/em&gt; rather than &lt;em&gt;helloworld.rs&lt;/em&gt;.</source>
          <target state="translated">接下来，做一个新的源文件并调用它&lt;em&gt;main.rs&lt;/em&gt;。Rust文件始终以&lt;em&gt;.rs&lt;/em&gt;扩展名结尾。如果文件名中使用多个单词，请使用下划线将其分开。例如，使用&lt;em&gt;hello_world.rs&lt;/em&gt;而不是&lt;em&gt;helloworld.rs&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="03d3c37a590f1ae7381c9279be8f7a97b6800076" translate="yes" xml:space="preserve">
          <source>Next, we add a call to &lt;code&gt;to_lowercase&lt;/code&gt; on each &lt;code&gt;line&lt;/code&gt; before we check whether it contains &lt;code&gt;query&lt;/code&gt; to lowercase all characters. Now that we&amp;rsquo;ve converted &lt;code&gt;line&lt;/code&gt; and &lt;code&gt;query&lt;/code&gt; to lowercase, we&amp;rsquo;ll find matches no matter what the case of the query is.</source>
          <target state="translated">接下来，在检查行是否包含小写所有字符的 &lt;code&gt;query&lt;/code&gt; 之前，我们在每 &lt;code&gt;line&lt;/code&gt; 上添加一个 &lt;code&gt;to_lowercase&lt;/code&gt; 调用。现在我们已经将 &lt;code&gt;line&lt;/code&gt; 和 &lt;code&gt;query&lt;/code&gt; 转换为小写，无论查询大小写如何，我们都将找到匹配项。</target>
        </trans-unit>
        <trans-unit id="8e52d9272848f0823ca640fddf0b693b0608206b" translate="yes" xml:space="preserve">
          <source>Next, we create an iterator over the array of bytes using the &lt;code&gt;iter&lt;/code&gt; method:</source>
          <target state="translated">接下来，我们使用 &lt;code&gt;iter&lt;/code&gt; 方法在字节数组上创建一个迭代器：</target>
        </trans-unit>
        <trans-unit id="fbb5669be934c8d9daa09d2fb6f075709e7fa5e2" translate="yes" xml:space="preserve">
          <source>Next, we implement a method named &lt;code&gt;value&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt;, doesn&amp;rsquo;t have any other parameters, and returns an &lt;code&gt;i32&lt;/code&gt;. This kind of method is sometimes called a &lt;em&gt;getter&lt;/em&gt;, because its purpose is to get some data from its fields and return it. This public method is necessary because the &lt;code&gt;value&lt;/code&gt; field of the &lt;code&gt;Guess&lt;/code&gt; struct is private. It&amp;rsquo;s important that the &lt;code&gt;value&lt;/code&gt; field be private so code using the &lt;code&gt;Guess&lt;/code&gt; struct is not allowed to set &lt;code&gt;value&lt;/code&gt; directly: code outside the module &lt;em&gt;must&lt;/em&gt; use the &lt;code&gt;Guess::new&lt;/code&gt; function to create an instance of &lt;code&gt;Guess&lt;/code&gt;, thereby ensuring there&amp;rsquo;s no way for a &lt;code&gt;Guess&lt;/code&gt; to have a &lt;code&gt;value&lt;/code&gt; that hasn&amp;rsquo;t been checked by the conditions in the &lt;code&gt;Guess::new&lt;/code&gt; function.</source>
          <target state="translated">接下来，我们实现一个名为 &lt;code&gt;value&lt;/code&gt; 的方法，该方法借用 &lt;code&gt;self&lt;/code&gt; ，没有任何其他参数，然后返回 &lt;code&gt;i32&lt;/code&gt; 。这种方法有时称为&lt;em&gt;getter&lt;/em&gt;，因为其目的是从其字段中获取一些数据并返回。因为 &lt;code&gt;Guess&lt;/code&gt; 结构的 &lt;code&gt;value&lt;/code&gt; 字段是私有的，所以此公共方法是必需的。重要的是， &lt;code&gt;value&lt;/code&gt; 字段是私有的，因此不允许使用 &lt;code&gt;Guess&lt;/code&gt; 结构的代码直接设置 &lt;code&gt;value&lt;/code&gt; ：模块外部的代码&lt;em&gt;必须&lt;/em&gt;使用 &lt;code&gt;Guess::new&lt;/code&gt; 函数创建 &lt;code&gt;Guess&lt;/code&gt; 实例&lt;em&gt;&lt;/em&gt;，从而确保有没有办法让一个 &lt;code&gt;Guess&lt;/code&gt; 有一个 &lt;code&gt;value&lt;/code&gt; 尚未由条件检查 &lt;code&gt;Guess::new&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="605d6de7987c12e157a0df6ee5c1a07b22d453f2" translate="yes" xml:space="preserve">
          <source>Next, we implement the &lt;code&gt;FnBox&lt;/code&gt; trait for any type &lt;code&gt;F&lt;/code&gt; that implements the &lt;code&gt;FnOnce()&lt;/code&gt; trait. Effectively, this means that any &lt;code&gt;FnOnce()&lt;/code&gt; closures can use our &lt;code&gt;call_box&lt;/code&gt; method. The implementation of &lt;code&gt;call_box&lt;/code&gt; uses &lt;code&gt;(*self)()&lt;/code&gt; to move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and call the closure.</source>
          <target state="translated">接下来，我们执行 &lt;code&gt;FnBox&lt;/code&gt; 特质对任何类型的 &lt;code&gt;F&lt;/code&gt; 实现了 &lt;code&gt;FnOnce()&lt;/code&gt; 特征。实际上，这意味着任何 &lt;code&gt;FnOnce()&lt;/code&gt; 闭包都可以使用我们的 &lt;code&gt;call_box&lt;/code&gt; 方法。 &lt;code&gt;call_box&lt;/code&gt; 的实现使用 &lt;code&gt;(*self)()&lt;/code&gt; 将闭包移出 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 并调用闭包。</target>
        </trans-unit>
        <trans-unit id="813cf7c3c4cb11a394f89f5d5322e12f202af557" translate="yes" xml:space="preserve">
          <source>Next, we need to actually read from the stream. We do this in two steps: first, we declare a &lt;code&gt;buffer&lt;/code&gt; on the stack to hold the data that is read in. We&amp;rsquo;ve made the buffer 1024 bytes in size, which is big enough to hold the data of a basic request and sufficient for our purposes in this chapter. If we wanted to handle requests of an arbitrary size, buffer management would need to be more complicated; we&amp;rsquo;ll keep it simple for now. We pass the buffer to &lt;code&gt;stream.read&lt;/code&gt;, which will read bytes from the &lt;code&gt;TcpStream&lt;/code&gt; and put them in the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc7c952c5d6180788b66b960a497f1bbb0d5cfe" translate="yes" xml:space="preserve">
          <source>Next, we need to actually read from the stream. We do this in two steps: first, we declare a &lt;code&gt;buffer&lt;/code&gt; on the stack to hold the data that is read in. We&amp;rsquo;ve made the buffer 512 bytes in size, which is big enough to hold the data of a basic request and sufficient for our purposes in this chapter. If we wanted to handle requests of an arbitrary size, buffer management would need to be more complicated; we&amp;rsquo;ll keep it simple for now. We pass the buffer to &lt;code&gt;stream.read&lt;/code&gt;, which will read bytes from the &lt;code&gt;TcpStream&lt;/code&gt; and put them in the buffer.</source>
          <target state="translated">接下来，我们需要实际读取流。我们分两个步骤进行操作：首先，我们在堆栈上声明一个 &lt;code&gt;buffer&lt;/code&gt; 以容纳读取的数据。我们使缓冲区的大小为512字节，足以容纳基本请求的数据并且足够在本章中出于我们的目的。如果我们要处理任意大小的请求，则缓冲区管理将需要更加复杂。我们暂时保持简单。我们将缓冲区传递给 &lt;code&gt;stream.read&lt;/code&gt; ，它将从 &lt;code&gt;TcpStream&lt;/code&gt; 读取字节并将其放入缓冲区。</target>
        </trans-unit>
        <trans-unit id="76351bb871037a13a112e6c874825b1ebb4611c8" translate="yes" xml:space="preserve">
          <source>Next, we need to add functionality to request a review of a post, which should change its state from &lt;code&gt;Draft&lt;/code&gt; to &lt;code&gt;PendingReview&lt;/code&gt;. Listing 17-15 shows this code:</source>
          <target state="translated">接下来，我们需要添加功能以请求对帖子的审阅，这应该将其状态从 &lt;code&gt;Draft&lt;/code&gt; 更改为 &lt;code&gt;PendingReview&lt;/code&gt; 。清单17-15显示了以下代码：</target>
        </trans-unit>
        <trans-unit id="92e1faec54108ffc0dae30cd9cc0b93fd8d1895e" translate="yes" xml:space="preserve">
          <source>Next, we need to generate a secret number that the user will try to guess. The secret number should be different every time so the game is fun to play more than once. Let&amp;rsquo;s use a random number between 1 and 100 so the game isn&amp;rsquo;t too difficult. Rust doesn&amp;rsquo;t yet include random number functionality in its standard library. However, the Rust team does provide a &lt;a href=&quot;https://crates.io/crates/rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt; crate&lt;/a&gt;.</source>
          <target state="translated">接下来，我们需要生成一个供用户尝试猜测的秘密号码。每次的秘密号码都应该不同，这样，玩一次以上就很有趣了。让我们使用1到100之间的随机数，这样游戏就不太困难了。Rust尚未在其标准库中包含随机数功能。但是，Rust团队确实提供了一个&lt;a href=&quot;https://crates.io/crates/rand&quot;&gt; &lt;code&gt;rand&lt;/code&gt; 箱&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3048ae1981e29d8fc7bb24867dd28498448fb02" translate="yes" xml:space="preserve">
          <source>Next, we need to update the definition of &lt;code&gt;Config::new&lt;/code&gt;. In your I/O project&amp;rsquo;s &lt;em&gt;src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s change the signature of &lt;code&gt;Config::new&lt;/code&gt; to look like Listing 13-26. This still won&amp;rsquo;t compile because we need to update the function body.</source>
          <target state="translated">接下来，我们需要更新 &lt;code&gt;Config::new&lt;/code&gt; 的定义。在I / O项目的&lt;em&gt;src / lib.rs&lt;/em&gt;文件中，让我们将 &lt;code&gt;Config::new&lt;/code&gt; 的签名更改为清单13-26。这仍然无法编译，因为我们需要更新函数主体。</target>
        </trans-unit>
        <trans-unit id="f7002fc97279e473d70d4660362de14f1e116f1c" translate="yes" xml:space="preserve">
          <source>Next, we use &lt;code&gt;format!&lt;/code&gt; to add the file&amp;rsquo;s contents as the body of the success response.</source>
          <target state="translated">接下来，我们使用 &lt;code&gt;format!&lt;/code&gt; 将文件的内容添加为成功响应的正文。</target>
        </trans-unit>
        <trans-unit id="5f1848680d22a75c771965dd71d24a16003163fc" translate="yes" xml:space="preserve">
          <source>Next, we use &lt;code&gt;format!&lt;/code&gt; to add the file&amp;rsquo;s contents as the body of the success response. To ensure a valid HTTP response, we add the &lt;code&gt;Content-Length&lt;/code&gt; header which is set to the size of our response body, in this case the size of &lt;code&gt;hello.html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cb8822a67321b8c02da9e7e8c260dc9c0b608d" translate="yes" xml:space="preserve">
          <source>Next, we want to enable a request for a review of the post, and we want &lt;code&gt;content&lt;/code&gt; to return an empty string while waiting for the review. When the post receives approval, it should get published, meaning the text of the post will be returned when &lt;code&gt;content&lt;/code&gt; is called.</source>
          <target state="translated">接下来，我们要启用对帖子进行审阅的请求，并希望 &lt;code&gt;content&lt;/code&gt; 在等待审阅时返回空字符串。帖子获得批准后，就应该发布，这意味着帖子的 &lt;code&gt;content&lt;/code&gt; 将在调用内容时返回。</target>
        </trans-unit>
        <trans-unit id="dc0c1d1b57e4826864a1d45c2ceee72d00bff7d9" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll check whether the current line contains our query string. Fortunately, strings have a helpful method named &lt;code&gt;contains&lt;/code&gt; that does this for us! Add a call to the &lt;code&gt;contains&lt;/code&gt; method in the &lt;code&gt;search&lt;/code&gt; function, as shown in Listing 12-18. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">接下来，我们将检查当前行是否包含查询字符串。幸运的是，字符串有一个有用的名为 &lt;code&gt;contains&lt;/code&gt; 的方法，它可以为我们做到这一点！在 &lt;code&gt;search&lt;/code&gt; 功能中添加对 &lt;code&gt;contains&lt;/code&gt; 方法的调用，如清单12-18所示。请注意，这仍然不会编译。</target>
        </trans-unit>
        <trans-unit id="5ac1479b99a85012a6bea69ba1759d1f7cc3ad30" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create a place to store the user input, like this:</source>
          <target state="translated">接下来，我们将创建一个存储用户输入的位置，如下所示：</target>
        </trans-unit>
        <trans-unit id="e5a328539b3bbff608c05675d0f98ba529495a33" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create a raw pointer whose validity we can&amp;rsquo;t be so certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, but it is possible.</source>
          <target state="translated">接下来，我们将创建一个原始指针，我们无法确定其有效性。清单19-2显示了如何创建指向内存中任意位置的原始指针。尝试使用任意内存是不确定的：该地址可能有数据，也可能没有，编译器可能优化了代码，所以没有内存访问，或者程序可能由于分段错误而出错。通常，没有充分的理由编写这样的代码，但是有可能。</target>
        </trans-unit>
        <trans-unit id="629644a5201c55cb9634591304da90b26a4571c8" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the &lt;code&gt;adder&lt;/code&gt; binary crate by running &lt;code&gt;cargo new&lt;/code&gt; within the &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">接下来，我们将通过在&lt;em&gt;add&lt;/em&gt;目录中运行 &lt;code&gt;cargo new&lt;/code&gt; 创建 &lt;code&gt;adder&lt;/code&gt; 二进制板条箱：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4c8171dc56214044bf871f6ef39d7d39bc7a5954" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll define the &lt;code&gt;HelloMacro&lt;/code&gt; trait and its associated function:</source>
          <target state="translated">接下来，我们将定义 &lt;code&gt;HelloMacro&lt;/code&gt; 特征及其相关函数：</target>
        </trans-unit>
        <trans-unit id="a47fb6ac34c3efb030b781d2a69ff8c26654e8b7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll explore some Rust features that were influenced by functional languages: closures and iterators.</source>
          <target state="translated">接下来，我们将探究一些受功能语言影响的Rust功能：闭包和迭代器。</target>
        </trans-unit>
        <trans-unit id="de89b671f67de5d1f170a1b7712e3f2c4f2d52b0" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll explore some advanced features related to functions and closures, which include function pointers and returning closures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df380b1f8d3c4226cb4356e67a4308029f7b04af" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll fix the body of &lt;code&gt;Config::new&lt;/code&gt;. The standard library documentation also mentions that &lt;code&gt;std::env::Args&lt;/code&gt; implements the &lt;code&gt;Iterator&lt;/code&gt; trait, so we know we can call the &lt;code&gt;next&lt;/code&gt; method on it! Listing 13-27 updates the code from Listing 12-23 to use the &lt;code&gt;next&lt;/code&gt; method:</source>
          <target state="translated">接下来，我们将修复 &lt;code&gt;Config::new&lt;/code&gt; 的主体。标准库文档还提到 &lt;code&gt;std::env::Args&lt;/code&gt; 实现了 &lt;code&gt;Iterator&lt;/code&gt; 特征，因此我们知道可以对其调用 &lt;code&gt;next&lt;/code&gt; 方法！清单13-27更新了清单12-23中的代码，以使用 &lt;code&gt;next&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="3a19f54b1a11fc876360a8c3cf621da7fa07cef6" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll implement the &lt;code&gt;Iterator&lt;/code&gt; trait for our &lt;code&gt;Counter&lt;/code&gt; type by defining the body of the &lt;code&gt;next&lt;/code&gt; method to specify what we want to happen when this iterator is used, as shown in Listing 13-21:</source>
          <target state="translated">接下来，我们将通过定义 &lt;code&gt;next&lt;/code&gt; 方法的主体来为 &lt;code&gt;Counter&lt;/code&gt; 类型实现 &lt;code&gt;Iterator&lt;/code&gt; trait，以指定使用该迭代器时想要发生的事情，如清单13-21所示：</target>
        </trans-unit>
        <trans-unit id="8192333a1969b9548e0a4b704aec1d71dbd5da8d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a different kind of reference: slices.</source>
          <target state="translated">接下来，我们将看另一种参考：切片。</target>
        </trans-unit>
        <trans-unit id="4634a5dae53b28ce905455154ee2c8f9020614d5" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at patterns, which are another of Rust&amp;rsquo;s features that enable lots of flexibility. We&amp;rsquo;ve looked at them briefly throughout the book but haven&amp;rsquo;t seen their full capability yet. Let&amp;rsquo;s go!</source>
          <target state="translated">接下来，我们将研究模式，这是Rust具有很多灵活性的功能之一。我们在整本书中都简要地看过它们，但是还没有看到它们的全部功能。我们走吧！</target>
        </trans-unit>
        <trans-unit id="c7d28f3c2f2542f898d8da87d4a31466a385d3a6" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll put everything we&amp;rsquo;ve discussed throughout the book into practice and do one more project!</source>
          <target state="translated">接下来，我们将把本书中讨论的所有内容付诸实践，并再做一个项目！</target>
        </trans-unit>
        <trans-unit id="b241e1c5f37c0baa3f70582a9ac2883d59e35af5" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about concurrency in Rust. You&amp;rsquo;ll even learn about a few new smart pointers.</source>
          <target state="translated">接下来，我们将讨论Rust中的并发性。您甚至还将了解一些新的智能指针。</target>
        </trans-unit>
        <trans-unit id="03a59d930c382bd744dde7a012f05351047ee5cc" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about functions and closures!</source>
          <target state="translated">接下来，我们将讨论函数和闭包！</target>
        </trans-unit>
        <trans-unit id="1fde554107211f23cac1a0bbf25be3203f7855d9" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about idiomatic ways to model problems and structure solutions as your Rust programs get bigger. In addition, we&amp;rsquo;ll discuss how Rust&amp;rsquo;s idioms relate to those you might be familiar with from object-oriented programming.</source>
          <target state="translated">接下来，我们将讨论随着Rust程序变得越来越大而用惯用的方式对问题进行建模并构造解决方案。另外，我们将讨论Rust的习惯用法如何与您可能会从面向对象的编程中熟悉的习惯联系起来。</target>
        </trans-unit>
        <trans-unit id="12c381a078ea586c1a6dde5139c1770828ccdb51" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll use our struct definition and create one &lt;code&gt;Node&lt;/code&gt; instance named &lt;code&gt;leaf&lt;/code&gt; with the value 3 and no children, and another instance named &lt;code&gt;branch&lt;/code&gt; with the value 5 and &lt;code&gt;leaf&lt;/code&gt; as one of its children, as shown in Listing 15-27:</source>
          <target state="translated">接下来，我们将使用struct定义并创建一个名为 &lt;code&gt;leaf&lt;/code&gt; 的 &lt;code&gt;Node&lt;/code&gt; 实例，其值为3并且没有任何子级，并创建另一个名为 &lt;code&gt;branch&lt;/code&gt; 的实例，其值为5，并且 &lt;code&gt;leaf&lt;/code&gt; 作为其子级之一，如清单15-27所示：</target>
        </trans-unit>
        <trans-unit id="49cce52cf3729ef44c726e5a417fc215b857117b" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll use these same steps with generics to reduce code duplication in different ways. In the same way that the function body can operate on an abstract &lt;code&gt;list&lt;/code&gt; instead of specific values, generics allow code to operate on abstract types.</source>
          <target state="translated">接下来，我们将对泛型使用相同的步骤，以不同的方式减少代码重复。与函数体可以在抽象 &lt;code&gt;list&lt;/code&gt; 上操作而不是在特定值上操作的方式相同，泛型允许代码对抽象类型进行操作。</target>
        </trans-unit>
        <trans-unit id="05f6878762b08e453ff7c9c981e816c32f84aa8d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;re adding two lines in the middle. The &lt;code&gt;rand::thread_rng&lt;/code&gt; function will give us the particular random number generator that we&amp;rsquo;re going to use: one that is local to the current thread of execution and seeded by the operating system. Then we call the &lt;code&gt;gen_range&lt;/code&gt; method on the random number generator. This method is defined by the &lt;code&gt;Rng&lt;/code&gt; trait that we brought into scope with the &lt;code&gt;use rand::Rng&lt;/code&gt; statement. The &lt;code&gt;gen_range&lt;/code&gt; method takes two numbers as arguments and generates a random number between them. It&amp;rsquo;s inclusive on the lower bound but exclusive on the upper bound, so we need to specify &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;101&lt;/code&gt; to request a number between 1 and 100.</source>
          <target state="translated">接下来，我们在中间添加两行。该 &lt;code&gt;rand::thread_rng&lt;/code&gt; 功能会给我们具体的随机数生成器，我们将使用：一个是本地执行的当前线程和操作系统播种。然后，我们在随机数生成器上调用 &lt;code&gt;gen_range&lt;/code&gt; 方法。该方法由我们 &lt;code&gt;use rand::Rng&lt;/code&gt; 语句引入范围的 &lt;code&gt;Rng&lt;/code&gt; 特性定义。该 &lt;code&gt;gen_range&lt;/code&gt; 方法有两个数字作为参数，并在它们之间产生一个随机数。它在下限包含但在上限不包含，因此我们需要指定 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;101&lt;/code&gt; 以请求1到100之间的数字。</target>
        </trans-unit>
        <trans-unit id="188a1831aead9f2050d9903c88b40256b8d0ba24" translate="yes" xml:space="preserve">
          <source>Nice! Even though spaces were added before the guess, the program still figured out that the user guessed 76. Run the program a few times to verify the different behavior with different kinds of input: guess the number correctly, guess a number that is too high, and guess a number that is too low.</source>
          <target state="translated">很好! 即使在猜测之前加了空格,程序仍然计算出用户猜测的是76。运行程序几次来验证不同类型的输入的不同行为:猜对了数字,猜的数字太高,猜的数字太低。</target>
        </trans-unit>
        <trans-unit id="41d756e582a9b7133fefe3aba97d94609533d175" translate="yes" xml:space="preserve">
          <source>Nice! It&amp;rsquo;s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging. When we have larger structs, it&amp;rsquo;s useful to have output that&amp;rsquo;s a bit easier to read; in those cases, we can use &lt;code&gt;{:#?}&lt;/code&gt; instead of &lt;code&gt;{:?}&lt;/code&gt; in the &lt;code&gt;println!&lt;/code&gt; string. When we use the &lt;code&gt;{:#?}&lt;/code&gt; style in the example, the output will look like this:</source>
          <target state="translated">真好！它不是最漂亮的输出，但是它显示了此实例的所有字段的值，这在调试期间肯定会有所帮助。当我们有更大的结构时，具有易于阅读的输出很有用；在这种情况下，我们可以在 &lt;code&gt;println!&lt;/code&gt; 使用 &lt;code&gt;{:#?}&lt;/code&gt; 而不是 &lt;code&gt;{:?}&lt;/code&gt; ！串。在示例中使用 &lt;code&gt;{:#?}&lt;/code&gt; 样式时，输出将如下所示：</target>
        </trans-unit>
        <trans-unit id="c9e429b1798d0142b8b31e82c1f9da5d8e0c9420" translate="yes" xml:space="preserve">
          <source>Nightly</source>
          <target state="translated">Nightly</target>
        </trans-unit>
        <trans-unit id="0e61ca1796e0a674ec697f05ff94882071738de7" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;../glossary#uncovered-type&quot;&gt;uncovered type&lt;/a&gt; parameters &lt;code&gt;P1..=Pn&lt;/code&gt; may appear in &lt;code&gt;T0..Ti&lt;/code&gt; (excluding &lt;code&gt;Ti&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dabebe1f19f9827a4f8cf661fd813509cd607c6" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;main&lt;/code&gt; function was found in a binary crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3334d46bace193a18342fe23d9ec73cf45eeee44" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;main&lt;/code&gt; function was found in a binary crate. To fix this error, add a &lt;code&gt;main&lt;/code&gt; function. For example:</source>
          <target state="translated">没有 &lt;code&gt;main&lt;/code&gt; 功能是在一个二进制箱中。要解决此错误，请添加一个 &lt;code&gt;main&lt;/code&gt; 功能。例如：</target>
        </trans-unit>
        <trans-unit id="40e9183fb0e170dc10c265ea9f5ac313b7e7824e" translate="yes" xml:space="preserve">
          <source>No arguments to the program</source>
          <target state="translated">没有参数的程序</target>
        </trans-unit>
        <trans-unit id="86e59c19b9b6a6d88fc2db18875d3bedb5eeda2c" translate="yes" xml:space="preserve">
          <source>No code is generated for this intrinsic, but the optimizer will try to preserve it (and its condition) between passes, which may interfere with optimization of surrounding code and reduce performance. It should not be used if the invariant can be discovered by the optimizer on its own, or if it does not enable any significant optimizations.</source>
          <target state="translated">不会为这个本征生成代码,但优化器会在两次传递之间尝试保留它(及其条件),这可能会干扰周围代码的优化,降低性能。如果不变量可以被优化器自行发现,或者它不能实现任何显著的优化,就不应该使用它。</target>
        </trans-unit>
        <trans-unit id="6d24aa51295019d1b05b76a7e56a3b4b701ef15c" translate="yes" xml:space="preserve">
          <source>No data is allocated on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b940936fa4a1fc768ca623a652084963506c1c89" translate="yes" xml:space="preserve">
          <source>No file is allowed to exist at the target location, also no (dangling) symlink. In this way, if the call succeeds, the file returned is guaranteed to be new.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd44839870a9b58128d358fce877ecbaa11fd40a" translate="yes" xml:space="preserve">
          <source>No formal timeline for turning the warnings into errors has been set. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/58781&quot;&gt;GitHub issue 58781&lt;/a&gt; for more information.</source>
          <target state="translated">尚未设置将警告变为错误的正式时间表。有关更多信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/58781&quot;&gt;GitHub问题58781&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f506aac03a59ef1406f6d0689bfcd0dc4c05822a" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that &lt;em&gt;implementations&lt;/em&gt; only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents.</source>
          <target state="translated">调用此函数时，不能保证 &lt;code&gt;buf&lt;/code&gt; 的内容，实现不能依赖 &lt;code&gt;buf&lt;/code&gt; 内容的任何属性为true。建议&lt;em&gt;实现&lt;/em&gt;仅将数据写入 &lt;code&gt;buf&lt;/code&gt; ,而不要读取其内容。</target>
        </trans-unit>
        <trans-unit id="4f0a95bf47b8945eb4629fd1207fec71669b8c5c" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that implementations only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents.</source>
          <target state="translated">调用此函数时，不能保证 &lt;code&gt;buf&lt;/code&gt; 的内容，实现不能依赖 &lt;code&gt;buf&lt;/code&gt; 内容的任何属性为true。建议实现仅将数据写入 &lt;code&gt;buf&lt;/code&gt; ,而不要读取其内容。</target>
        </trans-unit>
        <trans-unit id="44c3fb55dfa5ac1ea3e6cc8751e2f98b499318f5" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that implementations only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents. The documentation on &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; has a more detailed explanation on this subject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0692c18a626152270d81a21a828cf37a6f5e5b" translate="yes" xml:space="preserve">
          <source>No matter whether or not you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust. Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance. You can use this flexibility to implement object-oriented patterns that can help your code&amp;rsquo;s maintainability. Rust also has other features, like ownership, that object-oriented languages don&amp;rsquo;t have. An object-oriented pattern won&amp;rsquo;t always be the best way to take advantage of Rust&amp;rsquo;s strengths, but is an available option.</source>
          <target state="translated">阅读本章后，无论您是否认为Rust是面向对象的语言，现在都知道可以使用trait对象在Rust中获得一些面向对象的功能。动态调度可以使您的代码具有一定的灵活性，以换取一些运行时性能。您可以利用这种灵活性来实现面向对象的模式，这些模式可以帮助您的代码实现可维护性。Rust还具有其他功能，例如所有权，而面向对象的语言则没有。面向对象的模式并非始终是利用Rust的优势的最佳方法，而是一种可用的选项。</target>
        </trans-unit>
        <trans-unit id="11ac1612603c0c3d5163e13082f76411af9ee697" translate="yes" xml:space="preserve">
          <source>No ordering constraints, only atomic operations.</source>
          <target state="translated">没有排序限制,只有原子操作。</target>
        </trans-unit>
        <trans-unit id="2d3c73825e4a8031f1bb82e1a976c1ab255294e6" translate="yes" xml:space="preserve">
          <source>No truncation occurs when &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length:</source>
          <target state="translated">当 &lt;code&gt;len&lt;/code&gt; 大于向量的当前长度时，不会发生截断：</target>
        </trans-unit>
        <trans-unit id="9d9d7a3fa61acc7fab275007c75a11f20d8c99c2" translate="yes" xml:space="preserve">
          <source>No uncovered type parameters &lt;code&gt;P1..=Pm&lt;/code&gt; may appear in &lt;code&gt;T0..Ti&lt;/code&gt; (excluding &lt;code&gt;Ti&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d402441c3b972c1257d41a23a0cf7d56800bfb6" translate="yes" xml:space="preserve">
          <source>No value</source>
          <target state="translated">无价值</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="e1e00ea722ddcc62dfc3b69613fb2a2d565490a9" translate="yes" xml:space="preserve">
          <source>Nominal types</source>
          <target state="translated">名义类型</target>
        </trans-unit>
        <trans-unit id="cdb02ce94d87fb6259e95b77d6deab219ecd04ba" translate="yes" xml:space="preserve">
          <source>Nominal types &amp;mdash; &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt; and &lt;a href=&quot;types/union&quot;&gt;unions&lt;/a&gt; &amp;mdash; may be recursive. That is, each &lt;code&gt;enum&lt;/code&gt; variant or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; field may refer, directly or indirectly, to the enclosing &lt;code&gt;enum&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; type itself. Such recursion has restrictions:</source>
          <target state="translated">标称类型（&lt;a href=&quot;types/struct&quot;&gt;结构&lt;/a&gt;，&lt;a href=&quot;types/enum&quot;&gt;枚举&lt;/a&gt;和&lt;a href=&quot;types/union&quot;&gt;联合&lt;/a&gt;）可能是递归的。也就是说，每个 &lt;code&gt;enum&lt;/code&gt; 变量， &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; 字段都可以直接或间接引用封闭的 &lt;code&gt;enum&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; 类型本身。这种递归有一些限制：</target>
        </trans-unit>
        <trans-unit id="f4149c46b37e254e72be155dd7b9caf947125984" translate="yes" xml:space="preserve">
          <source>Nominal types &amp;mdash; &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;types/union&quot;&gt;unions&lt;/a&gt; &amp;mdash; may be recursive. That is, each &lt;code&gt;enum&lt;/code&gt; variant or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; field may refer, directly or indirectly, to the enclosing &lt;code&gt;enum&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; type itself. Such recursion has restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b8571666155408fb60b3d7bfe218ca438c97ed" translate="yes" xml:space="preserve">
          <source>Nominal types without a &lt;code&gt;repr&lt;/code&gt; attribute have the default representation. Informally, this representation is also called the &lt;code&gt;rust&lt;/code&gt; representation.</source>
          <target state="translated">没有 &lt;code&gt;repr&lt;/code&gt; 属性的标称类型具有默认表示形式。非正式地，该表示也称为 &lt;code&gt;rust&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="5059fea19d0d88b99facd98e04beb3723c567878" translate="yes" xml:space="preserve">
          <source>Non capturing closures to &lt;code&gt;fn&lt;/code&gt; pointers</source>
          <target state="translated">不捕获对 &lt;code&gt;fn&lt;/code&gt; 指针的闭包</target>
        </trans-unit>
        <trans-unit id="a51a0d057519ba84abe774072805e81677bec4c4" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1983af4c53629f3985aabae2faea197763bce6d6" translate="yes" xml:space="preserve">
          <source>Non-UTF-8 byte sequences in a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 中的非UTF-8字节序列。</target>
        </trans-unit>
        <trans-unit id="c7afa6ec3e9abfb77b76d7813a424b3a22eeb6a6" translate="yes" xml:space="preserve">
          <source>Non-allocating substring search.</source>
          <target state="translated">非分配子串搜索。</target>
        </trans-unit>
        <trans-unit id="918c67058d00d25e0f0f3d637bc930eba67e9f26" translate="yes" xml:space="preserve">
          <source>Non-ascii can be used as module names if it is inlined or if a &lt;code&gt;#[path]&lt;/code&gt; attribute is specified. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcd44915e2ff9a86c47e1f5d9c641f6ca3a035b" translate="yes" xml:space="preserve">
          <source>Non-doc comments</source>
          <target state="translated">非文件评论</target>
        </trans-unit>
        <trans-unit id="824440476584993bab7b4958488eb74ef1df4ce3" translate="yes" xml:space="preserve">
          <source>Non-doc comments are interpreted as a form of whitespace.</source>
          <target state="translated">非doc注释被解释为一种空白的形式。</target>
        </trans-unit>
        <trans-unit id="aa21851a9f906887214ca347fd6a9f54a7e9f855" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cecc28192fc5e84850b4a3c1cd7bbfd836407b" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.Empty&quot;&gt;&lt;code id=&quot;Empty.v&quot;&gt;Empty&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">非穷举枚举将来可能会添加其他变体。因此，在与非穷举枚举的变体进行匹配时，必须添加一个额外的通配符臂来考虑将来的任何变体。&lt;span id=&quot;variant.Empty&quot;&gt; &lt;code id=&quot;Empty.v&quot;&gt;Empty&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c2d926eda1237eaff90e4752c522197b25cce1b5" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.NotFound&quot;&gt;&lt;code id=&quot;NotFound.v&quot;&gt;NotFound&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">非穷举枚举将来可能会添加其他变体。因此，当与非穷举枚举的变体匹配时，必须添加一个额外的通配符臂来考虑将来的任何变体。&lt;span id=&quot;variant.NotFound&quot;&gt; &lt;code id=&quot;NotFound.v&quot;&gt;NotFound&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9ffc5a4a3c3cd6c9da0af373638cb3d4d5bda691" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.Relaxed&quot;&gt;&lt;code id=&quot;Relaxed.v&quot;&gt;Relaxed&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">非穷举枚举将来可能会添加其他变体。因此，在与非穷举枚举的变体进行匹配时，必须添加一个额外的通配符臂来考虑将来的任何变体。&lt;span id=&quot;variant.Relaxed&quot;&gt; &lt;code id=&quot;Relaxed.v&quot;&gt;Relaxed&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0eb9bd2ad410dc2a883c07d5cdc83ffe0afd40df" translate="yes" xml:space="preserve">
          <source>Non-exhaustive types are always considered inhabited in downstream crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a6b0df00b9143148ae426e200b78dbd7fb89f" translate="yes" xml:space="preserve">
          <source>Non-exhaustive types cannot be constructed outside of the defining crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f438ec02f71051c0a40ce9311998d29382298836" translate="yes" xml:space="preserve">
          <source>Non-exhaustive variants (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; variant&lt;/a&gt;) cannot be constructed with a &lt;a href=&quot;../expressions/struct-expr&quot;&gt;&lt;em&gt;StructExpression&lt;/em&gt;&lt;/a&gt; (including with &lt;a href=&quot;../expressions/struct-expr#functional-update-syntax&quot;&gt;functional update syntax&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677ced73d5856aaca0b6f678eabc91c14dca818b" translate="yes" xml:space="preserve">
          <source>Non-operator Symbols</source>
          <target state="translated">非操作者符号</target>
        </trans-unit>
        <trans-unit id="4e30c9c45a102a66eb26f8221fcbff4ef463e321" translate="yes" xml:space="preserve">
          <source>NonNull</source>
          <target state="translated">NonNull</target>
        </trans-unit>
        <trans-unit id="4406dddaf8fa2617ceb6cc8c44402048c8cf820a" translate="yes" xml:space="preserve">
          <source>NonNull::as_mut</source>
          <target state="translated">NonNull::as_mut</target>
        </trans-unit>
        <trans-unit id="2114c5e9abc5430a075844ac84cde8dc1be1fea6" translate="yes" xml:space="preserve">
          <source>NonNull::as_ptr</source>
          <target state="translated">NonNull::as_ptr</target>
        </trans-unit>
        <trans-unit id="1cabae6d82425bb900a0d474f79596c63d831307" translate="yes" xml:space="preserve">
          <source>NonNull::as_ref</source>
          <target state="translated">NonNull::as_ref</target>
        </trans-unit>
        <trans-unit id="6ed17b6bc3c37842c56b35d303eedea6a7299966" translate="yes" xml:space="preserve">
          <source>NonNull::borrow</source>
          <target state="translated">NonNull::borrow</target>
        </trans-unit>
        <trans-unit id="7e334211ca12677d4c793a4a4f5aff0a42317022" translate="yes" xml:space="preserve">
          <source>NonNull::borrow_mut</source>
          <target state="translated">NonNull::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d14ea41704eb3153152593ae4083750dca37c043" translate="yes" xml:space="preserve">
          <source>NonNull::cast</source>
          <target state="translated">NonNull::cast</target>
        </trans-unit>
        <trans-unit id="898faa9b1446e51151d3471366dee5a575326bb3" translate="yes" xml:space="preserve">
          <source>NonNull::clamp</source>
          <target state="translated">NonNull::clamp</target>
        </trans-unit>
        <trans-unit id="bf5ade412290b7a0e9f887083d2f7add59f5a5fc" translate="yes" xml:space="preserve">
          <source>NonNull::clone</source>
          <target state="translated">NonNull::clone</target>
        </trans-unit>
        <trans-unit id="d26e757d1bc68cfc66ec9cac7468feab54ad3bf1" translate="yes" xml:space="preserve">
          <source>NonNull::clone_from</source>
          <target state="translated">NonNull::clone_from</target>
        </trans-unit>
        <trans-unit id="ec88376a17645ec47ad005ff58328f13df7dd535" translate="yes" xml:space="preserve">
          <source>NonNull::clone_into</source>
          <target state="translated">NonNull::clone_into</target>
        </trans-unit>
        <trans-unit id="fd33327c1c03c18157e310949eb3ee49adc1b771" translate="yes" xml:space="preserve">
          <source>NonNull::cmp</source>
          <target state="translated">NonNull::cmp</target>
        </trans-unit>
        <trans-unit id="987e425f6d75ea2d5d6595ecf927bb4ee065890c" translate="yes" xml:space="preserve">
          <source>NonNull::dangling</source>
          <target state="translated">NonNull::dangling</target>
        </trans-unit>
        <trans-unit id="c22e4114ed2e98fa57926d0f979b5e4f67cb57d4" translate="yes" xml:space="preserve">
          <source>NonNull::eq</source>
          <target state="translated">NonNull::eq</target>
        </trans-unit>
        <trans-unit id="d00b2d876766572056074e351b4e54188d623d2b" translate="yes" xml:space="preserve">
          <source>NonNull::fmt</source>
          <target state="translated">NonNull::fmt</target>
        </trans-unit>
        <trans-unit id="920d1fd41b172fec04d2e45bb2bdef697e4fe777" translate="yes" xml:space="preserve">
          <source>NonNull::from</source>
          <target state="translated">NonNull::from</target>
        </trans-unit>
        <trans-unit id="e069f30f0197691ef84cfb150cfed51e68e388e1" translate="yes" xml:space="preserve">
          <source>NonNull::ge</source>
          <target state="translated">NonNull::ge</target>
        </trans-unit>
        <trans-unit id="c04dde85527ee18200a552eae552b457a7f99bd6" translate="yes" xml:space="preserve">
          <source>NonNull::gt</source>
          <target state="translated">NonNull::gt</target>
        </trans-unit>
        <trans-unit id="1962f7d627fcf30051ef24ad505c0bc5f914d525" translate="yes" xml:space="preserve">
          <source>NonNull::hash</source>
          <target state="translated">NonNull::hash</target>
        </trans-unit>
        <trans-unit id="947f5524bfbda623a81d3a1c8013f457968a7a86" translate="yes" xml:space="preserve">
          <source>NonNull::hash_slice</source>
          <target state="translated">NonNull::hash_slice</target>
        </trans-unit>
        <trans-unit id="389c43bbeacefc5b6764890179f4b9b2032438f2" translate="yes" xml:space="preserve">
          <source>NonNull::into</source>
          <target state="translated">NonNull::into</target>
        </trans-unit>
        <trans-unit id="47e7802874702c46a2e861846c1495c139c4c850" translate="yes" xml:space="preserve">
          <source>NonNull::le</source>
          <target state="translated">NonNull::le</target>
        </trans-unit>
        <trans-unit id="9345c04e2a031789eec4e0c10625a029c4ae6f61" translate="yes" xml:space="preserve">
          <source>NonNull::lt</source>
          <target state="translated">NonNull::lt</target>
        </trans-unit>
        <trans-unit id="7a29d42be85ea3d359fc0499cfc787631cbd8fc5" translate="yes" xml:space="preserve">
          <source>NonNull::max</source>
          <target state="translated">NonNull::max</target>
        </trans-unit>
        <trans-unit id="61df043b4cb69b06e977ed45aa61b72a55c0c1a7" translate="yes" xml:space="preserve">
          <source>NonNull::min</source>
          <target state="translated">NonNull::min</target>
        </trans-unit>
        <trans-unit id="abded46d5ba3ed8a510f52a6c525d34081184868" translate="yes" xml:space="preserve">
          <source>NonNull::ne</source>
          <target state="translated">NonNull::ne</target>
        </trans-unit>
        <trans-unit id="28098f7280cb4f6eb94dfb98674503d36042312c" translate="yes" xml:space="preserve">
          <source>NonNull::new</source>
          <target state="translated">NonNull::new</target>
        </trans-unit>
        <trans-unit id="faebd85a1d1a684a9974b3cced67816fb864d3e2" translate="yes" xml:space="preserve">
          <source>NonNull::new_unchecked</source>
          <target state="translated">NonNull::new_unchecked</target>
        </trans-unit>
        <trans-unit id="daad03caa96878a899bd74268cdf22f8762238fc" translate="yes" xml:space="preserve">
          <source>NonNull::partial_cmp</source>
          <target state="translated">NonNull::partial_cmp</target>
        </trans-unit>
        <trans-unit id="4a54ca911ffa7ae9c156cb290778a55bb5102986" translate="yes" xml:space="preserve">
          <source>NonNull::to_owned</source>
          <target state="translated">NonNull::to_owned</target>
        </trans-unit>
        <trans-unit id="9c8c974cd30a86ae9347bdcc34e89477c2ec64af" translate="yes" xml:space="preserve">
          <source>NonNull::try_from</source>
          <target state="translated">NonNull::try_from</target>
        </trans-unit>
        <trans-unit id="cbe36570c4b5d03cc4de672aa3768cec6ff79fc7" translate="yes" xml:space="preserve">
          <source>NonNull::try_into</source>
          <target state="translated">NonNull::try_into</target>
        </trans-unit>
        <trans-unit id="5c4656d738141e414301ef5f2fc675edf57dbe67" translate="yes" xml:space="preserve">
          <source>NonNull::type_id</source>
          <target state="translated">NonNull::type_id</target>
        </trans-unit>
        <trans-unit id="3551d2c727366d003ebd8c642167f4ef9debfb26" translate="yes" xml:space="preserve">
          <source>NonZeroI128</source>
          <target state="translated">NonZeroI128</target>
        </trans-unit>
        <trans-unit id="f7717a5e03944c9f7da8d5810a2b468333e1dd38" translate="yes" xml:space="preserve">
          <source>NonZeroI128::borrow</source>
          <target state="translated">NonZeroI128::borrow</target>
        </trans-unit>
        <trans-unit id="f964efe706788bf3868121236c120eec56d477d3" translate="yes" xml:space="preserve">
          <source>NonZeroI128::borrow_mut</source>
          <target state="translated">NonZeroI128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5ff8443b26f494de74b190931a04e5ad0a0f8bce" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clamp</source>
          <target state="translated">NonZeroI128::clamp</target>
        </trans-unit>
        <trans-unit id="b41821f2bbc6d793e496bf8cf8e0961c8c6cf20e" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone</source>
          <target state="translated">NonZeroI128::clone</target>
        </trans-unit>
        <trans-unit id="86b0e71b93cf7cfc8d3f88502fefd684a7508a83" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone_from</source>
          <target state="translated">NonZeroI128::clone_from</target>
        </trans-unit>
        <trans-unit id="e87976c36fbb769fdf82eb4fc79b3850621b2d11" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone_into</source>
          <target state="translated">NonZeroI128::clone_into</target>
        </trans-unit>
        <trans-unit id="1fbab26faccad65c9594c9912db60595257c834d" translate="yes" xml:space="preserve">
          <source>NonZeroI128::cmp</source>
          <target state="translated">NonZeroI128::cmp</target>
        </trans-unit>
        <trans-unit id="e40f0ecb53bba7364d61eeddde211916e2de23b0" translate="yes" xml:space="preserve">
          <source>NonZeroI128::eq</source>
          <target state="translated">NonZeroI128::eq</target>
        </trans-unit>
        <trans-unit id="06203fb0241e3db251fdbeb37b55ecf55bc73b90" translate="yes" xml:space="preserve">
          <source>NonZeroI128::fmt</source>
          <target state="translated">NonZeroI128::fmt</target>
        </trans-unit>
        <trans-unit id="0fc860ac20708b78eba2f88aebf4c0cae43f1b01" translate="yes" xml:space="preserve">
          <source>NonZeroI128::from</source>
          <target state="translated">NonZeroI128::from</target>
        </trans-unit>
        <trans-unit id="e9225e88cc3a187fc6e8da37813f50d8aace8352" translate="yes" xml:space="preserve">
          <source>NonZeroI128::from_str</source>
          <target state="translated">NonZeroI128::from_str</target>
        </trans-unit>
        <trans-unit id="1060cfd82a1c5a4f9319951b3ccf33667960e338" translate="yes" xml:space="preserve">
          <source>NonZeroI128::ge</source>
          <target state="translated">NonZeroI128::ge</target>
        </trans-unit>
        <trans-unit id="1174fff40e9915f0fddc11dc5e858638caff1eb7" translate="yes" xml:space="preserve">
          <source>NonZeroI128::get</source>
          <target state="translated">NonZeroI128::get</target>
        </trans-unit>
        <trans-unit id="6360aa3b732a77c2367a197d6649d264398a3733" translate="yes" xml:space="preserve">
          <source>NonZeroI128::gt</source>
          <target state="translated">NonZeroI128::gt</target>
        </trans-unit>
        <trans-unit id="74c9ab59cffa5d7149b9a4669f4269b74eeb9074" translate="yes" xml:space="preserve">
          <source>NonZeroI128::hash</source>
          <target state="translated">NonZeroI128::hash</target>
        </trans-unit>
        <trans-unit id="683d8b9cc521cc55c631921795be0979d992e3f0" translate="yes" xml:space="preserve">
          <source>NonZeroI128::hash_slice</source>
          <target state="translated">NonZeroI128::hash_slice</target>
        </trans-unit>
        <trans-unit id="aa52174afecb1310862de00467bdc35c65937a26" translate="yes" xml:space="preserve">
          <source>NonZeroI128::into</source>
          <target state="translated">NonZeroI128::into</target>
        </trans-unit>
        <trans-unit id="148aa4d7eea87fc4622065d40fb8f2ec58899a47" translate="yes" xml:space="preserve">
          <source>NonZeroI128::le</source>
          <target state="translated">NonZeroI128::le</target>
        </trans-unit>
        <trans-unit id="4cab526460d9eafdf6e790d31dfeefc0f6385568" translate="yes" xml:space="preserve">
          <source>NonZeroI128::lt</source>
          <target state="translated">NonZeroI128::lt</target>
        </trans-unit>
        <trans-unit id="c0e0f0d6f1984e61de46b50df3dd15bb2c3be699" translate="yes" xml:space="preserve">
          <source>NonZeroI128::max</source>
          <target state="translated">NonZeroI128::max</target>
        </trans-unit>
        <trans-unit id="afd96d69d525973449f87aee12afd0af77bb90ff" translate="yes" xml:space="preserve">
          <source>NonZeroI128::min</source>
          <target state="translated">NonZeroI128::min</target>
        </trans-unit>
        <trans-unit id="246cde0659cbc3a878d28d1aa05929c570deac33" translate="yes" xml:space="preserve">
          <source>NonZeroI128::ne</source>
          <target state="translated">NonZeroI128::ne</target>
        </trans-unit>
        <trans-unit id="8673425a72ca5491b6fece38839c045e52eb4d36" translate="yes" xml:space="preserve">
          <source>NonZeroI128::new</source>
          <target state="translated">NonZeroI128::new</target>
        </trans-unit>
        <trans-unit id="83c86c3acc20bd4fdf03572b0722c1f12370f0bb" translate="yes" xml:space="preserve">
          <source>NonZeroI128::new_unchecked</source>
          <target state="translated">NonZeroI128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="7d31a0e09cd71a4a287a5059ffc925fb40c7ce05" translate="yes" xml:space="preserve">
          <source>NonZeroI128::partial_cmp</source>
          <target state="translated">NonZeroI128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="608c27b25bdd1b009cc3a24d8a6782000bd55a1c" translate="yes" xml:space="preserve">
          <source>NonZeroI128::to_owned</source>
          <target state="translated">NonZeroI128::to_owned</target>
        </trans-unit>
        <trans-unit id="744cd6d60888a33636a82b0368460edf2109a4f4" translate="yes" xml:space="preserve">
          <source>NonZeroI128::to_string</source>
          <target state="translated">NonZeroI128::to_string</target>
        </trans-unit>
        <trans-unit id="ac99be0bfb14a319fad21b69b5e280921b9604e7" translate="yes" xml:space="preserve">
          <source>NonZeroI128::try_from</source>
          <target state="translated">NonZeroI128::try_from</target>
        </trans-unit>
        <trans-unit id="2abe344dbf2f82320c3d223157d57b6766d23549" translate="yes" xml:space="preserve">
          <source>NonZeroI128::try_into</source>
          <target state="translated">NonZeroI128::try_into</target>
        </trans-unit>
        <trans-unit id="10a577a305c3efc3499cc94da566386465669213" translate="yes" xml:space="preserve">
          <source>NonZeroI128::type_id</source>
          <target state="translated">NonZeroI128::type_id</target>
        </trans-unit>
        <trans-unit id="36f429958b2bd2e0923475b148a0c1f6e808e911" translate="yes" xml:space="preserve">
          <source>NonZeroI16</source>
          <target state="translated">NonZeroI16</target>
        </trans-unit>
        <trans-unit id="18b48de75cdc24dca01c5ee1c28e20115a7eb2a1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::borrow</source>
          <target state="translated">NonZeroI16::borrow</target>
        </trans-unit>
        <trans-unit id="bdbca21815164e23bce622eb47091fb5f9f2176c" translate="yes" xml:space="preserve">
          <source>NonZeroI16::borrow_mut</source>
          <target state="translated">NonZeroI16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2541826a258687d3b644073478113268e63c74af" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clamp</source>
          <target state="translated">NonZeroI16::clamp</target>
        </trans-unit>
        <trans-unit id="115ee98eb9f17414d1638645fa06af3167003827" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone</source>
          <target state="translated">NonZeroI16::clone</target>
        </trans-unit>
        <trans-unit id="0278b33294858e10f554d1971ffc6f87bb8f5b09" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone_from</source>
          <target state="translated">NonZeroI16::clone_from</target>
        </trans-unit>
        <trans-unit id="c7c71d2e0fcced1b160e7459dff80d6f48dcbc4f" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone_into</source>
          <target state="translated">NonZeroI16::clone_into</target>
        </trans-unit>
        <trans-unit id="850888fdd17f8d9104362438c1677057b27654a4" translate="yes" xml:space="preserve">
          <source>NonZeroI16::cmp</source>
          <target state="translated">NonZeroI16::cmp</target>
        </trans-unit>
        <trans-unit id="f05c890da588a6175c01f462a0b77681853ea3b1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::eq</source>
          <target state="translated">NonZeroI16::eq</target>
        </trans-unit>
        <trans-unit id="afd24843e5add4461be3e24eb291a9cc7627956c" translate="yes" xml:space="preserve">
          <source>NonZeroI16::fmt</source>
          <target state="translated">NonZeroI16::fmt</target>
        </trans-unit>
        <trans-unit id="4858ff995b8e659abd51265d63ea466463440d7f" translate="yes" xml:space="preserve">
          <source>NonZeroI16::from</source>
          <target state="translated">NonZeroI16::from</target>
        </trans-unit>
        <trans-unit id="e029bc06979cac03c696126c7078fc97b9d215f8" translate="yes" xml:space="preserve">
          <source>NonZeroI16::from_str</source>
          <target state="translated">NonZeroI16::from_str</target>
        </trans-unit>
        <trans-unit id="bafd6163144db642a0a88ae9a0d1f67a9aa327c8" translate="yes" xml:space="preserve">
          <source>NonZeroI16::ge</source>
          <target state="translated">NonZeroI16::ge</target>
        </trans-unit>
        <trans-unit id="8aabc8e5c65d44f1317cc2c944b8544a7d7743b4" translate="yes" xml:space="preserve">
          <source>NonZeroI16::get</source>
          <target state="translated">NonZeroI16::get</target>
        </trans-unit>
        <trans-unit id="f4bd402ef0cb908aeee7f003297047e0d4730ffe" translate="yes" xml:space="preserve">
          <source>NonZeroI16::gt</source>
          <target state="translated">NonZeroI16::gt</target>
        </trans-unit>
        <trans-unit id="eea24fe60c2ee511de571b916e274e0b8b9953ea" translate="yes" xml:space="preserve">
          <source>NonZeroI16::hash</source>
          <target state="translated">NonZeroI16::hash</target>
        </trans-unit>
        <trans-unit id="2072b7c0817666ffd6461a331c7f56a7e3159241" translate="yes" xml:space="preserve">
          <source>NonZeroI16::hash_slice</source>
          <target state="translated">NonZeroI16::hash_slice</target>
        </trans-unit>
        <trans-unit id="609c336f653a5586992a687fdc21a4e12e0e5bfc" translate="yes" xml:space="preserve">
          <source>NonZeroI16::into</source>
          <target state="translated">NonZeroI16::into</target>
        </trans-unit>
        <trans-unit id="dcd26dca67e989e320ea7d8ce4a6b4b2f5a19253" translate="yes" xml:space="preserve">
          <source>NonZeroI16::le</source>
          <target state="translated">NonZeroI16::le</target>
        </trans-unit>
        <trans-unit id="764441ce7cfb74845e4e5601e7c04d15cb44d34d" translate="yes" xml:space="preserve">
          <source>NonZeroI16::lt</source>
          <target state="translated">NonZeroI16::lt</target>
        </trans-unit>
        <trans-unit id="ba011aa8171b9001b2fd20e4d332efc5ad115b12" translate="yes" xml:space="preserve">
          <source>NonZeroI16::max</source>
          <target state="translated">NonZeroI16::max</target>
        </trans-unit>
        <trans-unit id="a323327b77c7bebd588241f8e49fcd0eb80d98c1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::min</source>
          <target state="translated">NonZeroI16::min</target>
        </trans-unit>
        <trans-unit id="2ea2360fbbb5c24f384364e47a1ccf667fabf208" translate="yes" xml:space="preserve">
          <source>NonZeroI16::ne</source>
          <target state="translated">NonZeroI16::ne</target>
        </trans-unit>
        <trans-unit id="8a2d9c5311b2f8e5e740b1521cf3f032afe2075a" translate="yes" xml:space="preserve">
          <source>NonZeroI16::new</source>
          <target state="translated">NonZeroI16::new</target>
        </trans-unit>
        <trans-unit id="d31ab8bc0d5d31927c609f1a69be30fb3accda97" translate="yes" xml:space="preserve">
          <source>NonZeroI16::new_unchecked</source>
          <target state="translated">NonZeroI16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="9f248594130914dc8c1850b1503ca6a5baa9ab10" translate="yes" xml:space="preserve">
          <source>NonZeroI16::partial_cmp</source>
          <target state="translated">NonZeroI16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="e47f6505b2ad746102f22ad01953cb709a47b9ca" translate="yes" xml:space="preserve">
          <source>NonZeroI16::to_owned</source>
          <target state="translated">NonZeroI16::to_owned</target>
        </trans-unit>
        <trans-unit id="9e491563b10305c5dc822fc5b251f24741e46929" translate="yes" xml:space="preserve">
          <source>NonZeroI16::to_string</source>
          <target state="translated">NonZeroI16::to_string</target>
        </trans-unit>
        <trans-unit id="f4ff4d972a8c42fa8c0abaffc2f1e2b76fcb4197" translate="yes" xml:space="preserve">
          <source>NonZeroI16::try_from</source>
          <target state="translated">NonZeroI16::try_from</target>
        </trans-unit>
        <trans-unit id="63b8ff5cf42ec223a0adb54868428b7e995a5c22" translate="yes" xml:space="preserve">
          <source>NonZeroI16::try_into</source>
          <target state="translated">NonZeroI16::try_into</target>
        </trans-unit>
        <trans-unit id="c06a21dec83a42f8edb2e0d6693bc0ed2ab66da7" translate="yes" xml:space="preserve">
          <source>NonZeroI16::type_id</source>
          <target state="translated">NonZeroI16::type_id</target>
        </trans-unit>
        <trans-unit id="e97bcb5feaee0189523545e2b1d1eaf6c4e683e0" translate="yes" xml:space="preserve">
          <source>NonZeroI32</source>
          <target state="translated">NonZeroI32</target>
        </trans-unit>
        <trans-unit id="54c92b19f0c002e52d95b9a54c687cabaec7d0c3" translate="yes" xml:space="preserve">
          <source>NonZeroI32::borrow</source>
          <target state="translated">NonZeroI32::borrow</target>
        </trans-unit>
        <trans-unit id="6269e913feb8c230d29ea7ab62da579bdbf5a4eb" translate="yes" xml:space="preserve">
          <source>NonZeroI32::borrow_mut</source>
          <target state="translated">NonZeroI32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1224c3cd7e71ba3386431b31298d37d70f8c5b82" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clamp</source>
          <target state="translated">NonZeroI32::clamp</target>
        </trans-unit>
        <trans-unit id="84582bf1efcf9bffacf576b2dc9d228ded21783f" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone</source>
          <target state="translated">NonZeroI32::clone</target>
        </trans-unit>
        <trans-unit id="6d253c4ffdb7629f523cd7bb9f9e369a62759084" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone_from</source>
          <target state="translated">NonZeroI32::clone_from</target>
        </trans-unit>
        <trans-unit id="1193f158b2ad7d7a268d3f866cb7f7b1315214d1" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone_into</source>
          <target state="translated">NonZeroI32::clone_into</target>
        </trans-unit>
        <trans-unit id="4b603b1e9d2c2afaaf494daaf899ac95dbaaf60d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::cmp</source>
          <target state="translated">NonZeroI32::cmp</target>
        </trans-unit>
        <trans-unit id="36ea7e2e5a4bb27588581579d297e2d75bde8c04" translate="yes" xml:space="preserve">
          <source>NonZeroI32::eq</source>
          <target state="translated">NonZeroI32::eq</target>
        </trans-unit>
        <trans-unit id="1edda6e591f89ce442f2cb26f60edda071d57e45" translate="yes" xml:space="preserve">
          <source>NonZeroI32::fmt</source>
          <target state="translated">NonZeroI32::fmt</target>
        </trans-unit>
        <trans-unit id="ddd4914f74fdfcbf44e61dac8ed824dc7daf8835" translate="yes" xml:space="preserve">
          <source>NonZeroI32::from</source>
          <target state="translated">NonZeroI32::from</target>
        </trans-unit>
        <trans-unit id="40c6ed7e5bb0241e56fda5056b11bd5c06468ef7" translate="yes" xml:space="preserve">
          <source>NonZeroI32::from_str</source>
          <target state="translated">NonZeroI32::from_str</target>
        </trans-unit>
        <trans-unit id="ade03fa8f0e3d00c9d57318b69563c321a5de2eb" translate="yes" xml:space="preserve">
          <source>NonZeroI32::ge</source>
          <target state="translated">NonZeroI32::ge</target>
        </trans-unit>
        <trans-unit id="1d06e8a039855892a9b222f01348adf7e49edc4d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::get</source>
          <target state="translated">NonZeroI32::get</target>
        </trans-unit>
        <trans-unit id="fa60ed7434a0539f3d9490e5fd97303495e8e4c6" translate="yes" xml:space="preserve">
          <source>NonZeroI32::gt</source>
          <target state="translated">NonZeroI32::gt</target>
        </trans-unit>
        <trans-unit id="f8325277d4aaaad37e3f8e3f7eea57d33a82b14d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::hash</source>
          <target state="translated">NonZeroI32::hash</target>
        </trans-unit>
        <trans-unit id="15d30eee444980fbb702c19bb0e763a3a3edcf54" translate="yes" xml:space="preserve">
          <source>NonZeroI32::hash_slice</source>
          <target state="translated">NonZeroI32::hash_slice</target>
        </trans-unit>
        <trans-unit id="803e758732aa4ff1933498c8c223c849e07ecb60" translate="yes" xml:space="preserve">
          <source>NonZeroI32::into</source>
          <target state="translated">NonZeroI32::into</target>
        </trans-unit>
        <trans-unit id="790804224c71a8a913941fd99262449cfc4eae1f" translate="yes" xml:space="preserve">
          <source>NonZeroI32::le</source>
          <target state="translated">NonZeroI32::le</target>
        </trans-unit>
        <trans-unit id="67201699a9447f0b39d54ba4f84c3b95336721f4" translate="yes" xml:space="preserve">
          <source>NonZeroI32::lt</source>
          <target state="translated">NonZeroI32::lt</target>
        </trans-unit>
        <trans-unit id="ed55b8cb9ce6596e0102020b3149699afc739afa" translate="yes" xml:space="preserve">
          <source>NonZeroI32::max</source>
          <target state="translated">NonZeroI32::max</target>
        </trans-unit>
        <trans-unit id="ea9de8a6d3342c8565ee626a42eaee51ddecb252" translate="yes" xml:space="preserve">
          <source>NonZeroI32::min</source>
          <target state="translated">NonZeroI32::min</target>
        </trans-unit>
        <trans-unit id="b4954c9a76b0d358e8ac80094df9a4364fff4cb7" translate="yes" xml:space="preserve">
          <source>NonZeroI32::ne</source>
          <target state="translated">NonZeroI32::ne</target>
        </trans-unit>
        <trans-unit id="6049048c2192264cafbbf66dce8946d4e59179cf" translate="yes" xml:space="preserve">
          <source>NonZeroI32::new</source>
          <target state="translated">NonZeroI32::new</target>
        </trans-unit>
        <trans-unit id="fffc2d80845e3795deaddee315cce1ed09540038" translate="yes" xml:space="preserve">
          <source>NonZeroI32::new_unchecked</source>
          <target state="translated">NonZeroI32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="da01db7b3738e2a15dd55235e9cf2517c43505ad" translate="yes" xml:space="preserve">
          <source>NonZeroI32::partial_cmp</source>
          <target state="translated">NonZeroI32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="86e152a0c12749dda033dd64bbf2468b20925901" translate="yes" xml:space="preserve">
          <source>NonZeroI32::to_owned</source>
          <target state="translated">NonZeroI32::to_owned</target>
        </trans-unit>
        <trans-unit id="c8e2c1746dcaaf891c7f0924e2a7d50565492f1c" translate="yes" xml:space="preserve">
          <source>NonZeroI32::to_string</source>
          <target state="translated">NonZeroI32::to_string</target>
        </trans-unit>
        <trans-unit id="55a921f848a7b22a94032abe096e9e693c57d8c2" translate="yes" xml:space="preserve">
          <source>NonZeroI32::try_from</source>
          <target state="translated">NonZeroI32::try_from</target>
        </trans-unit>
        <trans-unit id="153dc660977b7dbd63100838a1c1f00c97814fda" translate="yes" xml:space="preserve">
          <source>NonZeroI32::try_into</source>
          <target state="translated">NonZeroI32::try_into</target>
        </trans-unit>
        <trans-unit id="d326f8bf5b1e05bd3e854148e764814dfa31fec6" translate="yes" xml:space="preserve">
          <source>NonZeroI32::type_id</source>
          <target state="translated">NonZeroI32::type_id</target>
        </trans-unit>
        <trans-unit id="47326afc55d69221c5bab6f6fc50b489aa6e615c" translate="yes" xml:space="preserve">
          <source>NonZeroI64</source>
          <target state="translated">NonZeroI64</target>
        </trans-unit>
        <trans-unit id="dc475e1ce0d61071c86badb53c4876f712060aa4" translate="yes" xml:space="preserve">
          <source>NonZeroI64::borrow</source>
          <target state="translated">NonZeroI64::borrow</target>
        </trans-unit>
        <trans-unit id="b34344f17d4f0c2fd181fff34ce7e309683eb1f9" translate="yes" xml:space="preserve">
          <source>NonZeroI64::borrow_mut</source>
          <target state="translated">NonZeroI64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ed2423a4aa70c798c0ab5645f6d832bd412161f6" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clamp</source>
          <target state="translated">NonZeroI64::clamp</target>
        </trans-unit>
        <trans-unit id="f5d711fdbab29c1437fb83b2a0f49dcbcc2c895c" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone</source>
          <target state="translated">NonZeroI64::clone</target>
        </trans-unit>
        <trans-unit id="267a861768f4cde9358a3ce3dea2c45f82d2d70c" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone_from</source>
          <target state="translated">NonZeroI64::clone_from</target>
        </trans-unit>
        <trans-unit id="5cb0bd8479d4a4e335894c67e9f47406638b985a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone_into</source>
          <target state="translated">NonZeroI64::clone_into</target>
        </trans-unit>
        <trans-unit id="62c821c3e10a9bc5dda6564e62e097e6d1aaded4" translate="yes" xml:space="preserve">
          <source>NonZeroI64::cmp</source>
          <target state="translated">NonZeroI64::cmp</target>
        </trans-unit>
        <trans-unit id="69e086a251f574f1bcd8ddeee49f798091de65ae" translate="yes" xml:space="preserve">
          <source>NonZeroI64::eq</source>
          <target state="translated">NonZeroI64::eq</target>
        </trans-unit>
        <trans-unit id="4628e95346886a1385b96213a08e94cab6a3e3ec" translate="yes" xml:space="preserve">
          <source>NonZeroI64::fmt</source>
          <target state="translated">NonZeroI64::fmt</target>
        </trans-unit>
        <trans-unit id="fa74211c65ed03702df0d7fec92011a00e46da4e" translate="yes" xml:space="preserve">
          <source>NonZeroI64::from</source>
          <target state="translated">NonZeroI64::from</target>
        </trans-unit>
        <trans-unit id="374c31c818806d2d53cf7d6521ef765de951d640" translate="yes" xml:space="preserve">
          <source>NonZeroI64::from_str</source>
          <target state="translated">NonZeroI64::from_str</target>
        </trans-unit>
        <trans-unit id="716f09379283859a96964aa90f9488fffda7f930" translate="yes" xml:space="preserve">
          <source>NonZeroI64::ge</source>
          <target state="translated">NonZeroI64::ge</target>
        </trans-unit>
        <trans-unit id="2826557154d33d398abcd879206752804a2bdf65" translate="yes" xml:space="preserve">
          <source>NonZeroI64::get</source>
          <target state="translated">NonZeroI64::get</target>
        </trans-unit>
        <trans-unit id="c03423dc02e1ef948358b0f5f0ef5c13016b5d96" translate="yes" xml:space="preserve">
          <source>NonZeroI64::gt</source>
          <target state="translated">NonZeroI64::gt</target>
        </trans-unit>
        <trans-unit id="7c084405e2fa1d7847475c21cc64bd06540a721b" translate="yes" xml:space="preserve">
          <source>NonZeroI64::hash</source>
          <target state="translated">NonZeroI64::hash</target>
        </trans-unit>
        <trans-unit id="bb8f897598ee6dc20d33aa36af3c10e2b97e157a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::hash_slice</source>
          <target state="translated">NonZeroI64::hash_slice</target>
        </trans-unit>
        <trans-unit id="ef8da458756764d04abbf9c4bf5a7d43687e9799" translate="yes" xml:space="preserve">
          <source>NonZeroI64::into</source>
          <target state="translated">NonZeroI64::into</target>
        </trans-unit>
        <trans-unit id="361205d1a32febcfc1190394e636de20cf9980ff" translate="yes" xml:space="preserve">
          <source>NonZeroI64::le</source>
          <target state="translated">NonZeroI64::le</target>
        </trans-unit>
        <trans-unit id="bfa76864905ebec51d3cd7370cb21f3b8325bc2a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::lt</source>
          <target state="translated">NonZeroI64::lt</target>
        </trans-unit>
        <trans-unit id="d05fd485f6f48cbcf9797f21c7f72b7da774ef73" translate="yes" xml:space="preserve">
          <source>NonZeroI64::max</source>
          <target state="translated">NonZeroI64::max</target>
        </trans-unit>
        <trans-unit id="4445fa7cd5899e3dddfe813b834bacaadd0b1f16" translate="yes" xml:space="preserve">
          <source>NonZeroI64::min</source>
          <target state="translated">NonZeroI64::min</target>
        </trans-unit>
        <trans-unit id="0e8b97484e878d06b6ee68465379752feed3cd3d" translate="yes" xml:space="preserve">
          <source>NonZeroI64::ne</source>
          <target state="translated">NonZeroI64::ne</target>
        </trans-unit>
        <trans-unit id="bde2e9f1fb06520bab485b2e3afb4e80b33dba82" translate="yes" xml:space="preserve">
          <source>NonZeroI64::new</source>
          <target state="translated">NonZeroI64::new</target>
        </trans-unit>
        <trans-unit id="f82a0245493af04b7985ed399fa466dc4edc8ced" translate="yes" xml:space="preserve">
          <source>NonZeroI64::new_unchecked</source>
          <target state="translated">NonZeroI64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="ff0c4a829e7306aac0aa333126abf09bbe21f706" translate="yes" xml:space="preserve">
          <source>NonZeroI64::partial_cmp</source>
          <target state="translated">NonZeroI64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="12b3dd3db76faeb57eec7254b2c1977c25f88349" translate="yes" xml:space="preserve">
          <source>NonZeroI64::to_owned</source>
          <target state="translated">NonZeroI64::to_owned</target>
        </trans-unit>
        <trans-unit id="898927cce217ffb93b1463253607e0954996b3fd" translate="yes" xml:space="preserve">
          <source>NonZeroI64::to_string</source>
          <target state="translated">NonZeroI64::to_string</target>
        </trans-unit>
        <trans-unit id="2d19979b95b66165d9cce2a874b5b50774c07fee" translate="yes" xml:space="preserve">
          <source>NonZeroI64::try_from</source>
          <target state="translated">NonZeroI64::try_from</target>
        </trans-unit>
        <trans-unit id="a50be005ecf5a07bc843f676f748462b8adca096" translate="yes" xml:space="preserve">
          <source>NonZeroI64::try_into</source>
          <target state="translated">NonZeroI64::try_into</target>
        </trans-unit>
        <trans-unit id="0134deb92dae159c2082bceaef595cfc9df55dce" translate="yes" xml:space="preserve">
          <source>NonZeroI64::type_id</source>
          <target state="translated">NonZeroI64::type_id</target>
        </trans-unit>
        <trans-unit id="de2b631972cf994d47d76eac38bd59ef1aa6e707" translate="yes" xml:space="preserve">
          <source>NonZeroI8</source>
          <target state="translated">NonZeroI8</target>
        </trans-unit>
        <trans-unit id="02a97b1be1b57111983e0f301eaade35ec979636" translate="yes" xml:space="preserve">
          <source>NonZeroI8::borrow</source>
          <target state="translated">NonZeroI8::borrow</target>
        </trans-unit>
        <trans-unit id="585184585d76b6d884767a1ba1173bf3fdcf9087" translate="yes" xml:space="preserve">
          <source>NonZeroI8::borrow_mut</source>
          <target state="translated">NonZeroI8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="61d82766a6745e76c9a921124d58b68ee8622344" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clamp</source>
          <target state="translated">NonZeroI8::clamp</target>
        </trans-unit>
        <trans-unit id="9639aa6f98547170260a0dbed71fe42368a45037" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone</source>
          <target state="translated">NonZeroI8::clone</target>
        </trans-unit>
        <trans-unit id="69bea805436f5d9faeecb421d3ad1efbed040ab0" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone_from</source>
          <target state="translated">NonZeroI8::clone_from</target>
        </trans-unit>
        <trans-unit id="f79563630b90126fa16369923d147a8e6ffaf90f" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone_into</source>
          <target state="translated">NonZeroI8::clone_into</target>
        </trans-unit>
        <trans-unit id="2e5b078a7705aaa646d49606a0e296d4af0f1acd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::cmp</source>
          <target state="translated">NonZeroI8::cmp</target>
        </trans-unit>
        <trans-unit id="cdfffa6f6db5c090ca460987b1da2d174ad3dd70" translate="yes" xml:space="preserve">
          <source>NonZeroI8::eq</source>
          <target state="translated">NonZeroI8::eq</target>
        </trans-unit>
        <trans-unit id="303fe1ff3066af96ac1869cf4c4fcfeeee433dc7" translate="yes" xml:space="preserve">
          <source>NonZeroI8::fmt</source>
          <target state="translated">NonZeroI8::fmt</target>
        </trans-unit>
        <trans-unit id="77bf7d94ae999f9b201e336425c9ca11763912ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::from</source>
          <target state="translated">NonZeroI8::from</target>
        </trans-unit>
        <trans-unit id="058ab838a9faa626f87b01a68a1ab8af9ceffa5e" translate="yes" xml:space="preserve">
          <source>NonZeroI8::from_str</source>
          <target state="translated">NonZeroI8::from_str</target>
        </trans-unit>
        <trans-unit id="5ffec8af45e4b9e098c857beafee4bb4710502df" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ge</source>
          <target state="translated">NonZeroI8::ge</target>
        </trans-unit>
        <trans-unit id="39931bb71d49054bdf1fb8e4a5d156766e03a349" translate="yes" xml:space="preserve">
          <source>NonZeroI8::get</source>
          <target state="translated">NonZeroI8::get</target>
        </trans-unit>
        <trans-unit id="47babee6888e0103956b5d6fb324645bab23db7a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::gt</source>
          <target state="translated">NonZeroI8::gt</target>
        </trans-unit>
        <trans-unit id="93874d53399c77a41bf9531800d5f0fa474a4cda" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash</source>
          <target state="translated">NonZeroI8::hash</target>
        </trans-unit>
        <trans-unit id="29013108ddf40e18600983e97e9034bd5257369c" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash_slice</source>
          <target state="translated">NonZeroI8::hash_slice</target>
        </trans-unit>
        <trans-unit id="037dc348d54512f4eac4bc525c27d1f766b25a1a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::into</source>
          <target state="translated">NonZeroI8::into</target>
        </trans-unit>
        <trans-unit id="0515501fa1d050e6a321477214d1c4d9c56b0a91" translate="yes" xml:space="preserve">
          <source>NonZeroI8::le</source>
          <target state="translated">NonZeroI8::le</target>
        </trans-unit>
        <trans-unit id="7cad17cf5fce8924f80e26fc0cc84eaa9e833005" translate="yes" xml:space="preserve">
          <source>NonZeroI8::lt</source>
          <target state="translated">NonZeroI8::lt</target>
        </trans-unit>
        <trans-unit id="90330e65e0da907071c3c4c3d6a116bb84c932c4" translate="yes" xml:space="preserve">
          <source>NonZeroI8::max</source>
          <target state="translated">NonZeroI8::max</target>
        </trans-unit>
        <trans-unit id="e20ad8db00b5d962f11dd424a9bc3a6c8e774305" translate="yes" xml:space="preserve">
          <source>NonZeroI8::min</source>
          <target state="translated">NonZeroI8::min</target>
        </trans-unit>
        <trans-unit id="73e8e9fd3f901d81ee2336d6e8ea9cf220fba88b" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ne</source>
          <target state="translated">NonZeroI8::ne</target>
        </trans-unit>
        <trans-unit id="af45d6c29f79e266eb5d7ab85309f358f8208a69" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new</source>
          <target state="translated">NonZeroI8::new</target>
        </trans-unit>
        <trans-unit id="81a02f698c1e4f2332bb4e3e7c3edf4ff27a1c50" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new_unchecked</source>
          <target state="translated">NonZeroI8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2686fbb343af79a855c02e59fa60522e101b42ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::partial_cmp</source>
          <target state="translated">NonZeroI8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cd75ff5beac899fb4e419778f9513cbe1ad0b2a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_owned</source>
          <target state="translated">NonZeroI8::to_owned</target>
        </trans-unit>
        <trans-unit id="2b4fc6493819df1f404760f50612536b8bbfc7bd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_string</source>
          <target state="translated">NonZeroI8::to_string</target>
        </trans-unit>
        <trans-unit id="44995331a911be947ba3e877e13ce380ef4d9378" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_from</source>
          <target state="translated">NonZeroI8::try_from</target>
        </trans-unit>
        <trans-unit id="c6edd8a860f42d4c84935088ebf51ade98d95115" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_into</source>
          <target state="translated">NonZeroI8::try_into</target>
        </trans-unit>
        <trans-unit id="694926ab4cd6b261f66a7c4ea43bd5a538ca07a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::type_id</source>
          <target state="translated">NonZeroI8::type_id</target>
        </trans-unit>
        <trans-unit id="39eb2a5ae94e10b055d94f86300fae4bd3a2c861" translate="yes" xml:space="preserve">
          <source>NonZeroIsize</source>
          <target state="translated">NonZeroIsize</target>
        </trans-unit>
        <trans-unit id="4075b4a43affee6576128660a15087ef7d46f01c" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow</source>
          <target state="translated">NonZeroIsize::borrow</target>
        </trans-unit>
        <trans-unit id="ec545959e67fee5329d2293a10abf7982b0e5d27" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow_mut</source>
          <target state="translated">NonZeroIsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a61bacb1affb3b3a864b9054448b3c878abd8923" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clamp</source>
          <target state="translated">NonZeroIsize::clamp</target>
        </trans-unit>
        <trans-unit id="191e1ee11e03e2904eddf99c3224190191357bac" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone</source>
          <target state="translated">NonZeroIsize::clone</target>
        </trans-unit>
        <trans-unit id="5dc48b7609417f7ce614e10e63d58e556492bcf9" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_from</source>
          <target state="translated">NonZeroIsize::clone_from</target>
        </trans-unit>
        <trans-unit id="d38a3dead1294ded03ccb72c57ad049cf009cb60" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_into</source>
          <target state="translated">NonZeroIsize::clone_into</target>
        </trans-unit>
        <trans-unit id="ca7ed6d7cb5393e8a7ba6e95fd43e5b4d5bb7809" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::cmp</source>
          <target state="translated">NonZeroIsize::cmp</target>
        </trans-unit>
        <trans-unit id="2fe615f032ce982861bba71b45a232958641a0cd" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::eq</source>
          <target state="translated">NonZeroIsize::eq</target>
        </trans-unit>
        <trans-unit id="d9ec29b8a341c99081d89a3bd91dc15ff5f6812f" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::fmt</source>
          <target state="translated">NonZeroIsize::fmt</target>
        </trans-unit>
        <trans-unit id="817a465d80d81fe1b61c88aca0859799182b0ced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from</source>
          <target state="translated">NonZeroIsize::from</target>
        </trans-unit>
        <trans-unit id="d2cfcb21d317b6fab455622f5d899c19b4caab20" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from_str</source>
          <target state="translated">NonZeroIsize::from_str</target>
        </trans-unit>
        <trans-unit id="955b4cb4cf6dd3e94857ccb753d3fe4d1fb111bb" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ge</source>
          <target state="translated">NonZeroIsize::ge</target>
        </trans-unit>
        <trans-unit id="94dfb4eb2acf5d4199e2494aa3141f234b7ec552" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::get</source>
          <target state="translated">NonZeroIsize::get</target>
        </trans-unit>
        <trans-unit id="ee800c8db94226df90984d0310a1c3b583e90f13" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::gt</source>
          <target state="translated">NonZeroIsize::gt</target>
        </trans-unit>
        <trans-unit id="36fffe56efef4816a331398e4562a265e92bfb10" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash</source>
          <target state="translated">NonZeroIsize::hash</target>
        </trans-unit>
        <trans-unit id="cf00fd8ca399a52d34e9a8feac17a1b26fe0bcee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash_slice</source>
          <target state="translated">NonZeroIsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="882f34faf603e4c98fc372332977f902076ab5a0" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::into</source>
          <target state="translated">NonZeroIsize::into</target>
        </trans-unit>
        <trans-unit id="0d24785358cfb27caebb3a32bf5c7678cb2e30ee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::le</source>
          <target state="translated">NonZeroIsize::le</target>
        </trans-unit>
        <trans-unit id="f8f7c7c85f4aab3786722bfd2d7aefb8b686bd6e" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::lt</source>
          <target state="translated">NonZeroIsize::lt</target>
        </trans-unit>
        <trans-unit id="19c94dc6fa11f95d35e7c7c4f115e86acb80fc00" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::max</source>
          <target state="translated">NonZeroIsize::max</target>
        </trans-unit>
        <trans-unit id="9bf079159116a040501bb2bee238b98de390d6b7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::min</source>
          <target state="translated">NonZeroIsize::min</target>
        </trans-unit>
        <trans-unit id="78420580500ef47e7d9c63e510686240542d08c3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ne</source>
          <target state="translated">NonZeroIsize::ne</target>
        </trans-unit>
        <trans-unit id="9b5caea647537e28a582a1b68216f403a92bdea7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new</source>
          <target state="translated">NonZeroIsize::new</target>
        </trans-unit>
        <trans-unit id="f92bdba42fa66b6909fc4ad5b38b7d0a8808cced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new_unchecked</source>
          <target state="translated">NonZeroIsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2b55347d5d71b451caf945bb5b1b4cacc28afc98" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::partial_cmp</source>
          <target state="translated">NonZeroIsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="717d7fcf3dd2db66a5b657bdcd5df3b72e3ca14d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_owned</source>
          <target state="translated">NonZeroIsize::to_owned</target>
        </trans-unit>
        <trans-unit id="1a88ee49d5b8865561ef951ccbe17add31975cf3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_string</source>
          <target state="translated">NonZeroIsize::to_string</target>
        </trans-unit>
        <trans-unit id="aeed335ba630cd0f02972d3792f625986e0da579" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_from</source>
          <target state="translated">NonZeroIsize::try_from</target>
        </trans-unit>
        <trans-unit id="3b703381eaac2b4d7c2b865c4b56d5e07385cb0d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_into</source>
          <target state="translated">NonZeroIsize::try_into</target>
        </trans-unit>
        <trans-unit id="cfd236d892fc65a9056aca980b3c2a0c1b08fc90" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::type_id</source>
          <target state="translated">NonZeroIsize::type_id</target>
        </trans-unit>
        <trans-unit id="0044d6a252510995bf93ecb1dd199ad6280b0298" translate="yes" xml:space="preserve">
          <source>NonZeroU128</source>
          <target state="translated">NonZeroU128</target>
        </trans-unit>
        <trans-unit id="d33cdcef0f6bce3ae4d1c100820f29fb8e8de6be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow</source>
          <target state="translated">NonZeroU128::borrow</target>
        </trans-unit>
        <trans-unit id="3f647fdd084e34cb19c62fa95a5df0d0b02f7830" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow_mut</source>
          <target state="translated">NonZeroU128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6dd84c262632c4ce99cd20fd6d4cce46ad766f6c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clamp</source>
          <target state="translated">NonZeroU128::clamp</target>
        </trans-unit>
        <trans-unit id="54a6620faedc0c0d7296506b17b24167c833f343" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone</source>
          <target state="translated">NonZeroU128::clone</target>
        </trans-unit>
        <trans-unit id="361f908936891415e62dbb126d73b91cdd535809" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_from</source>
          <target state="translated">NonZeroU128::clone_from</target>
        </trans-unit>
        <trans-unit id="95b289a7b3408284866f730f49c7cefc4940ea32" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_into</source>
          <target state="translated">NonZeroU128::clone_into</target>
        </trans-unit>
        <trans-unit id="939d6fc64a58c3aad5a29fd29b5cb1ddf18ffa03" translate="yes" xml:space="preserve">
          <source>NonZeroU128::cmp</source>
          <target state="translated">NonZeroU128::cmp</target>
        </trans-unit>
        <trans-unit id="e3d76ecf73e9d2bddfdc690dd3583c65cb4e8c6b" translate="yes" xml:space="preserve">
          <source>NonZeroU128::eq</source>
          <target state="translated">NonZeroU128::eq</target>
        </trans-unit>
        <trans-unit id="cf1f402d3b803071978d5c02ef20145ad5e75f93" translate="yes" xml:space="preserve">
          <source>NonZeroU128::fmt</source>
          <target state="translated">NonZeroU128::fmt</target>
        </trans-unit>
        <trans-unit id="1cb47e3de5cf28c31000e229db50c161ce7a7c28" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from</source>
          <target state="translated">NonZeroU128::from</target>
        </trans-unit>
        <trans-unit id="04a3a610d61c54fe04e5c4fb7dc3736c9608563d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from_str</source>
          <target state="translated">NonZeroU128::from_str</target>
        </trans-unit>
        <trans-unit id="b8dacf31071a7dcf6913c1d5f60e1467a0c7b52c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ge</source>
          <target state="translated">NonZeroU128::ge</target>
        </trans-unit>
        <trans-unit id="bc070e9b4c11812f956c2c3942dbeeb60e1907d7" translate="yes" xml:space="preserve">
          <source>NonZeroU128::get</source>
          <target state="translated">NonZeroU128::get</target>
        </trans-unit>
        <trans-unit id="bf61b92a5979f684a74d24d35e7223a980f74915" translate="yes" xml:space="preserve">
          <source>NonZeroU128::gt</source>
          <target state="translated">NonZeroU128::gt</target>
        </trans-unit>
        <trans-unit id="66888226d70c2e49258374545510affc0bdd95ec" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash</source>
          <target state="translated">NonZeroU128::hash</target>
        </trans-unit>
        <trans-unit id="11f423a193c168fdc5ff7611f300ac57dfd70171" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash_slice</source>
          <target state="translated">NonZeroU128::hash_slice</target>
        </trans-unit>
        <trans-unit id="b29bc2e8eba682c97ef473e0bd889b9b87439b43" translate="yes" xml:space="preserve">
          <source>NonZeroU128::into</source>
          <target state="translated">NonZeroU128::into</target>
        </trans-unit>
        <trans-unit id="dd97daae9ce7a0b9ab85c6cf73bd03826d2dacad" translate="yes" xml:space="preserve">
          <source>NonZeroU128::le</source>
          <target state="translated">NonZeroU128::le</target>
        </trans-unit>
        <trans-unit id="4c5ffedb155e243e75eb535bd12d40831e3c5755" translate="yes" xml:space="preserve">
          <source>NonZeroU128::lt</source>
          <target state="translated">NonZeroU128::lt</target>
        </trans-unit>
        <trans-unit id="cefe09ff65521779b9f59c83b8f0425d577bc41f" translate="yes" xml:space="preserve">
          <source>NonZeroU128::max</source>
          <target state="translated">NonZeroU128::max</target>
        </trans-unit>
        <trans-unit id="66bc9dddfd54e67077a2f3098f5b87831d049d31" translate="yes" xml:space="preserve">
          <source>NonZeroU128::min</source>
          <target state="translated">NonZeroU128::min</target>
        </trans-unit>
        <trans-unit id="1af4ac1a95b7f36c718aa21d748fb13ce2e824ee" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ne</source>
          <target state="translated">NonZeroU128::ne</target>
        </trans-unit>
        <trans-unit id="774e6ffc8823e6223f1ffa87fab102416ea1637d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new</source>
          <target state="translated">NonZeroU128::new</target>
        </trans-unit>
        <trans-unit id="80588590ec2ef5a265edf292dba20ca05ed9ff1d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new_unchecked</source>
          <target state="translated">NonZeroU128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="4f33be7cbf8c678c8187f371f4f5d027a69d0647" translate="yes" xml:space="preserve">
          <source>NonZeroU128::partial_cmp</source>
          <target state="translated">NonZeroU128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="3dea4243dcea470ba4d4f180f81f6eecca14e04e" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_owned</source>
          <target state="translated">NonZeroU128::to_owned</target>
        </trans-unit>
        <trans-unit id="24acde94eff6342ff2fba2e9d267a2fdb25acd94" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_string</source>
          <target state="translated">NonZeroU128::to_string</target>
        </trans-unit>
        <trans-unit id="b21ef37ea8ca3269318a2c852c86163df43432be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_from</source>
          <target state="translated">NonZeroU128::try_from</target>
        </trans-unit>
        <trans-unit id="6c546400526ea1ed6ea89201862535a6549699f1" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_into</source>
          <target state="translated">NonZeroU128::try_into</target>
        </trans-unit>
        <trans-unit id="5b4b31430f7adfc4f26872a558ae35d43d7da9ff" translate="yes" xml:space="preserve">
          <source>NonZeroU128::type_id</source>
          <target state="translated">NonZeroU128::type_id</target>
        </trans-unit>
        <trans-unit id="70d9b595abe5e850f484266bc477e3d70b58c790" translate="yes" xml:space="preserve">
          <source>NonZeroU16</source>
          <target state="translated">NonZeroU16</target>
        </trans-unit>
        <trans-unit id="a2e830bdc612e459ecbf94a5d900db9adf22d552" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow</source>
          <target state="translated">NonZeroU16::borrow</target>
        </trans-unit>
        <trans-unit id="84a81450427618c9efd99c6046bdcfcb15a8f7bb" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow_mut</source>
          <target state="translated">NonZeroU16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4eb94e8343ecdde314f21ae1472878c2e5be4f43" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clamp</source>
          <target state="translated">NonZeroU16::clamp</target>
        </trans-unit>
        <trans-unit id="4f9cad5198a59312536b10433f5195716121d4f5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone</source>
          <target state="translated">NonZeroU16::clone</target>
        </trans-unit>
        <trans-unit id="d8ef4ec4d957a02aaa882335c6f3d0a67035a3c7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_from</source>
          <target state="translated">NonZeroU16::clone_from</target>
        </trans-unit>
        <trans-unit id="3808aec2130dc48a153e5a520294b26744b3e702" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_into</source>
          <target state="translated">NonZeroU16::clone_into</target>
        </trans-unit>
        <trans-unit id="9d0062487248621e89b96fe5bf643abe821bb17a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::cmp</source>
          <target state="translated">NonZeroU16::cmp</target>
        </trans-unit>
        <trans-unit id="41a2d5bd4797b2d1eb6b20161786347a9f0dd370" translate="yes" xml:space="preserve">
          <source>NonZeroU16::eq</source>
          <target state="translated">NonZeroU16::eq</target>
        </trans-unit>
        <trans-unit id="4e58083d69fb5df5404d73e024559cb858948a6f" translate="yes" xml:space="preserve">
          <source>NonZeroU16::fmt</source>
          <target state="translated">NonZeroU16::fmt</target>
        </trans-unit>
        <trans-unit id="f40fdab8202fbcb58f6fbdbc2b16303b0de2f1ee" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from</source>
          <target state="translated">NonZeroU16::from</target>
        </trans-unit>
        <trans-unit id="97bb49319fe5098129502422bda785cd16c5234a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from_str</source>
          <target state="translated">NonZeroU16::from_str</target>
        </trans-unit>
        <trans-unit id="12e676e778fbbdbfffb5d2b98fabd5a4306c10e5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ge</source>
          <target state="translated">NonZeroU16::ge</target>
        </trans-unit>
        <trans-unit id="1313691aadbfef04a5d2c70132da7c9072b9834a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::get</source>
          <target state="translated">NonZeroU16::get</target>
        </trans-unit>
        <trans-unit id="e4a7103dfe5dfdaccf5405172a6bfb6564cbb39e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::gt</source>
          <target state="translated">NonZeroU16::gt</target>
        </trans-unit>
        <trans-unit id="4843257888dce95e20cf1eaff515263fe997bf35" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash</source>
          <target state="translated">NonZeroU16::hash</target>
        </trans-unit>
        <trans-unit id="b9c900dd5aa52134650740a33c407b05339dc782" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash_slice</source>
          <target state="translated">NonZeroU16::hash_slice</target>
        </trans-unit>
        <trans-unit id="83aabdee7d487ec9cb728178e573f802394226b4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::into</source>
          <target state="translated">NonZeroU16::into</target>
        </trans-unit>
        <trans-unit id="7970d0eb118d83ab0b72df82542034727ba2a453" translate="yes" xml:space="preserve">
          <source>NonZeroU16::le</source>
          <target state="translated">NonZeroU16::le</target>
        </trans-unit>
        <trans-unit id="2e5e858925d50659f9b1b6d9aae3740085d6d25b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::lt</source>
          <target state="translated">NonZeroU16::lt</target>
        </trans-unit>
        <trans-unit id="5d3b1652b96c8f150360a583d2605f47b1963560" translate="yes" xml:space="preserve">
          <source>NonZeroU16::max</source>
          <target state="translated">NonZeroU16::max</target>
        </trans-unit>
        <trans-unit id="1e4034b09df30190832a52072bcf8af6041bbf4d" translate="yes" xml:space="preserve">
          <source>NonZeroU16::min</source>
          <target state="translated">NonZeroU16::min</target>
        </trans-unit>
        <trans-unit id="815e8d53bff937d8e0463d3319f42f6179bc0760" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ne</source>
          <target state="translated">NonZeroU16::ne</target>
        </trans-unit>
        <trans-unit id="23ac83515dc8fab41df4280bc33fe4bc456b4ff2" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new</source>
          <target state="translated">NonZeroU16::new</target>
        </trans-unit>
        <trans-unit id="bb140336d169ad21d933a68a3d8746b26d1b8b72" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new_unchecked</source>
          <target state="translated">NonZeroU16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d8dd3cac934926e6de446e12a7408c3a4890b68e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::partial_cmp</source>
          <target state="translated">NonZeroU16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="93b1877253643b0a75cda9a47fc455fc67b284f7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_owned</source>
          <target state="translated">NonZeroU16::to_owned</target>
        </trans-unit>
        <trans-unit id="450d0b2017abf1787e4b40c9180053f5f1c5d6b5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_string</source>
          <target state="translated">NonZeroU16::to_string</target>
        </trans-unit>
        <trans-unit id="565d7bfa4f368119e8eb8c597666eee168d3ec36" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_from</source>
          <target state="translated">NonZeroU16::try_from</target>
        </trans-unit>
        <trans-unit id="c9ffda0c65ec9d2c6dac8e1259fd7cb09818b7a4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_into</source>
          <target state="translated">NonZeroU16::try_into</target>
        </trans-unit>
        <trans-unit id="35a3919e55cf0455983744e7e8ab659cda957d3b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::type_id</source>
          <target state="translated">NonZeroU16::type_id</target>
        </trans-unit>
        <trans-unit id="027b94edf209f9b339fcc3f9fcbe95bea73b0fff" translate="yes" xml:space="preserve">
          <source>NonZeroU32</source>
          <target state="translated">NonZeroU32</target>
        </trans-unit>
        <trans-unit id="19103157b2dd994e271093d37a26558f253c1df5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow</source>
          <target state="translated">NonZeroU32::borrow</target>
        </trans-unit>
        <trans-unit id="d5900a35010072cf8f8a0e31e3295500e147138f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow_mut</source>
          <target state="translated">NonZeroU32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a3d0eea5bcf469a951789307713538f7dd48cc64" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clamp</source>
          <target state="translated">NonZeroU32::clamp</target>
        </trans-unit>
        <trans-unit id="ca9c328d071b73e6fec77d280d2dec16c6afe8be" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone</source>
          <target state="translated">NonZeroU32::clone</target>
        </trans-unit>
        <trans-unit id="4d0cce4f0af9fe9b58667070ea3aae8608af18fc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_from</source>
          <target state="translated">NonZeroU32::clone_from</target>
        </trans-unit>
        <trans-unit id="beeb1f8a7db4e17dce219e3b75ed85a27a214ce6" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_into</source>
          <target state="translated">NonZeroU32::clone_into</target>
        </trans-unit>
        <trans-unit id="66de3d60d49a5fd2460c7fce4fc4af569dea2ea8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::cmp</source>
          <target state="translated">NonZeroU32::cmp</target>
        </trans-unit>
        <trans-unit id="b9a64d225fbd880a1d363e7928600204954c435d" translate="yes" xml:space="preserve">
          <source>NonZeroU32::eq</source>
          <target state="translated">NonZeroU32::eq</target>
        </trans-unit>
        <trans-unit id="d198043d6e6b2dcbdbd140d6e9a9832d41ef00b0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::fmt</source>
          <target state="translated">NonZeroU32::fmt</target>
        </trans-unit>
        <trans-unit id="f99dcfdc314e32f70a453660a94f7ab9fd67185e" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from</source>
          <target state="translated">NonZeroU32::from</target>
        </trans-unit>
        <trans-unit id="298799838c58c16143fcd9e2418534b329517ba2" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from_str</source>
          <target state="translated">NonZeroU32::from_str</target>
        </trans-unit>
        <trans-unit id="6cd1cc0b365f1d3d480575dcbc2de54dae6a1d17" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ge</source>
          <target state="translated">NonZeroU32::ge</target>
        </trans-unit>
        <trans-unit id="1dbe40ea77f784440de6e51cfcfb8778482bc067" translate="yes" xml:space="preserve">
          <source>NonZeroU32::get</source>
          <target state="translated">NonZeroU32::get</target>
        </trans-unit>
        <trans-unit id="e88628f83bc918c532752959c92d4ac82adbf0fd" translate="yes" xml:space="preserve">
          <source>NonZeroU32::gt</source>
          <target state="translated">NonZeroU32::gt</target>
        </trans-unit>
        <trans-unit id="7104f6c9a14d29e93513632fa9934f8edd1d6e95" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash</source>
          <target state="translated">NonZeroU32::hash</target>
        </trans-unit>
        <trans-unit id="ed57c71253659bc0210251e89d76fbd4f29b25de" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash_slice</source>
          <target state="translated">NonZeroU32::hash_slice</target>
        </trans-unit>
        <trans-unit id="708299fe453aae6d855b8d5980451e3d6fa01e3f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::into</source>
          <target state="translated">NonZeroU32::into</target>
        </trans-unit>
        <trans-unit id="18cade9c6a5784c63e5e9e3cd947c01187616ffa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::le</source>
          <target state="translated">NonZeroU32::le</target>
        </trans-unit>
        <trans-unit id="258acfab28050bc7bb168cbfd4ef30a6d48665c5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::lt</source>
          <target state="translated">NonZeroU32::lt</target>
        </trans-unit>
        <trans-unit id="030aea2e6963a8f4da13cbc262733cb19ce4afc3" translate="yes" xml:space="preserve">
          <source>NonZeroU32::max</source>
          <target state="translated">NonZeroU32::max</target>
        </trans-unit>
        <trans-unit id="ec7f1e7d4f631759d2fa095faa8ca43552f8684a" translate="yes" xml:space="preserve">
          <source>NonZeroU32::min</source>
          <target state="translated">NonZeroU32::min</target>
        </trans-unit>
        <trans-unit id="1339b30fe6c5981bffbab3f00e68cdd9c9f8a0bc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ne</source>
          <target state="translated">NonZeroU32::ne</target>
        </trans-unit>
        <trans-unit id="0d42ac2122a8ce6e542130048262c73787d65cfa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new</source>
          <target state="translated">NonZeroU32::new</target>
        </trans-unit>
        <trans-unit id="53b766be632e74846603297c0e0ac6f9ccfdb9cc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new_unchecked</source>
          <target state="translated">NonZeroU32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="8d058b61ea076257a2a74125c037a43db242bed9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::partial_cmp</source>
          <target state="translated">NonZeroU32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="daeb2592a753cbd5361feb58a583b78797b11fc9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_owned</source>
          <target state="translated">NonZeroU32::to_owned</target>
        </trans-unit>
        <trans-unit id="60aaf34cff920dc42256dc10eec23c5ea806feec" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_string</source>
          <target state="translated">NonZeroU32::to_string</target>
        </trans-unit>
        <trans-unit id="73f9e4f2ad5073070910a47ac63d54b649f8d6e8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_from</source>
          <target state="translated">NonZeroU32::try_from</target>
        </trans-unit>
        <trans-unit id="63d1c4723bc8f38b153bb0f2590c96abef27a5d0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_into</source>
          <target state="translated">NonZeroU32::try_into</target>
        </trans-unit>
        <trans-unit id="97923d854095a52b24576bacbd79fc9ba83145d4" translate="yes" xml:space="preserve">
          <source>NonZeroU32::type_id</source>
          <target state="translated">NonZeroU32::type_id</target>
        </trans-unit>
        <trans-unit id="ff9af574bd71ecdb8a94e5c11d8cb03c995c903e" translate="yes" xml:space="preserve">
          <source>NonZeroU64</source>
          <target state="translated">NonZeroU64</target>
        </trans-unit>
        <trans-unit id="9174928c781d84aa02c125b176a43aa320ff0a5d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow</source>
          <target state="translated">NonZeroU64::borrow</target>
        </trans-unit>
        <trans-unit id="84bb893e16a6e53a0c100c76ec3f68a95e3e668d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow_mut</source>
          <target state="translated">NonZeroU64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcf340d75d4265672f320969bda5046bdb409e81" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clamp</source>
          <target state="translated">NonZeroU64::clamp</target>
        </trans-unit>
        <trans-unit id="183552bd8482c37ff61fe2a742c9ddb1ea0ca355" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone</source>
          <target state="translated">NonZeroU64::clone</target>
        </trans-unit>
        <trans-unit id="0eb415342585f28f35047e6cd3c2974cdbbe66bd" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_from</source>
          <target state="translated">NonZeroU64::clone_from</target>
        </trans-unit>
        <trans-unit id="6ab29e679c166bbe4bda6532e91d9eeb91acad3c" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_into</source>
          <target state="translated">NonZeroU64::clone_into</target>
        </trans-unit>
        <trans-unit id="a63a17006148383604de4d3fcb995f84d18aaa77" translate="yes" xml:space="preserve">
          <source>NonZeroU64::cmp</source>
          <target state="translated">NonZeroU64::cmp</target>
        </trans-unit>
        <trans-unit id="9de4084186275b67715c01bdf2631108a20373b3" translate="yes" xml:space="preserve">
          <source>NonZeroU64::eq</source>
          <target state="translated">NonZeroU64::eq</target>
        </trans-unit>
        <trans-unit id="f701376286f75acabb93bc338425e6cae42fdba1" translate="yes" xml:space="preserve">
          <source>NonZeroU64::fmt</source>
          <target state="translated">NonZeroU64::fmt</target>
        </trans-unit>
        <trans-unit id="e6c78a21f2934d9a2da92dd578a35b8157419529" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from</source>
          <target state="translated">NonZeroU64::from</target>
        </trans-unit>
        <trans-unit id="546bd47a252bfe7b85af380602d87da22806650f" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from_str</source>
          <target state="translated">NonZeroU64::from_str</target>
        </trans-unit>
        <trans-unit id="9aadba2a2b721871fd6af482b4623eee945bd2ca" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ge</source>
          <target state="translated">NonZeroU64::ge</target>
        </trans-unit>
        <trans-unit id="23badb59c2bf64bbfd600b89c65d6464f288c34e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::get</source>
          <target state="translated">NonZeroU64::get</target>
        </trans-unit>
        <trans-unit id="70ba0bfc2ee5de3dc8d77e5c800ac26d942aad60" translate="yes" xml:space="preserve">
          <source>NonZeroU64::gt</source>
          <target state="translated">NonZeroU64::gt</target>
        </trans-unit>
        <trans-unit id="1be0d3fa424fa8f1c9033db1563822faa87d86bc" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash</source>
          <target state="translated">NonZeroU64::hash</target>
        </trans-unit>
        <trans-unit id="9ef89b20cd332d28440efb1ab8c800e464dbc0c5" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash_slice</source>
          <target state="translated">NonZeroU64::hash_slice</target>
        </trans-unit>
        <trans-unit id="9cf4c75c1bac7fde4346dcdbc35fda963e585282" translate="yes" xml:space="preserve">
          <source>NonZeroU64::into</source>
          <target state="translated">NonZeroU64::into</target>
        </trans-unit>
        <trans-unit id="7376c3fefec318f3031bdc950d6f8f2a3089d974" translate="yes" xml:space="preserve">
          <source>NonZeroU64::le</source>
          <target state="translated">NonZeroU64::le</target>
        </trans-unit>
        <trans-unit id="9c3837210065694f326259c4c009fcf151ab8938" translate="yes" xml:space="preserve">
          <source>NonZeroU64::lt</source>
          <target state="translated">NonZeroU64::lt</target>
        </trans-unit>
        <trans-unit id="e88a4e86bb9a247b011285115d5e4adc34155d05" translate="yes" xml:space="preserve">
          <source>NonZeroU64::max</source>
          <target state="translated">NonZeroU64::max</target>
        </trans-unit>
        <trans-unit id="3ca2447656d5c5bf7e39124b2a8d6630ff253464" translate="yes" xml:space="preserve">
          <source>NonZeroU64::min</source>
          <target state="translated">NonZeroU64::min</target>
        </trans-unit>
        <trans-unit id="bf2706867bfa59da3e12e574c1c7a042c0c7fa0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ne</source>
          <target state="translated">NonZeroU64::ne</target>
        </trans-unit>
        <trans-unit id="2fb761a04a1a28848d5bbb8c94562514f64738e6" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new</source>
          <target state="translated">NonZeroU64::new</target>
        </trans-unit>
        <trans-unit id="a84ebe37c16ccdf34c145d075dd2d1ae8e718fd7" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new_unchecked</source>
          <target state="translated">NonZeroU64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="424d3fd0d71ac1783106c5f073cedfafd2433e33" translate="yes" xml:space="preserve">
          <source>NonZeroU64::partial_cmp</source>
          <target state="translated">NonZeroU64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="689c6172e5e5fa7d743f6d9ea54feb2a2c45360e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_owned</source>
          <target state="translated">NonZeroU64::to_owned</target>
        </trans-unit>
        <trans-unit id="0f770ca97d17ac208580e4663b1cb35d1585cd0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_string</source>
          <target state="translated">NonZeroU64::to_string</target>
        </trans-unit>
        <trans-unit id="b3edffffa9ccb083ef6dc98f9a91d2ee62a6a140" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_from</source>
          <target state="translated">NonZeroU64::try_from</target>
        </trans-unit>
        <trans-unit id="2309bbba28296004c54d80642075d1ce6e4cf120" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_into</source>
          <target state="translated">NonZeroU64::try_into</target>
        </trans-unit>
        <trans-unit id="ddce3cce76f837592f485e87ab5ddde6cfce8cd0" translate="yes" xml:space="preserve">
          <source>NonZeroU64::type_id</source>
          <target state="translated">NonZeroU64::type_id</target>
        </trans-unit>
        <trans-unit id="93acae18872d78f1044f122c7fa386b8e0790d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8</source>
          <target state="translated">NonZeroU8</target>
        </trans-unit>
        <trans-unit id="6ff1a3cea907e661f3495c1cde07624988c92d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow</source>
          <target state="translated">NonZeroU8::borrow</target>
        </trans-unit>
        <trans-unit id="63abe3b6e90de29270a227a14eb1cd95090ba8b5" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow_mut</source>
          <target state="translated">NonZeroU8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="803a11a99b517fd90ac23a43eefbdfca5457f48a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clamp</source>
          <target state="translated">NonZeroU8::clamp</target>
        </trans-unit>
        <trans-unit id="5c11d86db1fbb6b9b9c0d8f7f4a28a4bf6afbb24" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone</source>
          <target state="translated">NonZeroU8::clone</target>
        </trans-unit>
        <trans-unit id="670ad8364fc1871b9629299e869bcbacc5da96b2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_from</source>
          <target state="translated">NonZeroU8::clone_from</target>
        </trans-unit>
        <trans-unit id="6c6784a6e074a57a017f865c39fe9469883e2de8" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_into</source>
          <target state="translated">NonZeroU8::clone_into</target>
        </trans-unit>
        <trans-unit id="693fb00ea40fa5aabc302b79d7c8e3718e6c8088" translate="yes" xml:space="preserve">
          <source>NonZeroU8::cmp</source>
          <target state="translated">NonZeroU8::cmp</target>
        </trans-unit>
        <trans-unit id="2158bd65bbc659ddb6d6412bd01916cb5d982ed3" translate="yes" xml:space="preserve">
          <source>NonZeroU8::eq</source>
          <target state="translated">NonZeroU8::eq</target>
        </trans-unit>
        <trans-unit id="3c80d10814d815cf1d99f1b13a12df65b0875877" translate="yes" xml:space="preserve">
          <source>NonZeroU8::fmt</source>
          <target state="translated">NonZeroU8::fmt</target>
        </trans-unit>
        <trans-unit id="7deaab84759c8ba54fbc5d91e72a59bd1aeb6577" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from</source>
          <target state="translated">NonZeroU8::from</target>
        </trans-unit>
        <trans-unit id="2756bc8cdd2a9198a79f5cf73b9e1d572f0f1491" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from_str</source>
          <target state="translated">NonZeroU8::from_str</target>
        </trans-unit>
        <trans-unit id="96e3274a26e461fa91c098ddcfa2558cac9c4747" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ge</source>
          <target state="translated">NonZeroU8::ge</target>
        </trans-unit>
        <trans-unit id="922117f87c8142145cb8b8abbabb7402b5e2bc53" translate="yes" xml:space="preserve">
          <source>NonZeroU8::get</source>
          <target state="translated">NonZeroU8::get</target>
        </trans-unit>
        <trans-unit id="9d9dcce691d917ac54e2661132eb0950cc45d9a7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::gt</source>
          <target state="translated">NonZeroU8::gt</target>
        </trans-unit>
        <trans-unit id="86ed98098229a654859aa731e5195157190e73cb" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash</source>
          <target state="translated">NonZeroU8::hash</target>
        </trans-unit>
        <trans-unit id="cb3adb90e777f04027a60a7879f9d135f08d1607" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash_slice</source>
          <target state="translated">NonZeroU8::hash_slice</target>
        </trans-unit>
        <trans-unit id="b79391b251df236d1d6289790b5260179dbdacc9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::into</source>
          <target state="translated">NonZeroU8::into</target>
        </trans-unit>
        <trans-unit id="349980dfec87decceb14ada089c45ad6b63c099a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::le</source>
          <target state="translated">NonZeroU8::le</target>
        </trans-unit>
        <trans-unit id="d736ad9511ba8ef5fa21ea6939ea1822c7d2dcb0" translate="yes" xml:space="preserve">
          <source>NonZeroU8::lt</source>
          <target state="translated">NonZeroU8::lt</target>
        </trans-unit>
        <trans-unit id="a284bcab69108d0fe7e56d5c4b3448e94a95b9b7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::max</source>
          <target state="translated">NonZeroU8::max</target>
        </trans-unit>
        <trans-unit id="5a9a87bf0c351a8fa498461781bb9417c3bc85f9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::min</source>
          <target state="translated">NonZeroU8::min</target>
        </trans-unit>
        <trans-unit id="950681f0c85136301d4d8bc7bd384530cbe0ad13" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ne</source>
          <target state="translated">NonZeroU8::ne</target>
        </trans-unit>
        <trans-unit id="32bcfbfa6acfd6ddd32e20022619e9223f40a94f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new</source>
          <target state="translated">NonZeroU8::new</target>
        </trans-unit>
        <trans-unit id="c65bae8471e01bcbc9a0141783aef01900f64a4c" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new_unchecked</source>
          <target state="translated">NonZeroU8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="60e3a745d7919f9cebc4387f60a9049fdd9960a9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::partial_cmp</source>
          <target state="translated">NonZeroU8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="814facf57cfd7397aa0ec4ff5934741dc1504d0a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_owned</source>
          <target state="translated">NonZeroU8::to_owned</target>
        </trans-unit>
        <trans-unit id="b5e9e73145a1a10790ac2c4b4ee56c85d1e6f97f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_string</source>
          <target state="translated">NonZeroU8::to_string</target>
        </trans-unit>
        <trans-unit id="2b735ce2d45697df8d25226cb8808f268d9dad27" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_from</source>
          <target state="translated">NonZeroU8::try_from</target>
        </trans-unit>
        <trans-unit id="2b02b5ef9beb40480c74f9952d3ce821f4d69911" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_into</source>
          <target state="translated">NonZeroU8::try_into</target>
        </trans-unit>
        <trans-unit id="8c0fc32ec166f66886b38f57ea7d3cb7a7835fe2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::type_id</source>
          <target state="translated">NonZeroU8::type_id</target>
        </trans-unit>
        <trans-unit id="b35788d3f6ffc592ab0774878cef29486e7e5bd4" translate="yes" xml:space="preserve">
          <source>NonZeroUsize</source>
          <target state="translated">NonZeroUsize</target>
        </trans-unit>
        <trans-unit id="c419d78f65ceafa9adf9a16c8a0459bf66be0bb0" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow</source>
          <target state="translated">NonZeroUsize::borrow</target>
        </trans-unit>
        <trans-unit id="c7ac97a8de687d7597163c213da2788ada2700d7" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow_mut</source>
          <target state="translated">NonZeroUsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d423dc3c41f93a9c06c0e4ce6ae7fc621e805056" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clamp</source>
          <target state="translated">NonZeroUsize::clamp</target>
        </trans-unit>
        <trans-unit id="47e7faa665db9da3adc8893ed9e5dcaa815fe4b2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone</source>
          <target state="translated">NonZeroUsize::clone</target>
        </trans-unit>
        <trans-unit id="cb938c36bd0b3049477f6ad99f18c0d0ed6bf26f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_from</source>
          <target state="translated">NonZeroUsize::clone_from</target>
        </trans-unit>
        <trans-unit id="030e5620dfbf55afbbfe2d9c96c1e322152959d2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_into</source>
          <target state="translated">NonZeroUsize::clone_into</target>
        </trans-unit>
        <trans-unit id="a38099d022e9104d990e7e4e2d00982504357f0e" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::cmp</source>
          <target state="translated">NonZeroUsize::cmp</target>
        </trans-unit>
        <trans-unit id="57469c189c9f0d01b944369669232584fcab48be" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::eq</source>
          <target state="translated">NonZeroUsize::eq</target>
        </trans-unit>
        <trans-unit id="a3e007978854dfec2ea17781a918799b74afb325" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::fmt</source>
          <target state="translated">NonZeroUsize::fmt</target>
        </trans-unit>
        <trans-unit id="f78a5853c07aa978500a70738e411232664860cc" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from</source>
          <target state="translated">NonZeroUsize::from</target>
        </trans-unit>
        <trans-unit id="7712061538648151dde34c4415be3b5d61f5877b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from_str</source>
          <target state="translated">NonZeroUsize::from_str</target>
        </trans-unit>
        <trans-unit id="f4728f09de22bd70d445970426411f10a0225b43" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ge</source>
          <target state="translated">NonZeroUsize::ge</target>
        </trans-unit>
        <trans-unit id="b1cdf6cf2409f8c0f48ff7b3ba56ccc5ce5115e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::get</source>
          <target state="translated">NonZeroUsize::get</target>
        </trans-unit>
        <trans-unit id="a20bd2dec9d5657f43798c2c990e62953392115c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::gt</source>
          <target state="translated">NonZeroUsize::gt</target>
        </trans-unit>
        <trans-unit id="801d8bc95574bf029e7d684d2cf3f771b60cd725" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash</source>
          <target state="translated">NonZeroUsize::hash</target>
        </trans-unit>
        <trans-unit id="6e0922eea57f8699c098adb3c035a1605d38f3df" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash_slice</source>
          <target state="translated">NonZeroUsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="fb7586f1fe5330ac7ebbf29da06f142f1a81f679" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::into</source>
          <target state="translated">NonZeroUsize::into</target>
        </trans-unit>
        <trans-unit id="2236d0a73fe65fdff9ad7360c0db597b0672828c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::le</source>
          <target state="translated">NonZeroUsize::le</target>
        </trans-unit>
        <trans-unit id="9347ed4b41dd70587e1703f7c2e07851b56cb2e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::lt</source>
          <target state="translated">NonZeroUsize::lt</target>
        </trans-unit>
        <trans-unit id="751ac4d697954b225e6f1616e4b4e0881bb6a41f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::max</source>
          <target state="translated">NonZeroUsize::max</target>
        </trans-unit>
        <trans-unit id="00f9ea1a8ab80868d5583ca29a5d8f2c152f6d4b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::min</source>
          <target state="translated">NonZeroUsize::min</target>
        </trans-unit>
        <trans-unit id="a3adc830a3d6e8e1f76b36c1da867853c22f3352" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ne</source>
          <target state="translated">NonZeroUsize::ne</target>
        </trans-unit>
        <trans-unit id="b482e2411d650436386f31aaaee9d529c27faf6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new</source>
          <target state="translated">NonZeroUsize::new</target>
        </trans-unit>
        <trans-unit id="0a63ca14c98c0ba3afecce88c1ee164dbbe678b5" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new_unchecked</source>
          <target state="translated">NonZeroUsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d2e829a9fc8b73a5ec3a806953ba65e782b63e4f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::partial_cmp</source>
          <target state="translated">NonZeroUsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="0fc32bf985ee7be65f7708751121df22adec3ee2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_owned</source>
          <target state="translated">NonZeroUsize::to_owned</target>
        </trans-unit>
        <trans-unit id="368109929572f9725530c9b5e66c0770d0254f6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_string</source>
          <target state="translated">NonZeroUsize::to_string</target>
        </trans-unit>
        <trans-unit id="87d57ca9ccbaaeab13b116376180c23efda524d3" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_from</source>
          <target state="translated">NonZeroUsize::try_from</target>
        </trans-unit>
        <trans-unit id="f36d6ccda72162b66595cff5afa6abcccb3ef47a" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_into</source>
          <target state="translated">NonZeroUsize::try_into</target>
        </trans-unit>
        <trans-unit id="661478a23cc64b875358e2c7f6262c9eb208bcf8" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::type_id</source>
          <target state="translated">NonZeroUsize::type_id</target>
        </trans-unit>
        <trans-unit id="36aa77cbc45a62a558a375b317bc9b3804badfce" translate="yes" xml:space="preserve">
          <source>NoneError</source>
          <target state="translated">NoneError</target>
        </trans-unit>
        <trans-unit id="8def7b12f8f65fd01050dafd05df50f8287c0655" translate="yes" xml:space="preserve">
          <source>NoneError::borrow</source>
          <target state="translated">NoneError::borrow</target>
        </trans-unit>
        <trans-unit id="411f23ffccc2c350e97a02f83bb00bb04a9c1832" translate="yes" xml:space="preserve">
          <source>NoneError::borrow_mut</source>
          <target state="translated">NoneError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a4d6154b1c340d1443c5a20d251329f398af2e11" translate="yes" xml:space="preserve">
          <source>NoneError::clamp</source>
          <target state="translated">NoneError::clamp</target>
        </trans-unit>
        <trans-unit id="555a6fa6139d1928ed4e7fa787af07b254f8f631" translate="yes" xml:space="preserve">
          <source>NoneError::clone</source>
          <target state="translated">NoneError::clone</target>
        </trans-unit>
        <trans-unit id="b7be3f1dfae027d0e36e44675d36fbd402d1e26e" translate="yes" xml:space="preserve">
          <source>NoneError::clone_from</source>
          <target state="translated">NoneError::clone_from</target>
        </trans-unit>
        <trans-unit id="dc67355563b52eb89e32ff38b5504d3dd52d77c9" translate="yes" xml:space="preserve">
          <source>NoneError::clone_into</source>
          <target state="translated">NoneError::clone_into</target>
        </trans-unit>
        <trans-unit id="65e99ec3e2a6e151575264b82499d7f2e38008ff" translate="yes" xml:space="preserve">
          <source>NoneError::cmp</source>
          <target state="translated">NoneError::cmp</target>
        </trans-unit>
        <trans-unit id="0611d16ae0dbf1df9ec05c20e45d31816b7a33e3" translate="yes" xml:space="preserve">
          <source>NoneError::eq</source>
          <target state="translated">NoneError::eq</target>
        </trans-unit>
        <trans-unit id="ddc77b796895a55df93a0b820a464b4aa338d41d" translate="yes" xml:space="preserve">
          <source>NoneError::fmt</source>
          <target state="translated">NoneError::fmt</target>
        </trans-unit>
        <trans-unit id="f69f3c5a7bc9e57ba1c80a5b7f03fced9bacf61f" translate="yes" xml:space="preserve">
          <source>NoneError::from</source>
          <target state="translated">NoneError::from</target>
        </trans-unit>
        <trans-unit id="ea4b13c4f12ac04af5fe2cbffa33fc963c8d5a26" translate="yes" xml:space="preserve">
          <source>NoneError::ge</source>
          <target state="translated">NoneError::ge</target>
        </trans-unit>
        <trans-unit id="80a0b1216e8cf201b9e9391df5c095172374f508" translate="yes" xml:space="preserve">
          <source>NoneError::gt</source>
          <target state="translated">NoneError::gt</target>
        </trans-unit>
        <trans-unit id="3cade823dfb903a695b6582abf8a0356daee7927" translate="yes" xml:space="preserve">
          <source>NoneError::hash</source>
          <target state="translated">NoneError::hash</target>
        </trans-unit>
        <trans-unit id="2c1acaeb04c59b2f4a9a10620721a7a1d4aa42f7" translate="yes" xml:space="preserve">
          <source>NoneError::hash_slice</source>
          <target state="translated">NoneError::hash_slice</target>
        </trans-unit>
        <trans-unit id="46b77ff1d8e23b12f242a6cf68b6e7dd11a9e430" translate="yes" xml:space="preserve">
          <source>NoneError::into</source>
          <target state="translated">NoneError::into</target>
        </trans-unit>
        <trans-unit id="ba9c0b7fd1b90ee18de8e25f5e5340671555fa67" translate="yes" xml:space="preserve">
          <source>NoneError::le</source>
          <target state="translated">NoneError::le</target>
        </trans-unit>
        <trans-unit id="41e697d230de0c7c6e3ccd553c26214e3ef30472" translate="yes" xml:space="preserve">
          <source>NoneError::lt</source>
          <target state="translated">NoneError::lt</target>
        </trans-unit>
        <trans-unit id="02bc1b16e164540afd825f0ab014879760deedcf" translate="yes" xml:space="preserve">
          <source>NoneError::max</source>
          <target state="translated">NoneError::max</target>
        </trans-unit>
        <trans-unit id="03ed85d18288e8c6efca69c28f3c605bc8004901" translate="yes" xml:space="preserve">
          <source>NoneError::min</source>
          <target state="translated">NoneError::min</target>
        </trans-unit>
        <trans-unit id="0cf87dcf59fc2d8f60cce9e0913e3c5ea01c71c6" translate="yes" xml:space="preserve">
          <source>NoneError::ne</source>
          <target state="translated">NoneError::ne</target>
        </trans-unit>
        <trans-unit id="88b27454a88f2b6d19dafb3a30b27e9e4799a66b" translate="yes" xml:space="preserve">
          <source>NoneError::partial_cmp</source>
          <target state="translated">NoneError::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d76800607ec208e0e9251b9a3a41ceabc49a331f" translate="yes" xml:space="preserve">
          <source>NoneError::to_owned</source>
          <target state="translated">NoneError::to_owned</target>
        </trans-unit>
        <trans-unit id="a3e3b0d2121e13d536f0151b0514e0d6c2c50efe" translate="yes" xml:space="preserve">
          <source>NoneError::try_from</source>
          <target state="translated">NoneError::try_from</target>
        </trans-unit>
        <trans-unit id="b6f9326f4f9275b1c9ee9bf38430eb240361bf0b" translate="yes" xml:space="preserve">
          <source>NoneError::try_into</source>
          <target state="translated">NoneError::try_into</target>
        </trans-unit>
        <trans-unit id="2ed007421edc30616530d31dc1a9b886d8f905b6" translate="yes" xml:space="preserve">
          <source>NoneError::type_id</source>
          <target state="translated">NoneError::type_id</target>
        </trans-unit>
        <trans-unit id="59bdf32f963e32403610f535ed38d94ab9fa57b3" translate="yes" xml:space="preserve">
          <source>Nonequality comparison</source>
          <target state="translated">无质量比较</target>
        </trans-unit>
        <trans-unit id="aa380f41959815056bfdd3029c1845bf486477df" translate="yes" xml:space="preserve">
          <source>Nor can you use direct field access to do field-by-field gradual initialization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19eddb0e70179b2e619be3068cd8376966632800" translate="yes" xml:space="preserve">
          <source>Nor will this:</source>
          <target state="translated">也不会这样。</target>
        </trans-unit>
        <trans-unit id="9b417a21d4e30df48f9cabc1eb07b9ff439a8913" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="translated">通常，在这里，人们会使用&lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;来正确删除内容，从而不会泄漏内存。</target>
        </trans-unit>
        <trans-unit id="5084dc27f957de7bc8c196b5f20cd9275d3c3a4f" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="7531cdd8037edc1069a4fd743641ffecf0edfa83" translate="yes" xml:space="preserve">
          <source>Not Equal</source>
          <target state="translated">不平等</target>
        </trans-unit>
        <trans-unit id="f8548a3657bfc32a33e876b215b140f301134c05" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN).</source>
          <target state="translated">不是一个数字(NaN)。</target>
        </trans-unit>
        <trans-unit id="d52a965ff185906c6e9fb5c36534475faa112b26" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NAN&quot;&gt;&lt;code&gt;f32::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd484bf7d113fac0a06fa50cec141b09e01e967e" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NAN&quot;&gt;&lt;code&gt;f64::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64507e89e4bdf04e8f9c77f8ac34253ff22412a5" translate="yes" xml:space="preserve">
          <source>Not all platforms that libstd compiles for support capturing backtraces. Some platforms simply do nothing when capturing a backtrace. To check whether the platform supports capturing backtraces you can consult the &lt;code&gt;BacktraceStatus&lt;/code&gt; enum as a result of &lt;code&gt;Backtrace::status&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736e9bdbdcdd4b04a6c46d181f239630b7b9a187" translate="yes" xml:space="preserve">
          <source>Not all uses of &lt;code&gt;unsafe&lt;/code&gt; are equivalent: some are here to mark the existence of a contract the programmer must check, others are to say &quot;I have checked the contract, go ahead and do this&quot;. The following &lt;a href=&quot;https://internals.rust-lang.org/t/what-does-unsafe-mean/6696&quot;&gt;discussion on Rust Internals&lt;/a&gt; has more in-depth explanations about this but here is a summary of the main points:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2508d67aae4fe16b65d89f08837d02c03c4df29" translate="yes" xml:space="preserve">
          <source>Not be &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13ee2c7e4ca985d57b930eb6ea7f0b33421d3e0" translate="yes" xml:space="preserve">
          <source>Not be infinite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="translated">不等于</target>
        </trans-unit>
        <trans-unit id="a2b674143c807a9d4d57ac721ad16bfa7f8e15e8" translate="yes" xml:space="preserve">
          <source>Not finding the pattern:</source>
          <target state="translated">没有找到模式。</target>
        </trans-unit>
        <trans-unit id="ba8cbd3db6c5866f33c337f17d9969faf64a68a8" translate="yes" xml:space="preserve">
          <source>Not have any type parameters (although lifetime parameters are allowed), and</source>
          <target state="translated">没有任何类型参数(虽然允许使用寿命参数),并且</target>
        </trans-unit>
        <trans-unit id="fcaef0deabf89559da493cc8fdbfb1b73c922bc5" translate="yes" xml:space="preserve">
          <source>Not having to worry about incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn&amp;rsquo;t an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, you &lt;em&gt;can&lt;/em&gt; safely assume that the value isn&amp;rsquo;t null. This was a deliberate design decision for Rust to limit null&amp;rsquo;s pervasiveness and increase the safety of Rust code.</source>
          <target state="translated">不必担心错误地假设非空值有助于您对代码更有信心。为了具有可能为空的值，您必须通过使该值的类型为 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 来显式选择加入。然后，当您使用该值时，要求您显式处理该值为null的情况。值的任何地方都不是 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ，您&lt;em&gt;可以&lt;/em&gt;放心地假定该值不为null。对于Rust来说，这是一个故意的设计决策，旨在限制null的普遍性并提高Rust代码的安全性。</target>
        </trans-unit>
        <trans-unit id="c51294854fb6314b2caed8c3d6d50e7adbd261e2" translate="yes" xml:space="preserve">
          <source>Not running destructors</source>
          <target state="translated">不运行析构器</target>
        </trans-unit>
        <trans-unit id="b24fd225d5f013f2fa70d00cf4c24dafb25feaf7" translate="yes" xml:space="preserve">
          <source>Not running destructors in Rust is safe even if it has a type that isn't &lt;code&gt;'static&lt;/code&gt;. &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt;&lt;/a&gt; provides a wrapper to prevent a variable or field from being dropped automatically.</source>
          <target state="translated">在Rust中不运行析构函数是安全的，即使其类型不是 &lt;code&gt;'static&lt;/code&gt; 。&lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt; &lt;/a&gt;提供了一个包装器，以防止变量或字段被自动删除。</target>
        </trans-unit>
        <trans-unit id="0c7cc856a7f3d9cb5a50a65d04097b3b7b8538aa" translate="yes" xml:space="preserve">
          <source>Not that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">并不是说如果初始值也是NaN,这个函数就会返回NaN。</target>
        </trans-unit>
        <trans-unit id="c78919f021b1d754a66fe9891819ec98d0a80ddf" translate="yes" xml:space="preserve">
          <source>Not::not</source>
          <target state="translated">Not::not</target>
        </trans-unit>
        <trans-unit id="67e3ba0677bb45d7937c81385c061373c31498a8" translate="yes" xml:space="preserve">
          <source>Notable exception is made for situations where any of the directories specified in the &lt;code&gt;path&lt;/code&gt; could not be created as it was being created concurrently. Such cases are considered to be successful. That is, calling &lt;code&gt;create_dir_all&lt;/code&gt; concurrently from multiple threads or processes is guaranteed not to fail due to a race condition with itself.</source>
          <target state="translated">对于在并发创建 &lt;code&gt;path&lt;/code&gt; 无法创建该目录中指定的任何目录的情况，则有一个例外。这种情况被认为是成功的。也就是说，确保从多个线程或进程并发调用 &lt;code&gt;create_dir_all&lt;/code&gt; 不会因自身的竞争条件而失败。</target>
        </trans-unit>
        <trans-unit id="23a734e9b17de37ddc28f39d989ac717c3bd9ad8" translate="yes" xml:space="preserve">
          <source>Notable features that const contexts have, but const fn haven't are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215a4bdf475a8ec68726e515897b581b10444b3f" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ [u8]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d369df1510ca517b58a49f8cd6e6bb0e489ca52a" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut F</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e37dfc133bc97ebdeab9c07032473d9272189b3" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut I</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb09acdfe424fff47bc90762c736658052520f0" translate="yes" xml:space="preserve">
          <source>Notable traits for Ancestors&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49884a82c86f5e2dcfd40b1838c34bab8f05e373" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunks&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd325ab96ff06257d643a3909af2cf159e2fa33" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunksMut&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4c4055a5d727f7480702b2cc7fa22ff495757b" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayWindows&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8627fe98c009205a399c633908682c9a3e1ee4d" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9870581aecb430500b110feb6009781a8a35709" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01102f0879a5c2ca5c62809ffff0c0b0bad939d6" translate="yes" xml:space="preserve">
          <source>Notable traits for BufReader&amp;lt;R&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcafa8b1481fa65c646affea37accfbcf24f6580" translate="yes" xml:space="preserve">
          <source>Notable traits for BufWriter&amp;lt;W&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e8f6f48862fb0efc8b91d4c920e5075c8f689b" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be95aee73944208a8cbfa7ffa1a48d80537a439d" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;R&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa0ca54ac23d2115ba17da930b0b2c7d22ecc0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425c2e101149bb0adbc3f3833b4e9a88563fb4a0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;A, B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7e1c82210baf0b46d0937fbf969162cf98c76c" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;T, U&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4d751abd8ab3ab6e55826ec326c6f4c431564f" translate="yes" xml:space="preserve">
          <source>Notable traits for CharIndices&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08171c5effb66b03601f395559057c5c02e5ba5f" translate="yes" xml:space="preserve">
          <source>Notable traits for Chars&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9df882063622aa637c014b3eaf06c558ffb8da5" translate="yes" xml:space="preserve">
          <source>Notable traits for Chunks&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e432bd66d3f874ed890c86d21283df436f2bbd0" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584a1b10a62ffb190941baeea973451d496428d5" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cc072812a01dbd66f6d2c5f3918fc1eecb2a25" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefa79cd49091a7a7a4ec1ce49b7dc2c3e8635da" translate="yes" xml:space="preserve">
          <source>Notable traits for Cloned&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1c1d71ecdd9048c788733f05c8ee9170150c39" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandArgs&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d93748b1b05464de3995712c8cd56c0fc09338" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandEnvs&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97de3ec8fdabeefc703a8e7d7547f9f3496a716" translate="yes" xml:space="preserve">
          <source>Notable traits for Components&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d315c976ebb90a2389ef7743e81e7feecc3a3a82" translate="yes" xml:space="preserve">
          <source>Notable traits for Copied&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf59bdb6fb943dc984c5feb9e03a98364bc20d8" translate="yes" xml:space="preserve">
          <source>Notable traits for Cursor&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59f29f61cd42c0f0ff909de6d45f9e90f184a20" translate="yes" xml:space="preserve">
          <source>Notable traits for Cycle&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53b4ea31bf598b85ea40c284bdb3c0198881f8c" translate="yes" xml:space="preserve">
          <source>Notable traits for DecodeUtf16&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5127544158054e8bfb051274dd2021f84d9c3e7" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49894b4bfbcd9313cd8e1fca37fff62b0d5fe327" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc7c96c5bc0e2db809df1de91687bd4053c4024" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c298a9ee76878fdf90e4aa0fdba569c9110023" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfff38769221a3bcf19fc3461189daa684992a6d" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958272eb22af639d41c1f50e43d47fb61a6b14ef" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daba3253b1d0ae9af8dc2745c8744b02b11222b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2385be6e59fcef027951939bd378844cfa66cc4e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, V, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830f76c13044b7581905cb940dcf417e291d507b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, T, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304a6f343623430e09952339820090a6a8ba207e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainSorted&amp;lt;'_, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac510d8e5089a326a2eb18feaee192a8adc0a137" translate="yes" xml:space="preserve">
          <source>Notable traits for Empty&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3573695011deffd446de805daa200465e4ba04e" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeUtf16&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43fb28465d3894c2c42629f7fcac035e497cddd" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeWide&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89d4ae7f36a369049ddb4e7f3c8216010d3419d" translate="yes" xml:space="preserve">
          <source>Notable traits for Enumerate&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3db15928fc8d95aa51b8ec8568ffb5eabd15ff" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8ea88e979fa0c14d5d9cdbbd9d161b88b39045" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098a62e8683b0a13c0908e723720ee9c6810fedc" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1190462f1941cfb82dacec2de3ad04f7c9541203" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac599426120513bc277a63e47f672a5774b2c3d2" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8024ca6f7e281ae2b2c49427386c5bf3564e02b9" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f685f90ec7f2abae36adf82f3e91f906928c37" translate="yes" xml:space="preserve">
          <source>Notable traits for File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c974ed1aff38ed15c92fd39174e5a139046f0e34" translate="yes" xml:space="preserve">
          <source>Notable traits for Filter&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0176f9f85bf66bf907565450c64018c10c6cb978" translate="yes" xml:space="preserve">
          <source>Notable traits for FilterMap&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcdf064b818fb335120a0a13f2aad0c77345394" translate="yes" xml:space="preserve">
          <source>Notable traits for FlatMap&amp;lt;I, U, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1073550fde927671db722e47a13215279dc8806e" translate="yes" xml:space="preserve">
          <source>Notable traits for Flatten&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bb84e817e2df7af3ebf4adf8af3eae4361fbed" translate="yes" xml:space="preserve">
          <source>Notable traits for FromFn&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab5351ad5f13713d82cab1221966fc7e75e9d94" translate="yes" xml:space="preserve">
          <source>Notable traits for Fuse&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b96e5efed1886b8e4bb59473b0f591f83aa189" translate="yes" xml:space="preserve">
          <source>Notable traits for Incoming&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f0a4d3c756c850a0608c731279e5ac5c5ca49c" translate="yes" xml:space="preserve">
          <source>Notable traits for Inspect&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f01a7c49836f7656e92d546f4185d1aefd357b8" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20846e5c04b975b9bee849726ac0019c4f7b197d" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4917b9b001be9af84b1ad65c2d45310be0927721" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1104b62a63a5899e12eeb37d5678f9df68b057f0" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b19c0d62a927883656bbd747f944a9ce1ae1de8" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5480768feb968b4174c1ae6ddf0dcc0e359f66ea" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3722bff12524c5b2d2d05cda59ba23d190ce3bfe" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2d3479bd2162e028960fa1d767fb2598f2f013" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIterSorted&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad4c5fe36c7d254f4808dae95121b2bb0b54801" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoKeys&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da31fc5c3cf56bab8c815369c2547a6911c833ba" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoValues&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80895d49113bdb3cb86cfb4506bc6ebd9cd990ad" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ae4aeecd3653ca01fd74624e132869451eaf4" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5c2ab959e5631dfaa0a10009806935497b8c43" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3bc881963ccadbe18c6746d9bbee3015f5abf1" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b543ae90963f05f96f4dd377980b1713d5159b" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b070bfb60176569efaa6c1a4d324dc380b18332" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c915012f89d1a99c63f545f2ebffcef019fb4f2d" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7bfb298a8fa281946d7580611e184273523102f" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5811113cb7885323072cf61d5667a2b362dde2" translate="yes" xml:space="preserve">
          <source>Notable traits for Keys&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c669d87d53a9eb6f676c0605066d307d9e6144" translate="yes" xml:space="preserve">
          <source>Notable traits for LineWriter&amp;lt;W&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6228658663ccbd3f41a5107629651e3c2771c99b" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9213f8c618faa944ed6f22753d61edcc9d4ecdf2" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a5e49b0d0ee24c230282dd8f08580ff2f4ffb7" translate="yes" xml:space="preserve">
          <source>Notable traits for LinesAny&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99d80dc293caeb573cce051072ed906b6f15c5e" translate="yes" xml:space="preserve">
          <source>Notable traits for Map&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172f87d0793ddf7da88be709a2311741cbd4b363" translate="yes" xml:space="preserve">
          <source>Notable traits for MapWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64729c888eeabe7cf12e1842e01480ed82b337ff" translate="yes" xml:space="preserve">
          <source>Notable traits for MatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2b75e66e9e050b8169e3218de5ee791479721" translate="yes" xml:space="preserve">
          <source>Notable traits for Matches&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae519d64a28536d279768ad769256299621686" translate="yes" xml:space="preserve">
          <source>Notable traits for Once&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b307122c682ff77253a547508bfd2ee6faae04" translate="yes" xml:space="preserve">
          <source>Notable traits for OnceWith&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7b3a034e2d225ecfcc33f32f2f83f5b7d3d90b" translate="yes" xml:space="preserve">
          <source>Notable traits for Peekable&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8f81a496f377f17826b87b054d41b9d3f6cb71" translate="yes" xml:space="preserve">
          <source>Notable traits for Pending&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74be0fa24b2449c87cf0033da73af99abb038226" translate="yes" xml:space="preserve">
          <source>Notable traits for Pin&amp;lt;P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6ce59e954214088a5388d7abe14ace680afd30" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunks&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0549023d3e07da72d7eaec8fd8c7d3b1bfc8bb" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1891d732a25cb1a2d6470e2f1e61d90d79932069" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272511b477fb6f4d7e66f455a8927b6aa68fd2ce" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc67e64b7ea3bfd3fc10ece7ec2491353da6e9d" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7b6da19243fedcfa70bfd82f4cf8717d322f80" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatches&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa09ee60858aa32b9e0f1689cc4891931af0d24" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fe88a7318fe9810ff3810f98339d43244a6877" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70be06d4120000b8b8b94371aec7e2580c6b381b" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b31a8c9c6cb2046e7ec9e536ce72d0609e4c5c4" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19040f24ad7c9687e49caaeab46d848dc263b5ea" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1988fde6a09875d4b04a7b9e55d197b9d9a90765" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907edfb9c1524174e07ccbc24ecb37a8cbb06d65" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9198631706611f9de2afa1f3a5e4389cd7cb8e7a" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3fe2b23ebaced9425f58daf076814b8c0291d9" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0614892f74433d616b37d2ae04d67fe7f14ad105" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beebcbfc8cc5133e5166a3028ebbd90ecdb7055f" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeFrom&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f744d9434a4d9b5c37c99f5c97d2b2cc90b13077" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeInclusive&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4e925f094b7a69f246e42e8b50c5128f8129c7" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd184a89bc10bea6baedba72d627209bea1056f" translate="yes" xml:space="preserve">
          <source>Notable traits for Ready&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64702f1280547e388d11ff5ae890bb729b733d36" translate="yes" xml:space="preserve">
          <source>Notable traits for Repeat&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a3b2a3770cc905b8da25f64e140b4ab80c6ffe" translate="yes" xml:space="preserve">
          <source>Notable traits for RepeatWith&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ad194cda463ad2c6dd1506daf0367114be5c8e" translate="yes" xml:space="preserve">
          <source>Notable traits for Rev&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff8f63be235b7ea2055383c2e9b72b84c7bd07e" translate="yes" xml:space="preserve">
          <source>Notable traits for Scan&amp;lt;I, St, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d073dbfe88a46f9a5d9a064d7c96c1a9ddbdb" translate="yes" xml:space="preserve">
          <source>Notable traits for Skip&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0eaba444b8b7b51819626fe7d8a57f993cdf9a" translate="yes" xml:space="preserve">
          <source>Notable traits for SkipWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8f82912aa693cda641dbb9a8f2619f7e15ddea" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef399e09acd6419098e7cfcabf45df6744dbfbc6" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f967c2a861c03dbdc5cf356551e97bb60b084f" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a8c3f513e0738a443ac406858d3b7bc026953" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d5f710d040b4a11a5d716baa68dcf2d617217b" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitAsciiWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7865e840a56b3e0895b5ec1bdbc829b951351d" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusive&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9818f4f1fdfe2d933ac6655c5c4953e8aff5a7e1" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusiveMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0838dd01ca950ce33cd2058b8d0ff4fd43821113" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5880f295f9b58cf5125e602e8fae3c01c02bfbe" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7599a2d009c0938be30293d468e1a75ce65377d5" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e0cb911750681c09ba0b190a9557e42adc2590" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48dc2915683e916503c8dcf3e59f491126656bf" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d707147c6fab5cc551e32ce5467c609e374e4f50" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437caeb56851568308dca5cb78609789356f0853" translate="yes" xml:space="preserve">
          <source>Notable traits for StderrLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c194fa1f0bd2541f390bd24896165b0c23c7e5" translate="yes" xml:space="preserve">
          <source>Notable traits for StdinLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee33f3797cb0a601933ebede73fe50f827c75b6e" translate="yes" xml:space="preserve">
          <source>Notable traits for StdoutLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0ae991bfa5ac7c9c453dec86d28b7d72d47073" translate="yes" xml:space="preserve">
          <source>Notable traits for StepBy&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f5fe0a710de90155479f39d5f77c153488c0a5" translate="yes" xml:space="preserve">
          <source>Notable traits for Successors&amp;lt;T, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647ebf3b1fc10e80b4ce476f35a75fa114a5fab1" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0deb017937ef51088c94bb895f3902110ffe16" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b271862886a9e625b5ac46fc4e49bcce91334f9" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1491004df1c3cd73af985e7889ffe06072d374" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c484c47892ef31d80e9449405b6a45f7812a953" translate="yes" xml:space="preserve">
          <source>Notable traits for TakeWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce43b5e8ae4c3d3abba449747c3b74da4e5cf5b2" translate="yes" xml:space="preserve">
          <source>Notable traits for TcpStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1590902cedb9997418d686f3b41f48a7faa5a8" translate="yes" xml:space="preserve">
          <source>Notable traits for ToLowercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cea9ba6a0245158a668390fdcdb390b3ee3a95" translate="yes" xml:space="preserve">
          <source>Notable traits for ToUppercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc316517c095ef6246876fb36dafafef8842df0" translate="yes" xml:space="preserve">
          <source>Notable traits for TryIter&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cd3ac7d99db311332b377e21251e4fba5322ec" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1623bf8aee40498694e04160abcc7cc94e51160" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fbaa40eb7f00c2be283feaa1fbb38e29701e83" translate="yes" xml:space="preserve">
          <source>Notable traits for UnixStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c50d1662883c24d433db05a688c0aa44526ac2e" translate="yes" xml:space="preserve">
          <source>Notable traits for Values&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c872469ad3d287548b76d4b848eba9a4a4c7d9" translate="yes" xml:space="preserve">
          <source>Notable traits for ValuesMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34aac67be859564d9e8c0c60e00e2a029f471028" translate="yes" xml:space="preserve">
          <source>Notable traits for Vec&amp;lt;u8&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1ce7df300d5a68156470029c1320d12946032a" translate="yes" xml:space="preserve">
          <source>Notable traits for Windows&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ed148e4a8689fea1373b25b6f60ce6eb17047c" translate="yes" xml:space="preserve">
          <source>Notable traits for Zip&amp;lt;A, B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">值得注意的是，此函数忽略 &lt;code&gt;flag&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">值得注意的是：&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;，函数参数，&lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt;和&lt;a href=&quot;items/static-items&quot;&gt;静态&lt;/a&gt;项必须调整 &lt;code&gt;Sized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">注1:即使迭代器直到最后才被消耗,元素范围也会被删除。</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">注1:即使迭代器只消耗了一部分或根本没有消耗,元素范围也会被删除。</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">注1:无论给定的步长是多少,迭代器的第一个元素都会被返回。</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">注意2：如果 &lt;code&gt;Drain&lt;/code&gt; 值没有下降，但保留的借用到期（例如由于 &lt;code&gt;mem::forget&lt;/code&gt; ），则未指定从双端队列中删除了多少个元素。</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">注2：如果 &lt;code&gt;Drain&lt;/code&gt; 值泄漏，则从向量中删除了多少个元素（未指定）。</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">注2：拉出被忽略元素的时间不固定。 &lt;code&gt;StepBy&lt;/code&gt; 的行为类似于序列 &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; ，但是也可以自由地表现为序列 &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; 哪种方式可以由于性能原因，需要对某些迭代器进行更改。第二种方法将使迭代器更早地进行，并可能消耗更多的项。</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">还要注意，在清单19-1和19-3中，我们创建了 &lt;code&gt;*const i32&lt;/code&gt; 和 &lt;code&gt;*mut i32&lt;/code&gt; 原始指针，它们都指向相同的内存位置（存储 &lt;code&gt;num&lt;/code&gt; ）。如果改为尝试创建对 &lt;code&gt;num&lt;/code&gt; 的不可变且可变的引用，则代码将无法编译，因为Rust的所有权规则不允许与任何不可变的引用同时使用可变的引用。使用原始指针，我们可以创建指向相同位置的可变指针和不可变指针，并通过可变指针更改数据，从而潜在地造成数据竞争。小心！</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">还要注意，在这种形式主义的上下文中，术语&amp;ldquo;令牌&amp;rdquo;通常&lt;em&gt;包括&lt;/em&gt;简单的NT。</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">但请注意:</target>
        </trans-unit>
        <trans-unit id="ac8dc1e3e610d665d4339a3068108ed3e4e3d7f2" translate="yes" xml:space="preserve">
          <source>Note however, that &lt;code&gt;black_box&lt;/code&gt; is only (and can only be) provided on a &quot;best-effort&quot; basis. The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used. Programs cannot rely on &lt;code&gt;black_box&lt;/code&gt; for &lt;em&gt;correctness&lt;/em&gt; in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">关于地域的说明</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">请注意，＆Any仅限于测试值是否为指定的具体类型，而不能用于测试类型是否实现了特征。</target>
        </trans-unit>
        <trans-unit id="57e530ae79447e200db1291082ac88c201431874" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; already performs this check, so if your workload can be reduced to some small number of &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; calls, using this is unnecessary. In particular note that you can &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">注意，例如使用此原语实现&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;。确实，当您调用 &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;recv&lt;/code&gt; 时，它们阻塞了，如果通道不可用，它们会产生作用。</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">请注意，&lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; &lt;/a&gt;实现&lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; ,&lt;/a&gt;而&lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt;实现&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cb54b0f71bbcbfc437ecfe318e92da06296ef44e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">请注意， &lt;code&gt;(T,)&lt;/code&gt; 始终表示包含 &lt;code&gt;T&lt;/code&gt; 型元素的1元组的类型。逗号对于语法消除歧义是必要的。</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">请注意， &lt;code&gt;CoerceUnsized&lt;/code&gt; 主要由 &lt;code&gt;Box&lt;/code&gt; ， &lt;code&gt;Rc&lt;/code&gt; 和 &lt;code&gt;Arc&lt;/code&gt; 等智能指针使用，以便能够标记它们可以强制其指向的非大小类型。</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">请注意， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 仅用于单线程方案。在第16章讨论并发时，我们将介绍如何在多线程程序中进行引用计数。</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">请注意，默认情况下 &lt;code&gt;Rhs&lt;/code&gt; 为 &lt;code&gt;Self&lt;/code&gt; ，但这不是强制性的。</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">请注意，默认情况下 &lt;code&gt;Rhs&lt;/code&gt; 为 &lt;code&gt;Self&lt;/code&gt; ，但这不是强制性的。例如，&lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; ，它允许以 &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; 的形式进行操作。</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">请注意，默认情况下 &lt;code&gt;Rhs&lt;/code&gt; 为 &lt;code&gt;Self&lt;/code&gt; ，但这不是强制性的。例如，&lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; ，它允许以 &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; 的形式进行操作。</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">请注意， &lt;code&gt;T&lt;/code&gt; 不一定实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，因此它甚至无法克隆并重置 &lt;code&gt;self.buf&lt;/code&gt; 。但 &lt;code&gt;replace&lt;/code&gt; 可以用来撇清原值 &lt;code&gt;self.buf&lt;/code&gt; 从 &lt;code&gt;self&lt;/code&gt; ，允许其返回：</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">请注意， &lt;code&gt;T&lt;/code&gt; 不一定实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，因此它甚至无法克隆并重置 &lt;code&gt;self.buf&lt;/code&gt; 。但 &lt;code&gt;take&lt;/code&gt; 可以用来撇清原值 &lt;code&gt;self.buf&lt;/code&gt; 从 &lt;code&gt;self&lt;/code&gt; ，允许其返回：</target>
        </trans-unit>
        <trans-unit id="ac00b6421a53f1cb355d37f763df7d0ab6908815" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so we can't even clone &lt;code&gt;self.buf[i]&lt;/code&gt; to avoid the move. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value at that index from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7210db58c23cf5014deeb9448717499ab480d12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt;; this is the case when it would require more than &lt;code&gt;usize::MAX&lt;/code&gt; steps to get to &lt;code&gt;b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">请注意， &lt;code&gt;drain_filter&lt;/code&gt; 还允许您更改过滤器闭包中的每个元素，无论您选择保留还是删除它。</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">请注意， &lt;code&gt;drain_filter&lt;/code&gt; 允许您更改过滤器闭包中的每个元素，无论您选择保留还是删除它。</target>
        </trans-unit>
        <trans-unit id="5c2297eec650eb177080c75bea870e375a760bc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900305edc91345ae356f030caba1b6142733f009" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d482051dadae6146f69f3e213d64c34dd92558" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.find(f)&lt;/code&gt; is equivalent to &lt;code&gt;iter.filter(f).next()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">请注意， &lt;code&gt;ptr::drop_in_place&lt;/code&gt; 已经执行了此检查，因此如果可以将您的工作量减少到少量的drop_in_place调用，则无需使用此功能。特别要注意的是，您可以drop_in_place一个slice，这将对所有值进行单个需求检查。</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">请注意， &lt;code&gt;query&lt;/code&gt; 现在是 &lt;code&gt;String&lt;/code&gt; 而不是字符串切片，因为调用 &lt;code&gt;to_lowercase&lt;/code&gt; 会创建新数据，而不是引用现有数据。假设查询为 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; ，例如：该字符串切片不包含小写字母 &lt;code&gt;u&lt;/code&gt; 或 &lt;code&gt;t&lt;/code&gt; 供我们使用，因此我们必须分配一个包含 &lt;code&gt;&quot;rust&quot;&lt;/code&gt; 的新 &lt;code&gt;String&lt;/code&gt; 。现在，当将 &lt;code&gt;query&lt;/code&gt; 作为参数传递给 &lt;code&gt;contains&lt;/code&gt; 方法时，我们需要添加一个＆符，因为 &lt;code&gt;contains&lt;/code&gt; 的签名定义为采用字符串切片。</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">请注意，如果任何参数包含无效的Unicode ，则 &lt;code&gt;std::env::args&lt;/code&gt; 将惊慌。如果您的程序需要接受包含无效Unicode的参数，请改用 &lt;code&gt;std::env::args_os&lt;/code&gt; 。该函数返回一个生成 &lt;code&gt;OsString&lt;/code&gt; 值而不是 &lt;code&gt;String&lt;/code&gt; 值的迭代器。为了简单起见，我们选择在这里使用 &lt;code&gt;std::env::args&lt;/code&gt; ，因为 &lt;code&gt;OsString&lt;/code&gt; 值在每个平台上都不同，并且比 &lt;code&gt;String&lt;/code&gt; 值更复杂。</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;zip&lt;/code&gt; 仅产生四对。理论上不会产生第五对 &lt;code&gt;(5, None)&lt;/code&gt; ，因为当 &lt;code&gt;zip&lt;/code&gt; 的任何一个输入迭代器返回 &lt;code&gt;None&lt;/code&gt; 时，zip返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">请注意,Rust没有可选函数参数或变量函数的概念(除了它的C-FFI)。</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">请注意,&quot;尽最大的努力 &quot;来确保存储在线程本地存储中的类型的destructor被运行,但并不是所有的平台都能保证线程本地存储中的所有类型都能运行destructor。例如,有一些已知的注意事项,在这些情况下,destructor不会被运行。</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">请注意， &lt;code&gt;()&lt;/code&gt; -返回 &lt;code&gt;main&lt;/code&gt; 隐式导致成功终止，因此除非您还返回其他可能的代码，否则无需从 &lt;code&gt;main&lt;/code&gt; 返回此函数。</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">请注意,捕获会移动或借用一个变量,但在这种情况下,闭包是借用变量。关于捕捉的更多信息,请看http://rustbyexample.com/fn/closures/capture.html。</target>
        </trans-unit>
        <trans-unit id="d28236ceeda3d941466d94520f9be31d9496ffc8" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;Capturing&lt;/a&gt; in Rust By Example for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">请注意，匹配器只是令牌树。如上所述，&amp;ldquo;简单NT&amp;rdquo;是元变量NT；因此，这是不可重复的。例如， &lt;code&gt;$foo:ty&lt;/code&gt; 是一个简单的NT，但是 &lt;code&gt;$($foo:ty)+&lt;/code&gt; 是一个复杂的NT。</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">请注意，引用的范围从引入它的地方开始，一直持续到最后一次使用该引用。例如，此代码将被编译，因为不可变引用的最后一次使用发生在引入可变引用之前：</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">请注意，如果此通道上有缓冲区，则成功发送并&lt;em&gt;不能&lt;/em&gt;保证接收方会看到数据。可以将项目排队在内部缓冲区中，以供接收者以后接收。但是，如果缓冲区大小为0，则该通道成为会合通道，并且如果此函数返回成功，则可以保证接收方确实已接收到数据。</target>
        </trans-unit>
        <trans-unit id="1f0335bd5206c4df046874965f0d18fc2183ed51" translate="yes" xml:space="preserve">
          <source>Note that accessing the value inside a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; is safe. This means that a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; whose content has been dropped must not be exposed through a public safe API. Correspondingly, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; is unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5885b8aa2d181f8795166dedd7f6344e9a60f6b3" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">请注意，某些类型可能无法实现对齐。特别是，它通常不是针对 &lt;code&gt;Debug&lt;/code&gt; 特性实现的。确保应用填充的一种好方法是格式化输入，然后使用该结果字符串填充输出。</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">请注意，所有&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;都是有效的&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;，可以使用 &lt;code&gt;as&lt;/code&gt; 强制转换为一个：</target>
        </trans-unit>
        <trans-unit id="516c2ce158a14ccb1ab369bf0a62cbade5443e81" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;char&lt;/code&gt;s are valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">请注意，将使用end和返回元素之间的所有元素，包括返回元素。这也意味着在同一迭代器上多次调用 &lt;code&gt;nth_back(0)&lt;/code&gt; 将返回不同的元素。</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">请注意，所有先前的元素以及返回的元素都将从迭代器中使用。这意味着前面的元素将被丢弃，并且在同一迭代器上多次调用 &lt;code&gt;nth(0)&lt;/code&gt; 将返回不同的元素。</target>
        </trans-unit>
        <trans-unit id="491da8d1616c74f297c93c3f76ed9c42830ffa59" translate="yes" xml:space="preserve">
          <source>Note that any code in earlier iterations of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">请注意，即使更新了所用的Rust编译器版本，已编译&lt;em&gt;的Rust编程语言的&lt;/em&gt; &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 印刷中&lt;em&gt;的&lt;/em&gt;所有代码也将继续编译，而无需在项目的&lt;em&gt;Cargo.toml中&lt;/em&gt;使用version =&amp;ldquo; 2018&amp;rdquo;进行编译。这就是Rust的向后兼容性保证！</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">请注意,内部缓冲区的任何剩余数据都会丢失。</target>
        </trans-unit>
        <trans-unit id="2a041883f7bee5eb6e6f55708c727c8ab3a3ed00" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost. Therefore, a following read from the underlying reader may lead to data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">需要注意的是,由于这个函数永不返回,而且它终止了进程,所以不会运行当前堆栈或任何其他线程堆栈上的析构函数。</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">需要注意的是,由于这个函数永远不会返回,而且它终止了进程,所以不会运行当前堆栈或任何其他线程堆栈上的析构函数。如果需要干净的关机,建议只在一个已知的点上调用这个函数,在这个点上没有更多的destructors可以运行。</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">请注意，由于我们在清单10-13 中的相同&lt;em&gt;lib.rs&lt;/em&gt;中定义了 &lt;code&gt;Summary&lt;/code&gt; trait以及 &lt;code&gt;NewsArticle&lt;/code&gt; 和 &lt;code&gt;Tweet&lt;/code&gt; 类型，因此它们都在同一范围内。假设此&lt;em&gt;lib.rs&lt;/em&gt;用于我们称为 &lt;code&gt;aggregator&lt;/code&gt; 的板条箱，并且其他人希望使用板条箱的功能在其库范围内定义的结构上实现 &lt;code&gt;Summary&lt;/code&gt; 特性。他们将需要首先将特征纳入自己的范围。他们可以通过指定 &lt;code&gt;use aggregator::Summary;&lt;/code&gt; ，这将使他们能够为其类型实现 &lt;code&gt;Summary&lt;/code&gt; 。本 &lt;code&gt;Summary&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;trait还需要成为另一个板条箱实现的公共特征，这是因为在清单10-12中，我们将 &lt;code&gt;pub&lt;/code&gt; 关键字放在 &lt;code&gt;trait&lt;/code&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">请注意，因为我们只用一个泛型类型定义 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; ，这个定义说， &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 结构是通过某种类型的通用 &lt;code&gt;T&lt;/code&gt; ，而字段 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是&lt;em&gt;两个&lt;/em&gt;同类型的，无论该类型也许。如果我们创建一个 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 的实例，该实例具有不同类型的值，如清单10-7所示，我们的代码将无法编译。</target>
        </trans-unit>
        <trans-unit id="ee83d2a98a726eb4d0819a08ff35a51d203bcc33" translate="yes" xml:space="preserve">
          <source>Note that capturing a backtrace can be an expensive operation on some platforms, so this should be used with caution in performance-sensitive parts of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">请注意，删除 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 将永远不会调用 &lt;code&gt;T&lt;/code&gt; 的删除代码。如果初始化了 &lt;code&gt;T&lt;/code&gt; ，则有责任确保将其删除。</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">注意，由于方法调用deref强制，简单地调用trait方法将像它们对引用一样起作用，对它们所拥有的值也起作用！这里描述的实现是针对通用上下文的，其中最终类型 &lt;code&gt;T&lt;/code&gt; 是类型参数或本地未知。</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">请注意，空数组 &lt;code&gt;[T; 0]&lt;/code&gt; 与元素类型 &lt;code&gt;T&lt;/code&gt; 具有相同的对齐要求。另请注意，即使零号类型的对齐方式小于或等于数据字段的对齐方式，也会保守地报告该错误。</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">请注意,环境变量名在Windows上不区分大小写(但保留大小写),在其他平台上则区分大小写。</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">请注意，即使 &lt;code&gt;T&lt;/code&gt; 的大小为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL并正确对齐。</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">请注意，即使 &lt;code&gt;T&lt;/code&gt; 的大小为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL。</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">请注意，即使 &lt;code&gt;T&lt;/code&gt; 的大小为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL并正确对齐。</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">请注意，即使有效复制的大小（ &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ）为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL并且正确对齐。</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">请注意，即使有效复制的大小（ &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ）为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL并且正确对齐。</target>
        </trans-unit>
        <trans-unit id="6c1ad3562574888b0c8c8e999ed33eff7030ffcd" translate="yes" xml:space="preserve">
          <source>Note that even if this panics, the value is considered to be dropped; you must not cause &lt;code&gt;drop&lt;/code&gt; to be called again. This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;ptr::drop_in_place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">请注意，即使标准库包含 &lt;code&gt;IpAddr&lt;/code&gt; 的定义，我们仍然可以创建和使用自己的定义而不会发生冲突，因为我们尚未将标准库的定义引入我们的范围。我们将在第7章中进一步讨论将类型纳入范围。</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">请注意，可能会添加将来的平台，这些平台也不支持某些原子操作。最大程度的可移植代码将要小心使用哪种原子类型。 &lt;code&gt;AtomicUsize&lt;/code&gt; 和 &lt;code&gt;AtomicIsize&lt;/code&gt; 通常是最可移植的，但即使在那时，它们也并非随处可用。作为参考， &lt;code&gt;std&lt;/code&gt; 库需要指针大小的原子，尽管 &lt;code&gt;core&lt;/code&gt; 不需要。</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">请注意，枚举变量构造函数的通用参数位于变量之后，而不位于枚举之后。例如，您将编写 &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; ，而不是 &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">请注意，这里的&lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;调用是为了清楚起见-表示我们已经完成了给定值，应该销毁它。</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">请注意，如果 &lt;code&gt;Self::Item&lt;/code&gt; 仅是 &lt;code&gt;PartialOrd&lt;/code&gt; ，而不是 &lt;code&gt;Ord&lt;/code&gt; ，则上述定义意味着，如果任意两个连续的项都不可比，则此函数返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">请注意，如果 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 都指向同一个文件，那么该文件将有可能获得通过此操作截断。</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">请注意,如果一个函数接受多个类型参数,但你想让编译器推断出其中的一些参数,你可以使用类型占位符。</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">请注意，如果 &lt;code&gt;static&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 项包含函数或闭包引用，而它们本身也包含引用，则编译器将首先尝试标准省略规则。如果它无法通过其通常的规则来解决生存期，那么它将出错。举例来说：</target>
        </trans-unit>
        <trans-unit id="9ef199153d75a42174c42cff6fb7c6c1476957fd" translate="yes" xml:space="preserve">
          <source>Note that implementations do not necessarily have to provide access to the inner-most source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part of the pipeline and expose its internal storage as source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">需要注意的是,在Rust中,只有当包含非大小类型的字段是结构中最后且唯一的非大小类型字段时,结构才能包含非大小类型。</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">请注意，在某些语言和测试框架中，断言两个值相等的函数的参数称为 &lt;code&gt;expected&lt;/code&gt; 和 &lt;code&gt;actual&lt;/code&gt; ，而指定参数的顺序很重要。但是，在Rust中，它们分别称为 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; ，我们指定期望值的顺序与被测试代码产生的值无关紧要。我们可以在此测试中将断言写为 &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; ，这将导致一条失败消息，显示 &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; ，而 &lt;code&gt;left&lt;/code&gt; 为 &lt;code&gt;5&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; 为 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">请注意，引入另一个 &lt;code&gt;struct&lt;/code&gt; 只是为了在其他属性中占一席之地，可能会对表示形式产生意想不到的副作用：</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">请注意,不可能将本地动态依赖链接到静态库,在这种情况下,所有未链接的本地动态依赖将被打印出警告。</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">注意，不可能从相同方法的重写实现中调用默认实现。</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">请注意,一个流的长度可能会随着时间的推移而改变(例如,当数据被附加到一个文件时)。所以多次调用这个方法不一定每次都返回相同的长度。</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">注意,否定任何正整数都会溢出。</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">请注意，没有其他标准化发生。特别是， &lt;code&gt;a/c&lt;/code&gt; 和 &lt;code&gt;a/b/../c&lt;/code&gt; 是不同的，以考虑 &lt;code&gt;b&lt;/code&gt; 是符号链接（因此其父级不是 &lt;code&gt;a&lt;/code&gt; ）的可能性。</target>
        </trans-unit>
        <trans-unit id="0f36d8aec30ccdcaddeba64d187fcf335e3e550e" translate="yes" xml:space="preserve">
          <source>Note that not all errors contain a &lt;code&gt;Backtrace&lt;/code&gt;. Also note that a &lt;code&gt;Backtrace&lt;/code&gt; may actually be empty. For more information consult the &lt;code&gt;Backtrace&lt;/code&gt; type itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">请注意，并非所有平台都将在文件的元数据中保留此字段的更新，例如Windows可以选择在访问文件时禁用此更新，而Linux同样具有 &lt;code&gt;noatime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">请注意，在此输出中没有任何地方可以看到 &lt;code&gt;I got the value 4&lt;/code&gt; ，该值是运行通过的测试时输出的值。该输出已被捕获。测试失败的输出（ &lt;code&gt;I got the value 8&lt;/code&gt; ）出现在测试摘要输出的部分中，该部分还显示了测试失败的原因。</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">请注意，在多次 &lt;code&gt;poll&lt;/code&gt; ，应仅安排从&lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;传递到最近的调用的&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;接收唤醒。</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">注意，不能将 &lt;code&gt;CannotReallocInPlace&lt;/code&gt; 传递给 &lt;code&gt;handle_alloc_error&lt;/code&gt; 函数。客户端应该能够从 &lt;code&gt;grow_in_place&lt;/code&gt; 故障中恢复而不会中止，或者希望在中止之前依靠另一种重新分配方法。</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">注意，不能将 &lt;code&gt;CannotReallocInPlace&lt;/code&gt; 传递给 &lt;code&gt;handle_alloc_error&lt;/code&gt; 函数。期望客户端能够在不中止的情况下从 &lt;code&gt;shrink_in_place&lt;/code&gt; 故障中恢复，或者在诉诸中止之前使用另一种重新分配方法。</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">请注意,Rust中的恐慌并不总是通过解除缠绕来实现,但它们可能通过中止进程来实现。如果当恐慌以这种方式实现时调用这个函数,那么这个函数将中止进程,而不是触发解卷。</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">请注意,这个区块的部分使用。</target>
        </trans-unit>
        <trans-unit id="fff05e35d755803ade4b50f50d29c987f0007787" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;. For example, whether or not &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; has no effect on the behavior of &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">请注意，固定和 &lt;code&gt;Unpin&lt;/code&gt; 固定仅影响指向类型 &lt;code&gt;P::Target&lt;/code&gt; ，而不影响包裹在 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 的指针类型 &lt;code&gt;P&lt;/code&gt; 本身。例如， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 是否为 &lt;code&gt;Unpin&lt;/code&gt; 对 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 的行为没有影响（此处 &lt;code&gt;T&lt;/code&gt; 是指向类型）。</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">请注意,读取会将分片更新为指向尚未读取的部分。当达到EOF时,分片将为空。</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">注意，类似于&lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt;，短读返回不是错误。</target>
        </trans-unit>
        <trans-unit id="78d8286e3fe0bd2fe84e388fefe8408d278761d1" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">请注意，类似于&lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt;，返回短写不是错误。</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">注意，类似于 &lt;code&gt;File::read&lt;/code&gt; ，短读返回不是错误。从短读返回时，文件指针仍会更新。</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">请注意，类似于 &lt;code&gt;File::write&lt;/code&gt; ，返回短写不是错误。从这么短的写入返回时，文件指针仍会更新。</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，某些平台可能只是根据&lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt;实现此目的。</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">注意，默认情况下，stdout通常是行缓冲的，因此可能有必要使用&lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt;来确保立即发出输出。</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">请注意，由于Rust的安全保证，假设我们在此模块中未使用任何同步原语，则访问全局（静态）变量需要使用 &lt;code&gt;unsafe&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 运算符会短路，即，只有对第二个操作数有帮助的结果，他们才求值。由于此行为不能由特征强制执行，所以 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 不支持作为可重载运算符。</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">请注意，每次我们在代码中使用 &lt;code&gt;*&lt;/code&gt; 时， &lt;code&gt;*&lt;/code&gt; 运算符都会被调用 &lt;code&gt;deref&lt;/code&gt; 方法代替，然后仅调用一次 &lt;code&gt;*&lt;/code&gt; 运算符。由于的替代 &lt;code&gt;*&lt;/code&gt; 运算符不递归无限，我们与类型的数据结束了 &lt;code&gt;i32&lt;/code&gt; ，其匹配 &lt;code&gt;5&lt;/code&gt; 中 &lt;code&gt;assert_eq!&lt;/code&gt; 在清单15-9中。</target>
        </trans-unit>
        <trans-unit id="42a41979051d804f1901f27167063da0694efa1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function can be used to ignore these environment variables. Also note that the state of environment variables is cached once the first backtrace is created, so altering &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; at runtime may not actually change how backtraces are captured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6dbff824203032252330e130f2e622a82a7979" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;FromFn&lt;/code&gt; 迭代器不对闭包的行为进行假设，因此保守地不会实现&lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; &lt;/a&gt;，也不会从其默认值 &lt;code&gt;(0, None)&lt;/code&gt; 覆盖&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">请注意，首页上没有列出 &lt;code&gt;PrimaryColor&lt;/code&gt; 和 &lt;code&gt;SecondaryColor&lt;/code&gt; 类型， &lt;code&gt;mix&lt;/code&gt; 功能也没有列出。我们必须单击 &lt;code&gt;kinds&lt;/code&gt; 和 &lt;code&gt;utils&lt;/code&gt; 才能看到它们。</target>
        </trans-unit>
        <trans-unit id="8f49c43ce4bf9debfde5b04db98c0212ba6c8e15" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;SOME_PROPERTY&lt;/code&gt; associated constant would not compile, as its type &lt;code&gt;bool&lt;/code&gt; refers to the struct, rather than to the primitive bool type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">请注意， &lt;code&gt;black&lt;/code&gt; 和 &lt;code&gt;origin&lt;/code&gt; 值是不同的类型，因为它们是不同元组结构的实例。您定义的每个结构都是其自己的类型，即使该结构中的字段具有相同的类型。例如，即使两个类型都由三个 &lt;code&gt;i32&lt;/code&gt; 值组成，但是采用 &lt;code&gt;Color&lt;/code&gt; 类型参数的函数也不能将 &lt;code&gt;Point&lt;/code&gt; 作为参数。否则，元组struct实例的行为类似于元组：您可以将它们分解为各自的片段，可以使用 &lt;code&gt;.&lt;/code&gt; 然后是索引以访问单个值，依此类推。</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">请注意， &lt;code&gt;internal_adder&lt;/code&gt; 函数未标记为 &lt;code&gt;pub&lt;/code&gt; ，但是由于测试只是Rust代码，而 &lt;code&gt;tests&lt;/code&gt; 模块只是另一个模块，因此您可以将 &lt;code&gt;internal_adder&lt;/code&gt; 放入测试的作用域并对其进行调用。如果您不认为应该测试私有功能，那么Rust中没有什么可以迫使您这样做。</target>
        </trans-unit>
        <trans-unit id="1dfcc45249eab2386a4a77c00ed86344264ef031" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">注意， &lt;code&gt;mod common;&lt;/code&gt; 声明与清单7-25中演示的模块声明相同。然后在测试函数中，我们可以调用 &lt;code&gt;common::setup()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">请注意，&lt;em&gt;src / lib.rs&lt;/em&gt;中的 &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; 语句也没有更改， &lt;code&gt;use&lt;/code&gt; 也不会影响作为crate一部分编译的文件。该 &lt;code&gt;mod&lt;/code&gt; 关键字声明模块和锈看起来具有相同的名称作为该进入该模块的代码模块的文件。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">请注意，Rust语法将 &lt;code&gt;-1i8&lt;/code&gt; 视为一&lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;元减号运算符&lt;/a&gt;对整数文字 &lt;code&gt;1i8&lt;/code&gt; 的应用，而不是单个整数文字。</target>
        </trans-unit>
        <trans-unit id="56aae01ce79d910a619efda10dafe9ed6c6133a8" translate="yes" xml:space="preserve">
          <source>Note that the alignment of the resulting layout will be the maximum of those of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in order to ensure alignment of both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">请注意，分配器可能会给集合提供比其请求更多的空间。因此，不能依靠容量精确地最小化。如果预计将来会插入，则优先&lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c27c4a17236d84a273debe0206e2acee86fe4f0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0700ca055cbce179ecc3d9a30bb5baa7a6c28e" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088614193a26ec5fa144e1468834aa2d40a502e0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71fe50cc784bf479a83f567c5fb33ac0db88d1d" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">请注意，分配器可能会给集合提供比其请求更多的空间。因此，不能依靠容量来精确地最小化。如果预计将来会插入，则优先 &lt;code&gt;reserve&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">请注意,分配器给集合的空间可能比它请求的更多。因此,不能依靠容量精确到最小。如果预计未来会有插入,则优先选择保留。</target>
        </trans-unit>
        <trans-unit id="08c862951a6a3b03e0330454b0efc29b2b754947" translate="yes" xml:space="preserve">
          <source>Note that the argument is not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0769350c5d5d78015e993d43a239511a252097" translate="yes" xml:space="preserve">
          <source>Note that the arguments are not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">需要注意的是,尽量保证等待的时间是用单调的时钟测量的,不受系统时间变化的影响。</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">请注意，已尽最大努力确保使用单调时钟测量等待的时间，并且不受系统时间更改的影响。此功能易受虚假唤醒的影响。条件变量通常具有与之关联的布尔谓词，并且每次该函数返回时都必须始终检查谓词，以防止虚假唤醒。另外，尽管有虚假的唤醒，通常还是希望超时不超过某个持续时间，因此睡眠时间会减少睡眠量。另外，也可以使用 &lt;code&gt;wait_timeout_until&lt;/code&gt; 方法来等待，直到达到条件且总超时为止，而不管虚假唤醒如何。</target>
        </trans-unit>
        <trans-unit id="a6a58cc27a5e657fb0a670643552701080e58296" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_while&lt;/code&gt; method to wait with a timeout while a predicate is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">请注意， &lt;code&gt;self&lt;/code&gt; 的能力不会改变。</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">注意整个实例必须是可变的。Rust不允许我们仅将某些字段标记为可变字段。与任何表达式一样，我们可以构造该结构的新实例作为函数主体中的最后一个表达式，以隐式返回该新实例。</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">请注意，这里的错误在于通用函数的定义：尽管我们仅使用实现 &lt;code&gt;Debug&lt;/code&gt; 的参数来调用它，但编译器仍拒绝该函数：它必须适用于所有可能的输入类型。为了编译该示例，我们需要限制我们接受的泛型类型：</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">请注意,输入令牌的扩展结果将来可能会改变。如果你依赖输出,你应该小心。</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，最里面的对象设置了边界，因此 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; 仍然是 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">注意,小写的点 &quot;i &quot;与拉丁文相同。因此。</target>
        </trans-unit>
        <trans-unit id="0529503c0b783f1fa295149899ee5a9048a3f3e4" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">请注意，该宏旨在用作调试工具，因此，应避免长时间在版本控制中使用该宏。涉及调试输出的用例应添加到版本控制中，这样的宏可以更好地服务于&lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;的宏！从&lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;箱中。</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">请注意，测试的输出和测试结果是交错的；原因是测试是并行运行的，正如我们在上一节中讨论的那样。尝试使用 &lt;code&gt;--test-threads=1&lt;/code&gt; 选项和 &lt;code&gt;--nocapture&lt;/code&gt; 标志，然后查看输出结果！</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">请注意，该指针值可能表示代表 &lt;code&gt;T&lt;/code&gt; 的有效指针，这意味着不得将其用作&amp;ldquo;尚未初始化&amp;rdquo;的前哨值。延迟分配的类型必须通过其他某种方式来跟踪初始化。</target>
        </trans-unit>
        <trans-unit id="219a901fc4bbd905770e11b959092de46ce1a4b3" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">请注意，主线程的堆栈大小&lt;em&gt;不是&lt;/em&gt;由Rust确定的。</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">请注意，标准库（ &lt;code&gt;std&lt;/code&gt; ）也是我们包外部的板条箱。因为标准库是随Rust语言一起提供的，所以我们不需要更改&lt;em&gt;Cargo.toml&lt;/em&gt;以包含 &lt;code&gt;std&lt;/code&gt; 。但是，我们确实需要提到它与 &lt;code&gt;use&lt;/code&gt; 带来的物品从那里进入我们的包的范围。例如，对于 &lt;code&gt;HashMap&lt;/code&gt; ,我们将使用以下行：</target>
        </trans-unit>
        <trans-unit id="81d14f271d71ceb8a4e63a395e2c2b18f3026e6e" translate="yes" xml:space="preserve">
          <source>Note that the traits &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../convert/trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">请注意,性状AsRef和AsMut为可能不是固定大小的数组的类型提供了类似的方法。实现者应该选择这些特性。</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">注意，现在可以从 &lt;code&gt;temp&lt;/code&gt; 的类型推断 &lt;code&gt;v&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">需要注意的是底层的迭代器仍然是先进的时候&lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt;被称为首次：为了检索下一个元素，&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;被称为在底层迭代器，因此任何副作用的（即不是获取下一个值以外的任何东西）&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;方法将发生。</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">请注意，对于整个分配的内存块，返回值的用途要求 &lt;code&gt;align&lt;/code&gt; 小于或等于起始地址的对齐。满足此约束的一种方法是确保 &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">请注意，枚举的变体在其标识符下命名空间，并且我们使用双冒号将两者分开。之所以有用，是因为现在两个值 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 和 &lt;code&gt;IpAddrKind::V6&lt;/code&gt; 都属于同一类型： &lt;code&gt;IpAddrKind&lt;/code&gt; 。例如，我们然后可以定义一个接受任何 &lt;code&gt;IpAddrKind&lt;/code&gt; 的函数：</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">请注意，仅使用 &lt;code&gt;_&lt;/code&gt; 和以下划线开头的名称之间存在细微差别。语法 &lt;code&gt;_x&lt;/code&gt; 仍将值绑定到变量，而 &lt;code&gt;_&lt;/code&gt; 根本不绑定。为了说明这种区别很重要的情况，清单18-21将给我们提供一个错误。</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">请注意,不保证文件会被立即删除(例如,根据平台的不同,其他打开的文件描述符可能会阻止立即删除)。</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">请注意，两个 &lt;code&gt;Match&lt;/code&gt; es 之间可能有多个 &lt;code&gt;Reject&lt;/code&gt; ，没有要求将它们组合为一个。</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">请注意，这些输出是可堆叠的，如果指定了多个，则编译器将立即生成每种形式的输出，而无需重新编译。但是，这仅适用于用相同方法指定的输出。如果仅指定 &lt;code&gt;crate_type&lt;/code&gt; 属性，则将全部构建它们，但是如果指定一个或多个 &lt;code&gt;--crate-type&lt;/code&gt; 命令行标志，则仅将构建那些输出。</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，这些要求意味着特征本身必须对称且可传递地实现：如果 &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; 和 &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; 则 &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，这些要求意味着特征本身必须对称且可传递地实现：如果 &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; 和 &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; 则 &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">请注意，此 &lt;code&gt;let&lt;/code&gt; 语句意味着 &lt;code&gt;expensive_closure&lt;/code&gt; 包含匿名函数的&lt;em&gt;定义&lt;/em&gt;，而不是调用匿名函数的&lt;em&gt;结果值&lt;/em&gt;。回想一下我们使用闭包的原因，因为我们想定义代码以便在某一时刻调用，存储该代码并在以后一点调用；现在，我们要调用的代码存储在 &lt;code&gt;expensive_closure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">注意，这种方法需要与寿命参考小号 &lt;code&gt;'a&lt;/code&gt; 。短于 &lt;code&gt;'a&lt;/code&gt; 就足够了：较短的生存期意味着 &lt;code&gt;demo&lt;/code&gt; 完成执行后，在较短的生存期结束后，其他内容（例如析构函数！）可以访问 &lt;code&gt;s.data&lt;/code&gt; ，这再次违反了 &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrow的专有规定。访问。</target>
        </trans-unit>
        <trans-unit id="c27fe5a5d1e022b605f9e160ee6f188847c0730a" translate="yes" xml:space="preserve">
          <source>Note that this behavior is a consequence of the desugaring to a function that returns an &lt;code&gt;impl Future&lt;/code&gt; -- in this case, the function we desugar to is an &lt;code&gt;unsafe&lt;/code&gt; function, but the return value remains the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d559316d5513a320d9bd5dde1c5db0aa4a3ef581" translate="yes" xml:space="preserve">
          <source>Note that this differs from the behavior of &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt;&lt;code&gt;Rc::make_mut&lt;/code&gt;&lt;/a&gt; which disassociates any remaining &lt;code&gt;Weak&lt;/code&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">请注意，这并&lt;strong&gt;没有&lt;/strong&gt;返回字符串操作系统形式在字符串中的字节数。</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">请注意，这不会移动 &lt;code&gt;v&lt;/code&gt; （与 &lt;code&gt;transmute&lt;/code&gt; 不同），并且可能需要调用 &lt;code&gt;mem::forget(v)&lt;/code&gt; ，以防止避免调用析构函数。</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">请注意，此示例使用 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 用于单线程方案。如果在多线程情况下需要共享可变性，请考虑使用 &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">请注意，该示例尚未编译。我们稍后会解释原因。</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">请注意，此功能&lt;strong&gt;可能无法捕获&lt;/strong&gt; Rust中的&lt;strong&gt;所有紧急情况&lt;/strong&gt;。Rust中的恐慌并不总是通过平仓来实现，但是也可以通过中止该过程来实现。此功能&lt;em&gt;仅&lt;/em&gt;捕获正在缓解的紧急情况，而不会中止该过程的紧急情况。</target>
        </trans-unit>
        <trans-unit id="d3651367d7bc20ea65e217082fe9e78b8f819776" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f32&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a1415dd489b9fd2f261b68de74159561b45e0" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f64&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">请注意，此函数 &lt;code&gt;as&lt;/code&gt; 强制转换不同，后者试图保留&lt;em&gt;数字&lt;/em&gt;值而不是按位值。</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">请注意，此功能与&lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;相同，只是专门用于切片。如果并且当Rust获得专业化时，此功能可能会被弃用（但仍然可用）。</target>
        </trans-unit>
        <trans-unit id="0f406b6d417033b808228cce14b8dbb1120d5c7d" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;struct.vec#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">请注意,这个函数很容易被虚假唤醒。条件变量通常有一个与之相关的布尔谓词,每次函数返回时必须检查谓词,以防止虚假唤醒。</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">请注意,该函数在执行解析时可能会阻塞当前线程。</target>
        </trans-unit>
        <trans-unit id="380b102b57d47b1e80ead440741eb736cbc5acae" translate="yes" xml:space="preserve">
          <source>Note that this function returns NaN if the initial value was NaN as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">请注意，这&lt;em&gt;也&lt;/em&gt;不同于Windows-1252 aka代码页1252，后者是ISO / IEC 8859-1的超集，该集将一些（不是全部！）空格分配给标点符号和各种拉丁字符。</target>
        </trans-unit>
        <trans-unit id="c12e3030c3946db5f00ad56e92693e7a60e9d4f4" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_left&quot;&gt;&lt;code&gt;rotate_left&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05d921ff847b716a1e90578f4bb30e691402415" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;[&lt;/code&gt;rotate_left`](#method.rotate_left) function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">请注意，这是&lt;em&gt;不&lt;/em&gt;一样的左旋转; 环绕左移的RHS限于该类型的范围，而不是从LHS移出的位返回到另一端。所有原始整数类型都实现了 &lt;code&gt;rotate_left&lt;/code&gt; 函数，而您可能想要的就是该函数。</target>
        </trans-unit>
        <trans-unit id="3efbf7b6ffbe371fa44b1cbc24ab53cb5dc43bf3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_right&quot;&gt;&lt;code&gt;rotate_right&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">请注意，这是&lt;em&gt;不&lt;/em&gt;一样的一个旋转右; 环绕右移的RHS限制在类型范围内，而不是从LHS移出的位返回到另一端。所有原始整数类型都实现了 &lt;code&gt;rotate_right&lt;/code&gt; 函数，而您可能想要这么做。</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">请注意,这与ISO/IEC 8859-1又名ISO 8859-1(少了一个连字符)不同,后者留下了一些 &quot;空白&quot;,即没有分配给任何字符的字节值。ISO-8859-1(IANA的那个)把它们分配给C0和C1控制码。</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">请注意,目前还没有完全支持。</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">请注意,随着未来的澄清,这个列表可能会随着时间的推移而有所调整。</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">请注意,这可能对IPv6套接字没有任何影响。</target>
        </trans-unit>
        <trans-unit id="75b3dfc6f40c762d7bf2bac499b7412fe6b10302" translate="yes" xml:space="preserve">
          <source>Note that this may not have any effect on IPv6 sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">请注意，即使采用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，该方法也会更改基础文件的内容。</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">请注意，即使使用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，该方法也会更改基础文件的权限。</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">请注意，无论返回的布局是否具有不同的对齐方式，此方法都不会在整体大小上添加任何填充。换句话说，如果 &lt;code&gt;K&lt;/code&gt; 具有大小为16， &lt;code&gt;K.align_to(32)&lt;/code&gt; 将&lt;em&gt;仍然&lt;/em&gt;具有尺寸16。</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">请注意,此方法对字符串的分配容量没有影响。</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">请注意,这种方法对向量的分配容量没有影响。</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">请注意，此结构&lt;strong&gt;不是&lt;/strong&gt; &lt;code&gt;repr(C)&lt;/code&gt; ，建议不要将其放在FFI函数的签名中。相反，FFI函数的安全包装器可能会利用不安全的&lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; &lt;/a&gt;构造函数为其他使用者提供安全的接口。</target>
        </trans-unit>
        <trans-unit id="9aac27458abae34c90a97df1aff42a3fdeee40a4" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt;&lt;code&gt;CStr::from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">请注意,这种技术也可以用于匹配表达式的武器。</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">请注意,这将掉落任何多余的容量。</target>
        </trans-unit>
        <trans-unit id="6affebf246a6b9323b472569ce7b0d2dca1b6504" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; this iterator is &lt;strong&gt;not&lt;/strong&gt; fused. It is also not specified what this iterator returns after the first&lt;code&gt; None&lt;/code&gt; is returned. If you need fused iterator, use &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">请注意，与 &lt;code&gt;wait&lt;/code&gt; 不同，此函数不会尝试删除stdin。</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">请注意，与数组表达式不同，此语法支持实现&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; 的&lt;/a&gt;所有元素，并且元素的数量不必为常数。</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">需要注意的是,非大小类型有很多可能的空指针,因为只考虑原始数据指针,不考虑它们的长度、vtable等。因此,两个为空的指针可能仍然不能相互比较相等。</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">请注意，将来可能不需要以这种方式使用 &lt;code&gt;self&lt;/code&gt; 。Rust开发人员正在努力消除的语言不一致。</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">请注意，在这里无法使用 &lt;code&gt;type&lt;/code&gt; 关键字，因为 &lt;code&gt;type&lt;/code&gt; 仅引入了类型别名：</target>
        </trans-unit>
        <trans-unit id="bb6b42394e9bea5f3f448212418ce1a68b9d76c5" translate="yes" xml:space="preserve">
          <source>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">请注意,没有手动指定判别符的变体从0开始从上到下编号,所以看似不相关的变体也会发生冲突。</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">请注意，我们在此处添加了类型注释。因为我们没有在此向量中插入任何值，所以Rust不知道我们打算存储哪种元素。这是重要的一点。向量是使用泛型实现的；我们将在第10章中介绍如何将泛型与您自己的类型一起使用。现在，您知道标准库提供的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 类型可以容纳任何类型，并且当特定向量拥有特定类型时，该类型为在尖括号中指定。在清单8-1中，我们已经告诉锈的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;code&gt;v&lt;/code&gt; 将持有的元素 &lt;code&gt;i32&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">请注意，我们添加了包含布尔值的 &lt;code&gt;case_sensitive&lt;/code&gt; 字段。接下来，我们需要 &lt;code&gt;run&lt;/code&gt; 函数来检查 &lt;code&gt;case_sensitive&lt;/code&gt; 字段的值，并使用该值来决定是调用 &lt;code&gt;search&lt;/code&gt; 函数还是 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数，如清单12-22所示。请注意，这仍然不会编译。</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">注意，我们不需要将生成的 &lt;code&gt;split_at_mut&lt;/code&gt; 函数标记为 &lt;code&gt;unsafe&lt;/code&gt; ，我们可以从安全的Rust调用此函数。我们通过以安全方式使用 &lt;code&gt;unsafe&lt;/code&gt; 代码的函数的实现创建了对不安全代码的安全抽象，因为该函数仅从该函数可访问的数据中创建有效指针。</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">请注意，我们必须在 &lt;code&gt;impl&lt;/code&gt; 之后声明 &lt;code&gt;T&lt;/code&gt; ，以便可以使用它来指定我们要在 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 类型上实现方法。通过在 &lt;code&gt;impl&lt;/code&gt; 之后将 &lt;code&gt;T&lt;/code&gt; 声明为通用类型，Rust可以识别 &lt;code&gt;Point&lt;/code&gt; 中尖括号中的类型是通用类型，而不是具体类型。</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">请注意，由于必须使用名为 &lt;code&gt;to_string&lt;/code&gt; 的多个函数，因此必须使用前面在&lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;高级特性&amp;rdquo;&lt;/a&gt;部分中讨论的完全限定的语法。在这里，我们使用 &lt;code&gt;ToString&lt;/code&gt; 特性中定义的 &lt;code&gt;to_string&lt;/code&gt; 函数，标准库已为实现 &lt;code&gt;Display&lt;/code&gt; 的任何类型实现了此特性。</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">请注意，正如我们在第10章中讨论的那样，我们需要此方法的生命周期批注。我们将对 &lt;code&gt;post&lt;/code&gt; 的引用作为参数，并返回对该 &lt;code&gt;post&lt;/code&gt; 一部分的引用，因此返回的引用的生命周期与 &lt;code&gt;post&lt;/code&gt; 参数的生存期。</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">请注意，我们需要先 &lt;code&gt;use&lt;/code&gt; 的 &lt;code&gt;HashMap&lt;/code&gt; 的标准库中的馆藏部分。在我们的三个常见集合中，该集合是最不常用的集合，因此未包含在序幕中自动纳入范围的功能中。哈希图也没有得到标准库的支持。例如，没有内置的宏来构造它们。</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">注意，我们需要在左侧 &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 。这是因为我们可以改为收集例如&lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">请注意，我们需要使 &lt;code&gt;v1_iter&lt;/code&gt; 可变：在迭代器上调用 &lt;code&gt;next&lt;/code&gt; 方法将更改迭代器用来跟踪其在序列中的位置的内部状态。换句话说，此代码&lt;em&gt;消耗&lt;/em&gt;或&lt;em&gt;消耗&lt;/em&gt;了迭代器。每次调用 &lt;code&gt;next&lt;/code&gt; 都会消耗迭代器中的一个项目。使用 &lt;code&gt;for&lt;/code&gt; 循环时，我们不需要使 &lt;code&gt;v1_iter&lt;/code&gt; 可变，因为该循环获得了 &lt;code&gt;v1_iter&lt;/code&gt; 的所有权并使其在后台可变。</target>
        </trans-unit>
        <trans-unit id="5994cd1512c44aaad650a1803fdb7c349136ad1d" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. Refer to the &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;String Slices as Parameters&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">请注意，我们希望函数采用字符串切片（即引用），因为我们不希望 &lt;code&gt;longest&lt;/code&gt; 函数采用其参数的所有权。我们要允许该函数接受 &lt;code&gt;String&lt;/code&gt; 的切片（存储在变量 &lt;code&gt;string1&lt;/code&gt; 中的类型）以及字符串文字（变量 &lt;code&gt;string2&lt;/code&gt; 包含的内容）。</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">请注意，我们在 &lt;code&gt;tests&lt;/code&gt; 模块内添加了新行： &lt;code&gt;use super::*;&lt;/code&gt; 。该 &lt;code&gt;tests&lt;/code&gt; 模块是遵循我们在第7章中所涉及的通常可见性规则的规则模块&lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;模块为隐私边界&amp;rdquo;&lt;/a&gt;一节。因为 &lt;code&gt;tests&lt;/code&gt; 模块是内部模块，所以我们需要将外部模块中的测试代码带入内部模块的范围。我们在这里使用glob，因此我们在外部模块中定义的任何内容都可用于此 &lt;code&gt;tests&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="8e05c11c9aa8615f8372dccd3f7625301eed4295" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">请注意，我们也已经编辑了旧测试的 &lt;code&gt;contents&lt;/code&gt; 。我们在文本中添加了新行 &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; 当我们以区分大小写的方式进行搜索时，使用的首字母D不应与查询 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 匹配。以这种方式更改旧测试有助于确保我们不会意外破坏已经实现的区分大小写的搜索功能。该测试现在应该通过，并且在我们进行不区分大小写的搜索时应该继续通过。</target>
        </trans-unit>
        <trans-unit id="2e87959963706a5a2e57c9724a365d2a982bba5d" translate="yes" xml:space="preserve">
          <source>Note that when the wildcard &lt;code&gt;*&lt;/code&gt; is used on a type, it does not import its methods (though for &lt;code&gt;enum&lt;/code&gt;s it imports the variants, as shown in the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，在发生联系的地方，&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;通常会比&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;快，而&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;通常会比&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;快。</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">请注意,虽然在Rust中对环境变量的并发访问是安全的,但有些平台只公开了本质上不安全的非线程安全API来检查环境。因此,在审计对不安全的外部FFI函数的调用时,需要格外小心,以确保任何外部环境访问与Rust中的访问正确同步。</target>
        </trans-unit>
        <trans-unit id="d3954c01ae7015c1edc03c422ae6922dcf56ba11" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">请注意，虽然可以对 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 的内容进行突变或可变别名（如果您以其他方式强制执行不变式），但是具有多个 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 别名仍然是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="9eb90457458f8170cc06094675d04f9c0e8116dd" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a non-&lt;code&gt;unsafe&lt;/code&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">请注意,使用这个函数,当主线程结束时,新线程将被停止,无论它是否已经完成运行。这个程序的输出可能每次都有些不同,但看起来会类似于下面。</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">请注意,写入会更新分片,指向尚未写入的部分。当它被完全覆盖时,分片将是空的。</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">请注意，您不能使用&lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; 。&lt;/a&gt;不返回&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;函数中的运算符。相反，您可以调用&lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt;或在返回值上进行 &lt;code&gt;match&lt;/code&gt; 以捕获任何可能的错误：</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">请注意，尽管读写方法需要 &lt;code&gt;&amp;amp;mut File&lt;/code&gt; ，但是由于&lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;的接口， &lt;code&gt;&amp;amp;File&lt;/code&gt; 的持有者仍可以通过采用 &lt;code&gt;&amp;amp;File&lt;/code&gt; 的方法或通过检索基础OS对象并修改文件来修改文件。那样。此外，许多操作系统允许通过不同的进程同时修改文件。避免假定持有 &lt;code&gt;&amp;amp;File&lt;/code&gt; 表示文件不会更改。</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">请注意，由于 &lt;code&gt;$crate&lt;/code&gt; 引用当前的条板箱，因此在引用非宏项目时必须与标准模块路径一起使用：</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">请注意，就像 &lt;code&gt;Option&lt;/code&gt; 枚举一样， &lt;code&gt;Result&lt;/code&gt; 枚举及其变体已被序言纳入范围，因此我们无需在 &lt;code&gt;match&lt;/code&gt; 臂中的 &lt;code&gt;Ok&lt;/code&gt; 和 &lt;code&gt;Err&lt;/code&gt; 变体之前指定 &lt;code&gt;Result::&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">请注意，与 &lt;code&gt;repeat&lt;/code&gt; 不同，即使给定的 &lt;code&gt;self&lt;/code&gt; 实例正确对齐， &lt;code&gt;repeat_packed&lt;/code&gt; 也不保证 &lt;code&gt;self&lt;/code&gt; 的重复实例将正确对齐。换句话说，如果 &lt;code&gt;repeat_packed&lt;/code&gt; 返回的布局用于分配数组，则不能保证数组中的所有元素都将正确对齐。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">请注意:</target>
        </trans-unit>
        <trans-unit id="fc7308ef65a4b47d9c6953435d548f4e965b07bd" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">请注意基元&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;（也称为&amp;ldquo;切片&amp;rdquo;）的文档。实际上，通过&lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref强制&lt;/a&gt;，对&lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;许多方法调用实际上分别是对&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;上的方法的调用。</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">执行者须知</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">给实现者的注意：如果返回 &lt;code&gt;Ok(ptr)&lt;/code&gt; ，则 &lt;code&gt;ptr&lt;/code&gt; 必须被视为&amp;ldquo;当前分配&amp;rdquo;，并且必须是 &lt;code&gt;realloc&lt;/code&gt; 或 &lt;code&gt;dealloc&lt;/code&gt; 之类的方法的可接受输入，&lt;em&gt;即使&lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 是零大小的类型。换句话说，如果您的 &lt;code&gt;Alloc&lt;/code&gt; 实现以可以返回零大小的 &lt;code&gt;ptr&lt;/code&gt; 的方式覆盖此方法，则需要类似地重写所有重新分配和取消分配方法，以接受此类值作为输入。</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请在此处注意两个细节。首先，我们使用 &lt;code&gt;2&lt;/code&gt; 的索引值来获取第三个元素：向量从0开始按数字索引。其次，获取第三个元素的两种方法是使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;[]&lt;/code&gt; 给我们提供引用，或者使用 &lt;code&gt;get&lt;/code&gt; 方法将索引作为参数传递给我们，这给了我们 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c6f9d9871d6089da68d73e5351d58428691fe43" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">注意， &lt;code&gt;OsString&lt;/code&gt; 和 &lt;code&gt;OsStr&lt;/code&gt; 在内部不一定以平台固有的形式保存字符串。在Unix上，字符串存储为8位值的序列，而在Windows上，字符串如前所述是基于16位值的，而字符串实际上也存储为8位值的序列，其编码方式为UTF-8的严格变体。了解处理容量和长度值时，这很有用。</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">但是请注意，不能保证瞬间&lt;strong&gt;稳定&lt;/strong&gt;。换句话说，基础时钟的每个滴答声的长度可能不相同（例如，某些秒可能比其他秒长）。瞬间可能会向前跳跃或经历时间膨胀（减速或加速），但永远不会向后退。</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">但是请注意，名称相同的项可用于不重叠的固有 &lt;code&gt;impl&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">但是请注意，这不是不安全的特征，因此该特征没有提供简洁的合同。取而代之的是，它更多地是作为&amp;ldquo;减速带&amp;rdquo;来警告 &lt;code&gt;catch_unwind&lt;/code&gt; 的用户，可能见证并可能需要解决损坏的不变式。</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">请注意，在许多情况下， &lt;code&gt;str&lt;/code&gt; 上的 &lt;code&gt;.parse()&lt;/code&gt; 方法更为合适。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;Pin&lt;/code&gt; 还实现了对目标的 &lt;code&gt;Deref&lt;/code&gt; ，可用于访问内部值。然而， &lt;code&gt;Deref&lt;/code&gt; 只提供一种生活，只要在的借参考 &lt;code&gt;Pin&lt;/code&gt; ，而不是寿命 &lt;code&gt;Pin&lt;/code&gt; 本身。这种方法可以将 &lt;code&gt;Pin&lt;/code&gt; 转换为与原始 &lt;code&gt;Pin&lt;/code&gt; 寿命相同的参考。</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;Pin&lt;/code&gt; 还对数据实现 &lt;code&gt;DerefMut&lt;/code&gt; ，可用于访问内部值。然而， &lt;code&gt;DerefMut&lt;/code&gt; 只提供一种生活，只要在的借参考 &lt;code&gt;Pin&lt;/code&gt; ，而不是寿命 &lt;code&gt;Pin&lt;/code&gt; 本身。这种方法可以将 &lt;code&gt;Pin&lt;/code&gt; 转换为与原始 &lt;code&gt;Pin&lt;/code&gt; 寿命相同的参考。</target>
        </trans-unit>
        <trans-unit id="fe08fa35bb3e2ac30191647bef4f566cd6842a4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;core&lt;/code&gt; provides &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt;&lt;code&gt;core::panic::Location::caller&lt;/code&gt;&lt;/a&gt; for observing caller locations. It wraps the &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt;&lt;code&gt;core::intrinsics::caller_location&lt;/code&gt;&lt;/a&gt; intrinsic implemented by &lt;code&gt;rustc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">注意： &lt;code&gt;fold()&lt;/code&gt; 和遍历整个迭代器的类似方法对于无限迭代器可能不会终止，即使在可以在有限时间内确定结果的特征上也是如此。</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">注意： &lt;code&gt;move&lt;/code&gt; 闭包仍然可以实现&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;，即使它们通过移动捕获变量。这是因为由闭包类型实现的特征是由闭包对捕获的值执行的操作而不是其捕获它们的方式确定的。</target>
        </trans-unit>
        <trans-unit id="ddaee189fcb99b6fc9ed6acd8de34bd62f953e86" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by &lt;code&gt;move&lt;/code&gt;. This is because the traits implemented by a closure type are determined by &lt;em&gt;what&lt;/em&gt; the closure does with captured values, not &lt;em&gt;how&lt;/em&gt; it captures them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">注意： &lt;code&gt;rustc&lt;/code&gt; 当前识别工具&amp;ldquo; clippy&amp;rdquo;和&amp;ldquo; rustfmt&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">注意： &lt;code&gt;rustc&lt;/code&gt; 为每个目标和CPU启用了一组默认功能。可以使用&lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt;标志选择CPU。可以使用&lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt;标志为整个包装箱启用或禁用单个功能。</target>
        </trans-unit>
        <trans-unit id="3f9c395bf29ddc7654449b79d4dc0411e7becef5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;str&lt;/code&gt; in &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; is not meaningful here. This type parameter of the trait only exists to enable another impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d79cac345f205a82618d9422d71b4ef0b8bd13" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;union&lt;/code&gt;s with non-&lt;code&gt;Copy&lt;/code&gt; fields are unstable, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">注意：您可能会听到一句关于使用严格的编译器（例如Haskell和Rust）的语言的说法，即&amp;ldquo;如果代码可以编译，则可以正常工作&amp;rdquo;。但是，这句话并非普遍如此。我们的项目可以编译，但是绝对不起作用！如果我们要构建一个真实，完整的项目，那么这将是开始编写单元测试以检查代码是否已编译&lt;em&gt;并&lt;/em&gt;具有所需行为的好时机。</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">注:虽然Rust和其他任何语言一样,可以由解释器以及编译器来实现,但现有的唯一实现是编译器,而且该语言一直被设计成编译语言。由于这些原因,本节假定有一个编译器。</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">注意：由于表示形式是商品的属性，因此表示形式不依赖于通用参数。具有相同名称的任何两种类型具有相同的表示形式。例如， &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; 都具有相同的表示形式。</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">注意：作为控制流表达式，如果块表达式是表达式语句的外部表达式，则期望的类型为 &lt;code&gt;()&lt;/code&gt; ,除非紧随其后是分号。</target>
        </trans-unit>
        <trans-unit id="09b47fffa556007259b32260e62d1512eb70865a" translate="yes" xml:space="preserve">
          <source>Note: Due to the representation of &lt;code&gt;repr(C)&lt;/code&gt; structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an &lt;code&gt;enum&lt;/code&gt;'s representation may therefore use whichever form is more convenient or consistent for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">注意:除了lints外,习惯上只在函数项上使用外属性。</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">注意：为了清楚起见，建议始终在特征对象上使用 &lt;code&gt;dyn&lt;/code&gt; 关键字，除非您的代码库支持使用Rust 1.26或更低版本进行编译。</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">注意：有关 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 类型的实现细节的更多信息，请参见https://doc.rust-lang.org/stable/nomicon/vec.html上的&amp;ldquo; The Rustonomicon&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="12ed0cecef028f179120e48d11efd24c874bfd2d" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">注意：为了简单起见，我们将许多问题称为&lt;em&gt;并发，&lt;/em&gt;而不是通过说出&lt;em&gt;并发和/或并行&lt;/em&gt;来更精确。如果这本书是关于并发和/或并行性的，我们会更具体一些。对于本章，每当我们使用&lt;em&gt;并发&lt;/em&gt;时，请在精神上替换&lt;em&gt;并发和/或并行&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">注意：函数也可以实现所有三个 &lt;code&gt;Fn&lt;/code&gt; 特性。如果我们想要做的事情不需要从环境中获取值，则可以使用函数而不是闭包，而在闭包中我们需要实现 &lt;code&gt;Fn&lt;/code&gt; 特性的东西。</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">注意：Git是常见的版本控制系统。您可以使用 &lt;code&gt;--vcs&lt;/code&gt; 标志将 &lt;code&gt;cargo new&lt;/code&gt; 更改为使用其他版本控制系统或不使用任何版本控制系统。运行 &lt;code&gt;cargo new --help&lt;/code&gt; 以查看可用选项。</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">注意：从历史上看，位置表达式称为&lt;em&gt;lvalues，&lt;/em&gt;而值表达式称为&lt;em&gt;rvalues&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">注意：如果 &lt;code&gt;PeekMut&lt;/code&gt; 值泄漏，则堆可能处于不一致状态。</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">注意：如果由于某些原因您不想使用 &lt;code&gt;rustup&lt;/code&gt; ，请参阅&lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;Rust安装页面&lt;/a&gt;以获取其他选项。</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">注意：在C ++中，这种在项目生命周期结束时分配资源的模式有时称为&lt;em&gt;Resource Acquisition Is Initialization（RAII）&lt;/em&gt;。如果您使用过RAII模式，Rust中的 &lt;code&gt;drop&lt;/code&gt; 函数将为您所熟悉。</target>
        </trans-unit>
        <trans-unit id="54b56211cde322330df3d7c8028b1e66317b030b" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse()&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">注意：通常，如果需要融合的迭代器，则 &lt;code&gt;FusedIterator&lt;/code&gt; 在通用范围内使用FusedIterator。相反，您应该只在迭代器上调用&lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt;。如果迭代器已经融合，则附加的&lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt;包装器将是无操作的，并且不会降低性能。</target>
        </trans-unit>
        <trans-unit id="30cece00231291046dd06875e4aca4bb16fbdc74" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
