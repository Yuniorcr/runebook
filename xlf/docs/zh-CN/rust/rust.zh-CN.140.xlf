<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1ff8f63be235b7ea2055383c2e9b72b84c7bd07e" translate="yes" xml:space="preserve">
          <source>Notable traits for Scan&amp;lt;I, St, F&amp;gt;</source>
          <target state="translated">Scan &amp;lt;I，St，F&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="985d073dbfe88a46f9a5d9a064d7c96c1a9ddbdb" translate="yes" xml:space="preserve">
          <source>Notable traits for Skip&amp;lt;I&amp;gt;</source>
          <target state="translated">Skip &amp;lt;I&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="4f0eaba444b8b7b51819626fe7d8a57f993cdf9a" translate="yes" xml:space="preserve">
          <source>Notable traits for SkipWhile&amp;lt;I, P&amp;gt;</source>
          <target state="translated">SkipWhile &amp;lt;I，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="ca8f82912aa693cda641dbb9a8f2619f7e15ddea" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I&amp;gt;</source>
          <target state="translated">Splice &amp;lt;'_，I&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="12d474f38bf85bfc1567b98ee3eb463b107a0ce2" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I, A&amp;gt;</source>
          <target state="translated">Splice &amp;lt;'_，I，A&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="ef399e09acd6419098e7cfcabf45df6744dbfbc6" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">Split &amp;lt;'a，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="e1f967c2a861c03dbdc5cf356551e97bb60b084f" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">Split &amp;lt;'a，T，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="e39a8c3f513e0738a443ac406858d3b7bc026953" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;B&amp;gt;</source>
          <target state="translated">Split &amp;lt;B&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="d1d5f710d040b4a11a5d716baa68dcf2d617217b" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitAsciiWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="translated">SplitAsciiWhitespace &amp;lt;'a&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="fb7865e840a56b3e0895b5ec1bdbc829b951351d" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusive&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitInclusive &amp;lt;'a，T，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="9818f4f1fdfe2d933ac6655c5c4953e8aff5a7e1" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusiveMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitInclusiveMut &amp;lt;'a，T，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="0838dd01ca950ce33cd2058b8d0ff4fd43821113" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitMut &amp;lt;'a，T，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="e5880f295f9b58cf5125e602e8fae3c01c02bfbe" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">SplitN &amp;lt;'a，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="7599a2d009c0938be30293d468e1a75ce65377d5" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitN &amp;lt;'a，T，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="37e0cb911750681c09ba0b190a9557e42adc2590" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitNMut &amp;lt;'a，T，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="f48dc2915683e916503c8dcf3e59f491126656bf" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">SplitTerminator &amp;lt;'a，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="d707147c6fab5cc551e32ce5467c609e374e4f50" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="translated">SplitWhitespace &amp;lt;'a&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="437caeb56851568308dca5cb78609789356f0853" translate="yes" xml:space="preserve">
          <source>Notable traits for StderrLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StderrLock &amp;lt;'_&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="48c194fa1f0bd2541f390bd24896165b0c23c7e5" translate="yes" xml:space="preserve">
          <source>Notable traits for StdinLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StdinLock &amp;lt;'_&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="ee33f3797cb0a601933ebede73fe50f827c75b6e" translate="yes" xml:space="preserve">
          <source>Notable traits for StdoutLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StdoutLock &amp;lt;'_&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="3e0ae991bfa5ac7c9c453dec86d28b7d72d47073" translate="yes" xml:space="preserve">
          <source>Notable traits for StepBy&amp;lt;I&amp;gt;</source>
          <target state="translated">StepBy &amp;lt;I&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="83f5fe0a710de90155479f39d5f77c153488c0a5" translate="yes" xml:space="preserve">
          <source>Notable traits for Successors&amp;lt;T, F&amp;gt;</source>
          <target state="translated">后继者的显着特征&amp;lt;T，F&amp;gt;</target>
        </trans-unit>
        <trans-unit id="647ebf3b1fc10e80b4ce476f35a75fa114a5fab1" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">SymmetricDifference &amp;lt;'a，T&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="5e0deb017937ef51088c94bb895f3902110ffe16" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">SymmetricDifference &amp;lt;'a，T，S&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="6b271862886a9e625b5ac46fc4e49bcce91334f9" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;I&amp;gt;</source>
          <target state="translated">Take &amp;lt;I&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="8d1491004df1c3cd73af985e7889ffe06072d374" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;T&amp;gt;</source>
          <target state="translated">Take &amp;lt;T&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="8c484c47892ef31d80e9449405b6a45f7812a953" translate="yes" xml:space="preserve">
          <source>Notable traits for TakeWhile&amp;lt;I, P&amp;gt;</source>
          <target state="translated">TakeWhile &amp;lt;I，P&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="ce43b5e8ae4c3d3abba449747c3b74da4e5cf5b2" translate="yes" xml:space="preserve">
          <source>Notable traits for TcpStream</source>
          <target state="translated">TcpStream的显著特征</target>
        </trans-unit>
        <trans-unit id="0e1590902cedb9997418d686f3b41f48a7faa5a8" translate="yes" xml:space="preserve">
          <source>Notable traits for ToLowercase</source>
          <target state="translated">ToLowercase的显著特征</target>
        </trans-unit>
        <trans-unit id="71cea9ba6a0245158a668390fdcdb390b3ee3a95" translate="yes" xml:space="preserve">
          <source>Notable traits for ToUppercase</source>
          <target state="translated">ToUppercase的显著特征。</target>
        </trans-unit>
        <trans-unit id="2bc316517c095ef6246876fb36dafafef8842df0" translate="yes" xml:space="preserve">
          <source>Notable traits for TryIter&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">TryIter &amp;lt;'a，T&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="36cd3ac7d99db311332b377e21251e4fba5322ec" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Union &amp;lt;'a，T&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="a1623bf8aee40498694e04160abcc7cc94e51160" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">Union &amp;lt;'a，T，S&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="41fbaa40eb7f00c2be283feaa1fbb38e29701e83" translate="yes" xml:space="preserve">
          <source>Notable traits for UnixStream</source>
          <target state="translated">UnixStream的显著特征</target>
        </trans-unit>
        <trans-unit id="9c50d1662883c24d433db05a688c0aa44526ac2e" translate="yes" xml:space="preserve">
          <source>Notable traits for Values&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">值&amp;lt;'a，K，V&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="58c872469ad3d287548b76d4b848eba9a4a4c7d9" translate="yes" xml:space="preserve">
          <source>Notable traits for ValuesMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">ValuesMut &amp;lt;'a，K，V&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="34aac67be859564d9e8c0c60e00e2a029f471028" translate="yes" xml:space="preserve">
          <source>Notable traits for Vec&amp;lt;u8&amp;gt;</source>
          <target state="translated">Vec &amp;lt;u8&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="3f1ce7df300d5a68156470029c1320d12946032a" translate="yes" xml:space="preserve">
          <source>Notable traits for Windows&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Windows &amp;lt;'a，T&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="a8ed148e4a8689fea1373b25b6f60ce6eb17047c" translate="yes" xml:space="preserve">
          <source>Notable traits for Zip&amp;lt;A, B&amp;gt;</source>
          <target state="translated">Zip &amp;lt;A，B&amp;gt;的显着特征</target>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">值得注意的是，此函数忽略 &lt;code&gt;flag&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">值得注意的是：&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;，函数参数，&lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt;和&lt;a href=&quot;items/static-items&quot;&gt;静态&lt;/a&gt;项必须调整 &lt;code&gt;Sized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">注1:即使迭代器直到最后才被消耗,元素范围也会被删除。</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">注1:即使迭代器只消耗了一部分或根本没有消耗,元素范围也会被删除。</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">注1:无论给定的步长是多少,迭代器的第一个元素都会被返回。</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">注意2：如果 &lt;code&gt;Drain&lt;/code&gt; 值没有下降，但保留的借用到期（例如由于 &lt;code&gt;mem::forget&lt;/code&gt; ），则未指定从双端队列中删除了多少个元素。</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">注2：如果 &lt;code&gt;Drain&lt;/code&gt; 值泄漏，则从向量中删除了多少个元素（未指定）。</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">注2：拉出被忽略元素的时间不固定。 &lt;code&gt;StepBy&lt;/code&gt; 的行为类似于序列 &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; ，但是也可以自由地表现为序列 &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; 哪种方式可以由于性能原因，需要对某些迭代器进行更改。第二种方法将使迭代器更早地进行，并可能消耗更多的项。</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">还要注意，在清单19-1和19-3中，我们创建了 &lt;code&gt;*const i32&lt;/code&gt; 和 &lt;code&gt;*mut i32&lt;/code&gt; 原始指针，它们都指向相同的内存位置（存储 &lt;code&gt;num&lt;/code&gt; ）。如果改为尝试创建对 &lt;code&gt;num&lt;/code&gt; 的不可变且可变的引用，则代码将无法编译，因为Rust的所有权规则不允许与任何不可变的引用同时使用可变的引用。使用原始指针，我们可以创建指向相同位置的可变指针和不可变指针，并通过可变指针更改数据，从而潜在地造成数据竞争。小心！</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">还要注意，在这种形式主义的上下文中，术语&amp;ldquo;令牌&amp;rdquo;通常&lt;em&gt;包括&lt;/em&gt;简单的NT。</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">但请注意:</target>
        </trans-unit>
        <trans-unit id="ac8dc1e3e610d665d4339a3068108ed3e4e3d7f2" translate="yes" xml:space="preserve">
          <source>Note however, that &lt;code&gt;black_box&lt;/code&gt; is only (and can only be) provided on a &quot;best-effort&quot; basis. The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used. Programs cannot rely on &lt;code&gt;black_box&lt;/code&gt; for &lt;em&gt;correctness&lt;/em&gt; in any way.</source>
          <target state="translated">但是请注意， &lt;code&gt;black_box&lt;/code&gt; 仅（并且只能）基于&amp;ldquo;尽力而为&amp;rdquo;的方式提供。它可以阻止优化的程度可能会有所不同，具体取决于所使用的平台和代码源后端。程序不能以任何方式依靠 &lt;code&gt;black_box&lt;/code&gt; 来确保&lt;em&gt;正确性&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">关于地域的说明</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">请注意，＆Any仅限于测试值是否为指定的具体类型，而不能用于测试类型是否实现了特征。</target>
        </trans-unit>
        <trans-unit id="57e530ae79447e200db1291082ac88c201431874" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; already performs this check, so if your workload can be reduced to some small number of &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; calls, using this is unnecessary. In particular note that you can &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">请注意，&lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; &lt;/a&gt;已经执行了此检查，因此如果可以将您的工作量减少到少量的&lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; &lt;/a&gt;调用，则无需使用此功能。特别要注意的是，您可以&lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; &lt;/a&gt;一个切片，这将对所有值进行一次需求检查。</target>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">注意，例如使用此原语实现&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;。确实，当您调用 &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;recv&lt;/code&gt; 时，它们阻塞了，如果通道不可用，它们会产生作用。</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">请注意，&lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; &lt;/a&gt;实现&lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; ,&lt;/a&gt;而&lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt;实现&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cb54b0f71bbcbfc437ecfe318e92da06296ef44e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; 仅限于测试值是否为指定的具体类型，而不能用于测试类型是否实现了特征。</target>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">请注意， &lt;code&gt;(T,)&lt;/code&gt; 始终表示包含 &lt;code&gt;T&lt;/code&gt; 型元素的1元组的类型。逗号对于语法消除歧义是必要的。</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">请注意， &lt;code&gt;CoerceUnsized&lt;/code&gt; 主要由 &lt;code&gt;Box&lt;/code&gt; ， &lt;code&gt;Rc&lt;/code&gt; 和 &lt;code&gt;Arc&lt;/code&gt; 等智能指针使用，以便能够标记它们可以强制其指向的非大小类型。</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">请注意， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 仅用于单线程方案。在第16章讨论并发时，我们将介绍如何在多线程程序中进行引用计数。</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">请注意，默认情况下 &lt;code&gt;Rhs&lt;/code&gt; 为 &lt;code&gt;Self&lt;/code&gt; ，但这不是强制性的。</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">请注意，默认情况下 &lt;code&gt;Rhs&lt;/code&gt; 为 &lt;code&gt;Self&lt;/code&gt; ，但这不是强制性的。例如，&lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; ，它允许以 &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; 的形式进行操作。</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">请注意，默认情况下 &lt;code&gt;Rhs&lt;/code&gt; 为 &lt;code&gt;Self&lt;/code&gt; ，但这不是强制性的。例如，&lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; ，它允许以 &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; 的形式进行操作。</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">请注意， &lt;code&gt;T&lt;/code&gt; 不一定实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，因此它甚至无法克隆并重置 &lt;code&gt;self.buf&lt;/code&gt; 。但 &lt;code&gt;replace&lt;/code&gt; 可以用来撇清原值 &lt;code&gt;self.buf&lt;/code&gt; 从 &lt;code&gt;self&lt;/code&gt; ，允许其返回：</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">请注意， &lt;code&gt;T&lt;/code&gt; 不一定实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，因此它甚至无法克隆并重置 &lt;code&gt;self.buf&lt;/code&gt; 。但 &lt;code&gt;take&lt;/code&gt; 可以用来撇清原值 &lt;code&gt;self.buf&lt;/code&gt; 从 &lt;code&gt;self&lt;/code&gt; ，允许其返回：</target>
        </trans-unit>
        <trans-unit id="ac00b6421a53f1cb355d37f763df7d0ab6908815" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so we can't even clone &lt;code&gt;self.buf[i]&lt;/code&gt; to avoid the move. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value at that index from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">请注意， &lt;code&gt;T&lt;/code&gt; 不一定实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，因此我们甚至无法克隆 &lt;code&gt;self.buf[i]&lt;/code&gt; 来避免此举。但是 &lt;code&gt;replace&lt;/code&gt; 可以用来使该索引处的原始值与 &lt;code&gt;self&lt;/code&gt; 解除关联，从而可以将其返回：</target>
        </trans-unit>
        <trans-unit id="a23e62c56ad5b9bcbd4370446379ba67e37df78f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;[expr; 0]&lt;/code&gt; is allowed, and produces an empty array. This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so be mindful of side effects.</source>
          <target state="translated">注意 &lt;code&gt;[expr; 0]&lt;/code&gt; 是允许的，并产生一个空数组。但是，这仍将评估 &lt;code&gt;expr&lt;/code&gt; ，并立即降低结果值，因此请注意副作用。</target>
        </trans-unit>
        <trans-unit id="a7210db58c23cf5014deeb9448717499ab480d12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt;; this is the case when it would require more than &lt;code&gt;usize::MAX&lt;/code&gt; steps to get to &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">注意， &lt;code&gt;a &amp;lt;= b&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;暗示 &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt; ; 这是当我们需要不止的情况下 &lt;code&gt;usize::MAX&lt;/code&gt; 步骤去 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">请注意， &lt;code&gt;drain_filter&lt;/code&gt; 还允许您更改过滤器闭包中的每个元素，无论您选择保留还是删除它。</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">请注意， &lt;code&gt;drain_filter&lt;/code&gt; 允许您更改过滤器闭包中的每个元素，无论您选择保留还是删除它。</target>
        </trans-unit>
        <trans-unit id="5c2297eec650eb177080c75bea870e375a760bc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">请注意， &lt;code&gt;drain_filter&lt;/code&gt; 允许您更改过滤器闭包中的每个值，无论您选择保留还是删除它。</target>
        </trans-unit>
        <trans-unit id="900305edc91345ae356f030caba1b6142733f009" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;iter.filter(f).next()&lt;/code&gt; 等同于 &lt;code&gt;iter.find(f)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7d482051dadae6146f69f3e213d64c34dd92558" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.find(f)&lt;/code&gt; is equivalent to &lt;code&gt;iter.filter(f).next()&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;iter.find(f)&lt;/code&gt; 等同于 &lt;code&gt;iter.filter(f).next()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">请注意， &lt;code&gt;ptr::drop_in_place&lt;/code&gt; 已经执行了此检查，因此如果可以将您的工作量减少到少量的drop_in_place调用，则无需使用此功能。特别要注意的是，您可以drop_in_place一个slice，这将对所有值进行单个需求检查。</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">请注意， &lt;code&gt;query&lt;/code&gt; 现在是 &lt;code&gt;String&lt;/code&gt; 而不是字符串切片，因为调用 &lt;code&gt;to_lowercase&lt;/code&gt; 会创建新数据，而不是引用现有数据。假设查询为 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; ，例如：该字符串切片不包含小写字母 &lt;code&gt;u&lt;/code&gt; 或 &lt;code&gt;t&lt;/code&gt; 供我们使用，因此我们必须分配一个包含 &lt;code&gt;&quot;rust&quot;&lt;/code&gt; 的新 &lt;code&gt;String&lt;/code&gt; 。现在，当将 &lt;code&gt;query&lt;/code&gt; 作为参数传递给 &lt;code&gt;contains&lt;/code&gt; 方法时，我们需要添加一个＆符，因为 &lt;code&gt;contains&lt;/code&gt; 的签名定义为采用字符串切片。</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">请注意，如果任何参数包含无效的Unicode ，则 &lt;code&gt;std::env::args&lt;/code&gt; 将惊慌。如果您的程序需要接受包含无效Unicode的参数，请改用 &lt;code&gt;std::env::args_os&lt;/code&gt; 。该函数返回一个生成 &lt;code&gt;OsString&lt;/code&gt; 值而不是 &lt;code&gt;String&lt;/code&gt; 值的迭代器。为了简单起见，我们选择在这里使用 &lt;code&gt;std::env::args&lt;/code&gt; ，因为 &lt;code&gt;OsString&lt;/code&gt; 值在每个平台上都不同，并且比 &lt;code&gt;String&lt;/code&gt; 值更复杂。</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;zip&lt;/code&gt; 仅产生四对。理论上不会产生第五对 &lt;code&gt;(5, None)&lt;/code&gt; ，因为当 &lt;code&gt;zip&lt;/code&gt; 的任何一个输入迭代器返回 &lt;code&gt;None&lt;/code&gt; 时，zip返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">请注意,Rust没有可选函数参数或变量函数的概念(除了它的C-FFI)。</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">请注意,&quot;尽最大的努力 &quot;来确保存储在线程本地存储中的类型的destructor被运行,但并不是所有的平台都能保证线程本地存储中的所有类型都能运行destructor。例如,有一些已知的注意事项,在这些情况下,destructor不会被运行。</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">请注意， &lt;code&gt;()&lt;/code&gt; -返回 &lt;code&gt;main&lt;/code&gt; 隐式导致成功终止，因此除非您还返回其他可能的代码，否则无需从 &lt;code&gt;main&lt;/code&gt; 返回此函数。</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">请注意,捕获会移动或借用一个变量,但在这种情况下,闭包是借用变量。关于捕捉的更多信息,请看http://rustbyexample.com/fn/closures/capture.html。</target>
        </trans-unit>
        <trans-unit id="d28236ceeda3d941466d94520f9be31d9496ffc8" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;Capturing&lt;/a&gt; in Rust By Example for more information.</source>
          <target state="translated">请注意，捕获将移动或借用变量，但是在这种情况下，闭包正在借用变量。有关更多信息，请参见&amp;ldquo;通过示例&lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;捕获&lt;/a&gt;Rust &amp;rdquo;一章。</target>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">请注意，匹配器只是令牌树。如上所述，&amp;ldquo;简单NT&amp;rdquo;是元变量NT；因此，这是不可重复的。例如， &lt;code&gt;$foo:ty&lt;/code&gt; 是一个简单的NT，但是 &lt;code&gt;$($foo:ty)+&lt;/code&gt; 是一个复杂的NT。</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">请注意，引用的范围从引入它的地方开始，一直持续到最后一次使用该引用。例如，此代码将被编译，因为不可变引用的最后一次使用发生在引入可变引用之前：</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">请注意，如果此通道上有缓冲区，则成功发送并&lt;em&gt;不能&lt;/em&gt;保证接收方会看到数据。可以将项目排队在内部缓冲区中，以供接收者以后接收。但是，如果缓冲区大小为0，则该通道成为会合通道，并且如果此函数返回成功，则可以保证接收方确实已接收到数据。</target>
        </trans-unit>
        <trans-unit id="1f0335bd5206c4df046874965f0d18fc2183ed51" translate="yes" xml:space="preserve">
          <source>Note that accessing the value inside a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; is safe. This means that a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; whose content has been dropped must not be exposed through a public safe API. Correspondingly, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; is unsafe.</source>
          <target state="translated">请注意，访问 &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; 内部的值是安全的。这意味着其内容已被删除的 &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; 不得通过公共安全API公开。相应地， &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; 不安全。</target>
        </trans-unit>
        <trans-unit id="5885b8aa2d181f8795166dedd7f6344e9a60f6b3" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:</source>
          <target state="translated">请注意，某些类型可能无法实现对齐。特别是，它通常不是针对 &lt;code&gt;Debug&lt;/code&gt; 特性实现的。确保应用填充的一种好方法是格式化输入，然后填充此结果字符串以获得输出：</target>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">请注意，某些类型可能无法实现对齐。特别是，它通常不是针对 &lt;code&gt;Debug&lt;/code&gt; 特性实现的。确保应用填充的一种好方法是格式化输入，然后使用该结果字符串填充输出。</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">请注意，所有&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;都是有效的&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;，可以使用 &lt;code&gt;as&lt;/code&gt; 强制转换为一个：</target>
        </trans-unit>
        <trans-unit id="516c2ce158a14ccb1ab369bf0a62cbade5443e81" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;char&lt;/code&gt;s are valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">请注意，所有 &lt;code&gt;char&lt;/code&gt; 都是有效的&lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;，并且可以使用 &lt;code&gt;as&lt;/code&gt; 强制转换为一个：</target>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">请注意，将使用end和返回元素之间的所有元素，包括返回元素。这也意味着在同一迭代器上多次调用 &lt;code&gt;nth_back(0)&lt;/code&gt; 将返回不同的元素。</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">请注意，所有先前的元素以及返回的元素都将从迭代器中使用。这意味着前面的元素将被丢弃，并且在同一迭代器上多次调用 &lt;code&gt;nth(0)&lt;/code&gt; 将返回不同的元素。</target>
        </trans-unit>
        <trans-unit id="491da8d1616c74f297c93c3f76ed9c42830ffa59" translate="yes" xml:space="preserve">
          <source>Note that any code in earlier iterations of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">请注意，即使更新了所用的Rust编译器版本，在已编译&lt;em&gt;的Rust编程语言的&lt;/em&gt;较早版本中&lt;em&gt;的&lt;/em&gt;任何代码也可以在项目的&lt;em&gt;Cargo.toml中&lt;/em&gt;继续编译，而无需使用version &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 。这就是Rust的向后兼容性保证！&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">请注意，即使更新了所用的Rust编译器版本，已编译&lt;em&gt;的Rust编程语言的&lt;/em&gt; &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 印刷中&lt;em&gt;的&lt;/em&gt;所有代码也将继续编译，而无需在项目的&lt;em&gt;Cargo.toml中&lt;/em&gt;使用version =&amp;ldquo; 2018&amp;rdquo;进行编译。这就是Rust的向后兼容性保证！</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">请注意,内部缓冲区的任何剩余数据都会丢失。</target>
        </trans-unit>
        <trans-unit id="2a041883f7bee5eb6e6f55708c727c8ab3a3ed00" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost. Therefore, a following read from the underlying reader may lead to data loss.</source>
          <target state="translated">请注意,内部缓冲区中的任何剩余数据都会丢失。因此,从底层读卡器的后续读取可能会导致数据丢失。</target>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">需要注意的是,由于这个函数永不返回,而且它终止了进程,所以不会运行当前堆栈或任何其他线程堆栈上的析构函数。</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">需要注意的是,由于这个函数永远不会返回,而且它终止了进程,所以不会运行当前堆栈或任何其他线程堆栈上的析构函数。如果需要干净的关机,建议只在一个已知的点上调用这个函数,在这个点上没有更多的destructors可以运行。</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">请注意，由于我们在清单10-13 中的相同&lt;em&gt;lib.rs&lt;/em&gt;中定义了 &lt;code&gt;Summary&lt;/code&gt; trait以及 &lt;code&gt;NewsArticle&lt;/code&gt; 和 &lt;code&gt;Tweet&lt;/code&gt; 类型，因此它们都在同一范围内。假设此&lt;em&gt;lib.rs&lt;/em&gt;用于我们称为 &lt;code&gt;aggregator&lt;/code&gt; 的板条箱，并且其他人希望使用板条箱的功能在其库范围内定义的结构上实现 &lt;code&gt;Summary&lt;/code&gt; 特性。他们将需要首先将特征纳入自己的范围。他们可以通过指定 &lt;code&gt;use aggregator::Summary;&lt;/code&gt; ，这将使他们能够为其类型实现 &lt;code&gt;Summary&lt;/code&gt; 。本 &lt;code&gt;Summary&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;trait还需要成为另一个板条箱实现的公共特征，这是因为在清单10-12中，我们将 &lt;code&gt;pub&lt;/code&gt; 关键字放在 &lt;code&gt;trait&lt;/code&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">请注意，因为我们只用一个泛型类型定义 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; ，这个定义说， &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 结构是通过某种类型的通用 &lt;code&gt;T&lt;/code&gt; ，而字段 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是&lt;em&gt;两个&lt;/em&gt;同类型的，无论该类型也许。如果我们创建一个 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 的实例，该实例具有不同类型的值，如清单10-7所示，我们的代码将无法编译。</target>
        </trans-unit>
        <trans-unit id="ee83d2a98a726eb4d0819a08ff35a51d203bcc33" translate="yes" xml:space="preserve">
          <source>Note that capturing a backtrace can be an expensive operation on some platforms, so this should be used with caution in performance-sensitive parts of code.</source>
          <target state="translated">请注意,在某些平台上,捕捉回溯可能是一个昂贵的操作,因此在对性能敏感的代码部分,应谨慎使用。</target>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">请注意，删除 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 将永远不会调用 &lt;code&gt;T&lt;/code&gt; 的删除代码。如果初始化了 &lt;code&gt;T&lt;/code&gt; ，则有责任确保将其删除。</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">注意，由于方法调用deref强制，简单地调用trait方法将像它们对引用一样起作用，对它们所拥有的值也起作用！这里描述的实现是针对通用上下文的，其中最终类型 &lt;code&gt;T&lt;/code&gt; 是类型参数或本地未知。</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">请注意，空数组 &lt;code&gt;[T; 0]&lt;/code&gt; 与元素类型 &lt;code&gt;T&lt;/code&gt; 具有相同的对齐要求。另请注意，即使零号类型的对齐方式小于或等于数据字段的对齐方式，也会保守地报告该错误。</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">请注意,环境变量名在Windows上不区分大小写(但保留大小写),在其他平台上则区分大小写。</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">请注意，即使 &lt;code&gt;T&lt;/code&gt; 的大小为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL并正确对齐。</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">请注意，即使 &lt;code&gt;T&lt;/code&gt; 的大小为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL。</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">请注意，即使 &lt;code&gt;T&lt;/code&gt; 的大小为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL并正确对齐。</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">请注意，即使有效复制的大小（ &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ）为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL并且正确对齐。</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">请注意，即使有效复制的大小（ &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ）为 &lt;code&gt;0&lt;/code&gt; ，指针也必须为非NULL并且正确对齐。</target>
        </trans-unit>
        <trans-unit id="6c1ad3562574888b0c8c8e999ed33eff7030ffcd" translate="yes" xml:space="preserve">
          <source>Note that even if this panics, the value is considered to be dropped; you must not cause &lt;code&gt;drop&lt;/code&gt; to be called again. This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;ptr::drop_in_place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，即使出现这种情况，该值也被认为已被删除；您一定不能使 &lt;code&gt;drop&lt;/code&gt; 再次被调用。这通常由编译器自动处理，但是在使用不安全的代码时，有时可能会无意间发生，尤其是在使用&lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;ptr::drop_in_place&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">请注意，即使标准库包含 &lt;code&gt;IpAddr&lt;/code&gt; 的定义，我们仍然可以创建和使用自己的定义而不会发生冲突，因为我们尚未将标准库的定义引入我们的范围。我们将在第7章中进一步讨论将类型纳入范围。</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">请注意，可能会添加将来的平台，这些平台也不支持某些原子操作。最大程度的可移植代码将要小心使用哪种原子类型。 &lt;code&gt;AtomicUsize&lt;/code&gt; 和 &lt;code&gt;AtomicIsize&lt;/code&gt; 通常是最可移植的，但即使在那时，它们也并非随处可用。作为参考， &lt;code&gt;std&lt;/code&gt; 库需要指针大小的原子，尽管 &lt;code&gt;core&lt;/code&gt; 不需要。</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">请注意，枚举变量构造函数的通用参数位于变量之后，而不位于枚举之后。例如，您将编写 &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; ，而不是 &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">请注意，这里的&lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;调用是为了清楚起见-表示我们已经完成了给定值，应该销毁它。</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">请注意，如果 &lt;code&gt;Self::Item&lt;/code&gt; 仅是 &lt;code&gt;PartialOrd&lt;/code&gt; ，而不是 &lt;code&gt;Ord&lt;/code&gt; ，则上述定义意味着，如果任意两个连续的项都不可比，则此函数返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">请注意，如果 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 都指向同一个文件，那么该文件将有可能获得通过此操作截断。</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">请注意,如果一个函数接受多个类型参数,但你想让编译器推断出其中的一些参数,你可以使用类型占位符。</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">请注意，如果 &lt;code&gt;static&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 项包含函数或闭包引用，而它们本身也包含引用，则编译器将首先尝试标准省略规则。如果它无法通过其通常的规则来解决生存期，那么它将出错。举例来说：</target>
        </trans-unit>
        <trans-unit id="9ef199153d75a42174c42cff6fb7c6c1476957fd" translate="yes" xml:space="preserve">
          <source>Note that implementations do not necessarily have to provide access to the inner-most source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part of the pipeline and expose its internal storage as source.</source>
          <target state="translated">请注意,实现不一定要提供对管道最内部源的访问。一个有状态的中间适配器可能会急切地评估管道的一部分,并将其内部存储作为源暴露出来。</target>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">需要注意的是,在Rust中,只有当包含非大小类型的字段是结构中最后且唯一的非大小类型字段时,结构才能包含非大小类型。</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">请注意，在某些语言和测试框架中，断言两个值相等的函数的参数称为 &lt;code&gt;expected&lt;/code&gt; 和 &lt;code&gt;actual&lt;/code&gt; ，而指定参数的顺序很重要。但是，在Rust中，它们分别称为 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; ，我们指定期望值的顺序与被测试代码产生的值无关紧要。我们可以在此测试中将断言写为 &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; ，这将导致一条失败消息，显示 &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; ，而 &lt;code&gt;left&lt;/code&gt; 为 &lt;code&gt;5&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; 为 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">请注意，引入另一个 &lt;code&gt;struct&lt;/code&gt; 只是为了在其他属性中占一席之地，可能会对表示形式产生意想不到的副作用：</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">请注意,不可能将本地动态依赖链接到静态库,在这种情况下,所有未链接的本地动态依赖将被打印出警告。</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">注意，不可能从相同方法的重写实现中调用默认实现。</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">请注意,一个流的长度可能会随着时间的推移而改变(例如,当数据被附加到一个文件时)。所以多次调用这个方法不一定每次都返回相同的长度。</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">注意,否定任何正整数都会溢出。</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">请注意，没有其他标准化发生。特别是， &lt;code&gt;a/c&lt;/code&gt; 和 &lt;code&gt;a/b/../c&lt;/code&gt; 是不同的，以考虑 &lt;code&gt;b&lt;/code&gt; 是符号链接（因此其父级不是 &lt;code&gt;a&lt;/code&gt; ）的可能性。</target>
        </trans-unit>
        <trans-unit id="0f36d8aec30ccdcaddeba64d187fcf335e3e550e" translate="yes" xml:space="preserve">
          <source>Note that not all errors contain a &lt;code&gt;Backtrace&lt;/code&gt;. Also note that a &lt;code&gt;Backtrace&lt;/code&gt; may actually be empty. For more information consult the &lt;code&gt;Backtrace&lt;/code&gt; type itself.</source>
          <target state="translated">请注意，并非所有错误都包含 &lt;code&gt;Backtrace&lt;/code&gt; 。另请注意， &lt;code&gt;Backtrace&lt;/code&gt; 实际上可能为空。有关更多信息，请查阅 &lt;code&gt;Backtrace&lt;/code&gt; 类型本身。</target>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">请注意，并非所有平台都将在文件的元数据中保留此字段的更新，例如Windows可以选择在访问文件时禁用此更新，而Linux同样具有 &lt;code&gt;noatime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">请注意，在此输出中没有任何地方可以看到 &lt;code&gt;I got the value 4&lt;/code&gt; ，该值是运行通过的测试时输出的值。该输出已被捕获。测试失败的输出（ &lt;code&gt;I got the value 8&lt;/code&gt; ）出现在测试摘要输出的部分中，该部分还显示了测试失败的原因。</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">请注意，在多次 &lt;code&gt;poll&lt;/code&gt; ，应仅安排从&lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;传递到最近的调用的&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;接收唤醒。</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">注意，不能将 &lt;code&gt;CannotReallocInPlace&lt;/code&gt; 传递给 &lt;code&gt;handle_alloc_error&lt;/code&gt; 函数。客户端应该能够从 &lt;code&gt;grow_in_place&lt;/code&gt; 故障中恢复而不会中止，或者希望在中止之前依靠另一种重新分配方法。</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">注意，不能将 &lt;code&gt;CannotReallocInPlace&lt;/code&gt; 传递给 &lt;code&gt;handle_alloc_error&lt;/code&gt; 函数。期望客户端能够在不中止的情况下从 &lt;code&gt;shrink_in_place&lt;/code&gt; 故障中恢复，或者在诉诸中止之前使用另一种重新分配方法。</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">请注意,Rust中的恐慌并不总是通过解除缠绕来实现,但它们可能通过中止进程来实现。如果当恐慌以这种方式实现时调用这个函数,那么这个函数将中止进程,而不是触发解卷。</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">请注意,这个区块的部分使用。</target>
        </trans-unit>
        <trans-unit id="fff05e35d755803ade4b50f50d29c987f0007787" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;. For example, whether or not &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; has no effect on the behavior of &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">请注意，固定和&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;固定仅影响指向类型 &lt;code&gt;P::Target&lt;/code&gt; ，而不影响包裹在&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;的指针类型 &lt;code&gt;P&lt;/code&gt; 本身。例如，&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;是否为&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;对&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 的行为没有影响（此处 &lt;code&gt;T&lt;/code&gt; 是指向类型）。</target>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">请注意，固定和 &lt;code&gt;Unpin&lt;/code&gt; 固定仅影响指向类型 &lt;code&gt;P::Target&lt;/code&gt; ，而不影响包裹在 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 的指针类型 &lt;code&gt;P&lt;/code&gt; 本身。例如， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 是否为 &lt;code&gt;Unpin&lt;/code&gt; 对 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 的行为没有影响（此处 &lt;code&gt;T&lt;/code&gt; 是指向类型）。</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">请注意,读取会将分片更新为指向尚未读取的部分。当达到EOF时,分片将为空。</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">注意，类似于&lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt;，短读返回不是错误。</target>
        </trans-unit>
        <trans-unit id="78d8286e3fe0bd2fe84e388fefe8408d278761d1" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">请注意，类似于&lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt;，返回短写不是错误。</target>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">请注意，类似于&lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt;，返回短写不是错误。</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">注意，类似于 &lt;code&gt;File::read&lt;/code&gt; ，短读返回不是错误。从短读返回时，文件指针仍会更新。</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">请注意，类似于 &lt;code&gt;File::write&lt;/code&gt; ，返回短写不是错误。从这么短的写入返回时，文件指针仍会更新。</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，某些平台可能只是根据&lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt;实现此目的。</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">注意，默认情况下，stdout通常是行缓冲的，因此可能有必要使用&lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt;来确保立即发出输出。</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">请注意，由于Rust的安全保证，假设我们在此模块中未使用任何同步原语，则访问全局（静态）变量需要使用 &lt;code&gt;unsafe&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 运算符会短路，即，只有对第二个操作数有帮助的结果，他们才求值。由于此行为不能由特征强制执行，所以 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 不支持作为可重载运算符。</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">请注意，每次我们在代码中使用 &lt;code&gt;*&lt;/code&gt; 时， &lt;code&gt;*&lt;/code&gt; 运算符都会被调用 &lt;code&gt;deref&lt;/code&gt; 方法代替，然后仅调用一次 &lt;code&gt;*&lt;/code&gt; 运算符。由于的替代 &lt;code&gt;*&lt;/code&gt; 运算符不递归无限，我们与类型的数据结束了 &lt;code&gt;i32&lt;/code&gt; ，其匹配 &lt;code&gt;5&lt;/code&gt; 中 &lt;code&gt;assert_eq!&lt;/code&gt; 在清单15-9中。</target>
        </trans-unit>
        <trans-unit id="42a41979051d804f1901f27167063da0694efa1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function can be used to ignore these environment variables. Also note that the state of environment variables is cached once the first backtrace is created, so altering &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; at runtime may not actually change how backtraces are captured.</source>
          <target state="translated">请注意，可以使用 &lt;code&gt;Backtrace::force_capture&lt;/code&gt; 函数忽略这些环境变量。还要注意，一旦创建了第一个回溯跟踪，环境变量的状态就会被缓存，因此在运行时更改 &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; 或 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 可能实际上并不会改变捕获回溯跟踪的方式。</target>
        </trans-unit>
        <trans-unit id="2c6dbff824203032252330e130f2e622a82a7979" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;FromFn&lt;/code&gt; 迭代器不对闭包的行为进行假设，因此保守地不会实现&lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; &lt;/a&gt;，也不会从其默认值 &lt;code&gt;(0, None)&lt;/code&gt; 覆盖&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;FromFn&lt;/code&gt; 迭代器不对闭包的行为进行假设，因此保守地不会实现&lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; &lt;/a&gt;，也不会从其默认值 &lt;code&gt;(0, None)&lt;/code&gt; 覆盖&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">请注意，首页上没有列出 &lt;code&gt;PrimaryColor&lt;/code&gt; 和 &lt;code&gt;SecondaryColor&lt;/code&gt; 类型， &lt;code&gt;mix&lt;/code&gt; 功能也没有列出。我们必须单击 &lt;code&gt;kinds&lt;/code&gt; 和 &lt;code&gt;utils&lt;/code&gt; 才能看到它们。</target>
        </trans-unit>
        <trans-unit id="8f49c43ce4bf9debfde5b04db98c0212ba6c8e15" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;SOME_PROPERTY&lt;/code&gt; associated constant would not compile, as its type &lt;code&gt;bool&lt;/code&gt; refers to the struct, rather than to the primitive bool type.</source>
          <target state="translated">请注意，与 &lt;code&gt;SOME_PROPERTY&lt;/code&gt; 相关联的常量将不会编译，因为它的类型 &lt;code&gt;bool&lt;/code&gt; 引用了该结构，而不是原始的bool类型。</target>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">请注意， &lt;code&gt;black&lt;/code&gt; 和 &lt;code&gt;origin&lt;/code&gt; 值是不同的类型，因为它们是不同元组结构的实例。您定义的每个结构都是其自己的类型，即使该结构中的字段具有相同的类型。例如，即使两个类型都由三个 &lt;code&gt;i32&lt;/code&gt; 值组成，但是采用 &lt;code&gt;Color&lt;/code&gt; 类型参数的函数也不能将 &lt;code&gt;Point&lt;/code&gt; 作为参数。否则，元组struct实例的行为类似于元组：您可以将它们分解为各自的片段，可以使用 &lt;code&gt;.&lt;/code&gt; 然后是索引以访问单个值，依此类推。</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">请注意， &lt;code&gt;internal_adder&lt;/code&gt; 函数未标记为 &lt;code&gt;pub&lt;/code&gt; ，但是由于测试只是Rust代码，而 &lt;code&gt;tests&lt;/code&gt; 模块只是另一个模块，因此您可以将 &lt;code&gt;internal_adder&lt;/code&gt; 放入测试的作用域并对其进行调用。如果您不认为应该测试私有功能，那么Rust中没有什么可以迫使您这样做。</target>
        </trans-unit>
        <trans-unit id="1dfcc45249eab2386a4a77c00ed86344264ef031" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">请注意， &lt;code&gt;mod common;&lt;/code&gt; 声明与清单7-21中演示的模块声明相同。然后在测试函数中，我们可以调用 &lt;code&gt;common::setup()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">注意， &lt;code&gt;mod common;&lt;/code&gt; 声明与清单7-25中演示的模块声明相同。然后在测试函数中，我们可以调用 &lt;code&gt;common::setup()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">请注意，&lt;em&gt;src / lib.rs&lt;/em&gt;中的 &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; 语句也没有更改， &lt;code&gt;use&lt;/code&gt; 也不会影响作为crate一部分编译的文件。该 &lt;code&gt;mod&lt;/code&gt; 关键字声明模块和锈看起来具有相同的名称作为该进入该模块的代码模块的文件。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">请注意，Rust语法将 &lt;code&gt;-1i8&lt;/code&gt; 视为一&lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;元减号运算符&lt;/a&gt;对整数文字 &lt;code&gt;1i8&lt;/code&gt; 的应用，而不是单个整数文字。</target>
        </trans-unit>
        <trans-unit id="56aae01ce79d910a619efda10dafe9ed6c6133a8" translate="yes" xml:space="preserve">
          <source>Note that the alignment of the resulting layout will be the maximum of those of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in order to ensure alignment of both parts.</source>
          <target state="translated">请注意，最终布局的对齐方式将是 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 对齐方式的最大值，以确保两个部分的对齐方式。</target>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">请注意，分配器可能会给集合提供比其请求更多的空间。因此，不能依靠容量精确地最小化。如果预计将来会插入，则优先&lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c27c4a17236d84a273debe0206e2acee86fe4f0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">请注意，分配器可能会给集合提供比其请求更多的空间。因此，不能依靠容量来精确地将其最小化。如果预计将来会插入，则优先&lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b0700ca055cbce179ecc3d9a30bb5baa7a6c28e" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">请注意，分配器可能会给集合提供比其请求更多的空间。因此，不能依靠容量来精确地将其最小化。如果预计将来会插入，则优先&lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="088614193a26ec5fa144e1468834aa2d40a502e0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">请注意，分配器可能会给集合提供比其请求更多的空间。因此，不能依靠容量来精确地将其最小化。如果预计将来会插入，则优先&lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e71fe50cc784bf479a83f567c5fb33ac0db88d1d" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">请注意，分配器可能会给集合提供比其请求更多的空间。因此，不能依靠容量来精确地将其最小化。如果预计将来会插入，则优先&lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">请注意，分配器可能会给集合提供比其请求更多的空间。因此，不能依靠容量来精确地最小化。如果预计将来会插入，则优先 &lt;code&gt;reserve&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">请注意,分配器给集合的空间可能比它请求的更多。因此,不能依靠容量精确到最小。如果预计未来会有插入,则优先选择保留。</target>
        </trans-unit>
        <trans-unit id="08c862951a6a3b03e0330454b0efc29b2b754947" translate="yes" xml:space="preserve">
          <source>Note that the argument is not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="translated">请注意,参数不是通过shell传递的,而是按字面意思给程序的,这意味着shell语法如引号、转义字符、分词、glob模式、替换等没有任何效果。这意味着shell语法,如引号、转义字符、分词、glob模式、替换等都没有效果。</target>
        </trans-unit>
        <trans-unit id="ba0769350c5d5d78015e993d43a239511a252097" translate="yes" xml:space="preserve">
          <source>Note that the arguments are not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="translated">注意,参数不是通过shell传递的,而是按字面意思给程序的。这意味着shell语法,如引号、转义字符、分词、glob模式、替换等都没有效果。</target>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">需要注意的是,尽量保证等待的时间是用单调的时钟测量的,不受系统时间变化的影响。</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">请注意，已尽最大努力确保使用单调时钟测量等待的时间，并且不受系统时间更改的影响。此功能易受虚假唤醒的影响。条件变量通常具有与之关联的布尔谓词，并且每次该函数返回时都必须始终检查谓词，以防止虚假唤醒。另外，尽管有虚假的唤醒，通常还是希望超时不超过某个持续时间，因此睡眠时间会减少睡眠量。另外，也可以使用 &lt;code&gt;wait_timeout_until&lt;/code&gt; 方法来等待，直到达到条件且总超时为止，而不管虚假唤醒如何。</target>
        </trans-unit>
        <trans-unit id="a6a58cc27a5e657fb0a670643552701080e58296" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_while&lt;/code&gt; method to wait with a timeout while a predicate is true.</source>
          <target state="translated">请注意，已尽最大努力确保使用单调时钟来测量等待的时间，并且不受系统时间更改的影响。此功能易受虚假唤醒的影响。条件变量通常具有与之关联的布尔谓词，并且每次该函数返回时都必须始终检查谓词，以防止虚假唤醒。另外，尽管有虚假的唤醒，但通常还是希望超时不超过某个持续时间，因此睡眠时间会减少睡眠量。或者，在谓词为true时，使用 &lt;code&gt;wait_timeout_while&lt;/code&gt; 方法等待超时。</target>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">请注意， &lt;code&gt;self&lt;/code&gt; 的能力不会改变。</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">注意整个实例必须是可变的。Rust不允许我们仅将某些字段标记为可变字段。与任何表达式一样，我们可以构造该结构的新实例作为函数主体中的最后一个表达式，以隐式返回该新实例。</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">请注意，这里的错误在于通用函数的定义：尽管我们仅使用实现 &lt;code&gt;Debug&lt;/code&gt; 的参数来调用它，但编译器仍拒绝该函数：它必须适用于所有可能的输入类型。为了编译该示例，我们需要限制我们接受的泛型类型：</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">请注意,输入令牌的扩展结果将来可能会改变。如果你依赖输出,你应该小心。</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，最里面的对象设置了边界，因此 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; 仍然是 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">注意,小写的点 &quot;i &quot;与拉丁文相同。因此。</target>
        </trans-unit>
        <trans-unit id="0529503c0b783f1fa295149899ee5a9048a3f3e4" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">请注意，该宏旨在用作调试工具，因此，应避免长时间在版本控制中使用该宏。涉及调试输出的用例应添加到版本控制中，这样的宏可以更好地服务于诸如&lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;的宏！从&lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;箱中。</target>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">请注意，该宏旨在用作调试工具，因此，应避免长时间在版本控制中使用该宏。涉及调试输出的用例应添加到版本控制中，这样的宏可以更好地服务于&lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;的宏！从&lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;箱中。</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">请注意，测试的输出和测试结果是交错的；原因是测试是并行运行的，正如我们在上一节中讨论的那样。尝试使用 &lt;code&gt;--test-threads=1&lt;/code&gt; 选项和 &lt;code&gt;--nocapture&lt;/code&gt; 标志，然后查看输出结果！</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">请注意，该指针值可能表示代表 &lt;code&gt;T&lt;/code&gt; 的有效指针，这意味着不得将其用作&amp;ldquo;尚未初始化&amp;rdquo;的前哨值。延迟分配的类型必须通过其他某种方式来跟踪初始化。</target>
        </trans-unit>
        <trans-unit id="219a901fc4bbd905770e11b959092de46ce1a4b3" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">请注意,指针值有可能代表一个有效的指针,这意味着不能将其用作 &quot;尚未初始化 &quot;的哨兵值。懒惰分配的类型必须通过其他方式跟踪初始化。</target>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">请注意，主线程的堆栈大小&lt;em&gt;不是&lt;/em&gt;由Rust确定的。</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">请注意，标准库（ &lt;code&gt;std&lt;/code&gt; ）也是我们包外部的板条箱。因为标准库是随Rust语言一起提供的，所以我们不需要更改&lt;em&gt;Cargo.toml&lt;/em&gt;以包含 &lt;code&gt;std&lt;/code&gt; 。但是，我们确实需要提到它与 &lt;code&gt;use&lt;/code&gt; 带来的物品从那里进入我们的包的范围。例如，对于 &lt;code&gt;HashMap&lt;/code&gt; ,我们将使用以下行：</target>
        </trans-unit>
        <trans-unit id="81d14f271d71ceb8a4e63a395e2c2b18f3026e6e" translate="yes" xml:space="preserve">
          <source>Note that the traits &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../convert/trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">请注意，特征&lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../convert/trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt;为可能不是固定大小的数组的类型提供了类似的方法。实施者应该更喜欢这些特征。</target>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">请注意,性状AsRef和AsMut为可能不是固定大小的数组的类型提供了类似的方法。实现者应该选择这些特性。</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">注意，现在可以从 &lt;code&gt;temp&lt;/code&gt; 的类型推断 &lt;code&gt;v&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">需要注意的是底层的迭代器仍然是先进的时候&lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt;被称为首次：为了检索下一个元素，&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;被称为在底层迭代器，因此任何副作用的（即不是获取下一个值以外的任何东西）&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;方法将发生。</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">请注意，对于整个分配的内存块，返回值的用途要求 &lt;code&gt;align&lt;/code&gt; 小于或等于起始地址的对齐。满足此约束的一种方法是确保 &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">请注意，枚举的变体在其标识符下命名空间，并且我们使用双冒号将两者分开。之所以有用，是因为现在两个值 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 和 &lt;code&gt;IpAddrKind::V6&lt;/code&gt; 都属于同一类型： &lt;code&gt;IpAddrKind&lt;/code&gt; 。例如，我们然后可以定义一个接受任何 &lt;code&gt;IpAddrKind&lt;/code&gt; 的函数：</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">请注意，仅使用 &lt;code&gt;_&lt;/code&gt; 和以下划线开头的名称之间存在细微差别。语法 &lt;code&gt;_x&lt;/code&gt; 仍将值绑定到变量，而 &lt;code&gt;_&lt;/code&gt; 根本不绑定。为了说明这种区别很重要的情况，清单18-21将给我们提供一个错误。</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">请注意,不保证文件会被立即删除(例如,根据平台的不同,其他打开的文件描述符可能会阻止立即删除)。</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">请注意，两个 &lt;code&gt;Match&lt;/code&gt; es 之间可能有多个 &lt;code&gt;Reject&lt;/code&gt; ，没有要求将它们组合为一个。</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">请注意，这些输出是可堆叠的，如果指定了多个，则编译器将立即生成每种形式的输出，而无需重新编译。但是，这仅适用于用相同方法指定的输出。如果仅指定 &lt;code&gt;crate_type&lt;/code&gt; 属性，则将全部构建它们，但是如果指定一个或多个 &lt;code&gt;--crate-type&lt;/code&gt; 命令行标志，则仅将构建那些输出。</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，这些要求意味着特征本身必须对称且可传递地实现：如果 &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; 和 &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; 则 &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，这些要求意味着特征本身必须对称且可传递地实现：如果 &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; 和 &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; 则 &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">请注意，此 &lt;code&gt;let&lt;/code&gt; 语句意味着 &lt;code&gt;expensive_closure&lt;/code&gt; 包含匿名函数的&lt;em&gt;定义&lt;/em&gt;，而不是调用匿名函数的&lt;em&gt;结果值&lt;/em&gt;。回想一下我们使用闭包的原因，因为我们想定义代码以便在某一时刻调用，存储该代码并在以后一点调用；现在，我们要调用的代码存储在 &lt;code&gt;expensive_closure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">注意，这种方法需要与寿命参考小号 &lt;code&gt;'a&lt;/code&gt; 。短于 &lt;code&gt;'a&lt;/code&gt; 就足够了：较短的生存期意味着 &lt;code&gt;demo&lt;/code&gt; 完成执行后，在较短的生存期结束后，其他内容（例如析构函数！）可以访问 &lt;code&gt;s.data&lt;/code&gt; ，这再次违反了 &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrow的专有规定。访问。</target>
        </trans-unit>
        <trans-unit id="c27fe5a5d1e022b605f9e160ee6f188847c0730a" translate="yes" xml:space="preserve">
          <source>Note that this behavior is a consequence of the desugaring to a function that returns an &lt;code&gt;impl Future&lt;/code&gt; -- in this case, the function we desugar to is an &lt;code&gt;unsafe&lt;/code&gt; function, but the return value remains the same.</source>
          <target state="translated">请注意，此行为是由于对返回一个 &lt;code&gt;impl Future&lt;/code&gt; 的函数进行减重操作的结果-在这种情况下，我们将子函数转换为 &lt;code&gt;unsafe&lt;/code&gt; 函数，但是返回值保持不变。</target>
        </trans-unit>
        <trans-unit id="d559316d5513a320d9bd5dde1c5db0aa4a3ef581" translate="yes" xml:space="preserve">
          <source>Note that this differs from the behavior of &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt;&lt;code&gt;Rc::make_mut&lt;/code&gt;&lt;/a&gt; which disassociates any remaining &lt;code&gt;Weak&lt;/code&gt; pointers.</source>
          <target state="translated">请注意，这与&lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt; &lt;code&gt;Rc::make_mut&lt;/code&gt; &lt;/a&gt;的行为不同，后者会取消关联所有剩余的 &lt;code&gt;Weak&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">请注意，这并&lt;strong&gt;没有&lt;/strong&gt;返回字符串操作系统形式在字符串中的字节数。</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">请注意，这不会移动 &lt;code&gt;v&lt;/code&gt; （与 &lt;code&gt;transmute&lt;/code&gt; 不同），并且可能需要调用 &lt;code&gt;mem::forget(v)&lt;/code&gt; ，以防止避免调用析构函数。</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">请注意，此示例使用 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 用于单线程方案。如果在多线程情况下需要共享可变性，请考虑使用 &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">请注意，该示例尚未编译。我们稍后会解释原因。</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">请注意，此功能&lt;strong&gt;可能无法捕获&lt;/strong&gt; Rust中的&lt;strong&gt;所有紧急情况&lt;/strong&gt;。Rust中的恐慌并不总是通过平仓来实现，但是也可以通过中止该过程来实现。此功能&lt;em&gt;仅&lt;/em&gt;捕获正在缓解的紧急情况，而不会中止该过程的紧急情况。</target>
        </trans-unit>
        <trans-unit id="d3651367d7bc20ea65e217082fe9e78b8f819776" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f32&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="translated">请注意，此功能并不总是与 &lt;code&gt;f32&lt;/code&gt; 的&lt;a href=&quot;cmp/trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;实现一致。特别是，他们将负零和正零视为相等，而 &lt;code&gt;total_cmp&lt;/code&gt; 则不同。</target>
        </trans-unit>
        <trans-unit id="2d6a1415dd489b9fd2f261b68de74159561b45e0" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f64&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="translated">请注意，此功能并不总是与&lt;a href=&quot;cmp/trait.partialord&quot;&gt; &lt;code&gt;PartialOrd&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;f64&lt;/code&gt; 。特别是，他们将负零和正零视为相等，而 &lt;code&gt;total_cmp&lt;/code&gt; 则不同。</target>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">请注意，此函数 &lt;code&gt;as&lt;/code&gt; 强制转换不同，后者试图保留&lt;em&gt;数字&lt;/em&gt;值而不是按位值。</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">请注意，此功能与&lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;相同，只是专门用于切片。如果并且当Rust获得专业化时，此功能可能会被弃用（但仍然可用）。</target>
        </trans-unit>
        <trans-unit id="0f406b6d417033b808228cce14b8dbb1120d5c7d" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;struct.vec#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">请注意，此功能与&lt;a href=&quot;struct.vec#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;相同，只是它专门用于切片。如果并且当Rust获得专业化时，此功能可能会被弃用（但仍然可用）。</target>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">请注意,这个函数很容易被虚假唤醒。条件变量通常有一个与之相关的布尔谓词,每次函数返回时必须检查谓词,以防止虚假唤醒。</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">请注意,该函数在执行解析时可能会阻塞当前线程。</target>
        </trans-unit>
        <trans-unit id="380b102b57d47b1e80ead440741eb736cbc5acae" translate="yes" xml:space="preserve">
          <source>Note that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">请注意,如果初始值也是NaN,则该函数返回NaN。</target>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">请注意，这&lt;em&gt;也&lt;/em&gt;不同于Windows-1252 aka代码页1252，后者是ISO / IEC 8859-1的超集，该集将一些（不是全部！）空格分配给标点符号和各种拉丁字符。</target>
        </trans-unit>
        <trans-unit id="c12e3030c3946db5f00ad56e92693e7a60e9d4f4" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_left&quot;&gt;&lt;code&gt;rotate_left&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="translated">请注意，这是&lt;em&gt;不&lt;/em&gt;一样的左旋转; 环绕左移的RHS限于该类型的范围，而不是从LHS移出的位返回到另一端。所有原始整数类型都实现了&lt;a href=&quot;#method.rotate_left&quot;&gt; &lt;code&gt;rotate_left&lt;/code&gt; &lt;/a&gt;函数，而您可能想要的就是该函数。</target>
        </trans-unit>
        <trans-unit id="d05d921ff847b716a1e90578f4bb30e691402415" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;[&lt;/code&gt;rotate_left`](#method.rotate_left) function, which may be what you want instead.</source>
          <target state="translated">请注意，这是&lt;em&gt;不&lt;/em&gt;一样的左旋转; 环绕左移的RHS限于该类型的范围，而不是从LHS移出的位返回到另一端。所有原始整数类型均实现 &lt;code&gt;[&lt;/code&gt; rotate_left`]（＃method.rotate_left）函数，而您可能想要的是该函数。</target>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">请注意，这是&lt;em&gt;不&lt;/em&gt;一样的左旋转; 环绕左移的RHS限于该类型的范围，而不是从LHS移出的位返回到另一端。所有原始整数类型都实现了 &lt;code&gt;rotate_left&lt;/code&gt; 函数，而您可能想要的就是该函数。</target>
        </trans-unit>
        <trans-unit id="3efbf7b6ffbe371fa44b1cbc24ab53cb5dc43bf3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_right&quot;&gt;&lt;code&gt;rotate_right&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="translated">请注意，这是&lt;em&gt;不&lt;/em&gt;一样的一个旋转右; 环绕右移的RHS限制在类型的范围内，而不是从LHS移出的位返回到另一端。所有原始整数类型都实现了&lt;a href=&quot;#method.rotate_right&quot;&gt; &lt;code&gt;rotate_right&lt;/code&gt; &lt;/a&gt;函数，而您可能想要的是该函数。</target>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">请注意，这是&lt;em&gt;不&lt;/em&gt;一样的一个旋转右; 环绕右移的RHS限制在类型范围内，而不是从LHS移出的位返回到另一端。所有原始整数类型都实现了 &lt;code&gt;rotate_right&lt;/code&gt; 函数，而您可能想要这么做。</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">请注意,这与ISO/IEC 8859-1又名ISO 8859-1(少了一个连字符)不同,后者留下了一些 &quot;空白&quot;,即没有分配给任何字符的字节值。ISO-8859-1(IANA的那个)把它们分配给C0和C1控制码。</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">请注意,目前还没有完全支持。</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">请注意,随着未来的澄清,这个列表可能会随着时间的推移而有所调整。</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">请注意,这可能对IPv6套接字没有任何影响。</target>
        </trans-unit>
        <trans-unit id="75b3dfc6f40c762d7bf2bac499b7412fe6b10302" translate="yes" xml:space="preserve">
          <source>Note that this may not have any effect on IPv6 sockets.</source>
          <target state="translated">请注意,这可能对IPv6套接字没有任何影响。</target>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">请注意，即使采用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，该方法也会更改基础文件的内容。</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">请注意，即使使用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，该方法也会更改基础文件的权限。</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">请注意，无论返回的布局是否具有不同的对齐方式，此方法都不会在整体大小上添加任何填充。换句话说，如果 &lt;code&gt;K&lt;/code&gt; 具有大小为16， &lt;code&gt;K.align_to(32)&lt;/code&gt; 将&lt;em&gt;仍然&lt;/em&gt;具有尺寸16。</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">请注意,此方法对字符串的分配容量没有影响。</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">请注意,这种方法对向量的分配容量没有影响。</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">请注意，此结构&lt;strong&gt;不是&lt;/strong&gt; &lt;code&gt;repr(C)&lt;/code&gt; ，建议不要将其放在FFI函数的签名中。相反，FFI函数的安全包装器可能会利用不安全的&lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; &lt;/a&gt;构造函数为其他使用者提供安全的接口。</target>
        </trans-unit>
        <trans-unit id="9aac27458abae34c90a97df1aff42a3fdeee40a4" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt;&lt;code&gt;CStr::from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">请注意，此结构&lt;strong&gt;不是&lt;/strong&gt; &lt;code&gt;repr(C)&lt;/code&gt; ，不建议将其放置在FFI函数的签名中。相反，FFI函数的安全包装器可能会利用不安全的&lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt; &lt;code&gt;CStr::from_ptr&lt;/code&gt; &lt;/a&gt;构造函数为其他使用者提供安全的接口。</target>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">请注意,这种技术也可以用于匹配表达式的武器。</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">请注意,这将掉落任何多余的容量。</target>
        </trans-unit>
        <trans-unit id="6affebf246a6b9323b472569ce7b0d2dca1b6504" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; this iterator is &lt;strong&gt;not&lt;/strong&gt; fused. It is also not specified what this iterator returns after the first&lt;code&gt; None&lt;/code&gt; is returned. If you need fused iterator, use &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，与&lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt;不同，此迭代器&lt;strong&gt;未&lt;/strong&gt;融合。在返回第一个 &lt;code&gt; None&lt;/code&gt; 之后，也没有指定此迭代器返回什么。如果需要带保险丝的迭代器，请使用&lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;fuse&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">请注意，与 &lt;code&gt;wait&lt;/code&gt; 不同，此函数不会尝试删除stdin。</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">请注意，与数组表达式不同，此语法支持实现&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; 的&lt;/a&gt;所有元素，并且元素的数量不必为常数。</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">需要注意的是,非大小类型有很多可能的空指针,因为只考虑原始数据指针,不考虑它们的长度、vtable等。因此,两个为空的指针可能仍然不能相互比较相等。</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">请注意，将来可能不需要以这种方式使用 &lt;code&gt;self&lt;/code&gt; 。Rust开发人员正在努力消除的语言不一致。</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">请注意，在这里无法使用 &lt;code&gt;type&lt;/code&gt; 关键字，因为 &lt;code&gt;type&lt;/code&gt; 仅引入了类型别名：</target>
        </trans-unit>
        <trans-unit id="bb6b42394e9bea5f3f448212418ce1a68b9d76c5" translate="yes" xml:space="preserve">
          <source>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</source>
          <target state="translated">请注意,使用这些特质方法将导致每次函数调用的堆分配。这对于绝大多数应用程序来说并不是一个重要的成本,但是在决定是否在一个低级函数的公共API中使用这个功能时,应该考虑到这个问题,因为这个函数预计每秒会被调用数百万次。</target>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">请注意,没有手动指定判别符的变体从0开始从上到下编号,所以看似不相关的变体也会发生冲突。</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">请注意，我们在此处添加了类型注释。因为我们没有在此向量中插入任何值，所以Rust不知道我们打算存储哪种元素。这是重要的一点。向量是使用泛型实现的；我们将在第10章中介绍如何将泛型与您自己的类型一起使用。现在，您知道标准库提供的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 类型可以容纳任何类型，并且当特定向量拥有特定类型时，该类型为在尖括号中指定。在清单8-1中，我们已经告诉锈的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;code&gt;v&lt;/code&gt; 将持有的元素 &lt;code&gt;i32&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">请注意，我们添加了包含布尔值的 &lt;code&gt;case_sensitive&lt;/code&gt; 字段。接下来，我们需要 &lt;code&gt;run&lt;/code&gt; 函数来检查 &lt;code&gt;case_sensitive&lt;/code&gt; 字段的值，并使用该值来决定是调用 &lt;code&gt;search&lt;/code&gt; 函数还是 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数，如清单12-22所示。请注意，这仍然不会编译。</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">注意，我们不需要将生成的 &lt;code&gt;split_at_mut&lt;/code&gt; 函数标记为 &lt;code&gt;unsafe&lt;/code&gt; ，我们可以从安全的Rust调用此函数。我们通过以安全方式使用 &lt;code&gt;unsafe&lt;/code&gt; 代码的函数的实现创建了对不安全代码的安全抽象，因为该函数仅从该函数可访问的数据中创建有效指针。</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">请注意，我们必须在 &lt;code&gt;impl&lt;/code&gt; 之后声明 &lt;code&gt;T&lt;/code&gt; ，以便可以使用它来指定我们要在 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 类型上实现方法。通过在 &lt;code&gt;impl&lt;/code&gt; 之后将 &lt;code&gt;T&lt;/code&gt; 声明为通用类型，Rust可以识别 &lt;code&gt;Point&lt;/code&gt; 中尖括号中的类型是通用类型，而不是具体类型。</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">请注意，由于必须使用名为 &lt;code&gt;to_string&lt;/code&gt; 的多个函数，因此必须使用前面在&lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;高级特性&amp;rdquo;&lt;/a&gt;部分中讨论的完全限定的语法。在这里，我们使用 &lt;code&gt;ToString&lt;/code&gt; 特性中定义的 &lt;code&gt;to_string&lt;/code&gt; 函数，标准库已为实现 &lt;code&gt;Display&lt;/code&gt; 的任何类型实现了此特性。</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">请注意，正如我们在第10章中讨论的那样，我们需要此方法的生命周期批注。我们将对 &lt;code&gt;post&lt;/code&gt; 的引用作为参数，并返回对该 &lt;code&gt;post&lt;/code&gt; 一部分的引用，因此返回的引用的生命周期与 &lt;code&gt;post&lt;/code&gt; 参数的生存期。</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">请注意，我们需要先 &lt;code&gt;use&lt;/code&gt; 的 &lt;code&gt;HashMap&lt;/code&gt; 的标准库中的馆藏部分。在我们的三个常见集合中，该集合是最不常用的集合，因此未包含在序幕中自动纳入范围的功能中。哈希图也没有得到标准库的支持。例如，没有内置的宏来构造它们。</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">注意，我们需要在左侧 &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 。这是因为我们可以改为收集例如&lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">请注意，我们需要使 &lt;code&gt;v1_iter&lt;/code&gt; 可变：在迭代器上调用 &lt;code&gt;next&lt;/code&gt; 方法将更改迭代器用来跟踪其在序列中的位置的内部状态。换句话说，此代码&lt;em&gt;消耗&lt;/em&gt;或&lt;em&gt;消耗&lt;/em&gt;了迭代器。每次调用 &lt;code&gt;next&lt;/code&gt; 都会消耗迭代器中的一个项目。使用 &lt;code&gt;for&lt;/code&gt; 循环时，我们不需要使 &lt;code&gt;v1_iter&lt;/code&gt; 可变，因为该循环获得了 &lt;code&gt;v1_iter&lt;/code&gt; 的所有权并使其在后台可变。</target>
        </trans-unit>
        <trans-unit id="5994cd1512c44aaad650a1803fdb7c349136ad1d" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. Refer to the &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;String Slices as Parameters&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</source>
          <target state="translated">请注意，我们希望函数采用字符串切片（它们是引用），因为我们不希望 &lt;code&gt;longest&lt;/code&gt; 函数采用其参数的所有权。有关为什么为什么在清单10-20中使用的参数是我们想要的参数的更多讨论，请参见第4章中的&lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;将字符串切片作为参数&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">请注意，我们希望函数采用字符串切片（即引用），因为我们不希望 &lt;code&gt;longest&lt;/code&gt; 函数采用其参数的所有权。我们要允许该函数接受 &lt;code&gt;String&lt;/code&gt; 的切片（存储在变量 &lt;code&gt;string1&lt;/code&gt; 中的类型）以及字符串文字（变量 &lt;code&gt;string2&lt;/code&gt; 包含的内容）。</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">请注意，我们在 &lt;code&gt;tests&lt;/code&gt; 模块内添加了新行： &lt;code&gt;use super::*;&lt;/code&gt; 。该 &lt;code&gt;tests&lt;/code&gt; 模块是遵循我们在第7章中所涉及的通常可见性规则的规则模块&lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;模块为隐私边界&amp;rdquo;&lt;/a&gt;一节。因为 &lt;code&gt;tests&lt;/code&gt; 模块是内部模块，所以我们需要将外部模块中的测试代码带入内部模块的范围。我们在这里使用glob，因此我们在外部模块中定义的任何内容都可用于此 &lt;code&gt;tests&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="8e05c11c9aa8615f8372dccd3f7625301eed4295" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">请注意，我们在 &lt;code&gt;tests&lt;/code&gt; 模块内添加了新行： &lt;code&gt;use super::*;&lt;/code&gt; 。所述 &lt;code&gt;tests&lt;/code&gt; 模块是如下我们在第7章中所覆盖的通常的可见性规则的规则模块&lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;路径为参考模块树中的项目&amp;rdquo;&lt;/a&gt;部分。因为 &lt;code&gt;tests&lt;/code&gt; 模块是内部模块，所以我们需要将外部模块中的测试代码带入内部模块的范围。我们在这里使用glob，因此我们在外部模块中定义的任何内容都可用于此 &lt;code&gt;tests&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">请注意，我们也已经编辑了旧测试的 &lt;code&gt;contents&lt;/code&gt; 。我们在文本中添加了新行 &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; 当我们以区分大小写的方式进行搜索时，使用的首字母D不应与查询 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 匹配。以这种方式更改旧测试有助于确保我们不会意外破坏已经实现的区分大小写的搜索功能。该测试现在应该通过，并且在我们进行不区分大小写的搜索时应该继续通过。</target>
        </trans-unit>
        <trans-unit id="2e87959963706a5a2e57c9724a365d2a982bba5d" translate="yes" xml:space="preserve">
          <source>Note that when the wildcard &lt;code&gt;*&lt;/code&gt; is used on a type, it does not import its methods (though for &lt;code&gt;enum&lt;/code&gt;s it imports the variants, as shown in the example below).</source>
          <target state="translated">请注意，在类型上使用通配符 &lt;code&gt;*&lt;/code&gt; 时，它不会导入其方法（尽管对于 &lt;code&gt;enum&lt;/code&gt; 来说，它会导入变量，如下面的示例所示）。</target>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，在发生联系的地方，&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;通常会比&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;快，而&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;通常会比&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;快。</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">请注意,虽然在Rust中对环境变量的并发访问是安全的,但有些平台只公开了本质上不安全的非线程安全API来检查环境。因此,在审计对不安全的外部FFI函数的调用时,需要格外小心,以确保任何外部环境访问与Rust中的访问正确同步。</target>
        </trans-unit>
        <trans-unit id="d3954c01ae7015c1edc03c422ae6922dcf56ba11" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">请注意,虽然在Rust中对环境变量的并发访问是安全的,但有些平台只公开了本质上不安全的非线程安全API来检查环境。因此,在审计对不安全的外部FFI函数的调用时,需要格外小心,以确保任何外部环境访问与Rust中的访问正确同步。</target>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">请注意，虽然可以对 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 的内容进行突变或可变别名（如果您以其他方式强制执行不变式），但是具有多个 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 别名仍然是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="f5bec177fd61b6b3b97ae7f2a117594bad43deaa" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a &lt;em&gt;safe&lt;/em&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="translated">请注意，虽然可以 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; （即使其他 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 引用该单元格为别名）也可以（只要以其他方式实施上述不变式即可），但具有多个 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 别名。也就是说， &lt;code&gt;UnsafeCell&lt;/code&gt; 是一个包装程序，旨在与&lt;em&gt;共享&lt;/em&gt;访问进行特殊交互（&lt;em&gt;即&lt;/em&gt;，通过 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; 引用）；处理&lt;em&gt;独占&lt;/em&gt;访问（&lt;em&gt;例如&lt;/em&gt;，通过 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; ）时，没有任何魔术：在该持续时间内，单元格和包装值都不能被别名 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 借用。这是由展示&lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt; &lt;code&gt;.get_mut()&lt;/code&gt; &lt;/a&gt;存取器，这是一种&lt;em&gt;安全的&lt;/em&gt;吸气剂那收益率 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9eb90457458f8170cc06094675d04f9c0e8116dd" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a non-&lt;code&gt;unsafe&lt;/code&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="translated">请注意，虽然可以 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; （即使其他 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 引用该单元格为别名）也可以（只要以其他方式实施上述不变式即可），但具有多个 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 别名。也就是说， &lt;code&gt;UnsafeCell&lt;/code&gt; 是一个包装程序，旨在与&lt;em&gt;共享&lt;/em&gt;访问进行特殊交互（&lt;em&gt;即&lt;/em&gt;，通过 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; 引用）；处理&lt;em&gt;独占&lt;/em&gt;访问（&lt;em&gt;例如&lt;/em&gt;，通过 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; ）时，没有任何魔术：在该持续时间内，单元格和包装值都不能被别名 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 借用。这是由展示&lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt; &lt;code&gt;.get_mut()&lt;/code&gt; &lt;/a&gt;存取器，它是一种非 &lt;code&gt;unsafe&lt;/code&gt; 吸气剂那收益率 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">请注意,使用这个函数,当主线程结束时,新线程将被停止,无论它是否已经完成运行。这个程序的输出可能每次都有些不同,但看起来会类似于下面。</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">请注意,写入会更新分片,指向尚未写入的部分。当它被完全覆盖时,分片将是空的。</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">请注意，您不能使用&lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; 。&lt;/a&gt;不返回&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;函数中的运算符。相反，您可以调用&lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt;或在返回值上进行 &lt;code&gt;match&lt;/code&gt; 以捕获任何可能的错误：</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">请注意，尽管读写方法需要 &lt;code&gt;&amp;amp;mut File&lt;/code&gt; ，但是由于&lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;的接口， &lt;code&gt;&amp;amp;File&lt;/code&gt; 的持有者仍可以通过采用 &lt;code&gt;&amp;amp;File&lt;/code&gt; 的方法或通过检索基础OS对象并修改文件来修改文件。那样。此外，许多操作系统允许通过不同的进程同时修改文件。避免假定持有 &lt;code&gt;&amp;amp;File&lt;/code&gt; 表示文件不会更改。</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">请注意，由于 &lt;code&gt;$crate&lt;/code&gt; 引用当前的条板箱，因此在引用非宏项目时必须与标准模块路径一起使用：</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">请注意，就像 &lt;code&gt;Option&lt;/code&gt; 枚举一样， &lt;code&gt;Result&lt;/code&gt; 枚举及其变体已被序言纳入范围，因此我们无需在 &lt;code&gt;match&lt;/code&gt; 臂中的 &lt;code&gt;Ok&lt;/code&gt; 和 &lt;code&gt;Err&lt;/code&gt; 变体之前指定 &lt;code&gt;Result::&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">请注意，与 &lt;code&gt;repeat&lt;/code&gt; 不同，即使给定的 &lt;code&gt;self&lt;/code&gt; 实例正确对齐， &lt;code&gt;repeat_packed&lt;/code&gt; 也不保证 &lt;code&gt;self&lt;/code&gt; 的重复实例将正确对齐。换句话说，如果 &lt;code&gt;repeat_packed&lt;/code&gt; 返回的布局用于分配数组，则不能保证数组中的所有元素都将正确对齐。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">请注意:</target>
        </trans-unit>
        <trans-unit id="fc7308ef65a4b47d9c6953435d548f4e965b07bd" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">请注意基元&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;slice/index&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;（也称为&amp;ldquo;切片&amp;rdquo;）的文档。实际上，通过&lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref强制&lt;/a&gt;，对&lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;许多方法调用实际上分别是对&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;slice/index&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;上的方法的调用。</target>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">请注意基元&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;（也称为&amp;ldquo;切片&amp;rdquo;）的文档。实际上，通过&lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref强制&lt;/a&gt;，对&lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;许多方法调用实际上分别是对&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;上的方法的调用。</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">执行者须知</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">给实现者的注意：如果返回 &lt;code&gt;Ok(ptr)&lt;/code&gt; ，则 &lt;code&gt;ptr&lt;/code&gt; 必须被视为&amp;ldquo;当前分配&amp;rdquo;，并且必须是 &lt;code&gt;realloc&lt;/code&gt; 或 &lt;code&gt;dealloc&lt;/code&gt; 之类的方法的可接受输入，&lt;em&gt;即使&lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 是零大小的类型。换句话说，如果您的 &lt;code&gt;Alloc&lt;/code&gt; 实现以可以返回零大小的 &lt;code&gt;ptr&lt;/code&gt; 的方式覆盖此方法，则需要类似地重写所有重新分配和取消分配方法，以接受此类值作为输入。</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请在此处注意两个细节。首先，我们使用 &lt;code&gt;2&lt;/code&gt; 的索引值来获取第三个元素：向量从0开始按数字索引。其次，获取第三个元素的两种方法是使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;[]&lt;/code&gt; 给我们提供引用，或者使用 &lt;code&gt;get&lt;/code&gt; 方法将索引作为参数传递给我们，这给了我们 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c6f9d9871d6089da68d73e5351d58428691fe43" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">注意，内部的 &lt;code&gt;OsString&lt;/code&gt; 和&lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;不一定以平台固有的形式保存字符串。在Unix上，字符串存储为8位值的序列，而在Windows上，字符串如前所述是基于16位值的，而字符串实际上也存储为8位值的序列，其编码方式为： UTF-8的严格变体。这对于理解处理容量和长度值时很有用。</target>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">注意， &lt;code&gt;OsString&lt;/code&gt; 和 &lt;code&gt;OsStr&lt;/code&gt; 在内部不一定以平台固有的形式保存字符串。在Unix上，字符串存储为8位值的序列，而在Windows上，字符串如前所述是基于16位值的，而字符串实际上也存储为8位值的序列，其编码方式为UTF-8的严格变体。了解处理容量和长度值时，这很有用。</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">但是请注意，不能保证瞬间&lt;strong&gt;稳定&lt;/strong&gt;。换句话说，基础时钟的每个滴答声的长度可能不相同（例如，某些秒可能比其他秒长）。瞬间可能会向前跳跃或经历时间膨胀（减速或加速），但永远不会向后退。</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">但是请注意，名称相同的项可用于不重叠的固有 &lt;code&gt;impl&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">但是请注意，这不是不安全的特征，因此该特征没有提供简洁的合同。取而代之的是，它更多地是作为&amp;ldquo;减速带&amp;rdquo;来警告 &lt;code&gt;catch_unwind&lt;/code&gt; 的用户，可能见证并可能需要解决损坏的不变式。</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">请注意，在许多情况下， &lt;code&gt;str&lt;/code&gt; 上的 &lt;code&gt;.parse()&lt;/code&gt; 方法更为合适。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;Pin&lt;/code&gt; 还实现了对目标的 &lt;code&gt;Deref&lt;/code&gt; ，可用于访问内部值。然而， &lt;code&gt;Deref&lt;/code&gt; 只提供一种生活，只要在的借参考 &lt;code&gt;Pin&lt;/code&gt; ，而不是寿命 &lt;code&gt;Pin&lt;/code&gt; 本身。这种方法可以将 &lt;code&gt;Pin&lt;/code&gt; 转换为与原始 &lt;code&gt;Pin&lt;/code&gt; 寿命相同的参考。</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;Pin&lt;/code&gt; 还对数据实现 &lt;code&gt;DerefMut&lt;/code&gt; ，可用于访问内部值。然而， &lt;code&gt;DerefMut&lt;/code&gt; 只提供一种生活，只要在的借参考 &lt;code&gt;Pin&lt;/code&gt; ，而不是寿命 &lt;code&gt;Pin&lt;/code&gt; 本身。这种方法可以将 &lt;code&gt;Pin&lt;/code&gt; 转换为与原始 &lt;code&gt;Pin&lt;/code&gt; 寿命相同的参考。</target>
        </trans-unit>
        <trans-unit id="fe08fa35bb3e2ac30191647bef4f566cd6842a4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;core&lt;/code&gt; provides &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt;&lt;code&gt;core::panic::Location::caller&lt;/code&gt;&lt;/a&gt; for observing caller locations. It wraps the &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt;&lt;code&gt;core::intrinsics::caller_location&lt;/code&gt;&lt;/a&gt; intrinsic implemented by &lt;code&gt;rustc&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;core&lt;/code&gt; 提供&lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt; &lt;code&gt;core::panic::Location::caller&lt;/code&gt; &lt;/a&gt;来观察呼叫者的位置。它包装了由 &lt;code&gt;rustc&lt;/code&gt; 实现的&lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt; &lt;code&gt;core::intrinsics::caller_location&lt;/code&gt; &lt;/a&gt;内部函数。</target>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">注意： &lt;code&gt;fold()&lt;/code&gt; 和遍历整个迭代器的类似方法对于无限迭代器可能不会终止，即使在可以在有限时间内确定结果的特征上也是如此。</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">注意： &lt;code&gt;move&lt;/code&gt; 闭包仍然可以实现&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;，即使它们通过移动捕获变量。这是因为由闭包类型实现的特征是由闭包对捕获的值执行的操作而不是其捕获它们的方式确定的。</target>
        </trans-unit>
        <trans-unit id="ddaee189fcb99b6fc9ed6acd8de34bd62f953e86" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by &lt;code&gt;move&lt;/code&gt;. This is because the traits implemented by a closure type are determined by &lt;em&gt;what&lt;/em&gt; the closure does with captured values, not &lt;em&gt;how&lt;/em&gt; it captures them:</source>
          <target state="translated">注意：尽管 &lt;code&gt;move&lt;/code&gt; 闭包可以通过 &lt;code&gt;move&lt;/code&gt; 捕获变量，但它们仍然可以实现&lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;。这是因为，通过闭合类型实现的性状是通过确定&lt;em&gt;什么&lt;/em&gt;封不与捕获的值，而不是&lt;em&gt;如何&lt;/em&gt;它捕捉它们：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="153802f008ce0ac25a19e7452c9f21a823543a00" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;code&gt;Fn&lt;/code&gt; or &lt;code&gt;FnMut&lt;/code&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them. The &lt;code&gt;move&lt;/code&gt; keyword only specifies the latter.</source>
          <target state="translated">注意： &lt;code&gt;move&lt;/code&gt; 闭包仍然可以实现 &lt;code&gt;Fn&lt;/code&gt; 或 &lt;code&gt;FnMut&lt;/code&gt; ，即使它们通过移动捕获变量。这是因为由闭包类型实现的特征是由闭包对捕获的值执行的操作而不是由闭包如何捕获的值确定的。该 &lt;code&gt;move&lt;/code&gt; 关键字仅指定了后者。</target>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">注意： &lt;code&gt;rustc&lt;/code&gt; 当前识别工具&amp;ldquo; clippy&amp;rdquo;和&amp;ldquo; rustfmt&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">注意： &lt;code&gt;rustc&lt;/code&gt; 为每个目标和CPU启用了一组默认功能。可以使用&lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt;标志选择CPU。可以使用&lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt;标志为整个包装箱启用或禁用单个功能。</target>
        </trans-unit>
        <trans-unit id="3f9c395bf29ddc7654449b79d4dc0411e7becef5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;str&lt;/code&gt; in &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; is not meaningful here. This type parameter of the trait only exists to enable another impl.</source>
          <target state="translated">注意： &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; &lt;code&gt;str&lt;/code&gt; 在这里没有意义。特质的此类型参数仅存在以启用另一个impl。</target>
        </trans-unit>
        <trans-unit id="c0d79cac345f205a82618d9422d71b4ef0b8bd13" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;union&lt;/code&gt;s with non-&lt;code&gt;Copy&lt;/code&gt; fields are unstable, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;.</source>
          <target state="translated">注： &lt;code&gt;union&lt;/code&gt; s的非 &lt;code&gt;Copy&lt;/code&gt; 领域的不稳定，见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">注意：您可能会听到一句关于使用严格的编译器（例如Haskell和Rust）的语言的说法，即&amp;ldquo;如果代码可以编译，则可以正常工作&amp;rdquo;。但是，这句话并非普遍如此。我们的项目可以编译，但是绝对不起作用！如果我们要构建一个真实，完整的项目，那么这将是开始编写单元测试以检查代码是否已编译&lt;em&gt;并&lt;/em&gt;具有所需行为的好时机。</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">注:虽然Rust和其他任何语言一样,可以由解释器以及编译器来实现,但现有的唯一实现是编译器,而且该语言一直被设计成编译语言。由于这些原因,本节假定有一个编译器。</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">注意：由于表示形式是商品的属性，因此表示形式不依赖于通用参数。具有相同名称的任何两种类型具有相同的表示形式。例如， &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; 都具有相同的表示形式。</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">注意：作为控制流表达式，如果块表达式是表达式语句的外部表达式，则期望的类型为 &lt;code&gt;()&lt;/code&gt; ,除非紧随其后是分号。</target>
        </trans-unit>
        <trans-unit id="09b47fffa556007259b32260e62d1512eb70865a" translate="yes" xml:space="preserve">
          <source>Note: Due to the representation of &lt;code&gt;repr(C)&lt;/code&gt; structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an &lt;code&gt;enum&lt;/code&gt;'s representation may therefore use whichever form is more convenient or consistent for them.</source>
          <target state="translated">注意：由于 &lt;code&gt;repr(C)&lt;/code&gt; 结构和联合的表示形式，如果变量具有单个字段，则直接将该字段放入联合或将其包装在结构中没有区别。任何希望操纵此类 &lt;code&gt;enum&lt;/code&gt; 表示形式的系统都可以使用对它们更方便或更一致的任何形式。</target>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">注意:除了lints外,习惯上只在函数项上使用外属性。</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">注意：为了清楚起见，建议始终在特征对象上使用 &lt;code&gt;dyn&lt;/code&gt; 关键字，除非您的代码库支持使用Rust 1.26或更低版本进行编译。</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">注意：有关 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 类型的实现细节的更多信息，请参见https://doc.rust-lang.org/stable/nomicon/vec.html上的&amp;ldquo; The Rustonomicon&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="12ed0cecef028f179120e48d11efd24c874bfd2d" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">注意：有关 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 类型的实现细节的更多信息，请参见&lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo; The Rustonomicon&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">注意：为了简单起见，我们将许多问题称为&lt;em&gt;并发，&lt;/em&gt;而不是通过说出&lt;em&gt;并发和/或并行&lt;/em&gt;来更精确。如果这本书是关于并发和/或并行性的，我们会更具体一些。对于本章，每当我们使用&lt;em&gt;并发&lt;/em&gt;时，请在精神上替换&lt;em&gt;并发和/或并行&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">注意：函数也可以实现所有三个 &lt;code&gt;Fn&lt;/code&gt; 特性。如果我们想要做的事情不需要从环境中获取值，则可以使用函数而不是闭包，而在闭包中我们需要实现 &lt;code&gt;Fn&lt;/code&gt; 特性的东西。</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">注意：Git是常见的版本控制系统。您可以使用 &lt;code&gt;--vcs&lt;/code&gt; 标志将 &lt;code&gt;cargo new&lt;/code&gt; 更改为使用其他版本控制系统或不使用任何版本控制系统。运行 &lt;code&gt;cargo new --help&lt;/code&gt; 以查看可用选项。</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">注意：从历史上看，位置表达式称为&lt;em&gt;lvalues，&lt;/em&gt;而值表达式称为&lt;em&gt;rvalues&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">注意：如果 &lt;code&gt;PeekMut&lt;/code&gt; 值泄漏，则堆可能处于不一致状态。</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">注意：如果由于某些原因您不想使用 &lt;code&gt;rustup&lt;/code&gt; ，请参阅&lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;Rust安装页面&lt;/a&gt;以获取其他选项。</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">注意：在C ++中，这种在项目生命周期结束时分配资源的模式有时称为&lt;em&gt;Resource Acquisition Is Initialization（RAII）&lt;/em&gt;。如果您使用过RAII模式，Rust中的 &lt;code&gt;drop&lt;/code&gt; 函数将为您所熟悉。</target>
        </trans-unit>
        <trans-unit id="54b56211cde322330df3d7c8028b1e66317b030b" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse()&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">注意：通常，如果需要融合的迭代器，则 &lt;code&gt;FusedIterator&lt;/code&gt; 在通用范围内使用FusedIterator。相反，您应该只在迭代器上调用&lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse()&lt;/code&gt; &lt;/a&gt;。如果迭代器已经融合，则附加的&lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt;包装器将是无操作的，并且不会降低性能。</target>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">注意：通常，如果需要融合的迭代器，则 &lt;code&gt;FusedIterator&lt;/code&gt; 在通用范围内使用FusedIterator。相反，您应该只在迭代器上调用&lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt;。如果迭代器已经融合，则附加的&lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt;包装器将是无操作的，并且不会降低性能。</target>
        </trans-unit>
        <trans-unit id="30cece00231291046dd06875e4aca4bb16fbdc74" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">注意：在使用&lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(n)&lt;/code&gt; 进行搜索的极端情况下，其中 &lt;code&gt;n&lt;/code&gt; 减去内部缓冲区长度使 &lt;code&gt;i64&lt;/code&gt; 溢出，将执行两次搜索，而不是一次。如果第二个搜索返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，则底层阅读器将保留在与您使用&lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; 调用 &lt;code&gt;seek&lt;/code&gt; 时相同的位置。</target>
        </trans-unit>
        <trans-unit id="3a4be906ba1df5fea075ac60c84354ab807a7ba2" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;code&gt;Err&lt;/code&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt;.</source>
          <target state="translated">注意：在使用 &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; 进行搜索的极端情况下，其中 &lt;code&gt;n&lt;/code&gt; 减去内部缓冲区长度 &lt;code&gt;i64&lt;/code&gt; 溢出，则将执行两次搜索，而不是一次。如果第二个搜索返回 &lt;code&gt;Err&lt;/code&gt; ，则底层阅读器将保留在与您使用 &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt; 调用 &lt;code&gt;seek&lt;/code&gt; 时相同的位置。</target>
        </trans-unit>
        <trans-unit id="ffeb95a03330faff30434eb464fab2ecfe395aa0" translate="yes" xml:space="preserve">
          <source>Note: It is idiomatic to use a &lt;a href=&quot;../statements#let-statements&quot;&gt;let statement&lt;/a&gt; with a pattern of &lt;code&gt;_&lt;/code&gt; when a must-used value is purposely discarded.</source>
          <target state="translated">注意：故意丢弃必须使用的值时，使用带有 &lt;code&gt;_&lt;/code&gt; 模式的&lt;a href=&quot;../statements#let-statements&quot;&gt;let语句&lt;/a&gt;是惯用的。</target>
        </trans-unit>
        <trans-unit id="a98353ad4c2ea48db43b41e0a837834f6a8b30a0" translate="yes" xml:space="preserve">
          <source>Note: Lifetimes can be and usually are elided with this shorthand.</source>
          <target state="translated">注:寿命可以而且通常用这个速记来省略。</target>
        </trans-unit>
        <trans-unit id="9458a465758bdea1aa806edbdf38d0829ff7abbc" translate="yes" xml:space="preserve">
          <source>Note: Multiple matches using the &lt;code&gt;|&lt;/code&gt; operator can cause the pattern guard and the side effects it has to execute multiple times. For example:</source>
          <target state="translated">注意：使用 &lt;code&gt;|&lt;/code&gt; 进行多个匹配 操作员可能会导致模式保护及其必须执行多次的副作用。例如：</target>
        </trans-unit>
        <trans-unit id="b48aac9382dceff2ad2732e0844fc1d124e5afbe" translate="yes" xml:space="preserve">
          <source>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;ldquo;Storing UTF-8 Encoded Text with Strings&amp;rdquo;&lt;/a&gt; section of Chapter 8.</source>
          <target state="translated">注意：字符串切片范围索引必须出现在有效的UTF-8字符边界处。如果尝试在多字节字符的中间创建字符串切片，则程序将退出并出现错误。为了引入字符串片段，我们仅在本节中假定为ASCII；否则，将使用ASCII码。第8章的&lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;ldquo;存储带字符串的UTF-8编码文本&amp;rdquo;&lt;/a&gt;部分对UTF-8处理进行了更全面的讨论。</target>
        </trans-unit>
        <trans-unit id="d0300d6a8e919cca08e1ab2c8db38b624e4574c2" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; standard library type provides a heap-allocated resizable array type.</source>
          <target state="translated">注意：&lt;a href=&quot;../../std/vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;标准库类型提供了堆分配的可调整大小的数组类型。</target>
        </trans-unit>
        <trans-unit id="29d2f706dbf0a3794fd072f42986f2a9c440ff62" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;//&lt;/code&gt; syntax starts a comment that continues until the end of the line. Rust ignores everything in comments, which are discussed in more detail in Chapter 3.</source>
          <target state="translated">注意： &lt;code&gt;//&lt;/code&gt; 语法开始注释，该注释一直持续到行尾。Rust忽略了注释中的所有内容，第3章将对此进行详细讨论。</target>
        </trans-unit>
        <trans-unit id="187085942721c7c78a8ec180c1642f4ed13694fc" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;2..=9&lt;/code&gt; is a &lt;a href=&quot;../patterns#range-patterns&quot;&gt;Range Pattern&lt;/a&gt;, not a &lt;a href=&quot;range-expr&quot;&gt;Range Expression&lt;/a&gt;. Thus, only those types of ranges supported by range patterns can be used in match arms.</source>
          <target state="translated">注意： &lt;code&gt;2..=9&lt;/code&gt; 是&lt;a href=&quot;../patterns#range-patterns&quot;&gt;范围模式&lt;/a&gt;，而不是&lt;a href=&quot;range-expr&quot;&gt;范围表达式&lt;/a&gt;。因此，在匹配臂中只能使用范围模式支持的那些类型的范围。</target>
        </trans-unit>
        <trans-unit id="f039047f79b4edcb39be10eb9b4e9a5ff0260001" translate="yes" xml:space="preserve">
          <source>Note: The actual definition of the &lt;code&gt;vec!&lt;/code&gt; macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don&amp;rsquo;t include here to make the example simpler.</source>
          <target state="translated">注意： &lt;code&gt;vec!&lt;/code&gt; 的实际定义！标准库中的宏包含用于预先分配正确内存量的代码。该代码是一种优化，为了使示例更简单，我们此处未包括在内。</target>
        </trans-unit>
        <trans-unit id="43e1990329df70de099fd02b501085a14776154b" translate="yes" xml:space="preserve">
          <source>Note: The aforementioned shim for function pointers is necessary because &lt;code&gt;rustc&lt;/code&gt; implements &lt;code&gt;track_caller&lt;/code&gt; in a codegen context by appending an implicit parameter to the function ABI, but this would be unsound for an indirect call because the parameter is not a part of the function's type and a given function pointer type may or may not refer to a function with the attribute. The creation of a shim hides the implicit parameter from callers of the function pointer, preserving soundness.</source>
          <target state="translated">注意：前述的函数指针填充是必要的，因为 &lt;code&gt;rustc&lt;/code&gt; 在 &lt;code&gt;track_caller&lt;/code&gt; 上下文中通过将隐式参数附加到函数ABI来实现track_caller，但是对于间接调用而言，这是不合理的，因为该参数不是函数类型的一部分，并且给定的函数指针类型可以或可以不使用具有属性的函数来引用。填充程序的创建对函数指针的调用者隐藏了隐式参数，从而保持了完整性。</target>
        </trans-unit>
        <trans-unit id="130fc90f1f7559f295e76dc148708d583a3eb9e9" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 1048576.</source>
          <target state="translated">注意： &lt;code&gt;rustc&lt;/code&gt; 中的默认值为1048576。</target>
        </trans-unit>
        <trans-unit id="26390a0ab47722e2e502de5688756dbd639d3d95" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 128.</source>
          <target state="translated">注意： &lt;code&gt;rustc&lt;/code&gt; 中的默认值为128。</target>
        </trans-unit>
        <trans-unit id="a3d9efde740053cef26656af7a7f6ab7316f24e6" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 64.</source>
          <target state="translated">注意： &lt;code&gt;rustc&lt;/code&gt; 中的默认值为64。</target>
        </trans-unit>
        <trans-unit id="8180c8df8ae11541f19b00a561591d13760a8ee6" translate="yes" xml:space="preserve">
          <source>Note: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">注意:即使迭代器直到最后才被消耗,元素范围也会被删除。</target>
        </trans-unit>
        <trans-unit id="9f4fea507ec4e68a49f42af2c77e67668a288392" translate="yes" xml:space="preserve">
          <source>Note: The enum representation in C is implementation defined, so this is really a &quot;best guess&quot;. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</source>
          <target state="translated">注意:C语言中的枚举表示是由实现定义的,所以这实际上是一个 &quot;最佳猜测&quot;。特别是,当相关的C代码在编译时使用某些标志时,这可能是不正确的。</target>
        </trans-unit>
        <trans-unit id="4cee4fb70834d29d39a99e3fa46a091ae845a20c" translate="yes" xml:space="preserve">
          <source>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;issue #33685&lt;/a&gt; for more details.</source>
          <target state="translated">注意：上面的示例曾经（错误地）被编译器接受，但此后已得到纠正。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;问题＃33685&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="daadbb2b1b33b48dcd9e6359e7eecc90c0e80c1e" translate="yes" xml:space="preserve">
          <source>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust&amp;rsquo;s having no null values. However, if we try to use a variable before giving it a value, we&amp;rsquo;ll get a compile-time error, which shows that Rust indeed does not allow null values.</source>
          <target state="translated">注意：清单10-17、10-18和10-24中的示例在声明变量时没有给它们提供初始值，因此变量名称位于外部作用域中。乍一看，这似乎与Rust没有空值的情况相冲突。但是，如果我们在给变量赋值之前尝试使用它，则会得到一个编译时错误，这表明Rust确实不允许空值。</target>
        </trans-unit>
        <trans-unit id="50e01f1ed4a46f62a5d14f0b5fa9d8b4796d1c64" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">注意：允许返回类型的实现由不稳定的&lt;a href=&quot;../../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt;特征决定。</target>
        </trans-unit>
        <trans-unit id="788f6375fff581af876a714c5f38068ea6a94a60" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">注意：允许返回类型的实现由不稳定的&lt;a href=&quot;../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt;特征决定。</target>
        </trans-unit>
        <trans-unit id="40b1e975f4973c7f7bd859ba82ec6ff70298303a" translate="yes" xml:space="preserve">
          <source>Note: The lint checks supported by &lt;code&gt;rustc&lt;/code&gt; can be found via &lt;code&gt;rustc -W help&lt;/code&gt;, along with their default settings and are documented in the &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc book&lt;/a&gt;.</source>
          <target state="translated">注意： &lt;code&gt;rustc&lt;/code&gt; 支持的皮棉检查可通过 &lt;code&gt;rustc -W help&lt;/code&gt; 及其默认设置找到，并记录在&lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc book中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5df3cfb866cdb5ad3722ea9687c561d88d29727a" translate="yes" xml:space="preserve">
          <source>Note: The next section assumes you&amp;rsquo;ve read the earlier section &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;ldquo;Using the Newtype Pattern to Implement External Traits on External Types.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">注意：下一部分假定您已阅读前面的部分&lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;ldquo;使用新类型模式对外部类型实施外部特征&amp;rdquo;。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7007864547a1ff842641db1454a617feb860ba4c" translate="yes" xml:space="preserve">
          <source>Note: The opposite of referencing by using &lt;code&gt;&amp;amp;&lt;/code&gt; is &lt;em&gt;dereferencing&lt;/em&gt;, which is accomplished with the dereference operator, &lt;code&gt;*&lt;/code&gt;. We&amp;rsquo;ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</source>
          <target state="translated">注意：使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 进行&lt;em&gt;引用&lt;/em&gt;的反义是&lt;em&gt;解引用&lt;/em&gt;，这是通过解引用运算符 &lt;code&gt;*&lt;/code&gt; 完成的。我们将在第8章中看到解引用运算符的一些用法，并在第15章中讨论解引用的细节。</target>
        </trans-unit>
        <trans-unit id="a0cacc6a55793cf1996cae56b2d43488d313d554" translate="yes" xml:space="preserve">
          <source>Note: The semicolon following a statement is not a part of the statement itself. They are invalid when using the &lt;code&gt;stmt&lt;/code&gt; macro matcher.</source>
          <target state="translated">注意：语句后的分号不是该语句本身的一部分。使用 &lt;code&gt;stmt&lt;/code&gt; 宏匹配器时，它们无效。</target>
        </trans-unit>
        <trans-unit id="ebd41440d85e280e6b8e0940e9eb1baf556c6663" translate="yes" xml:space="preserve">
          <source>Note: The test mode is enabled by passing the &lt;code&gt;--test&lt;/code&gt; argument to &lt;code&gt;rustc&lt;/code&gt; or using &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">注意：通过将 &lt;code&gt;--test&lt;/code&gt; 参数传递给 &lt;code&gt;rustc&lt;/code&gt; 或使用 &lt;code&gt;cargo test&lt;/code&gt; 来启用测试模式。</target>
        </trans-unit>
        <trans-unit id="019655f819e73b6b959d0e74887282806fb3a878" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. In C, an empty struct declaration like &lt;code&gt;struct Foo { }&lt;/code&gt; is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the &lt;code&gt;[[no_unique_address]]&lt;/code&gt; attribute, in which case they do not increase the overall size of the struct.</source>
          <target state="translated">注意：此算法可以生成零大小的结构。在C语言中，像 &lt;code&gt;struct Foo { }&lt;/code&gt; 这样的空struct声明是非法的。但是，gcc和clang都支持启用这些结构并将其分配为零的选项。相反，C ++给出的空结构的大小为1，除非它们继承自空结构，或者它们是具有 &lt;code&gt;[[no_unique_address]]&lt;/code&gt; 属性的字段，在这种情况下，它们不会增加结构的整体大小。</target>
        </trans-unit>
        <trans-unit id="a7281566219ec90e2a7e767d6f73d5379e3c0db2" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. This differs from C where structs without data still have a size of one byte.</source>
          <target state="translated">注意:这个算法可以产生零大小的结构。这与C语言不同,在C语言中,没有数据的结构仍然只有一个字节大小。</target>
        </trans-unit>
        <trans-unit id="84916df8964c95c521b7aa5c595fc0771cbfc9af" translate="yes" xml:space="preserve">
          <source>Note: This book assumes basic familiarity with the command line. Rust makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. Many IDEs now have some degree of Rust support; check the IDE&amp;rsquo;s documentation for details. Recently, the Rust team has been focusing on enabling great IDE support, and progress has been made rapidly on that front!</source>
          <target state="translated">注意：本书假定您基本熟悉命令行。Rust对您的编辑或工具或代码所在的位置没有特殊要求，因此，如果您更喜欢使用集成开发环境（IDE）而不是命令行，请随时使用自己喜欢的IDE。现在，许多IDE都提供了一定程度的Rust支持。有关详细信息，请查看IDE的文档。最近，Rust团队一直致力于实现出色的IDE支持，并且在这方面已取得了迅速的进步！</target>
        </trans-unit>
        <trans-unit id="5ac1eb98b0f589191a31e26db76121648795b41e" translate="yes" xml:space="preserve">
          <source>Note: This edition of the book is the same as &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language&lt;/a&gt; available in print and ebook format from &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;.</source>
          <target state="translated">注意：这本书的版本与&lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;发行的印刷版和电子书格式&lt;a href=&quot;https://nostarch.com/rust&quot;&gt;的Rust编程语言&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="12f5db48053663ec58249f015893f0934fb3f9cb" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_slice&lt;/code&gt; instead.</source>
          <target state="translated">注意：此示例显示 &lt;code&gt;&amp;amp;str&lt;/code&gt; 的内部。通常情况下， &lt;code&gt;unsafe&lt;/code&gt; 不应该用于获取字符串切片。请改用 &lt;code&gt;as_slice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98315c88f72bf459de14ba0cdd9324f6a6dfd072" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt; instead.</source>
          <target state="translated">注意：此示例显示 &lt;code&gt;&amp;amp;str&lt;/code&gt; 的内部。在正常情况下， &lt;code&gt;unsafe&lt;/code&gt; 不应该用于获取字符串切片。改用 &lt;code&gt;as_str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71c5367b5e1ca4ccf0bf834db2cd4b500fbdeb5c" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw &lt;code&gt;[T]&lt;/code&gt; type, not pointers (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;, &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;, etc.) to slices.</source>
          <target state="translated">注意：这是关于原始 &lt;code&gt;[T]&lt;/code&gt; 类型的，而不是指向切片的指针（ &lt;code&gt;&amp;amp;[T]&lt;/code&gt; ， &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="53274b0feb8252b3f7e0516cd656e66a12715d39" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">注：这是关于原始特征对象类型的，而不是指向特征对象的指针（ &lt;code&gt;&amp;amp;Trait&lt;/code&gt; ， &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="c578bc980d0061348761c9a476bec4981d2bea05" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">注意：这是关于原始特征对象类型的，而不是指向特征对象的指针（ &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; ， &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="3efbe622a99893d160a87ba1b5dbe54cdc04b646" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in argument position&quot;.</source>
          <target state="translated">注:这通常被称为 &quot;论点位置的内涵特质&quot;。</target>
        </trans-unit>
        <trans-unit id="ebd18dc0abe826773a124050720a5e27942c51e0" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in return position&quot;.</source>
          <target state="translated">注:这通常被称为 &quot;返回位置的 impl Trait&quot;。</target>
        </trans-unit>
        <trans-unit id="dcf4aae415a3e26a6bf431396708d40ea1b5d658" translate="yes" xml:space="preserve">
          <source>Note: This macro can be used in &lt;code&gt;no_std&lt;/code&gt; setups as well. In a &lt;code&gt;no_std&lt;/code&gt; setup you are responsible for the implementation details of the components.</source>
          <target state="translated">注意：此宏也可以在 &lt;code&gt;no_std&lt;/code&gt; 设置中使用。在 &lt;code&gt;no_std&lt;/code&gt; 设置中，您负责组件的实现细节。</target>
        </trans-unit>
        <trans-unit id="3ba312fede1a13f53566373763f2cc827d3cc6a0" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied but once to the stored value.</source>
          <target state="translated">注意：如果与此值同时已从其他线程更改，则此函数可以多次调用该函数，只要该函数返回 &lt;code&gt;Some(_)&lt;/code&gt; ，但该函数仅对存储的值应用一次。</target>
        </trans-unit>
        <trans-unit id="859d3e3283a94e543f2b35839b775cd31f5e0f59" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied only once to the stored value.</source>
          <target state="translated">注意：如果同时已从其他线程更改了值，则此函数可以多次调用该函数，只要该函数返回 &lt;code&gt;Some(_)&lt;/code&gt; ，但该函数仅对存储的值应用一次。</target>
        </trans-unit>
        <trans-unit id="64c40b5289fbe1388c2536811cdec7566f0df820" translate="yes" xml:space="preserve">
          <source>Note: This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a &lt;code&gt;struct&lt;/code&gt;).</source>
          <target state="translated">注意：如果标记在联合中被赋予其自己的成员，则这种表示形式将保持不变，这应该使您的操作更加清晰（尽管遵循C ++标准，标记成员应包装在 &lt;code&gt;struct&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="239a5948be38f752de16eb5b0ffe5444c5d1e29d" translate="yes" xml:space="preserve">
          <source>Note: This section is a placeholder for more comprehensive reference material.</source>
          <target state="translated">注:本节为更全面的参考资料的占位符。</target>
        </trans-unit>
        <trans-unit id="5b012ed05fd45d1a0619d2a532517a96144ac5c9" translate="yes" xml:space="preserve">
          <source>Note: This section is described more in terms of the compiler than of the language.</source>
          <target state="translated">注:本节更多的是用编译器而不是语言来描述。</target>
        </trans-unit>
        <trans-unit id="3b7a991aa3513a216522c1b812051b6fd94ca027" translate="yes" xml:space="preserve">
          <source>Note: Though you should not rely on this, all pointers to</source>
          <target state="translated">注意:虽然你不应该依赖这个,但所有指向</target>
        </trans-unit>
        <trans-unit id="ccec92c826b382bbeb8d0f3b3ce8f2aff5320851" translate="yes" xml:space="preserve">
          <source>Note: Traits are similar to a feature often called &lt;em&gt;interfaces&lt;/em&gt; in other languages, although with some differences.</source>
          <target state="translated">注意：特性与其他语言中通常称为&lt;em&gt;接口&lt;/em&gt;的功能相似，但有一些区别。</target>
        </trans-unit>
        <trans-unit id="0ff8579bff78c963092559227a81a969d9708ad7" translate="yes" xml:space="preserve">
          <source>Note: Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; and then not using that type and being the final expression of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block expression&lt;/a&gt; that is not used.</source>
          <target state="translated">注意：包含该值的琐碎的no-op表达式不会违反lint。例如，将值包装为不实现&lt;a href=&quot;../special-types-and-traits#drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;的类型，然后不使用该类型，并将其作为未使用的&lt;a href=&quot;../expressions/block-expr&quot;&gt;块表达式&lt;/a&gt;的最终表达式。</target>
        </trans-unit>
        <trans-unit id="eb186d5904a6ce9b777e0cf94b3203a9889bfac8" translate="yes" xml:space="preserve">
          <source>Note: Using primitive values when a complex type would be more appropriate is an anti-pattern known as &lt;em&gt;primitive obsession&lt;/em&gt;.</source>
          <target state="translated">注意：当复杂类型更合适时使用原始值是一种称为&lt;em&gt;原始痴迷&lt;/em&gt;的反模式。</target>
        </trans-unit>
        <trans-unit id="04993cf7d2f50288aed55f19ed2ebc1756b87d27" translate="yes" xml:space="preserve">
          <source>Note: We&amp;rsquo;re implementing a cons list that holds only &lt;code&gt;i32&lt;/code&gt; values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</source>
          <target state="translated">注意：就本示例而言，我们正在实现一个仅 &lt;code&gt;i32&lt;/code&gt; 值的缺点列表。就像我们在第10章中讨论过的那样，我们可以使用泛型来实现它，以定义可以存储任何类型的值的缺点列表类型。</target>
        </trans-unit>
        <trans-unit id="9a9063f50fe88aae84e6d578aa20b9af4873e66f" translate="yes" xml:space="preserve">
          <source>Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.</source>
          <target state="translated">注:虽然非大小胁迫的定义及其实现已经稳定,但特性本身还不稳定,因此不能直接在稳定的Rust中使用。</target>
        </trans-unit>
        <trans-unit id="2dfa6e64910004aadc24cb034a538f296b64dc2f" translate="yes" xml:space="preserve">
          <source>Note: Windows Portability Consideration</source>
          <target state="translated">注:Windows可移植性考虑</target>
        </trans-unit>
        <trans-unit id="54ec2a3d57d83413137977409179cfe79c9797ac" translate="yes" xml:space="preserve">
          <source>Note: You won&amp;rsquo;t just know which traits to use and which methods and functions to call from a crate. Instructions for using a crate are in each crate&amp;rsquo;s documentation. Another neat feature of Cargo is that you can run the &lt;code&gt;cargo doc --open&lt;/code&gt; command, which will build documentation provided by all of your dependencies locally and open it in your browser. If you&amp;rsquo;re interested in other functionality in the &lt;code&gt;rand&lt;/code&gt; crate, for example, run &lt;code&gt;cargo doc --open&lt;/code&gt; and click &lt;code&gt;rand&lt;/code&gt; in the sidebar on the left.</source>
          <target state="translated">注意：您不仅会知道要使用哪些特征，还可以从包装箱中调用哪些方法和函数。每个板条箱的文档中都有使用板条箱的说明。Cargo的另一个巧妙功能是您可以运行 &lt;code&gt;cargo doc --open&lt;/code&gt; 命令，该命令将在本地构建所有依赖项提供的文档，并在浏览器中打开它。例如，如果您对 &lt;code&gt;rand&lt;/code&gt; 板条箱中的其他功能感兴趣，请运行 &lt;code&gt;cargo doc --open&lt;/code&gt; ，然后单击左侧边栏中的 &lt;code&gt;rand&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dd21546f26b11f02ddb49b823b4ad3f527dfdac" translate="yes" xml:space="preserve">
          <source>Note: any changes to the constness of intrinsics should be discussed with the language team. This includes changes in the stability of the constness.</source>
          <target state="translated">注意:对内在性的任何变化都应与语言团队讨论。这包括对固有性稳定性的改变。</target>
        </trans-unit>
        <trans-unit id="1377a2c8bb6dcbd807394d1b50fa3eae990de774" translate="yes" xml:space="preserve">
          <source>Note: because the resulting &lt;code&gt;Location&lt;/code&gt; is a hint, an implementation may halt its walk up the stack early. See &lt;a href=&quot;#limitations&quot;&gt;Limitations&lt;/a&gt; for important caveats.</source>
          <target state="translated">注意：由于生成的 &lt;code&gt;Location&lt;/code&gt; 只是提示，因此实现可能会提前停止其前进。有关重要警告，请参阅&lt;a href=&quot;#limitations&quot;&gt;限制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa7e98c548306a32db0bad3d57bbd3a5f699aa40" translate="yes" xml:space="preserve">
          <source>Note: if you open &lt;em&gt;/sleep&lt;/em&gt; in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</source>
          <target state="translated">注意：如果您同时在多个浏览器窗口中打开&lt;em&gt;/ sleep&lt;/em&gt;，则它们可能会每5秒钟一次加载一个。出于缓存原因，某些Web浏览器会顺序执行同一请求的多个实例。此限制不是由我们的Web服务器引起的。</target>
        </trans-unit>
        <trans-unit id="0f059d54c5a420d80b996d0b044829768d22d426" translate="yes" xml:space="preserve">
          <source>Note: in a future Rust version this method may become unnecessary when array literal syntax allows &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;repeating const expressions&lt;/a&gt;. The example below could then use &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt;.</source>
          <target state="translated">注意：在将来的Rust版本中，当数组文字语法允许&lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;重复const表达式&lt;/a&gt;时，此方法可能变得不必要。然后，下面的示例可以使用 &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a67ae8b5976b293a38b572b260c03db2df6555be" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.instant#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="translated">注意：如果基础结构无法表示新的时间点，则诸如&lt;a href=&quot;struct.instant#method.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; 之&lt;/a&gt;类的数学运算可能会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="670b99fc8bc3c4e3e76a24aaf458d8652eb20452" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.systemtime#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="translated">注意：如果基础结构无法表示新的时间点，则诸如&lt;a href=&quot;struct.systemtime#method.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; 之&lt;/a&gt;类的数学运算可能会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="94be0b88d71e4f4b09ff423fbdb3966a642ec68a" translate="yes" xml:space="preserve">
          <source>Note: only extended grapheme codepoints that begin the string will be escaped.</source>
          <target state="translated">注意:只有以字符串开头的扩展grapheme码点才会被转义。</target>
        </trans-unit>
        <trans-unit id="15aa3f25c0678e364c46087d4cf15cef24972d41" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;Item&lt;/code&gt; type parameter is not used in this trait, but it allows impls to be more generic. Without it, we get this error:</source>
          <target state="translated">注意：在此特征中不使用 &lt;code&gt;Item&lt;/code&gt; 类型参数，但它使impls更为通用。没有它，我们将收到此错误：</target>
        </trans-unit>
        <trans-unit id="59ba94b4a0ce80567a5f66bf9563fcdf82240def" translate="yes" xml:space="preserve">
          <source>Note: the lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print &quot;In trait impl!&quot;, because &lt;code&gt;&amp;amp;self&lt;/code&gt; methods are looked up first, the trait method is found before the struct's &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method is found.</source>
          <target state="translated">注意：按顺序对每种类型进行查找，这有时会导致令人惊讶的结果。下面的代码将显示&amp;ldquo; In trait impl！&amp;rdquo;，因为先查找 &lt;code&gt;&amp;amp;self&lt;/code&gt; 方法，所以在找到结构的 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 方法之前先找到trait方法。</target>
        </trans-unit>
        <trans-unit id="c7cb38696a69ae9af0ae23e81e9d982ddfe77188" translate="yes" xml:space="preserve">
          <source>Note: the value returned by this method is unspecified after the range has been iterated to exhaustion.</source>
          <target state="translated">注意:本方法返回的值在范围迭代到用尽后,是不指定的。</target>
        </trans-unit>
        <trans-unit id="aa3e5b7333a9df0d2dc6ac8acfc43125fde51982" translate="yes" xml:space="preserve">
          <source>Note: there&amp;rsquo;s one big difference between the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;re about to build and the real &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: our version will not store its data on the heap. We are focusing this example on &lt;code&gt;Deref&lt;/code&gt;, so where the data is actually stored is less important than the pointer-like behavior.</source>
          <target state="translated">注意：我们将要构建的 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 类型与实际的 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 有一个很大的区别：我们的版本不会将其数据存储在堆中。我们将这个示例重点放在 &lt;code&gt;Deref&lt;/code&gt; 上，因此实际存储数据的位置比指针式行为重要。</target>
        </trans-unit>
        <trans-unit id="07525906ea71db41f7991cef8484c00c750f6dcb" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler</source>
          <target state="translated">注意:这个错误代码不再由编译器发出。</target>
        </trans-unit>
        <trans-unit id="0c580688b8d6e9090963bfacda97bc90a713c687" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler.</source>
          <target state="translated">注意:这个错误代码不再由编译器发出。</target>
        </trans-unit>
        <trans-unit id="82b6db0c7e241e7e5bc0253c1ea4acf7f9b04451" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::alloc_ref(&amp;amp;b)&lt;/code&gt; instead of &lt;code&gt;b.alloc_ref()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注意：这是一个关联的函数，这意味着您必须将其称为 &lt;code&gt;Box::alloc_ref(&amp;amp;b)&lt;/code&gt; 而不是 &lt;code&gt;b.alloc_ref()&lt;/code&gt; 。这样就不会与内部类型的方法发生冲突。</target>
        </trans-unit>
        <trans-unit id="5d8c035d8819f3ef6c6af80dffef20eae4c16d50" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::allocator(&amp;amp;b)&lt;/code&gt; instead of &lt;code&gt;b.allocator()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注意：这是一个关联的函数，这意味着您必须将其称为 &lt;code&gt;Box::allocator(&amp;amp;b)&lt;/code&gt; 而不是 &lt;code&gt;b.allocator()&lt;/code&gt; 。这样就不会与内部类型的方法发生冲突。</target>
        </trans-unit>
        <trans-unit id="de79d60b5ae69ae8de10ccab3addf181d505537b" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注意：这是一个关联的函数，这意味着您必须将其称为 &lt;code&gt;Box::into_raw(b)&lt;/code&gt; 而不是 &lt;code&gt;b.into_raw()&lt;/code&gt; 。这样就不会与内部类型上的方法发生冲突。</target>
        </trans-unit>
        <trans-unit id="9801006a2ac0b25e680ddaebb4a6a97fc9bd8dc1" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_non_null()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注意：这是一个关联的函数，这意味着您必须将其称为 &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; 而不是 &lt;code&gt;b.into_raw_non_null()&lt;/code&gt; 。这样就不会与内部类型上的方法发生冲突。</target>
        </trans-unit>
        <trans-unit id="3ad7dd66ed2768898bcd615504f6e1f37abf0500" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_with_alloc(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_with_alloc()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注意：这是一个关联的函数，这意味着您必须将其称为 &lt;code&gt;Box::into_raw_with_alloc(b)&lt;/code&gt; 而不是 &lt;code&gt;b.into_raw_with_alloc()&lt;/code&gt; 。这样就不会与内部类型的方法发生冲突。</target>
        </trans-unit>
        <trans-unit id="cc8801e3986d4fa9491ea8a20db52c0e7bd9b75a" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_with_allocator(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_with_allocator()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注意：这是一个关联的函数，这意味着您必须将其称为 &lt;code&gt;Box::into_raw_with_allocator(b)&lt;/code&gt; 而不是 &lt;code&gt;b.into_raw_with_allocator()&lt;/code&gt; 。这样就不会与内部类型的方法发生冲突。</target>
        </trans-unit>
        <trans-unit id="b61290dcffaed8f71df5ea3435ea91289cbca703" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::leak(b)&lt;/code&gt; instead of &lt;code&gt;b.leak()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注意：这是一个关联的函数，这意味着您必须将其称为 &lt;code&gt;Box::leak(b)&lt;/code&gt; 而不是 &lt;code&gt;b.leak()&lt;/code&gt; 。这样就不会与内部类型上的方法发生冲突。</target>
        </trans-unit>
        <trans-unit id="99cc9083edfe04d950b19fddc376275a0d86e32a" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/index.html#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意：虽然此类型不稳定，但是可以通过&lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/index.html#functions&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; 中&lt;/a&gt;的自由函数来访问其提供的功能。</target>
        </trans-unit>
        <trans-unit id="855408558daaf89b8b3b6445b95d7c1b8fc7ac9c" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;index#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意：虽然此类型不稳定，但是可以通过&lt;a href=&quot;index#functions&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; 中&lt;/a&gt;的自由函数来访问其提供的功能。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9ea884e20e19e59213993b5d483a5cae6c6deb6b" translate="yes" xml:space="preserve">
          <source>Notes about side effects</source>
          <target state="translated">副作用的注意事项</target>
        </trans-unit>
        <trans-unit id="0665801607b97f01a2cf09fef56752d404c94329" translate="yes" xml:space="preserve">
          <source>Notes and Safety</source>
          <target state="translated">注意事项和安全</target>
        </trans-unit>
        <trans-unit id="5367ad0070e3b4dc018a1e98ba396857c9a89c8b" translate="yes" xml:space="preserve">
          <source>Notes that contain useful information about the state of the book or point out useful, but mostly out of scope, information are in blockquotes that start with the word &quot;Note:&quot; in &lt;strong&gt;bold&lt;/strong&gt;.</source>
          <target state="translated">包含有关书籍或点出有用的状态有用的信息，但多出的范围注释，信息都是以单词&amp;ldquo;注：&amp;rdquo;开始引用文字的&lt;strong&gt;大胆&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="343e2ff0e712d5880f73c89d0629c959a0cbc677" translate="yes" xml:space="preserve">
          <source>Nothing in Rust prevents a trait from having a method with the same name as another trait&amp;rsquo;s method, nor does Rust prevent you from implementing both traits on one type. It&amp;rsquo;s also possible to implement a method directly on the type with the same name as methods from traits.</source>
          <target state="translated">Rust中的任何内容都不能阻止一个特征具有与另一个特征的方法同名的方法，Rust也不能阻止您对一种类型实现这两个特征。也可以直接在类型上实现与traits中的方法同名的方法。</target>
        </trans-unit>
        <trans-unit id="85a8ab9caff8306933eb7dd48f9cd08900551077" translate="yes" xml:space="preserve">
          <source>Notice in Listing 16-1 that the closure we pass to &lt;code&gt;thread::spawn&lt;/code&gt; takes no arguments: we&amp;rsquo;re not using any data from the main thread in the spawned thread&amp;rsquo;s code. To use data from the main thread in the spawned thread, the spawned thread&amp;rsquo;s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won&amp;rsquo;t yet work, as you&amp;rsquo;ll see in a moment.</source>
          <target state="translated">请注意，在清单16-1中，传递给 &lt;code&gt;thread::spawn&lt;/code&gt; 的闭包不带任何参数：在衍生线程的代码中，我们没有使用来自主线程的任何数据。要使用派生线程中主线程的数据，派生线程的闭包必须捕获其所需的值。清单16-3展示了尝试在主线程中创建向量并将其在生成的线程中使用的尝试。但是，这将无法正常工作，稍后您将看到。</target>
        </trans-unit>
        <trans-unit id="753a2ed5c1b14367e2086b1d9e2763add33258b6" translate="yes" xml:space="preserve">
          <source>Notice one interesting aspect of this particular execution: the &lt;code&gt;ThreadPool&lt;/code&gt; sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish. In the meantime, each of the workers received the termination messages. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all received the termination message and were able to shut down.</source>
          <target state="translated">请注意此特定执行的一个有趣方面： &lt;code&gt;ThreadPool&lt;/code&gt; 在通道上发送了终止消息，并且在任何工作程序接收消息之前，我们尝试加入工作程序0。工作程序0尚未收到终止消息，因此主线程阻塞了等待让工人0完成。同时，每个工人都收到了终止消息。当worker 0完成时，主线程等待其余的worker完成。到那时，他们都收到了终止消息并能够关闭。</target>
        </trans-unit>
        <trans-unit id="d88bd61c5288b6b4a4fab344b4f64355a8809dd2" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; has a &lt;code&gt;From&lt;/code&gt; instance for &lt;code&gt;&amp;amp;T&lt;/code&gt;. However, this does not change the fact that mutating through a (pointer derived from a) shared reference is undefined behavior unless the mutation happens inside an &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The same goes for creating a mutable reference from a shared reference. When using this &lt;code&gt;From&lt;/code&gt; instance without an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;, it is your responsibility to ensure that &lt;code&gt;as_mut&lt;/code&gt; is never called, and &lt;code&gt;as_ptr&lt;/code&gt; is never used for mutation.</source>
          <target state="translated">注意， &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 具有 &lt;code&gt;&amp;amp;T&lt;/code&gt; 的 &lt;code&gt;From&lt;/code&gt; 实例。但是，这不会改变以下事实：通过共享引用（从a派生的指针）进行的突变是未定义的行为，除非该突变发生在&lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;内部。从共享引用创建可变引用也是如此。当使用这种 &lt;code&gt;From&lt;/code&gt; 实例没有 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; ，它是你的责任，以确保 &lt;code&gt;as_mut&lt;/code&gt; 不会被调用，并 &lt;code&gt;as_ptr&lt;/code&gt; 从不用于突变。</target>
        </trans-unit>
        <trans-unit id="a4555814d84e265a1a37b6f84e64a162ac1d207e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;x&lt;/code&gt; is stack-allocated by &lt;code&gt;foo()&lt;/code&gt;. By default, Rust captures closed-over data by reference. This means that once &lt;code&gt;foo()&lt;/code&gt; returns, &lt;code&gt;x&lt;/code&gt; no longer exists. An attempt to access &lt;code&gt;x&lt;/code&gt; within the closure would thus be unsafe.</source>
          <target state="translated">请注意， &lt;code&gt;x&lt;/code&gt; 由 &lt;code&gt;foo()&lt;/code&gt; 堆栈分配。默认情况下，Rust通过引用捕获封闭数据。这意味着一旦 &lt;code&gt;foo()&lt;/code&gt; 返回， &lt;code&gt;x&lt;/code&gt; 将不再存在。因此，尝试在闭包内访问 &lt;code&gt;x&lt;/code&gt; 是不安全的。</target>
        </trans-unit>
        <trans-unit id="0e90ccdac3be23d4ae5fee41e5c9c069831f7aa8" translate="yes" xml:space="preserve">
          <source>Notice that being unblocked does not imply any synchronization with someone that unparked this thread, it could also be spurious. For example, it would be a valid, but inefficient, implementation to make both &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; return immediately without doing anything.</source>
          <target state="translated">请注意，解除阻止并不意味着与解除此线程的某个人的任何同步，这也可能是虚假的。例如，如果不执行任何&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;立即返回&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;和取消停放，这将是一种有效但效率低下的实现。</target>
        </trans-unit>
        <trans-unit id="6dc4ada24330684cf56181017076bf6667acd63e" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;code&gt;AcqRel&lt;/code&gt; will never perform &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">注意，在 &lt;code&gt;compare_and_swap&lt;/code&gt; 的情况下，该操作可能最终不执行任何存储，因此仅具有&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;排序。但是， &lt;code&gt;AcqRel&lt;/code&gt; 将永远不会执行&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="a7aa95fb880edfba626d059a08ec359fcae43db0" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; will never perform &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">请注意，在 &lt;code&gt;compare_and_swap&lt;/code&gt; 的情况下，该操作可能最终不执行任何存储，因此仅具有&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;排序。但是，&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt;将永远不会执行&lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="d68951af70c1b2b14c8581375aa37ef775c2c882" translate="yes" xml:space="preserve">
          <source>Notice that the code panicked with the message &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt;. This is how &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; handles violations of the borrowing rules at runtime.</source>
          <target state="translated">注意，对于 &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt; 的消息感到惊慌的代码：BorrowMutError。这是 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 在运行时处理违反借用规则的方式。</target>
        </trans-unit>
        <trans-unit id="e6e01b202ce551c042845c38802ff1f31e6bfcd1" translate="yes" xml:space="preserve">
          <source>Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call &lt;code&gt;drop_in_place&lt;/code&gt; manually.</source>
          <target state="translated">请注意，在删除打包的结构时，编译器会自动执行此复制，即，除非您手动调用 &lt;code&gt;drop_in_place&lt;/code&gt; ,否则通常不必担心此类问题。</target>
        </trans-unit>
        <trans-unit id="90e25cc098640b84fbba68a414a9fbb480dff45c" translate="yes" xml:space="preserve">
          <source>Notice that the first value in the vector is &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt;, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It&amp;rsquo;s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we&amp;rsquo;ll ignore it and save only the two arguments we need.</source>
          <target state="translated">请注意，向量中的第一个值是 &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt; ，这是我们二进制文件的名称。这与C中参数列表的行为匹配，从而使程序可以使用在执行过程中被调用的名称。如果要在消息中打印该名称或根据用于调用程序的命令行别名来更改程序的行为，通常可以方便地访问该程序的名称。但是出于本章的目的，我们将忽略它，仅保存我们需要的两个参数。</target>
        </trans-unit>
        <trans-unit id="a69330b1430c6944224f92b74bbe0967131daf2e" translate="yes" xml:space="preserve">
          <source>Notice that the only type we&amp;rsquo;re interacting with from the crate is the &lt;code&gt;Post&lt;/code&gt; type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in&amp;mdash;draft, waiting for review, or published. Changing from one state to another will be managed internally within the &lt;code&gt;Post&lt;/code&gt; type. The states change in response to the methods called by our library&amp;rsquo;s users on the &lt;code&gt;Post&lt;/code&gt; instance, but they don&amp;rsquo;t have to manage the state changes directly. Also, users can&amp;rsquo;t make a mistake with the states, like publishing a post before it&amp;rsquo;s reviewed.</source>
          <target state="translated">请注意，我们在箱子中与之交互的唯一类型是 &lt;code&gt;Post&lt;/code&gt; 类型。此类型将使用状态模式，并保存一个值，该值将是表示帖子可以处于的各种状态的三个状态对象之一（草稿，等待审阅或发布）。从一种状态更改为另一种状态将在内部通过 &lt;code&gt;Post&lt;/code&gt; 类型进行管理。状态会根据我们的图书馆用户在 &lt;code&gt;Post&lt;/code&gt; 实例上调用的方法而变化，但他们不必直接管理状态变化。同样，用户不能对状态做出错误的选择，例如在发表评论之前发布帖子。</target>
        </trans-unit>
        <trans-unit id="a7d5a7d44a98e57a3adf5c0193845ed9098d4a93" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">请注意，工作区在工作区的顶层只有一个&lt;em&gt;Cargo.lock&lt;/em&gt;文件，而不是在每个板条箱的目录中都有&lt;em&gt;Cargo.lock&lt;/em&gt;。这样可以确保所有包装箱都使用相同版本的所有依赖项。如果我们将 &lt;code&gt;rand&lt;/code&gt; 板条箱添加到&lt;em&gt;adder / Cargo.toml&lt;/em&gt;和&lt;em&gt;add-one / Cargo.toml&lt;/em&gt;文件，则Cargo会将这两个文件解析为 &lt;code&gt;rand&lt;/code&gt; 的一个版本，并将其记录在一个&lt;em&gt;Cargo.lock中&lt;/em&gt;。使工作区中的所有板条箱都使用相同的依赖性意味着工作区中的板条箱将始终相互兼容。让我们在添加 &lt;code&gt;rand&lt;/code&gt; 箱子到 &lt;code&gt;[dependencies]&lt;/code&gt; 在部分&lt;em&gt;add-one / Cargo.toml&lt;/em&gt;文件，以便能够在 &lt;code&gt;add-one&lt;/code&gt; &lt;em&gt;装箱&lt;/em&gt;中使用 &lt;code&gt;rand&lt;/code&gt; &lt;em&gt;装箱&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="43f89d0af380f75c1edd764ee3eac2d94a06cd6c" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; package to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">请注意，工作区在工作区的顶层只有一个&lt;em&gt;Cargo.lock&lt;/em&gt;文件，而不是在每个板条箱的目录中都有&lt;em&gt;Cargo.lock&lt;/em&gt;。这样可以确保所有包装箱都使用相同版本的所有依赖项。如果我们将 &lt;code&gt;rand&lt;/code&gt; 软件包添加到&lt;em&gt;adder / Cargo.toml&lt;/em&gt;和&lt;em&gt;add-one / Cargo.toml&lt;/em&gt;文件，则Cargo会将这两个&lt;em&gt;软件包&lt;/em&gt;解析为 &lt;code&gt;rand&lt;/code&gt; 的一个版本，并将其记录在一个&lt;em&gt;Cargo.lock中&lt;/em&gt;。使工作区中的所有板条箱使用相同的依赖关系意味着工作区中的板条箱将始终相互兼容。让我们在添加 &lt;code&gt;rand&lt;/code&gt; 箱子到 &lt;code&gt;[dependencies]&lt;/code&gt; 在部分&lt;em&gt;add-one / Cargo.toml&lt;/em&gt;文件，以便能够在 &lt;code&gt;add-one&lt;/code&gt; &lt;em&gt;装箱&lt;/em&gt;中使用 &lt;code&gt;rand&lt;/code&gt; &lt;em&gt;装箱&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="aa6a1647ef2a65fa35dd0dfd2179008c8845ec9d" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">请注意，这个保证却&lt;em&gt;并不&lt;/em&gt;意味着内存不漏！绝对不可以在固定的元素上调用&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;（例如，您仍然可以在&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 上调用&lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt;）。在双向链接列表的示例中，该元素将仅保留在列表中。但是，如果&lt;em&gt;没有调用&lt;/em&gt;&lt;em&gt;&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; ,则&lt;/a&gt;&lt;/em&gt;可能无法释放或重用存储。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d099748c8a2369f6e0484b9fb1916260cb072d44" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;code&gt;drop&lt;/code&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;code&gt;drop&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">请注意，这个保证却&lt;em&gt;并不&lt;/em&gt;意味着内存不漏！永远不要在固定的元素上调用 &lt;code&gt;drop&lt;/code&gt; （例如，您仍然可以在 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 上调用&lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt;）。在双向链接列表的示例中，该元素将仅保留在列表中。但是，如果&lt;em&gt;不调用&lt;/em&gt;&lt;em&gt; &lt;code&gt;drop&lt;/code&gt; ,&lt;/em&gt;可能无法释放或重用存储。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8e96d92ae370594b0a23d663a0a9b44ba5cff77" translate="yes" xml:space="preserve">
          <source>Notice that this time we didn&amp;rsquo;t see output indicating that Cargo was compiling &lt;code&gt;hello_cargo&lt;/code&gt;. Cargo figured out that the files hadn&amp;rsquo;t changed, so it just ran the binary. If you had modified your source code, Cargo would have rebuilt the project before running it, and you would have seen this output:</source>
          <target state="translated">注意，这次我们没有看到表明Cargo正在编译 &lt;code&gt;hello_cargo&lt;/code&gt; 的输出。Cargo发现文件没有更改，因此只运行了二进制文件。如果您修改了源代码，那么Cargo将在运行项目之前重建项目，并且您将看到以下输出：</target>
        </trans-unit>
        <trans-unit id="75afd928e1d9d07e8e8783b4a4c896142a3ef3bd" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">请注意，对组合负载和存储的操作使用此顺序将导致&amp;ldquo;&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;负载操作！</target>
        </trans-unit>
        <trans-unit id="bc0d2528578bd301fdbec6c6a7d80185cfd20062" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">请注意，使用此顺序进行结合了装载和存储的操作会导致&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;存储操作！</target>
        </trans-unit>
        <trans-unit id="6af1b53e3b0f26b23d98afe8cfa1fff0e78676da" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">请注意，对组合负载和存储的操作使用此顺序将导致&amp;ldquo; &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;负载操作！</target>
        </trans-unit>
        <trans-unit id="a34cbcc2842b5a9803de21bbd3cea40bd2f9faf2" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">请注意，使用此排序进行结合了负载和存储的操作将导致&lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;存储操作！</target>
        </trans-unit>
        <trans-unit id="1648ed9eef01e81103715c2fb558bce27eedcadf" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t include the &lt;code&gt;unsafe&lt;/code&gt; keyword in this code. We can create raw pointers in safe code; we just can&amp;rsquo;t dereference raw pointers outside an unsafe block, as you&amp;rsquo;ll see in a bit.</source>
          <target state="translated">请注意，我们在此代码中没有包含 &lt;code&gt;unsafe&lt;/code&gt; 关键字。我们可以使用安全代码创建原始指针；正如您将看到的那样，我们只是无法在不安全的块之外取消引用原始指针。</target>
        </trans-unit>
        <trans-unit id="111ab81f0256d10482ec4d240e310c1571a40527" translate="yes" xml:space="preserve">
          <source>Notice that we need an explicit lifetime &lt;code&gt;'a&lt;/code&gt; defined in the signature of &lt;code&gt;search&lt;/code&gt; and used with the &lt;code&gt;contents&lt;/code&gt; argument and the return value. Recall in &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;Chapter 10&lt;/a&gt; that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument &lt;code&gt;contents&lt;/code&gt; (rather than the argument &lt;code&gt;query&lt;/code&gt;).</source>
          <target state="translated">请注意，我们需要在 &lt;code&gt;search&lt;/code&gt; 签名中定义一个显式生命周期 &lt;code&gt;'a&lt;/code&gt; ，并与 &lt;code&gt;contents&lt;/code&gt; 参数和返回值一起使用。在&lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;第10章&lt;/a&gt;中，生命周期参数指定了将哪个参数生命周期连接到返回值的生命周期。在这种情况下，我们指示返回的向量应包含引用参数 &lt;code&gt;contents&lt;/code&gt; 切片的字符串切片（而不是参数 &lt;code&gt;query&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fd9233164b7146f50abe145b0977e2ddba8ac9ff" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;ve split the code into the &lt;code&gt;hello_macro_derive&lt;/code&gt; function, which is responsible for parsing the &lt;code&gt;TokenStream&lt;/code&gt;, and the &lt;code&gt;impl_hello_macro&lt;/code&gt; function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (&lt;code&gt;hello_macro_derive&lt;/code&gt; in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (&lt;code&gt;impl_hello_macro&lt;/code&gt; in this case) will be different depending on your procedural macro&amp;rsquo;s purpose.</source>
          <target state="translated">注意到，我们的代码分成 &lt;code&gt;hello_macro_derive&lt;/code&gt; 功能，它负责解析 &lt;code&gt;TokenStream&lt;/code&gt; 和 &lt;code&gt;impl_hello_macro&lt;/code&gt; 功能，它负责将语法树：这使得编写一个程序宏更方便。外部函数中的代码（在本例中为 &lt;code&gt;hello_macro_derive&lt;/code&gt; ）对于您看到或创建的几乎所有程序宏都相同。您在内部函数的主体中指定的代码（在本例中为 &lt;code&gt;impl_hello_macro&lt;/code&gt; ）将有所不同，具体取决于您的过程宏的用途。</target>
        </trans-unit>
        <trans-unit id="8966a5e7726edf21a4dc24ce7e3b95ed94980ac9" translate="yes" xml:space="preserve">
          <source>Notice there isn&amp;rsquo;t any code after the last line that begins with &lt;code&gt;//!&lt;/code&gt;. Because we started the comments with &lt;code&gt;//!&lt;/code&gt; instead of &lt;code&gt;///&lt;/code&gt;, we&amp;rsquo;re documenting the item that contains this comment rather than an item that follows this comment. In this case, the item that contains this comment is the &lt;em&gt;src/lib.rs&lt;/em&gt; file, which is the crate root. These comments describe the entire crate.</source>
          <target state="translated">请注意，以 &lt;code&gt;//!&lt;/code&gt; 开头的最后一行之后没有任何代码！。因为我们以 &lt;code&gt;//!&lt;/code&gt; 开始注释！而不是 &lt;code&gt;///&lt;/code&gt; ，我们正在记录包含此注释的项目，而不是此注释之后的项目。在这种情况下，包含此注释的项目是&lt;em&gt;src / lib.rs&lt;/em&gt;文件，它是板条箱根。这些评论描述了整个箱子。</target>
        </trans-unit>
        <trans-unit id="fcd0fb110f9fe32ec66824d300336739072d5b34" translate="yes" xml:space="preserve">
          <source>Notice this definition uses some new syntax: &lt;code&gt;type Item&lt;/code&gt; and &lt;code&gt;Self::Item&lt;/code&gt;, which are defining an &lt;em&gt;associated type&lt;/em&gt; with this trait. We&amp;rsquo;ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the &lt;code&gt;Iterator&lt;/code&gt; trait requires that you also define an &lt;code&gt;Item&lt;/code&gt; type, and this &lt;code&gt;Item&lt;/code&gt; type is used in the return type of the &lt;code&gt;next&lt;/code&gt; method. In other words, the &lt;code&gt;Item&lt;/code&gt; type will be the type returned from the iterator.</source>
          <target state="translated">注意，此定义使用了一些新语法： &lt;code&gt;type Item&lt;/code&gt; 和 &lt;code&gt;Self::Item&lt;/code&gt; ，它们定义了与此特征&lt;em&gt;相关的类型&lt;/em&gt;。我们将在第19章中深入讨论关联类型。现在，您需要知道的是，这段代码说实现 &lt;code&gt;Iterator&lt;/code&gt; trait要求您还定义一个 &lt;code&gt;Item&lt;/code&gt; 类型，并且该 &lt;code&gt;Item&lt;/code&gt; 类型用于以下代码的返回类型中：在 &lt;code&gt;next&lt;/code&gt; 方法。换句话说， &lt;code&gt;Item&lt;/code&gt; 类型将是从迭代器返回的类型。</target>
        </trans-unit>
        <trans-unit id="e0aa323f0e9e9e9d80a8d3d6a7b2a9db9ba76843" translate="yes" xml:space="preserve">
          <source>Now all the instances of &lt;code&gt;Point&lt;/code&gt; shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</source>
          <target state="translated">现在可以显示所有 &lt;code&gt;Point&lt;/code&gt; 实例！您可以根据需要在定义中使用任意多个泛型类型参数，但使用多个泛型类型参数会使代码难以阅读。当您的代码中需要大量泛型类型时，这可能表明您的代码需要重组为较小的部分。</target>
        </trans-unit>
        <trans-unit id="23eaa14436421a3e3cff4560bf4fb71eb52f11da" translate="yes" xml:space="preserve">
          <source>Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</source>
          <target state="translated">现在这个函数签名中的所有引用都有寿命,编译器可以继续分析,而不需要程序员在这个函数签名中注释寿命。</target>
        </trans-unit>
        <trans-unit id="6e1a1d010dc9ab9a0953fedbe299c3c77ffa1062" translate="yes" xml:space="preserve">
          <source>Now an example of &lt;code&gt;bool&lt;/code&gt; cast to integer type:</source>
          <target state="translated">现在将 &lt;code&gt;bool&lt;/code&gt; 为整数类型的示例：</target>
        </trans-unit>
        <trans-unit id="d65b9b0f422f439e94c8e42e9b963ca1e3008607" translate="yes" xml:space="preserve">
          <source>Now consider this twist where we add a call to &lt;code&gt;rev&lt;/code&gt;. This version will print &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt;. Note that the letters are reversed, but the values of the counter still go in order. This is because &lt;code&gt;map()&lt;/code&gt; is still being called lazily on each item, but we are popping items off the back of the vector now, instead of shifting them from the front.</source>
          <target state="translated">现在考虑这种扭曲，在其中添加对 &lt;code&gt;rev&lt;/code&gt; 的调用。此版本将打印 &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt; 。请注意，字母是相反的，但计数器的值仍按顺序排列。这是因为 &lt;code&gt;map()&lt;/code&gt; 仍然在每个项目上被懒惰地调用，但是我们现在正在将项目从向量的后面弹出，而不是将它们从前面移开。</target>
        </trans-unit>
        <trans-unit id="3a875ba4bda66efea86acc1d83b8c4cd40356ff2" translate="yes" xml:space="preserve">
          <source>Now enter the code in Listing 20-1 in &lt;em&gt;src/main.rs&lt;/em&gt; to start. This code will listen at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt; for incoming TCP streams. When it gets an incoming stream, it will print &lt;code&gt;Connection established!&lt;/code&gt;.</source>
          <target state="translated">现在，在&lt;em&gt;src / main.rs中&lt;/em&gt;输入清单20-1中的代码开始。该代码将在地址 &lt;code&gt;127.0.0.1:7878&lt;/code&gt; 处侦听传入的TCP流。当它得到一个输入流时，它将打印 &lt;code&gt;Connection established!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc71b87d7408d245b3b0aa3a92982cb74fc6ac9f" translate="yes" xml:space="preserve">
          <source>Now everything in the program should work as expected. Let&amp;rsquo;s try it:</source>
          <target state="translated">现在，程序中的所有内容均应按预期工作。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="d7f4763863038d188ed1914c2142e2e561d22201" translate="yes" xml:space="preserve">
          <source>Now if we change either the function or the example so the &lt;code&gt;assert_eq!&lt;/code&gt; in the example panics and run &lt;code&gt;cargo test&lt;/code&gt; again, we&amp;rsquo;ll see that the doc tests catch that the example and the code are out of sync with each other!</source>
          <target state="translated">现在，如果我们更改函数或示例，则 &lt;code&gt;assert_eq!&lt;/code&gt; 在示例恐慌并再次运行 &lt;code&gt;cargo test&lt;/code&gt; ，我们将看到doc测试发现该示例与代码彼此不同步！</target>
        </trans-unit>
        <trans-unit id="2e5aa4ec7130600ff4ecc4d4f5150848ff00d36e" translate="yes" xml:space="preserve">
          <source>Now it's possible to create at least one instance of &lt;code&gt;Foo&lt;/code&gt;: &lt;code&gt;Foo { x: None }&lt;/code&gt;.</source>
          <target state="translated">现在可以创建至少一个 &lt;code&gt;Foo&lt;/code&gt; 实例： &lt;code&gt;Foo { x: None }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57dee911ce426e019e30db0fccc486981ac3d8d4" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add the code in Listing 20-7 to the &lt;code&gt;else&lt;/code&gt; block to return a response with the status code 404, which signals that the content for the request was not found. We&amp;rsquo;ll also return some HTML for a page to render in the browser indicating the response to the end user.</source>
          <target state="translated">现在，将清单20-7中的代码添加到 &lt;code&gt;else&lt;/code&gt; 块中，以返回带有状态代码404的响应，该信号表明未找到请求的内容。我们还将为在浏览器中呈现的页面返回一些HTML，以指示对最终用户的响应。</target>
        </trans-unit>
        <trans-unit id="82511279c647b8b87ee818b8d44458ab76617b1f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s compile this &amp;ldquo;Hello, world!&amp;rdquo; program and run it in the same step using the &lt;code&gt;cargo run&lt;/code&gt; command:</source>
          <target state="translated">现在，我们来编译这个&amp;ldquo; Hello，world！&amp;rdquo; 程序并使用 &lt;code&gt;cargo run&lt;/code&gt; 命令在同一步骤中运行它：</target>
        </trans-unit>
        <trans-unit id="8863ee5075a8246e730bfe40012862faba75a02b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s consider the second call of &lt;code&gt;plus_one&lt;/code&gt; in Listing 6-5, where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. We enter the &lt;code&gt;match&lt;/code&gt; and compare to the first arm.</source>
          <target state="translated">现在，让我们考虑清单6-5中第二次调用 &lt;code&gt;plus_one&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; 。我们进入 &lt;code&gt;match&lt;/code&gt; 并与第一只手臂进行比较。</target>
        </trans-unit>
        <trans-unit id="b8300b290a67f9ed128322c21050dab12f2d0aa0" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s examine lifetime annotations in the context of the &lt;code&gt;longest&lt;/code&gt; function. As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime. We&amp;rsquo;ll name the lifetime &lt;code&gt;'a&lt;/code&gt; and then add it to each reference, as shown in Listing 10-22.</source>
          <target state="translated">现在，让我们在 &lt;code&gt;longest&lt;/code&gt; 函数的上下文中检查生命周期注释。与泛型类型参数一样，我们需要在函数名称和参数列表之间的尖括号内声明泛型寿命参数。我们要在此签名中表达的约束是参数中的所有引用和返回值必须具有相同的生存期。我们将生命周期命名为 &lt;code&gt;'a&lt;/code&gt; ，然后将其添加到每个引用中，如清单10-22所示。</target>
        </trans-unit>
        <trans-unit id="4d1d28eae4c7f65ed347f71ad22936c83ed0eb43" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:</source>
          <target state="translated">现在，让我们依靠编译器查找其他需要更改的地方。检查此代码，我们得到两个错误：</target>
        </trans-unit>
        <trans-unit id="89a2cc6c6da74e574a540dd470febae8d113a245" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the &lt;code&gt;String&lt;/code&gt; version:</source>
          <target state="translated">现在让我们看一下 &lt;code&gt;String&lt;/code&gt; 版本：</target>
        </trans-unit>
        <trans-unit id="aaee68df203c11b18152dd8afe26709ec73580c1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the pattern in the body of the code associated with this arm: &lt;code&gt;temp_vec.push()&lt;/code&gt; within &lt;code&gt;$()*&lt;/code&gt; is generated for each part that matches &lt;code&gt;$()&lt;/code&gt; in the pattern zero or more times depending on how many times the pattern matches. The &lt;code&gt;$x&lt;/code&gt; is replaced with each expression matched. When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the code generated that replaces this macro call will be the following:</source>
          <target state="translated">现在，让我们看看在这个手臂的相关代码的主体格局： &lt;code&gt;temp_vec.push()&lt;/code&gt; 内 &lt;code&gt;$()*&lt;/code&gt; 为每个匹配部分产生的 &lt;code&gt;$()&lt;/code&gt; 在模式取决于有多少次零次或更多次的模式匹配。的 &lt;code&gt;$x&lt;/code&gt; 被替换为匹配每个表达式。当我们用 &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; 调用此宏时；，生成的用于替换此宏调用的代码将如下所示：</target>
        </trans-unit>
        <trans-unit id="c4243cfe8f9ac10ec246b38ad823287bb3f58d73" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the &amp;ldquo;Hello, world!&amp;rdquo; program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">现在，让我们看看构建和运行&amp;ldquo; Hello，world！&amp;rdquo;的不同之处。货运程序！在&lt;em&gt;hello_cargo&lt;/em&gt;目录中，输入以下命令来构建项目：</target>
        </trans-unit>
        <trans-unit id="80b98c3dc4276471e5dedcfc50a6872d575390db" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the Hello, world! program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">现在，让我们看看构建和运行Hello World的不同之处！货运程序！在&lt;em&gt;hello_cargo&lt;/em&gt;目录中，输入以下命令来构建项目：</target>
        </trans-unit>
        <trans-unit id="5b581411bc505a7c21b9a362d12d054fb0134b63" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the test:</source>
          <target state="translated">现在让我们运行测试：</target>
        </trans-unit>
        <trans-unit id="f0501637a3932ce5ddf54dd291b5e0f5788b9a63" translate="yes" xml:space="preserve">
          <source>Now open &lt;em&gt;src/main.rs&lt;/em&gt; and take a look:</source>
          <target state="translated">现在打开&lt;em&gt;src / main.rs&lt;/em&gt;并查看：</target>
        </trans-unit>
        <trans-unit id="b399f29f23b6c286984286dd9b48d3e844228cb4" translate="yes" xml:space="preserve">
          <source>Now open the &lt;em&gt;main.rs&lt;/em&gt; file you just created and enter the code in Listing 1-1.</source>
          <target state="translated">现在打开刚刚创建的&lt;em&gt;main.rs&lt;/em&gt;文件，并输入清单1-1中的代码。</target>
        </trans-unit>
        <trans-unit id="d981ccfedbc387139591c6429e1ab6bbb51ae547" translate="yes" xml:space="preserve">
          <source>Now our code more clearly conveys that &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the &lt;code&gt;config&lt;/code&gt; instance in the fields named for their purpose.</source>
          <target state="translated">现在，我们的代码更加清楚地表明 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 是相关的，它们的目的是配置程序的工作方式。任何使用这些值的代码都知道可以在 &lt;code&gt;config&lt;/code&gt; 实例中为它们的目的而命名的字段中找到它们。</target>
        </trans-unit>
        <trans-unit id="e98906bcddd6edae414bc05f0060b41c04becc18" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;cargo test&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">现在在顶级&lt;em&gt;添加&lt;/em&gt;目录中运行 &lt;code&gt;cargo test&lt;/code&gt; ：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7999991a01bc3db0ab51179e8f7d5b7ea1e4709" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;search&lt;/code&gt; function is working and tested, we need to call &lt;code&gt;search&lt;/code&gt; from our &lt;code&gt;run&lt;/code&gt; function. We need to pass the &lt;code&gt;config.query&lt;/code&gt; value and the &lt;code&gt;contents&lt;/code&gt; that &lt;code&gt;run&lt;/code&gt; reads from the file to the &lt;code&gt;search&lt;/code&gt; function. Then &lt;code&gt;run&lt;/code&gt; will print each line returned from &lt;code&gt;search&lt;/code&gt;:</source>
          <target state="translated">现在 &lt;code&gt;search&lt;/code&gt; 功能正在运行并经过测试，我们需要从 &lt;code&gt;run&lt;/code&gt; 功能调用 &lt;code&gt;search&lt;/code&gt; 。我们需要通过 &lt;code&gt;config.query&lt;/code&gt; 值和 &lt;code&gt;contents&lt;/code&gt; 是 &lt;code&gt;run&lt;/code&gt; 从文件到读取 &lt;code&gt;search&lt;/code&gt; 功能。然后 &lt;code&gt;run&lt;/code&gt; 将打印 &lt;code&gt;search&lt;/code&gt; 返回的每一行：</target>
        </trans-unit>
        <trans-unit id="03229adf31a42bdb64eb9cba521d26f0154223d5" translate="yes" xml:space="preserve">
          <source>Now that the closure has its own copy of the data, there's no need to worry about safety.</source>
          <target state="translated">现在封闭有了自己的数据副本,就不用担心安全问题了。</target>
        </trans-unit>
        <trans-unit id="80c8ae661a453d666a29851514f9590667d50328" translate="yes" xml:space="preserve">
          <source>Now that we have a library crate in the workspace, we can have the binary crate &lt;code&gt;adder&lt;/code&gt; depend on the library crate &lt;code&gt;add-one&lt;/code&gt;. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">既然我们在工作区中有了一个库箱，我们就可以使二进制库箱 &lt;code&gt;adder&lt;/code&gt; 依赖于库箱 &lt;code&gt;add-one&lt;/code&gt; 了。首先，我们需要添加一个路径依赖 &lt;code&gt;add-one&lt;/code&gt; 到&lt;em&gt;加法器/ Cargo.toml&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e1d03746f7af11550c4dab530f554fdd12c9b9be" translate="yes" xml:space="preserve">
          <source>Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the &lt;code&gt;ThreadPool&lt;/code&gt; struct before returning it. But how do we &amp;ldquo;store&amp;rdquo; a thread? Let&amp;rsquo;s take another look at the &lt;code&gt;thread::spawn&lt;/code&gt; signature:</source>
          <target state="translated">现在，我们已经知道要在池中存储有效数量的线程，可以在返回之前创建这些线程并将它们存储在 &lt;code&gt;ThreadPool&lt;/code&gt; 结构中。但是，我们如何&amp;ldquo;存储&amp;rdquo;线程？让我们再来看一下 &lt;code&gt;thread::spawn&lt;/code&gt; 签名：</target>
        </trans-unit>
        <trans-unit id="bda29c679c337b77198a68eb0c281ffe77fd4dfe" translate="yes" xml:space="preserve">
          <source>Now that we have an external dependency, Cargo fetches the latest versions of everything from the &lt;em&gt;registry&lt;/em&gt;, which is a copy of data from &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</source>
          <target state="translated">现在我们有了一个外部依赖关系，Cargo从&lt;em&gt;注册表中&lt;/em&gt;获取所有内容的最新版本，这是&lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;中数据的副本。Crates.io是Rust生态系统中的人发布其开源Rust项目供他人使用的地方。</target>
        </trans-unit>
        <trans-unit id="b1ccc08848b1ba0169c7f988c879a0f190ff1fea" translate="yes" xml:space="preserve">
          <source>Now that we have another package in the workspace, we can have the &lt;code&gt;adder&lt;/code&gt; package with our binary depend on the &lt;code&gt;add-one&lt;/code&gt; package, that has our library. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">现在，我们在工作空间中有了另一个包，我们可以将 &lt;code&gt;adder&lt;/code&gt; 包和二进制文件依赖于具有我们库的 &lt;code&gt;add-one&lt;/code&gt; 包。首先，我们需要添加一个路径依赖 &lt;code&gt;add-one&lt;/code&gt; 到&lt;em&gt;加法器/ Cargo.toml&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3228f1351fbe40c57701ca17a80dd025a6bfe94f" translate="yes" xml:space="preserve">
          <source>Now that we have the code to turn the annotated Rust code from a &lt;code&gt;TokenStream&lt;/code&gt; into a &lt;code&gt;DeriveInput&lt;/code&gt; instance, let&amp;rsquo;s generate the code that implements the &lt;code&gt;HelloMacro&lt;/code&gt; trait on the annotated type, as shown in Listing 19-33.</source>
          <target state="translated">现在我们有了将注释后的Rust代码从 &lt;code&gt;TokenStream&lt;/code&gt; 转换为 &lt;code&gt;DeriveInput&lt;/code&gt; 实例的代码，让我们生成在注释后的类型上实现 &lt;code&gt;HelloMacro&lt;/code&gt; 特征的代码，如清单19-33所示。</target>
        </trans-unit>
        <trans-unit id="a05d1adf4441c02b17aff2e4ed6b1b6d76dccfa3" translate="yes" xml:space="preserve">
          <source>Now that we have the context, let&amp;rsquo;s get to the algorithm. The function &lt;code&gt;generate_workout&lt;/code&gt; in Listing 13-3 contains the business logic of the app that we&amp;rsquo;re most concerned with in this example. The rest of the code changes in this example will be made to this function.</source>
          <target state="translated">现在我们有了上下文，让我们进入算法。清单13-3中的函数 &lt;code&gt;generate_workout&lt;/code&gt; 包含了本例中我们最关注的应用程序的业务逻辑。此示例中的其余代码更改将对此函数进行。</target>
        </trans-unit>
        <trans-unit id="d0d7185e0fbe1a274eebe89e5b39be3986c2db0a" translate="yes" xml:space="preserve">
          <source>Now that we have user input and a random number, we can compare them. That step is shown in Listing 2-4. Note that this code won&amp;rsquo;t compile quite yet, as we will explain.</source>
          <target state="translated">现在我们有了用户输入和一个随机数，我们可以对其进行比较。清单2-4中显示了该步骤。请注意，正如我们将要解释的那样，该代码尚未编译。</target>
        </trans-unit>
        <trans-unit id="38f50db14e5d3025086efbe8bea15a9ba8ef6b08" translate="yes" xml:space="preserve">
          <source>Now that we know what the browser is asking for, let&amp;rsquo;s send back some data!</source>
          <target state="translated">现在我们知道了浏览器的要求，让我们发送一些数据！</target>
        </trans-unit>
        <trans-unit id="e92484795e9a806e19045c8bd7479798242a92b0" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined the desired behavior using the &lt;code&gt;Summary&lt;/code&gt; trait, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the &lt;code&gt;Summary&lt;/code&gt; trait on the &lt;code&gt;NewsArticle&lt;/code&gt; struct that uses the headline, the author, and the location to create the return value of &lt;code&gt;summarize&lt;/code&gt;. For the &lt;code&gt;Tweet&lt;/code&gt; struct, we define &lt;code&gt;summarize&lt;/code&gt; as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</source>
          <target state="translated">现在，我们已经使用 &lt;code&gt;Summary&lt;/code&gt; 特性定义了所需的行为，我们可以在媒体聚合器中的类型上实现它。清单10-13显示了一个执行 &lt;code&gt;Summary&lt;/code&gt; 的特点 &lt;code&gt;NewsArticle&lt;/code&gt; 使用的标题，作者，创建的返回值的位置结构 &lt;code&gt;summarize&lt;/code&gt; 。对于 &lt;code&gt;Tweet&lt;/code&gt; 结构，我们定义 &lt;code&gt;summarize&lt;/code&gt; 作为用户名随后鸣叫的整个文本，假定该鸣叫内容已经限于280个字符。</target>
        </trans-unit>
        <trans-unit id="847c864456f96a628c83e8df1e38c081c9008635" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined threads in Rust, let&amp;rsquo;s explore how to use the thread-related API provided by the standard library.</source>
          <target state="translated">现在，我们已经在Rust中定义了线程，让我们探索如何使用标准库提供的与线程相关的API。</target>
        </trans-unit>
        <trans-unit id="4bba9ff87fd1d7a113978a70c232f211dcf89ab4" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review &lt;a href=&quot;../std/vec/struct.vec&quot;&gt;the API documentation&lt;/a&gt; for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">现在，我们已经讨论了一些使用向量的最常用方法，请确保查看标准库在 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 上定义的所有有用方法&lt;a href=&quot;../std/vec/struct.vec&quot;&gt;的API文档&lt;/a&gt;。例如，除了 &lt;code&gt;push&lt;/code&gt; 之外， &lt;code&gt;pop&lt;/code&gt; 方法还会删除并返回最后一个元素。让我们继续下一个集合类型： &lt;code&gt;String&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="87dd1868af24eb68dc999a15f4b71b72a52c4914" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">既然我们已经讨论了一些使用向量的最常用方法，请确保查看标准库在 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 上定义的所有有用方法的API文档。例如，除了 &lt;code&gt;push&lt;/code&gt; 之外， &lt;code&gt;pop&lt;/code&gt; 方法还会删除并返回最后一个元素。让我们继续下一个集合类型： &lt;code&gt;String&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="2ec4c24a317d3f7bc3c352fa146805708f0bd185" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed the details of calling &lt;code&gt;panic!&lt;/code&gt; or returning &lt;code&gt;Result&lt;/code&gt;, let&amp;rsquo;s return to the topic of how to decide which is appropriate to use in which cases.</source>
          <target state="translated">现在，我们已经讨论了调用 &lt;code&gt;panic!&lt;/code&gt; 的细节！或返回 &lt;code&gt;Result&lt;/code&gt; ，让我们回到如何决定在哪种情况下适合使用的主题。</target>
        </trans-unit>
        <trans-unit id="dcf9675ca650b7816e93bbac61987240fde0e1c1" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve examined &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and some of the characteristics of smart pointers, let&amp;rsquo;s look at a few other smart pointers defined in the standard library.</source>
          <target state="translated">现在，我们已经研究了 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 和智能指针的一些特性，让我们看一下标准库中定义的其他一些智能指针。</target>
        </trans-unit>
        <trans-unit id="1275cf5c5193957df5e8d9870d52448402e96389" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve explored how variables work, let&amp;rsquo;s look at more data types they can have.</source>
          <target state="translated">现在，我们已经研究了变量的工作方式，让我们看一下它们可以拥有的更多数据类型。</target>
        </trans-unit>
        <trans-unit id="b53e79d7c3785836a15f4ecfc6aac9abee118b76" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted the logic into &lt;em&gt;src/lib.rs&lt;/em&gt; and left the argument collecting and error handling in &lt;em&gt;src/main.rs&lt;/em&gt;, it&amp;rsquo;s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line. Feel free to write some tests for the functionality in the &lt;code&gt;Config::new&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; functions on your own.</source>
          <target state="translated">现在，我们已将逻辑提取到&lt;em&gt;src / lib.rs中&lt;/em&gt;，并将参数收集和错误处理留在&lt;em&gt;src / main.rs中&lt;/em&gt;，为代码的核心功能编写测试要容易得多。我们可以直接使用各种参数调用函数，并检查返回值，而无需从命令行调用二进制文件。随时为 &lt;code&gt;Config::new&lt;/code&gt; 的功能编写一些测试，并自行 &lt;code&gt;run&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="2a08eff4bb167e5da1e95f954b1304af56f21965" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve finished refactoring the configuration parsing, let&amp;rsquo;s turn to the program&amp;rsquo;s logic. As we stated in &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;Separation of Concerns for Binary Projects&amp;rdquo;&lt;/a&gt;, we&amp;rsquo;ll extract a function named &lt;code&gt;run&lt;/code&gt; that will hold all the logic currently in the &lt;code&gt;main&lt;/code&gt; function that isn&amp;rsquo;t involved with setting up configuration or handling errors. When we&amp;rsquo;re done, &lt;code&gt;main&lt;/code&gt; will be concise and easy to verify by inspection, and we&amp;rsquo;ll be able to write tests for all the other logic.</source>
          <target state="translated">现在，我们已经完成了对配置解析的重构，接下来让我们来看程序的逻辑。如我们在&lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;二进制项目的关注点分离&amp;rdquo;中所述&lt;/a&gt;，我们将提取一个名为 &lt;code&gt;run&lt;/code&gt; 的函数，该函数将保留 &lt;code&gt;main&lt;/code&gt; 函数中当前不涉及设置配置或处理错误的所有逻辑。完成后， &lt;code&gt;main&lt;/code&gt; 将会简洁明了，并且易于通过检查进行验证，并且我们将能够为所有其他逻辑编写测试。</target>
        </trans-unit>
        <trans-unit id="67636ff52e1a7401207e61d89497c3656085f595" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve improved the expressiveness of our I/O project, let&amp;rsquo;s look at some more features of &lt;code&gt;cargo&lt;/code&gt; that will help us share the project with the world.</source>
          <target state="translated">现在，我们已经改善了I / O项目的表达能力，下面让我们看一下更多的 &lt;code&gt;cargo&lt;/code&gt; 功能，这些功能将有助于我们与世界共享该项目。</target>
        </trans-unit>
        <trans-unit id="f8c732cbf77e2073635c5b38e31310fafb9b6c1e" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve introduced iterators, we can demonstrate a common use of closures that capture their environment by using the &lt;code&gt;filter&lt;/code&gt; iterator adaptor. The &lt;code&gt;filter&lt;/code&gt; method on an iterator takes a closure that takes each item from the iterator and returns a Boolean. If the closure returns &lt;code&gt;true&lt;/code&gt;, the value will be included in the iterator produced by &lt;code&gt;filter&lt;/code&gt;. If the closure returns &lt;code&gt;false&lt;/code&gt;, the value won&amp;rsquo;t be included in the resulting iterator.</source>
          <target state="translated">现在，我们已经介绍了迭代器，我们可以证明一个共同使用闭包捕获通过使用他们的环境 &lt;code&gt;filter&lt;/code&gt; 迭代器适配器。所述 &lt;code&gt;filter&lt;/code&gt; 上的迭代方法以一个闭合从迭代花费的每个项目，并返回一个布尔值。如果闭包返回 &lt;code&gt;true&lt;/code&gt; ，则该值将包含在 &lt;code&gt;filter&lt;/code&gt; 产生的迭代器中。如果闭包返回 &lt;code&gt;false&lt;/code&gt; ，则该值不会包含在结果迭代器中。</target>
        </trans-unit>
        <trans-unit id="0f5c8cc4166bf098c054b91aa56eafdd80a280aa" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve looked at how channels work, let&amp;rsquo;s look at a different method of concurrency.</source>
          <target state="translated">既然我们已经研究了通道的工作方式，那么让我们看一下不同的并发方法。</target>
        </trans-unit>
        <trans-unit id="67653a6049372ba09d60cbd375a44f6c3cccaf9a" translate="yes" xml:space="preserve">
          <source>Now that we've got an idea of what unwind safety is in Rust, it's also important to understand what this trait represents. As mentioned above, one way to witness broken invariants is through the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module as it allows catching a panic and then re-using the environment of the closure.</source>
          <target state="translated">既然我们已经了解了Rust的放松安全性，那么了解此特征代表什么也很重要。如上所述，一种见证不变量不变的方法是通过此模块中的 &lt;code&gt;catch_unwind&lt;/code&gt; 函数，因为它允许捕获恐慌，然后重新使用闭包的环境。</target>
        </trans-unit>
        <trans-unit id="d02969884890c4347910c461b721cc439357c5a4" translate="yes" xml:space="preserve">
          <source>Now that you have an account, let&amp;rsquo;s say you have a crate you want to publish. Before publishing, you&amp;rsquo;ll need to add some metadata to your crate by adding it to the &lt;code&gt;[package]&lt;/code&gt; section of the crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">现在您已经有一个帐户，假设您有一个要发布的板条箱。发布之前，您需要通过将某些元数据添加到板条箱的&lt;em&gt;Cargo.toml&lt;/em&gt;文件的 &lt;code&gt;[package]&lt;/code&gt; 部分中来向板条箱中添加一些元数据。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09f54035802dcb8ec1dd44caa3ea32209f58c20d" translate="yes" xml:space="preserve">
          <source>Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we&amp;rsquo;ve annotated the types of the values that are returned from these functions for extra clarity.</source>
          <target state="translated">既然您知道如何创建，更新和销毁向量，那么下一步就是了解如何读取向量的内容。有两种方法可以引用存储在向量中的值。在示例中，我们为从这些函数返回的值的类型添加了注释，以更加明确。</target>
        </trans-unit>
        <trans-unit id="81f4f18161b98344a0f7e41a60ca860036728be7" translate="yes" xml:space="preserve">
          <source>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types.</source>
          <target state="translated">现在你已经知道如何定义和实现特质,我们可以探索如何使用特质来定义接受多种不同类型的函数。</target>
        </trans-unit>
        <trans-unit id="abb4d086b7b2c677929b00ae06d7123ecd180a15" translate="yes" xml:space="preserve">
          <source>Now that you know how to specify the behavior you want to use using the generic type parameter&amp;rsquo;s bounds, let&amp;rsquo;s return to Listing 10-5 to fix the definition of the &lt;code&gt;largest&lt;/code&gt; function that uses a generic type parameter! Last time we tried to run that code, we received this error:</source>
          <target state="translated">现在您已经知道如何使用泛型类型参数的界限指定要使用的行为，让我们返回清单10-5，以修复使用泛型类型参数的 &lt;code&gt;largest&lt;/code&gt; 函数的定义！上一次我们尝试运行该代码时，我们收到此错误：</target>
        </trans-unit>
        <trans-unit id="e396981103292f81034753c73fe592831d9392a8" translate="yes" xml:space="preserve">
          <source>Now that you know several ways to write tests, let&amp;rsquo;s look at what is happening when we run our tests and explore the different options we can use with &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">既然您已经知道编写测试的几种方法，那么让我们看看运行测试时发生了什么，并探索可以用于 &lt;code&gt;cargo test&lt;/code&gt; 的不同选项。</target>
        </trans-unit>
        <trans-unit id="e62f4573546a99a0fd5e85dde630775910ab5fc8" translate="yes" xml:space="preserve">
          <source>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let&amp;rsquo;s explore generic lifetimes of parameters and return values in the context of functions.</source>
          <target state="translated">既然您知道了引用的生存期在哪里以及Rust如何分析生存期以确保引用始终有效，那么让我们在函数的上下文中探索参数和返回值的通用生存期。</target>
        </trans-unit>
        <trans-unit id="30a6477678dd7180d7e0d481486280f7e98fefae" translate="yes" xml:space="preserve">
          <source>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let&amp;rsquo;s cover all the syntax we can use to create patterns.</source>
          <target state="translated">既然您知道了在哪里使用模式以及可重用和不可重用模式之间的区别，那么让我们介绍一下可用于创建模式的所有语法。</target>
        </trans-unit>
        <trans-unit id="31528a068a5d3a841cff61741fee15a1c0b2479f" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve added the &lt;code&gt;rand&lt;/code&gt; crate to &lt;em&gt;Cargo.toml&lt;/em&gt;, let&amp;rsquo;s start using &lt;code&gt;rand&lt;/code&gt;. The next step is to update &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 2-3.</source>
          <target state="translated">现在，您已将 &lt;code&gt;rand&lt;/code&gt; 板条箱添加到&lt;em&gt;Cargo.toml中&lt;/em&gt;，让我们开始使用 &lt;code&gt;rand&lt;/code&gt; 。下一步是更新&lt;em&gt;src / main.rs&lt;/em&gt;，如清单2-3所示。</target>
        </trans-unit>
        <trans-unit id="25f40b5e485b1b15ed8e4d216ebb9b698b979c06" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you&amp;rsquo;re ready to publish! Publishing a crate uploads a specific version to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; for others to use.</source>
          <target state="translated">现在，您已经创建了一个帐户，保存了API令牌，为包装箱选择了一个名称，并指定了所需的元数据，就可以开始发布了！发布板条箱&lt;a href=&quot;https://crates.io/&quot;&gt;会将&lt;/a&gt;特定版本上传到crates.io，以供其他人使用。</target>
        </trans-unit>
        <trans-unit id="920c59c826e17db818f515c07dfec7c798d59ee0" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve installed Rust, let&amp;rsquo;s write your first Rust program. It&amp;rsquo;s traditional when learning a new language to write a little program that prints the text &lt;code&gt;Hello, world!&lt;/code&gt; to the screen, so we&amp;rsquo;ll do the same here!</source>
          <target state="translated">现在，您已经安装了Rust，让我们编写您的第一个Rust程序。当学习一种新语言时，写一个小的程序来打印文本是很传统的， &lt;code&gt;Hello, world!&lt;/code&gt; 屏幕上，所以我们在这里做同样的事情！</target>
        </trans-unit>
        <trans-unit id="da83ac95984492a0d09f569c59cd96503f2138e1" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen how to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, let&amp;rsquo;s dig into how it works!</source>
          <target state="translated">现在您已经了解了如何使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，让我们深入研究它的工作原理！</target>
        </trans-unit>
        <trans-unit id="3226e5056b022a9871764bceba61de34cf95da11" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen useful ways that the standard library uses generics with the &lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; enums, we&amp;rsquo;ll talk about how generics work and how you can use them in your code.</source>
          <target state="translated">既然您已经看到了标准库在 &lt;code&gt;Option&lt;/code&gt; 和 &lt;code&gt;Result&lt;/code&gt; 枚举中使用泛型的有用方法，我们将讨论泛型的工作方式以及如何在代码中使用它们。</target>
        </trans-unit>
        <trans-unit id="c62551adf3df866d6c2e2a8e1a359461a03ffa45" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen what the test results look like in different scenarios, let&amp;rsquo;s look at some macros other than &lt;code&gt;panic!&lt;/code&gt; that are useful in tests.</source>
          <target state="translated">既然您已经看到了在不同情况下的测试结果，那么让我们看一下 &lt;code&gt;panic!&lt;/code&gt; 以外的一些宏！在测试中很有用。</target>
        </trans-unit>
        <trans-unit id="b7ef50d26b9af16e9b7dc94b8c74f1d0f89a5d4f" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; using a pattern in the &lt;code&gt;let&lt;/code&gt; statement, as discussed in Chapter 18.</source>
          <target state="translated">现在， &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块仅在元组中返回状态行和文件名的适当值；然后，我们使用结构化方法使用 &lt;code&gt;let&lt;/code&gt; 语句中的模式将这两个值分配给 &lt;code&gt;status_line&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; ，如第18章所述。</target>
        </trans-unit>
        <trans-unit id="4c7125187714db67fed394d49d485e2e00abd4cb" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;search&lt;/code&gt; function should return only the lines that contain &lt;code&gt;query&lt;/code&gt;, and our test should pass. Let&amp;rsquo;s run the test:</source>
          <target state="translated">现在， &lt;code&gt;search&lt;/code&gt; 功能应该仅返回包含 &lt;code&gt;query&lt;/code&gt; 的行，并且测试应该通过。让我们运行测试：</target>
        </trans-unit>
        <trans-unit id="522023e5be1135a608b1cd7f8c8337b4cfc43235" translate="yes" xml:space="preserve">
          <source>Now the code will compile! Let&amp;rsquo;s look at the absolute and the relative path and double-check why adding the &lt;code&gt;pub&lt;/code&gt; keyword lets us use these paths in &lt;code&gt;add_to_waitlist&lt;/code&gt; with respect to the privacy rules.</source>
          <target state="translated">现在代码将编译！让我们看一下绝对路径和相对路径，并仔细检查为什么添加 &lt;code&gt;pub&lt;/code&gt; 关键字使我们可以在 &lt;code&gt;add_to_waitlist&lt;/code&gt; 中使用这些路径来遵守隐私规则。</target>
        </trans-unit>
        <trans-unit id="9b0d5ba9ad57069914ace4b7ba7c228161663abb" translate="yes" xml:space="preserve">
          <source>Now the entire program should work! Let&amp;rsquo;s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, &amp;ldquo;frog&amp;rdquo;:</source>
          <target state="translated">现在整个程序应该可以工作了！让我们尝试一下，首先使用一个单词，该单词应该与艾米莉&amp;middot;狄金森的诗&amp;ldquo;青蛙&amp;rdquo;恰好返回一行：</target>
        </trans-unit>
        <trans-unit id="acdcf552dc404df4d014e75904c60498b68c4c55" translate="yes" xml:space="preserve">
          <source>Now the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">现在发生错误，因为我们在 &lt;code&gt;ThreadPool&lt;/code&gt; 上没有 &lt;code&gt;execute&lt;/code&gt; 方法。回想一下&lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;为有限数量的线程创建相似的接口&amp;rdquo;&lt;/a&gt;一节，我们决定线程池应该具有类似于 &lt;code&gt;thread::spawn&lt;/code&gt; 的接口。另外，我们将实现 &lt;code&gt;execute&lt;/code&gt; 函数，以便它使用给定的闭包并将其提供给池中的空闲线程以运行。</target>
        </trans-unit>
        <trans-unit id="14d34886bdb2d79a108c1eb310a74fea56db9de1" translate="yes" xml:space="preserve">
          <source>Now the expensive calculation is called in only one place, and we&amp;rsquo;re only executing that code where we need the results.</source>
          <target state="translated">现在，仅在一个地方调用了昂贵的计算，而我们仅在需要结果的地方执行该代码。</target>
        </trans-unit>
        <trans-unit id="e22993365c1cb308452dac73cf5565235b2c67e8" translate="yes" xml:space="preserve">
          <source>Now the program is getting interesting! There&amp;rsquo;s a lot going on in this little line. Notice that this is a &lt;code&gt;let&lt;/code&gt; statement, which is used to create a &lt;em&gt;variable&lt;/em&gt;. Here&amp;rsquo;s another example:</source>
          <target state="translated">现在程序变得有趣了！这条小线上有很多事情要做。请注意，这是一个 &lt;code&gt;let&lt;/code&gt; 语句，用于创建&lt;em&gt;变量&lt;/em&gt;。这是另一个例子：</target>
        </trans-unit>
        <trans-unit id="9b5e26741b88a54ad8284d61f9e2e51ca7f82268" translate="yes" xml:space="preserve">
          <source>Now the signature indicates that the function data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Alternatively, you could change the body to not return data from &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">现在，签名表明函数数据是从 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 借用的。或者，您可以更改主体以不从 &lt;code&gt;y&lt;/code&gt; 返回数据：</target>
        </trans-unit>
        <trans-unit id="c1198ca2a8c86240e1af84c3d28743f89fded1ad" translate="yes" xml:space="preserve">
          <source>Now we can start seeing the advantages of the state pattern: the &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; is the same no matter its &lt;code&gt;state&lt;/code&gt; value. Each state is responsible for its own rules.</source>
          <target state="translated">现在我们可以开始看到状态模式的优点： &lt;code&gt;Post&lt;/code&gt; 上的 &lt;code&gt;request_review&lt;/code&gt; 方法无论 &lt;code&gt;state&lt;/code&gt; 值如何都是相同的。每个州都对自己的规则负责。</target>
        </trans-unit>
        <trans-unit id="0ea1cd6e6626b68365f6c8947fa55d16ff141954" translate="yes" xml:space="preserve">
          <source>Now we get a warning and an error. Ignoring the warning for a moment, the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">现在我们得到一个警告和一个错误。暂时忽略警告，由于我们在 &lt;code&gt;ThreadPool&lt;/code&gt; 上没有 &lt;code&gt;execute&lt;/code&gt; 方法，因此发生错误。回想一下&lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;为有限数量的线程创建相似的接口&amp;rdquo;&lt;/a&gt;一节，我们决定线程池应该具有类似于 &lt;code&gt;thread::spawn&lt;/code&gt; 的接口。另外，我们将实现 &lt;code&gt;execute&lt;/code&gt; 函数，以便它使用给定的闭包并将其提供给池中的空闲线程以运行。</target>
        </trans-unit>
        <trans-unit id="d7705a7f1894fbc9d3a536be0dfea4d6af32a807" translate="yes" xml:space="preserve">
          <source>Now we need to bring the code we moved to &lt;em&gt;src/lib.rs&lt;/em&gt; into the scope of the binary crate in &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 12-14.</source>
          <target state="translated">现在，我们需要将移至&lt;em&gt;src / lib.rs&lt;/em&gt;的代码引入&lt;em&gt;src / main.rs&lt;/em&gt;中的二进制板条箱的范围，如清单12-14所示。</target>
        </trans-unit>
        <trans-unit id="b54fd4c3b5f78dc6afcacc14a208e5f25a781f43" translate="yes" xml:space="preserve">
          <source>Now we need to update the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt;: if the state is &lt;code&gt;Published&lt;/code&gt;, we want to return the value in the post&amp;rsquo;s &lt;code&gt;content&lt;/code&gt; field; otherwise, we want to return an empty string slice, as shown in Listing 17-17:</source>
          <target state="translated">现在我们需要更新 &lt;code&gt;Post&lt;/code&gt; 的 &lt;code&gt;content&lt;/code&gt; 方法：如果状态为 &lt;code&gt;Published&lt;/code&gt; ，我们想返回post的 &lt;code&gt;content&lt;/code&gt; 字段中的值；否则，我们想返回一个空字符串切片，如清单17-17所示：</target>
        </trans-unit>
        <trans-unit id="6174f1c624d6e6d6e079aee3674396394f363d5b" translate="yes" xml:space="preserve">
          <source>Now we see the error onscreen and &lt;em&gt;output.txt&lt;/em&gt; contains nothing, which is the behavior we expect of command line programs.</source>
          <target state="translated">现在，我们在屏幕上看到错误，并且&lt;em&gt;output.txt不&lt;/em&gt;包含任何内容，这是我们期望命令行程序执行的行为。</target>
        </trans-unit>
        <trans-unit id="cdda59c39165af59e97381c7390ecfef3d12a8f6" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add functionality to read the file that is specified in the &lt;code&gt;filename&lt;/code&gt; command line argument. First, we need a sample file to test it with: the best kind of file to use to make sure &lt;code&gt;minigrep&lt;/code&gt; is working is one with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called &lt;em&gt;poem.txt&lt;/em&gt; at the root level of your project, and enter the poem &amp;ldquo;I&amp;rsquo;m Nobody! Who are you?&amp;rdquo;</source>
          <target state="translated">现在，我们将添加功能来读取文件 &lt;code&gt;filename&lt;/code&gt; 命令行参数中指定的文件。首先，我们需要一个示例文件进行测试：用来确保 &lt;code&gt;minigrep&lt;/code&gt; 正常工作的最佳文件类型是：在多行文本中包含少量文本，并包含一些重复的单词。清单12-3的一首埃米莉&amp;middot;狄金森诗很不错！在项目的根目录下创建一个名为&lt;em&gt;poem.txt&lt;/em&gt;的文件，然后输入一首诗&amp;ldquo; I'm Nobody！你是谁？&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="dd1d31103e62a1ec520be0bcddbbbdb89e976849" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add some types that implement the &lt;code&gt;Draw&lt;/code&gt; trait. We&amp;rsquo;ll provide the &lt;code&gt;Button&lt;/code&gt; type. Again, actually implementing a GUI library is beyond the scope of this book, so the &lt;code&gt;draw&lt;/code&gt; method won&amp;rsquo;t have any useful implementation in its body. To imagine what the implementation might look like, a &lt;code&gt;Button&lt;/code&gt; struct might have fields for &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt;, as shown in Listing 17-7:</source>
          <target state="translated">现在，我们将添加一些实现 &lt;code&gt;Draw&lt;/code&gt; 特征的类型。我们将提供 &lt;code&gt;Button&lt;/code&gt; 类型。同样，实际实现GUI库超出了本书的范围，因此 &lt;code&gt;draw&lt;/code&gt; 方法在其主体中将没有任何有用的实现。为了想象实现的样子， &lt;code&gt;Button&lt;/code&gt; 结构可能具有 &lt;code&gt;width&lt;/code&gt; ， &lt;code&gt;height&lt;/code&gt; 和 &lt;code&gt;label&lt;/code&gt; 的字段，如清单17-7所示：</target>
        </trans-unit>
        <trans-unit id="e57698dd0ca960cc0b20cbcaaf7560d2276dfedc" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement sending data in response to a client request. Responses have the following format:</source>
          <target state="translated">现在，我们将实现发送数据以响应客户请求。响应具有以下格式：</target>
        </trans-unit>
        <trans-unit id="faa7223d94f8959f76182c7251992c3581bab825" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement the &lt;code&gt;Drop&lt;/code&gt; trait to call &lt;code&gt;join&lt;/code&gt; on each of the threads in the pool so they can finish the requests they&amp;rsquo;re working on before closing. Then we&amp;rsquo;ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we&amp;rsquo;ll modify our server to accept only two requests before gracefully shutting down its thread pool.</source>
          <target state="translated">现在，我们将实现 &lt;code&gt;Drop&lt;/code&gt; 特性以在池中的每个线程上调用 &lt;code&gt;join&lt;/code&gt; ，以便它们可以在关闭之前完成正在处理的请求。然后，我们将实现一种方法来告诉线程它们应停止接受新请求并关闭。要查看此代码的实际效果，我们将修改服务器以仅接受两个请求，然后正常关闭其线程池。</target>
        </trans-unit>
        <trans-unit id="f36ce7a9b5e2c1e7eedfaeab844cfb65b78a49c0" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll tackle the problem that the closures given to &lt;code&gt;thread::spawn&lt;/code&gt; do absolutely nothing. Currently, we get the closure we want to execute in the &lt;code&gt;execute&lt;/code&gt; method. But we need to give &lt;code&gt;thread::spawn&lt;/code&gt; a closure to run when we create each &lt;code&gt;Worker&lt;/code&gt; during the creation of the &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">现在，我们要解决的问题是，给 &lt;code&gt;thread::spawn&lt;/code&gt; 的闭包绝对不起作用。当前，我们在 &lt;code&gt;execute&lt;/code&gt; 方法中获得了要执行的闭包。但是我们需要给 &lt;code&gt;thread::spawn&lt;/code&gt; 一个闭包，以便在创建 &lt;code&gt;ThreadPool&lt;/code&gt; 时创建每个 &lt;code&gt;Worker&lt;/code&gt; 时运行。</target>
        </trans-unit>
        <trans-unit id="0ff72d33ea4877ceb607d0497b7819ecb5fe8345" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll work on fixing our error handling. Recall that attempting to access the values in the &lt;code&gt;args&lt;/code&gt; vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:</source>
          <target state="translated">现在，我们将修复错误处理。回想一下，如果尝试访问 &lt;code&gt;args&lt;/code&gt; 1或索引2 的args向量中的值，则如果向量包含的项少于三个，将导致程序崩溃。尝试运行不带任何参数的程序；它看起来像这样：</target>
        </trans-unit>
        <trans-unit id="13208408fb234a6274c662e0cea2839eb0d4df4f" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;re tracking a starting &lt;em&gt;and&lt;/em&gt; an ending index, and we have even more values that were calculated from data in a particular state but aren&amp;rsquo;t tied to that state at all. We now have three unrelated variables floating around that need to be kept in sync.</source>
          <target state="translated">现在，我们正在跟踪起始索引&lt;em&gt;和&lt;/em&gt;结束索引，并且有更多的值是根据特定状态下的数据计算得出的，但根本没有与该状态相关联。现在，我们有三个不相关的变量需要保持同步。</target>
        </trans-unit>
        <trans-unit id="e2c6d85ff7e11c55ebfacf4a5ea15b76883f9037" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;first_word&lt;/code&gt;, we get back a single value that is tied to the underlying data. The value is made up of a reference to the starting point of the slice and the number of elements in the slice.</source>
          <target state="translated">现在，当我们调用 &lt;code&gt;first_word&lt;/code&gt; 时，我们将获得与基础数据相关的单个值。该值由对切片起点的引用以及切片中元素的数量组成。</target>
        </trans-unit>
        <trans-unit id="ae56f18fed45d04e5e1b1341584607fec330d0c6" translate="yes" xml:space="preserve">
          <source>Now when we run the program, we won&amp;rsquo;t get any errors, and we&amp;rsquo;ll see the following output:</source>
          <target state="translated">现在，当我们运行该程序时，将不会出现任何错误，并且我们将看到以下输出：</target>
        </trans-unit>
        <trans-unit id="a1e40e49d7c93a75ee26e23465f603f6bbef3e57" translate="yes" xml:space="preserve">
          <source>Now when we run the test, we&amp;rsquo;ll get a more informative error message:</source>
          <target state="translated">现在，当我们运行测试时，我们将获得更多有用的错误消息：</target>
        </trans-unit>
        <trans-unit id="77f2a1a56e2b0bc8d28e09777d58b6d63d25bdc8" translate="yes" xml:space="preserve">
          <source>Now you know how the newtype pattern is used in relation to traits; it&amp;rsquo;s also a useful pattern even when traits are not involved. Let&amp;rsquo;s switch focus and look at some advanced ways to interact with Rust&amp;rsquo;s type system.</source>
          <target state="translated">现在您知道了如何将新类型模式与特征相关联；即使不涉及特质，这也是一种有用的模式。让我们切换焦点，看看与Rust的字体系统交互的一些高级方法。</target>
        </trans-unit>
        <trans-unit id="698e184c44b77b78a4f0259358fd0568a9ef42f1" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;foo()&lt;/code&gt; can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call &lt;code&gt;foo()&lt;/code&gt; on types implementing that trait that aren't behind trait objects.</source>
          <target state="translated">现在，不再可以在trait对象上调用 &lt;code&gt;foo()&lt;/code&gt; ，但是现在可以创建一个trait对象，并且可以调用任何对象安全的方法。有了这样的限制，仍然可以在实现该特征的类型 &lt;code&gt;foo()&lt;/code&gt; 不位于特征对象之后）上调用foo（）。</target>
        </trans-unit>
        <trans-unit id="e2eab767e7fabf7d41783d8a69e9cbea73a62c87" translate="yes" xml:space="preserve">
          <source>Now, every time you call &lt;code&gt;rustc&lt;/code&gt; or &lt;code&gt;cargo&lt;/code&gt; inside of &lt;em&gt;~/projects/needs-nightly&lt;/em&gt;, &lt;code&gt;rustup&lt;/code&gt; will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!</source>
          <target state="translated">现在，每次在&lt;em&gt;〜/ projects / needs-nightly&lt;/em&gt;内调用 &lt;code&gt;rustc&lt;/code&gt; 或 &lt;code&gt;cargo&lt;/code&gt; ， &lt;code&gt;rustup&lt;/code&gt; 将确保您使用的是每晚Rust，而不是默认的稳定Rust。当您有很多Rust项目时，这会派上用场！&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e79236607753f413c66ac854a24fa640c09a981f" translate="yes" xml:space="preserve">
          <source>Now, if we have the following code:</source>
          <target state="translated">现在,如果我们有以下代码。</target>
        </trans-unit>
        <trans-unit id="8bfc390ee5863dbfd9bc2b1fac71150d32bafb63" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. Note that the next few examples will have compiler errors, and we&amp;rsquo;ll use those errors to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly. Listing 16-13 has our starting example:</source>
          <target state="translated">现在，让我们尝试使用 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 在多个线程之间共享一个值。我们将旋转10个线程，并使它们每个将计数器值加1，因此计数器从0到10。请注意，接下来的几个示例将出现编译器错误，并且我们将使用这些错误来学习有关使用的更多信息。 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 以及Rust如何帮助我们正确使用它。清单16-13是我们的起始示例：</target>
        </trans-unit>
        <trans-unit id="12a0ede889bbdab76f8ecdca9c8b3f108a1224a8" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. The next example in Listing 16-13 will have a compiler error, and we&amp;rsquo;ll use that error to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly.</source>
          <target state="translated">现在，让我们尝试使用 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 在多个线程之间共享一个值。我们将旋转10个线程，并使每个线程将一个计数器值加1，以便计数器从0到10。清单16-13中的下一个示例将出现编译器错误，我们将使用该错误来学习有关使用 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 更多信息，以及Rust如何帮助我们正确使用它。</target>
        </trans-unit>
        <trans-unit id="4684dc088b34ae2083e2057208489a24262c5c09" translate="yes" xml:space="preserve">
          <source>Now, run this program using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">现在，使用 &lt;code&gt;cargo run&lt;/code&gt; 运行该程序：</target>
        </trans-unit>
        <trans-unit id="5f63a9b785af57bd0365b9cf3f0ad0d87a3314b8" translate="yes" xml:space="preserve">
          <source>Now, the alias &lt;code&gt;Kilometers&lt;/code&gt; is a &lt;em&gt;synonym&lt;/em&gt; for &lt;code&gt;i32&lt;/code&gt;; unlike the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; types we created in Listing 19-15, &lt;code&gt;Kilometers&lt;/code&gt; is not a separate, new type. Values that have the type &lt;code&gt;Kilometers&lt;/code&gt; will be treated the same as values of type &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">现在，别名 &lt;code&gt;Kilometers&lt;/code&gt; 是一个&lt;em&gt;同义词&lt;/em&gt;为 &lt;code&gt;i32&lt;/code&gt; ; 与清单19-15中创建的 &lt;code&gt;Millimeters&lt;/code&gt; 和 &lt;code&gt;Meters&lt;/code&gt; 类型不同， &lt;code&gt;Kilometers&lt;/code&gt; 不是独立的新类型。具有 &lt;code&gt;Kilometers&lt;/code&gt; 数类型的值将与类型 &lt;code&gt;i32&lt;/code&gt; 的值相同：</target>
        </trans-unit>
        <trans-unit id="89254150c2be7dc87d0a9f78d979708d51af3c47" translate="yes" xml:space="preserve">
          <source>Now, we can go further. Here are some erroneous code examples:</source>
          <target state="translated">现在,我们可以更进一步。这里有一些错误的代码例子。</target>
        </trans-unit>
        <trans-unit id="0a10d92135d2873e2b02f8fce9c6f1692a0cbb60" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;?&lt;/code&gt; instead of &lt;code&gt;match&lt;/code&gt;, and the return type makes a lot more sense: if the loop ever stops, it means that an error occurred. We don't even have to wrap the loop in an &lt;code&gt;Ok&lt;/code&gt; because &lt;code&gt;!&lt;/code&gt; coerces to &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; automatically.</source>
          <target state="translated">现在，我们可以使用 &lt;code&gt;?&lt;/code&gt; 而不是 &lt;code&gt;match&lt;/code&gt; ，并且返回类型更有意义：如果循环停止，则意味着发生错误。我们甚至不必将循环包装在 &lt;code&gt;Ok&lt;/code&gt; 中,因为 &lt;code&gt;!&lt;/code&gt; 自动转换为 &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00574ee534bf3b794cc8e985f367f79be7646f65" translate="yes" xml:space="preserve">
          <source>Now, when the server disconnects, we exit the loop with an error instead of panicking. While it might be intuitive to simply return the error, we might want to wrap it in a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">现在，当服务器断开连接时，我们以错误退出循环而不是惊慌失措。虽然简单地返回错误可能很直观，但我们可能希望将其包装在&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="63f5d491af12e32408bf602e1dfb4af7a20ca44f" translate="yes" xml:space="preserve">
          <source>Now, without changing any of the code, let&amp;rsquo;s build the project, as shown in Listing 2-2.</source>
          <target state="translated">现在，无需更改任何代码，就可以构建项目，如清单2-2所示。</target>
        </trans-unit>
        <trans-unit id="335506e2ff8a4e3e39e5a5e2b3fc6bf1463c0bb5" translate="yes" xml:space="preserve">
          <source>Now, you get all of the default values. Rust implements &lt;code&gt;Default&lt;/code&gt; for various primitives types.</source>
          <target state="translated">现在，您将获得所有默认值。Rust 为各种基本类型实现了 &lt;code&gt;Default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="019a7808328d4c7ef510130b49858e7cc7a93df4" translate="yes" xml:space="preserve">
          <source>NulError</source>
          <target state="translated">NulError</target>
        </trans-unit>
        <trans-unit id="0cb22fef16057827ecc4973a05f1f48159ecfb08" translate="yes" xml:space="preserve">
          <source>NulError::borrow</source>
          <target state="translated">NulError::borrow</target>
        </trans-unit>
        <trans-unit id="093c6ad11b2674276a386aef18e019c41e18c73d" translate="yes" xml:space="preserve">
          <source>NulError::borrow_mut</source>
          <target state="translated">NulError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2212c8b5028758465c03e3f70e4f2b53155ddf4f" translate="yes" xml:space="preserve">
          <source>NulError::cause</source>
          <target state="translated">NulError::cause</target>
        </trans-unit>
        <trans-unit id="29768f5bfd32a963dcb296b9cb20f40a82c74df5" translate="yes" xml:space="preserve">
          <source>NulError::clone</source>
          <target state="translated">NulError::clone</target>
        </trans-unit>
        <trans-unit id="11102afce6dc8292dc39655665283f8191fb13f1" translate="yes" xml:space="preserve">
          <source>NulError::clone_from</source>
          <target state="translated">NulError::clone_from</target>
        </trans-unit>
        <trans-unit id="f533f8602af54aaa16eff696d1575d42e14848a1" translate="yes" xml:space="preserve">
          <source>NulError::clone_into</source>
          <target state="translated">NulError::clone_into</target>
        </trans-unit>
        <trans-unit id="dbdb7cc3a8e4e6691a99909b0fc53de13cd8f2d3" translate="yes" xml:space="preserve">
          <source>NulError::description</source>
          <target state="translated">NulError::description</target>
        </trans-unit>
        <trans-unit id="90a567cb98b0dcdd50aff9ea97e9fff9eaab566d" translate="yes" xml:space="preserve">
          <source>NulError::eq</source>
          <target state="translated">NulError::eq</target>
        </trans-unit>
        <trans-unit id="5a4bafcb93f1795790aaa47109d1e73bf1dc48ee" translate="yes" xml:space="preserve">
          <source>NulError::fmt</source>
          <target state="translated">NulError::fmt</target>
        </trans-unit>
        <trans-unit id="fea70f345cef208acafc3c691d14a34ddbaffb2c" translate="yes" xml:space="preserve">
          <source>NulError::from</source>
          <target state="translated">NulError::from</target>
        </trans-unit>
        <trans-unit id="c667a60cc8a552cdd2774d6820e70ba3a6f7fa11" translate="yes" xml:space="preserve">
          <source>NulError::into</source>
          <target state="translated">NulError::into</target>
        </trans-unit>
        <trans-unit id="30b7683d9cdd43993a6fc1126ff7ee715887f7b2" translate="yes" xml:space="preserve">
          <source>NulError::into_vec</source>
          <target state="translated">NulError::into_vec</target>
        </trans-unit>
        <trans-unit id="0a051a00c0c437269ea80583c284491216e4bda7" translate="yes" xml:space="preserve">
          <source>NulError::ne</source>
          <target state="translated">NulError::ne</target>
        </trans-unit>
        <trans-unit id="2853d8c78438f77254b0a497c86fde1fc17dc043" translate="yes" xml:space="preserve">
          <source>NulError::nul_position</source>
          <target state="translated">NulError::nul_position</target>
        </trans-unit>
        <trans-unit id="266ad98111087a4df9e19e655c096e1306270de2" translate="yes" xml:space="preserve">
          <source>NulError::source</source>
          <target state="translated">NulError::source</target>
        </trans-unit>
        <trans-unit id="5a34a4566a411696ebf16a2b9ec49441272c8c0b" translate="yes" xml:space="preserve">
          <source>NulError::to_owned</source>
          <target state="translated">NulError::to_owned</target>
        </trans-unit>
        <trans-unit id="657290a7e7bc42a0480eee65c34175ba47172560" translate="yes" xml:space="preserve">
          <source>NulError::to_string</source>
          <target state="translated">NulError::to_string</target>
        </trans-unit>
        <trans-unit id="d1202df6e66660732652af8ec880ff1ae89ff7c3" translate="yes" xml:space="preserve">
          <source>NulError::try_from</source>
          <target state="translated">NulError::try_from</target>
        </trans-unit>
        <trans-unit id="1d16960d944bfade9db6cf467b0e67afd7e5faaf" translate="yes" xml:space="preserve">
          <source>NulError::try_into</source>
          <target state="translated">NulError::try_into</target>
        </trans-unit>
        <trans-unit id="1f3e1c8599374779dd8128ca0f06731901b2e4e4" translate="yes" xml:space="preserve">
          <source>NulError::type_id</source>
          <target state="translated">NulError::type_id</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="a7321f8049c14a666fefc1ca42149346db408d7b" translate="yes" xml:space="preserve">
          <source>Null-unchecked version</source>
          <target state="translated">无勾选版本</target>
        </trans-unit>
        <trans-unit id="2276df81ba459368e74bc9d4361d3c8cfd09f1df" translate="yes" xml:space="preserve">
          <source>Nullable pointers</source>
          <target state="translated">可空指针</target>
        </trans-unit>
        <trans-unit id="c25cad253b19d0908d73f07b038e8b9aad37e183" translate="yes" xml:space="preserve">
          <source>Number literals</source>
          <target state="translated">数字字面</target>
        </trans-unit>
        <trans-unit id="bcec75d4dad01d7ef8298e79673d17da682b5ff9" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2.</source>
          <target state="translated">基数为2的有意义的数字。</target>
        </trans-unit>
        <trans-unit id="2805eca363fc3f5bc17c10d2663c97e212a66b12" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">以2为底的有效位数。请改用&lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt; &lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12801815bc7acefa87d6f150e6c4da3f8cfc4e2c" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">以2为底的有效位数。请改用&lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt; &lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="21e67f90f74a7a640f48c34557cd9804c3bb16bf" translate="yes" xml:space="preserve">
          <source>Numeric Operations</source>
          <target state="translated">数值运算</target>
        </trans-unit>
        <trans-unit id="46e7eddaee58aa04d38eef7cd137db7696751094" translate="yes" xml:space="preserve">
          <source>Numeric cast</source>
          <target state="translated">数值铸造</target>
        </trans-unit>
        <trans-unit id="5fc7eba5de8d1ad8c7f788326b72adec568ef6c6" translate="yes" xml:space="preserve">
          <source>Numeric literal of specific type</source>
          <target state="translated">特定类型的数字文字</target>
        </trans-unit>
        <trans-unit id="1569010f07b1014b3cf4df2495e2025b598353cd" translate="yes" xml:space="preserve">
          <source>Numeric type</source>
          <target state="translated">数值型</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">数字类型</target>
        </trans-unit>
        <trans-unit id="448f04fec46467e790879ea8707bb67f916a6de0" translate="yes" xml:space="preserve">
          <source>Numeric values used in this type don't have portable meanings, and different platforms may mask different amounts of them.</source>
          <target state="translated">这种类型中使用的数值不具有可移植的含义,不同的平台可能会掩盖不同的数量。</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="41a98fdd88fe9c4cdb77aa3ef162d2e340554b26" translate="yes" xml:space="preserve">
          <source>O(1)~</source>
          <target state="translated">O(1)~</target>
        </trans-unit>
        <trans-unit id="aae47a530dc867303fbce9c5d00c60595dd72df2" translate="yes" xml:space="preserve">
          <source>O(1)~*</source>
          <target state="translated">O(1)~*</target>
        </trans-unit>
        <trans-unit id="21c63d891edf29bd0dc5694a68dc0fe5e6523174" translate="yes" xml:space="preserve">
          <source>O(log n)</source>
          <target state="translated">O(log n)</target>
        </trans-unit>
        <trans-unit id="e74f9c141120b2be3e1dcb28f8561ddce1e8fcd1" translate="yes" xml:space="preserve">
          <source>O(log(n))</source>
          <target state="translated">O(log(n))</target>
        </trans-unit>
        <trans-unit id="eed5a0c9d789f93df61247fbcb2bb3a3c20ad0c2" translate="yes" xml:space="preserve">
          <source>O(m)*</source>
          <target state="translated">O(m)*</target>
        </trans-unit>
        <trans-unit id="0a498ed9d22d1c99ae0662d3eb2e582169c852e2" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))</source>
          <target state="translated">O(min(i,n-i))</target>
        </trans-unit>
        <trans-unit id="dede0f12fa78bfb74f3fa2188214d44df32644d9" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))*</source>
          <target state="translated">O(min(i,n-i))*。</target>
        </trans-unit>
        <trans-unit id="1eb19fcfc5873ac1d44e4d58ddd8518a66a4491a" translate="yes" xml:space="preserve">
          <source>O(n+m)</source>
          <target state="translated">O(n+m)</target>
        </trans-unit>
        <trans-unit id="c8fadbf37575cb84317acb6f8d4f3d46463f8753" translate="yes" xml:space="preserve">
          <source>O(n-i)</source>
          <target state="translated">O(n-i)</target>
        </trans-unit>
        <trans-unit id="cc8b4f2a60d0d1f3741e6ca4292cce74adf6d07a" translate="yes" xml:space="preserve">
          <source>O(n-i)*</source>
          <target state="translated">O(n-i)*</target>
        </trans-unit>
        <trans-unit id="40df041793dd78f66b71a0840b6daf38640d0a3a" translate="yes" xml:space="preserve">
          <source>OCT_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;]</source>
          <target state="translated">OCT_DIGIT：[ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="2458dc9d400f320af963a0c090896d1bb8a3eafb" translate="yes" xml:space="preserve">
          <source>OCT_LITERAL :</source>
          <target state="translated">OCT_LITERAL :</target>
        </trans-unit>
        <trans-unit id="7eefb54fc6fa85bcfd8cad8fd3e002943372f832" translate="yes" xml:space="preserve">
          <source>ONCE_INIT</source>
          <target state="translated">ONCE_INIT</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="7367af2af477750e5937879b87fd589c058636c7" translate="yes" xml:space="preserve">
          <source>OS-specific behaviors</source>
          <target state="translated">操作系统特有的行为</target>
        </trans-unit>
        <trans-unit id="c616ed05e5cb0d4373e277ab3e8348ce34b627e9" translate="yes" xml:space="preserve">
          <source>OS-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">特定于OS的&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="d40770bb8444e5820c3f38469b205f65cc11cae4" translate="yes" xml:space="preserve">
          <source>OS-specific functionality.</source>
          <target state="translated">操作系统特有的功能。</target>
        </trans-unit>
        <trans-unit id="a6c434024b24606a906b9f03f39592fffa3be309" translate="yes" xml:space="preserve">
          <source>OUTER_BLOCK_DOC :</source>
          <target state="translated">OUTER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="0bb940376a39f5fb9ff8c9b1c3a635c5bc777eb9" translate="yes" xml:space="preserve">
          <source>OUTER_LINE_DOC :</source>
          <target state="translated">OUTER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="497044c1c5d284e50b6c69945072ebc9add34281" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming Features of Rust</source>
          <target state="translated">Rust的面向对象编程特性</target>
        </trans-unit>
        <trans-unit id="1cd60d3a8e30cd469c24d35e86095d88eed38ea9" translate="yes" xml:space="preserve">
          <source>Object Safety</source>
          <target state="translated">物品安全</target>
        </trans-unit>
        <trans-unit id="907637cc210857e2030448d19632670732a6954a" translate="yes" xml:space="preserve">
          <source>Object Safety Is Required for Trait Objects</source>
          <target state="translated">特质对象需要对象安全</target>
        </trans-unit>
        <trans-unit id="bca6b9d231b55a9e6e8a10f5e5322c009f386439" translate="yes" xml:space="preserve">
          <source>Object safe traits</source>
          <target state="translated">对象安全特征</target>
        </trans-unit>
        <trans-unit id="c0123c00fdac3367f93d574c1f48635a32708f0d" translate="yes" xml:space="preserve">
          <source>Object safe traits can be the base trait of a &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;. A trait is &lt;em&gt;object safe&lt;/em&gt; if it has the following qualities (defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt;):</source>
          <target state="translated">对象安全特征可以是&lt;a href=&quot;../types/trait-object&quot;&gt;特征对象&lt;/a&gt;的基本特征。如果特征具有以下特征（在&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255中&lt;/a&gt;定义），则该特征是&lt;em&gt;对象安全的&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="23297e036939da16d72f8c944d8900bfb5bf3104" translate="yes" xml:space="preserve">
          <source>Object-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay&amp;rsquo;s programming architecture in which objects pass messages to each other. He coined the term &lt;em&gt;object-oriented programming&lt;/em&gt; in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we&amp;rsquo;ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We&amp;rsquo;ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust&amp;rsquo;s strengths instead.</source>
          <target state="translated">面向对象编程（OOP）是对程序进行建模的一种方式。 1960年代，物体来自西姆拉。这些对象影响了Alan Kay的编程体系结构，在该体系结构中，对象彼此传递消息。他在1967 年创造了术语&amp;ldquo; &lt;em&gt;面向对象编程&amp;rdquo;&lt;/em&gt;来描述这种体系结构。许多竞争性的定义描述了OOP是什么；一些定义会将Rust归类为面向对象，而其他定义则不会。在本章中，我们将探讨通常被认为是面向对象的某些特征，以及这些特征如何转化为惯用的Rust。然后，我们将向您展示如何在Rust中实现面向对象的设计模式，并讨论这样做的权衡与使用Rust的一些优势来实施解决方案。</target>
        </trans-unit>
        <trans-unit id="93a2f7998a1b0abd936ff0b0c2f570cbbedd6635" translate="yes" xml:space="preserve">
          <source>Object-oriented programs are made up of objects. An &lt;em&gt;object&lt;/em&gt; packages both data and the procedures that operate on that data. The procedures are typically called &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;operations&lt;/em&gt;.</source>
          <target state="translated">面向对象的程序由对象组成。一个&lt;em&gt;对象&lt;/em&gt;封装了数据和操作这些数据的程序。该过程通常称为&lt;em&gt;方法&lt;/em&gt;或&lt;em&gt;操作&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="69fa88294fcaac54902a4347d53a07e91ef5771c" translate="yes" xml:space="preserve">
          <source>Objects Contain Data and Behavior</source>
          <target state="translated">对象包含数据和行为</target>
        </trans-unit>
        <trans-unit id="d206d3fa18be5581f351f10db48f9bf4a1014628" translate="yes" xml:space="preserve">
          <source>Objects that can be stepped over in both directions.</source>
          <target state="translated">可以双向踏过的物体。</target>
        </trans-unit>
        <trans-unit id="c6ec1c4f32b6ec8b2dd6c5acb228ddee1480f8b1" translate="yes" xml:space="preserve">
          <source>Objects that have a notion of &lt;em&gt;successor&lt;/em&gt; and &lt;em&gt;predecessor&lt;/em&gt; operations.</source>
          <target state="translated">具有&lt;em&gt;后继&lt;/em&gt;和&lt;em&gt;前任&lt;/em&gt;操作概念的对象。</target>
        </trans-unit>
        <trans-unit id="b899f01274e7bc44fb14d411dd765a15a7787c5f" translate="yes" xml:space="preserve">
          <source>Occasionally it may be desirable not to expose in an API that there is mutation happening &quot;under the hood&quot;. This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">有时可能希望不要在API中公开&amp;ldquo;在幕后&amp;rdquo;发生的突变。这可能是因为该操作在逻辑上是不可变的，但是例如，缓存会强制实现执行突变；或因为必须使用变体才能实现最初定义为采用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 的特征方法。</target>
        </trans-unit>
        <trans-unit id="473e728a2f59da64c670799897819b1d614ba35f" translate="yes" xml:space="preserve">
          <source>OccupiedEntry</source>
          <target state="translated">OccupiedEntry</target>
        </trans-unit>
        <trans-unit id="9d9953ee64c9a9ed960498f1a51e79c8aae9c8dd" translate="yes" xml:space="preserve">
          <source>Occurrences of &lt;code&gt;.&lt;/code&gt; are normalized away, except if they are at the beginning of the path. For example, &lt;code&gt;a/./b&lt;/code&gt;, &lt;code&gt;a/b/&lt;/code&gt;, &lt;code&gt;a/b/.&lt;/code&gt; and &lt;code&gt;a/b&lt;/code&gt; all have &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as components, but &lt;code&gt;./a/b&lt;/code&gt; starts with an additional &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt;&lt;code&gt;CurDir&lt;/code&gt;&lt;/a&gt; component.</source>
          <target state="translated">发生的情况 &lt;code&gt;.&lt;/code&gt; 被归一化，除非它们位于路径的开头。例如， &lt;code&gt;a/./b&lt;/code&gt; ， &lt;code&gt;a/b/&lt;/code&gt; ， &lt;code&gt;a/b/.&lt;/code&gt; 和 &lt;code&gt;a/b&lt;/code&gt; 都有 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 作为组成部分，但是 &lt;code&gt;./a/b&lt;/code&gt; 以附加的&lt;a href=&quot;enum.component#variant.CurDir&quot;&gt; &lt;code&gt;CurDir&lt;/code&gt; &lt;/a&gt;组件开头。</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="e6f02e23e2b227ac6699b92be300da464d475a6e" translate="yes" xml:space="preserve">
          <source>Octal integer</source>
          <target state="translated">八进制整数</target>
        </trans-unit>
        <trans-unit id="d04577406c042a11b4da7bb39486816308c607a6" translate="yes" xml:space="preserve">
          <source>Octal::fmt</source>
          <target state="translated">Octal::fmt</target>
        </trans-unit>
        <trans-unit id="615b20b5b110a1806177c985ebbca57031daa785" translate="yes" xml:space="preserve">
          <source>Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.</source>
          <target state="translated">当然,知道哪种集合是正确的工作,并不能立即允许你正确使用它。这里有一些快速的提示,可以让你有效和正确地使用一般的标准集合。如果您对如何使用特定的集合感兴趣,请查阅它的文档以获得详细的讨论和代码示例。</target>
        </trans-unit>
        <trans-unit id="2cbe09e34f3d1d91d444d3537b55bb92b3326aea" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;a href=&quot;fn.stdout&quot;&gt;&lt;code&gt;io::stdout&lt;/code&gt;&lt;/a&gt; directly is less common than something like &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当然，直接使用&lt;a href=&quot;fn.stdout&quot;&gt; &lt;code&gt;io::stdout&lt;/code&gt; &lt;/a&gt;比诸如&lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;东西少见。。</target>
        </trans-unit>
        <trans-unit id="35c2f4d3ee9ba6ff467650c366d5a389ebdd0812" translate="yes" xml:space="preserve">
          <source>Of course, you can do it as long as the module you're referring to is an ancestor:</source>
          <target state="translated">当然,只要你所指的模块是祖先,你就可以这样做。</target>
        </trans-unit>
        <trans-unit id="35d478ea3e054425d68cac2b881bb4303c629df5" translate="yes" xml:space="preserve">
          <source>Often, you&amp;rsquo;ll want to combine two existing strings. One way is to use the &lt;code&gt;+&lt;/code&gt; operator, as shown in Listing 8-18.</source>
          <target state="translated">通常，您需要合并两个现有的字符串。一种方法是使用 &lt;code&gt;+&lt;/code&gt; 运算符，如清单8-18所示。</target>
        </trans-unit>
        <trans-unit id="3894dea4e557c370e601b5214f719623a770bfec" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;packed&lt;/code&gt; structs</source>
          <target state="translated">在 &lt;code&gt;packed&lt;/code&gt; 结构上</target>
        </trans-unit>
        <trans-unit id="6b1d4e18544489b4eaf442b238d12d6d0846066b" translate="yes" xml:space="preserve">
          <source>On Linux systems, if this is compiled as &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">在Linux系统上，如果将其编译为 &lt;code&gt;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="81c83f6982dcc0359616815ff2d1c2e0f9aa8bfa" translate="yes" xml:space="preserve">
          <source>On Linux, macOS, and PowerShell on Windows, you can see the executable by entering the &lt;code&gt;ls&lt;/code&gt; command in your shell. On Linux and macOS, you&amp;rsquo;ll see two files. With PowerShell on Windows, you&amp;rsquo;ll see the same three files that you would see using CMD.</source>
          <target state="translated">在Linux，macOS和Windows上的PowerShell中，您可以通过在Shell中输入 &lt;code&gt;ls&lt;/code&gt; 命令来查看可执行文件。在Linux和macOS上，您将看到两个文件。使用Windows上的PowerShell，您将看到与使用CMD相同的三个文件。</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="translated">在Linux上。</target>
        </trans-unit>
        <trans-unit id="28f964279968ee11e024ad4734a1849f6d567b40" translate="yes" xml:space="preserve">
          <source>On Redox this always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">在Redox上，它总是返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c27c55a04c34d1416124c71c1487f965daf5e2b" translate="yes" xml:space="preserve">
          <source>On Unix</source>
          <target state="translated">在Unix上</target>
        </trans-unit>
        <trans-unit id="f580d63739e00a5c78d3db723e0a54f4eebdec61" translate="yes" xml:space="preserve">
          <source>On Unix platforms, calling this method corresponds to calling &lt;code&gt;fcntl&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;. On Windows calling this method corresponds to calling &lt;code&gt;ioctlsocket&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;.</source>
          <target state="translated">在Unix平台上，调用此方法对应于调用 &lt;code&gt;fcntl&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; 。在Windows上，调用此方法与调用 &lt;code&gt;ioctlsocket&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; 相对应。</target>
        </trans-unit>
        <trans-unit id="368e8ed37eeed58c150496b19476b91dc7031ee8" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times.</source>
          <target state="translated">在Unix平台上,底层的syscall可能会被虚假的唤醒或信号处理程序打断。为了确保睡眠至少在指定的时间内发生,该函数可能会多次调用该系统调用。</target>
        </trans-unit>
        <trans-unit id="5d8d403cb28547a9afda373b97085e009420f7cc" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times. Platforms which do not support nanosecond precision for sleeping will have &lt;code&gt;dur&lt;/code&gt; rounded up to the nearest granularity of time they can sleep for.</source>
          <target state="translated">在Unix平台上，底层的系统调用可能会被虚假的唤醒或信号处理程序中断。为了确保至少在指定的持续时间内发生睡眠，此函数可以多次调用该系统调用。不支持纳秒精度睡觉都会有平台 &lt;code&gt;dur&lt;/code&gt; 四舍五入到的时候，他们可以睡上最近的粒度。</target>
        </trans-unit>
        <trans-unit id="f15b383f304eefe4931d61a084a59f34627760f4" translate="yes" xml:space="preserve">
          <source>On Unix systems shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">在Unix系统上，shell通常使用glob模式（例如 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;?&lt;/code&gt; ）扩展未加引号的参数。在Windows上，此操作尚未完成，并且此类参数按原样传递。</target>
        </trans-unit>
        <trans-unit id="35aecf3282b41109feea97145ac8fcf33e5a85c0" translate="yes" xml:space="preserve">
          <source>On Unix systems the shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">在Unix系统上，shell通常使用glob模式（例如 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;?&lt;/code&gt; ）扩展未加引号的参数。在Windows上，此操作尚未完成，并且此类参数按原样传递。</target>
        </trans-unit>
        <trans-unit id="73ed9ce935220230672af1ba06994403c22fd01d" translate="yes" xml:space="preserve">
          <source>On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well.</source>
          <target state="translated">在Unix系统中,当使用基于pthread的TLS时,当主线程退出时,不会为主线程上的TLS值运行析构函数。请注意,在主线程退出后,应用程序也会立即退出。</target>
        </trans-unit>
        <trans-unit id="fb3ee6950e481b93ea06bd207e97b8f1a208a9e6" translate="yes" xml:space="preserve">
          <source>On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.</source>
          <target state="translated">在Unix系统中,字符串通常是由非零字节组成的任意序列,在许多情况下被解释为UTF-8。</target>
        </trans-unit>
        <trans-unit id="ade1ebaf1f97bbb67b44937124b853209f01a0de" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which augments it with two methods, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt;&lt;code&gt;from_bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;. These do inexpensive conversions from and to UTF-8 byte slices.</source>
          <target state="translated">在Unix上，&lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt;特性，该特性通过&lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt; &lt;code&gt;from_bytes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt;两种方法进行了扩充。它们可以在UTF-8字节片之间进行廉价的转换。</target>
        </trans-unit>
        <trans-unit id="947b55450ee1839446a5472dd42bc83b983d60aa" translate="yes" xml:space="preserve">
          <source>On Unix, a path has a root if it begins with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">在Unix上，如果路径以 &lt;code&gt;/&lt;/code&gt; 开头，则其根为根。</target>
        </trans-unit>
        <trans-unit id="3bd3b4c86524e4799caf099ecd37af36c6672deb" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">在Unix上，如果路径以根开头，则它是绝对路径，因此 &lt;code&gt;is_absolute&lt;/code&gt; 和&lt;a href=&quot;#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt;是等效的。</target>
        </trans-unit>
        <trans-unit id="c1d8cd80a5b3e4b5d2416174dfc8848e290d79c0" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;struct.path#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">在Unix上，如果路径以根开头，则它是绝对路径，因此 &lt;code&gt;is_absolute&lt;/code&gt; 和&lt;a href=&quot;struct.path#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt;是等效的。</target>
        </trans-unit>
        <trans-unit id="8c49b23a9e8913d5f28e887403c1dd64ea25f5f0" translate="yes" xml:space="preserve">
          <source>On Unix, this will return &lt;code&gt;None&lt;/code&gt; if the process was terminated by a signal; &lt;code&gt;std::os::unix&lt;/code&gt; provides an extension trait for extracting the signal and other details from the &lt;code&gt;ExitStatus&lt;/code&gt;.</source>
          <target state="translated">在Unix上，如果进程被信号终止，它将返回 &lt;code&gt;None&lt;/code&gt; ;否则，它将返回None。 &lt;code&gt;std::os::unix&lt;/code&gt; 提供了扩展特性，用于从 &lt;code&gt;ExitStatus&lt;/code&gt; 中提取信号和其他详细信息。</target>
        </trans-unit>
        <trans-unit id="08103bc8083664f610de1cd76da40c7342e367bf" translate="yes" xml:space="preserve">
          <source>On Windows</source>
          <target state="translated">在Windows上</target>
        </trans-unit>
        <trans-unit id="340634e7ba37ae9abb46e394a10f468ca07b5406" translate="yes" xml:space="preserve">
          <source>On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to &lt;code&gt;symlink_metadata&lt;/code&gt; to learn about the target file type.</source>
          <target state="translated">在Windows和大多数Unix平台上，此功能是免费的（不需要额外的系统调用），但是某些Unix平台可能需要等效调用 &lt;code&gt;symlink_metadata&lt;/code&gt; 来了解目标文件类型。</target>
        </trans-unit>
        <trans-unit id="dc05b2580f0d12742976994a81fdd3a92daa9627" translate="yes" xml:space="preserve">
          <source>On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling &lt;code&gt;symlink_metadata&lt;/code&gt; on the path.</source>
          <target state="translated">在Windows上，此函数调用便宜（不需要额外的系统调用），但是在Unix平台上，此函数等效于在路径上调用 &lt;code&gt;symlink_metadata&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96488f7f2e398f8d620db102c3767404f52cec35" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Windows上，&lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt;特性，该特性提供了&lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt;方法。这提供了一个迭代器，可以将其&lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;到&lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;的向量中。</target>
        </trans-unit>
        <trans-unit id="354971d9fc4cf41d4726d0f246b8a7efa90a20dd" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Windows上，&lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt;特性，该特性提供了&lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt;方法。这提供了一个迭代器，可以将其&lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;到&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;的向量中。</target>
        </trans-unit>
        <trans-unit id="9af64d7ebac16f152870c457029381910a90ad98" translate="yes" xml:space="preserve">
          <source>On Windows, a path has a root if it:</source>
          <target state="translated">在Windows上,一个路径有一个根,如果它。</target>
        </trans-unit>
        <trans-unit id="23aad31490e7c68a187977dea619fd53f62cad2c" translate="yes" xml:space="preserve">
          <source>On Windows, a path is absolute if it has a prefix and starts with the root: &lt;code&gt;c:\windows&lt;/code&gt; is absolute, while &lt;code&gt;c:temp&lt;/code&gt; and &lt;code&gt;\temp&lt;/code&gt; are not.</source>
          <target state="translated">在Windows上，如果路径带有前缀并以根开头，则它是绝对路径： &lt;code&gt;c:\windows&lt;/code&gt; 是绝对路径，而 &lt;code&gt;c:temp&lt;/code&gt; 和 &lt;code&gt;\temp&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="76c59bd2f582fcbc4571a1c46e5718df63ea4def" translate="yes" xml:space="preserve">
          <source>On Windows, a symbolic link knows whether it is a file or directory.</source>
          <target state="translated">在Windows上,符号链接知道它是文件还是目录。</target>
        </trans-unit>
        <trans-unit id="21bc0d515b3e6fb7f3d9412e9a760b756bd52140" translate="yes" xml:space="preserve">
          <source>On Windows, enter the command &lt;code&gt;.\main.exe&lt;/code&gt; instead of &lt;code&gt;./main&lt;/code&gt;:</source>
          <target state="translated">在Windows上，输入命​​令 &lt;code&gt;.\main.exe&lt;/code&gt; 而不是 &lt;code&gt;./main&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a5430ea74797e1304f80750653012edbeaab36ca" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. When asked which workloads to install make sure &quot;C++ build tools&quot; is selected and that the Windows 10 SDK and the English language pack components are included.</source>
          <target state="translated">在Windows上，转到&lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt;并按照说明安装Rust。在安装过程中的某个时刻，您会收到一条消息，说明您还需要用于Visual Studio 2013或更高版本的C ++生成工具。获取构建工具的最简单方法是&lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;为Visual Studio 2019&lt;/a&gt;安装构建工具。当被问及要安装哪些工作负载时，请确保已选择&amp;ldquo; C ++构建工具&amp;rdquo;，并且包括Windows 10 SDK和英语包。</target>
        </trans-unit>
        <trans-unit id="bd7a73ca0a18d815fd6e51cfa03502575932403d" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. The tools are in the Other Tools and Frameworks section.</source>
          <target state="translated">在Windows上，转到&lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt;并按照说明安装Rust。在安装过程中的某个时刻，您会收到一条消息，说明您还需要用于Visual Studio 2013或更高版本的C ++生成工具。获取构建工具的最简单方法是&lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;为Visual Studio 2019&lt;/a&gt;安装构建工具。这些工具在&amp;ldquo;其他工具和框架&amp;rdquo;部分中。</target>
        </trans-unit>
        <trans-unit id="f9e96b3ce49cbd593ce10eba431579916c1beb4e" translate="yes" xml:space="preserve">
          <source>On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.</source>
          <target state="translated">在Windows上,字符串通常是非零的16位值的任意序列,在有效的情况下被解释为UTF-16。</target>
        </trans-unit>
        <trans-unit id="4d87cfdfbe26beaf98d7cabde9343985e270cf11" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">在Windows上，这会将路径转换为使用&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;扩展长度路径&lt;/a&gt;语法，这使您的程序可以使用更长的路径名，但意味着您只能将反斜杠分隔的路径连接到该路径，并且它可能与其他应用程序不兼容（如果传递给命令行上的应用程序，或写入另一个应用程序可能会读取的文件）。</target>
        </trans-unit>
        <trans-unit id="e57ac5776aebf69e1a4091e5f62bdd9bd9a59609" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">在Windows上，这会将路径转换为使用&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;扩展长度路径&lt;/a&gt;语法，这使您的程序可以使用更长的路径名，但是这意味着您只能将反斜杠分隔的路径连接到它，并且它可能与其他应用程序不兼容（如果传递给命令行上的应用程序，或写入另一个应用程序可以读取的文件）。</target>
        </trans-unit>
        <trans-unit id="22cfd134aef9e5447e4029c33c01913e82dca29d" translate="yes" xml:space="preserve">
          <source>On Windows, you must specify whether a symbolic link points to a file or directory. Use &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; to create a symbolic link to a file, or &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; to create a symbolic link to a directory. Additionally, the process must have &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; in order to be able to create a symbolic link.</source>
          <target state="translated">在Windows上，必须指定符号链接指向文件还是目录。使用 &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; 创建指向文件的符号链接，或者使用 &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; 创建指向目录的符号链接。此外，该过程必须具有 &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; 才能创建符号链接。</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">在Windows上。</target>
        </trans-unit>
        <trans-unit id="2d943049f7275605af2957c0729af75e15804644" translate="yes" xml:space="preserve">
          <source>On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">在结构模式上，通过名称，索引（在元组结构的情况下）或通过使用 &lt;code&gt;..&lt;/code&gt; 忽略字段来引用字段：</target>
        </trans-unit>
        <trans-unit id="bc5ae395985a077524b266fc2c058a9c41f9a6c9" translate="yes" xml:space="preserve">
          <source>On a technical level, Rust inserts</source>
          <target state="translated">在技术层面上,锈迹斑斑</target>
        </trans-unit>
        <trans-unit id="1b348ad01b675597a26bee9f6007707cf4e88f3f" translate="yes" xml:space="preserve">
          <source>On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.</source>
          <target state="translated">在所有的平台上,TLS都有可能在销毁过程中重新初始化其他TLS插槽。一些平台通过防止重新初始化任何已经被销毁的槽来确保这种情况不会无限发生,但并不是所有的平台都有这种防护措施。那些没有防护的平台通常有一个合成限制,过了这个限制,就不会再运行销毁器了。</target>
        </trans-unit>
        <trans-unit id="037d4731f94d8fe39eb9b4a6879b2f19130604a0" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;)).</source>
          <target state="translated">在所有平台上，换行符仅是LINE FEED字符（ &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ）（没有其他的回车符（ &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ））。</target>
        </trans-unit>
        <trans-unit id="d799d2a3d45a2a27a645560d44031039269d8400" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;).</source>
          <target state="translated">在所有平台上，换行符仅是LINE FEED字符（ &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ）（没有其他的回车符（ &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8026d1566cfb33142845deb08dc55be0e48c8b84" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutErr&lt;/code&gt;.</source>
          <target state="translated">发生算术溢出时，返回 &lt;code&gt;LayoutErr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf819fffd5786da2be15358bf27201c594c34573" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutError&lt;/code&gt;.</source>
          <target state="translated">发生算术溢出时，返回 &lt;code&gt;LayoutError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62056a56ee350ef2ac48d7878ee0e8c05c6cdab9" translate="yes" xml:space="preserve">
          <source>On big endian this is a no-op. On little endian the bytes are swapped.</source>
          <target state="translated">在大恩迪安上,这是个不可能的事情,在小恩迪安上,字节被交换。在小恩迪安上,字节是交换的。</target>
        </trans-unit>
        <trans-unit id="3209db243d37f470d1d7cfe42ce3d766b7bc29ef" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;CString&lt;/code&gt; is returned.</source>
          <target state="translated">失败时，将返回原始 &lt;code&gt;CString&lt;/code&gt; 的所有权。</target>
        </trans-unit>
        <trans-unit id="4c9afd72e5fc07b12e4a58aab05b5a861ccfe991" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;OsString&lt;/code&gt; is returned.</source>
          <target state="translated">失败时，将返回原始 &lt;code&gt;OsString&lt;/code&gt; 的所有权。</target>
        </trans-unit>
        <trans-unit id="259a9191e45f4405904adb74ccfbaecde8fac969" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &quot;.init_array&quot;. Glibc passes argc, argv, and envp to functions in &quot;.init_array&quot;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="translated">在glibc Linux系统上，可通过将函数放在&amp;ldquo; .init_array&amp;rdquo;中来检索参数。Glibc将argc，argv和envp作为非标准扩展传递给&amp;ldquo; .init_array&amp;rdquo;中的函数。这使 &lt;code&gt;std::env::args&lt;/code&gt; 甚至可以在 &lt;code&gt;cdylib&lt;/code&gt; 或 &lt;code&gt;staticlib&lt;/code&gt; 中工作，就像在macOS和Windows上一样。</target>
        </trans-unit>
        <trans-unit id="d682d53e730f8107b6e28e70ea3aca1f2f84a3a2" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &lt;code&gt;.init_array&lt;/code&gt;. Glibc passes &lt;code&gt;argc&lt;/code&gt;, &lt;code&gt;argv&lt;/code&gt;, and &lt;code&gt;envp&lt;/code&gt; to functions in &lt;code&gt;.init_array&lt;/code&gt;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="translated">在glibc Linux系统上，可通过将函数放在 &lt;code&gt;.init_array&lt;/code&gt; 中来检索参数。Glibc将 &lt;code&gt;argc&lt;/code&gt; ， &lt;code&gt;argv&lt;/code&gt; 和 &lt;code&gt;envp&lt;/code&gt; 传递给 &lt;code&gt;.init_array&lt;/code&gt; 中的函数，作为非标准扩展名。这使 &lt;code&gt;std::env::args&lt;/code&gt; 甚至可以在 &lt;code&gt;cdylib&lt;/code&gt; 或 &lt;code&gt;staticlib&lt;/code&gt; 中工作，就像在macOS和Windows上一样。</target>
        </trans-unit>
        <trans-unit id="3818a4eb5a3ae2432429a2be6f00d2b57327ad67" translate="yes" xml:space="preserve">
          <source>On iteration, the closure will be applied to each element of the iterator and the return value from the closure, an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;, is yielded by the iterator.</source>
          <target state="translated">在迭代过程中，闭包将应用于迭代器的每个元素，并且闭包的返回值&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;由迭代器产生。</target>
        </trans-unit>
        <trans-unit id="7ac8ec0fd24d5e212f6e7881f085d7af49a49607" translate="yes" xml:space="preserve">
          <source>On little endian this is a no-op. On big endian the bytes are swapped.</source>
          <target state="translated">在小恩迪安上,这是不可能的。在大恩迪安上,字节是交换的。</target>
        </trans-unit>
        <trans-unit id="4e3e1efffa4b7d24fe7283223e058e550576b614" translate="yes" xml:space="preserve">
          <source>On many architectures, this function can perform better than &lt;code&gt;leading_zeros()&lt;/code&gt; on the underlying integer type, as special handling of zero can be avoided.</source>
          <target state="translated">在许多体系结构上，此函数在底层整数类型上的性能可能优于 &lt;code&gt;leading_zeros()&lt;/code&gt; ，因为可以避免对零的特殊处理。</target>
        </trans-unit>
        <trans-unit id="848a615b6290900cfd1ddd55f346fc45b2bed670" translate="yes" xml:space="preserve">
          <source>On many architectures, this function can perform better than &lt;code&gt;trailing_zeros()&lt;/code&gt; on the underlying integer type, as special handling of zero can be avoided.</source>
          <target state="translated">在许多体系结构上，此函数的性能要优于底层整数类型的 &lt;code&gt;trailing_zeros()&lt;/code&gt; ，因为可以避免对零的特殊处理。</target>
        </trans-unit>
        <trans-unit id="5d4ddcfc8d324d93f4c94125de45c5742f4d5101" translate="yes" xml:space="preserve">
          <source>On non-pointer types &lt;code&gt;*x&lt;/code&gt; is equivalent to &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; in an &lt;a href=&quot;../expressions#mutability&quot;&gt;immutable place expression context&lt;/a&gt; and &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; in a mutable place expression context.</source>
          <target state="translated">在非指针类型 &lt;code&gt;*x&lt;/code&gt; 相当于 &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; 中的&lt;a href=&quot;../expressions#mutability&quot;&gt;不可变的地方表达上下文&lt;/a&gt;和 &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 在一个可变的地方表达式上下文。</target>
        </trans-unit>
        <trans-unit id="152e667068d08065574b6f3ea75735b1ef22f81c" translate="yes" xml:space="preserve">
          <source>On panic, this macro will print the values of the expressions with their debug representations.</source>
          <target state="translated">恐慌时,这个宏将打印表达式的值与其调试表示。</target>
        </trans-unit>
        <trans-unit id="a0e8d873b690ac84365bcb6ce9a48ba9ac4a73cf" translate="yes" xml:space="preserve">
          <source>On some system, calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">在某些系统上，操作系统释放资源需要调用&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;或类似命令。终止但尚未等待的进程仍然是&amp;ldquo;僵尸&amp;rdquo;。留下太多的僵尸可能会耗尽全局资源（例如，进程ID）。</target>
        </trans-unit>
        <trans-unit id="8d680bbd1b29ac2bd7f1c4039cc2f034c2409b58" translate="yes" xml:space="preserve">
          <source>On some systems, calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">在某些系统上，操作系统释放资源需要调用&lt;a href=&quot;struct.child#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;或类似命令。终止但尚未等待的进程仍然是&amp;ldquo;僵尸&amp;rdquo;。留下太多的僵尸可能会耗尽全局资源（例如，进程ID）。</target>
        </trans-unit>
        <trans-unit id="f95b6f9f5ca3589fe7d076155399faa6b71dbbbe" translate="yes" xml:space="preserve">
          <source>On success this function will not return, and otherwise it will return an error indicating why the exec (or another part of the setup of the &lt;code&gt;Command&lt;/code&gt;) failed.</source>
          <target state="translated">成功执行后，此函数将不会返回，否则将返回错误，指示exec（或 &lt;code&gt;Command&lt;/code&gt; 设置的另一部分）失败的原因。</target>
        </trans-unit>
        <trans-unit id="9dc3aca4d292aed062c338c543e13af0f74c89de" translate="yes" xml:space="preserve">
          <source>On success, returns a &lt;a href=&quot;../ptr/struct.nonnull&quot;&gt;&lt;code&gt;NonNull&amp;lt;[u8]&amp;gt;&lt;/code&gt;&lt;/a&gt; meeting the size and alignment guarantees of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">成功时，返回一个&lt;a href=&quot;../ptr/struct.nonnull&quot;&gt; &lt;code&gt;NonNull&amp;lt;[u8]&amp;gt;&lt;/code&gt; &lt;/a&gt;满足的尺寸和对准保证 &lt;code&gt;layout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="105508220fba1586b41aed6de3e9afe8bdcad7d2" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and if the data was truncated.</source>
          <target state="translated">成功时,返回读取的字节数以及数据是否被截断。</target>
        </trans-unit>
        <trans-unit id="85ee4aa1b293e333458ae17de2dc9971adc5a07b" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and the address from whence the data came.</source>
          <target state="translated">成功后,返回读取的字节数和数据来源地址。</target>
        </trans-unit>
        <trans-unit id="dfc14b3f66c1dadb297ac68b0d484bfc6cc7a217" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.</source>
          <target state="translated">成功后,如果数据被截断,返回读取的字节数和msg的地址。</target>
        </trans-unit>
        <trans-unit id="4ea0ccaabe0c9b1fbc90341ab5a04d65215e560d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read.</source>
          <target state="translated">成功时,返回读取的字节数。</target>
        </trans-unit>
        <trans-unit id="bc5a49aba56a5b26329959ae0e37a7391cbb54ed" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes written.</source>
          <target state="translated">成功时,返回写入的字节数。</target>
        </trans-unit>
        <trans-unit id="f9b7167ab1cb81802d4cc93ff38048bd7cd2f218" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes copied is returned and it is equal to the length of the &lt;code&gt;to&lt;/code&gt; file as reported by &lt;code&gt;metadata&lt;/code&gt;.</source>
          <target state="translated">成功后，将返回复制的字节总数，该总数等于 &lt;code&gt;metadata&lt;/code&gt; 报告的 &lt;code&gt;to&lt;/code&gt; 文件的长度。</target>
        </trans-unit>
        <trans-unit id="a6bfa6f8c514698639a06b222dc94c1639495b9f" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes that were copied from &lt;code&gt;reader&lt;/code&gt; to &lt;code&gt;writer&lt;/code&gt; is returned.</source>
          <target state="translated">成功后，将返回从 &lt;code&gt;reader&lt;/code&gt; 复制到 &lt;code&gt;writer&lt;/code&gt; 器的字节总数。</target>
        </trans-unit>
        <trans-unit id="43a00d4716ce2886f17dadaa3b0e2204d940167a" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Screen&lt;/code&gt; struct, we&amp;rsquo;ll define a method named &lt;code&gt;run&lt;/code&gt; that will call the &lt;code&gt;draw&lt;/code&gt; method on each of its &lt;code&gt;components&lt;/code&gt;, as shown in Listing 17-5:</source>
          <target state="translated">在 &lt;code&gt;Screen&lt;/code&gt; 结构上，我们将定义一个名为 &lt;code&gt;run&lt;/code&gt; 的方法，该方法将在其每个 &lt;code&gt;components&lt;/code&gt; 上调用 &lt;code&gt;draw&lt;/code&gt; 方法，如清单17-5所示：</target>
        </trans-unit>
        <trans-unit id="417a01b51fb2fc402d7ff9e7a38ed36ddb3ab97a" translate="yes" xml:space="preserve">
          <source>On the first line of &lt;code&gt;main&lt;/code&gt;, we call &lt;code&gt;env::args&lt;/code&gt;, and we immediately use &lt;code&gt;collect&lt;/code&gt; to turn the iterator into a vector containing all the values produced by the iterator. We can use the &lt;code&gt;collect&lt;/code&gt; function to create many kinds of collections, so we explicitly annotate the type of &lt;code&gt;args&lt;/code&gt; to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, &lt;code&gt;collect&lt;/code&gt; is one function you do often need to annotate because Rust isn&amp;rsquo;t able to infer the kind of collection you want.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 的第一行，我们调用 &lt;code&gt;env::args&lt;/code&gt; ，然后立即使用 &lt;code&gt;collect&lt;/code&gt; 将迭代器转换为包含迭代器产生的所有值的向量。我们可以使用 &lt;code&gt;collect&lt;/code&gt; 函数创建多种集合，因此我们显式注释 &lt;code&gt;args&lt;/code&gt; 的类型以指定我们想要字符串向量。尽管我们很少需要在Rust中注释类型，但是 &lt;code&gt;collect&lt;/code&gt; 是您经常需要注释的功能之一，因为Rust无法推断您想要的集合类型。</target>
        </trans-unit>
        <trans-unit id="9eddcffce559b2f4fd96faa276545d34f1b2fe9a" translate="yes" xml:space="preserve">
          <source>On the other hand, one trait which would not be appropriate to implement is &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">另一方面，不适合实施的一个特征是&lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c286483c8f6ceb616a180cf64f82c92b911d5676" translate="yes" xml:space="preserve">
          <source>On the other hand, this is correct:</source>
          <target state="translated">另一方面,这是对的。</target>
        </trans-unit>
        <trans-unit id="8cf67f3b833240197b7f3967e7a28b88e1336e77" translate="yes" xml:space="preserve">
          <source>On the other hand, this will not compile because the &lt;code&gt;where 'b: 'a&lt;/code&gt; clause is missing: the &lt;code&gt;'b&lt;/code&gt; lifetime is not known to live at least as long as &lt;code&gt;'a&lt;/code&gt; which means this function cannot ensure it always returns a valid reference:</source>
          <target state="translated">另一方面，这将不会编译，因为缺少 &lt;code&gt;where 'b: 'a&lt;/code&gt; 子句：已知 &lt;code&gt;'b&lt;/code&gt; 的生存期至少与 &lt;code&gt;'a&lt;/code&gt; 一样长，这意味着该函数无法确保它始终返回有效的引用：</target>
        </trans-unit>
        <trans-unit id="09d6ad3b118e12286d44db37bda32a77e5392fde" translate="yes" xml:space="preserve">
          <source>On the other hand, when bringing in structs, enums, and other items with &lt;code&gt;use&lt;/code&gt;, it&amp;rsquo;s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library&amp;rsquo;s &lt;code&gt;HashMap&lt;/code&gt; struct into the scope of a binary crate.</source>
          <target state="translated">另一方面，当 &lt;code&gt;use&lt;/code&gt; 引入结构，枚举和其他项目时，指定完整路径是惯用的。清单7-14显示了将标准库的 &lt;code&gt;HashMap&lt;/code&gt; 结构引入二进制条板箱范围的惯用方式。</target>
        </trans-unit>
        <trans-unit id="50d2f428f140a723a3dc474c3eb5d43ababe5b45" translate="yes" xml:space="preserve">
          <source>On the other hand, with the method using trait objects, one &lt;code&gt;Screen&lt;/code&gt; instance can hold a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that contains a &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; as well as a &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at how this works, and then we&amp;rsquo;ll talk about the runtime performance implications.</source>
          <target state="translated">另一方面，使用使用特征对象的方法，一个 &lt;code&gt;Screen&lt;/code&gt; 实例可以容纳一个 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，该Vec &amp;lt;T&amp;gt;包含 &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt; 。让我们看一下它是如何工作的，然后我们将讨论运行时性能的含义。</target>
        </trans-unit>
        <trans-unit id="05a08140d648b8eef0f62e5e0b016ae12318d58b" translate="yes" xml:space="preserve">
          <source>On the surface, &lt;code&gt;static&lt;/code&gt; items seem very similar to &lt;a href=&quot;keyword.const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt;s: both contain a value, both require type annotations and both can only be initialized with constant functions and values. However, &lt;code&gt;static&lt;/code&gt;s are notably different in that they represent a location in memory. That means that you can have references to &lt;code&gt;static&lt;/code&gt; items and potentially even modify them, making them essentially global variables.</source>
          <target state="translated">从表面上看， &lt;code&gt;static&lt;/code&gt; 项与&lt;a href=&quot;keyword.const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt;非常相似：都包含一个值，都需要类型注释，并且都只能使用常量函数和值进行初始化。但是， &lt;code&gt;static&lt;/code&gt; 变量s的显着不同之处在于它们表示内存中的位置。这意味着您可以引用 &lt;code&gt;static&lt;/code&gt; 项目，甚至可以对其进行修改，从而使它们本质上是全局变量。</target>
        </trans-unit>
        <trans-unit id="8593d2dddd7916b4461c2238bc4c5b8191583e5e" translate="yes" xml:space="preserve">
          <source>On top of that, all additional invariants of the type &lt;code&gt;T&lt;/code&gt; must be satisfied, as the &lt;code&gt;Drop&lt;/code&gt; implementation of &lt;code&gt;T&lt;/code&gt; (or its members) may rely on this. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Dropping such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; however will cause undefined behaviour.</source>
          <target state="translated">最重要的是，必须满足类型 &lt;code&gt;T&lt;/code&gt; 的所有其他不变量，因为 &lt;code&gt;T&lt;/code&gt; （或其成员）的 &lt;code&gt;Drop&lt;/code&gt; 实现可能依赖于此。例如，将 &lt;code&gt;1&lt;/code&gt; 初始化的&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;视为已初始化（在当前实现下；这并不构成稳定的保证），因为编译器知道的唯一要求是数据指针必须为非null。但是，丢弃这样的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 会导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="7d7c692a18f46234aa3957edc945a28ff83c44fe" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword before the type, followed by the ABI in question. The default ABI is &quot;Rust&quot;, i.e., &lt;code&gt;fn()&lt;/code&gt; is the exact same type as &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt;. A pointer to a function with C ABI would have type &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;.</source>
          <target state="translated">最重要的是，函数指针可以根据使用的ABI有所不同。这可以通过在类型之前添加 &lt;code&gt;extern&lt;/code&gt; 关键字来实现，然后再加上有问题的ABI。默认的ABI是&amp;ldquo; Rust&amp;rdquo;，即， &lt;code&gt;fn()&lt;/code&gt; 与 &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt; 类型完全相同。指向具有C ABI的函数的指针将具有类型 &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7c793eb037e8ef3b7da8efa89ac452132495eae" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword to the type name, followed by the ABI in question. For example, &lt;code&gt;fn()&lt;/code&gt; is different from &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;, which itself is different from &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt;, and so on for the various ABIs that Rust supports. Non-&lt;code&gt;extern&lt;/code&gt; functions have an ABI of &lt;code&gt;&quot;Rust&quot;&lt;/code&gt;, and &lt;code&gt;extern&lt;/code&gt; functions without an explicit ABI have an ABI of &lt;code&gt;&quot;C&quot;&lt;/code&gt;. For more information, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;the nomicon's section on foreign calling conventions&lt;/a&gt;.</source>
          <target state="translated">最重要的是，函数指针可以根据使用的ABI有所不同。这是通过将 &lt;code&gt;extern&lt;/code&gt; 关键字添加到类型名称中，然后添加有问题的ABI来实现的。例如， &lt;code&gt;fn()&lt;/code&gt; 与 &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; 不同，后者本身与 &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt; 不同，对于Rust支持的各种ABI来说，依此类推。非 &lt;code&gt;extern&lt;/code&gt; 函数的ABI为 &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ，而没有显式ABI的 &lt;code&gt;extern&lt;/code&gt; 函数的ABI为 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;有关外来调用约定的nomicon部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b2aa688af42ea89b3fbf818f2d4bdeab6c73c4a" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">最重要的是，请记住，大多数类型具有其他不变式，而不仅仅是在类型级别上被初始化。例如，将 &lt;code&gt;1&lt;/code&gt; 初始化的&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;视为已初始化（在当前实现下；这并不构成稳定的保证），因为编译器知道的唯一要求是数据指针必须为非null。创建这样的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 不会&lt;em&gt;立即&lt;/em&gt;导致未定义的行为，但是会在大多数安全操作（包括删除操作）中导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="630c59f788be2f8b6b4b1ca247b245094c3530e8" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">最重要的是，请记住，大多数类型具有其他不变式，而不仅仅是在类型级别被初始化。例如，将 &lt;code&gt;1&lt;/code&gt; 初始化的&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;视为已初始化，因为编译器知道的唯一要求是数据指针必须为非null。创建这样的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 不会&lt;em&gt;立即&lt;/em&gt;导致未定义的行为，但是会在大多数安全操作（包括删除操作）中导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="dde4e913efe3a7bb20d91e29731b497ad0b7ade2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;Config::new&lt;/code&gt; takes ownership of the iterator and stops using indexing operations that borrow, we can move the &lt;code&gt;String&lt;/code&gt; values from the iterator into &lt;code&gt;Config&lt;/code&gt; rather than calling &lt;code&gt;clone&lt;/code&gt; and making a new allocation.</source>
          <target state="translated">一旦 &lt;code&gt;Config::new&lt;/code&gt; 拥有了迭代器的所有权并停止使用借用的索引操作，我们就可以将 &lt;code&gt;String&lt;/code&gt; 值从迭代器移到 &lt;code&gt;Config&lt;/code&gt; 中,而不用调用 &lt;code&gt;clone&lt;/code&gt; 并进行新的分配。</target>
        </trans-unit>
        <trans-unit id="8b0de6bbc4d6a271545919a41560436f915e4647" translate="yes" xml:space="preserve">
          <source>Once a future has completed (returned &lt;code&gt;Ready&lt;/code&gt; from &lt;code&gt;poll&lt;/code&gt;), calling its &lt;code&gt;poll&lt;/code&gt; method again may panic, block forever, or cause other kinds of problems; the &lt;code&gt;Future&lt;/code&gt; trait places no requirements on the effects of such a call. However, as the &lt;code&gt;poll&lt;/code&gt; method is not marked &lt;code&gt;unsafe&lt;/code&gt;, Rust's usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of &lt;code&gt;unsafe&lt;/code&gt; functions, or the like), regardless of the future's state.</source>
          <target state="translated">一旦将来完成（从 &lt;code&gt;poll&lt;/code&gt; 返回为 &lt;code&gt;Ready&lt;/code&gt; ），再次调用其 &lt;code&gt;poll&lt;/code&gt; 方法可能会出现恐慌，永久性阻塞或引起其他类型的问题；在 &lt;code&gt;Future&lt;/code&gt; 特质放在这样的电话的效果没有要求。但是，由于没有将 &lt;code&gt;poll&lt;/code&gt; 方法标记为 &lt;code&gt;unsafe&lt;/code&gt; ，Rust的通常规则适用：无论将来的状态如何，调用都绝不能引起未定义的行为（内存损坏，对 &lt;code&gt;unsafe&lt;/code&gt; 函数的错误使用等）。</target>
        </trans-unit>
        <trans-unit id="472f512f503c00a7a3badf54bca4e8a984d78d81" translate="yes" xml:space="preserve">
          <source>Once a future has finished, clients should not &lt;code&gt;poll&lt;/code&gt; it again.</source>
          <target state="translated">将来完成后，客户不应再次对其进行 &lt;code&gt;poll&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52d66dce2b0cbeb3ef0b4a40c595411581c4bf47" translate="yes" xml:space="preserve">
          <source>Once a valid size is received, our &lt;code&gt;ThreadPool&lt;/code&gt; creates a new vector that can hold &lt;code&gt;size&lt;/code&gt; items. We haven&amp;rsquo;t used the &lt;code&gt;with_capacity&lt;/code&gt; function in this book yet, which performs the same task as &lt;code&gt;Vec::new&lt;/code&gt; but with an important difference: it preallocates space in the vector. Because we know we need to store &lt;code&gt;size&lt;/code&gt; elements in the vector, doing this allocation up front is slightly more efficient than using &lt;code&gt;Vec::new&lt;/code&gt;, which resizes itself as elements are inserted.</source>
          <target state="translated">收到有效尺寸后，我们的 &lt;code&gt;ThreadPool&lt;/code&gt; 将创建一个可以容纳 &lt;code&gt;size&lt;/code&gt; 项目的新矢量。本书尚未使用 &lt;code&gt;with_capacity&lt;/code&gt; 函数，该函数执行与 &lt;code&gt;Vec::new&lt;/code&gt; 相同的任务，但有一个重要区别：它在向量中预分配了空间。因为我们知道我们需要将 &lt;code&gt;size&lt;/code&gt; 元素存储在向量中，所以与使用 &lt;code&gt;Vec::new&lt;/code&gt; 进行预先分配相比，使用Vec :: new效率更高，后者会在插入元素时自动调整大小。</target>
        </trans-unit>
        <trans-unit id="b9c2a150a70fbfb0f86650e1f5cd73ca0f595c49" translate="yes" xml:space="preserve">
          <source>Once again we're using &lt;code&gt;!&lt;/code&gt;'s ability to coerce into any other type, in this case &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;. Since this method takes a &lt;code&gt;&amp;amp;!&lt;/code&gt; as an argument we know that it can never be called (because there is no value of type &lt;code&gt;!&lt;/code&gt; for it to be called with). Writing &lt;code&gt;*self&lt;/code&gt; essentially tells the compiler &quot;We know that this code can never be run, so just treat the entire function body as having type &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;&quot;. This pattern can be used a lot when implementing traits for &lt;code&gt;!&lt;/code&gt;. Generally, any trait which only has methods which take a &lt;code&gt;self&lt;/code&gt; parameter should have such an impl.</source>
          <target state="translated">我们再次使用 &lt;code&gt;!&lt;/code&gt; 强制转换为其他任何类型的能力，在本例中为&lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;。由于此方法需要 &lt;code&gt;&amp;amp;!&lt;/code&gt; 作为参数，我们知道，它永远不会被调用（因为没有类型的值 &lt;code&gt;!&lt;/code&gt; 它与被调用）。编写 &lt;code&gt;*self&lt;/code&gt; 本质上告诉编译器&amp;ldquo;我们知道该代码永远无法运行，因此只需将整个函数体视为&lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;类型&amp;rdquo;即可。在实现trait时，可以使用此模式很多 &lt;code&gt;!&lt;/code&gt; 。通常，任何仅具有采用 &lt;code&gt;self&lt;/code&gt; 参数的方法的特征都应具有这样的含义。</target>
        </trans-unit>
        <trans-unit id="3c60f2098dcfc1948a1cd5eb57c13cccf48d2d00" translate="yes" xml:space="preserve">
          <source>Once again, we compile and get... different errors! The compiler is teaching us a lot.</source>
          <target state="translated">再一次,我们编译后得到的是...不同的错误! 编译器教会了我们很多东西。</target>
        </trans-unit>
        <trans-unit id="30ba447807ee16c40637ce8c42ca10892e8780ac" translate="yes" xml:space="preserve">
          <source>Once half of a channel has been deallocated, most operations can no longer continue to make progress, so &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned. Many applications will continue to &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt; the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.</source>
          <target state="translated">一旦重新分配了一半的通道，大多数操作将不再继续进行，因此将返回&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。许多应用程序将继续&lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt;从该模块返回的结果，如果一个线程意外死亡，则会导致线程之间传播失败。</target>
        </trans-unit>
        <trans-unit id="a91c464fe4209e458222e2a75f2d92f1b46b0155" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="translated">一旦内部存储是连续的，所述&lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt; &lt;code&gt;as_slices&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt; &lt;code&gt;as_mut_slices&lt;/code&gt; &lt;/a&gt;方法将返回的全部内容 &lt;code&gt;VecDeque&lt;/code&gt; 在单个切片。</target>
        </trans-unit>
        <trans-unit id="6364bb4d426e3f0cecb2911427f26ed73152d755" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="translated">一旦内部存储是连续的，所述&lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt; &lt;code&gt;as_slices&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt; &lt;code&gt;as_mut_slices&lt;/code&gt; &lt;/a&gt;方法将返回的全部内容 &lt;code&gt;VecDeque&lt;/code&gt; 在单个切片。</target>
        </trans-unit>
        <trans-unit id="7b36c9a4ffe1c545648e7557d44e1b469b4df260" translate="yes" xml:space="preserve">
          <source>Once this function returns, the contents of &lt;code&gt;bufs&lt;/code&gt; are unspecified, as this depends on how many calls to &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; were necessary. It is best to understand this function as taking ownership of &lt;code&gt;bufs&lt;/code&gt; and to not use &lt;code&gt;bufs&lt;/code&gt; afterwards. The underlying buffers, to which the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s point (but not the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s themselves), are unchanged and can be reused.</source>
          <target state="translated">一旦此函数返回，则 &lt;code&gt;bufs&lt;/code&gt; 的内容将不确定，因为这取决于需要对&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt;进行多少次调用。最好将此功能理解为拥有 &lt;code&gt;bufs&lt;/code&gt; 的所有权，并且此后不使用 &lt;code&gt;bufs&lt;/code&gt; 。&lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt;指向的基础缓冲区（而不是&lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt;本身）是不变的，可以重用。</target>
        </trans-unit>
        <trans-unit id="0fa4b20ac7b7c2a8a0f92535a2333b6aa807706f" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we used iterators with &lt;code&gt;for&lt;/code&gt; loops to execute some code on each item, although we glossed over what the call to &lt;code&gt;iter&lt;/code&gt; did until now.</source>
          <target state="translated">创建迭代器后，我们可以通过多种方式使用它。在第3章的清单3-5中，我们使用了带有 &lt;code&gt;for&lt;/code&gt; 循环的迭代器在每个项目上执行一些代码，尽管我们掩盖了到目前为止对 &lt;code&gt;iter&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="58851a1903858c976f2730a714ae3f3f46765304" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve implemented the &lt;code&gt;Iterator&lt;/code&gt; trait, we have an iterator! Listing 13-22 shows a test demonstrating that we can use the iterator functionality of our &lt;code&gt;Counter&lt;/code&gt; struct by calling the &lt;code&gt;next&lt;/code&gt; method on it directly, just as we did with the iterator created from a vector in Listing 13-15.</source>
          <target state="translated">一旦实现了 &lt;code&gt;Iterator&lt;/code&gt; 特质，便有了一个迭代器！清单13-22显示了一个测试，该测试表明我们可以通过直接调用 &lt;code&gt;Counter&lt;/code&gt; 结构的 &lt;code&gt;next&lt;/code&gt; 方法来使用Counter结构的迭代器功能，就像我们使用清单13-15中的向量创建的迭代器一样。</target>
        </trans-unit>
        <trans-unit id="84bcbd885f09e288fb3013478b1c1b345aab434e" translate="yes" xml:space="preserve">
          <source>Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the &lt;code&gt;[-]&lt;/code&gt; button near the top of the page to collapse it into a more skimmable view.</source>
          <target state="translated">一旦您熟悉了标准库的内容，您可能会发现散文分散了人们的冗长。在开发的此阶段，您可能需要按页面顶部附近的 &lt;code&gt;[-]&lt;/code&gt; 按钮将其折叠为更可浏览的视图。</target>
        </trans-unit>
        <trans-unit id="f9e4ff73fcbf2b9b71b1855afa48c76c6aa49139" translate="yes" xml:space="preserve">
          <source>Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; method to get a read-only raw pointer to pass to extern functions. See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.</source>
          <target state="translated">一旦有了所需的切片类型（带或不带nul终止符），就可以调用切片自己的&lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt;方法以获取只读的原始指针，以将其传递给extern函数。有关确保原始指针的生存期的讨论，请参见该函数的文档。</target>
        </trans-unit>
        <trans-unit id="ef776c26c7f6b2f89aaf4c349afba29be9ab2040" translate="yes" xml:space="preserve">
          <source>Once::all</source>
          <target state="translated">Once::all</target>
        </trans-unit>
        <trans-unit id="fa85c00dce196844734611fc55302ba498cdda9b" translate="yes" xml:space="preserve">
          <source>Once::any</source>
          <target state="translated">Once::any</target>
        </trans-unit>
        <trans-unit id="826f1ec43224196e7c0e18a9f4c8ba3d03de27f1" translate="yes" xml:space="preserve">
          <source>Once::borrow</source>
          <target state="translated">Once::borrow</target>
        </trans-unit>
        <trans-unit id="e53e91b8fe24cb0570a1a97b3316a02ec5d3ee03" translate="yes" xml:space="preserve">
          <source>Once::borrow_mut</source>
          <target state="translated">Once::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c2f8e8374534fd9f5e2ff592398a6ffc6014fd99" translate="yes" xml:space="preserve">
          <source>Once::by_ref</source>
          <target state="translated">Once::by_ref</target>
        </trans-unit>
        <trans-unit id="28a72e0c985bccd2edce22b1340d3ed027a4ac1f" translate="yes" xml:space="preserve">
          <source>Once::call_once</source>
          <target state="translated">Once::call_once</target>
        </trans-unit>
        <trans-unit id="e0cfc1e91951cfca51a0190fd8a21d0b035190a9" translate="yes" xml:space="preserve">
          <source>Once::call_once_force</source>
          <target state="translated">Once::call_once_force</target>
        </trans-unit>
        <trans-unit id="1376857cb86f72af6eff74ad397cf00fcde6210e" translate="yes" xml:space="preserve">
          <source>Once::chain</source>
          <target state="translated">Once::chain</target>
        </trans-unit>
        <trans-unit id="190ff92b2c593bf6e13bca7abde87e505a3ec2bb" translate="yes" xml:space="preserve">
          <source>Once::clone</source>
          <target state="translated">Once::clone</target>
        </trans-unit>
        <trans-unit id="212f098b1763e1e51ae7f7bc19ffa302ddfe30a1" translate="yes" xml:space="preserve">
          <source>Once::clone_from</source>
          <target state="translated">Once::clone_from</target>
        </trans-unit>
        <trans-unit id="311f7aa02f0a54433f61dae481c3b3e4040d2495" translate="yes" xml:space="preserve">
          <source>Once::clone_into</source>
          <target state="translated">Once::clone_into</target>
        </trans-unit>
        <trans-unit id="19afa196b08d6f8f3b6f43f40d2d7cd3c50fbc8f" translate="yes" xml:space="preserve">
          <source>Once::cloned</source>
          <target state="translated">Once::cloned</target>
        </trans-unit>
        <trans-unit id="6b4930ea79c81962eae48dcaf70c7227f1aa12a7" translate="yes" xml:space="preserve">
          <source>Once::cmp</source>
          <target state="translated">Once::cmp</target>
        </trans-unit>
        <trans-unit id="5d169980cad74ac2c6880808ed94fb787b98960a" translate="yes" xml:space="preserve">
          <source>Once::collect</source>
          <target state="translated">Once::collect</target>
        </trans-unit>
        <trans-unit id="313d94ea32a51b1b516cb8b52850728efe9ae8b5" translate="yes" xml:space="preserve">
          <source>Once::copied</source>
          <target state="translated">Once::copied</target>
        </trans-unit>
        <trans-unit id="f98560cce6e4eadc3911ce81d61f52d107ea5142" translate="yes" xml:space="preserve">
          <source>Once::count</source>
          <target state="translated">Once::count</target>
        </trans-unit>
        <trans-unit id="2ef6bd0928aad3dcaf46fb7f0bdafb3492745ec4" translate="yes" xml:space="preserve">
          <source>Once::cycle</source>
          <target state="translated">Once::cycle</target>
        </trans-unit>
        <trans-unit id="8ad5b4150f82970fff0038e17ac64a51521d1924" translate="yes" xml:space="preserve">
          <source>Once::enumerate</source>
          <target state="translated">Once::enumerate</target>
        </trans-unit>
        <trans-unit id="23c903ad536fa2bd73035fce46787048ed4f628a" translate="yes" xml:space="preserve">
          <source>Once::eq</source>
          <target state="translated">Once::eq</target>
        </trans-unit>
        <trans-unit id="82879e4fcf39171c09b466e2bf43bc8f45af6822" translate="yes" xml:space="preserve">
          <source>Once::filter</source>
          <target state="translated">Once::filter</target>
        </trans-unit>
        <trans-unit id="095605951ca140555bd59e4149308c63f272478d" translate="yes" xml:space="preserve">
          <source>Once::filter_map</source>
          <target state="translated">Once::filter_map</target>
        </trans-unit>
        <trans-unit id="7ca070326207c327aa1bb557f657f2fac61b1c8a" translate="yes" xml:space="preserve">
          <source>Once::find</source>
          <target state="translated">Once::find</target>
        </trans-unit>
        <trans-unit id="f8cbae0491d42da2ee0b9caaa6d41cbeef0233e4" translate="yes" xml:space="preserve">
          <source>Once::find_map</source>
          <target state="translated">Once::find_map</target>
        </trans-unit>
        <trans-unit id="8f0358e16d2477b8dc5e572ca1dae6005b455b17" translate="yes" xml:space="preserve">
          <source>Once::flat_map</source>
          <target state="translated">Once::flat_map</target>
        </trans-unit>
        <trans-unit id="8580b5a613c1d1f4df99cede210bdc2e9fe3a843" translate="yes" xml:space="preserve">
          <source>Once::flatten</source>
          <target state="translated">Once::flatten</target>
        </trans-unit>
        <trans-unit id="c9a403b6a5f9f7ce825a2ce8e6b8fc78c53b4261" translate="yes" xml:space="preserve">
          <source>Once::fmt</source>
          <target state="translated">Once::fmt</target>
        </trans-unit>
        <trans-unit id="a4dbe0ef075896956284d0f6da5e3cf48dd08238" translate="yes" xml:space="preserve">
          <source>Once::fold</source>
          <target state="translated">Once::fold</target>
        </trans-unit>
        <trans-unit id="9129023999880ed84891680b4f8fd96dda590894" translate="yes" xml:space="preserve">
          <source>Once::for_each</source>
          <target state="translated">Once::for_each</target>
        </trans-unit>
        <trans-unit id="d64f18e6780e0faf671ed9d539a0b268b8174066" translate="yes" xml:space="preserve">
          <source>Once::from</source>
          <target state="translated">Once::from</target>
        </trans-unit>
        <trans-unit id="bbf7ace21ce049891d14dd08bdb7b81831f05411" translate="yes" xml:space="preserve">
          <source>Once::fuse</source>
          <target state="translated">Once::fuse</target>
        </trans-unit>
        <trans-unit id="6d843124e3a2669cb3c40cac626394b00fbd78a9" translate="yes" xml:space="preserve">
          <source>Once::ge</source>
          <target state="translated">Once::ge</target>
        </trans-unit>
        <trans-unit id="a9af56769b34f56c5ffcf89a8ea47ff768c6858a" translate="yes" xml:space="preserve">
          <source>Once::gt</source>
          <target state="translated">Once::gt</target>
        </trans-unit>
        <trans-unit id="52b97e5420ac6c5141f11b243b00d6a1d91a82aa" translate="yes" xml:space="preserve">
          <source>Once::inspect</source>
          <target state="translated">Once::inspect</target>
        </trans-unit>
        <trans-unit id="24c9670c06579750ad91802403773c861f00f73c" translate="yes" xml:space="preserve">
          <source>Once::into</source>
          <target state="translated">Once::into</target>
        </trans-unit>
        <trans-unit id="efb0afcea9cf69ad9f300407891f7cf24889abde" translate="yes" xml:space="preserve">
          <source>Once::into_iter</source>
          <target state="translated">Once::into_iter</target>
        </trans-unit>
        <trans-unit id="0608fd7f8eac14cce16ca80dbfd5613b14204122" translate="yes" xml:space="preserve">
          <source>Once::is_completed</source>
          <target state="translated">Once::is_completed</target>
        </trans-unit>
        <trans-unit id="7251c3dcf49fe3c4c5830d926dcb3f340b9a4518" translate="yes" xml:space="preserve">
          <source>Once::is_empty</source>
          <target state="translated">Once::is_empty</target>
        </trans-unit>
        <trans-unit id="4b0fbfe12c4a015929a04dd53407a0499a03410c" translate="yes" xml:space="preserve">
          <source>Once::is_sorted</source>
          <target state="translated">Once::is_sorted</target>
        </trans-unit>
        <trans-unit id="6f25e0f3331d93f4e5eb47652d49ab83abddd5c6" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by</source>
          <target state="translated">Once::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="cb7a1da6af62c62d1c48e6f892b45246ff8fb722" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by_key</source>
          <target state="translated">Once::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="12b8716333449d7ef6ccc84a866d8c71f4d4596a" translate="yes" xml:space="preserve">
          <source>Once::last</source>
          <target state="translated">Once::last</target>
        </trans-unit>
        <trans-unit id="14b21ec5ab3251444e0715d08a995824bf98046f" translate="yes" xml:space="preserve">
          <source>Once::le</source>
          <target state="translated">Once::le</target>
        </trans-unit>
        <trans-unit id="c7ec127a76b81f92cbddfa60f7e443869f07dfc3" translate="yes" xml:space="preserve">
          <source>Once::len</source>
          <target state="translated">Once::len</target>
        </trans-unit>
        <trans-unit id="5200802a32d08edabd28e77c8bfacda66faabb5f" translate="yes" xml:space="preserve">
          <source>Once::lt</source>
          <target state="translated">Once::lt</target>
        </trans-unit>
        <trans-unit id="f2976b7d4debc6f0c6faff19e72feb23c6da98c9" translate="yes" xml:space="preserve">
          <source>Once::map</source>
          <target state="translated">Once::map</target>
        </trans-unit>
        <trans-unit id="37c43ed9043bf5a1d86c776c7a83980f8e44b550" translate="yes" xml:space="preserve">
          <source>Once::max</source>
          <target state="translated">Once::max</target>
        </trans-unit>
        <trans-unit id="42f687a90cb8ae799fc923fe98bf332780e16e1a" translate="yes" xml:space="preserve">
          <source>Once::max_by</source>
          <target state="translated">Once::max_by</target>
        </trans-unit>
        <trans-unit id="f790fae0c1ab8520d2b3bb6dee8c10e0df61fb21" translate="yes" xml:space="preserve">
          <source>Once::max_by_key</source>
          <target state="translated">Once::max_by_key</target>
        </trans-unit>
        <trans-unit id="be86a53ca110f0c0f2e5f786db25770b11e8fb89" translate="yes" xml:space="preserve">
          <source>Once::min</source>
          <target state="translated">Once::min</target>
        </trans-unit>
        <trans-unit id="5b4c2bfd34d4ce8913a24cdbba40c903c58ba228" translate="yes" xml:space="preserve">
          <source>Once::min_by</source>
          <target state="translated">Once::min_by</target>
        </trans-unit>
        <trans-unit id="0ff4bd1f1edb9d1e53ee61824c45a6b65f4eafd0" translate="yes" xml:space="preserve">
          <source>Once::min_by_key</source>
          <target state="translated">Once::min_by_key</target>
        </trans-unit>
        <trans-unit id="6236fe088142c957857770ab09a2b6fc2f27b69e" translate="yes" xml:space="preserve">
          <source>Once::ne</source>
          <target state="translated">Once::ne</target>
        </trans-unit>
        <trans-unit id="7d6911dda1f2483e209159a8e136b2c52051e6bb" translate="yes" xml:space="preserve">
          <source>Once::new</source>
          <target state="translated">Once::new</target>
        </trans-unit>
        <trans-unit id="578bd116c5e7fde5716979b05be2a783abe2fcec" translate="yes" xml:space="preserve">
          <source>Once::next</source>
          <target state="translated">Once::next</target>
        </trans-unit>
        <trans-unit id="8af821c9e317f67614d97739eed7d7394a46629b" translate="yes" xml:space="preserve">
          <source>Once::next_back</source>
          <target state="translated">Once::next_back</target>
        </trans-unit>
        <trans-unit id="430bb3482a938ef6cd7fe977041d4fa3bbc1fc55" translate="yes" xml:space="preserve">
          <source>Once::nth</source>
          <target state="translated">Once::nth</target>
        </trans-unit>
        <trans-unit id="c55b0c5a25d6a4c7729b67045964bd182f6c743b" translate="yes" xml:space="preserve">
          <source>Once::nth_back</source>
          <target state="translated">Once::nth_back</target>
        </trans-unit>
        <trans-unit id="22c36618829e3a03fdefff9bbca40dbd8e473846" translate="yes" xml:space="preserve">
          <source>Once::partial_cmp</source>
          <target state="translated">Once::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b7269ba05ed7753f4b47e7a0b54fad46c7fdfa25" translate="yes" xml:space="preserve">
          <source>Once::partition</source>
          <target state="translated">Once::partition</target>
        </trans-unit>
        <trans-unit id="a2a93318d906b75ba7d478b7d2053f09b5d47c8e" translate="yes" xml:space="preserve">
          <source>Once::peekable</source>
          <target state="translated">Once::peekable</target>
        </trans-unit>
        <trans-unit id="443ba5a518af1ceeeb00165b521452d07ea04e5b" translate="yes" xml:space="preserve">
          <source>Once::position</source>
          <target state="translated">Once::position</target>
        </trans-unit>
        <trans-unit id="aefb04c2392cc211f451d367f733cc6c65c3e11b" translate="yes" xml:space="preserve">
          <source>Once::product</source>
          <target state="translated">Once::product</target>
        </trans-unit>
        <trans-unit id="0bc9c08f73c34cac78d945ebc22d8397bbb66131" translate="yes" xml:space="preserve">
          <source>Once::rev</source>
          <target state="translated">Once::rev</target>
        </trans-unit>
        <trans-unit id="3c7856aff7c1c10689eb91760b905ac36a86fd8f" translate="yes" xml:space="preserve">
          <source>Once::rfind</source>
          <target state="translated">Once::rfind</target>
        </trans-unit>
        <trans-unit id="bb98b537fa90b815cfad245be9b6f8a9980c10ad" translate="yes" xml:space="preserve">
          <source>Once::rfold</source>
          <target state="translated">Once::rfold</target>
        </trans-unit>
        <trans-unit id="068dbc2b0446d02924974dc89dc2e5c0506be3c0" translate="yes" xml:space="preserve">
          <source>Once::rposition</source>
          <target state="translated">Once::rposition</target>
        </trans-unit>
        <trans-unit id="2f7d42081a9a3b1a18973e17303b804987f7c991" translate="yes" xml:space="preserve">
          <source>Once::scan</source>
          <target state="translated">Once::scan</target>
        </trans-unit>
        <trans-unit id="689e357b41f0be20a1862814b9c83d77ef8f1e70" translate="yes" xml:space="preserve">
          <source>Once::size_hint</source>
          <target state="translated">Once::size_hint</target>
        </trans-unit>
        <trans-unit id="cbf339d38d49468cb345d7cfb9cb77b78f365fd1" translate="yes" xml:space="preserve">
          <source>Once::skip</source>
          <target state="translated">Once::skip</target>
        </trans-unit>
        <trans-unit id="86fd91a24a1bbc66ca2ece695858498a65db16dd" translate="yes" xml:space="preserve">
          <source>Once::skip_while</source>
          <target state="translated">Once::skip_while</target>
        </trans-unit>
        <trans-unit id="6fe0f81f7153271dc977040947a6cad61882f9d1" translate="yes" xml:space="preserve">
          <source>Once::step_by</source>
          <target state="translated">Once::step_by</target>
        </trans-unit>
        <trans-unit id="033b2578f1615ee184814d95335d5fd74302c231" translate="yes" xml:space="preserve">
          <source>Once::sum</source>
          <target state="translated">Once::sum</target>
        </trans-unit>
        <trans-unit id="442e2927616d29972c328197ab646af0a109e0ac" translate="yes" xml:space="preserve">
          <source>Once::take</source>
          <target state="translated">Once::take</target>
        </trans-unit>
        <trans-unit id="e0055054cf1a45bf179b412f905b6b7b804fe427" translate="yes" xml:space="preserve">
          <source>Once::take_while</source>
          <target state="translated">Once::take_while</target>
        </trans-unit>
        <trans-unit id="1ff7fdb84e0ce09813e50c320654790d32c718fe" translate="yes" xml:space="preserve">
          <source>Once::to_owned</source>
          <target state="translated">Once::to_owned</target>
        </trans-unit>
        <trans-unit id="b045ee709dc7ad89b9c21500aecbcde1537d7e58" translate="yes" xml:space="preserve">
          <source>Once::try_fold</source>
          <target state="translated">Once::try_fold</target>
        </trans-unit>
        <trans-unit id="ca7011c5d5b35881f4391164193c191f7c91a8ed" translate="yes" xml:space="preserve">
          <source>Once::try_for_each</source>
          <target state="translated">Once::try_for_each</target>
        </trans-unit>
        <trans-unit id="145392f846fa35a3754a9cdb737cf3389c9b3bb1" translate="yes" xml:space="preserve">
          <source>Once::try_from</source>
          <target state="translated">Once::try_from</target>
        </trans-unit>
        <trans-unit id="36d585158ca953d0dbbe69c61419f1e9cfd5cbd0" translate="yes" xml:space="preserve">
          <source>Once::try_into</source>
          <target state="translated">Once::try_into</target>
        </trans-unit>
        <trans-unit id="bb47966988d0ea30157cfc9b32edfc0454ef3340" translate="yes" xml:space="preserve">
          <source>Once::try_rfold</source>
          <target state="translated">Once::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e7005b30f23dbe8e521fbb090487b02e260839e" translate="yes" xml:space="preserve">
          <source>Once::type_id</source>
          <target state="translated">Once::type_id</target>
        </trans-unit>
        <trans-unit id="89b4b7dbbcd40342a9b06361de2f912cf9887391" translate="yes" xml:space="preserve">
          <source>Once::unzip</source>
          <target state="translated">Once::unzip</target>
        </trans-unit>
        <trans-unit id="9c587dbc5b4ada9eb96816888453bd9099854f2c" translate="yes" xml:space="preserve">
          <source>Once::zip</source>
          <target state="translated">Once::zip</target>
        </trans-unit>
        <trans-unit id="69dcb4de79e8a81381a0466b75f257a36ecf89cd" translate="yes" xml:space="preserve">
          <source>OnceCell</source>
          <target state="translated">OnceCell</target>
        </trans-unit>
        <trans-unit id="2db71cb543a4836972aba340022bf66c34ca9483" translate="yes" xml:space="preserve">
          <source>OnceState</source>
          <target state="translated">OnceState</target>
        </trans-unit>
        <trans-unit id="864b2494c0a17291fe44802d2dfa7280c6515a58" translate="yes" xml:space="preserve">
          <source>OnceState::borrow</source>
          <target state="translated">OnceState::borrow</target>
        </trans-unit>
        <trans-unit id="3ba03425574355acef161a03b37753e3dc3fce0d" translate="yes" xml:space="preserve">
          <source>OnceState::borrow_mut</source>
          <target state="translated">OnceState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="137f612918b3ff9f01b5b2eed8a892cbbde080f1" translate="yes" xml:space="preserve">
          <source>OnceState::fmt</source>
          <target state="translated">OnceState::fmt</target>
        </trans-unit>
        <trans-unit id="cc9d74ec28c33e153d2d0894a6de5f14c5c9aabd" translate="yes" xml:space="preserve">
          <source>OnceState::from</source>
          <target state="translated">OnceState::from</target>
        </trans-unit>
        <trans-unit id="d968db4b631f42cce77d0ea2bff8656be4e57c06" translate="yes" xml:space="preserve">
          <source>OnceState::into</source>
          <target state="translated">OnceState::into</target>
        </trans-unit>
        <trans-unit id="5279da3ce88f5a2ebd344f9b9ae566f2cb009268" translate="yes" xml:space="preserve">
          <source>OnceState::poisoned</source>
          <target state="translated">OnceState::poisoned</target>
        </trans-unit>
        <trans-unit id="8447bc72e127b3443efef418a2e8188e3cc3f620" translate="yes" xml:space="preserve">
          <source>OnceState::try_from</source>
          <target state="translated">OnceState::try_from</target>
        </trans-unit>
        <trans-unit id="2a35fc55239b76803a74ad10688fe793f6102501" translate="yes" xml:space="preserve">
          <source>OnceState::try_into</source>
          <target state="translated">OnceState::try_into</target>
        </trans-unit>
        <trans-unit id="fcd8d541e6822fd809940974bebc8a81f8b16c8d" translate="yes" xml:space="preserve">
          <source>OnceState::type_id</source>
          <target state="translated">OnceState::type_id</target>
        </trans-unit>
        <trans-unit id="bac414ebd5a08ef0bd8f0f09a9b6b081da1540b4" translate="yes" xml:space="preserve">
          <source>OnceWith</source>
          <target state="translated">OnceWith</target>
        </trans-unit>
        <trans-unit id="9421b02fba334e65b31591c89d7fcfa34aea5e57" translate="yes" xml:space="preserve">
          <source>OnceWith::all</source>
          <target state="translated">OnceWith::all</target>
        </trans-unit>
        <trans-unit id="ec045f959571abb529fe845ffb143c5aa440d98a" translate="yes" xml:space="preserve">
          <source>OnceWith::any</source>
          <target state="translated">OnceWith::any</target>
        </trans-unit>
        <trans-unit id="1ef37dd0c57f299c431f6fc7296ed50225f08e1a" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow</source>
          <target state="translated">OnceWith::borrow</target>
        </trans-unit>
        <trans-unit id="527f129227b962c7154dfbbc8fa56239753273a3" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow_mut</source>
          <target state="translated">OnceWith::borrow_mut</target>
        </trans-unit>
        <trans-unit id="220386db15c3ac797f2d78a1fa6328e0e524bbaa" translate="yes" xml:space="preserve">
          <source>OnceWith::by_ref</source>
          <target state="translated">OnceWith::by_ref</target>
        </trans-unit>
        <trans-unit id="8cca4e55ae50dd0aee68afe79ea244d5bca99ced" translate="yes" xml:space="preserve">
          <source>OnceWith::chain</source>
          <target state="translated">OnceWith::chain</target>
        </trans-unit>
        <trans-unit id="69a3e8d814785ab85c33556c6a099c9cc6ea940e" translate="yes" xml:space="preserve">
          <source>OnceWith::clone</source>
          <target state="translated">OnceWith::clone</target>
        </trans-unit>
        <trans-unit id="18ada5e17d413555745065a07348ed90106c203d" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_from</source>
          <target state="translated">OnceWith::clone_from</target>
        </trans-unit>
        <trans-unit id="840d6af9e9dfbf237e7af2ccf27dbd5ad69cee46" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_into</source>
          <target state="translated">OnceWith::clone_into</target>
        </trans-unit>
        <trans-unit id="28fb35fd1901c33eee7b84b451b7753c7c867260" translate="yes" xml:space="preserve">
          <source>OnceWith::cloned</source>
          <target state="translated">OnceWith::cloned</target>
        </trans-unit>
        <trans-unit id="30d119dee0d9c070c3e61005d6831099ce8bd793" translate="yes" xml:space="preserve">
          <source>OnceWith::cmp</source>
          <target state="translated">OnceWith::cmp</target>
        </trans-unit>
        <trans-unit id="abe9447efe3162bb1b99fa4be3a78e85a49dc04b" translate="yes" xml:space="preserve">
          <source>OnceWith::collect</source>
          <target state="translated">OnceWith::collect</target>
        </trans-unit>
        <trans-unit id="4d6da14365d0d73a28c1b23f782a042915618b92" translate="yes" xml:space="preserve">
          <source>OnceWith::copied</source>
          <target state="translated">OnceWith::copied</target>
        </trans-unit>
        <trans-unit id="7016f9903cc220eec1b3d930f0d6d91062934899" translate="yes" xml:space="preserve">
          <source>OnceWith::count</source>
          <target state="translated">OnceWith::count</target>
        </trans-unit>
        <trans-unit id="addfc373b9df5fc305b9e5e6eb635cd2466d07d4" translate="yes" xml:space="preserve">
          <source>OnceWith::cycle</source>
          <target state="translated">OnceWith::cycle</target>
        </trans-unit>
        <trans-unit id="095f0dc0c2b642b81131fb698197ca6766b54a2e" translate="yes" xml:space="preserve">
          <source>OnceWith::enumerate</source>
          <target state="translated">OnceWith::enumerate</target>
        </trans-unit>
        <trans-unit id="7e9ec613a8f6c55d8eb6ea553ee7ebd7e6244ce6" translate="yes" xml:space="preserve">
          <source>OnceWith::eq</source>
          <target state="translated">OnceWith::eq</target>
        </trans-unit>
        <trans-unit id="f3f3ad0faefd45bbd859ece3bf3eef9075759214" translate="yes" xml:space="preserve">
          <source>OnceWith::filter</source>
          <target state="translated">OnceWith::filter</target>
        </trans-unit>
        <trans-unit id="ea81115d4b00890df3a160e9b9a84ff71ded3a01" translate="yes" xml:space="preserve">
          <source>OnceWith::filter_map</source>
          <target state="translated">OnceWith::filter_map</target>
        </trans-unit>
        <trans-unit id="04462b9dd7bbda24ad2bd90e2b7883781de4acd6" translate="yes" xml:space="preserve">
          <source>OnceWith::find</source>
          <target state="translated">OnceWith::find</target>
        </trans-unit>
        <trans-unit id="aca2dee92401221e00169ab44175f018d2db65f4" translate="yes" xml:space="preserve">
          <source>OnceWith::find_map</source>
          <target state="translated">OnceWith::find_map</target>
        </trans-unit>
        <trans-unit id="10d39de4f24d2dcddb78ea6874f21fecb0e42b39" translate="yes" xml:space="preserve">
          <source>OnceWith::flat_map</source>
          <target state="translated">OnceWith::flat_map</target>
        </trans-unit>
        <trans-unit id="6ff780249f2a51d00d5d95dcfd4610dadafd2bd8" translate="yes" xml:space="preserve">
          <source>OnceWith::flatten</source>
          <target state="translated">OnceWith::flatten</target>
        </trans-unit>
        <trans-unit id="e7394a8ea887cd043223fc687a97cc1f193256c1" translate="yes" xml:space="preserve">
          <source>OnceWith::fmt</source>
          <target state="translated">OnceWith::fmt</target>
        </trans-unit>
        <trans-unit id="5e004a4ea95a589f773f9befbef25abe72f46ba2" translate="yes" xml:space="preserve">
          <source>OnceWith::fold</source>
          <target state="translated">OnceWith::fold</target>
        </trans-unit>
        <trans-unit id="0826514ea858174b22832240424d387a6a62a698" translate="yes" xml:space="preserve">
          <source>OnceWith::for_each</source>
          <target state="translated">OnceWith::for_each</target>
        </trans-unit>
        <trans-unit id="6f44e41130791319e6c6d5e080615570ac91fa72" translate="yes" xml:space="preserve">
          <source>OnceWith::from</source>
          <target state="translated">OnceWith::from</target>
        </trans-unit>
        <trans-unit id="d991094123caac201e372f78da1221c72316dec1" translate="yes" xml:space="preserve">
          <source>OnceWith::fuse</source>
          <target state="translated">OnceWith::fuse</target>
        </trans-unit>
        <trans-unit id="491865c492a9358b9d74d7461f65fbb3c2ad3116" translate="yes" xml:space="preserve">
          <source>OnceWith::ge</source>
          <target state="translated">OnceWith::ge</target>
        </trans-unit>
        <trans-unit id="cb6cb84ba3cef039e288bea61f9e271654ca16b3" translate="yes" xml:space="preserve">
          <source>OnceWith::gt</source>
          <target state="translated">OnceWith::gt</target>
        </trans-unit>
        <trans-unit id="f9bca0dbc5eb1308057e3acda537f87ae5584bf0" translate="yes" xml:space="preserve">
          <source>OnceWith::inspect</source>
          <target state="translated">OnceWith::inspect</target>
        </trans-unit>
        <trans-unit id="130c0779f2fab716215af75fb82426f43a016224" translate="yes" xml:space="preserve">
          <source>OnceWith::into</source>
          <target state="translated">OnceWith::into</target>
        </trans-unit>
        <trans-unit id="e53104deb8174e788d926bdbaa53ed5840ec7390" translate="yes" xml:space="preserve">
          <source>OnceWith::into_iter</source>
          <target state="translated">OnceWith::into_iter</target>
        </trans-unit>
        <trans-unit id="57fb266c4456dcf8194282f31a9c9693a675f52f" translate="yes" xml:space="preserve">
          <source>OnceWith::is_empty</source>
          <target state="translated">OnceWith::is_empty</target>
        </trans-unit>
        <trans-unit id="35067e17a5dc55a4bb918b85dcd10ca948035cb7" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted</source>
          <target state="translated">OnceWith::is_sorted</target>
        </trans-unit>
        <trans-unit id="fa54dbd797d14264ee865bf4783d41bbaaceb9bb" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by</source>
          <target state="translated">OnceWith::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0805f33825aaffa765bd319b5f5123f28e25c541" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by_key</source>
          <target state="translated">OnceWith::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b8642e0e6fa2a743b75cee962cacad7d55075240" translate="yes" xml:space="preserve">
          <source>OnceWith::last</source>
          <target state="translated">OnceWith::last</target>
        </trans-unit>
        <trans-unit id="93fa8fd9eba96e349d5cb407b64fe72f152eb5a8" translate="yes" xml:space="preserve">
          <source>OnceWith::le</source>
          <target state="translated">OnceWith::le</target>
        </trans-unit>
        <trans-unit id="7222c5552e670e1ab40e927a15a3bb3893a18137" translate="yes" xml:space="preserve">
          <source>OnceWith::len</source>
          <target state="translated">OnceWith::len</target>
        </trans-unit>
        <trans-unit id="115bc72442e41419d2748702b3dc2105c1045ca1" translate="yes" xml:space="preserve">
          <source>OnceWith::lt</source>
          <target state="translated">OnceWith::lt</target>
        </trans-unit>
        <trans-unit id="4a5a3ea857244c9e36891ebf8831e5ae98613302" translate="yes" xml:space="preserve">
          <source>OnceWith::map</source>
          <target state="translated">OnceWith::map</target>
        </trans-unit>
        <trans-unit id="e13117c44b319bc7f0f9709faa2a5544da1bccc4" translate="yes" xml:space="preserve">
          <source>OnceWith::max</source>
          <target state="translated">OnceWith::max</target>
        </trans-unit>
        <trans-unit id="5fe974dd4baeb92c36de177f1091466a40a950e9" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by</source>
          <target state="translated">OnceWith::max_by</target>
        </trans-unit>
        <trans-unit id="4bced0b61c3c1cb8410f882718a68a33aeae5a9b" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by_key</source>
          <target state="translated">OnceWith::max_by_key</target>
        </trans-unit>
        <trans-unit id="06568f09e719a331a84ceae60f4b66de6e9d0ea4" translate="yes" xml:space="preserve">
          <source>OnceWith::min</source>
          <target state="translated">OnceWith::min</target>
        </trans-unit>
        <trans-unit id="286481980c2d0b526534de52416aa1cce0683996" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by</source>
          <target state="translated">OnceWith::min_by</target>
        </trans-unit>
        <trans-unit id="5dd37a258caeec2b0eb6451dca8a726b836a9a92" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by_key</source>
          <target state="translated">OnceWith::min_by_key</target>
        </trans-unit>
        <trans-unit id="69f93b3a318af71379ddca4ec93fe8d140ce5f0f" translate="yes" xml:space="preserve">
          <source>OnceWith::ne</source>
          <target state="translated">OnceWith::ne</target>
        </trans-unit>
        <trans-unit id="ac26f725cccaf1526e5014347f9adea936f74ce7" translate="yes" xml:space="preserve">
          <source>OnceWith::next</source>
          <target state="translated">OnceWith::next</target>
        </trans-unit>
        <trans-unit id="e4330c855cf5f92fc7584c51cdee41319443487c" translate="yes" xml:space="preserve">
          <source>OnceWith::next_back</source>
          <target state="translated">OnceWith::next_back</target>
        </trans-unit>
        <trans-unit id="1527b9229bda86674b9d9102f7590dba88349ecd" translate="yes" xml:space="preserve">
          <source>OnceWith::nth</source>
          <target state="translated">OnceWith::nth</target>
        </trans-unit>
        <trans-unit id="52e0f2df5caf846213c666b22fff6456cda8a68f" translate="yes" xml:space="preserve">
          <source>OnceWith::nth_back</source>
          <target state="translated">OnceWith::nth_back</target>
        </trans-unit>
        <trans-unit id="2d124bbf09c7f2b80ff84f088c67f3f07ae5780b" translate="yes" xml:space="preserve">
          <source>OnceWith::partial_cmp</source>
          <target state="translated">OnceWith::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cabc7165c7c9b316158511856e73e51b4305e89b" translate="yes" xml:space="preserve">
          <source>OnceWith::partition</source>
          <target state="translated">OnceWith::partition</target>
        </trans-unit>
        <trans-unit id="1cda021009cce16eced253abaf1a3a1b11566d18" translate="yes" xml:space="preserve">
          <source>OnceWith::peekable</source>
          <target state="translated">OnceWith::peekable</target>
        </trans-unit>
        <trans-unit id="03590b6367dd3bb1ba4d65b39afee2b09ca08df1" translate="yes" xml:space="preserve">
          <source>OnceWith::position</source>
          <target state="translated">OnceWith::position</target>
        </trans-unit>
        <trans-unit id="e1735abbbee6972dc130e89d570fd8fa919407fe" translate="yes" xml:space="preserve">
          <source>OnceWith::product</source>
          <target state="translated">OnceWith::product</target>
        </trans-unit>
        <trans-unit id="ec925c93a26e2eadc7d07e055f695e74c83d4c23" translate="yes" xml:space="preserve">
          <source>OnceWith::rev</source>
          <target state="translated">OnceWith::rev</target>
        </trans-unit>
        <trans-unit id="6243776ef017e4a1cf3d502a3968703e2ab8d6ed" translate="yes" xml:space="preserve">
          <source>OnceWith::rfind</source>
          <target state="translated">OnceWith::rfind</target>
        </trans-unit>
        <trans-unit id="aea12fd7d31659bccdee8c41ecdb4fb0f15444db" translate="yes" xml:space="preserve">
          <source>OnceWith::rfold</source>
          <target state="translated">OnceWith::rfold</target>
        </trans-unit>
        <trans-unit id="0c9e294cb61289d08c63ceca07aff5dfaea0261e" translate="yes" xml:space="preserve">
          <source>OnceWith::rposition</source>
          <target state="translated">OnceWith::rposition</target>
        </trans-unit>
        <trans-unit id="cef9b43e5eedf9af103faef7b1bbe4d12db9ab2f" translate="yes" xml:space="preserve">
          <source>OnceWith::scan</source>
          <target state="translated">OnceWith::scan</target>
        </trans-unit>
        <trans-unit id="cc6e5c82263a6bf9a575956ff17a327f6e8e1a12" translate="yes" xml:space="preserve">
          <source>OnceWith::size_hint</source>
          <target state="translated">OnceWith::size_hint</target>
        </trans-unit>
        <trans-unit id="eb30275a1bfcdf9e0075819a60e55de8140da973" translate="yes" xml:space="preserve">
          <source>OnceWith::skip</source>
          <target state="translated">OnceWith::skip</target>
        </trans-unit>
        <trans-unit id="d51df4ad9879230eee4b7d1f410130e26dd6a97e" translate="yes" xml:space="preserve">
          <source>OnceWith::skip_while</source>
          <target state="translated">OnceWith::skip_while</target>
        </trans-unit>
        <trans-unit id="13b1461f738d3541f7f825bf588919136b55d36d" translate="yes" xml:space="preserve">
          <source>OnceWith::step_by</source>
          <target state="translated">OnceWith::step_by</target>
        </trans-unit>
        <trans-unit id="74e43ad0cf8bc22a5af2d491f032ca5523c1d7b0" translate="yes" xml:space="preserve">
          <source>OnceWith::sum</source>
          <target state="translated">OnceWith::sum</target>
        </trans-unit>
        <trans-unit id="89cc6b13712f2c2ac536c3feb4e1809f1a6b5cc2" translate="yes" xml:space="preserve">
          <source>OnceWith::take</source>
          <target state="translated">OnceWith::take</target>
        </trans-unit>
        <trans-unit id="8c2cd8a3d3dfa6e2cb6f5f270f11cddff7173ce1" translate="yes" xml:space="preserve">
          <source>OnceWith::take_while</source>
          <target state="translated">OnceWith::take_while</target>
        </trans-unit>
        <trans-unit id="5a630013ba78b1577b011778f861dca34fdb6510" translate="yes" xml:space="preserve">
          <source>OnceWith::to_owned</source>
          <target state="translated">OnceWith::to_owned</target>
        </trans-unit>
        <trans-unit id="030ec595a21a12e03c641afa5fc2a0fbf3cfd96d" translate="yes" xml:space="preserve">
          <source>OnceWith::try_fold</source>
          <target state="translated">OnceWith::try_fold</target>
        </trans-unit>
        <trans-unit id="716d560ebaa2fa12887a04435f9271204fee9212" translate="yes" xml:space="preserve">
          <source>OnceWith::try_for_each</source>
          <target state="translated">OnceWith::try_for_each</target>
        </trans-unit>
        <trans-unit id="585e7e8b9f7e6990f4b13d54ca37d88a0bf70ca8" translate="yes" xml:space="preserve">
          <source>OnceWith::try_from</source>
          <target state="translated">OnceWith::try_from</target>
        </trans-unit>
        <trans-unit id="7cb93d634335cbd032ccfe91d14126a928250279" translate="yes" xml:space="preserve">
          <source>OnceWith::try_into</source>
          <target state="translated">OnceWith::try_into</target>
        </trans-unit>
        <trans-unit id="640ef41bdeff4cb6f8ee26085f02e8464a124452" translate="yes" xml:space="preserve">
          <source>OnceWith::try_rfold</source>
          <target state="translated">OnceWith::try_rfold</target>
        </trans-unit>
        <trans-unit id="100a64512cd2fe1b9fbd4ceea4850862b8f813b7" translate="yes" xml:space="preserve">
          <source>OnceWith::type_id</source>
          <target state="translated">OnceWith::type_id</target>
        </trans-unit>
        <trans-unit id="64fd105a0a6aa5f709a9477cafb3d6c01fd6cfb0" translate="yes" xml:space="preserve">
          <source>OnceWith::unzip</source>
          <target state="translated">OnceWith::unzip</target>
        </trans-unit>
        <trans-unit id="433df116ad00f74cb6d78ea83682ace23f21cb19" translate="yes" xml:space="preserve">
          <source>OnceWith::zip</source>
          <target state="translated">OnceWith::zip</target>
        </trans-unit>
        <trans-unit id="c04e60357eae6b0d2f646024db69bbf3bdb3f30b" translate="yes" xml:space="preserve">
          <source>One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of &lt;code&gt;grep&lt;/code&gt;, called &lt;code&gt;ripgrep&lt;/code&gt;. By comparison, our version of &lt;code&gt;grep&lt;/code&gt; will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as &lt;code&gt;ripgrep&lt;/code&gt;.</source>
          <target state="translated">Rust的一个社区成员Andrew Gallant已经创建了功能齐全的非常快速的 &lt;code&gt;grep&lt;/code&gt; 版本，称为 &lt;code&gt;ripgrep&lt;/code&gt; 。相比之下，我们的 &lt;code&gt;grep&lt;/code&gt; 版本将非常简单，但是本章将为您提供一些了解实际项目（例如 &lt;code&gt;ripgrep&lt;/code&gt; )所需的背景知识。</target>
        </trans-unit>
        <trans-unit id="6d8cb1de18a6c59ff63b7aa03082a18e5d9546ee" translate="yes" xml:space="preserve">
          <source>One benefit of implementing &lt;code&gt;IntoIterator&lt;/code&gt; is that your type will &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;work with Rust's &lt;code&gt;for&lt;/code&gt; loop syntax&lt;/a&gt;.</source>
          <target state="translated">实现 &lt;code&gt;IntoIterator&lt;/code&gt; 的一个好处是您的类型将&lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;与Rust的 &lt;code&gt;for&lt;/code&gt; 循环语法一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d5bdf955d9dc47b0601586e8217dda6094c541f" translate="yes" xml:space="preserve">
          <source>One character can become multiple:</source>
          <target state="translated">一个角色可以变成多个角色。</target>
        </trans-unit>
        <trans-unit id="9a0e2dea9fc38cc31adcbb6e264358edce5cb875" translate="yes" xml:space="preserve">
          <source>One could use &lt;code&gt;std::os::raw::c_void&lt;/code&gt; if they want to support old Rust compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by this definition. For more information, please read &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md&quot;&gt;RFC 2521&lt;/a&gt;.</source>
          <target state="translated">如果他们想支持低至1.1.0的旧Rust编译器，则可以使用 &lt;code&gt;std::os::raw::c_void&lt;/code&gt; 。在Rust 1.30.0之后，此定义将其重新导出。有关更多信息，请阅读&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md&quot;&gt;RFC 2521&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa91f526636a9109f1e67616db8e82d52af8d580" translate="yes" xml:space="preserve">
          <source>One detail we didn&amp;rsquo;t discuss in the &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;ldquo;References and Borrowing&amp;rdquo;&lt;/a&gt; section in Chapter 4 is that every reference in Rust has a &lt;em&gt;lifetime&lt;/em&gt;, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.</source>
          <target state="translated">我们在第4章的&lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;ldquo;参考和借阅&amp;rdquo;&lt;/a&gt;部分中没有讨论的一个细节是，Rust中的每个参考都有一个&lt;em&gt;生存期&lt;/em&gt;，这是该参考有效的范围。在大多数情况下，生存期是隐式和推断的，就像在大多数情况下一样，推断类型。当可能有多个类型时，我们必须注释类型。以类似的方式，当引用的生存期可以通过几种不同方式关联时，我们必须注释生存期。Rust要求我们使用通用生命周期参数来注释关系，以确保在运行时使用的实际引用绝对有效。</target>
        </trans-unit>
        <trans-unit id="d218cebb1b26aab7ac78425185eee65d682c0943" translate="yes" xml:space="preserve">
          <source>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. If we add another state between &lt;code&gt;PendingReview&lt;/code&gt; and &lt;code&gt;Published&lt;/code&gt;, such as &lt;code&gt;Scheduled&lt;/code&gt;, we would have to change the code in &lt;code&gt;PendingReview&lt;/code&gt; to transition to &lt;code&gt;Scheduled&lt;/code&gt; instead. It would be less work if &lt;code&gt;PendingReview&lt;/code&gt; didn&amp;rsquo;t need to change with the addition of a new state, but that would mean switching to another design pattern.</source>
          <target state="translated">状态模式的一个缺点是，由于状态实现了状态之间的转换，因此某些状态彼此耦合。如果我们在 &lt;code&gt;PendingReview&lt;/code&gt; 和 &lt;code&gt;Published&lt;/code&gt; 之间添加另一个状态，例如 &lt;code&gt;Scheduled&lt;/code&gt; ，则必须更改 &lt;code&gt;PendingReview&lt;/code&gt; 中的代码以过渡到 &lt;code&gt;Scheduled&lt;/code&gt; 。如果 &lt;code&gt;PendingReview&lt;/code&gt; 不需要通过添加新状态进行更改，则工作量会减少，但这意味着切换到另一种设计模式。</target>
        </trans-unit>
        <trans-unit id="79dab74a608a5fe55775f425d883e5609ea6484a" translate="yes" xml:space="preserve">
          <source>One example of a trait with an associated type is the &lt;code&gt;Iterator&lt;/code&gt; trait that the standard library provides. The associated type is named &lt;code&gt;Item&lt;/code&gt; and stands in for the type of the values the type implementing the &lt;code&gt;Iterator&lt;/code&gt; trait is iterating over. In &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;ldquo;The &lt;code&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method&amp;rdquo;&lt;/a&gt; section of Chapter 13, we mentioned that the definition of the &lt;code&gt;Iterator&lt;/code&gt; trait is as shown in Listing 19-12.</source>
          <target state="translated">具有关联类型的特征的一个示例是标准库提供的 &lt;code&gt;Iterator&lt;/code&gt; 特征。关联的类型称为 &lt;code&gt;Item&lt;/code&gt; ，代表实现 &lt;code&gt;Iterator&lt;/code&gt; 特征的类型所迭代的值的类型。在第13章的&lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;ldquo; &lt;code&gt;Iterator&lt;/code&gt; 特性和 &lt;code&gt;next&lt;/code&gt; 方法&amp;rdquo;&lt;/a&gt;部分中，我们提到了 &lt;code&gt;Iterator&lt;/code&gt; 特征的定义如清单19-12所示。</target>
        </trans-unit>
        <trans-unit id="6e24d429d27b48134811a91f7546e1e6d93fd489" translate="yes" xml:space="preserve">
          <source>One final expression that has the type &lt;code&gt;!&lt;/code&gt; is a &lt;code&gt;loop&lt;/code&gt;:</source>
          <target state="translated">一个具有类型的最终表达式 &lt;code&gt;!&lt;/code&gt; 是一个 &lt;code&gt;loop&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="08b7d5a5c0be732c550b04476aeb4d64ed0d9f34" translate="yes" xml:space="preserve">
          <source>One fix is to use &lt;code&gt;Option&lt;/code&gt;, like so:</source>
          <target state="translated">一种解决方法是使用 &lt;code&gt;Option&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="0404f28b47072e36d14ad36dc7e51fdfb00d1799" translate="yes" xml:space="preserve">
          <source>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</source>
          <target state="translated">一个修复方法可能是增加递归限制。请注意,有可能产生无限递归的脱引用,在这种情况下,唯一的修复方法是以某种方式打破递归。</target>
        </trans-unit>
        <trans-unit id="604777bf4c9ef568f65e74a5ef4770d9197bf0e4" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent.</source>
          <target state="translated">一个大于2的最小可能的正常指数幂。</target>
        </trans-unit>
        <trans-unit id="d1aad5d49e44c9e98dc9d596c60e87f16270d447" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f32::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">比2的最小可能标准幂大一。请改用&lt;a href=&quot;../primitive.f32#associatedconstant.MIN_EXP&quot;&gt; &lt;code&gt;f32::MIN_EXP&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af913244c1df707f9c82d8aebefb4735e4abcae8" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f64::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">比2的最小可能标准幂大一。请改用&lt;a href=&quot;../primitive.f64#associatedconstant.MIN_EXP&quot;&gt; &lt;code&gt;f64::MIN_EXP&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6888a831481b2df0737ae6067a1763cc0ae4b8b" translate="yes" xml:space="preserve">
          <source>One important part of this code is that the &lt;code&gt;Messenger&lt;/code&gt; trait has one method called &lt;code&gt;send&lt;/code&gt; that takes an immutable reference to &lt;code&gt;self&lt;/code&gt; and the text of the message. This is the interface our mock object needs to have. The other important part is that we want to test the behavior of the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt;. We can change what we pass in for the &lt;code&gt;value&lt;/code&gt; parameter, but &lt;code&gt;set_value&lt;/code&gt; doesn&amp;rsquo;t return anything for us to make assertions on. We want to be able to say that if we create a &lt;code&gt;LimitTracker&lt;/code&gt; with something that implements the &lt;code&gt;Messenger&lt;/code&gt; trait and a particular value for &lt;code&gt;max&lt;/code&gt;, when we pass different numbers for &lt;code&gt;value&lt;/code&gt;, the messenger is told to send the appropriate messages.</source>
          <target state="translated">该代码的一个重要部分是 &lt;code&gt;Messenger&lt;/code&gt; 特质具有一种称为 &lt;code&gt;send&lt;/code&gt; 的方法，该方法采用对 &lt;code&gt;self&lt;/code&gt; 和消息文本的不变引用。这是我们的模拟对象需要的接口。另一个重要的部分是我们要在 &lt;code&gt;LimitTracker&lt;/code&gt; 上测试 &lt;code&gt;set_value&lt;/code&gt; 方法的行为。我们可以更改为 &lt;code&gt;value&lt;/code&gt; 参数传入的内容，但 &lt;code&gt;set_value&lt;/code&gt; 不会返回任何内容供我们进行断言。我们想说的是，如果我们创建一个 &lt;code&gt;LimitTracker&lt;/code&gt; 并实现了 &lt;code&gt;Messenger&lt;/code&gt; 特质和 &lt;code&gt;max&lt;/code&gt; 的特定值，当我们传递不同的数字作为 &lt;code&gt;value&lt;/code&gt; ，系统会通知Messenger发送适当的消息。</target>
        </trans-unit>
        <trans-unit id="ded7cc38097138108681f22bf5306daeb4f49884" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="translated">&lt;em&gt;消息传递&lt;/em&gt;是一种越来越流行的确保安全并发的方法，其中线程或参与者通过相互发送包含数据的消息进行通信。这是&lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;Go语言文档&lt;/a&gt;中的口号：&amp;ldquo;不要通过共享内存进行交流；而是通过交流共享内存。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d3eaa18d42b0806c5f4bdf2e764c2ce7e402d5e8" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;https://golang.org/doc/effective_go.html#concurrency&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="translated">&lt;em&gt;消息传递&lt;/em&gt;是一种越来越流行的确保安全并发的方法，其中线程或参与者通过互相发送包含数据的消息进行通信。这是&lt;a href=&quot;https://golang.org/doc/effective_go.html#concurrency&quot;&gt;Go语言文档&lt;/a&gt;中的一个口号：&amp;ldquo;不要通过共享内存进行交流；不要通过共享内存进行交流。而是通过交流共享内存。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d6b559b40224203447024d2ae45e68a9e1945eed" translate="yes" xml:space="preserve">
          <source>One last example:</source>
          <target state="translated">最后一个例子。</target>
        </trans-unit>
        <trans-unit id="1ad534544463088b932bc112e0ba96d50acc9887" translate="yes" xml:space="preserve">
          <source>One lifetime annotation by itself doesn&amp;rsquo;t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. For example, let&amp;rsquo;s say we have a function with the parameter &lt;code&gt;first&lt;/code&gt; that is a reference to an &lt;code&gt;i32&lt;/code&gt; with lifetime &lt;code&gt;'a&lt;/code&gt;. The function also has another parameter named &lt;code&gt;second&lt;/code&gt; that is another reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;. The lifetime annotations indicate that the references &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; must both live as long as that generic lifetime.</source>
          <target state="translated">一个生命周期注释本身没有多大意义，因为注释的目的是告诉Rust多个引用的通用生命周期参数如何相互关联。例如，假设我们有一个函数，该函数的参数 &lt;code&gt;first&lt;/code&gt; 是对寿命为 &lt;code&gt;'a&lt;/code&gt; 的 &lt;code&gt;i32&lt;/code&gt; 的引用。该函数还具有另一个名为 &lt;code&gt;second&lt;/code&gt; 的参数，这是对 &lt;code&gt;i32&lt;/code&gt; 的另一个引用，该i32也具有生存期 &lt;code&gt;'a&lt;/code&gt; 。生命周期批注指示引用的 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;second&lt;/code&gt; 必须都与该通用生命周期一样长。</target>
        </trans-unit>
        <trans-unit id="eb999aea4a6804c2aba22f0ab64c0d473a5cc357" translate="yes" xml:space="preserve">
          <source>One major tool Rust has for accomplishing message-sending concurrency is the &lt;em&gt;channel&lt;/em&gt;, a programming concept that Rust&amp;rsquo;s standard library provides an implementation of. You can imagine a channel in programming as being like a channel of water, such as a stream or a river. If you put something like a rubber duck or boat into a stream, it will travel downstream to the end of the waterway.</source>
          <target state="translated">Rust实现消息发送并发的主要工具之一是&lt;em&gt;channel&lt;/em&gt;，它是Rust的标准库提供的一种编程概念。您可以想象编程中的一个通道就像一条水的通道，例如一条小溪或一条河。如果将橡皮鸭或橡皮艇之类的东西放进溪流中，它将顺流而下到达水路的尽头。</target>
        </trans-unit>
        <trans-unit id="5a21bfbca68fd0fbb69da3809cb39488fd50f372" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="translated">使用追加模式时，可能有一个明显的注意事项：确保将所有属于同一数据的数据通过一项操作写入文件中。这可以通过在将字符串传递给&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;之前串联字符串，或使用缓冲的writer（具有足够大小的缓冲区）并在消息完成后调用&lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt;来完成。</target>
        </trans-unit>
        <trans-unit id="a100de9eac9101d503c874b2c73fc8e99b7771dc" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;struct.file#method.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;struct.file#method.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="translated">使用附加模式时，可能有一个明显的注意事项：确保将所有在一起的数据通过一项操作写入文件。这可以通过在将字符串传递给&lt;a href=&quot;struct.file#method.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;之前对其进行串联，或者使用缓冲的writer（具有足够大小的缓冲区），并在消息完成后调用&lt;a href=&quot;struct.file#method.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt;来完成。</target>
        </trans-unit>
        <trans-unit id="2650888f948816ac8a9838e1462a292b91d57e17" translate="yes" xml:space="preserve">
          <source>One of the keys to &lt;code&gt;collect()&lt;/code&gt;'s power is that many things you might not think of as 'collections' actually are. For example, a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a collection of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. And a collection of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; can be thought of as single &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.</source>
          <target state="translated">的关键之一，以 &lt;code&gt;collect()&lt;/code&gt; 的强大之处在于很多东西你可能不认为的&amp;lsquo;收藏品&amp;rsquo;其实都是。例如，&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;的集合。可以将&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;的集合视为单个&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt; 。有关更多信息，请参见下面的示例。</target>
        </trans-unit>
        <trans-unit id="c25ed3c3dc3acc46e3e6ecc55a7e68acca10b918" translate="yes" xml:space="preserve">
          <source>One of the uses of a &lt;code&gt;loop&lt;/code&gt; is to retry an operation you know might fail, such as checking whether a thread has completed its job. However, you might need to pass the result of that operation to the rest of your code. To do this, you can add the value you want returned after the &lt;code&gt;break&lt;/code&gt; expression you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 的用途之一是重试您知道可能会失败的操作，例如检查线程是否已完成其工作。但是，您可能需要将该操作的结果传递给其余代码。为此，您可以在要用于停止循环的 &lt;code&gt;break&lt;/code&gt; 表达式之后添加要返回的值。该值将被循环返回，因此您可以使用它，如下所示：</target>
        </trans-unit>
        <trans-unit id="f31603daf9af84bcc62de6d02f7c02e0a197c236" translate="yes" xml:space="preserve">
          <source>One requirement for &lt;code&gt;match&lt;/code&gt; expressions is that they need to be &lt;em&gt;exhaustive&lt;/em&gt; in the sense that all possibilities for the value in the &lt;code&gt;match&lt;/code&gt; expression must be accounted for. One way to ensure you&amp;rsquo;ve covered every possibility is to have a catchall pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 表达式的一项要求是，在必须考虑 &lt;code&gt;match&lt;/code&gt; 表达式中值的所有可能性的意义上，它们必须是&lt;em&gt;详尽无遗&lt;/em&gt;的。确保涵盖所有可能性的一种方法是为最后一个分支使用通用模式：例如，与任何值匹配的变量名都不会失败，从而涵盖了所有剩余的情况。</target>
        </trans-unit>
        <trans-unit id="2015b7ca5d5d193e7b2cd1b845883b1560077b31" translate="yes" xml:space="preserve">
          <source>One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate. For example, we can implement standard library traits like &lt;code&gt;Display&lt;/code&gt; on a custom type like &lt;code&gt;Tweet&lt;/code&gt; as part of our &lt;code&gt;aggregator&lt;/code&gt; crate functionality, because the type &lt;code&gt;Tweet&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate. We can also implement &lt;code&gt;Summary&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in our &lt;code&gt;aggregator&lt;/code&gt; crate, because the trait &lt;code&gt;Summary&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate.</source>
          <target state="translated">特征实现需要注意的一个限制是，只有特征或类型在板条箱中是本地的，我们才能对类型实现特征。例如，我们可以在自定义类型（如 &lt;code&gt;Tweet&lt;/code&gt; )上实现标准库特征（如 &lt;code&gt;Display&lt;/code&gt; )，作为 &lt;code&gt;aggregator&lt;/code&gt; 箱功能的一部分，因为 &lt;code&gt;Tweet&lt;/code&gt; 类型是 &lt;code&gt;aggregator&lt;/code&gt; 箱的本地类型。我们还可以在 &lt;code&gt;aggregator&lt;/code&gt; 板条箱中对 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 实施 &lt;code&gt;Summary&lt;/code&gt; ，因为特征 &lt;code&gt;Summary&lt;/code&gt; 是我们 &lt;code&gt;aggregator&lt;/code&gt; 板条箱的局部特征。</target>
        </trans-unit>
        <trans-unit id="3ca14e0e855a4d320ac718d1dbab1d5658779f12" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">一个人应该总是更喜欢实现 &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; ,&lt;/a&gt;因为由于标准库中的一揽子实现，实现 &lt;code&gt;From&lt;/code&gt; 会自动为&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="721950a5dec28e319b3fc49a8295aa63db96bacc" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">一个人应该总是更喜欢实现 &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; ,&lt;/a&gt;因为由于标准库中的统一实现，实现 &lt;code&gt;From&lt;/code&gt; 会自动为&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="bb98649134293913fe4a45ee10ddf0211b082fad" translate="yes" xml:space="preserve">
          <source>One should avoid implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; and implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; instead. Implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">应该避免实现&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;。借助标准库中的统一实现，&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; 的&lt;/a&gt;实现自动为&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;的实现提供了一个实现。</target>
        </trans-unit>
        <trans-unit id="b9063035453c1b2c42529a52a82eaf086598016e" translate="yes" xml:space="preserve">
          <source>One should only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. Otherwise one should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library. &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; cannot do these type of conversions because of Rust's orphaning rules.</source>
          <target state="translated">仅当需要转换为当前包装箱之外的类型时，才应实施&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;。否则，应该总是更喜欢实现&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; ,&lt;/a&gt;因为由于标准库中的统一实现，实现&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; 会&lt;/a&gt;自动为&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;实现。由于Rust的孤立规则，&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;无法执行这些类型的转换。</target>
        </trans-unit>
        <trans-unit id="1a1308a26b40990e2a9ab226282be34a9c0f3915" translate="yes" xml:space="preserve">
          <source>One special lifetime we need to discuss is &lt;code&gt;'static&lt;/code&gt;, which means that this reference &lt;em&gt;can&lt;/em&gt; live for the entire duration of the program. All string literals have the &lt;code&gt;'static&lt;/code&gt; lifetime, which we can annotate as follows:</source>
          <target state="translated">我们需要讨论的一个特殊寿命是 &lt;code&gt;'static&lt;/code&gt; ，这意味着该引用&lt;em&gt;可以&lt;/em&gt;在程序的整个过程中有效。所有字符串文字都具有 &lt;code&gt;'static&lt;/code&gt; 生存期&amp;rdquo;，我们可以对其进行如下注释：</target>
        </trans-unit>
        <trans-unit id="b3c0e81ae8d50e16a5ef5685ec5ba7252876cd13" translate="yes" xml:space="preserve">
          <source>One way to do this would be to parse the guess as an &lt;code&gt;i32&lt;/code&gt; instead of only a &lt;code&gt;u32&lt;/code&gt; to allow potentially negative numbers, and then add a check for the number being in range, like so:</source>
          <target state="translated">这样做的一个方法是解析猜测为 &lt;code&gt;i32&lt;/code&gt; ，而不是只有 &lt;code&gt;u32&lt;/code&gt; ，让潜在的负面数字，然后在范围添加一个检查编号的存在，就像这样：</target>
        </trans-unit>
        <trans-unit id="040e8b6c5e16e2eb7dbd8ea369897b2ed67939bb" translate="yes" xml:space="preserve">
          <source>One way to fix this is by wrapping &lt;code&gt;ListNode&lt;/code&gt; in a &lt;code&gt;Box&lt;/code&gt;, like so:</source>
          <target state="translated">解决此问题的一种方法是将 &lt;code&gt;ListNode&lt;/code&gt; 包装在 &lt;code&gt;Box&lt;/code&gt; 中，如下所示：</target>
        </trans-unit>
        <trans-unit id="7b55ce1dd92a000535e70271090068fe574bb882" translate="yes" xml:space="preserve">
          <source>One way to fix this is to remove the items in negative impls:</source>
          <target state="translated">解决这个问题的方法之一是去掉负数impls中的项目。</target>
        </trans-unit>
        <trans-unit id="e58c5baae639d4247baa5d3c55a2e51c5fc2fcbf" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;AssertUnwindSafe&lt;/code&gt; is to assert that the entire closure itself is unwind safe, bypassing all checks for all variables:</source>
          <target state="translated">使用 &lt;code&gt;AssertUnwindSafe&lt;/code&gt; 的一种方法是断言整个闭包本身是安全的，绕过所有变量的所有检查：</target>
        </trans-unit>
        <trans-unit id="1d8228fcb1896e7f726b443ff97084ceedc8b0d1" translate="yes" xml:space="preserve">
          <source>One way to work around this is to introduce a phantom type parameter into &lt;code&gt;FooMaker&lt;/code&gt;, like so:</source>
          <target state="translated">解决此问题的一种方法是将幻像类型参数引入 &lt;code&gt;FooMaker&lt;/code&gt; 中，如下所示：</target>
        </trans-unit>
        <trans-unit id="5b0ab36b863c12847512c68879148e05a2480f26" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="translated">由于哈希的概率性质，只有&lt;a href=&quot;hash_map/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;具有预期的成本。从理论上讲，尽管非常不可能，但&lt;a href=&quot;hash_map/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 的&lt;/a&gt;性能可能会变差。</target>
        </trans-unit>
        <trans-unit id="5d2a1cfc42a9afc1fe710bb8389ace0259e088eb" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="translated">由于哈希的概率性质，只有&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;具有预期的成本。从理论上讲，尽管不太可能，但&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;可能会出现性能下降的情况。</target>
        </trans-unit>
        <trans-unit id="c64700ee184977494a32292609d647c2790da91d" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;extern crate&lt;/code&gt; imports at the crate root level are allowed to import macros.</source>
          <target state="translated">仅允许在板条箱根级别导入 &lt;code&gt;extern crate&lt;/code&gt; 箱来导入宏。</target>
        </trans-unit>
        <trans-unit id="0f1a591311049947010f4fb443dacb5d1227b8a1" translate="yes" xml:space="preserve">
          <source>Only Inserting a Value If the Key Has No Value</source>
          <target state="translated">只有在键没有值的情况下才会插入一个值。</target>
        </trans-unit>
        <trans-unit id="a86a2e98e34b9080a837979f0cd7c8a23bdc05cc" translate="yes" xml:space="preserve">
          <source>Only a higher-ranked bound can be used here as the lifetime of the reference is shorter than a lifetime parameter on the function:</source>
          <target state="translated">由于参考的寿命比函数上的寿命参数要短,所以这里只能使用高等级的约束。</target>
        </trans-unit>
        <trans-unit id="154f9dfbda3c7139a94a5be92a5a5842ea10cd7e" translate="yes" xml:space="preserve">
          <source>Only a single explicit lifetime bound is permitted on trait objects. To fix this error, consider removing one of the lifetime bounds:</source>
          <target state="translated">特质对象上只允许有一个明确的寿命约束。要修复这个错误,可以考虑删除其中一个寿命约束。</target>
        </trans-unit>
        <trans-unit id="1d9857467e96b586319b486e37d19a227573b8ef" translate="yes" xml:space="preserve">
          <source>Only considers whole path components to match.</source>
          <target state="translated">只考虑整个路径组件的匹配。</target>
        </trans-unit>
        <trans-unit id="79d045850f7f84e6ac5788c792fcb946090d94ed" translate="yes" xml:space="preserve">
          <source>Only field-less enums can be cast to numerical primitives, so this attribute will not apply to structs.</source>
          <target state="translated">只有无字段的枚举可以被转换为数字基元,因此此属性将不适用于结构。</target>
        </trans-unit>
        <trans-unit id="848279e3313c44734789a01608c8102412c68498" translate="yes" xml:space="preserve">
          <source>Only foreign functions can use the C-variadic type (&lt;code&gt;...&lt;/code&gt;). In such functions, &lt;code&gt;...&lt;/code&gt; may only occur non-nested. That is, &lt;code&gt;y: &amp;amp;'a ...&lt;/code&gt; is not allowed.</source>
          <target state="translated">仅外部函数可以使用C变量类型（ &lt;code&gt;...&lt;/code&gt; ）。在此类功能中， &lt;code&gt;...&lt;/code&gt; 可能仅非嵌套出现。也就是说， &lt;code&gt;y: &amp;amp;'a ...&lt;/code&gt; 是不允许的。</target>
        </trans-unit>
        <trans-unit id="905a2eaaaa2de81962debc1768f8a3e80eac42bb" translate="yes" xml:space="preserve">
          <source>Only functions and methods can be called using &lt;code&gt;()&lt;/code&gt;. Example:</source>
          <target state="translated">使用 &lt;code&gt;()&lt;/code&gt; 只能调用函数和方法。例：</target>
        </trans-unit>
        <trans-unit id="75a9ac98deeca6b24da630baa2c701b9504057f7" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. &lt;code&gt;From&lt;/code&gt; cannot do these type of conversions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">仅在需要转换为当前包装箱之外的类型时才实施&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;。由于Rust的孤立规则， &lt;code&gt;From&lt;/code&gt; 无法执行这些类型的转换。有关更多详细信息，请参见&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b305a83e8f3d0e4a37b5c57b23584e5d9862317" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; when targeting a version prior to Rust 1.41 and converting to a type outside the current crate. &lt;code&gt;From&lt;/code&gt; was not able to do these types of conversions in earlier versions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">仅当针对Rust 1.41之前的版本并将其转换为当前包装箱之外的类型时，才实现&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;。由于Rust的孤立规则， &lt;code&gt;From&lt;/code&gt; 无法执行这些类型的转换。有关更多详细信息，请参见&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32f9fc3a3cbf2058b25d70080083b8cc212e6656" translate="yes" xml:space="preserve">
          <source>Only one argument can be passed per use. So instead of:</source>
          <target state="translated">每次使用只能传递一个参数。所以,与其说是:</target>
        </trans-unit>
        <trans-unit id="457e98acf3983b9b27751cc789092296edcc762f" translate="yes" xml:space="preserve">
          <source>Only one thread will have &lt;code&gt;true&lt;/code&gt; returned from their result, all other threads will have &lt;code&gt;false&lt;/code&gt; returned.</source>
          <target state="translated">只有一个线程的结果返回 &lt;code&gt;true&lt;/code&gt; ，所有其他线程的返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc230d3e221cc5ba4ebb17173e6ee922e206f00e" translate="yes" xml:space="preserve">
          <source>Only paths to traits are allowed as argument inside &lt;code&gt;#[derive]&lt;/code&gt;. You can find more information about the &lt;code&gt;#[derive]&lt;/code&gt; attribute in the &lt;a href=&quot;book/appendix-03-derivable-traits&quot;&gt;Rust Book&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;#[derive]&lt;/code&gt; 内仅允许将特征的路径作为参数。您可以在&lt;a href=&quot;book/appendix-03-derivable-traits&quot;&gt;Rust Book中&lt;/a&gt;找到有关 &lt;code&gt;#[derive]&lt;/code&gt; 属性的更多信息。</target>
        </trans-unit>
        <trans-unit id="e3609d3dffa4fe7169c12045193a601a2a125a6f" translate="yes" xml:space="preserve">
          <source>Only primitive types can be cast into each other. Examples:</source>
          <target state="translated">只有基元类型可以相互投向。例如:</target>
        </trans-unit>
        <trans-unit id="ab9f48b23a6a48f0ef7b5f4e6bfbc32e252bb8f0" translate="yes" xml:space="preserve">
          <source>Only published blog posts return content to print, so unapproved posts can&amp;rsquo;t accidentally be published.</source>
          <target state="translated">只有已发布的博客帖子才能返回打印内容，因此不会意外发布未经批准的帖子。</target>
        </trans-unit>
        <trans-unit id="073ebf55d3884fb61165383e76a504c9d12cc4b5" translate="yes" xml:space="preserve">
          <source>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; is not allowed.</source>
          <target state="translated">仅允许使用结构体和枚举来暗示发送，同步和其他选择退出特征，并且该结构体或枚举必须在当前板条箱本地。因此，例如，不允许使用 &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48b01a920bc2fb585e3535476a3e6dbbaef350e6" translate="yes" xml:space="preserve">
          <source>Only structural-match types (that is, types that derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;) may be used as the types of const generic parameters.</source>
          <target state="translated">只能将结构匹配类型（即派生 &lt;code&gt;PartialEq&lt;/code&gt; 和 &lt;code&gt;Eq&lt;/code&gt; 的类型）用作const泛型参数的类型。</target>
        </trans-unit>
        <trans-unit id="51b0c3f2b71fcd0ea3442b5d718eb8c566a2296f" translate="yes" xml:space="preserve">
          <source>Only the appearance of &lt;em&gt;uncovered&lt;/em&gt; type parameters is restricted. Note that for the purposes of coherence, &lt;a href=&quot;../glossary#fundamental-type-constructors&quot;&gt;fundamental types&lt;/a&gt; are special. The &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered, and &lt;code&gt;Box&amp;lt;LocalType&amp;gt;&lt;/code&gt; is considered local.</source>
          <target state="translated">仅限制&lt;em&gt;未发现的&lt;/em&gt;类型参数的外观。请注意，出于一致性的目的，&lt;a href=&quot;../glossary#fundamental-type-constructors&quot;&gt;基本类型&lt;/a&gt;是特殊的。该 &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 不被认为覆盖，并且 &lt;code&gt;Box&amp;lt;LocalType&amp;gt;&lt;/code&gt; 被认为是本地的。</target>
        </trans-unit>
        <trans-unit id="62a5a90afa5fbb53aff61b9a8c2fc3d66d83b35e" translate="yes" xml:space="preserve">
          <source>Only the last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">只有 &lt;code&gt;Foo&lt;/code&gt; 的最后一个字段具有涉及 &lt;code&gt;T&lt;/code&gt; 的类型</target>
        </trans-unit>
        <trans-unit id="aa278176dd71a6e098f1078a99115e300d8910ce" translate="yes" xml:space="preserve">
          <source>Only the test with the name &lt;code&gt;one_hundred&lt;/code&gt; ran; the other two tests didn&amp;rsquo;t match that name. The test output lets us know we had more tests than what this command ran by displaying &lt;code&gt;2 filtered out&lt;/code&gt; at the end of the summary line.</source>
          <target state="translated">只有名称为 &lt;code&gt;one_hundred&lt;/code&gt; 的测试才运行；其他两个测试与该名称不匹配。测试输出通过在摘要行的末尾显示 &lt;code&gt;2 filtered out&lt;/code&gt; ，使我们知道我们有比该命令更多的测试。</target>
        </trans-unit>
        <trans-unit id="d609ff949d70f19612dfe2483b65eb476e7f69db" translate="yes" xml:space="preserve">
          <source>Only traits defined in the current crate can be implemented for arbitrary types.</source>
          <target state="translated">只有在当前箱子中定义的特征才能为任意类型实现。</target>
        </trans-unit>
        <trans-unit id="faa9f253f7801e4d949e62ca0dcb20642b072d46" translate="yes" xml:space="preserve">
          <source>Only types implementing &lt;code&gt;std::ops::Deref&lt;/code&gt; can be dereferenced (such as &lt;code&gt;&amp;amp;T&lt;/code&gt;). Example:</source>
          <target state="translated">只能取消实现 &lt;code&gt;std::ops::Deref&lt;/code&gt; 类型（例如 &lt;code&gt;&amp;amp;T&lt;/code&gt; ）。例：</target>
        </trans-unit>
        <trans-unit id="5b7cee0492b998101b493b89f7410ea880e0f8c8" translate="yes" xml:space="preserve">
          <source>Only use the item in the scope it has been defined:</source>
          <target state="translated">只在已定义的范围内使用该项目。</target>
        </trans-unit>
        <trans-unit id="737047a48ebff11c2ae87259e8e12b5a0ea9f000" translate="yes" xml:space="preserve">
          <source>Opaque type representing the discriminant of an enum.</source>
          <target state="translated">表示一个枚举的判别式的不透明类型。</target>
        </trans-unit>
        <trans-unit id="3ba5a04eec7ab34d16390d75e26fc3fe98620cc4" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;Cargo.toml&lt;/em&gt; in your text editor of choice. It should look similar to the code in Listing 1-2.</source>
          <target state="translated">在您选择的文本编辑器中打开&lt;em&gt;Cargo.toml&lt;/em&gt;。它的外观应类似于清单1-2中的代码。</target>
        </trans-unit>
        <trans-unit id="0b3dfe100cddab4329734c9e3ee2eed64968e7db" translate="yes" xml:space="preserve">
          <source>Open Source Developers</source>
          <target state="translated">开放源代码开发者</target>
        </trans-unit>
        <trans-unit id="9e593a95e08dd5f0164cac54edffcaa5d02e5a5e" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;. If the connection fails, open a TCP connection to &lt;code&gt;127.0.0.1:8081&lt;/code&gt;:</source>
          <target state="translated">打开与 &lt;code&gt;127.0.0.1:8080&lt;/code&gt; 的TCP连接。如果连接失败，请打开与 &lt;code&gt;127.0.0.1:8081&lt;/code&gt; 的TCP连接：</target>
        </trans-unit>
        <trans-unit id="36758b7ca5d96a8abc3401009a4668433b033b74" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;:</source>
          <target state="translated">打开到 &lt;code&gt;127.0.0.1:8080&lt;/code&gt; 的TCP连接：</target>
        </trans-unit>
        <trans-unit id="7e13d18d4e6433983fbb1efa54b9983d326c5ae6" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the &amp;ldquo;Hello, world!&amp;rdquo; project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="translated">打开终端，输入以下命令以创建&lt;em&gt;项目&lt;/em&gt;目录和&amp;ldquo; Hello，world！&amp;rdquo;目录。&lt;em&gt;项目&lt;/em&gt;目录中的&lt;em&gt;项目&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="65c15f3ba1726083fcf5e460a4e8e6321cd0586e" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the Hello, world! project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="translated">打开终端并输入以下命令，以创建&lt;em&gt;项目&lt;/em&gt;目录和Hello，world！目录。&lt;em&gt;项目&lt;/em&gt;目录中的&lt;em&gt;项目&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b4eb537f2a91bae055600573be45de77a27b9ed7" translate="yes" xml:space="preserve">
          <source>Open locally installed documentation</source>
          <target state="translated">打开本地安装的文档</target>
        </trans-unit>
        <trans-unit id="84587cdad70cebf6217908dcf7d0133574192d78" translate="yes" xml:space="preserve">
          <source>Open your I/O project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt; file, which should look like this:</source>
          <target state="translated">打开I / O项目的&lt;em&gt;src / main.rs&lt;/em&gt;文件，该文件应如下所示：</target>
        </trans-unit>
        <trans-unit id="aa0399eaec8c7efbd5c34bb50abdda7465b3ccba" translate="yes" xml:space="preserve">
          <source>OpenOptions</source>
          <target state="translated">OpenOptions</target>
        </trans-unit>
        <trans-unit id="8de57f288f4a4084e69c7c4b2aa9da0a06b4257d" translate="yes" xml:space="preserve">
          <source>OpenOptions::access_mode</source>
          <target state="translated">OpenOptions::access_mode</target>
        </trans-unit>
        <trans-unit id="b67e2c499284523d04746aeea5c1bfc24b967904" translate="yes" xml:space="preserve">
          <source>OpenOptions::append</source>
          <target state="translated">OpenOptions::append</target>
        </trans-unit>
        <trans-unit id="32e358709483fecc1c34aed91a515c84a061da75" translate="yes" xml:space="preserve">
          <source>OpenOptions::attributes</source>
          <target state="translated">OpenOptions::attributes</target>
        </trans-unit>
        <trans-unit id="e5c7a13c833ad959de5247957e258cf0746e21f9" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow</source>
          <target state="translated">OpenOptions::borrow</target>
        </trans-unit>
        <trans-unit id="0acab324be26d91ab189d61abdf16dc747c5192c" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow_mut</source>
          <target state="translated">OpenOptions::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ebf38deb5d5125bd571ab2fbede6b16bab299f15" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone</source>
          <target state="translated">OpenOptions::clone</target>
        </trans-unit>
        <trans-unit id="f31d22dcf8f9c141ab8ed3fbc1d9d368635388e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_from</source>
          <target state="translated">OpenOptions::clone_from</target>
        </trans-unit>
        <trans-unit id="b0b15f6e5b6b2ad70a686d3798f9b969c1be6e56" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_into</source>
          <target state="translated">OpenOptions::clone_into</target>
        </trans-unit>
        <trans-unit id="2924b17a8e2b9d34f65d2694a37b0e1b92b85fc1" translate="yes" xml:space="preserve">
          <source>OpenOptions::create</source>
          <target state="translated">OpenOptions::create</target>
        </trans-unit>
        <trans-unit id="518de4d4d480c6aa0ee355b7e8b68e44c261345e" translate="yes" xml:space="preserve">
          <source>OpenOptions::create_new</source>
          <target state="translated">OpenOptions::create_new</target>
        </trans-unit>
        <trans-unit id="5af121b8450a8bfc83582fafa544f257437f0c14" translate="yes" xml:space="preserve">
          <source>OpenOptions::custom_flags</source>
          <target state="translated">OpenOptions::custom_flags</target>
        </trans-unit>
        <trans-unit id="676df7a6e2a4b55c69a37308e4d1e8ab3f83cd3a" translate="yes" xml:space="preserve">
          <source>OpenOptions::fmt</source>
          <target state="translated">OpenOptions::fmt</target>
        </trans-unit>
        <trans-unit id="82f3b255624db61ae979a06d980867d5802d4709" translate="yes" xml:space="preserve">
          <source>OpenOptions::from</source>
          <target state="translated">OpenOptions::from</target>
        </trans-unit>
        <trans-unit id="96ad0ddadc43e2419e6227a5777a55351dd9ac83" translate="yes" xml:space="preserve">
          <source>OpenOptions::into</source>
          <target state="translated">OpenOptions::into</target>
        </trans-unit>
        <trans-unit id="8b77c907fad19cddc5960121fab1fa49b4431f22" translate="yes" xml:space="preserve">
          <source>OpenOptions::mode</source>
          <target state="translated">OpenOptions::mode</target>
        </trans-unit>
        <trans-unit id="1285fb69a9cc28fa9fdf3579b2f9690ab52069d7" translate="yes" xml:space="preserve">
          <source>OpenOptions::new</source>
          <target state="translated">OpenOptions::new</target>
        </trans-unit>
        <trans-unit id="aa320b137860771a593f171b8bca56f205bab7e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::open</source>
          <target state="translated">OpenOptions::open</target>
        </trans-unit>
        <trans-unit id="add50a5d5957c658756ea3d2bf5f0dc20542a4ce" translate="yes" xml:space="preserve">
          <source>OpenOptions::read</source>
          <target state="translated">OpenOptions::read</target>
        </trans-unit>
        <trans-unit id="7e91e59a4c689bbc7efae946cf7ef51cecceeefe" translate="yes" xml:space="preserve">
          <source>OpenOptions::security_qos_flags</source>
          <target state="translated">OpenOptions::security_qos_flags</target>
        </trans-unit>
        <trans-unit id="90b2992d4cec48c28058dee872298370548406ec" translate="yes" xml:space="preserve">
          <source>OpenOptions::share_mode</source>
          <target state="translated">OpenOptions::share_mode</target>
        </trans-unit>
        <trans-unit id="48a692736f06da779873a596d6bb2424b9ad7161" translate="yes" xml:space="preserve">
          <source>OpenOptions::to_owned</source>
          <target state="translated">OpenOptions::to_owned</target>
        </trans-unit>
        <trans-unit id="46e980851a36d656e0daadb411e16ffdbbc2e1eb" translate="yes" xml:space="preserve">
          <source>OpenOptions::truncate</source>
          <target state="translated">OpenOptions::truncate</target>
        </trans-unit>
        <trans-unit id="5f197b60663b22df305247c4bfa1a457e5c0d835" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_from</source>
          <target state="translated">OpenOptions::try_from</target>
        </trans-unit>
        <trans-unit id="747eda4c8e3b44e7c01f7e027a9bd03352e1f790" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_into</source>
          <target state="translated">OpenOptions::try_into</target>
        </trans-unit>
        <trans-unit id="5058de688dcc60c90693a5096962f6405ea1f171" translate="yes" xml:space="preserve">
          <source>OpenOptions::type_id</source>
          <target state="translated">OpenOptions::type_id</target>
        </trans-unit>
        <trans-unit id="19a0518d3e6a36eb2eabd3b78700ce36d617b64d" translate="yes" xml:space="preserve">
          <source>OpenOptions::write</source>
          <target state="translated">OpenOptions::write</target>
        </trans-unit>
        <trans-unit id="6dc0ebb4fa3738b9bc9aac0db1fdc06f34fea9fc" translate="yes" xml:space="preserve">
          <source>OpenOptionsExt</source>
          <target state="translated">OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="45d6a023e7aaf3a8b617725a7efb650cf62cdf6c" translate="yes" xml:space="preserve">
          <source>Opening a file for both reading and writing, as well as creating it if it doesn't exist:</source>
          <target state="translated">打开一个文件进行读写,如果文件不存在,也可以创建它。</target>
        </trans-unit>
        <trans-unit id="d0521aae78e8ad155838f7de5e8f14d0ef7781f3" translate="yes" xml:space="preserve">
          <source>Opening a file to read:</source>
          <target state="translated">打开文件阅读。</target>
        </trans-unit>
        <trans-unit id="d7d34b4c8e94f4c904313459b9fb9b442177d441" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host with a timeout.</source>
          <target state="translated">打开与远程主机的TCP连接,并设置超时。</target>
        </trans-unit>
        <trans-unit id="209d3641e1fce80e2ba36a03cac2a67f569fb4c6" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host.</source>
          <target state="translated">打开与远程主机的TCP连接。</target>
        </trans-unit>
        <trans-unit id="48dea963058d766cb37add48852fe3f445feaf08" translate="yes" xml:space="preserve">
          <source>Opens a file at &lt;code&gt;path&lt;/code&gt; with the options specified by &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;self&lt;/code&gt; 指定的选项在 &lt;code&gt;path&lt;/code&gt; 处打开文件。</target>
        </trans-unit>
        <trans-unit id="1ebe50b26242826a11bca679d30a026d4444d1a2" translate="yes" xml:space="preserve">
          <source>Opens a file in write-only mode.</source>
          <target state="translated">以只写模式打开文件。</target>
        </trans-unit>
        <trans-unit id="127d959111790c197f023d709985c8cb7e583159" translate="yes" xml:space="preserve">
          <source>Operand of the &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; (&lt;code&gt;*&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;解除引用运算符&lt;/a&gt;（ &lt;code&gt;*&lt;/code&gt; ）的操作数。</target>
        </trans-unit>
        <trans-unit id="a2b8c4621b34e3c27498c6c8832719e530f09634" translate="yes" xml:space="preserve">
          <source>Operands</source>
          <target state="translated">Operands</target>
        </trans-unit>
        <trans-unit id="3b28f00441a9534ad36bef8779425496277b4521" translate="yes" xml:space="preserve">
          <source>Operands of &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;比较&lt;/a&gt;操作数。</target>
        </trans-unit>
        <trans-unit id="796e9c6aba0ed5f7facb56a161b990345eb7dff2" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values are intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="translated">&lt;code&gt;u32&lt;/code&gt; 值上的 &lt;code&gt;+&lt;/code&gt; 等操作旨在永不溢出，并且在某些调试配置中，检测到溢出并导致恐慌。尽管大多数算术都属于此类，但是某些代码明确期望并依赖于模块化算术（例如，哈希）。</target>
        </trans-unit>
        <trans-unit id="fd7809a925050c789646447f7ccccf00c4e8608c" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values is intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="translated">&lt;code&gt;u32&lt;/code&gt; 值上的 &lt;code&gt;+&lt;/code&gt; 等操作旨在永不溢出，并且在某些调试配置中，检测到溢出并导致恐慌。虽然大多数算术都属于此类，但是某些代码明确期望并依赖于模块化算术（例如，哈希）。</target>
        </trans-unit>
        <trans-unit id="732a02d050941e6169a56caaf931604a39dfcf26" translate="yes" xml:space="preserve">
          <source>Operations on ASCII strings and characters.</source>
          <target state="translated">对ASCII字符串和字符的操作。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e2cce0c9ff63663c1cea812414bb03fc6e974bec" translate="yes" xml:space="preserve">
          <source>Operator Traits</source>
          <target state="translated">经营者特征</target>
        </trans-unit>
        <trans-unit id="9cad0fd3139ef048c0168daf393a34c1807af1a2" translate="yes" xml:space="preserve">
          <source>Operator expressions</source>
          <target state="translated">操作符表达式</target>
        </trans-unit>
        <trans-unit id="9ae1b0ed74ef02f2a20320b8054a76c10c592467" translate="yes" xml:space="preserve">
          <source>Operator/Expression</source>
          <target state="translated">Operator/Expression</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="a48efc62628a97b690c020f8a1e8f8cb0bb0733d" translate="yes" xml:space="preserve">
          <source>Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in &lt;code&gt;std::ops&lt;/code&gt; or &lt;code&gt;std::cmp&lt;/code&gt;.</source>
          <target state="translated">Rust语言为内置类型定义了运算符。使用 &lt;code&gt;std::ops&lt;/code&gt; 或 &lt;code&gt;std::cmp&lt;/code&gt; trait也可以重载以下许多运算符。</target>
        </trans-unit>
        <trans-unit id="d7b5d154187c93c9da7d2603b606ea0b5d7ebfc3" translate="yes" xml:space="preserve">
          <source>Optimization hints</source>
          <target state="translated">优化提示</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="9a8587bd4b256cb6bf9e533c046c7ec07658a2a8" translate="yes" xml:space="preserve">
          <source>Option::and</source>
          <target state="translated">Option::and</target>
        </trans-unit>
        <trans-unit id="ad6a1d3208211ea9f4a0bbc163a21ab722dcc207" translate="yes" xml:space="preserve">
          <source>Option::and_then</source>
          <target state="translated">Option::and_then</target>
        </trans-unit>
        <trans-unit id="3f27b9ef99923ea0d93a7d269559394c38b333c3" translate="yes" xml:space="preserve">
          <source>Option::as_mut</source>
          <target state="translated">Option::as_mut</target>
        </trans-unit>
        <trans-unit id="e2458bfdc527d230aa943b40bea1e47ef7c1716a" translate="yes" xml:space="preserve">
          <source>Option::as_pin_mut</source>
          <target state="translated">Option::as_pin_mut</target>
        </trans-unit>
        <trans-unit id="627cd8388f389dc8a414dc64f0bd2aeb93b8bdb8" translate="yes" xml:space="preserve">
          <source>Option::as_pin_ref</source>
          <target state="translated">Option::as_pin_ref</target>
        </trans-unit>
        <trans-unit id="9e1386f584a53f30c4efc9f16fd6a42d3d390020" translate="yes" xml:space="preserve">
          <source>Option::as_ref</source>
          <target state="translated">Option::as_ref</target>
        </trans-unit>
        <trans-unit id="7e71699a5e7a9d061403b6a9d9cd2031f35e7d57" translate="yes" xml:space="preserve">
          <source>Option::borrow</source>
          <target state="translated">Option::borrow</target>
        </trans-unit>
        <trans-unit id="5a2fc76bcd6cc7797b2fc8e79077c3b905ad253b" translate="yes" xml:space="preserve">
          <source>Option::borrow_mut</source>
          <target state="translated">Option::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f8c7733356cc897d454d9d0b3ed5583a86a4fc0c" translate="yes" xml:space="preserve">
          <source>Option::clamp</source>
          <target state="translated">Option::clamp</target>
        </trans-unit>
        <trans-unit id="b2ed5b3da837f6c02fff44b90e9fcf28f2c92857" translate="yes" xml:space="preserve">
          <source>Option::clone</source>
          <target state="translated">Option::clone</target>
        </trans-unit>
        <trans-unit id="41a138cf124c5fbd9ab6a71d2a521b6f7b355bd9" translate="yes" xml:space="preserve">
          <source>Option::clone_from</source>
          <target state="translated">Option::clone_from</target>
        </trans-unit>
        <trans-unit id="428c2ed3ef54229edff7bb1c574b0bfd79b5c01e" translate="yes" xml:space="preserve">
          <source>Option::clone_into</source>
          <target state="translated">Option::clone_into</target>
        </trans-unit>
        <trans-unit id="7cd06b03e80642a3e13258da69f36190c57d76fe" translate="yes" xml:space="preserve">
          <source>Option::cloned</source>
          <target state="translated">Option::cloned</target>
        </trans-unit>
        <trans-unit id="7ea9e4985c5cd3b4ff11c4891148d8ba5e1cf7f3" translate="yes" xml:space="preserve">
          <source>Option::cmp</source>
          <target state="translated">Option::cmp</target>
        </trans-unit>
        <trans-unit id="0498a1a6447eab280dd5d4ffdbbf44f5e3cd0a3e" translate="yes" xml:space="preserve">
          <source>Option::copied</source>
          <target state="translated">Option::copied</target>
        </trans-unit>
        <trans-unit id="cb4ad142555a29053e45e10fc10d79edcbc2a96c" translate="yes" xml:space="preserve">
          <source>Option::default</source>
          <target state="translated">Option::default</target>
        </trans-unit>
        <trans-unit id="ba7eb304c78625b7673ed4fb2b20bafd2105ff7d" translate="yes" xml:space="preserve">
          <source>Option::deref</source>
          <target state="translated">Option::deref</target>
        </trans-unit>
        <trans-unit id="cb4668f98374c478c313d6124b78706cb9deedbc" translate="yes" xml:space="preserve">
          <source>Option::eq</source>
          <target state="translated">Option::eq</target>
        </trans-unit>
        <trans-unit id="76cfff0c978f7770807e24ce63e5dfca252d4367" translate="yes" xml:space="preserve">
          <source>Option::expect</source>
          <target state="translated">Option::expect</target>
        </trans-unit>
        <trans-unit id="6a0b764b6cbe10497b80db91840a28c114598907" translate="yes" xml:space="preserve">
          <source>Option::filter</source>
          <target state="translated">Option::filter</target>
        </trans-unit>
        <trans-unit id="560bd097e6d518e06d94482f4a9697ad398f15d0" translate="yes" xml:space="preserve">
          <source>Option::flatten</source>
          <target state="translated">Option::flatten</target>
        </trans-unit>
        <trans-unit id="d94a2e5f0e616513666e331c6d9144bddb878e9c" translate="yes" xml:space="preserve">
          <source>Option::fmt</source>
          <target state="translated">Option::fmt</target>
        </trans-unit>
        <trans-unit id="cbd7d776e3b699aac19b698f4ca1165601a486cb" translate="yes" xml:space="preserve">
          <source>Option::from</source>
          <target state="translated">Option::from</target>
        </trans-unit>
        <trans-unit id="e4ce8c942f648512db0f55fca12f5af00d0f8696" translate="yes" xml:space="preserve">
          <source>Option::from_error</source>
          <target state="translated">Option::from_error</target>
        </trans-unit>
        <trans-unit id="7e569e7075b5cfd328272103d6b5f8ce7d4d2194" translate="yes" xml:space="preserve">
          <source>Option::from_iter</source>
          <target state="translated">Option::from_iter</target>
        </trans-unit>
        <trans-unit id="a43b3b6ad08c70527052c24fb47f39fcaa4ebb0e" translate="yes" xml:space="preserve">
          <source>Option::from_ok</source>
          <target state="translated">Option::from_ok</target>
        </trans-unit>
        <trans-unit id="39c61b7ca243afc1e123c7964d51460ccf7ce39f" translate="yes" xml:space="preserve">
          <source>Option::ge</source>
          <target state="translated">Option::ge</target>
        </trans-unit>
        <trans-unit id="9b6edfb0a8e4a4f18c5a5177c880df9517534d89" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert</source>
          <target state="translated">Option::get_or_insert</target>
        </trans-unit>
        <trans-unit id="998b5cc317f56f6b2107c170f3756fdcf6a6be39" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert_with</source>
          <target state="translated">Option::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="ff18d337dd9fab1c83bb85ddea3fd7d94d3281c1" translate="yes" xml:space="preserve">
          <source>Option::gt</source>
          <target state="translated">Option::gt</target>
        </trans-unit>
        <trans-unit id="501ecb8b666b964e28da12f4615b48d3b7e450ee" translate="yes" xml:space="preserve">
          <source>Option::hash</source>
          <target state="translated">Option::hash</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
