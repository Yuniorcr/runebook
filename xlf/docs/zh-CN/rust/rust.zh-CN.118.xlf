<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">如果要创建一个集合，&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;为其实现IntoIterator将使您的集合可以与 &lt;code&gt;for&lt;/code&gt; 循环一起使用。</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">如果你正在做某种副作用，喜欢&lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;来 &lt;code&gt;map()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50fae5c17f1680200b10a72b86983fc6d83252f1" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657123c4239a0672bb847d20cff32727a933d93f" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c18403b0527c315799b70edeca9e66be8c0011" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">如果仅从 &lt;code&gt;main&lt;/code&gt; 返回this和 &lt;code&gt;SUCCESS&lt;/code&gt; ，则考虑分别返回 &lt;code&gt;Err(_)&lt;/code&gt; 和 &lt;code&gt;Ok(())&lt;/code&gt; ，这将返回相同的代码（但也将 &lt;code&gt;eprintln!&lt;/code&gt; 错误）。</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">如果确定要覆盖棉绒检查，则可以将 &lt;code&gt;forbid&lt;/code&gt; 更改为 &lt;code&gt;deny&lt;/code&gt; （如果将 &lt;code&gt;forbid&lt;/code&gt; 设置作为命令行选项给出，则使用 &lt;code&gt;-D&lt;/code&gt; 而不是 &lt;code&gt;-F&lt;/code&gt; ）以允许内部棉绒检查属性：</target>
        </trans-unit>
        <trans-unit id="9708dfd947b0f617c80eaf862c93f6be07e715ad" translate="yes" xml:space="preserve">
          <source>If you're using PowerShell, you will need to set the environment variable and run the program as separate commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">如果你使用的是rustc的年夜版本,只需添加相应的功能就能够使用。</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">如果您使用的是稳定版或测试版的rustc,您将无法使用任何不稳定的功能。為此,請切換到夜間版的 rustc (使用 rustup)。</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">如果您正在编写&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;，则可以将其与 &lt;code&gt;for&lt;/code&gt; 循环一起使用。</target>
        </trans-unit>
        <trans-unit id="39b96bd78ad2447973090132f0c782a06fee701a" translate="yes" xml:space="preserve">
          <source>If you've expected to use a crate name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">如果你发现自己有一个集合,并且需要对该集合的元素进行操作,你会很快遇到 &quot;迭代器&quot;。迭代器在习惯性的Rust代码中被大量使用,所以值得熟悉它们。</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">如果您的结构实际上不&lt;em&gt;拥有&lt;/em&gt;类型 &lt;code&gt;T&lt;/code&gt; 的数据，则最好使用引用类型，例如 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; （理想情况下）或 &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; （如果没有生命周期适用），这样不表示所有权。</target>
        </trans-unit>
        <trans-unit id="1f6b5f80968da1047a776f5803bbfc765104a318" translate="yes" xml:space="preserve">
          <source>If your type is &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;, you can implement &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;&lt;code&gt;partial_cmp&lt;/code&gt;&lt;/a&gt; by using &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">如果您的类型是 &lt;code&gt;Ord&lt;/code&gt; ，则可以使用 &lt;code&gt;cmp()&lt;/code&gt; 来实现 &lt;code&gt;partial_cmp()&lt;/code&gt; （）：</target>
        </trans-unit>
        <trans-unit id="7bfd0ea25f9360aa8168faba44b4ab62b5c11325" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt;&lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">如果您的类型使用钉扎（例如上面的两个示例），则在实现 &lt;code&gt;Drop&lt;/code&gt; 时必须小心。该 &lt;code&gt;drop&lt;/code&gt; 的功能需要 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，但是这就是所谓的&lt;em&gt;，即使你以前类型被寄予厚望&lt;/em&gt;！就像编译器自动调用了 &lt;code&gt;get_unchecked_mut&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">相反，如果闭包直接使用 &lt;code&gt;self.vec&lt;/code&gt; ，则它将尝试通过可变引用来捕获 &lt;code&gt;self&lt;/code&gt; 。但是由于 &lt;code&gt;self.set&lt;/code&gt; 已被借来进行迭代，因此代码无法编译。</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">忽略的领域的其他 &lt;code&gt;person&lt;/code&gt; 。其余字段可以具有任何值，并且不与任何变量绑定。</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">忽略带有嵌套 &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; 的部分值</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">用 &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt; 忽略值的其余部分</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">除非有特别要求,否则忽略某些测试</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">忽略模式中的值</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">用 &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt; 忽略整个值</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">通过以 &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt; 开头的名称来忽略未使用的变量</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">想象一下 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 在家庭活动室中作为电视。当一个人进入看电视时，他们会打开电视。其他人可以进入房间看电视。当最后一个人离开房间时，由于不再使用电视，他们关闭了电视。如果有人关闭电视，而其他人仍在观看电视，那么其余的电视观看者将会感到不安！</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">不变的原始条目的使用非常有限；您可能需要 &lt;code&gt;raw_entry_mut&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">不可变的分片迭代器</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">不变的从自有价值中借来。</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">从拥有的价值中一成不变地借钱。&lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">不变地借用封装的值,如果该值当前是可变地借用的,则返回错误。</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">不变的借用包装值。</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">Impl块单独声明寿命参数。如果你要实现一个有自己的寿命参数的类型,你需要把寿命参数添加到一个 impl 块中。例如</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">Impl特征</target>
        </trans-unit>
        <trans-unit id="21127244da70324da76b7c0c9aa099a69f9c571a" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;unsafe&lt;/code&gt;&lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">实施不安全特性</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">为一个类型实现一些功能。</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">实现&lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt;特性以实现廉价的可变突变</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">实现&lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt;特征以实现廉价的参考到参考的转换</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">实施&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; trait以使用价值转换为价值</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">实现&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;特性，以将值到值的转换消耗到当前包装箱之外的类型</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">在类型上实现 &lt;code&gt;Copy&lt;/code&gt; 特征。</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">逻辑上不可变的方法的实施细节</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">逻辑上不可变的方法的实施细节。</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">实施说明</target>
        </trans-unit>
        <trans-unit id="cbd0574adde4a73750817df1b9bf6659b05baae3" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f209c5111fdc43ea4ba2b99ff5e91a185c5ba5f" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ae3ae0632c811bda0590dcd36a31748f12009" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6523b8f0fa5de5a2e923accee11e86f6d33eb03c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">鼓励实现在内存耗尽时返回 &lt;code&gt;Err&lt;/code&gt; 而不是惊慌或中止，但这不是严格的要求。（特别是：在底层的本机分配库上实现此特征是&lt;em&gt;合法的&lt;/em&gt;，该本机分配库因内存耗尽而中止。）</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">鼓励实现在内存耗尽时返回null而不是中止，但这不是严格的要求。（特别是：在底层的本机分配库上实现此特征是&lt;em&gt;合法的&lt;/em&gt;，该本机分配库因内存耗尽而中止。）</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">鼓励实现在内存耗尽时返回null，而不是惊慌或中止，但这不是严格的要求。（特别是：在底层的本机分配库上实现此特征是&lt;em&gt;合法的&lt;/em&gt;，该本机分配库因内存耗尽而中止。）</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">实现可能在 &lt;code&gt;impl&lt;/code&gt; 关键字之前包含外部&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;，而在包含相关项目的方括号内则包含内部&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;。内部属性必须位于任何关联的项目之前。在这里有意义的属性是&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5c6183888e78c3e46f39fb71a3e11db5b02b618" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906e45c0ce13a452d5ad583acf7c948d36606488" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c77f28f9797beb5e60c442300cafb1661e149f7" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">的实现 &lt;code&gt;PartialEq&lt;/code&gt; ， &lt;code&gt;PartialOrd&lt;/code&gt; 和 &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;互相同意。通过推导某些特征并手动实施其他特征，很容易使它们意外地产生分歧。</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">的实现 &lt;code&gt;PartialEq&lt;/code&gt; ， &lt;code&gt;PartialOrd&lt;/code&gt; 和 &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;互相同意。也就是说， &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; 当且仅当 &lt;code&gt;a == b&lt;/code&gt; 和 &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; 为所有 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。通过推导某些特征并手动实施其他特征，很容易使它们意外地产生分歧。</target>
        </trans-unit>
        <trans-unit id="f03739953743b6047f7ae8d466b9ff10b313f420" translate="yes" xml:space="preserve">
          <source>Implementations of must return the same mutable reference for their lifetime, unless replaced by a caller. Callers may only replace the reference when they stopped iteration and drop the iterator pipeline after extracting the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">考虑到操作符特性的通常含义和&lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;操作符优先级&lt;/a&gt;，在他们各自的上下文中实现操作符特性应该不足为奇。例如，在实现&lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; 时&lt;/a&gt;，该操作应与乘法有些相似（并共享期望的属性，如关联性）。</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">对于固定长度的数组，直到一定长度的东西，如 &lt;code&gt;Eq&lt;/code&gt; 的实现。最终，我们应该能够全面推广。</target>
        </trans-unit>
        <trans-unit id="2f5aa5cbed1b025d1b2126e25480e69829ce743f" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually, we should be able to generalize to all lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118b3aed38f3812ad05266c0985ae4538e945007" translate="yes" xml:space="preserve">
          <source>Implementations of this trait have to promise that if the argument to &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; is a safe reference, then so is the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">外来类型的实施</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">手动实现 &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; 和 &lt;code&gt;Sync&lt;/code&gt; 是不安全的</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">用泛型实现 &lt;code&gt;Add&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;Binary&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">为智能指针实现 &lt;code&gt;Deref&lt;/code&gt; 使得访问它们后面的数据变得方便，这就是为什么它们实现 &lt;code&gt;Deref&lt;/code&gt; 的原因。另一方面，有关 &lt;code&gt;Deref&lt;/code&gt; 和&lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;的规则是专门为容纳智能指针而设计的。因此，&lt;strong&gt;仅应为智能指针实现&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/strong&gt;以避免混淆。</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">为智能指针实现 &lt;code&gt;DerefMut&lt;/code&gt; 使得对它们后面的数据进行更改变得很方便，这就是它们实现 &lt;code&gt;DerefMut&lt;/code&gt; 的原因。另一方面，有关&lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;DerefMut&lt;/code&gt; 的规则是专门为容纳智能指针而设计的。因此，&lt;strong&gt;仅应为智能指针实现&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/strong&gt;以避免混淆。</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;Display&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">实现 &lt;code&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">实施 &lt;code&gt;Extend&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">为您的类型实现 &lt;code&gt;FromIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;Hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">实施 &lt;code&gt;Into&lt;/code&gt; 以转换为外部类型</target>
        </trans-unit>
        <trans-unit id="47b64f6f87d5b0f43159c63203037214de4fae2c" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types in old versions of Rust</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">为您的类型实现 &lt;code&gt;IntoIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;LowerExp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;LowerHex&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;Octal&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;Pointer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">用泛型实现 &lt;code&gt;Sub&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;TryInto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">在类型上实现 &lt;code&gt;UpperExp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">在一种类型上实现 &lt;code&gt;UpperHex&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">实现 &lt;code&gt;split_at_mut&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">迭代器的实现</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">将转换实现为不同类型的变换。</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">在类型上实现一个特征</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">在类型上实现特征类似于实现常规方法。区别在于，在 &lt;code&gt;impl&lt;/code&gt; 之后，我们放入要实现的特征名称，然后使用 &lt;code&gt;for&lt;/code&gt; 关键字，然后指定要为其实现特征的类型的名称。在 &lt;code&gt;impl&lt;/code&gt; 块中，我们放入特征定义已定义的方法签名。我们没有在每个签名后添加分号，而是使用大括号并在方法主体中填充了我们希望特征对于特定类型具有的特定行为。</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">实施&lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;不安全特质&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">实现面向对象的设计模式</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">实施不安全特征</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;ThreadPool&lt;/code&gt; 上实现 &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">实现 &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">实现 &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">实施 &lt;code&gt;Deref&lt;/code&gt; 特质让你自定义的行为&lt;em&gt;引用操作&lt;/em&gt;， &lt;code&gt;*&lt;/code&gt; （而不是乘法或水珠运营商）。通过以一种可以将智能指针视为常规引用的方式实施 &lt;code&gt;Deref&lt;/code&gt; ，您可以编写对引用进行操作的代码，并将该代码也与智能指针一起使用。</target>
        </trans-unit>
        <trans-unit id="0f9c556a4371185e579cbc710c1fc95eeb3c1d8f" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Unpin&lt;/code&gt; trait for &lt;code&gt;T&lt;/code&gt; lifts the restrictions of pinning off the type, which then allows moving &lt;code&gt;T&lt;/code&gt; out of &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">实施特质</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">实现这些特性可以让你过载某些操作符。</target>
        </trans-unit>
        <trans-unit id="eda774fd99643b19395b54fc514042bb2ec818cd" translate="yes" xml:space="preserve">
          <source>Implementing this method means adapters relinquish private-only access to their source and can only rely on guarantees made based on method receiver types. The lack of restricted access also requires that adapters must uphold the source's public API even when they have access to its internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现此特征可以解除固定类型的限制，然后允许使用诸如&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;功能将其移出。</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 特征的实现者称为&amp;ldquo;阅读器&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">具有 &lt;code&gt;Write&lt;/code&gt; 特性的实现者有时称为&amp;ldquo;作家&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a29b7cdf7ecad32a88da5f080db151e6782b6cbd" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3e920e06f6ab852e47c92d5907d33f79db03f9" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b100c6b8306d80c3deac3c66eb144722bfbf34" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9bfc1f72bab87b52d6e0bc8ae9d29b981a8471" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d4e2f4157c9478fac1167b8d36a099c3612234" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">在词典上实现向量的比较。</target>
        </trans-unit>
        <trans-unit id="8c72616b99bde1fdb32f3ac1428fa28fcbc9bbe4" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121392f51a7cb90c886bedc6219cb1e615ac17eb" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">实现向量的比较,词汇学。</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">实现对字符串的比较操作。</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">实现字符串的排序。</target>
        </trans-unit>
        <trans-unit id="35489c538a41efaebde69fb1cc4bd86b19d3be17" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d293e0c8158270fc97cffd60669c60a1be015e" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">实现向量的排序,词法。</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; 语法实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">使用语法 &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; 实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">使用语法 &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; 实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; 语法实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; 语法实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; 语法实现子字符串切片。</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">实现 &lt;code&gt;+&lt;/code&gt; 运算符以连接两个字符串。</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">实现 &lt;code&gt;+=&lt;/code&gt; 运算符以附加到 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">隐性借款</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">用函数和方法进行隐性脱力胁迫。</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">隐性借贷可采取以下表达方式。</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">隐性启用</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">从其他箱子或模块导入或重命名物品。</target>
        </trans-unit>
        <trans-unit id="a3bc444ee7d2e0f0563ef80376cca1e4bb0a9a91" translate="yes" xml:space="preserve">
          <source>Importing with &lt;code&gt;_&lt;/code&gt; to only import the methods of a trait without binding it to a name (to avoid conflict for example): &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">不允许在非项目语句（例如变量声明和表达式语句）之后导入（ &lt;code&gt;use&lt;/code&gt; 语句）。</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">通过线程池提高我们服务器的吞吐量。</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">改进我们的I/O项目</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">利用线程池提高吞吐量</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">改进错误信息</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">在 &lt;code&gt;ThreadPool::new&lt;/code&gt; ，使用 &lt;code&gt;for&lt;/code&gt; 循环计数器生成 &lt;code&gt;id&lt;/code&gt; ，创建一个新的 &lt;code&gt;Worker&lt;/code&gt; 与 &lt;code&gt;id&lt;/code&gt; ，与劳动者存储载体。</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">在 &lt;code&gt;ThreadPool::new&lt;/code&gt; ，我们创建我们的新通道，并让该池容纳发送端。这将成功编译，但仍带有警告。</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">在 &lt;code&gt;ThreadPool::new&lt;/code&gt; ，我们将通道的接收端放在 &lt;code&gt;Arc&lt;/code&gt; 和 &lt;code&gt;Mutex&lt;/code&gt; 中。对于每个新工作人员，我们克隆 &lt;code&gt;Arc&lt;/code&gt; 来增加参考计数，以便工作人员可以共享接收端的所有权。</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 中，我们调用 &lt;code&gt;Dog::baby_name&lt;/code&gt; 函数，该函数直接调用在 &lt;code&gt;Dog&lt;/code&gt; 上定义的关联函数。此代码显示以下内容：</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 中，我们创建了两个 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 实例，然后打印 &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; 。在 &lt;code&gt;main&lt;/code&gt; 的最后，我们的 &lt;code&gt;CustomSmartPointer&lt;/code&gt; 实例将超出范围，Rust将调用放置在 &lt;code&gt;drop&lt;/code&gt; 方法中的代码，并打印最终消息。注意，我们不需要显式调用 &lt;code&gt;drop&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="80fb329de5f9b05c42fffbe0f4f0674e4bf17666" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 中，我们添加了一条新语句： &lt;code&gt;fs::read_to_string&lt;/code&gt; 获取 &lt;code&gt;filename&lt;/code&gt; ，打开该文件，并返回文件内容的 &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; ，我们已经定义了一个 &lt;code&gt;Point&lt;/code&gt; ，其具有 &lt;code&gt;i32&lt;/code&gt; 为 &lt;code&gt;x&lt;/code&gt; （具有值 &lt;code&gt;5&lt;/code&gt; ）和 &lt;code&gt;f64&lt;/code&gt; 为 &lt;code&gt;y&lt;/code&gt; （具有值 &lt;code&gt;10.4&lt;/code&gt; ）。所述 &lt;code&gt;p2&lt;/code&gt; 变量是一个 &lt;code&gt;Point&lt;/code&gt; 结构，其具有用于一个字符串切片 &lt;code&gt;x&lt;/code&gt; （具有值 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ）和 &lt;code&gt;char&lt;/code&gt; 用于 &lt;code&gt;y&lt;/code&gt; （具有值 &lt;code&gt;c&lt;/code&gt; ）。调用 &lt;code&gt;mixup&lt;/code&gt; 上 &lt;code&gt;p1&lt;/code&gt; 与参数 &lt;code&gt;p2&lt;/code&gt; 为我们提供了 &lt;code&gt;p3&lt;/code&gt; ，这将有 &lt;code&gt;i32&lt;/code&gt; 的 &lt;code&gt;x&lt;/code&gt; ，因为 &lt;code&gt;x&lt;/code&gt; 来自 &lt;code&gt;p1&lt;/code&gt; 。在 &lt;code&gt;p3&lt;/code&gt; 变量将有一个 &lt;code&gt;char&lt;/code&gt; 为 &lt;code&gt;y&lt;/code&gt; ，因为 &lt;code&gt;y&lt;/code&gt; 从哪里来 &lt;code&gt;p2&lt;/code&gt; 。该 &lt;code&gt;println!&lt;/code&gt; 宏调用将输出 &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">在 &lt;code&gt;match&lt;/code&gt; 表达式中，可以使用 &lt;code&gt;|&lt;/code&gt; 匹配多个模式。语法，表示&lt;em&gt;或&lt;/em&gt;。例如，以下代码将 &lt;code&gt;x&lt;/code&gt; 的值与匹配臂进行匹配，匹配臂中的第一个具有&lt;em&gt;or&lt;/em&gt;选项，这意味着如果 &lt;code&gt;x&lt;/code&gt; 的值与该臂中的任一值匹配，则该臂的代码将运行：</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">在C和C ++中，两个不同的运算符用于调用方法：use &lt;code&gt;.&lt;/code&gt; 如果要直接在对象上调用方法，则 &lt;code&gt;-&amp;gt;&lt;/code&gt; 如果要在指向对象的指针上调用方法，并且需要先取消引用该指针。换句话说，如果 &lt;code&gt;object&lt;/code&gt; 是指针，则 &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; 与 &lt;code&gt;(*object).something()&lt;/code&gt; 相似。</target>
        </trans-unit>
        <trans-unit id="13a07dbff3d7bb71ba41c886c11573397f976542" translate="yes" xml:space="preserve">
          <source>In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn&amp;rsquo;t belong to that structure. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">在第1章中，您看到了 &lt;code&gt;cargo new&lt;/code&gt; 在版本的&lt;em&gt;Cargo.toml&lt;/em&gt;文件中添加了一些元数据。本附录讨论了这意味着什么！</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">在第10章&lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;在类型上实现特征&amp;rdquo;中&lt;/a&gt;，我们提到了孤立规则，该规则规定，只要特征或类型在板条箱中是本地的，就允许我们对类型实现特征。可以使用&lt;em&gt;newtype模式&lt;/em&gt;解决此限制，该&lt;em&gt;模式&lt;/em&gt;涉及在元组结构中创建新类型。 （我们在第5章的&lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;使用没有命名字段的元组结构创建不同类型&amp;rdquo;中&lt;/a&gt;介绍了元组结构。）元组结构将只有一个字段，并且是我们要为其实现特征的类型的瘦包装。然后包装器类型对于我们的板条箱是本地的，我们可以在包装器上实现特征。&lt;em&gt;新类型&lt;/em&gt;是一个源自Haskell编程语言的术语。使用此模式不会影响运行时性能，并且包装类型在编译时会被忽略。</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">在第10章中，我们将讨论如何解决这些错误，以便您可以将引用存储在结构中，但是现在，我们将使用诸如 &lt;code&gt;String&lt;/code&gt; 之类的拥有类型而不是像 &lt;code&gt;&amp;amp;str&lt;/code&gt; 这样的引用来修复此类错误。</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">在第12章中，我们构建了一个包含二进制板条箱和库板条箱的软件包。随着项目的发展，您可能会发现库箱继续变大，并且您想将包进一步拆分成多个库箱。在这种情况下，Cargo提供了一个称为&lt;em&gt;工作空间&lt;/em&gt;的功能，该功能可以帮助管理串联开发的多个相关程序包。</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">在第13章中，我们提到了可以在闭包的参数列表之前使用 &lt;code&gt;move&lt;/code&gt; 关键字，以强制闭包对其在环境中使用的值进行所有权。当创建新线程以将值的所有权从一个线程转移到另一个线程时，此技术特别有用。</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">在第15章中，我们使用智能指针 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 创建了一个参考计数值，从而为多个所有者赋予了一个值。让我们在这里做同样的事情，看看会发生什么。在清单16-14中，我们将 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 包装在 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 中，并在将所有权移至线程之前克隆 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 。现在我们已经看到了错误，我们还将切换回使用 &lt;code&gt;for&lt;/code&gt; 循环，并且将 &lt;code&gt;move&lt;/code&gt; 关键字保留在闭包中。</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">在第16章中，我们将介绍并发编程的不同模型，并讨论Rust如何帮助您轻松地在多个线程中进行编程。第17章介绍了Rust习惯用法与您可能熟悉的面向对象编程原理的比较。</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">在第16章中，您了解了&lt;em&gt;通道（&lt;/em&gt;在两个线程之间进行通信的一种简单方法），这对于此用例而言是完美的。我们将使用一个通道作为作业队列， &lt;code&gt;execute&lt;/code&gt; 将把作业从 &lt;code&gt;ThreadPool&lt;/code&gt; 发送到 &lt;code&gt;Worker&lt;/code&gt; 实例，再将作业发送到其线程。这是计划：</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">在第2章中，我们编写了一个猜测游戏项目，该项目使用一个称为 &lt;code&gt;rand&lt;/code&gt; 的外部程序包来获取随机数。要在我们的项目中使用 &lt;code&gt;rand&lt;/code&gt; ，我们将此行添加到&lt;em&gt;Cargo.toml中&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">在第20章中，我们将完成一个项目，在该项目中我们将实现一个低级多线程Web服务器！</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">在第3章中，我们提到了 &lt;code&gt;for&lt;/code&gt; 循环是Rust代码中最常见的循环构造，但我们尚未讨论 &lt;code&gt;for&lt;/code&gt; 取用的模式。在 &lt;code&gt;for&lt;/code&gt; 循环中，模式是紧随关键字 &lt;code&gt;for&lt;/code&gt; 的值，因此 &lt;code&gt;for x in y&lt;/code&gt; 中的x中， &lt;code&gt;x&lt;/code&gt; 是模式。</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">在第4章的&lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;悬挂引用&amp;rdquo;&lt;/a&gt;部分中，我们提到了编译器确保引用始终有效。不安全的Rust有两种称为&lt;em&gt;原始指针的&lt;/em&gt;新类型，它们类似于引用。与引用一样，原始指针可以是不可变的或可变的，并且分别写为 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 。星号不是取消引用运算符；它是类型名称的一部分。在原始指针的上下文中，&lt;em&gt;不可变&lt;/em&gt;意味着指针在被取消引用后不能直接分配给它。</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">在清单5-15的第5章中，我们使用了 &lt;code&gt;Rectangle&lt;/code&gt; 结构和 &lt;code&gt;can_hold&lt;/code&gt; 方法，在清单11-5中对此进行了重复。让我们将这段代码放在&lt;em&gt;src / lib.rs&lt;/em&gt;文件中，并使用 &lt;code&gt;assert!&lt;/code&gt; 为其编写一些测试！宏。</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">在第六章中，我们讨论了如何使用 &lt;code&gt;if let&lt;/code&gt; 表达主要表现为较短的方式写了一个等效的 &lt;code&gt;match&lt;/code&gt; ，只有匹配一个情况。或者， &lt;code&gt;if let&lt;/code&gt; 可以有一个相应的 &lt;code&gt;else&lt;/code&gt; 包含代码来运行，如果在模式 &lt;code&gt;if let&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">在第7章中，我们介绍了如何使用 &lt;code&gt;mod&lt;/code&gt; 关键字将代码组织到模块中，如何使用 &lt;code&gt;pub&lt;/code&gt; 关键字将项目公开，以及如何 &lt;code&gt;use&lt;/code&gt; 关键字将项目带入范围。但是，在开发板条箱时对您有意义的结构可能对您的用户而言不是很方便。您可能想要在包含多个级别的层次结构中组织结构，但是想要使用您在层次结构深处定义的类型的人可能很难发现该类型存在。他们也可能因为不得不输入 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; 而感到恼火。而不是 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">在第7章中，您将了解Rust的模块系统以及用于组织代码及其公共应用程序编程接口（API）的隐私规则。第8章讨论了标准库提供的一些常见的集合数据结构，例如向量，字符串和哈希图。第9章探讨了Rust的错误处理哲学和技术。</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">在第8章中，我们提到了向量的一个局限性是它们只能存储一种类型的元素。我们在清单8-10中创建了一种变通方法，其中定义了一个 &lt;code&gt;SpreadsheetCell&lt;/code&gt; 枚举，该枚举具有用于容纳整数，浮点数和文本的变体。这意味着我们可以在每个单元格中存储不同类型的数据，并且仍然具有代表一行单元格的向量。当我们的可互换项是我们在编译代码时就知道的一组固定类型时，这是一个非常好的解决方案。</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">在Enum定义中</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">在功能定义中</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">在清单10-3中，我们将找到最大数字的代码提取到名为 &lt;code&gt;largest&lt;/code&gt; 的函数中。与清单10-1中的代码只能在一个特定列表中找到最大的数字不同，此程序可以在两个不同的列表中找到最大的数字。</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">在清单11-7中，我们编写了一个名为 &lt;code&gt;add_two&lt;/code&gt; 的函数，该函数将其参数加 &lt;code&gt;2&lt;/code&gt; 并返回结果。然后，我们使用 &lt;code&gt;assert_eq!&lt;/code&gt; 测试此功能！宏。</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">在清单12-6中，我们添加了获取一部分 &lt;code&gt;String&lt;/code&gt; 值的代码，并通过索引该切片并克隆值来创建 &lt;code&gt;Config&lt;/code&gt; 结构的实例，从而使 &lt;code&gt;Config&lt;/code&gt; 结构拥有这些值。在清单13-24中，我们复制了清单12-23 中的 &lt;code&gt;Config::new&lt;/code&gt; 函数的实现：</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">在清单12-8中，我们在 &lt;code&gt;new&lt;/code&gt; 函数中添加了一个检查，该检查将在访问索引1和2之前验证切片是否足够长。如果切片不够长，则程序会产生恐慌并显示出比错误消息更好的错误消息。 &lt;code&gt;index out of bounds&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">在清单13-18中，我们收集了从调用 &lt;code&gt;map&lt;/code&gt; 返回到向量的迭代器上迭代的迭代结果。此向量最终将包含原始向量中每一项递增1的各项。</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">在清单13-19中，我们使用带有闭包的 &lt;code&gt;filter&lt;/code&gt; ，该闭包从其环境中捕获 &lt;code&gt;shoe_size&lt;/code&gt; 变量以遍历 &lt;code&gt;Shoe&lt;/code&gt; 结构实例的集合。它只会返回指定尺寸的鞋子。</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">在清单15-19中，我们将更改 &lt;code&gt;main&lt;/code&gt; ，使其在列表 &lt;code&gt;c&lt;/code&gt; 的内部具有范围；然后我们可以看到 &lt;code&gt;c&lt;/code&gt; 超出范围时引用计数如何变化。</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">在清单15-26中，我们添加了一个使用清单15-25中的定义的 &lt;code&gt;main&lt;/code&gt; 函数。此代码创建列表中的 &lt;code&gt;a&lt;/code&gt; ，并在列表 &lt;code&gt;b&lt;/code&gt; ，它指向列表中的 &lt;code&gt;a&lt;/code&gt; 。然后，它将 &lt;code&gt;a&lt;/code&gt; 中的列表修改为指向 &lt;code&gt;b&lt;/code&gt; ，从而创建一个参考循环。有 &lt;code&gt;println!&lt;/code&gt; 语句，以显示在此过程中各个点的引用计数。</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">在清单16-8中，我们将从主线程中通道的接收端获取值。这就像从河底的水中取回橡皮鸭一样，或者得到聊天消息。</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">在清单18-11中，我们提到可以使用匹配防护来解决我们的模式隐藏问题。回想一下，在 &lt;code&gt;match&lt;/code&gt; 表达式中的模式内部创建了一个新变量，而不是在 &lt;code&gt;match&lt;/code&gt; 之外使用该变量。这个新变量意味着我们无法针对外部变量的值进行测试。清单18-27显示了如何使用匹配保护器解决此问题。</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">在清单7-11中，我们把 &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; 模块插入的范围 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 功能，所以我们只需要指定 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 调用 &lt;code&gt;add_to_waitlist&lt;/code&gt; 功能 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">在清单7-11中，您可能想知道为什么我们指定 &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; 然后在 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 中调用 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; ，而不是一直指定到 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数的 &lt;code&gt;use&lt;/code&gt; 路径来获得相同的结果，如清单7-13所示。</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">在方法定义中</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">在Rust 1.3中，如&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156中&lt;/a&gt;所述，默认对象生存期界限应该发生变化。之所以会发出警告，是因为编译器认为此更改可能会导致代码中的编译错误。尽管不太可能，但这是一个错误的警报。</target>
        </trans-unit>
        <trans-unit id="024c5bd925d0560baf0e3312c1764bcb998284df" translate="yes" xml:space="preserve">
          <source>In Rust 2015, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the crate root. To import items relative to the current and parent modules, use the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dd28b00244d1766f66dc28a5630ffdd59cfac9" translate="yes" xml:space="preserve">
          <source>In Rust 2018 the &lt;code&gt;extern crate&lt;/code&gt; declaration is not required and you can instead just &lt;code&gt;use&lt;/code&gt; it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b256b3c7dd03072851511683d3f9db1e7f94539a" translate="yes" xml:space="preserve">
          <source>In Rust 2018, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the current module unless they begin with the name of a crate or a literal &lt;code&gt;crate::&lt;/code&gt;, in which case they start from the crate root. As in Rust 2015 code, the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes refer to the current and parent modules respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">在Rust中,如果一个函数惊慌失措,或者调用了一个中途惊慌失措的函数,它就会提前 &quot;返回&quot;。这种控制流并不总是被预料到的,并且有可能通过两个关键组件的组合造成微妙的错误。</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">在Rust中，&lt;em&gt;发布配置文件&lt;/em&gt;是具有不同配置的预定义和可自定义的配置文件，使程序员可以更好地控制各种用于编译代码的选项。每个配置文件均独立配置。</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">在Rust中，注释必须以两个斜杠开头，并一直持续到该行的末尾。对于超出一行的注释，您需要在每行上加上 &lt;code&gt;//&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">在Rust中，全局变量称为&lt;em&gt;静态&lt;/em&gt;变量。清单19-9显示了一个示例声明和一个静态变量的使用，该静态变量将字符串切片作为值。</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">在Rust中，集成测试完全在您的库外部。他们以与其他任何代码相同的方式使用您的库，这意味着它们只能调用属于您库的公共API的函数。它们的目的是测试库的许多部分是否可以正常协同工作。单独正确运行的代码单元在集成时可能会出现问题，因此测试集成代码的覆盖范围也很重要。要创建集成测试，首先需要一个&lt;em&gt;tests&lt;/em&gt;目录。</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">在Rust中，通常为不同的用例提供类型的不同表示形式。例如，可以通过诸如&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;类的指针类型，为特定用途适当地选择值的存储位置和管理。除了这些可以用于任何类型的通用包装器之外，某些类型还提供了可选的构面，从而提供了可能昂贵的功能。这种类型的一个例子是&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;，它增加了将字符串扩展到基本&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 的功能&lt;/a&gt;。这要求保持简单的，不变的字符串不需要的附加信息。</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Rust中，当您只想提供读取访问权限时，通常将切片作为参数而不是向量传递。这同样适用于&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa445d9bc6ce3579a8b9343d188f81a07982bc87" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">在Rust中，迭代器是&lt;em&gt;lazy&lt;/em&gt;，这意味着它们直到您调用消耗该迭代器的方法以将其耗尽为止才有效。例如，清单13-13中的代码通过调用 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 上定义的 &lt;code&gt;iter&lt;/code&gt; 方法，在向量 &lt;code&gt;v1&lt;/code&gt; 中的项目上创建了一个迭代器。这段代码本身没有任何用处。</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">在Rust中，某些简单类型是&amp;ldquo;隐式可复制的&amp;rdquo;，当您将它们分配或作为参数传递时，接收方将获得一个副本，而将原始值保留在原位。这些类型不需要分配就可以复制并且没有终结器（即，它们不包含拥有的盒子或实现&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;），因此编译器认为它们便宜且安全地复制。对于其他类型，必须按照惯例实现&lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; trait并调用&lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;方法来显式地进行复制。</target>
        </trans-unit>
        <trans-unit id="2fcd990460e8b6d0fc26ae7880ea98a98c91ad7c" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">在Rust中，某些类型在编译时没有已知大小。例如，在像 &lt;code&gt;[u32]&lt;/code&gt; 这样的切片类型中，元素数量在编译时未知，因此无法计算总体大小。结果，只能通过引用（例如 &lt;code&gt;&amp;amp;T&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）或其他指针类型（例如 &lt;code&gt;Box&lt;/code&gt; 或 &lt;code&gt;Rc&lt;/code&gt; ）来操纵此类类型。尝试强制转换为参考：</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">在Rust中,字符串总是有效的UTF-8,其中可能包含0。</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">在Rust中，编译器保证当您声明一个值不会更改时，它实际上不会更改。这意味着在阅读和编写代码时，不必跟踪值的更改方式和位置。因此，您的代码更易于推理。</target>
        </trans-unit>
        <trans-unit id="187bd10d150e89528422d52ad5b94f3768fbf136" translate="yes" xml:space="preserve">
          <source>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">在 Rust 中,进入数组的值被写成一个方括号内的逗号分隔的列表。</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">在使用所有权和借用概念的Rust中，引用和智能指针之间的另一个区别是，引用是仅借用数据的指针。相反，在许多情况下，智能指针&lt;em&gt;拥有&lt;/em&gt;它们指向的数据。</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">在 Rust 中,你只能在编译时知道一个值的大小时才能移动它。</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">在结构定义中</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">在土耳其语中,相当于拉丁语中的 &quot;i &quot;有五种形式,而不是两种。</target>
        </trans-unit>
        <trans-unit id="95435691c2a2f4eefe5ecbf90205f41c0b8b41fb" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; definition and related &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b57043cd55b10d931a7fc7d67ec1a60b6e68743" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type and not in the arguments types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">在 &lt;code&gt;fn&lt;/code&gt; 类型中，生存期仅出现在返回类型中，而不出现在参数类型中。</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在给定的程序中，标准库具有一个&amp;ldquo;全局&amp;rdquo;内存分配器，例如， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 使用该分配器。</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">在匹配表达式中,只能将数字和字符与一个范围进行匹配,这是因为编译器在编译时检查范围是非空的,无法评估任意比较函数。这是因为编译器在编译时检查范围是非空的,并且无法评估任意的比较函数。如果你想在两个端点之间捕获一个可排序类型的值,你可以使用守卫。</target>
        </trans-unit>
        <trans-unit id="33cf96775891f63612a2b18790b9f75c00ddb97e" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both (1.) the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; (2.) the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">在模式中，所有未实现 &lt;code&gt;Copy&lt;/code&gt; trait的值都必须以相同的方式绑定。此处的目标是避免同时通过by-ref和by-ref进行绑定。</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">在一个模式中:包含范围模式</target>
        </trans-unit>
        <trans-unit id="83c0ddf34fdbd1317fa94180ff2437b5be9c9767" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from a &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt;, calling it again may or may not ever return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; again. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; are interchangeable for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">以类似于&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;协议的方式，一旦 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 从 &lt;code&gt;next_back()&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; ，则再次调用它可能会或可能不会再次返回 &lt;code&gt;Some&lt;/code&gt; 。 &lt;code&gt;next()&lt;/code&gt; 和 &lt;code&gt;next_back()&lt;/code&gt; 可以互换使用。</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">从某种意义上说，任何编程语言中的通道都类似于单一所有权，因为一旦在通道下传递了值，就不应再使用该值。共享内存并发就像是多个所有权：多个线程可以同时访问同一内存位置。正如您在第15章中看到的那样，智能指针使多重所有权成为可能，多重所有权会增加复杂性，因为这些不同的所有者需要管理。 Rust的类型系统和所有权规则在很大程度上有助于正确地进行管理。例如，让我们看一下互斥锁，互斥锁是共享内存中最常见的并发原语之一。</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">除在不可变上下文中与（一元） &lt;code&gt;*&lt;/code&gt; 运算符一起用于显式解引用操作外，在许多情况下，编译器都将隐式使用 &lt;code&gt;Deref&lt;/code&gt; 。这种机制称为&lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&amp;ldquo; &lt;code&gt;Deref&lt;/code&gt; 强制&amp;rdquo;&lt;/a&gt;。在可变上下文中，使用&lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">除在可变上下文中与（一元） &lt;code&gt;*&lt;/code&gt; 运算符一起用于显式解引用操作外，在许多情况下，编译器都将隐式使用 &lt;code&gt;DerefMut&lt;/code&gt; 。这种机制称为&lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&amp;ldquo; &lt;code&gt;Deref&lt;/code&gt; 强制&amp;rdquo;&lt;/a&gt;。在不可变的上下文中，使用&lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">除了检查我们的代码是否返回了我们期望的正确值外，检查我们的代码是否按预期处理错误条件也很重要。例如，考虑我们在清单9-10的第9章中创建的 &lt;code&gt;Guess&lt;/code&gt; 类型。其他使用 &lt;code&gt;Guess&lt;/code&gt; 的代码取决于保证 &lt;code&gt;Guess&lt;/code&gt; 实例将只包含1到100之间的值。我们可以编写测试来确保尝试创建一个值超出该范围的 &lt;code&gt;Guess&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">除了通过模式匹配进行结构分解外，我们还可以通过使用句点（ &lt;code&gt;.&lt;/code&gt; ）和要访问的值的索引直接访问元组元素。例如：</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">除了装配所述存储器块 &lt;code&gt;layout&lt;/code&gt; ，所述的对准 &lt;code&gt;layout&lt;/code&gt; 必须与用于分配的存储器块中的对准相匹配。</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">除了分组功能之外，封装实现细节还使您可以在更高级别上重用代码：实现操作后，其他代码可以通过代码的公共接口调用该代码，而无需了解实现的工作方式。编写代码的方式定义了哪些部分是公共的，供其他代码使用，哪些部分是私有的实现细节，您保留更改权。这是限制必须保留在脑海中的细节量的另一种方法。</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">除了以 &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; 的形式显示固定类型之外，函数还可以声明类型参数列表以及它们所处的特征范围。</target>
        </trans-unit>
        <trans-unit id="d6b811c43ad4130bc5a6536fe58f23b2b67258a1" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">除了公共和私有之外，Rust允许用户将某项声明为在给定范围内可见。对于规则 &lt;code&gt;pub&lt;/code&gt; 是限制如下：</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">除了&lt;a href=&quot;#implementors&quot;&gt;下面列出&lt;/a&gt;的实现者之外，以下类型还可以实现 &lt;code&gt;Clone&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">除了&lt;a href=&quot;#implementors&quot;&gt;下面列出&lt;/a&gt;的实现者之外，以下类型还实现了 &lt;code&gt;Copy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">除了 &lt;code&gt;#[cfg]&lt;/code&gt; 属性之外，还提供了此宏以允许对配置标志进行布尔表达式评估。这经常导致重复代码更少。</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了按&lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt;返回的已解析&lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt;信息之外， &lt;code&gt;PrefixComponent&lt;/code&gt; 还保存由&lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; &lt;/a&gt;返回的原始和未解析的&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;切片。</target>
        </trans-unit>
        <trans-unit id="5eb0888677903038da8d3a6a5332c2add97dc4d4" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">除了根据其签名而有所不同之外，函数指针还具有两种形式：安全和不安全。普通的 &lt;code&gt;fn()&lt;/code&gt; 函数指针只能指向安全函数，而不 &lt;code&gt;unsafe fn()&lt;/code&gt; 函数指针可以指向安全或不安全函数。</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">此外， &lt;code&gt;unsafe&lt;/code&gt; 并不意味着该块内的代码必然是危险的，或者肯定会存在内存安全问题：目的是，作为程序员，您将确保 &lt;code&gt;unsafe&lt;/code&gt; 块内的代码将以有效方式访问内存。 。</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">此外，&lt;em&gt;任何&lt;/em&gt;签名，ABI或安全性的函数指针都是&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，并且所有&lt;em&gt;安全&lt;/em&gt;函数指针都实现&lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;。之所以可行，是因为这些特性是编译器特有的。</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">另外，这暗示了一种设计选择：Rust永远不会自动创建数据的&amp;ldquo;深层&amp;rdquo;副本。因此，就运行时性能而言，任何&lt;em&gt;自动&lt;/em&gt;复制都可以被认为是廉价的。</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">此外，我们还将介绍&lt;em&gt;内部可变性&lt;/em&gt;模式，其中不可变类型公开了用于改变内部值的API。我们还将讨论&lt;em&gt;参考周期&lt;/em&gt;：它们如何泄漏内存以及如何防止内存泄漏。</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">在第二支臂中 &lt;code&gt;_&lt;/code&gt; 模式表示的所有其他情况下（如果 &lt;code&gt;setting_value&lt;/code&gt; 或 &lt;code&gt;new_setting_value&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ），我们希望允许 &lt;code&gt;new_setting_value&lt;/code&gt; 成为 &lt;code&gt;setting_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">在所有其他情况下,属性会被忽略。</target>
        </trans-unit>
        <trans-unit id="7d8a9a3640946afedd6187bd88567e66ef40d8ba" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, if we want to return the &lt;code&gt;Born&lt;/code&gt; variant from the &lt;code&gt;Dragon&lt;/code&gt; enum, we must set the function to return the enum and not its variant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19757cafa1e47c029cbe2ba1f57c4bdca558327" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the &lt;code&gt;Mordor&lt;/code&gt; module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f29567923fe326970ee49948a1a1d55a18345" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f98ac0f1fa0dec56de41fe3ea37987b03944662" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">在一个侵入式双链路列表中,集合实际上并不为元素本身分配内存。分配是由客户端控制的,元素可以活在一个比集合活得更短的堆栈框架上。</target>
        </trans-unit>
        <trans-unit id="d614cd101c88d0fcc72d7ca1ff622264cb285eeb" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">在更大的程序中，使用嵌套路径将同一包或模块中的许多项目纳入范围可以减少很多单独的 &lt;code&gt;use&lt;/code&gt; 语句！</target>
        </trans-unit>
        <trans-unit id="411e743273ff9b097675015034e11f98bb60f0a1" translate="yes" xml:space="preserve">
          <source>In both cases, we're declaring a variable (called &lt;code&gt;_&lt;/code&gt;) and we're giving it a type. However, &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; and &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; aren't types, therefore the compiler throws an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">在这两个示例中，&amp;ldquo;&amp;szlig;&amp;rdquo;需要两个字节进行编码。</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">在这两个示例中，&amp;ldquo;𝕊&amp;rdquo;需要两个 &lt;code&gt;u16&lt;/code&gt; 进行编码。</target>
        </trans-unit>
        <trans-unit id="3bd0c40bcc38a21de271423b14aaff21406fde9d" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">在匹配器和转录器中， &lt;code&gt;$&lt;/code&gt; 令牌均用于从宏引擎调用特殊行为（以下在&lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt;和&lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions中进行了&lt;/a&gt;描述）。不属于此类调用的令牌将按字面进行匹配和转录，只有一个例外。唯一的例外是匹配器的外部定界符将匹配任何一对定界符。因此，例如，匹配器 &lt;code&gt;(())&lt;/code&gt; 将匹配 &lt;code&gt;{()}&lt;/code&gt; 而不是 &lt;code&gt;{{}}&lt;/code&gt; 。字符 &lt;code&gt;$&lt;/code&gt; 不能字面匹配或转录。</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">在匹配器和转录器中，通过将要重复的令牌放置在 &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; 内，然后是重复运算符（可选地在两者之间使用分隔符）来表示重复。分隔符令牌可以是除定界符或重复运算符之一以外的任何令牌，但 &lt;code&gt;;&lt;/code&gt; 和 &lt;code&gt;,&lt;/code&gt; 是最常见的。例如， &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 表示任意数量的标识符，用逗号分隔。嵌套重复是允许的。</target>
        </trans-unit>
        <trans-unit id="bda412bf4ac443ace6b933eedb9b5ef6ed17c2eb" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;self&lt;/code&gt; is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">如果是 &lt;code&gt;Err&lt;/code&gt; 变体，它将检索内部错误。 &lt;code&gt;try!&lt;/code&gt; 然后使用 &lt;code&gt;From&lt;/code&gt; 进行转换。这样可以在特殊错误和更常见错误之间进行自动转换。然后立即返回产生​​的错误。</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">如果该项是 &lt;code&gt;impl&lt;/code&gt; 内的函数，则定义私有帮助器函数可能会更容易：</target>
        </trans-unit>
        <trans-unit id="e819f47e8194440086ecc95f22e7c6f58bfe9e72" translate="yes" xml:space="preserve">
          <source>In case you want to document the item following the doc comment, you might want to use outer doc comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">如果存在许多嵌套模块，则在使用 &lt;code&gt;pub use&lt;/code&gt; 下在顶层重新导出类型会极大地影响使用板条箱的人员的体验。</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">在某些情况下，Rust没有足够的信息来进行这种转换，称为&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;强制转换。在以下示例中，字符串slice &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt;实现了特征 &lt;code&gt;TraitExample&lt;/code&gt; ，而函数 &lt;code&gt;example_func&lt;/code&gt; 则采用了实现该特征的任何东西。在这种情况下，Rust需要进行两次隐式转换，Rust没有办法进行转换。因此，以下示例将无法编译。</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">在某些情况下,子绑定有可能违反内存安全。在未来版本的Rust中,借贷检查器的更新可能会取消这一限制,但目前必须在没有子绑定的情况下重写模式。</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">相比之下，&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;不会区分获取锁的读取器或写入器，因此会阻塞等待锁可用的所有线程。一个 &lt;code&gt;RwLock&lt;/code&gt; 允许，只要任意数量的读者获取锁作为一个作家不持有锁。</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">总结:在做之前一定要检查你想得到的索引是否真的存在。</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">相反，如果我们将某个枚举公开，则其所有变体都将公开。我们只需要 &lt;code&gt;pub&lt;/code&gt; 在 &lt;code&gt;enum&lt;/code&gt; 关键字之前，如清单7-10所示。</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">相反，Rust中的语句&lt;em&gt;主要&lt;/em&gt;用于包含和显式排序表达式评估。</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">相比之下，清单19-7 中 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 的使用可能在使用slice时崩溃。此代码占用任意内存位置，并创建一个10,000个项目的切片。</target>
        </trans-unit>
        <trans-unit id="b352fcdc1230066708e3119b26e7a9dddf361692" translate="yes" xml:space="preserve">
          <source>In each such case, there are a set of types &lt;code&gt;T0..Tn&lt;/code&gt; to be mutually coerced to some target type &lt;code&gt;T_t&lt;/code&gt;, which is unknown to start. Computing the LUB coercion is done iteratively. The target type &lt;code&gt;T_t&lt;/code&gt; begins as the type &lt;code&gt;T0&lt;/code&gt;. For each new type &lt;code&gt;Ti&lt;/code&gt;, we consider whether</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759bae86a2327a6965c49083e94e3f6d305cc988" translate="yes" xml:space="preserve">
          <source>In either of the two scenarios above, we reject usage of such a constant in a pattern match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">本质上， &lt;code&gt;*const c_void&lt;/code&gt; 等效于C的 &lt;code&gt;const void*&lt;/code&gt; 而 &lt;code&gt;*mut c_void&lt;/code&gt; 等效于C的 &lt;code&gt;void*&lt;/code&gt; 。这就是说，这是&lt;em&gt;不是&lt;/em&gt;同C的 &lt;code&gt;void&lt;/code&gt; 返回类型，这是除锈的 &lt;code&gt;()&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">在函数签名中，&lt;em&gt;必须&lt;/em&gt;声明每个参数的类型。这是Rust设计中的一个故意决定：在函数定义中需要类型注释，这意味着编译器几乎不需要您在代码的其他地方使用它们来弄清楚您的意思。</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">通常，-- &lt;code&gt;--crate-type=bin&lt;/code&gt; 或 &lt;code&gt;--crate-type=lib&lt;/code&gt; 应该足以满足所有编译需求，而如果需要对包装箱的输出格式进行更细粒度的控制，则其他选项才可用。</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">通常，C ++实现遵循零开销原则：您不用的东西，不用花钱。更进一步：您使用的是什么，您再也无法编写更好的代码了。</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">通常，任何可以通过指定类型执行的强制转换也可以使用 &lt;code&gt;as&lt;/code&gt; 来完成，因此，与其编写 &lt;code&gt;let x: u32 = 123&lt;/code&gt; ，还可以将 &lt;code&gt;let x = 123 as u32&lt;/code&gt; 编写为u32（注意： &lt;code&gt;let x: u32 = 123&lt;/code&gt; 可以在这种情况下最好）。在另一个方向上却不是这样，但是，显式地使用 &lt;code&gt;as&lt;/code&gt; 可以允许更多隐式不允许的强制，例如更改原始指针的类型或将闭包转换为原始指针。</target>
        </trans-unit>
        <trans-unit id="3ee5af53911e508508beef41bbd5529b831af173" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however; explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">通常，由于此功能可能会引起恐慌，因此不建议使用该功能。相反，更喜欢使用模式匹配并显式处理&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;情况。</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">一般来说,完全限定语法的定义如下。</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">通常，为了使用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 值，您需要具有可处理每个变体的代码。你想一些代码，当你有一个，将只能运行 &lt;code&gt;Some(T)&lt;/code&gt; 的值，该代码被允许使用内部 &lt;code&gt;T&lt;/code&gt; 。如果您具有 &lt;code&gt;None&lt;/code&gt; 值，并且该代码没有可用的 &lt;code&gt;T&lt;/code&gt; 值，则希望运行其他代码。该 &lt;code&gt;match&lt;/code&gt; 表达式是一个控制流构建体与枚举使用时，不只是这样的：它会因它具有枚举的所述变体运行不同的代码，该代码可以使用匹配值内的数据。</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">一般来说,类型的大小在不同的编译中是不稳定的,但特定的类型,如基元,是稳定的。</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">通常，这本书假定您从前到后依次阅读。后面的章节以前面的章节中的概念为基础，而前面的章节可能不会深入研究某个主题。我们通常会在下一章中重新讨论该主题。</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">总的来说，您不必担心可重用和不可重用模式之间的区别。但是，您确实需要熟悉可引用性的概念，以便在错误消息中看到它时可以做出响应。在这些情况下，您需要根据代码的预期行为来更改模式或使用该模式的构造。</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">在这里， &lt;code&gt;jon_snow&lt;/code&gt; 引用已经借用了 &lt;code&gt;nights_watch&lt;/code&gt; ，因此 &lt;code&gt;starks&lt;/code&gt; 闭包不能同时借用它。要解决此问题，可以在借用结束后创建闭包：</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">在这里， &lt;code&gt;x&lt;/code&gt; 是不可变的，因此当我们尝试以可变方式借入 &lt;code&gt;y&lt;/code&gt; 时，它将失败。要解决此错误，您需要使 &lt;code&gt;x&lt;/code&gt; 可变：</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">在这里， &lt;code&gt;y&lt;/code&gt; 在内部作用域的末尾删除，但是 &lt;code&gt;x&lt;/code&gt; 借用了它，直到 &lt;code&gt;println&lt;/code&gt; 为止。要修复前面的示例，只需删除范围，以便在println之后才删除 &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">Edsger W. Dijkstra在1972年的文章&amp;ldquo;谦虚的程序员&amp;rdquo;中说：&amp;ldquo;程序测试可以是显示错误存在的一种非常有效的方法，但是毫无希望地不足以表明错误的存在。&amp;rdquo; 这并不意味着我们不应该尝试尽可能多地测试！</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">null的发明者Tony Hoare在2009年的演讲&amp;ldquo; Null References：十亿美元的错误&amp;rdquo;中说：</target>
        </trans-unit>
        <trans-unit id="c66d30f8ac627ea5119575fc56779340f4bd49e0" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">在不可变的上下文中，非指针类型上的 &lt;code&gt;*x&lt;/code&gt; 等效于 &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">在其线程中， &lt;code&gt;Worker&lt;/code&gt; 将在其通道的接收方上循环并执行其接收到的所有作业的关闭。</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">在没有标准库提供迭代器的语言中，您可能会编写相同的功能，方法是在索引0处启动变量，使用该变量索引向量以获得值，然后在循环中递增变量值直到达到向量中的项目总数。</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">在带有指针的语言中，很容易错误地创建一个&lt;em&gt;悬空指针&lt;/em&gt;，即通过在保留指向该内存的指针的同时释放一些内存来引用可能已分配给他人的内存中某个位置的指针。相比之下，在Rust中，编译器保证引用永远不会成为悬挂引用：如果您对某些数据有引用，则编译器将确保数据不会超出对数据的引用范围。</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">在许多其他编程语言中，通过按索引引用来访问字符串中的单个字符是有效且常见的操作。但是，如果尝试在Rust中使用索引语法访问 &lt;code&gt;String&lt;/code&gt; 的某些部分，则会收到错误消息。考虑清单8-19中的无效代码。</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">在许多编程语言中，您不必经常考虑堆栈和堆。但是在像Rust这样的系统编程语言中，值是在堆栈上还是在堆上对语言的行为以及为什么必须做出某些决定具有更大的影响。所有权的各个部分将在本章后面的堆栈和堆中进行介绍，因此这里是准备工作的简要说明。</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">在 &lt;code&gt;impl&lt;/code&gt; 块内的方法签名中，引用可能与结构字段中引用的生存期相关，或者它们可能是独立的。此外，生存期省略规则通常使之成为必需，因此在方法签名中不需要生存期批注。让我们看一下使用清单10-25中定义的名为 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 的结构的一些示例。</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">在方法签名中,还有一条规则</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">在更实际的代码中，Rust通常可以在插入值后就推断出要存储的值的类型，因此您几乎不需要执行此类型注释。创建具有初始值的 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 更为常见，而Rust提供了 &lt;code&gt;vec!&lt;/code&gt; 为方便起见。宏将创建一个新向量，其中包含您提供的值。清单8-2创建一个新的 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 保持的值 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，和 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa2c751f0fffe581147bea700ab4a27b2b536a1b" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;. The integer type is &lt;code&gt;i32&lt;/code&gt; because that&amp;rsquo;s the default integer type, as we discussed in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61ae2da01f7f174aa9072fda333fb0da9180ccf" translate="yes" xml:space="preserve">
          <source>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use &lt;code&gt;cfg_attr&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">在大多数情况下，当您不再需要特定的功能参数时，可以更改签名，使其不包括未使用的参数。忽略函数参数在某些情况下尤其有用，例如，当需要特定类型签名但实现中的函数主体不需要参数之一时实现特征时。然后，编译器将不会警告未使用的函数参数，就像使用名称代替一样。</target>
        </trans-unit>
        <trans-unit id="85959f6561074f86f5f458df7e8bde59a19923db" translate="yes" xml:space="preserve">
          <source>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">在大多数情况下,引用的使用可以和原始值一样。字段访问、方法调用和索引的工作方式都是一样的(当然,可变性规则除外)。此外,比较运算符透明地服从于引用的实现,允许引用与拥有的值一样进行比较。</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">在大多数当前的操作系统中，已执行程序的代码在一个&lt;em&gt;进程中&lt;/em&gt;运行，并且操作系统一次管理多个进程。在您的程序中，您还可以具有可以同时运行的独立部分。运行这些独立部分的功能称为&lt;em&gt;线程&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">在大多数情况下，我们会将您引向任何未编译代码的正确版本。</target>
        </trans-unit>
        <trans-unit id="c68d3ee8b930a30d24c024ab8aa0750ac37303d5" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">在可变上下文中，非指针类型上的 &lt;code&gt;*x&lt;/code&gt; 等效于 &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">在一个编译会话中，编译器可以通过使用命令行标志或 &lt;code&gt;crate_type&lt;/code&gt; 属性来生成多个工件。如果指定了一个或多个命令行标志，则将忽略所有 &lt;code&gt;crate_type&lt;/code&gt; 属性，而仅构建命令行指定的构件。</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">在某种程度上，该程序更好。元组让我们增加了一些结构，现在我们只传递一个参数。但是以另一种方式，此版本不太明确：元组未命名其元素，因此我们的计算变得更加混乱，因为我们必须索引元组的各个部分。</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">为了让类型实现这个特点，它不仅要为每个方法提供实现，但必须指定类型 &lt;code&gt;E&lt;/code&gt; 。这是标准库类型 &lt;code&gt;Vec&lt;/code&gt; 的 &lt;code&gt;Container&lt;/code&gt; 的实现：</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">为了创建文件，必须使用&lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="b17e4fe4c4cad25a01268fcf2e26864d2a26e310" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;struct.openoptions#method.write&quot;&gt;&lt;code&gt;OpenOptions::write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.append&quot;&gt;&lt;code&gt;OpenOptions::append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">为了与 Rust 缺乏全局类型推理保持一致,在项目签名中设计不允许使用类型和 const 占位符。</target>
        </trans-unit>
        <trans-unit id="8a65853b278eb7154e9a97a3b9168563f7fe07ac" translate="yes" xml:space="preserve">
          <source>In order to change the requirement from &lt;code&gt;'static&lt;/code&gt; to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime &lt;code&gt;'_&lt;/code&gt; or some appropriate named lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fa624eb80e06baae2665fd37db20bf0778d0e3" translate="yes" xml:space="preserve">
          <source>In order to encode this kind of constraint, a &lt;code&gt;where&lt;/code&gt; clause and a new type parameter are needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9667d5a282ae24dfeac4aaa28cc09c9d5311dfe4" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">为了表示我们希望泛型函数采用所有可以转换为指定类型 &lt;code&gt;T&lt;/code&gt; 的参数，我们可以使用&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 的特征范围。例如：函数 &lt;code&gt;is_hello&lt;/code&gt; 接受所有可以转换为 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">为了解决这个错误,请确认你使用的类型确实实现了这个特性。例子:</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">为了解决此错误，您需要使用 &lt;code&gt;pub&lt;/code&gt; 关键字将项目公开。例：</target>
        </trans-unit>
        <trans-unit id="0f266e5d780b399f0089fa40c8b0e4ea12c652ab" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from &lt;a href=&quot;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&quot;&gt;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&lt;/a&gt; to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7221777f5fa03d42ac87ea82e0b30794fd67a12c" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">为了使通用模式更符合人体工程学，可以在&lt;a href=&quot;types/function-item&quot;&gt;函数项&lt;/a&gt;，&lt;a href=&quot;types/function-pointer&quot;&gt;函数指针&lt;/a&gt;和&lt;a href=&quot;types/closure&quot;&gt;闭包特征&lt;/a&gt;签名中&lt;em&gt;省略&lt;/em&gt;生命周期参数。以下规则用于推断寿命消除的寿命参数。取消无法推断的寿命参数是一个错误。占位符生存期 &lt;code&gt;'_&lt;/code&gt; ，也可以用来以相同的方式推断出生存期。对于路径中的生命周期，首选使用 &lt;code&gt;'_&lt;/code&gt; 。特性对象的生存时间遵循&lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;下面&lt;/a&gt;讨论的不同规则。</target>
        </trans-unit>
        <trans-unit id="8c05c9e0569d955006204f9ccd8d44e873f7454e" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt;, and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d27121a6ebe29fbef52ed61a820dd624d21ff0c" translate="yes" xml:space="preserve">
          <source>In order to match C representation layout &lt;code&gt;repr(C)&lt;/code&gt;, you should call &lt;code&gt;pad_to_align&lt;/code&gt; after extending the layout with all fields. (There is no way to match the default Rust representation layout &lt;code&gt;repr(Rust)&lt;/code&gt;, as it is unspecified.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">为了向您的用户提供组织合理的API，该API易于使用，并且仅显示您的用户所需要的，现在让我们转向Rust的模块。</target>
        </trans-unit>
        <trans-unit id="62f97a59b8d70df8d4c8aedef19af999118a740d" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">换句话说，所有&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;都通过返回自身来实现&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;。这意味着两件事：</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">换句话说，每个&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;行为有点像自旋锁，可以使用 &lt;code&gt;park&lt;/code&gt; 和 &lt;code&gt;unpark&lt;/code&gt; 进行锁定和解锁。</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">换句话说,如果一个零大小的指针可以从一个分配器中流出,那么这个分配器同样必须接受该指针流回它的deallocation和reallocation方法中。</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">换句话说，如果两个键相等，则它们的哈希也必须相等。&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;都依赖此行为。</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">换句话说,如果两个键相等,它们的哈希值一定相等。</target>
        </trans-unit>
        <trans-unit id="651e99e3b0937bfaed54c38e268ae7294b8d7b90" translate="yes" xml:space="preserve">
          <source>In other words, if you tried to explicitly call &lt;code&gt;Drop::drop&lt;/code&gt; in the above example, you'd get a compiler error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">换句话说,它将两个迭代器连接在一起,形成一个链。🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">换句话说，它会自动删除&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;层。如果您的映射已经返回了&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;并且您想跳过&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，那么 &lt;code&gt;filter_map&lt;/code&gt; 会好用得多。</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">换句话说,它将两个迭代器压缩在一起,变成一个。</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">换句话说，删除所有字符 &lt;code&gt;c&lt;/code&gt; ，使 &lt;code&gt;f(c)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。此方法在原位运行，以原始顺序恰好一次访问每个字符，并保留保留字符的顺序。</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">换句话说，删除所有元素 &lt;code&gt;e&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="326bae5baf07932f414f02dbcc5ff71283bf4bd0" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The elements are visited in unsorted (and unspecified) order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">换句话说，删除所有元素 &lt;code&gt;e&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。此方法在原位运行，以原始顺序恰好一次访问每个元素，并保留保留元素的顺序。</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">换句话说，删除所有元素 &lt;code&gt;e&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; 返回false。此方法在原位运行，以原始顺序恰好一次访问每个元素，并保留保留元素的顺序。</target>
        </trans-unit>
        <trans-unit id="f592c733f4a495d9c0b5f64b20924cb17921a1b4" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k, &amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">换句话说，删除所有对 &lt;code&gt;(k, v)&lt;/code&gt; ，以使 &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">换句话说，结果是将 &lt;code&gt;self / rhs&lt;/code&gt; 舍入为整数 &lt;code&gt;n&lt;/code&gt; ,从而使 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; 。如果 &lt;code&gt;self &amp;gt; 0&lt;/code&gt; ，则等于舍入为零（Rust中的默认值）；否则为0。如果 &lt;code&gt;self &amp;lt; 0&lt;/code&gt; ，则等于朝+/-无限取整。</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">换句话说,这里有两个重要的时间点。</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">换句话说，我们告诉Rust，只要在 &lt;code&gt;contents&lt;/code&gt; 参数中传递给 &lt;code&gt;search&lt;/code&gt; 功能的数据有效，则 &lt;code&gt;search&lt;/code&gt; 功能返回的数据将一直存在。这个很重要！引用的数据&lt;em&gt;由&lt;/em&gt;一个切片需要是有效的基准是有效的;如果编译器假设我们要 &lt;code&gt;query&lt;/code&gt; 是字符串而不是 &lt;code&gt;contents&lt;/code&gt; ，则它将不正确地进行安全检查。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">换句话说，您可以将 &lt;code&gt;if let&lt;/code&gt; 视为 &lt;code&gt;match&lt;/code&gt; 语法糖，该匹配在值匹配一个模式然后忽略所有其他值时运行代码。</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">换句话说，必须先将 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 转换为 &lt;code&gt;T&lt;/code&gt; ,然后才能对其执行 &lt;code&gt;T&lt;/code&gt; 操作。通常，这有助于捕获null最常见的问题之一：假设某事物实际上并非为null。</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">换句话说：t&amp;isin;FOLLOW（M）当且仅当存在（可能为空）令牌序列&amp;alpha;，&amp;beta;，&amp;gamma;，&amp;delta;时，其中：</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">但是，在错误的示例中，我们引用的是单个具体类型。因为我们肯定知道 &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; 实现了 &lt;code&gt;Clone&lt;/code&gt; ，所以没有理由在 &lt;code&gt;where&lt;/code&gt; 子句中也指定它。</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">特别是 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; 和 &lt;code&gt;Hash&lt;/code&gt; 必须与借入和拥有的值等效： &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; 的结果应与 &lt;code&gt;x == y&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="75333f3519a07df1c42a5d8eddbdb687099bae84" translate="yes" xml:space="preserve">
          <source>In particular, coercing a function with &lt;code&gt;#[track_caller]&lt;/code&gt; to a function pointer creates a shim which appears to observers to have been called at the attributed function's definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">特别是，如果有人通过给定的分配器 &lt;code&gt;a&lt;/code&gt; 和布局 &lt;code&gt;k&lt;/code&gt; 分配了一个内存块，其中 &lt;code&gt;a.usable_size(k)&lt;/code&gt; 返回 &lt;code&gt;(l, u)&lt;/code&gt; ，则可以将该块传递给大小为 &lt;code&gt;a.dealloc()&lt;/code&gt; 的布局范围[l，u]。</target>
        </trans-unit>
        <trans-unit id="d30439b36bf2c88bac9a70141d7e2e3a34d9cecb" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">特别是,如果你忘记了一个寄存器约束的关闭括号,就会发生这种情况(见问题#51430)。</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">特别是,用于初始化原始条目的哈希仍然必须与最终存储在条目中的键的哈希一致。这是因为HashMap的实现在调整大小时可能需要重新计算哈希值,这时只有键可以使用。</target>
        </trans-unit>
        <trans-unit id="1f0c47f31f9dc083f9c5c01ccece4c74f77d799d" translate="yes" xml:space="preserve">
          <source>In particular, the resulting pointer remains attached to the same allocated object that &lt;code&gt;self&lt;/code&gt; points to. It may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">特别地，在大多数情况下，返回值 &lt;code&gt;r&lt;/code&gt; 满足 &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; 。但是，由于 &lt;code&gt;self&lt;/code&gt; 的幅度远小于 &lt;code&gt;rhs.abs()&lt;/code&gt; ，并且 &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; ，因此由于浮点舍入误差，可能导致 &lt;code&gt;r == rhs.abs()&lt;/code&gt; ，违反了数学定义。此结果不是函数共域的元素，但它是实数中最接近的浮点数，因此 &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; 实现了属性self == self.div_euclid（rhs）* rhs + self.rem_euclid（rhs）。</target>
        </trans-unit>
        <trans-unit id="5ace8c101adbcb8f417784f9525d6b6b04d2023a" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;fold()&lt;/code&gt; on the internal parts from which this iterator is composed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">特别是，尝试在组成此迭代器的内部部件上调用 &lt;code&gt;try_fold()&lt;/code&gt; 。如果需要多个呼叫，则 &lt;code&gt;?&lt;/code&gt; 运算符可能会很方便地将累加器值链接起来，但是要提防在这些早期返回之前需要维护的所有不变式。这是 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 方法，因此在此处遇到错误后，需要重新开始迭代。</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">在极少数情况下，编写紧急代码而不是返回 &lt;code&gt;Result&lt;/code&gt; 更为合适。让我们探讨为什么在示例，原型代码和测试中惊慌失措是适当的。然后，我们将讨论编译器无法告知失败是不可能的，但您却可以做到的情况。本章将以关于如何确定是否在库代码中引起恐慌的一些通用准则作为结尾。</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">简而言之，由于 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; （其中 &lt;code&gt;T&lt;/code&gt; 可以是任何类型）是不同的类型，因此编译器不会让我们使用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 值，就好像它绝对是有效值一样。例如，此代码将无法编译，因为它试图将 &lt;code&gt;i8&lt;/code&gt; 添加到 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">在单线程方案中，这可能在编写信号处理程序或某些类型的低级代码时引起问题。使用&lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;编译器篱笆&lt;/a&gt;来防止这种重新排序。</target>
        </trans-unit>
        <trans-unit id="6eccde4f87031328924ef4f1acaf135f499b7802" translate="yes" xml:space="preserve">
          <source>In some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a &quot;Least Upper Bound&quot; coercion. LUB coercion is used and only used in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">在某些语言中，程序员每次使用智能指针实例完成操作时，都必须调用代码以释放内存或资源。如果他们忘记了，系统可能会变得超载并崩溃。在Rust中，您可以指定每当值超出范围时就运行特定的代码位，编译器将自动插入此代码。结果，您无需在将特定类型的实例完成的程序中的任何地方放置清理代码的时候就很小心-您仍然不会泄漏资源！</target>
        </trans-unit>
        <trans-unit id="37072e6e82bbf9d96cc9281defd328d5ab53bf93" translate="yes" xml:space="preserve">
          <source>In some programming languages, the behavior of string formatting functions depends on the operating system's locale setting. The format functions provided by Rust's standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">在某些情况下，类型的组合可能不明确。在类型周围使用括号可避免歧义。例如，&lt;a href=&quot;types/pointer#shared-references-&quot;&gt;引用类型&lt;/a&gt;内&lt;a href=&quot;trait-bounds&quot;&gt;类型边界&lt;/a&gt;的 &lt;code&gt;+&lt;/code&gt; 运算符不清楚该边界适用于何处，因此需要使用括号。需要消除歧义的语法规则使用&lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt;规则而不是&lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78a25e5b990fcd1740e4efa791bdb025c393c864" translate="yes" xml:space="preserve">
          <source>In some situations, some strings that should create a valid float instead return an error. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;issue #31407&lt;/a&gt; for details.</source>
          <target state="translated">在某些情况下，某些应创建有效浮点数的字符串将返回错误。有关详细信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;问题＃31407&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e28b9cfae095cd08e8afd62032026a0b23bc39f7" translate="yes" xml:space="preserve">
          <source>In statements like &lt;code&gt;let x = 5;&lt;/code&gt; with a variable name in the &lt;code&gt;PATTERN&lt;/code&gt; slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the &lt;code&gt;let x = 5;&lt;/code&gt; example, &lt;code&gt;x&lt;/code&gt; is a pattern that means &amp;ldquo;bind what matches here to the variable &lt;code&gt;x&lt;/code&gt;.&amp;rdquo; Because the name &lt;code&gt;x&lt;/code&gt; is the whole pattern, this pattern effectively means &amp;ldquo;bind everything to the variable &lt;code&gt;x&lt;/code&gt;, whatever the value is.&amp;rdquo;</source>
          <target state="translated">在语句中， &lt;code&gt;let x = 5;&lt;/code&gt; 在 &lt;code&gt;PATTERN&lt;/code&gt; 插槽中有一个变量名，变量名只是模式的一种特别简单的形式。Rust将表达式与模式进行比较，并分配它找到的任何名称。因此， &lt;code&gt;let x = 5;&lt;/code&gt; 例如， &lt;code&gt;x&lt;/code&gt; 是一种模式，表示&amp;ldquo;将此处匹配的内容绑定到变量 &lt;code&gt;x&lt;/code&gt; &amp;rdquo;。因为名称 &lt;code&gt;x&lt;/code&gt; 是整个模式，所以该模式实际上意味着&amp;ldquo;将所有值绑定到变量 &lt;code&gt;x&lt;/code&gt; ，无论值是多少&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ab76c75fb8be2531be195781f70554fa526d2349" translate="yes" xml:space="preserve">
          <source>In such a case, the compiler cannot predict the return type of &lt;code&gt;foo()&lt;/code&gt; in a situation like the following:</source>
          <target state="translated">在这种情况下，编译器无法在以下情况下预测 &lt;code&gt;foo()&lt;/code&gt; 的返回类型：</target>
        </trans-unit>
        <trans-unit id="a84c028b3015af78e467c76bddbf22405a6992e9" translate="yes" xml:space="preserve">
          <source>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</source>
          <target state="translated">总而言之,以下是我们将清单10-2的代码改为清单10-3的步骤。</target>
        </trans-unit>
        <trans-unit id="b66a6766ec59e5aa720a0c750a221736c0a524da" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic memory orderings&lt;/a&gt;, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after &lt;code&gt;join&lt;/code&gt; returns.</source>
          <target state="translated">在&lt;a href=&quot;../sync/atomic/index&quot;&gt;原子内存排序方面&lt;/a&gt;，关联线程的完成与此函数返回同步。换句话说，该线程执行的所有操作在 &lt;code&gt;join&lt;/code&gt; 返回之后发生的所有操作之前被排序。</target>
        </trans-unit>
        <trans-unit id="49ebdf4d886162df5d53e77b9ab0d51282c8c87c" translate="yes" xml:space="preserve">
          <source>In the 2015 edition parameters pattern where not needed for traits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb4dfd79140995a00d7f2f4a091910c0bb3584f" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, &lt;a href=&quot;types/trait-object&quot;&gt;&lt;code&gt;dyn&lt;/code&gt;&lt;/a&gt; is a keyword when used in a type position followed by a path that does not start with &lt;code&gt;::&lt;/code&gt;.</source>
          <target state="translated">在2015版中，&lt;a href=&quot;types/trait-object&quot;&gt; &lt;code&gt;dyn&lt;/code&gt; &lt;/a&gt;在类型位置后跟不是以 &lt;code&gt;::&lt;/code&gt; 开头的路径时是关键字。</target>
        </trans-unit>
        <trans-unit id="e5c533200fa356e0f6f01942ecd077fd12144d48" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, the pattern for a trait function or method parameter is optional:</source>
          <target state="translated">在2015版中,性状函数或方法参数的模式是可选的。</target>
        </trans-unit>
        <trans-unit id="ead217a846b182b1c7c3895bb636fcdc53cf3da8" translate="yes" xml:space="preserve">
          <source>In the 2018 edition, if an in-scope item has the same name as an external crate, then &lt;code&gt;use&lt;/code&gt; of that crate name requires a leading &lt;code&gt;::&lt;/code&gt; to unambiguously select the crate name. This is to retain compatibility with potential future changes.</source>
          <target state="translated">在2018年版中，如果范围内的商品与外部包装箱具有相同的名称，则 &lt;code&gt;use&lt;/code&gt; 该包装箱名称需要使用前导 &lt;code&gt;::&lt;/code&gt; 来明确选择包装箱名称。这是为了保持与将来可能发生的更改的兼容性。</target>
        </trans-unit>
        <trans-unit id="a3999cf3a0362f5c3017eea167e996c61b1004cc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;Unicode Standard&lt;/a&gt;, Chapter 4 (Character Properties) discusses case mapping in general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8c3e671a7bc9e2a3ca26713c444ad82025ac40" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">在&lt;a href=&quot;index&quot;&gt;模块级文档&lt;/a&gt;中，我们实施了一个&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;Counter&lt;/code&gt; 。让我们也为其实现 &lt;code&gt;ExactSizeIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="29a70e5936b8ef90f87c3d79c860b1701d924dbc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module-level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542be6c89aa5ea78dd9931c09f1fa338c6d41b0e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;User&lt;/code&gt; struct definition in Listing 5-1, we used the owned &lt;code&gt;String&lt;/code&gt; type rather than the &lt;code&gt;&amp;amp;str&lt;/code&gt; string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</source>
          <target state="translated">在清单5-1中的 &lt;code&gt;User&lt;/code&gt; struct定义中，我们使用了拥有的 &lt;code&gt;String&lt;/code&gt; 类型而不是 &lt;code&gt;&amp;amp;str&lt;/code&gt; 字符串切片类型。这是一个有意的选择，因为我们希望该结构的实例拥有其所有数据，并且只要整个结构有效，该数据就一直有效。</target>
        </trans-unit>
        <trans-unit id="86f5e9e4af3e5d42db41973d9449d9469f700ef8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ve made the &lt;code&gt;stream&lt;/code&gt; parameter mutable. The reason is that the &lt;code&gt;TcpStream&lt;/code&gt; instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. It therefore needs to be &lt;code&gt;mut&lt;/code&gt; because its internal state might change; usually, we think of &amp;ldquo;reading&amp;rdquo; as not needing mutation, but in this case we need the &lt;code&gt;mut&lt;/code&gt; keyword.</source>
          <target state="translated">在 &lt;code&gt;handle_connection&lt;/code&gt; 函数中，我们使 &lt;code&gt;stream&lt;/code&gt; 参数可变。原因是 &lt;code&gt;TcpStream&lt;/code&gt; 实例跟踪它在内部返回给我们的数据。它读取的数据可能会超过我们的要求，并在下次我们要求数据时保存该数据。因此，它需要 &lt;code&gt;mut&lt;/code&gt; 因为其内部状态可能会改变;通常，我们认为&amp;ldquo;阅读&amp;rdquo;不需要突变，但是在这种情况下，我们需要 &lt;code&gt;mut&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="41e5d381e8adcfa53c11fefa07fcde5916d77703" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.3.14&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.3.14&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.3.14&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.3.14.&amp;rdquo;</source>
          <target state="translated">在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中，标头后的所有内容都是该节的一部分，该节一直持续到另一个节开始。在 &lt;code&gt;[dependencies]&lt;/code&gt; 部分中，您可以告诉Cargo项目所依赖的外部包装箱以及所需的这些包装箱的版本。在这种情况下，我们将使用语义版本说明符 &lt;code&gt;0.3.14&lt;/code&gt; 指定 &lt;code&gt;rand&lt;/code&gt; crate 。 Cargo理解&lt;a href=&quot;http://semver.org&quot;&gt;语义版本控制&lt;/a&gt;（有时称为&lt;em&gt;SemVer&lt;/em&gt;），这是编写版本号的标准。数字 &lt;code&gt;0.3.14&lt;/code&gt; 实际上是 &lt;code&gt;^0.3.14&lt;/code&gt; 简写，表示&amp;ldquo;具有与0.3.14版本兼容的公共API的任何版本。&amp;rdquo;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba414d8766c29269cba8897672efd77d70e901b9" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.5.5.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7177f5dba94e8e93990faf2d2454fb646d49847" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s add an &lt;code&gt;add_one&lt;/code&gt; function:</source>
          <target state="translated">在&lt;em&gt;add-one / src / lib.rs&lt;/em&gt;文件中，我们添加一个 &lt;code&gt;add_one&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="3da0b39e8b4dc5e8ab87b83cc0f936c2b1215ca7" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;T&lt;/code&gt; is unknowable by the compiler. To fix this you must bind &lt;code&gt;T&lt;/code&gt; to a concrete type such as &lt;code&gt;String&lt;/code&gt; so that a generator can then be constructed:</source>
          <target state="translated">在上面的示例中，编译器无法知道 &lt;code&gt;T&lt;/code&gt; 。要解决此问题，您必须将 &lt;code&gt;T&lt;/code&gt; 绑定到具体类型（例如 &lt;code&gt;String&lt;/code&gt; ),以便可以构造生成器：</target>
        </trans-unit>
        <trans-unit id="dac108bef6e0aa0c5a3c87c1e1dd002eec20cb12" translate="yes" xml:space="preserve">
          <source>In the absolute path, we start with &lt;code&gt;crate&lt;/code&gt;, the root of our crate&amp;rsquo;s module tree. Then the &lt;code&gt;front_of_house&lt;/code&gt; module is defined in the crate root. The &lt;code&gt;front_of_house&lt;/code&gt; module isn&amp;rsquo;t public, but because the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is defined in the same module as &lt;code&gt;front_of_house&lt;/code&gt; (that is, &lt;code&gt;eat_at_restaurant&lt;/code&gt; and &lt;code&gt;front_of_house&lt;/code&gt; are siblings), we can refer to &lt;code&gt;front_of_house&lt;/code&gt; from &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Next is the &lt;code&gt;hosting&lt;/code&gt; module marked with &lt;code&gt;pub&lt;/code&gt;. We can access the parent module of &lt;code&gt;hosting&lt;/code&gt;, so we can access &lt;code&gt;hosting&lt;/code&gt;. Finally, the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is marked with &lt;code&gt;pub&lt;/code&gt; and we can access its parent module, so this function call works!</source>
          <target state="translated">在绝对路径中，我们从 &lt;code&gt;crate&lt;/code&gt; 开始，这是crate的模块树的根。然后在 &lt;code&gt;front_of_house&lt;/code&gt; 中定义front_of_house模块。该 &lt;code&gt;front_of_house&lt;/code&gt; 模块是不公开的，但由于 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 功能是一样的模块定义 &lt;code&gt;front_of_house&lt;/code&gt; （即 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 和 &lt;code&gt;front_of_house&lt;/code&gt; 是兄弟），大家可以参考 &lt;code&gt;front_of_house&lt;/code&gt; 从 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。接下来是标有 &lt;code&gt;pub&lt;/code&gt; 的 &lt;code&gt;hosting&lt;/code&gt; 模块。我们可以访问 &lt;code&gt;hosting&lt;/code&gt; 的父模块，因此我们可以访问 &lt;code&gt;hosting&lt;/code&gt; 。最后，将 &lt;code&gt;add_to_waitlist&lt;/code&gt; 函数标记为 &lt;code&gt;pub&lt;/code&gt; ，我们可以访问其父模块，因此此函数调用有效！</target>
        </trans-unit>
        <trans-unit id="e8a74d26ff6bb6812e6769b94696470ac83d32c8" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;largest&lt;/code&gt; we wanted to compare two values of type &lt;code&gt;T&lt;/code&gt; using the greater than (&lt;code&gt;&amp;gt;&lt;/code&gt;) operator. Because that operator is defined as a default method on the standard library trait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, we need to specify &lt;code&gt;PartialOrd&lt;/code&gt; in the trait bounds for &lt;code&gt;T&lt;/code&gt; so the &lt;code&gt;largest&lt;/code&gt; function can work on slices of any type that we can compare. We don&amp;rsquo;t need to bring &lt;code&gt;PartialOrd&lt;/code&gt; into scope because it&amp;rsquo;s in the prelude. Change the signature of &lt;code&gt;largest&lt;/code&gt; to look like this:</source>
          <target state="translated">在 &lt;code&gt;largest&lt;/code&gt; 的正文中，我们想使用大于（ &lt;code&gt;&amp;gt;&lt;/code&gt; ）运算符比较两个类型 &lt;code&gt;T&lt;/code&gt; 的值。因为该运算符被定义为标准库特征 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; 的默认方法，所以我们需要在 &lt;code&gt;T&lt;/code&gt; 的特征范围中指定 &lt;code&gt;PartialOrd&lt;/code&gt; ，以便 &lt;code&gt;largest&lt;/code&gt; 函数可以作用于我们可以比较的任何类型的切片。我们不需要把 &lt;code&gt;PartialOrd&lt;/code&gt; 纳入范围，因为它处于序幕中。更改 &lt;code&gt;largest&lt;/code&gt; 的签名，如下所示：</target>
        </trans-unit>
        <trans-unit id="9eeb876353faccbcba2ce19feeb7d0dafe4faead" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we call &lt;code&gt;into_iter&lt;/code&gt; to create an iterator that takes ownership of the vector. Then we call &lt;code&gt;filter&lt;/code&gt; to adapt that iterator into a new iterator that only contains elements for which the closure returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;shoes_in_my_size&lt;/code&gt; 的主体中，我们调用 &lt;code&gt;into_iter&lt;/code&gt; 创建一个迭代器，该迭代器获取向量的所有权。然后，我们调用 &lt;code&gt;filter&lt;/code&gt; 使该迭代器适应新的迭代器，该迭代器仅包含闭包为其返回 &lt;code&gt;true&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="ccc28c109f469220d7a0f86ba3d92af7a489d690" translate="yes" xml:space="preserve">
          <source>In the body of a generic function, methods from &lt;code&gt;Trait&lt;/code&gt; can be called on &lt;code&gt;Ty&lt;/code&gt; values. Likewise associated constants on the &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">在泛型函数的主体中，可以对 &lt;code&gt;Ty&lt;/code&gt; 值调用 &lt;code&gt;Trait&lt;/code&gt; 中的方法。同样，可以使用 &lt;code&gt;Trait&lt;/code&gt; 上的关联常量。</target>
        </trans-unit>
        <trans-unit id="ed9b56a6d3a5e9ebb3e76d9359071c31eee0aecc" translate="yes" xml:space="preserve">
          <source>In the case a &lt;code&gt;loop&lt;/code&gt; has an associated &lt;code&gt;break&lt;/code&gt;, it is not considered diverging, and the &lt;code&gt;loop&lt;/code&gt; must have a type compatible with each &lt;code&gt;break&lt;/code&gt; expression. &lt;code&gt;break&lt;/code&gt; without an expression is considered identical to &lt;code&gt;break&lt;/code&gt; with expression &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;loop&lt;/code&gt; 具有关联的 &lt;code&gt;break&lt;/code&gt; ，则不认为它是发散的，并且 &lt;code&gt;loop&lt;/code&gt; 必须具有与每个 &lt;code&gt;break&lt;/code&gt; 表达式兼容的类型。没有表达式的 &lt;code&gt;break&lt;/code&gt; 被认为与带有表达式 &lt;code&gt;()&lt;/code&gt; 的 &lt;code&gt;break&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="5e9ac885fce76186450b96a37f179bf757255fd6" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;, the scope for the block and the expression are the same scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fe262eb9d9754ab04dac149861a78ef7f9cbdf" translate="yes" xml:space="preserve">
          <source>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&amp;rsquo;s immutability. Unfortunately, we can&amp;rsquo;t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.</source>
          <target state="translated">对于字符串文字，我们在编译时就知道内容，因此文本直接硬编码到最终的可执行文件中。这就是为什么字符串文字快速高效的原因。但是这些属性仅来自字符串文字的不变性。不幸的是，对于在编译时大小未知并且运行程序时大小可能会改变的每段文本，我们无法在二进制文件中放入一滴内存。</target>
        </trans-unit>
        <trans-unit id="174ee51902d80b0fa89335cd9be3f224ff39dd4c" translate="yes" xml:space="preserve">
          <source>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</source>
          <target state="translated">在隐式包装溢出的情况下,实现必须通过使用两个的补码溢出惯例来提供定义明确的(即使仍然被认为是错误的)结果。</target>
        </trans-unit>
        <trans-unit id="ad072c8ebb70bdab55dbb950bf9d58e7b04bb9e3" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;File::open&lt;/code&gt; succeeds, the value in the variable &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Ok&lt;/code&gt; that contains a file handle. In the case where it fails, the value in &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Err&lt;/code&gt; that contains more information about the kind of error that happened.</source>
          <target state="translated">如果 &lt;code&gt;File::open&lt;/code&gt; 成功，则变量 &lt;code&gt;f&lt;/code&gt; 中的值将是 &lt;code&gt;Ok&lt;/code&gt; 的实例，其中包含文件句柄。在失败的情况下， &lt;code&gt;f&lt;/code&gt; 中的值将是 &lt;code&gt;Err&lt;/code&gt; 的实例，其中包含有关发生的错误类型的更多信息。</target>
        </trans-unit>
        <trans-unit id="98ff22c3c9a8db90c4e7212603caadebf4d948d5" translate="yes" xml:space="preserve">
          <source>In the code above, the function is returning data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, but the &lt;code&gt;'a&lt;/code&gt; annotation indicates that it is returning data only from &lt;code&gt;x&lt;/code&gt;. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&amp;amp;'a i32&lt;/code&gt;, like so:</source>
          <target state="translated">在上面的代码中，该函数正在返回从 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 借来的数据，但是 &lt;code&gt;'a&lt;/code&gt; 批注表明它仅从 &lt;code&gt;x&lt;/code&gt; 返回数据。要纠正错误，必须使签名和正文匹配。通常，这是通过更新功能签名来完成的。因此，在这种情况下，我们将 &lt;code&gt;y&lt;/code&gt; 的类型更改为 &lt;code&gt;&amp;amp;'a i32&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="47d276ce9763d36114b6391e5e3702972a6d1fd2" translate="yes" xml:space="preserve">
          <source>In the context of Listing 9-7, the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;File::open&lt;/code&gt; call will return the value inside an &lt;code&gt;Ok&lt;/code&gt; to the variable &lt;code&gt;f&lt;/code&gt;. If an error occurs, the &lt;code&gt;?&lt;/code&gt; operator will return early out of the whole function and give any &lt;code&gt;Err&lt;/code&gt; value to the calling code. The same thing applies to the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call.</source>
          <target state="translated">在清单9-7的上下文中， &lt;code&gt;?&lt;/code&gt; 在 &lt;code&gt;File::open&lt;/code&gt; 调用的末尾，会将 &lt;code&gt;Ok&lt;/code&gt; 内的值返回给变量 &lt;code&gt;f&lt;/code&gt; 。如果发生错误，则 &lt;code&gt;?&lt;/code&gt; 运算符将在整个函数中尽早返回并为调用代码提供任何 &lt;code&gt;Err&lt;/code&gt; 值。同样的事情适用于 &lt;code&gt;?&lt;/code&gt; 在 &lt;code&gt;read_to_string&lt;/code&gt; 调用的末尾。</target>
        </trans-unit>
        <trans-unit id="c49979de4803e07d7682a6dac88ad65cf9bdcef3" translate="yes" xml:space="preserve">
          <source>In the end, this means that you may need to pair &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; with some sort of &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::sync&lt;/code&gt;&lt;/a&gt; type, usually &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最后，这意味着您可能需要将 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 与某种&lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::sync&lt;/code&gt; &lt;/a&gt;类型配对，通常是&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a1b716ed41677dd2be556cd6b10193bd9fd8fb5" translate="yes" xml:space="preserve">
          <source>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</source>
          <target state="translated">在上面的错误代码例子中,提供了错误的名称,所以改成正确的名称就可以解决这个错误。例子。</target>
        </trans-unit>
        <trans-unit id="a13ba9220a713242d839758de54b6d6a213f5d7c" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;closure&lt;/code&gt; is an &lt;code&gt;FnOnce&lt;/code&gt; closure whereas the &lt;code&gt;bar&lt;/code&gt; function expected an &lt;code&gt;Fn&lt;/code&gt; closure. In this case, it's simple to fix the issue, you just have to implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; traits on &lt;code&gt;struct X&lt;/code&gt; and it'll be ok:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;closure&lt;/code&gt; 为 &lt;code&gt;FnOnce&lt;/code&gt; 闭包，而 &lt;code&gt;bar&lt;/code&gt; 函数期望为 &lt;code&gt;Fn&lt;/code&gt; 闭包。在这种情况下，解决问题很简单，您只需要在 &lt;code&gt;struct X&lt;/code&gt; 上实现 &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Clone&lt;/code&gt; 特征即可，这可以：</target>
        </trans-unit>
        <trans-unit id="0a2556b76fed59d4f25e18f6058b48758d96fe76" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;name&lt;/code&gt; is moved out of &lt;code&gt;person&lt;/code&gt;, trying to use &lt;code&gt;person&lt;/code&gt; as a whole or &lt;code&gt;person.name&lt;/code&gt; would result in an error because of &lt;em&gt;partial move&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e63cece27f012d6cb0c3b410a4800e38cdde84" translate="yes" xml:space="preserve">
          <source>In the example below, we implement a &lt;code&gt;Point&lt;/code&gt; type. Because it only stores two integers, we opt-out of ownership semantics with &lt;code&gt;Copy&lt;/code&gt;. Then we can &lt;code&gt;let p2 = p1&lt;/code&gt; without &lt;code&gt;p1&lt;/code&gt; being moved.</source>
          <target state="translated">在下面的示例中，我们实现了 &lt;code&gt;Point&lt;/code&gt; 类型。因为它只存储两个整数，所以我们选择使用 &lt;code&gt;Copy&lt;/code&gt; 退出所有权语义。然后我们可以 &lt;code&gt;let p2 = p1&lt;/code&gt; 而不移动 &lt;code&gt;p1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1f21adbe43e342921b2cfef575b2b17bbbed822" translate="yes" xml:space="preserve">
          <source>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce7e71b1b63c6637f941a4911789744e653ecbd" translate="yes" xml:space="preserve">
          <source>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">在第一种情况下，推断出输出寿命与唯一输入寿命相同。在第二种情况下，生存期被推断为 &lt;code&gt;&amp;amp;self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 上的生存期相同。</target>
        </trans-unit>
        <trans-unit id="3fd5720ef4de3e0fbc4e279820c08cbec7f12fa8" translate="yes" xml:space="preserve">
          <source>In the first code example, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874b3aefadd7a8d78fd78ecf2f3f7b20564e4f86" translate="yes" xml:space="preserve">
          <source>In the first example, the lowercased string is represented &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (the last character is an acute accent &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining character&lt;/a&gt;). Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt;. In the second example, the lowercased string is represented &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (the last character is a single Unicode character representing an 'e' with an acute accent). Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt;.</source>
          <target state="translated">在第一个示例中，小写的字符串表示为 &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; （最后一个字符是尖音&lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;组合字符&lt;/a&gt;）。与字符串中的其他字符不同，合并字符不会映射到大写变体，从而导致 &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt; 。在第二个示例中，小写的字符串表示为 &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; （最后一个字符是单个Unicode字符，表示带有重音符的&amp;ldquo; e&amp;rdquo;）。由于最后一个字符是在ASCII范围之外定义的，因此不会将其映射为大写变体，从而导致 &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e492b1a4744d12effe76c9a0dc29e53bf345ccf" translate="yes" xml:space="preserve">
          <source>In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the &lt;code&gt;&amp;amp;&lt;/code&gt; operator can't be applied to the value's fields. For example, the following is not valid:</source>
          <target state="translated">在第一个匹配表达式中，将值复制（或移动）。在第二个匹配中，对相同存储位置的引用绑定到变量值。之所以需要这种语法，是因为在分解子模式时， &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符不能应用于值的字段。例如，以下无效：</target>
        </trans-unit>
        <trans-unit id="963b4be1c96ed23abf1f14a5ca37f0831c8c64ef" translate="yes" xml:space="preserve">
          <source>In the following example, we make the &lt;code&gt;call_from_c&lt;/code&gt; function accessible from C code, after it&amp;rsquo;s compiled to a shared library and linked from C:</source>
          <target state="translated">在以下示例中，在将 &lt;code&gt;call_from_c&lt;/code&gt; 函数编译到共享库并从C链接之后，我们使C语言可以访问call_from_c函数：</target>
        </trans-unit>
        <trans-unit id="ab9b978885ac92b130a921c64c6e0cb297ec938c" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068c8963b2ca078d181d2b0a51e8af10dd52ecbb" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbd16055f21eb6fdaf455bf26541bd9198ef8ac" translate="yes" xml:space="preserve">
          <source>In the implementation of &lt;code&gt;outline_print&lt;/code&gt;, we want to use the &lt;code&gt;Display&lt;/code&gt; trait&amp;rsquo;s functionality. Therefore, we need to specify that the &lt;code&gt;OutlinePrint&lt;/code&gt; trait will work only for types that also implement &lt;code&gt;Display&lt;/code&gt; and provide the functionality that &lt;code&gt;OutlinePrint&lt;/code&gt; needs. We can do that in the trait definition by specifying &lt;code&gt;OutlinePrint: Display&lt;/code&gt;. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the &lt;code&gt;OutlinePrint&lt;/code&gt; trait.</source>
          <target state="translated">在执行 &lt;code&gt;outline_print&lt;/code&gt; 的过程中，我们要使用 &lt;code&gt;Display&lt;/code&gt; trait的功能。因此，我们需要指定 &lt;code&gt;OutlinePrint&lt;/code&gt; 特征仅适用于还实现 &lt;code&gt;Display&lt;/code&gt; 并提供 &lt;code&gt;OutlinePrint&lt;/code&gt; 所需功能的类型。我们可以通过指定 &lt;code&gt;OutlinePrint: Display&lt;/code&gt; 在特征定义中做到这一点。此技术类似于添加绑定到该特性的特性。清单19-22显示了 &lt;code&gt;OutlinePrint&lt;/code&gt; 特征的实现。</target>
        </trans-unit>
        <trans-unit id="81a422714f2fa87b38ce332890d1f64c8678f1a7" translate="yes" xml:space="preserve">
          <source>In the last arm, where we&amp;rsquo;ve specified a variable without a range, we do have the value available to use in the arm&amp;rsquo;s code in a variable named &lt;code&gt;id&lt;/code&gt;. The reason is that we&amp;rsquo;ve used the struct field shorthand syntax. But we haven&amp;rsquo;t applied any test to the value in the &lt;code&gt;id&lt;/code&gt; field in this arm, as we did with the first two arms: any value would match this pattern.</source>
          <target state="translated">在最后一个分支中，我们指定了一个不带范围的变量，我们确实在一个名为 &lt;code&gt;id&lt;/code&gt; 的变量中具有可用于分支代码中的值。原因是我们使用了struct字段的简写语法。但是，我们没有像前两个手臂那样对此分支的 &lt;code&gt;id&lt;/code&gt; 字段中的值进行任何测试：任何值都将与此模式匹配。</target>
        </trans-unit>
        <trans-unit id="8a42fbeac9d5cd28add8db6a4c34d47e67684d80" translate="yes" xml:space="preserve">
          <source>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call &lt;code&gt;join&lt;/code&gt; on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</source>
          <target state="translated">在主线程中，我们收集所有联接句柄。然后，如清单16-2所示，我们在每个句柄上调用 &lt;code&gt;join&lt;/code&gt; 以确保所有线程完成。此时，主线程将获取该锁并打印该程序的结果。</target>
        </trans-unit>
        <trans-unit id="04da7f268aa71a2c6ae0063d0f79d0cc060f8123" translate="yes" xml:space="preserve">
          <source>In the main thread, we&amp;rsquo;re not calling the &lt;code&gt;recv&lt;/code&gt; function explicitly anymore: instead, we&amp;rsquo;re treating &lt;code&gt;rx&lt;/code&gt; as an iterator. For each value received, we&amp;rsquo;re printing it. When the channel is closed, iteration will end.</source>
          <target state="translated">在主线程中，我们不再显式调用 &lt;code&gt;recv&lt;/code&gt; 函数：相反，我们将 &lt;code&gt;rx&lt;/code&gt; 视为迭代器。对于收到的每个值，我们都在打印它。当通道关闭时，迭代将结束。</target>
        </trans-unit>
        <trans-unit id="6a6bd022f18026c156e26cea87623c8cec496bfa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn&amp;rsquo;t be cleaned up unless it doesn&amp;rsquo;t have any edges pointing to it.</source>
          <target state="translated">在大多数情况下，所有权很明确：您确切知道哪个变量拥有给定值。但是，在某些情况下，单个值可能具有多个所有者。例如，在图形数据结构中，多个边可能指向同一个节点，并且从概念上讲，该节点归指向该节点的所有边所有。除非没有任何指向它的边缘，否则不应该清除该节点。</target>
        </trans-unit>
        <trans-unit id="b4fe9ca25f444c9952c260922e7715e70a50aab9" translate="yes" xml:space="preserve">
          <source>In the match expression for this code, we add a variable called &lt;code&gt;state&lt;/code&gt; to the pattern that matches values of the variant &lt;code&gt;Coin::Quarter&lt;/code&gt;. When a &lt;code&gt;Coin::Quarter&lt;/code&gt; matches, the &lt;code&gt;state&lt;/code&gt; variable will bind to the value of that quarter&amp;rsquo;s state. Then we can use &lt;code&gt;state&lt;/code&gt; in the code for that arm, like so:</source>
          <target state="translated">在此代码的match表达式中，我们向模式添加一个名为 &lt;code&gt;state&lt;/code&gt; 的变量，以匹配变体 &lt;code&gt;Coin::Quarter&lt;/code&gt; 。当 &lt;code&gt;Coin::Quarter&lt;/code&gt; 匹配时， &lt;code&gt;state&lt;/code&gt; 变量将绑定到该季度状态的值。然后，我们可以在代码中为该支路使用 &lt;code&gt;state&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="37676c5799bfd02feed7afe648d55c20c391e411" translate="yes" xml:space="preserve">
          <source>In the matcher, &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;&lt;code&gt;:&lt;/code&gt;&lt;em&gt;fragment-specifier&lt;/em&gt; matches a Rust syntax fragment of the kind specified and binds it to the metavariable &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;. Valid fragment specifiers are:</source>
          <target state="translated">在匹配器中， &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name &lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;fragment-specifier&lt;/em&gt;匹配&lt;em&gt;指定类型&lt;/em&gt;的Rust语法片段，并将其绑定到元变量 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt;。有效的片段说明符是：</target>
        </trans-unit>
        <trans-unit id="963b3e8473b4ab06c6410ca4e20e74e946590848" translate="yes" xml:space="preserve">
          <source>In the next chapter, we&amp;rsquo;ll look at some collection data structures in the standard library that you can use in your neatly organized code.</source>
          <target state="translated">在下一章中，我们将研究标准库中的一些集合数据结构，您可以在整洁的代码中使用它们。</target>
        </trans-unit>
        <trans-unit id="62f755e3daa908e0af290719bd4bb3bcad378eef" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 12 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">在清单9-2的输出中，回溯的第12行指向导致问题的项目中的行：&lt;em&gt;src / main.rs的&lt;/em&gt;第4行。如果我们不希望我们的程序崩溃，那么第一行提到我们编写的文件所指向的位置就是我们应该开始调查的地方。在清单9-1中，我们故意编写了会恐慌的代码以演示如何使用回溯，解决恐慌的方法是不从仅包含3个项的向量中请求索引99的元素。将来当您的代码出现紧急情况时，您需要弄清楚该代码正在采取什么措施以及导致该紧急情况的值以及应该执行的操作。</target>
        </trans-unit>
        <trans-unit id="c97b14b94a5006f9b4ef147bf12f463db5d6141e" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 17 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1955a5e30929ce37102fab2f4935897b292825" translate="yes" xml:space="preserve">
          <source>In the previous section, we looked at how the &lt;code&gt;IpAddr&lt;/code&gt; enum let us use Rust&amp;rsquo;s type system to encode more information than just the data into our program. This section explores a case study of &lt;code&gt;Option&lt;/code&gt;, which is another enum defined by the standard library. The &lt;code&gt;Option&lt;/code&gt; type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing. Expressing this concept in terms of the type system means the compiler can check whether you&amp;rsquo;ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</source>
          <target state="translated">在上一节中，我们研究了 &lt;code&gt;IpAddr&lt;/code&gt; 枚举如何使我们使用Rust的类型系统来编码更多信息，而不仅仅是将数据编码到程序中。本节探讨 &lt;code&gt;Option&lt;/code&gt; 的案例研究，Option是标准库定义的另一个枚举。该 &lt;code&gt;Option&lt;/code&gt; 类型在很多地方使用，因为它编码中的值可能会是很常见的情况，也可能什么都不是。用类型系统来表达这个概念意味着编译器可以检查您是否已经处理了所有您应该处理的情况。此功能可以防止其他编程语言中极为常见的错误。</target>
        </trans-unit>
        <trans-unit id="7166e371e82ca092dfca006916f5e7d27ed3dcc0" translate="yes" xml:space="preserve">
          <source>In the previous section, we wanted to get the inner &lt;code&gt;T&lt;/code&gt; value out of the &lt;code&gt;Some&lt;/code&gt; case when using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;; we can also handle &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;match&lt;/code&gt; as we did with the &lt;code&gt;Coin&lt;/code&gt; enum! Instead of comparing coins, we&amp;rsquo;ll compare the variants of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, but the way that the &lt;code&gt;match&lt;/code&gt; expression works remains the same.</source>
          <target state="translated">在上一节中，我们希望使用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 时从 &lt;code&gt;Some&lt;/code&gt; case中获得内部 &lt;code&gt;T&lt;/code&gt; 值；我们也可以像使用 &lt;code&gt;Coin&lt;/code&gt; 枚举一样使用 &lt;code&gt;match&lt;/code&gt; 处理 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ！除了比较硬币以外，我们将比较 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 的变体，但是 &lt;code&gt;match&lt;/code&gt; 表达式的工作方式保持不变。</target>
        </trans-unit>
        <trans-unit id="021531d5da5d15cfe5b7187998d391941c64c620" translate="yes" xml:space="preserve">
          <source>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from &lt;code&gt;front_of_house&lt;/code&gt;. The &lt;code&gt;front_of_house&lt;/code&gt; module is defined within the same module as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, so the relative path starting from the module in which &lt;code&gt;eat_at_restaurant&lt;/code&gt; is defined works. Then, because &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;add_to_waitlist&lt;/code&gt; are marked with &lt;code&gt;pub&lt;/code&gt;, the rest of the path works, and this function call is valid!</source>
          <target state="translated">在相对路径中，除了第一步外，逻辑与绝对路径相同：路径不是从板条箱根开始， &lt;code&gt;front_of_house&lt;/code&gt; 从front_of_house开始。所述 &lt;code&gt;front_of_house&lt;/code&gt; 模块相同的模块中定义的 &lt;code&gt;eat_at_restaurant&lt;/code&gt; ，所以相对的路径从该模块开始 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 定义作品。然后，因为 &lt;code&gt;hosting&lt;/code&gt; 和 &lt;code&gt;add_to_waitlist&lt;/code&gt; 都标有 &lt;code&gt;pub&lt;/code&gt; ，路径工程的其余部分，而这个函数调用是有效的！</target>
        </trans-unit>
        <trans-unit id="34eddaeb0b0b8fe0265b13cd54b792a68e5d0a8d" translate="yes" xml:space="preserve">
          <source>In the restaurant industry, some parts of a restaurant are referred to as &lt;em&gt;front of house&lt;/em&gt; and others as &lt;em&gt;back of house&lt;/em&gt;. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.</source>
          <target state="translated">在餐饮业中，餐厅的某些部分称为&lt;em&gt;房屋前部，&lt;/em&gt;而其他部分称为&lt;em&gt;房屋后部&lt;/em&gt;。屋前就是顾客的所在。主机在这里招待客户，服务器在接受订单和付款，调酒师在这里喝酒。屋后是厨师在厨房工作，洗碗碟机，经理进行行政工作的地方。</target>
        </trans-unit>
        <trans-unit id="d2fbd57442ab7172a121e226a86228020af2eb14" translate="yes" xml:space="preserve">
          <source>In the second &lt;code&gt;use&lt;/code&gt; statement, we chose the new name &lt;code&gt;IoResult&lt;/code&gt; for the &lt;code&gt;std::io::Result&lt;/code&gt; type, which won&amp;rsquo;t conflict with the &lt;code&gt;Result&lt;/code&gt; from &lt;code&gt;std::fmt&lt;/code&gt; that we&amp;rsquo;ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!</source>
          <target state="translated">在第二个 &lt;code&gt;use&lt;/code&gt; 的语句，我们选择了新名称 &lt;code&gt;IoResult&lt;/code&gt; 为 &lt;code&gt;std::io::Result&lt;/code&gt; 类型，将与不冲突 &lt;code&gt;Result&lt;/code&gt; 从 &lt;code&gt;std::fmt&lt;/code&gt; ，我们也已经纳入范围。清单7-15和清单7-16被认为是惯用的，因此选择取决于您！</target>
        </trans-unit>
        <trans-unit id="adc1d9d12c1d2bddf332118061c6c7cd3ce7bb85" translate="yes" xml:space="preserve">
          <source>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&amp;rsquo;t have a variable that contains the actual value of the &lt;code&gt;id&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; field&amp;rsquo;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&amp;rsquo;t know which it is. The pattern code isn&amp;rsquo;t able to use the value from the &lt;code&gt;id&lt;/code&gt; field, because we haven&amp;rsquo;t saved the &lt;code&gt;id&lt;/code&gt; value in a variable.</source>
          <target state="translated">在第二个分支中，我们只有模式中指定的范围，与该分支关联的代码没有包含 &lt;code&gt;id&lt;/code&gt; 字段实际值的变量。该 &lt;code&gt;id&lt;/code&gt; 字段的值可能是10，11或12，但与该模式而来的代码不知道它是。模式代码无法使用 &lt;code&gt;id&lt;/code&gt; 字段中的值，因为我们尚未将 &lt;code&gt;id&lt;/code&gt; 值保存在变量中。</target>
        </trans-unit>
        <trans-unit id="555ee2d5bf80e581edd3155ac1632a3804b80f34" translate="yes" xml:space="preserve">
          <source>In the second case, it mentions that a private item &quot;can be accessed&quot; by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</source>
          <target state="translated">在第二种情况下,它提到一个私有项目 &quot;可以被当前的模块及其后代访问&quot;,但访问一个项目的确切含义取决于该项目是什么。例如,访问一个模块,就意味着在它的内部寻找(导入更多的项目)。另一方面,访问一个函数将意味着它被调用。此外,路径表达式和导入语句被认为是访问一个项目,因为导入/表达式只有在目标在当前可见范围内才有效。</target>
        </trans-unit>
        <trans-unit id="16e34afb2acb9f1c8b1247e4ecd62d975388d5ff" translate="yes" xml:space="preserve">
          <source>In the second error, we tried to bind the &lt;code&gt;Jak&lt;/code&gt; enum directly, which is not possible: you can only bind one of its variants. To do so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75974ca9e444bb30cc1d72502f982a23696566b5" translate="yes" xml:space="preserve">
          <source>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e1b0f0f7f1d23b0a9789a638c11ce7f83e6698" translate="yes" xml:space="preserve">
          <source>In the second you can do it by simply removing &lt;code&gt;'b&lt;/code&gt; so they both use &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde08af4b5bbaaf0718281f4cc2fdcf3ef098583" translate="yes" xml:space="preserve">
          <source>In the signature for &lt;code&gt;area&lt;/code&gt;, we use &lt;code&gt;&amp;amp;self&lt;/code&gt; instead of &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; because Rust knows the type of &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Rectangle&lt;/code&gt; due to this method&amp;rsquo;s being inside the &lt;code&gt;impl Rectangle&lt;/code&gt; context. Note that we still need to use the &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt;, just as we did in &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt;. Methods can take ownership of &lt;code&gt;self&lt;/code&gt;, borrow &lt;code&gt;self&lt;/code&gt; immutably as we&amp;rsquo;ve done here, or borrow &lt;code&gt;self&lt;/code&gt; mutably, just as they can any other parameter.</source>
          <target state="translated">在 &lt;code&gt;area&lt;/code&gt; 的签名中，我们使用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 而不是 &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; 因为Rust知道 &lt;code&gt;self&lt;/code&gt; 的类型是 &lt;code&gt;Rectangle&lt;/code&gt; ,因为该方法位于 &lt;code&gt;impl Rectangle&lt;/code&gt; 上下文中。需要注意的是，我们仍然需要使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 之前 &lt;code&gt;self&lt;/code&gt; ，就像我们在做 &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; 。方法可以取得 &lt;code&gt;self&lt;/code&gt; 所有权，像我们在这里所做的那样，不可变地借用 &lt;code&gt;self&lt;/code&gt; ，或者可变地借用 &lt;code&gt;self&lt;/code&gt; ，就像它们可以使用任何其他参数一样。</target>
        </trans-unit>
        <trans-unit id="15bf74e663ebaabe244e5b40c6c296178b0d40e8" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01eb539066ab2d6a68111a77de7d3391be1abdf" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;code&gt;Unpin&lt;/code&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">在标准库中，指针类型通常不具有结构固定，因此它们不提供固定投影。这就是 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 固定所有 &lt;code&gt;T&lt;/code&gt; 的原因。这是有道理的为指针类型做到这一点，因为移动 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 实际上并不移动 &lt;code&gt;T&lt;/code&gt; ：该 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 可以自由移动（又名 &lt;code&gt;Unpin&lt;/code&gt; ），即使 &lt;code&gt;T&lt;/code&gt; 不是。实际上，即使 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 总是总是自己 &lt;code&gt;Unpin&lt;/code&gt; 钉扎，原因相同：它们的内容（ &lt;code&gt;T&lt;/code&gt; ）被钉扎，但是指针本身可以移动而无需移动钉扎的数据。对彼此而言 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ，是否固定内容与指针是否固定完全无关，这意味着固定&lt;em&gt;不是&lt;/em&gt;结构化的。</target>
        </trans-unit>
        <trans-unit id="69a1bd27469eb2f59075cae2a36951b2f4c30b0e" translate="yes" xml:space="preserve">
          <source>In the test, we&amp;rsquo;re testing what happens when the &lt;code&gt;LimitTracker&lt;/code&gt; is told to set &lt;code&gt;value&lt;/code&gt; to something that is more than 75 percent of the &lt;code&gt;max&lt;/code&gt; value. First, we create a new &lt;code&gt;MockMessenger&lt;/code&gt;, which will start with an empty list of messages. Then we create a new &lt;code&gt;LimitTracker&lt;/code&gt; and give it a reference to the new &lt;code&gt;MockMessenger&lt;/code&gt; and a &lt;code&gt;max&lt;/code&gt; value of 100. We call the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt; with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the &lt;code&gt;MockMessenger&lt;/code&gt; is keeping track of should now have one message in it.</source>
          <target state="translated">在测试中，我们正在测试 &lt;code&gt;LimitTracker&lt;/code&gt; 被告知将 &lt;code&gt;value&lt;/code&gt; 设置为 &lt;code&gt;max&lt;/code&gt; 75％以上时发生的情况。首先，我们创建一个新的 &lt;code&gt;MockMessenger&lt;/code&gt; ，它将以一个空消息列表开始。然后，我们创建一个新的 &lt;code&gt;LimitTracker&lt;/code&gt; 并为其提供对新 &lt;code&gt;MockMessenger&lt;/code&gt; 的引用，且 &lt;code&gt;max&lt;/code&gt; 为100。我们在 &lt;code&gt;LimitTracker&lt;/code&gt; 上调用 &lt;code&gt;set_value&lt;/code&gt; 方法，该方法的值为80，该值大于100的75％。 &lt;code&gt;MockMessenger&lt;/code&gt; 跟踪的消息列表现在应该包含一条消息。</target>
        </trans-unit>
        <trans-unit id="adba8ce512afb3223e0e44bbc4efd34311d66e90" translate="yes" xml:space="preserve">
          <source>In the third case, we tried to only expect one variant of the &lt;code&gt;Wizard&lt;/code&gt; enum, which is not possible. To make this work, we need to using pattern matching over the &lt;code&gt;Wizard&lt;/code&gt; enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe4d3d8b095874ffa846390a6fba933c59176e6" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474cfc53c29ed4a7f5438f6a16ce96a820777966" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">在转录器中，由于片段&lt;em&gt;名称&lt;/em&gt;是在匹配器中指定的，因此 &lt;code&gt;$&lt;/code&gt; 变量仅用$ &lt;em&gt;name&lt;/em&gt;来引用。将元变量替换为与它们匹配的语法元素。关键字metavariable &lt;code&gt;$crate&lt;/code&gt; 可用于引用当前的板条箱；参见下面的&lt;a href=&quot;macros-by-example#hygiene&quot;&gt;卫生&lt;/a&gt;。元变量可以被转录多次或完全不被转录。</target>
        </trans-unit>
        <trans-unit id="fc28b1beae2c194779de6e426a53754bfb37f82e" translate="yes" xml:space="preserve">
          <source>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don&amp;rsquo;t have: they can capture their environment and access variables from the scope in which they&amp;rsquo;re defined.</source>
          <target state="translated">在锻炼生成器示例中，我们仅将闭包用作嵌入式匿名函数。但是，闭包具有函数所没有的其他功能：它们可以捕获其环境并从定义它们的作用域访问变量。</target>
        </trans-unit>
        <trans-unit id="402986500120f551bc8e41d90bdabaccacec9185" translate="yes" xml:space="preserve">
          <source>In the worst case, the algorithm allocates temporary storage in a &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; the length of the slice.</source>
          <target state="translated">在最坏的情况下，该算法以切片长度 &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; 分配临时存储。</target>
        </trans-unit>
        <trans-unit id="2792c27ad83efd64abffe24df3a1fb1485fd08bf" translate="yes" xml:space="preserve">
          <source>In these examples, types of the &lt;code&gt;ba*&lt;/code&gt; are found by LUB coercion. And the compiler checks whether LUB coercion result of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;i32&lt;/code&gt; in the processing of the function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc14d5532165c49508408bd484b7e97e6ac2646" translate="yes" xml:space="preserve">
          <source>In this appendix, we provide a reference of all the traits in the standard library that you can use with &lt;code&gt;derive&lt;/code&gt;. Each section covers:</source>
          <target state="translated">在本附录中，我们提供了标准库中可与 &lt;code&gt;derive&lt;/code&gt; 一起使用的所有特征的参考。每个部分包括：</target>
        </trans-unit>
        <trans-unit id="0046a6cf07943993e17ce12f3c78298391a2264f" translate="yes" xml:space="preserve">
          <source>In this appendix, we talk about some useful development tools that the Rust project provides. We&amp;rsquo;ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</source>
          <target state="translated">在本附录中，我们讨论了Rust项目提供的一些有用的开发工具。我们将研究自动格式化，应用警告修复的快速方法，lint和与IDE集成。</target>
        </trans-unit>
        <trans-unit id="ac9b1080783742689a97db16c3344339516e90c0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo&lt;/code&gt; is undefined, so it inherently isn't anything, and definitely not a struct.</source>
          <target state="translated">在这种情况下， &lt;code&gt;Foo&lt;/code&gt; 是未定义的，因此它本质上不是任何东西，并且绝对不是结构。</target>
        </trans-unit>
        <trans-unit id="afe608724d7fcb6b165ca3da57f4af8c6e2f8834" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Question&lt;/code&gt; would need to implement the &lt;code&gt;std::ops::Not&lt;/code&gt; trait in order to be able to use &lt;code&gt;!&lt;/code&gt; on it. Let's implement it:</source>
          <target state="translated">在这种情况下， &lt;code&gt;Question&lt;/code&gt; 将需要实现 &lt;code&gt;std::ops::Not&lt;/code&gt; trait才能使用 &lt;code&gt;!&lt;/code&gt; 在上面。让我们实现它：</target>
        </trans-unit>
        <trans-unit id="4b7473dc279144e44448cca5746abb04e0fa8694" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;c_double&lt;/code&gt; has the same size as &lt;code&gt;f64&lt;/code&gt; so we can use it directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b4ba6190447ccb2a7d84efd7c0391f36cf1b3c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;foo&lt;/code&gt; is defined, but is not a struct, so Rust can't use it as one.</source>
          <target state="translated">在这种情况下，定义了 &lt;code&gt;foo&lt;/code&gt; ，但它不是一个结构，因此Rust不能将其用作一个。</target>
        </trans-unit>
        <trans-unit id="e3897adfb1b49645b05c0b83e391e1fc19ac894e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;len&lt;/code&gt; will be 4, which means the vector storing the string &amp;ldquo;Hola&amp;rdquo; is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</source>
          <target state="translated">在这种情况下， &lt;code&gt;len&lt;/code&gt; 将为4，这意味着存储字符串&amp;ldquo; Hola&amp;rdquo;的向量为4个字节长。以UTF-8编码时，这些字母中的每个字母都占用1个字节。但是下一行呢？ （请注意，此字符串以大写的西里尔字母Ze开头，而不是阿拉伯数字3。）</target>
        </trans-unit>
        <trans-unit id="8561b972a9830d06a3e257ff13fef28acb8d1808" translate="yes" xml:space="preserve">
          <source>In this case, borrowing &lt;code&gt;x&lt;/code&gt; mutably is not possible, because &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;mut&lt;/code&gt;. But at the same time, borrowing &lt;code&gt;x&lt;/code&gt; immutably would make the assignment illegal, because a &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; reference may not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows &lt;code&gt;x&lt;/code&gt; immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of &lt;code&gt;y&lt;/code&gt; will produce an error because it would violate the uniqueness of the closure's borrow of &lt;code&gt;x&lt;/code&gt;; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.</source>
          <target state="translated">在这种情况下，因为 &lt;code&gt;x&lt;/code&gt; 不是 &lt;code&gt;mut&lt;/code&gt; ，所以无法可变地借用 &lt;code&gt;x&lt;/code&gt; 。但是同时，一成不变地借用 &lt;code&gt;x&lt;/code&gt; 会使赋值非法，因为 &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; 引用可能不是唯一的，因此不能安全地用于修改值。因此，使用了唯一的不可变借位：它不可变地借入 &lt;code&gt;x&lt;/code&gt; ，但像可变借位一样，它必须是唯一的。在上面的示例中，取消对 &lt;code&gt;y&lt;/code&gt; 声明的注释将产生错误，因为它将违反闭包的 &lt;code&gt;x&lt;/code&gt; 借位的唯一性； z的声明是有效的，因为闭包的生存期已在该块的末尾到期，从而释放了借位。</target>
        </trans-unit>
        <trans-unit id="bf5da830ba52c31b3f48f71542b74085fca253da" translate="yes" xml:space="preserve">
          <source>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren&amp;rsquo;t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</source>
          <target state="translated">在这种情况下，在创建参考循环之后，程序立即结束。这个周期的后果不是很可怕。但是，如果一个更复杂的程序在一个周期内分配了很多内存并保留了很长时间，则该程序将使用比所需数量更多的内存，并且可能使系统不堪重负，从而导致可用内存不足。</target>
        </trans-unit>
        <trans-unit id="94ade146c6864efc0d837c6a05c5b82eb67849f1" translate="yes" xml:space="preserve">
          <source>In this case, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">在这种情况下，编译器无法推断 &lt;code&gt;x&lt;/code&gt; 的类型： &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 都是合适的候选者。要指定使用哪种类型，可以在 &lt;code&gt;x&lt;/code&gt; 上使用类型注释：</target>
        </trans-unit>
        <trans-unit id="f275640cc613a55c1aac0d980097965aad345a42" translate="yes" xml:space="preserve">
          <source>In this case, the line indicated is part of our code, and if we go to that line, we see the &lt;code&gt;panic!&lt;/code&gt; macro call. In other cases, the &lt;code&gt;panic!&lt;/code&gt; call might be in code that our code calls, and the filename and line number reported by the error message will be someone else&amp;rsquo;s code where the &lt;code&gt;panic!&lt;/code&gt; macro is called, not the line of our code that eventually led to the &lt;code&gt;panic!&lt;/code&gt; call. We can use the backtrace of the functions the &lt;code&gt;panic!&lt;/code&gt; call came from to figure out the part of our code that is causing the problem. We&amp;rsquo;ll discuss what a backtrace is in more detail next.</source>
          <target state="translated">在这种情况下，指示的行是代码的一部分，如果转到该行，我们会感到 &lt;code&gt;panic!&lt;/code&gt; 宏调用。在其他情况下， &lt;code&gt;panic!&lt;/code&gt; 调用可能是在我们的代码调用的代码中，而错误消息报告的文件名和行号将是其他人的代码，因此 &lt;code&gt;panic!&lt;/code&gt; 宏被调用，而不是最终导致 &lt;code&gt;panic!&lt;/code&gt; 代码行！呼叫。我们可以使用函数的回溯来 &lt;code&gt;panic!&lt;/code&gt; 调用来自于找出导致问题的代码部分。接下来，我们将详细讨论回溯。</target>
        </trans-unit>
        <trans-unit id="a03c0650d25cf706ca4c711a0b4fa0c7cdd46367" translate="yes" xml:space="preserve">
          <source>In this case, you need to implement the &lt;code&gt;chocolate&lt;/code&gt; method to fix the error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfdeb564b13d0de24ae4a70c8a6c9f64176934b" translate="yes" xml:space="preserve">
          <source>In this chapter and throughout the book, we&amp;rsquo;ll show some commands used in the terminal. Lines that you should enter in a terminal all start with &lt;code&gt;$&lt;/code&gt;. You don&amp;rsquo;t need to type in the &lt;code&gt;$&lt;/code&gt; character; it indicates the start of each command. Lines that don&amp;rsquo;t start with &lt;code&gt;$&lt;/code&gt; typically show the output of the previous command. Additionally, PowerShell-specific examples will use &lt;code&gt;&amp;gt;&lt;/code&gt; rather than &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">在本章以及整本书中，我们将展示一些在终端中使用的命令。您应在终端中输入的行均以 &lt;code&gt;$&lt;/code&gt; 开头。您无需输入 &lt;code&gt;$&lt;/code&gt; 字符；它指示每个命令的开始。不以 &lt;code&gt;$&lt;/code&gt; 开头的行通常显示前一个命令的输出。此外，特定于PowerShell的示例将使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f1d6f9bd53aa4df418aa201b887fdd6df55aeab" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible &lt;em&gt;variants&lt;/em&gt;. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511940d9b79e52eebc6c566f728bbaeb0dd1dd34" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible values. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">在这一章中，我们将研究&lt;em&gt;枚举&lt;/em&gt;，也称为&lt;em&gt;枚举&lt;/em&gt;。枚举允许您通过枚举可能的值来定义类型。首先，我们将定义并使用一个枚举来显示枚举如何将含义与数据一起编码。接下来，我们将探讨一个名为 &lt;code&gt;Option&lt;/code&gt; 的特别有用的枚举，该枚举表示一个值可以是某些东西或什么都可以。然后，我们将研究 &lt;code&gt;match&lt;/code&gt; 表达式中的模式匹配如何使为枚举的不同值运行不同的代码变得容易。最后，我们将介绍 &lt;code&gt;if let&lt;/code&gt; 构造如何为您提供另一个方便且简洁的惯用法来处理代码中的枚举。</target>
        </trans-unit>
        <trans-unit id="54bfe40f65e4baf089b3fdf58b27393a8784f4c8" translate="yes" xml:space="preserve">
          <source>In this chapter, we won&amp;rsquo;t debate the issue of what functional programming is or isn&amp;rsquo;t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</source>
          <target state="translated">在本章中，我们将不讨论什么是函数编程或什么不是函数编程的问题，而将讨论Rust的某些功能，这些功能与许多语言（通常称为函数）的功能相似。</target>
        </trans-unit>
        <trans-unit id="1a7486659e0b2248f370c5b62acbfa92d0246aa8" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!</source>
          <target state="translated">在本章中，我们将介绍所有这些功能，讨论它们如何交互，并解释如何使用它们来管理范围。最后，您应该对模块系统有深入的了解，并且能够像专业人士一样使用示波器！</target>
        </trans-unit>
        <trans-unit id="323ae7b14fd96e68551f003142bf4b84170544d5" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover:</source>
          <target state="translated">在本章中，我们将介绍：</target>
        </trans-unit>
        <trans-unit id="a4639a7fb71c7cc2724cbe31da70376d99c56baa" translate="yes" xml:space="preserve">
          <source>In this code, the first and last value are matched with &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;. The &lt;code&gt;..&lt;/code&gt; will match and ignore everything in the middle.</source>
          <target state="translated">在此代码中，第一个和最后一个值与 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 匹配。该 &lt;code&gt;..&lt;/code&gt; 将匹配而忽略中间的一切。</target>
        </trans-unit>
        <trans-unit id="145a83e849a55e3baebf66ad497473ddcd7f5f55" translate="yes" xml:space="preserve">
          <source>In this code, the same thing happens as in the &lt;code&gt;match&lt;/code&gt; in Listing 19-26: Rust sees that &lt;code&gt;val&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;panic!&lt;/code&gt; has the type &lt;code&gt;!&lt;/code&gt;, so the result of the overall &lt;code&gt;match&lt;/code&gt; expression is &lt;code&gt;T&lt;/code&gt;. This code works because &lt;code&gt;panic!&lt;/code&gt; doesn&amp;rsquo;t produce a value; it ends the program. In the &lt;code&gt;None&lt;/code&gt; case, we won&amp;rsquo;t be returning a value from &lt;code&gt;unwrap&lt;/code&gt;, so this code is valid.</source>
          <target state="translated">在这段代码中，发生了 &lt;code&gt;match&lt;/code&gt; 清单19-26 中的匹配相同的事情：Rust看到 &lt;code&gt;val&lt;/code&gt; 具有类型 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;panic!&lt;/code&gt; 有类型 &lt;code&gt;!&lt;/code&gt; ，所以整体的结果 &lt;code&gt;match&lt;/code&gt; 表达式是 &lt;code&gt;T&lt;/code&gt; 。该代码有效，因为出现了 &lt;code&gt;panic!&lt;/code&gt; 没有产生价值；它结束程序。在 &lt;code&gt;None&lt;/code&gt; 的情况下，我们不会从 &lt;code&gt;unwrap&lt;/code&gt; 返回值，因此此代码有效。</target>
        </trans-unit>
        <trans-unit id="844247dc89592da735fc5622f72eb35876e2a2a2" translate="yes" xml:space="preserve">
          <source>In this code, you have two ways to solve this issue:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5f63902ac52a2fdb77ae9b0aaf168362307239" translate="yes" xml:space="preserve">
          <source>In this context, by &lt;em&gt;runtime&lt;/em&gt; we mean code that is included by the language in every binary. This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code. For that reason, colloquially when people say a language has &amp;ldquo;no runtime,&amp;rdquo; they often mean &amp;ldquo;small runtime.&amp;rdquo; Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts. Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</source>
          <target state="translated">在这种情况下，在&lt;em&gt;运行时中，&lt;/em&gt;我们指的是语言包含在每个二进制文件中的代码。取决于语言，此代码可以大可小，但是每种非汇编语言都将具有一定数量的运行时代码。因此，通常人们在说一种语言&amp;ldquo;没有运行时&amp;rdquo;时，通常是指&amp;ldquo;小型运行时&amp;rdquo;。较小的运行时具有较少的功能，但具有产生较小二进制文件的优势，这使得在更多上下文中更轻松地将语言与其他语言结合在一起。尽管许多语言可以通过增加运行时大小来换取更多功能，但是Rust几乎不需要运行时，并且不能折衷使用C来保持性能。</target>
        </trans-unit>
        <trans-unit id="3f10f5106c28699182d72488c5b199580b51f515" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;2&lt;/code&gt; is destroyed right after the assignment, which means that &lt;code&gt;ptr&lt;/code&gt; now points to an unavailable location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee00cd14e3198e4bb4ed77351c13a68c4d2964" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;BoxCar&lt;/code&gt; has two super-traits: &lt;code&gt;Vehicle&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt;. Both of these traits define an associated type &lt;code&gt;Color&lt;/code&gt;. &lt;code&gt;BoxCar&lt;/code&gt; inherits two types with that name from both super-traits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate &lt;code&gt;Color&lt;/code&gt; associated type, either &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; or &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt;, but this syntax is not allowed to be used in a function signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0ee0316ee57e8497270b5ce77464ecb56adca2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Cat&lt;/code&gt; is a &lt;em&gt;struct-like enum variant&lt;/em&gt;, whereas &lt;code&gt;Dog&lt;/code&gt; is simply called an enum variant. Each enum instance has a &lt;em&gt;discriminant&lt;/em&gt; which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt;&lt;code&gt;mem::discriminant&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">在此示例中， &lt;code&gt;Cat&lt;/code&gt; 是类似&lt;em&gt;struct的枚举变量&lt;/em&gt;，而 &lt;code&gt;Dog&lt;/code&gt; 简称为枚举变量。每个枚举实例都有一个&lt;em&gt;判别式&lt;/em&gt;，该&lt;em&gt;判别式&lt;/em&gt;是与之关联的整数，用于确定其拥有哪个变体。可以使用&lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt; &lt;code&gt;mem::discriminant&lt;/code&gt; &lt;/a&gt;函数获得对该判别式的不透明引用。</target>
        </trans-unit>
        <trans-unit id="7bb9799e70052b9e454a954f47a55d73983d300f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Foo&lt;/code&gt; defines an associated type &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;Bar&lt;/code&gt; inherits that type from &lt;code&gt;Foo&lt;/code&gt;, and defines another associated type of the same name. As a result, when we attempt to use &lt;code&gt;Self::A&lt;/code&gt;, it's ambiguous whether we mean the &lt;code&gt;A&lt;/code&gt; defined by &lt;code&gt;Foo&lt;/code&gt; or the one defined by &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">在此实例中， &lt;code&gt;Foo&lt;/code&gt; 定义的关联类型 &lt;code&gt;A&lt;/code&gt; 。 &lt;code&gt;Bar&lt;/code&gt; 从 &lt;code&gt;Foo&lt;/code&gt; 继承该类型，并定义了另一个具有相同名称的关联类型。结果，当我们尝试使用 &lt;code&gt;Self::A&lt;/code&gt; ，是指由 &lt;code&gt;Foo&lt;/code&gt; 定义的 &lt;code&gt;A&lt;/code&gt; 还是由 &lt;code&gt;Bar&lt;/code&gt; 定义的A都是不明确的。</target>
        </trans-unit>
        <trans-unit id="8cedc14f701bbdf96ac8102b9f064b1dca2f26cb" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Y&lt;/code&gt; cannot refer to &lt;code&gt;X&lt;/code&gt; here. To fix this, the value can be extracted as a const and then used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4ed47b5eac4878ae970fa360382b182707dcb9" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;string1&lt;/code&gt; is valid until the end of the outer scope, &lt;code&gt;string2&lt;/code&gt; is valid until the end of the inner scope, and &lt;code&gt;result&lt;/code&gt; references something that is valid until the end of the inner scope. Run this code, and you&amp;rsquo;ll see that the borrow checker approves of this code; it will compile and print &lt;code&gt;The longest string is long string is long&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;string1&lt;/code&gt; 在外部作用域结束之前一直有效， &lt;code&gt;string2&lt;/code&gt; 在内部作用域结束之前一直有效，并且 &lt;code&gt;result&lt;/code&gt; 引用的有效范围直到内部作用域结束为止。运行此代码，您将看到借用检查器批准了该代码；它将编译并打印 &lt;code&gt;The longest string is long string is long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a21a4f7cf44738665bcf722c117e87d97dd2b44" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;value&lt;/code&gt; is mutably borrowed by &lt;code&gt;borrow&lt;/code&gt; and cannot be used to calculate &lt;code&gt;sum&lt;/code&gt;. This is not possible because this would violate Rust's mutability rules.</source>
          <target state="translated">在这个例子中， &lt;code&gt;value&lt;/code&gt; 是由性情不定地借用 &lt;code&gt;borrow&lt;/code&gt; 并且不能被用于计算 &lt;code&gt;sum&lt;/code&gt; 。这是不可能的，因为这会违反Rust的可变性规则。</target>
        </trans-unit>
        <trans-unit id="ee5fd415a36736dbb42604438d3e115f3ef63293" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;x&lt;/code&gt; matches the pattern &lt;code&gt;(0, _)&lt;/code&gt;, the second field is set to &lt;code&gt;y&lt;/code&gt;. If it matches &lt;code&gt;(_, 0)&lt;/code&gt;, the first field is set to &lt;code&gt;y&lt;/code&gt;; so in all cases &lt;code&gt;y&lt;/code&gt; is set to some value.</source>
          <target state="translated">在此示例中，如果 &lt;code&gt;x&lt;/code&gt; 与模式 &lt;code&gt;(0, _)&lt;/code&gt; 匹配，则第二个字段设置为 &lt;code&gt;y&lt;/code&gt; 。如果匹配 &lt;code&gt;(_, 0)&lt;/code&gt; ，则第一个字段设置为 &lt;code&gt;y&lt;/code&gt; ；因此在所有情况下 &lt;code&gt;y&lt;/code&gt; 都设置为某个值。</target>
        </trans-unit>
        <trans-unit id="7fe9cc71a505a06c66b5d9f57153a2d3327a9165" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;'SnowWhite&lt;/code&gt; lifetime is supposed to outlive the &lt;code&gt;'kiss&lt;/code&gt; lifetime but the declaration of the &lt;code&gt;Prince&lt;/code&gt; struct doesn't enforce it. To fix this issue, you need to specify it:</source>
          <target state="translated">在此示例中， &lt;code&gt;'SnowWhite&lt;/code&gt; 生存期应该超过 &lt;code&gt;'kiss&lt;/code&gt; 生存期，但是 &lt;code&gt;Prince&lt;/code&gt; 结构的声明并未强制执行。要解决此问题，您需要指定它：</target>
        </trans-unit>
        <trans-unit id="5793bd2e6d3c5293d83c901c5867d17a61fb1b7b" translate="yes" xml:space="preserve">
          <source>In this example, the closure does not satisfy the &lt;code&gt;'static&lt;/code&gt; lifetime constraint. To fix this error, you need to double check the lifetime of the type. Here, we can fix this problem by giving &lt;code&gt;s&lt;/code&gt; a static lifetime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61f98e2cee2baaabf8be1956ffb960bd279fb24" translate="yes" xml:space="preserve">
          <source>In this example, the module &lt;code&gt;quux&lt;/code&gt; re-exports two public names defined in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在此示例中，模块 &lt;code&gt;quux&lt;/code&gt; 重新导出 &lt;code&gt;foo&lt;/code&gt; 中定义的两个公用名。</target>
        </trans-unit>
        <trans-unit id="4350bf464e116b6d57c761b20a820cb5925c37d3" translate="yes" xml:space="preserve">
          <source>In this example, the spawned thread is &quot;detached&quot; from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.</source>
          <target state="translated">在这个例子中,被产卵的线程是 &quot;脱离 &quot;于当前线程的,这意味着它的寿命可以超过它的父线程(产卵的线程),除非这个父线程是主线程。这意味着它的寿命可以超过它的父线程(产生它的线程),除非这个父线程是主线程。</target>
        </trans-unit>
        <trans-unit id="adb1f627c4f5f533a368664ad1bfd6b52635fef6" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Foo&lt;/code&gt; and the trait method &lt;code&gt;do_something_else&lt;/code&gt; both define a type parameter &lt;code&gt;T&lt;/code&gt;. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</source>
          <target state="translated">在这个例子中，所述性状 &lt;code&gt;Foo&lt;/code&gt; 和性状方法 &lt;code&gt;do_something_else&lt;/code&gt; 的都定义了类型参数 &lt;code&gt;T&lt;/code&gt; 。这是不允许的：如果该方法希望定义类型参数，则必须为其使用不同的名称。</target>
        </trans-unit>
        <trans-unit id="5106de7dace445aa59aa82effd4989b6c9358ae0" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Printable&lt;/code&gt; occurs as a trait object in both the type signature of &lt;code&gt;print&lt;/code&gt;, and the cast expression in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">在此示例中，特征 &lt;code&gt;Printable&lt;/code&gt; 在 &lt;code&gt;print&lt;/code&gt; 的类型签名和 &lt;code&gt;main&lt;/code&gt; 中的强制类型转换表达式中均作为特征对象出现。</target>
        </trans-unit>
        <trans-unit id="2c7b2451157bfe66dfc5ae3bcc7df818cb052f87" translate="yes" xml:space="preserve">
          <source>In this example, the value &lt;code&gt;p&lt;/code&gt; matches the second arm by virtue of &lt;code&gt;x&lt;/code&gt; containing a 0, so this code will print &lt;code&gt;On the y axis at 7&lt;/code&gt;.</source>
          <target state="translated">在此示例中，值 &lt;code&gt;p&lt;/code&gt; 由于 &lt;code&gt;x&lt;/code&gt; 包含0 而与第二条臂匹配，因此此代码将 &lt;code&gt;On the y axis at 7&lt;/code&gt; 打印。</target>
        </trans-unit>
        <trans-unit id="76e376bb135f5c25de32c031f91a381023081f30" translate="yes" xml:space="preserve">
          <source>In this example, the variable named &lt;code&gt;first&lt;/code&gt; will get the value &lt;code&gt;1&lt;/code&gt;, because that is the value at index &lt;code&gt;[0]&lt;/code&gt; in the array. The variable named &lt;code&gt;second&lt;/code&gt; will get the value &lt;code&gt;2&lt;/code&gt; from index &lt;code&gt;[1]&lt;/code&gt; in the array.</source>
          <target state="translated">在此示例中，名为 &lt;code&gt;first&lt;/code&gt; 的变量将获得值 &lt;code&gt;1&lt;/code&gt; ，因为它是数组中索引 &lt;code&gt;[0]&lt;/code&gt; 处的值。名为 &lt;code&gt;second&lt;/code&gt; 的变量将从数组中的索引 &lt;code&gt;[1]&lt;/code&gt; 获取值 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db1c89f552fe6cd5046ff6bd0d230e80deb004f6" translate="yes" xml:space="preserve">
          <source>In this example, we are asserting that the destructor for &lt;code&gt;Foo&lt;/code&gt; will not access any data of type &lt;code&gt;X&lt;/code&gt;, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this &lt;code&gt;impl&lt;/code&gt; as unsafe.</source>
          <target state="translated">在此示例中，我们断言 &lt;code&gt;Foo&lt;/code&gt; 的析构函数将不会访问 &lt;code&gt;X&lt;/code&gt; 类型的任何数据，并且要求此断言对我们程序的整体安全性为true。编译器当前不尝试验证此断言。因此，我们必须将此 &lt;code&gt;impl&lt;/code&gt; 标签标记为不安全。</target>
        </trans-unit>
        <trans-unit id="5b639017ef60ffaf0981282e4da6c27fcdd578e1" translate="yes" xml:space="preserve">
          <source>In this example, we define a function &lt;code&gt;ten_times&lt;/code&gt; that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.</source>
          <target state="translated">在此示例中，我们定义一个函数 &lt;code&gt;ten_times&lt;/code&gt; ，该函数接受一个高阶函数参数，然后以闭包表达式作为参数来调用它，然后是一个从环境中移出值的闭包表达式。</target>
        </trans-unit>
        <trans-unit id="9be8015724a60f5a7de7fc8be3cf3fbc9130aa82" translate="yes" xml:space="preserve">
          <source>In this example, we tried to set a value with an incompatible lifetime to another one (&lt;code&gt;'long&lt;/code&gt; is unrelated to &lt;code&gt;'short&lt;/code&gt;). We can solve this issue in two different ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8385385b7c5acae88f390fa2486165f8a8931f92" translate="yes" xml:space="preserve">
          <source>In this example, we tried to use the non-existent associated type &lt;code&gt;You&lt;/code&gt; of the &lt;code&gt;Hello&lt;/code&gt; trait. To fix this error, use an existing associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbce52117883bf5718cfbbb01cfe64f9309a2ae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the parameter &lt;code&gt;x&lt;/code&gt; and the return type, but not for the parameter &lt;code&gt;y&lt;/code&gt;, because the lifetime of &lt;code&gt;y&lt;/code&gt; does not have any relationship with the lifetime of &lt;code&gt;x&lt;/code&gt; or the return value.</source>
          <target state="translated">在此示例中，我们为参数 &lt;code&gt;x&lt;/code&gt; 和返回类型指定了寿命参数 &lt;code&gt;'a&lt;/code&gt; ，但没有为参数 &lt;code&gt;y&lt;/code&gt; 指定寿命参数，因为 &lt;code&gt;y&lt;/code&gt; 的寿命与 &lt;code&gt;x&lt;/code&gt; 的寿命或返回值没有任何关系。</target>
        </trans-unit>
        <trans-unit id="2185efdb59ae63a632adf24d45f191ffee2411df" translate="yes" xml:space="preserve">
          <source>In this example, when we assign the integer value 5 to &lt;code&gt;x&lt;/code&gt;, we let the compiler know that the generic type &lt;code&gt;T&lt;/code&gt; will be an integer for this instance of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. Then when we specify 4.0 for &lt;code&gt;y&lt;/code&gt;, which we&amp;rsquo;ve defined to have the same type as &lt;code&gt;x&lt;/code&gt;, we&amp;rsquo;ll get a type mismatch error like this:</source>
          <target state="translated">在此示例中，当我们将整数值5分配给 &lt;code&gt;x&lt;/code&gt; 时，我们让编译器知道，对于 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 此实例，泛型 &lt;code&gt;T&lt;/code&gt; 将为整数。然后，当我们为 &lt;code&gt;y&lt;/code&gt; 指定4.0时，我们将其定义为与 &lt;code&gt;x&lt;/code&gt; 具有相同的类型，我们将得到如下类型不匹配错误：</target>
        </trans-unit>
        <trans-unit id="af5f4c7efbea71694085e036fb3fca287f7c1342" translate="yes" xml:space="preserve">
          <source>In this example, you can see that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; enables mutation inside an immutable struct. In other words, it enables &quot;interior mutability&quot;.</source>
          <target state="translated">在此示例中，您可以看到 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 启用了不可变结构内的突变。换句话说，它实现了&amp;ldquo;内部可变性&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="28ad91d98b4c69b8725ca2927cbfaca53b3c5e8d" translate="yes" xml:space="preserve">
          <source>In this implementation, the &lt;code&gt;to_string&lt;/code&gt; method panics if the &lt;code&gt;Display&lt;/code&gt; implementation returns an error. This indicates an incorrect &lt;code&gt;Display&lt;/code&gt; implementation since &lt;code&gt;fmt::Write for String&lt;/code&gt; never returns an error itself.</source>
          <target state="translated">在此实现中，如果 &lt;code&gt;Display&lt;/code&gt; 实现返回错误，则 &lt;code&gt;to_string&lt;/code&gt; 方法会感到恐慌。这表明 &lt;code&gt;Display&lt;/code&gt; 实现不正确，因为 &lt;code&gt;fmt::Write for String&lt;/code&gt; 永远不会返回错误。</target>
        </trans-unit>
        <trans-unit id="7cf45f5e676953372bb64ede268b0f879c84bec0" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;not enough arguments&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">在此清单中，我们使用了之前未涉及的方法： &lt;code&gt;unwrap_or_else&lt;/code&gt; ，它是由标准库在 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 上定义的。使用 &lt;code&gt;unwrap_or_else&lt;/code&gt; 可让我们定义一些自定义的，非 &lt;code&gt;panic!&lt;/code&gt; 错误处理。如果 &lt;code&gt;Result&lt;/code&gt; 是 &lt;code&gt;Ok&lt;/code&gt; 值，则此方法的行为类似于 &lt;code&gt;unwrap&lt;/code&gt; ：它返回 &lt;code&gt;Ok&lt;/code&gt; 正在包装的内部值。但是，如果值是 &lt;code&gt;Err&lt;/code&gt; 值，则此方法将调用&lt;em&gt;闭包中&lt;/em&gt;的代码，这是我们定义的匿名函数，并将其作为参数传递给 &lt;code&gt;unwrap_or_else&lt;/code&gt; 。我们将在下面详细介绍闭包&lt;a href=&quot;ch13-00-functional-features&quot;&gt;第13章&lt;/a&gt;。现在，您只需要知道 &lt;code&gt;unwrap_or_else&lt;/code&gt; 将传递 &lt;code&gt;Err&lt;/code&gt; 的内部值（在本例中是静态字符串， &lt;code&gt;not enough arguments&lt;/code&gt; 清单12-9中没有添加足够的参数）将其传递给在 &lt;code&gt;err&lt;/code&gt; 之间出现的参数err中的闭包。垂直管道。然后，闭包中的代码在运行时可以使用 &lt;code&gt;err&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="bd1efd0f88f5695bb09cde72e8a0904d7ad1c207" translate="yes" xml:space="preserve">
          <source>In this more complex example, we use &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;.debug_set()&lt;/code&gt; to build a list of match arms:</source>
          <target state="translated">在这个更复杂的示例中，我们使用&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;.debug_set()&lt;/code&gt; 构建匹配臂列表：</target>
        </trans-unit>
        <trans-unit id="b03c6712fd2fec1eec14a91751691024a72c4d16" translate="yes" xml:space="preserve">
          <source>In this next example, &lt;code&gt;init_after_if&lt;/code&gt; is initialized after the &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt; expression&lt;/a&gt; while &lt;code&gt;uninit_after_if&lt;/code&gt; is not because it is not initialized in the &lt;code&gt;else&lt;/code&gt; case.</source>
          <target state="translated">在下一个示例中， &lt;code&gt;init_after_if&lt;/code&gt; 在&lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; 表达式&lt;/a&gt;之后初始化，而 &lt;code&gt;uninit_after_if&lt;/code&gt; 则不是，因为在 &lt;code&gt;else&lt;/code&gt; 情况下未初始化。</target>
        </trans-unit>
        <trans-unit id="8c69b4c18cf4fe1c7e28ef21ab7b9243778f0c95" translate="yes" xml:space="preserve">
          <source>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</source>
          <target state="translated">在这个过程中,编译器所做的与我们在清单10-5中用来创建泛型函数的步骤相反:编译器查看所有调用泛型代码的地方,并为泛型代码被调用的具体类型生成代码。</target>
        </trans-unit>
        <trans-unit id="9b2eecf1196adab0e0b7bc0dd52bfa9ea4118939" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll add the searching logic to the &lt;code&gt;minigrep&lt;/code&gt; program by using the Test-driven development (TDD) process. This software development technique follows these steps:</source>
          <target state="translated">在本节中，我们将使用测试驱动的开发（TDD）流程将搜索逻辑添加到 &lt;code&gt;minigrep&lt;/code&gt; 程序中。此软件开发技术遵循以下步骤：</target>
        </trans-unit>
        <trans-unit id="35594ca80fb0c4ca7018f39776903a474d1cfb0f" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll talk about modules and other parts of the module system, namely &lt;em&gt;paths&lt;/em&gt; that allow you to name items; the &lt;code&gt;use&lt;/code&gt; keyword that brings a path into scope; and the &lt;code&gt;pub&lt;/code&gt; keyword to make items public. We&amp;rsquo;ll also discuss the &lt;code&gt;as&lt;/code&gt; keyword, external packages, and the glob operator. For now, let&amp;rsquo;s focus on modules!</source>
          <target state="translated">在本节中，我们将讨论模块和模块系统的其他部分，即允许您命名项目的&lt;em&gt;路径&lt;/em&gt;。在 &lt;code&gt;use&lt;/code&gt; 关键字带来的路径进入范围; 和 &lt;code&gt;pub&lt;/code&gt; 关键字来公开商品。我们还将讨论 &lt;code&gt;as&lt;/code&gt; 关键字，外部包和glob运算符。现在，让我们专注于模块！</target>
        </trans-unit>
        <trans-unit id="b9ddbf2b08f89e10bfeee4884b118c18fb0ff1c3" translate="yes" xml:space="preserve">
          <source>In this situation, even the &lt;code&gt;ref&lt;/code&gt; keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</source>
          <target state="translated">在这种情况下，即使 &lt;code&gt;ref&lt;/code&gt; 关键字也无法解决它，因为借用的内容无法移动。这个问题一般无法解决。如果可以克隆该值，则这是一个不太明确的解决方案：</target>
        </trans-unit>
        <trans-unit id="66f6d7f6d5b6dce217f5225ca67e0e2ff88fca0a" translate="yes" xml:space="preserve">
          <source>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for &lt;em&gt;all&lt;/em&gt; possible types, so &lt;code&gt;transmute()&lt;/code&gt; simply only accepts types without any unsubstituted type parameters.</source>
          <target state="translated">在这种情况下，转换很有可能是无害的（但是Rust不能保证）。但是，当对齐和枚举优化出现在图中时，大小很可能与不同的类型参数替换匹配或不匹配。不可能检查&lt;em&gt;所有&lt;/em&gt;可能的类型，因此 &lt;code&gt;transmute()&lt;/code&gt; 仅接受没有任何未替换类型参数的类型。</target>
        </trans-unit>
        <trans-unit id="fe9b2052803d3d7b3dd78aa5085c8137d21478b8" translate="yes" xml:space="preserve">
          <source>In this suggestion, &amp;ldquo;indirection&amp;rdquo; means that instead of storing a value directly, we&amp;rsquo;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</source>
          <target state="translated">在此建议中，&amp;ldquo;间接&amp;rdquo;表示不直接存储值，而是通过存储指向值的指针来更改数据结构以间接存储值。</target>
        </trans-unit>
        <trans-unit id="ace1483441c50f77553551974f43198070533a0e" translate="yes" xml:space="preserve">
          <source>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</source>
          <target state="translated">这样一来,表达式的结构就决定了执行的结构。块只是另一种表达式,所以块、语句、表达式、块又可以相互递归嵌套在内部,达到任意深度。</target>
        </trans-unit>
        <trans-unit id="3c64ce605c02c94d28e3d47caa98671818a3b2ae" translate="yes" xml:space="preserve">
          <source>In those cases, you need to provide the type explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f60575dd030bfd74d0c69219e41591057c41df3" translate="yes" xml:space="preserve">
          <source>In trait declarations as &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt;: &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; is equivalent to &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt;.</source>
          <target state="translated">在特质声明中作为&lt;a href=&quot;items/traits#supertraits&quot;&gt;超&lt;/a&gt; &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; ：特质Circle：Shape {}等同于 &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4f93075a116db72d1570a79e9e24585b192c4ef" translate="yes" xml:space="preserve">
          <source>In trait declarations as bounds on &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;associated types&lt;/a&gt;: &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; is equivalent to &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt;.</source>
          <target state="translated">在特质声明中，以&lt;a href=&quot;items/associated-items#associated-types&quot;&gt;关联类型&lt;/a&gt;为界： &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; 等同于 &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d593169be70ffe063ab15f461603b04fb19d3943" translate="yes" xml:space="preserve">
          <source>In traits, &lt;code&gt;type&lt;/code&gt; is used to declare an &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;associated type&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d52c1f8837d60baebd5fe1bd8acd4770d12408" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses.</source>
          <target state="translated">在类型中， &lt;code&gt;+&lt;/code&gt; 类型运算符的优先级较低，因此通常需要使用括号。</target>
        </trans-unit>
        <trans-unit id="f9490ac1bbc7d37c9f2c0e3e394c8775ef19ff65" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1daf40491a926084464e0388144e6ba829d637" translate="yes" xml:space="preserve">
          <source>In various places in the book, we&amp;rsquo;ve discussed the &lt;code&gt;derive&lt;/code&gt; attribute, which you can apply to a struct or enum definition. The &lt;code&gt;derive&lt;/code&gt; attribute generates code that will implement a trait with its own default implementation on the type you&amp;rsquo;ve annotated with the &lt;code&gt;derive&lt;/code&gt; syntax.</source>
          <target state="translated">在本书的不同地方，我们讨论了 &lt;code&gt;derive&lt;/code&gt; 属性，您可以将其应用于结构或枚举定义。该 &lt;code&gt;derive&lt;/code&gt; 属性生成的代码将实现与您所使用的注解类型自身的默认实现一个特点 &lt;code&gt;derive&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="0cebe38e502b4e0d3a49a067f9739636c8c7567e" translate="yes" xml:space="preserve">
          <source>In very rare edge cases, this may happen when loading &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;std&lt;/code&gt; twice, once with &lt;code&gt;check&lt;/code&gt; metadata and once with &lt;code&gt;build&lt;/code&gt; metadata. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;#75176&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fcacf884bdd57e38c179c26c2a445daf0a3b88d" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be mixed with explicit lifetime binders. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1253e722ca01693911433634c27b9199fbe1b5" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be used in &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;Fn&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0307fb1316fe032b75c2eab1c02683137e89f74" translate="yes" xml:space="preserve">
          <source>In-band lifetimes were mixed with explicit lifetime binders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71195f6d729d094826e987475aa2b83d4c3354c6" translate="yes" xml:space="preserve">
          <source>InPlaceIterable</source>
          <target state="translated">InPlaceIterable</target>
        </trans-unit>
        <trans-unit id="0d84c9de7449d934ab38cca665ee24ab8d418e04" translate="yes" xml:space="preserve">
          <source>Includes a UTF-8 encoded file as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e257e75b3e4fa6d9e9989f973afa801a9a03f0" translate="yes" xml:space="preserve">
          <source>Includes a file as a reference to a byte array.</source>
          <target state="translated">包含一个文件作为对字节数组的引用。</target>
        </trans-unit>
        <trans-unit id="9c140715e3185328a980b4bc60a18b0febc51520" translate="yes" xml:space="preserve">
          <source>Includes a utf8-encoded file as a string.</source>
          <target state="translated">包含一个utf8编码的文件作为一个字符串。</target>
        </trans-unit>
        <trans-unit id="0c11e0c644b5890be96bab7620a548663254f1f7" translate="yes" xml:space="preserve">
          <source>Includes all extension traits, and some important type definitions.</source>
          <target state="translated">包括所有扩展特征,以及一些重要的类型定义。</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="805a014cffe854e2c811b260ab089d2eda0bbeb7" translate="yes" xml:space="preserve">
          <source>Incoming::all</source>
          <target state="translated">Incoming::all</target>
        </trans-unit>
        <trans-unit id="83bd443d175b9e89de0c8b8872961ea2816dcfb6" translate="yes" xml:space="preserve">
          <source>Incoming::any</source>
          <target state="translated">Incoming::any</target>
        </trans-unit>
        <trans-unit id="f9822b9a823019e577bdfe3ac98493f3aa60473c" translate="yes" xml:space="preserve">
          <source>Incoming::borrow</source>
          <target state="translated">Incoming::borrow</target>
        </trans-unit>
        <trans-unit id="db57c16634c0af16618401e02b9b1b14cfb90675" translate="yes" xml:space="preserve">
          <source>Incoming::borrow_mut</source>
          <target state="translated">Incoming::borrow_mut</target>
        </trans-unit>
        <trans-unit id="909a090d9b0ea3ec427658ae73388b50d4bfbc1f" translate="yes" xml:space="preserve">
          <source>Incoming::by_ref</source>
          <target state="translated">Incoming::by_ref</target>
        </trans-unit>
        <trans-unit id="6d7e9108e413d8a837bb790d96b999eaae29b3f2" translate="yes" xml:space="preserve">
          <source>Incoming::chain</source>
          <target state="translated">Incoming::chain</target>
        </trans-unit>
        <trans-unit id="30254dbd6651bc8d2ce9a6489cb59513c462d366" translate="yes" xml:space="preserve">
          <source>Incoming::cloned</source>
          <target state="translated">Incoming::cloned</target>
        </trans-unit>
        <trans-unit id="8a2bf20be5038460f2e5f09718d4cb6a21fb4c03" translate="yes" xml:space="preserve">
          <source>Incoming::cmp</source>
          <target state="translated">Incoming::cmp</target>
        </trans-unit>
        <trans-unit id="5ed0bcc65453a7978586b3e2016dacfbc14352fe" translate="yes" xml:space="preserve">
          <source>Incoming::collect</source>
          <target state="translated">Incoming::collect</target>
        </trans-unit>
        <trans-unit id="e70d0d30256802ac0658826bed8a56d75ffa6c45" translate="yes" xml:space="preserve">
          <source>Incoming::copied</source>
          <target state="translated">Incoming::copied</target>
        </trans-unit>
        <trans-unit id="a1ce4c03ba198d6862609c9bca7b4fdfd0e790c1" translate="yes" xml:space="preserve">
          <source>Incoming::count</source>
          <target state="translated">Incoming::count</target>
        </trans-unit>
        <trans-unit id="445c24f8aeffb804abbe66eac8d728adfa6384c3" translate="yes" xml:space="preserve">
          <source>Incoming::cycle</source>
          <target state="translated">Incoming::cycle</target>
        </trans-unit>
        <trans-unit id="c7373d860bdcd6bd00f58afd7287948921f2cf3d" translate="yes" xml:space="preserve">
          <source>Incoming::enumerate</source>
          <target state="translated">Incoming::enumerate</target>
        </trans-unit>
        <trans-unit id="422e90f2e0427cea81726aa22dde243c959e3442" translate="yes" xml:space="preserve">
          <source>Incoming::eq</source>
          <target state="translated">Incoming::eq</target>
        </trans-unit>
        <trans-unit id="d82ad0962be1b645dba4415057b56c8c71d2db6c" translate="yes" xml:space="preserve">
          <source>Incoming::filter</source>
          <target state="translated">Incoming::filter</target>
        </trans-unit>
        <trans-unit id="f2d060b73d6c431a592011fdcaf80f72c4327ea7" translate="yes" xml:space="preserve">
          <source>Incoming::filter_map</source>
          <target state="translated">Incoming::filter_map</target>
        </trans-unit>
        <trans-unit id="ec24aef48051e0d66dfbf513fbece0b535e8173a" translate="yes" xml:space="preserve">
          <source>Incoming::find</source>
          <target state="translated">Incoming::find</target>
        </trans-unit>
        <trans-unit id="9f1745b317ce967f0969bdd91f79615c9788ba14" translate="yes" xml:space="preserve">
          <source>Incoming::find_map</source>
          <target state="translated">Incoming::find_map</target>
        </trans-unit>
        <trans-unit id="57ed09c2ac8fbae367da14cf88b9a1cf3a0b0f16" translate="yes" xml:space="preserve">
          <source>Incoming::flat_map</source>
          <target state="translated">Incoming::flat_map</target>
        </trans-unit>
        <trans-unit id="aa8cfa9877df81bdf6f3e26ae8c327e4f18e7ca7" translate="yes" xml:space="preserve">
          <source>Incoming::flatten</source>
          <target state="translated">Incoming::flatten</target>
        </trans-unit>
        <trans-unit id="f534c99639d2a7b60622d67e3da268c1b2dbd8a2" translate="yes" xml:space="preserve">
          <source>Incoming::fmt</source>
          <target state="translated">Incoming::fmt</target>
        </trans-unit>
        <trans-unit id="7bf954d9f452b8f0bff229d58d17ebe667b8bdaa" translate="yes" xml:space="preserve">
          <source>Incoming::fold</source>
          <target state="translated">Incoming::fold</target>
        </trans-unit>
        <trans-unit id="f45d04534657562b3b8e1ac8b93f0995c4f52ffc" translate="yes" xml:space="preserve">
          <source>Incoming::for_each</source>
          <target state="translated">Incoming::for_each</target>
        </trans-unit>
        <trans-unit id="146d704978de3d221c4a8b538e653f767ff7d0cc" translate="yes" xml:space="preserve">
          <source>Incoming::from</source>
          <target state="translated">Incoming::from</target>
        </trans-unit>
        <trans-unit id="8d00e730beb7664120c689b2165fe55c7e43696b" translate="yes" xml:space="preserve">
          <source>Incoming::fuse</source>
          <target state="translated">Incoming::fuse</target>
        </trans-unit>
        <trans-unit id="d6f3fa46377ae997728223371f8e2928bbcd46ee" translate="yes" xml:space="preserve">
          <source>Incoming::ge</source>
          <target state="translated">Incoming::ge</target>
        </trans-unit>
        <trans-unit id="ed38c0b5ef84ea5163b2da693e4b72183ddee0ec" translate="yes" xml:space="preserve">
          <source>Incoming::gt</source>
          <target state="translated">Incoming::gt</target>
        </trans-unit>
        <trans-unit id="b1345261a277f185321d6adb9b350bcb58cd599e" translate="yes" xml:space="preserve">
          <source>Incoming::inspect</source>
          <target state="translated">Incoming::inspect</target>
        </trans-unit>
        <trans-unit id="59abb681c116c064869e4b015c6b1cd16fb45598" translate="yes" xml:space="preserve">
          <source>Incoming::into</source>
          <target state="translated">Incoming::into</target>
        </trans-unit>
        <trans-unit id="95a20422d3926772d9c359f121355edbd8f745f9" translate="yes" xml:space="preserve">
          <source>Incoming::into_iter</source>
          <target state="translated">Incoming::into_iter</target>
        </trans-unit>
        <trans-unit id="77b7ce153ce8067d29a7d019ff3fcc043c2fdd8e" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted</source>
          <target state="translated">Incoming::is_sorted</target>
        </trans-unit>
        <trans-unit id="4dfdf545d2798411e8ee50244269b54395d86c9a" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by</source>
          <target state="translated">Incoming::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d90a5dfb897aff5c068a0a4a12a54de5b9bdf1da" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by_key</source>
          <target state="translated">Incoming::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f1c770fca353b885ee610fe1f519139cdebcc0ee" translate="yes" xml:space="preserve">
          <source>Incoming::last</source>
          <target state="translated">Incoming::last</target>
        </trans-unit>
        <trans-unit id="f5c79843bca5e97321f55d85100e1ac93d537dd7" translate="yes" xml:space="preserve">
          <source>Incoming::le</source>
          <target state="translated">Incoming::le</target>
        </trans-unit>
        <trans-unit id="41753aa4086d7645034ac6f543870deca487abbb" translate="yes" xml:space="preserve">
          <source>Incoming::lt</source>
          <target state="translated">Incoming::lt</target>
        </trans-unit>
        <trans-unit id="42262cd6a3c45e0c4ccd2f403ab3dde4f31c999d" translate="yes" xml:space="preserve">
          <source>Incoming::map</source>
          <target state="translated">Incoming::map</target>
        </trans-unit>
        <trans-unit id="b14fbc258acb1391be68964dacf06c868d0223ee" translate="yes" xml:space="preserve">
          <source>Incoming::max</source>
          <target state="translated">Incoming::max</target>
        </trans-unit>
        <trans-unit id="e598cfd5a561805bab3a055536a7ce8d4cbc0d87" translate="yes" xml:space="preserve">
          <source>Incoming::max_by</source>
          <target state="translated">Incoming::max_by</target>
        </trans-unit>
        <trans-unit id="02e8830cd577c40509d7ca817740c861b52c07c0" translate="yes" xml:space="preserve">
          <source>Incoming::max_by_key</source>
          <target state="translated">Incoming::max_by_key</target>
        </trans-unit>
        <trans-unit id="e522553048356a9c7e3aafb53205e73c814823fd" translate="yes" xml:space="preserve">
          <source>Incoming::min</source>
          <target state="translated">Incoming::min</target>
        </trans-unit>
        <trans-unit id="8b1b84ed0cee495bc315c75dc85c4916ce7f680f" translate="yes" xml:space="preserve">
          <source>Incoming::min_by</source>
          <target state="translated">Incoming::min_by</target>
        </trans-unit>
        <trans-unit id="94a6455843a6def08f4247ddbcf5a373aff6a12c" translate="yes" xml:space="preserve">
          <source>Incoming::min_by_key</source>
          <target state="translated">Incoming::min_by_key</target>
        </trans-unit>
        <trans-unit id="af6f0e0d448b8971f8088a94ecfe2c2c28074b20" translate="yes" xml:space="preserve">
          <source>Incoming::ne</source>
          <target state="translated">Incoming::ne</target>
        </trans-unit>
        <trans-unit id="ad9f2df7e05588db669a49fe0bfa35787281e257" translate="yes" xml:space="preserve">
          <source>Incoming::next</source>
          <target state="translated">Incoming::next</target>
        </trans-unit>
        <trans-unit id="15fdadbdf731ff5f14bd01d14581b0031b5aa856" translate="yes" xml:space="preserve">
          <source>Incoming::nth</source>
          <target state="translated">Incoming::nth</target>
        </trans-unit>
        <trans-unit id="f584fdb6a022a6b9c2041ae0049adb844c00af0a" translate="yes" xml:space="preserve">
          <source>Incoming::partial_cmp</source>
          <target state="translated">Incoming::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d6e7347d2f13179a0246ad8c2f8f8c42d5ea1e8b" translate="yes" xml:space="preserve">
          <source>Incoming::partition</source>
          <target state="translated">Incoming::partition</target>
        </trans-unit>
        <trans-unit id="d15dc3a739c395fba4cdef1bb3db41863ef399f5" translate="yes" xml:space="preserve">
          <source>Incoming::peekable</source>
          <target state="translated">Incoming::peekable</target>
        </trans-unit>
        <trans-unit id="cab06ddc3af8abd52b92e45544310b0faa110219" translate="yes" xml:space="preserve">
          <source>Incoming::position</source>
          <target state="translated">Incoming::position</target>
        </trans-unit>
        <trans-unit id="bb23c8eb76a6d68dfc63c6d32849abe960c1b856" translate="yes" xml:space="preserve">
          <source>Incoming::product</source>
          <target state="translated">Incoming::product</target>
        </trans-unit>
        <trans-unit id="b3d90889f7b30454426b3ed4e11228f5d9d8ee9f" translate="yes" xml:space="preserve">
          <source>Incoming::rev</source>
          <target state="translated">Incoming::rev</target>
        </trans-unit>
        <trans-unit id="d662587d11104ca4324befe21e5aaa1cf3ed3fa3" translate="yes" xml:space="preserve">
          <source>Incoming::rposition</source>
          <target state="translated">Incoming::rposition</target>
        </trans-unit>
        <trans-unit id="6b42372525b119239ec4bd20dc7bf69a1a105a08" translate="yes" xml:space="preserve">
          <source>Incoming::scan</source>
          <target state="translated">Incoming::scan</target>
        </trans-unit>
        <trans-unit id="c1399e28a107bc4249663ed0d2b97e798127c9c6" translate="yes" xml:space="preserve">
          <source>Incoming::size_hint</source>
          <target state="translated">Incoming::size_hint</target>
        </trans-unit>
        <trans-unit id="85ee70ca43a998ef206f4a945f59006b6f40ddfa" translate="yes" xml:space="preserve">
          <source>Incoming::skip</source>
          <target state="translated">Incoming::skip</target>
        </trans-unit>
        <trans-unit id="fdd32c3e0206952202e83705e9d627eb48f607e6" translate="yes" xml:space="preserve">
          <source>Incoming::skip_while</source>
          <target state="translated">Incoming::skip_while</target>
        </trans-unit>
        <trans-unit id="5a589e1b9602c4ff48aa22e65968275507ea9485" translate="yes" xml:space="preserve">
          <source>Incoming::step_by</source>
          <target state="translated">Incoming::step_by</target>
        </trans-unit>
        <trans-unit id="d9ed48df44b20a36de8b0990f9b0c9b964475772" translate="yes" xml:space="preserve">
          <source>Incoming::sum</source>
          <target state="translated">Incoming::sum</target>
        </trans-unit>
        <trans-unit id="bcf6381c826c50e1aaea7423243d1529dca214b8" translate="yes" xml:space="preserve">
          <source>Incoming::take</source>
          <target state="translated">Incoming::take</target>
        </trans-unit>
        <trans-unit id="981c1e08f556e3870dd2af3a144f3176473200b7" translate="yes" xml:space="preserve">
          <source>Incoming::take_while</source>
          <target state="translated">Incoming::take_while</target>
        </trans-unit>
        <trans-unit id="2f0356552ebde5f1c3f3f3ad37fa03b3d1bf90bd" translate="yes" xml:space="preserve">
          <source>Incoming::try_fold</source>
          <target state="translated">Incoming::try_fold</target>
        </trans-unit>
        <trans-unit id="5c1f1df01cacdbf861258e63eb2cb8581f88d043" translate="yes" xml:space="preserve">
          <source>Incoming::try_for_each</source>
          <target state="translated">Incoming::try_for_each</target>
        </trans-unit>
        <trans-unit id="9a58299e31b9803379553db37123ab15774b671d" translate="yes" xml:space="preserve">
          <source>Incoming::try_from</source>
          <target state="translated">Incoming::try_from</target>
        </trans-unit>
        <trans-unit id="fff541a38a97a609e5012c516e4164326cfb79eb" translate="yes" xml:space="preserve">
          <source>Incoming::try_into</source>
          <target state="translated">Incoming::try_into</target>
        </trans-unit>
        <trans-unit id="946f55dc3e1af640cd291f2aaa8528234e768102" translate="yes" xml:space="preserve">
          <source>Incoming::type_id</source>
          <target state="translated">Incoming::type_id</target>
        </trans-unit>
        <trans-unit id="bf46b8f3bb432660f79899dee66baf3e9f087f95" translate="yes" xml:space="preserve">
          <source>Incoming::unzip</source>
          <target state="translated">Incoming::unzip</target>
        </trans-unit>
        <trans-unit id="96a8cde7e0e4c52965055072fd39e0d341071072" translate="yes" xml:space="preserve">
          <source>Incoming::zip</source>
          <target state="translated">Incoming::zip</target>
        </trans-unit>
        <trans-unit id="bcbf83cd2f0ed89c4d2689129dde9ed148866efc" translate="yes" xml:space="preserve">
          <source>Incorrect bytes:</source>
          <target state="translated">错误的字节。</target>
        </trans-unit>
        <trans-unit id="2a70492a6aefdfa404f3b9ac0c6d0448b88be337" translate="yes" xml:space="preserve">
          <source>Incorrect usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7c0e61e47d8d76b1fdbcd2b9644ebc448b482b" translate="yes" xml:space="preserve">
          <source>Increments the strong reference count on the &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; associated with the provided pointer by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="52cb15ca8d9c1e4b950b26ef1f32246271f50339" translate="yes" xml:space="preserve">
          <source>Index expressions on arrays and slices</source>
          <target state="translated">数组和切片的索引表达式</target>
        </trans-unit>
        <trans-unit id="361d6f89c121ce39bb2ed14f7085cd248645d21b" translate="yes" xml:space="preserve">
          <source>Index expressions, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; or &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; with a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">索引表达式，&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;数组索引&lt;/a&gt;或带有 &lt;code&gt;usize&lt;/code&gt; 的&lt;a href=&quot;types/slice&quot;&gt;切片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="528b0ff12e28b750b5aeda40648664d5f6804c7c" translate="yes" xml:space="preserve">
          <source>Index::index</source>
          <target state="translated">Index::index</target>
        </trans-unit>
        <trans-unit id="21d657443793a7fc6c319cfc186e761fac77191e" translate="yes" xml:space="preserve">
          <source>IndexMut</source>
          <target state="translated">IndexMut</target>
        </trans-unit>
        <trans-unit id="24f9ef47b9bb8985e28653af23b1accbf6cd2d9b" translate="yes" xml:space="preserve">
          <source>IndexMut::index_mut</source>
          <target state="translated">IndexMut::index_mut</target>
        </trans-unit>
        <trans-unit id="bda8e2dcef8324d4ce1ba450c4e2e0cae96a9a4a" translate="yes" xml:space="preserve">
          <source>Indexes must be within bounds of the original slice;</source>
          <target state="translated">索引必须在原始切片的范围内。</target>
        </trans-unit>
        <trans-unit id="fa74cb6623de227628f45b4ae93159daddea90b3" translate="yes" xml:space="preserve">
          <source>Indexes must lie on UTF-8 sequence boundaries.</source>
          <target state="translated">索引必须位于UTF-8序列边界上。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="8e33bba2a2fe8c945dee904cfed37743c8dd2807" translate="yes" xml:space="preserve">
          <source>Indexing into Strings</source>
          <target state="translated">索引到字符串中</target>
        </trans-unit>
        <trans-unit id="bc1a7f445eecf9a21ddaa6928da85497c3f808d7" translate="yes" xml:space="preserve">
          <source>Indexing into a string is often a bad idea because it&amp;rsquo;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using &lt;code&gt;[]&lt;/code&gt; with a single number, you can use &lt;code&gt;[]&lt;/code&gt; with a range to create a string slice containing particular bytes:</source>
          <target state="translated">索引到字符串通常不是一个好主意，因为尚不清楚字符串索引操作的返回类型应该是什么：字节值，字符，字形簇或字符串切片。因此，Rust要求您更具体地说明是否真的需要使用索引来创建字符串切片。为了更具体地指示索引并指示您要使用字符串切片，而不是使用带有单个数字的 &lt;code&gt;[]&lt;/code&gt; 进行索引，可以将 &lt;code&gt;[]&lt;/code&gt; 与范围结合使用以创建包含特定字节的字符串切片：</target>
        </trans-unit>
        <trans-unit id="6b92d7c5b5fd6e80ddd2c2e71ae6f53dabf14469" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">索引旨在进行恒定时间操作，但是UTF-8编码不允许我们执行此操作。此外，尚不清楚索引应返回哪种类型：字节，代码点或字素簇。该&lt;a href=&quot;#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt;的方法分别返回迭代器比前两个。</target>
        </trans-unit>
        <trans-unit id="ceeb8ddb5f53fcb5614444876f148bbebee79484" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aba4d1ffc3e50a35d8e6bb2627a9921d36e96c9" translate="yes" xml:space="preserve">
          <source>Indexing outside of the bounds of an object with &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; with the exception of one byte past the end of the object.</source>
          <target state="translated">用&lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;在对象边界之外进行索引，但要超出对象末尾一个字节。</target>
        </trans-unit>
        <trans-unit id="27caa1fa7c65a4437e649a4888fe129281a79568" translate="yes" xml:space="preserve">
          <source>Indicates if a buffer should be initialized.</source>
          <target state="translated">表示是否需要初始化缓冲区。</target>
        </trans-unit>
        <trans-unit id="c4c4786e638c55c48e8eb353954207ab6043189e" translate="yes" xml:space="preserve">
          <source>Indicates that directories should be created recursively, creating all parent directories. Parents that do not exist are created with the same security and permissions settings.</source>
          <target state="translated">表示应递归创建目录,创建所有父目录。不存在的父目录将以相同的安全和权限设置创建。</target>
        </trans-unit>
        <trans-unit id="4856479107baf14ea55cfdf8d4985b8807716a64" translate="yes" xml:space="preserve">
          <source>Indicates the manner in which a thread exited.</source>
          <target state="translated">表示线程退出的方式。</target>
        </trans-unit>
        <trans-unit id="075cfaf01d924967ba4b76beb1cc86c1b8ffbe22" translate="yes" xml:space="preserve">
          <source>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</source>
          <target state="translated">表示该套接字的外发组播数据包的存活时间值,默认值为1,表示除非明确要求,否则组播数据包不会离开本地网络。默认值是1,表示除非有明确的要求,否则多播数据包不会离开本地网络。</target>
        </trans-unit>
        <trans-unit id="888a497d6d0feb54c4bc51c8bbfa14e4db0f048b" translate="yes" xml:space="preserve">
          <source>Indicates unfinished code.</source>
          <target state="translated">表示未完成的代码。</target>
        </trans-unit>
        <trans-unit id="35472c24a202b583e18e139d3d561c6674911e84" translate="yes" xml:space="preserve">
          <source>Indicates unimplemented code by panicking with a message of &quot;not implemented&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4862445239fb7cd37f48e6ace7775dcd354d2d14" translate="yes" xml:space="preserve">
          <source>Indicates unreachable code.</source>
          <target state="translated">表示无法到达的代码。</target>
        </trans-unit>
        <trans-unit id="cd5cea6e94489fba68a0399bcc4d11feffb0cbe4" translate="yes" xml:space="preserve">
          <source>Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.</source>
          <target state="translated">表示是否有值可用,或者当前任务是否已被安排接收唤醒。</target>
        </trans-unit>
        <trans-unit id="a5d9b716629f981c5e75c2880c16718258347eb9" translate="yes" xml:space="preserve">
          <source>Indication that contents should be center-aligned.</source>
          <target state="translated">表示内容应居中对齐。</target>
        </trans-unit>
        <trans-unit id="582259f836deeb40225aa78333ee7027acddbdbe" translate="yes" xml:space="preserve">
          <source>Indication that contents should be left-aligned.</source>
          <target state="translated">表示内容应左对齐。</target>
        </trans-unit>
        <trans-unit id="30524864694504eb9866802047ab21c114fa2091" translate="yes" xml:space="preserve">
          <source>Indication that contents should be right-aligned.</source>
          <target state="translated">表示内容应右对齐。</target>
        </trans-unit>
        <trans-unit id="f2cd68a3153c21de89ed40993772ed6007b02a6f" translate="yes" xml:space="preserve">
          <source>Indices are zero-based for arrays and slices. Array access is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a &lt;em&gt;panicked state&lt;/em&gt; if it fails.</source>
          <target state="translated">数组和切片的索引从零开始。数组访问是一个&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;常量表达式&lt;/a&gt;，因此可以在编译时使用常量索引值检查范围。否则，将在运行时执行检查，如果检查失败，该检查会将线程置于&lt;em&gt;紧急状态&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e7d8ee4a5140f0e6e32c94f9ff32453c7e40a4a3" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">两个 &lt;code&gt;Arc&lt;/code&gt; 的不等式。</target>
        </trans-unit>
        <trans-unit id="8aa90054db987f32eec9e62690e9b9862d6f642a" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">两个 &lt;code&gt;Rc&lt;/code&gt; 不等式。</target>
        </trans-unit>
        <trans-unit id="5d55264281a8b8357477a0b1f6f6a4a72582a08d" translate="yes" xml:space="preserve">
          <source>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final &lt;code&gt;TokenStream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32565cc43897d204c904c25aeddc29a5a2fe5f4d" translate="yes" xml:space="preserve">
          <source>Infallible</source>
          <target state="translated">Infallible</target>
        </trans-unit>
        <trans-unit id="327440953e8036a6b78b97c190dedc5d1ddc1d6f" translate="yes" xml:space="preserve">
          <source>Infallible errors</source>
          <target state="translated">无懈可击的错误</target>
        </trans-unit>
        <trans-unit id="379d563f62e4c026be425a08a60de86e8b28b34e" translate="yes" xml:space="preserve">
          <source>Infallible::borrow</source>
          <target state="translated">Infallible::borrow</target>
        </trans-unit>
        <trans-unit id="ffd9adf91cadc5963cf564501d6440dfcb9953d6" translate="yes" xml:space="preserve">
          <source>Infallible::borrow_mut</source>
          <target state="translated">Infallible::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d5161b5d2a0dd973c7749267f912225db6f86b3c" translate="yes" xml:space="preserve">
          <source>Infallible::clamp</source>
          <target state="translated">Infallible::clamp</target>
        </trans-unit>
        <trans-unit id="f9dfe17efa7693fd64ca4bce650f4693dec46e6a" translate="yes" xml:space="preserve">
          <source>Infallible::clone</source>
          <target state="translated">Infallible::clone</target>
        </trans-unit>
        <trans-unit id="7c7c7505a3bdd3e6bbbfabe3c0aa36eea42c2f97" translate="yes" xml:space="preserve">
          <source>Infallible::clone_from</source>
          <target state="translated">Infallible::clone_from</target>
        </trans-unit>
        <trans-unit id="6af6b86ef345c274a60c49262dbedb50a8323471" translate="yes" xml:space="preserve">
          <source>Infallible::clone_into</source>
          <target state="translated">Infallible::clone_into</target>
        </trans-unit>
        <trans-unit id="3f4e892d27a40b0bfaf9fee7ba4a2719e5f0e03b" translate="yes" xml:space="preserve">
          <source>Infallible::cmp</source>
          <target state="translated">Infallible::cmp</target>
        </trans-unit>
        <trans-unit id="465ca79819acd2f64e9c25bd2a18d141db20f7e4" translate="yes" xml:space="preserve">
          <source>Infallible::eq</source>
          <target state="translated">Infallible::eq</target>
        </trans-unit>
        <trans-unit id="7b0120f9faa0f0e51d2f41f2228ccb58415bb901" translate="yes" xml:space="preserve">
          <source>Infallible::fmt</source>
          <target state="translated">Infallible::fmt</target>
        </trans-unit>
        <trans-unit id="7699715e87167505521e297f0cc5acf9571073ba" translate="yes" xml:space="preserve">
          <source>Infallible::from</source>
          <target state="translated">Infallible::from</target>
        </trans-unit>
        <trans-unit id="9ed64ca1536a61aeb71e791f8b0cd35996768800" translate="yes" xml:space="preserve">
          <source>Infallible::ge</source>
          <target state="translated">Infallible::ge</target>
        </trans-unit>
        <trans-unit id="6bc6944b5c980e7843d508d02dcd2bfaf58a503d" translate="yes" xml:space="preserve">
          <source>Infallible::gt</source>
          <target state="translated">Infallible::gt</target>
        </trans-unit>
        <trans-unit id="be25a1605cddc636f6f076ea8d21d97812f2aa85" translate="yes" xml:space="preserve">
          <source>Infallible::into</source>
          <target state="translated">Infallible::into</target>
        </trans-unit>
        <trans-unit id="acae0cd14002a94fe132d6ca88f1fdd5ca563403" translate="yes" xml:space="preserve">
          <source>Infallible::le</source>
          <target state="translated">Infallible::le</target>
        </trans-unit>
        <trans-unit id="2b7d09de5fbcd932797ca9cc160818ef628164b0" translate="yes" xml:space="preserve">
          <source>Infallible::lt</source>
          <target state="translated">Infallible::lt</target>
        </trans-unit>
        <trans-unit id="d981e531de4db6af3fa624928233a62cc48506b0" translate="yes" xml:space="preserve">
          <source>Infallible::max</source>
          <target state="translated">Infallible::max</target>
        </trans-unit>
        <trans-unit id="4e77b6f968c067dfd00c877ce693a33816232a84" translate="yes" xml:space="preserve">
          <source>Infallible::min</source>
          <target state="translated">Infallible::min</target>
        </trans-unit>
        <trans-unit id="1b9bdf4c04b01562bf66a579b3902b4d24df2814" translate="yes" xml:space="preserve">
          <source>Infallible::ne</source>
          <target state="translated">Infallible::ne</target>
        </trans-unit>
        <trans-unit id="593cf3934010f07d135bbd81984d0e7b07060f05" translate="yes" xml:space="preserve">
          <source>Infallible::partial_cmp</source>
          <target state="translated">Infallible::partial_cmp</target>
        </trans-unit>
        <trans-unit id="171d7fff4d94e2b47d18a78e5a1c94a683078c15" translate="yes" xml:space="preserve">
          <source>Infallible::to_owned</source>
          <target state="translated">Infallible::to_owned</target>
        </trans-unit>
        <trans-unit id="256be91884f5591734d76be10903ead44c9f209f" translate="yes" xml:space="preserve">
          <source>Infallible::to_string</source>
          <target state="translated">Infallible::to_string</target>
        </trans-unit>
        <trans-unit id="c3635403870a783a099eedcae587acfb8a52bc1f" translate="yes" xml:space="preserve">
          <source>Infallible::try_from</source>
          <target state="translated">Infallible::try_from</target>
        </trans-unit>
        <trans-unit id="3c8ee4706115d8499f3abf4d51e35db72e1ffd2e" translate="yes" xml:space="preserve">
          <source>Infallible::try_into</source>
          <target state="translated">Infallible::try_into</target>
        </trans-unit>
        <trans-unit id="9701bd213ca2d8e7962b353284539a737fba44f7" translate="yes" xml:space="preserve">
          <source>Infallible::type_id</source>
          <target state="translated">Infallible::type_id</target>
        </trans-unit>
        <trans-unit id="c548ca9534f0b8a6c18d5933d5460cae1f620bec" translate="yes" xml:space="preserve">
          <source>Inferred type</source>
          <target state="translated">推断类型</target>
        </trans-unit>
        <trans-unit id="85dc47997d86458573535c2b6419f71eaedb8bec" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b827f3090a9999d7251035ec3accdcd8d4fbe7d" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">像 &lt;code&gt;repeat()&lt;/code&gt; 这样的无限迭代器通常与&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 等&lt;/a&gt;适配器一起使用，以使它们变得有限。</target>
        </trans-unit>
        <trans-unit id="2872d343e29a3d0faf1e93a846c0ad3b8146eceb" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e414b3978173634ff311532d9eb1dc73109f5119" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">无限重复器（如 &lt;code&gt;repeat_with()&lt;/code&gt; )经常与适配器（如&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;）一起使用，以使它们变得有限。</target>
        </trans-unit>
        <trans-unit id="a2550f47e7bda60f30b73b2126315e72f6a1181f" translate="yes" xml:space="preserve">
          <source>Infinite loops</source>
          <target state="translated">无限循环</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="2caa9882f0053ecda17ba6be06a5251c1ec2645f" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;).</source>
          <target state="translated">无穷大（&amp;infin;）。</target>
        </trans-unit>
        <trans-unit id="87a3bea62fc4aac2370741613d6bad23fc5e7898" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f32::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5889ff563c59beba5ff715c644770f8c520445a" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f64::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="d42473cc429103c815ee41c99ce227e6800bc064" translate="yes" xml:space="preserve">
          <source>Informally:</source>
          <target state="translated">Informally:</target>
        </trans-unit>
        <trans-unit id="50473fcaee3f0826f522b7d9bde1dee298665a6b" translate="yes" xml:space="preserve">
          <source>Informs the compiler that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">告知编译器,代码中的这一点是无法达到的,以便进一步优化。</target>
        </trans-unit>
        <trans-unit id="da26edc8a2a6b051f930b8dc35ea3b2d2eb04a3f" translate="yes" xml:space="preserve">
          <source>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</source>
          <target state="translated">告知优化器一个条件始终为真。如果条件为假,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="7ae97ac101c4619f2cdd3e3df7584b679394eca7" translate="yes" xml:space="preserve">
          <source>Inhabited</source>
          <target state="translated">Inhabited</target>
        </trans-unit>
        <trans-unit id="b07b5b517980bf88c19321ee29f23f8a21e0b4de" translate="yes" xml:space="preserve">
          <source>Inherent Implementations</source>
          <target state="translated">固有实施</target>
        </trans-unit>
        <trans-unit id="bf73ea65fd18a78a9021507f0c11c78ed2ec5124" translate="yes" xml:space="preserve">
          <source>Inherent associated types were part of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; but are not yet implemented. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;the tracking issue&lt;/a&gt; for the status of this implementation.</source>
          <target state="translated">固有的关联类型是&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195的&lt;/a&gt;一部分，但尚未实现。有关此实现的状态，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;跟踪问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f47cc0e78be269b94ff1fbb506eefabb2d14cd1d" translate="yes" xml:space="preserve">
          <source>Inherent implementation</source>
          <target state="translated">固有的执行</target>
        </trans-unit>
        <trans-unit id="89d8c2e2efc6fafd98f5603953f0cb702613d6d3" translate="yes" xml:space="preserve">
          <source>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the &lt;code&gt;unsafe&lt;/code&gt; keyword from the inherent implementation will resolve this error.</source>
          <target state="translated">固有的实现（不实现特征但提供与类型关联的方法的实现）始终是安全的，因为它们没有实现不安全的特征。从固有实现中删除 &lt;code&gt;unsafe&lt;/code&gt; 关键字将解决此错误。</target>
        </trans-unit>
        <trans-unit id="02407dbce9ca24cc02710598fc24ae8f49c07a7e" translate="yes" xml:space="preserve">
          <source>Inherent implementations associate the contained items to the implementing type. Inherent implementations can contain &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;associated functions&lt;/a&gt; (including methods) and &lt;a href=&quot;associated-items#associated-constants&quot;&gt;associated constants&lt;/a&gt;. They cannot contain associated type aliases.</source>
          <target state="translated">固有的实现将所包含的项目与实现类型相关联。固有的实现可以包含&lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;关联的函数&lt;/a&gt;（包括方法）和&lt;a href=&quot;associated-items#associated-constants&quot;&gt;关联的常量&lt;/a&gt;。它们不能包含关联的类型别名。</target>
        </trans-unit>
        <trans-unit id="4ccb704ced0ac70357d35287cb1c67388f967d06" translate="yes" xml:space="preserve">
          <source>Inherent method</source>
          <target state="translated">固有方法</target>
        </trans-unit>
        <trans-unit id="c7a774bf3dce2aac99ad48347458653bbd55d325" translate="yes" xml:space="preserve">
          <source>Inherit stdin/stdout/stderr for &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt;, but create pipes for &lt;code&gt;output&lt;/code&gt;</source>
          <target state="translated">继承stdin / stdout / stderr &lt;code&gt;spawn&lt;/code&gt; 或 &lt;code&gt;status&lt;/code&gt; ，但创建管道 &lt;code&gt;output&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f4e94fb7b802199fb91e731b50847b79d9607c1" translate="yes" xml:space="preserve">
          <source>Inherit the current process's environment</source>
          <target state="translated">继承当前进程的环境</target>
        </trans-unit>
        <trans-unit id="44c348c84d3785ac5adb30ee3d2d10f68e971317" translate="yes" xml:space="preserve">
          <source>Inherit the current process's working directory</source>
          <target state="translated">继承当前进程的工作目录。</target>
        </trans-unit>
        <trans-unit id="6325b69277e854d2ebda5c6558b946870708063a" translate="yes" xml:space="preserve">
          <source>Inheritance as a Type System and as Code Sharing</source>
          <target state="translated">作为类型系统和代码共享的继承性</target>
        </trans-unit>
        <trans-unit id="c561edc4e8c488ada0373bbdca70237bf7b2c36a" translate="yes" xml:space="preserve">
          <source>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it&amp;rsquo;s often at risk of sharing more code than necessary. Subclasses shouldn&amp;rsquo;t always share all characteristics of their parent class but will do so with inheritance. This can make a program&amp;rsquo;s design less flexible. It also introduces the possibility of calling methods on subclasses that don&amp;rsquo;t make sense or that cause errors because the methods don&amp;rsquo;t apply to the subclass. In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program&amp;rsquo;s design.</source>
          <target state="translated">继承最近在许多编程语言中不再是编程设计解决方案的首选，因为继承经常有共享不必要代码的风险。子类不应该总是共享其父类的所有特征，而应该通过继承来共享。这会使程序的设计不灵活。它还引入了在子类上调用没有意义或会导致错误的子类的可能性，因为这些方法不适用于子类。另外，某些语言仅允许子类从一个类继承，从而进一步限制了程序设计的灵活性。</target>
        </trans-unit>
        <trans-unit id="2e8b04bb573d36dddf2182bf5af08f053f087e52" translate="yes" xml:space="preserve">
          <source>Initial values</source>
          <target state="translated">初始值</target>
        </trans-unit>
        <trans-unit id="c904b3e1f2d0c5d733b728b7a681f23a1ee75fda" translate="yes" xml:space="preserve">
          <source>Initialization and Destruction</source>
          <target state="translated">初始化和销毁</target>
        </trans-unit>
        <trans-unit id="13d802cdbafe0031cbe0ff944c50f80b718c2135" translate="yes" xml:space="preserve">
          <source>Initialization invariant</source>
          <target state="translated">初始化不变性</target>
        </trans-unit>
        <trans-unit id="e4de29eb027f99abd844645c1796c2a7a7d72482" translate="yes" xml:space="preserve">
          <source>Initialization is dynamically performed on the first call to &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; within a thread, and values that implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; get destructed when a thread exits. Some caveats apply, which are explained below.</source>
          <target state="translated">初始化是在线程中对&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;的第一次调用中动态执行的，并且在线程退出时，实现&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 的&lt;/a&gt;值将被破坏。一些注意事项适用，下面将进行说明。</target>
        </trans-unit>
        <trans-unit id="b12d9d28ca06ab166730d1a0be67505b54f2b263" translate="yes" xml:space="preserve">
          <source>Initialization of a union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db21316277d9b77e6330bd9b3d2303f36118171f" translate="yes" xml:space="preserve">
          <source>Initialization value for static &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">静态&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;值的初始化值。</target>
        </trans-unit>
        <trans-unit id="777041461872120636aa50d7bf36c832a7f4df98" translate="yes" xml:space="preserve">
          <source>Initialize a result to &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; before a loop:</source>
          <target state="translated">在循环之前将结果初始化为&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cb5407ce66e9cc74c7b9cdad45d317b358a42346" translate="yes" xml:space="preserve">
          <source>Initializer::borrow</source>
          <target state="translated">Initializer::borrow</target>
        </trans-unit>
        <trans-unit id="9329992da7e67d3d87b950443458d66c568d4935" translate="yes" xml:space="preserve">
          <source>Initializer::borrow_mut</source>
          <target state="translated">Initializer::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8b338b461eda8eab3ac52c21c7ba950b55ddab77" translate="yes" xml:space="preserve">
          <source>Initializer::fmt</source>
          <target state="translated">Initializer::fmt</target>
        </trans-unit>
        <trans-unit id="370ad1ce33d717e00bfed251c3d4bf09120c4049" translate="yes" xml:space="preserve">
          <source>Initializer::from</source>
          <target state="translated">Initializer::from</target>
        </trans-unit>
        <trans-unit id="26ef6fd69d6de0da79344847b51c3c8c83e2b8cc" translate="yes" xml:space="preserve">
          <source>Initializer::initialize</source>
          <target state="translated">Initializer::initialize</target>
        </trans-unit>
        <trans-unit id="bdae64fb5268754bb9cc8ae6c8db2ab2a08fdbc3" translate="yes" xml:space="preserve">
          <source>Initializer::into</source>
          <target state="translated">Initializer::into</target>
        </trans-unit>
        <trans-unit id="a79949e93a459b7f8ca5406e877e55f5660e5c75" translate="yes" xml:space="preserve">
          <source>Initializer::nop</source>
          <target state="translated">Initializer::nop</target>
        </trans-unit>
        <trans-unit id="dcb257db32b009bda392da62101575610abd1f91" translate="yes" xml:space="preserve">
          <source>Initializer::should_initialize</source>
          <target state="translated">Initializer::should_initialize</target>
        </trans-unit>
        <trans-unit id="bcab8cf375f63f790f0ce8e05777079bda310ea7" translate="yes" xml:space="preserve">
          <source>Initializer::try_from</source>
          <target state="translated">Initializer::try_from</target>
        </trans-unit>
        <trans-unit id="1ce33c3dc308ea20a9c3e23385d3fd4e6cdbc2f0" translate="yes" xml:space="preserve">
          <source>Initializer::try_into</source>
          <target state="translated">Initializer::try_into</target>
        </trans-unit>
        <trans-unit id="7015bd93154feb364c2957b0fc2cdb3fe5bb0863" translate="yes" xml:space="preserve">
          <source>Initializer::type_id</source>
          <target state="translated">Initializer::type_id</target>
        </trans-unit>
        <trans-unit id="38d15bea38cc632ed42db7368869a2581cd9ac0d" translate="yes" xml:space="preserve">
          <source>Initializer::zeroing</source>
          <target state="translated">Initializer::zeroing</target>
        </trans-unit>
        <trans-unit id="b02eff8ddabee28d5ce99312e8bd3930e76e09a5" translate="yes" xml:space="preserve">
          <source>Initializes a buffer if necessary.</source>
          <target state="translated">必要时初始化一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="c1014a628ca9687c4db754c43f3628d84e3050c5" translate="yes" xml:space="preserve">
          <source>Initializing a struct field-by-field</source>
          <target state="translated">逐字段初始化一个结构</target>
        </trans-unit>
        <trans-unit id="6d9d88d804a2b918f6a240e649b5e1a2aa5a1b6e" translate="yes" xml:space="preserve">
          <source>Initializing an array element-by-element</source>
          <target state="translated">逐元素初始化一个数组</target>
        </trans-unit>
        <trans-unit id="e30e79f506a4a7b48aa6bd2ea1d1c98586736d96" translate="yes" xml:space="preserve">
          <source>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety &lt;em&gt;and&lt;/em&gt; concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you&amp;rsquo;re working on it rather than potentially after it has been shipped to production. We&amp;rsquo;ve nicknamed this aspect of Rust &lt;em&gt;fearless&lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt;. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</source>
          <target state="translated">最初，Rust团队认为确保内存安全和防止并发问题是要用不同方法解决的两个独立挑战。随着时间的推移，该团队发现所有权和类型系统是一组功能强大的工具，可帮助管理内存安全&lt;em&gt;和&lt;/em&gt;并发问题！通过所有权和类型检查，许多并发错误是Rust中的编译时错误，而不是运行时错误。因此，错误的代码将拒绝编译并呈现一个解释问题的错误，而不是使您花费大量时间尝试重现运行时并发错误发生的确切情况。因此，您可以在处理代码时对其进行修复，而不是在将代码交付生产后进行修复。我们已经将Rust &lt;em&gt;无畏&lt;/em&gt;&lt;em&gt;并发的&lt;/em&gt;这一方面称为&amp;ldquo; &lt;em&gt;无畏&amp;rdquo;&lt;/em&gt;。无所畏惧的并发性使您可以编写无细微错误且易于重构的代码，而不会引入新的错误。</target>
        </trans-unit>
        <trans-unit id="377c3360b199ab4bedae33ce6d834fe07f041fe6" translate="yes" xml:space="preserve">
          <source>Inline assembly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a13c17feda3ff04e933d53202cd41c94dace05" translate="yes" xml:space="preserve">
          <source>Inner attribute</source>
          <target state="translated">内在属性</target>
        </trans-unit>
        <trans-unit id="565c802152b12c7dd9aea0fe59ebaacf3d1a82a3" translate="yes" xml:space="preserve">
          <source>Inner block doc comment</source>
          <target state="translated">内块文档注释</target>
        </trans-unit>
        <trans-unit id="af507067e5f2cec421f889124df4ee46c1a92bbf" translate="yes" xml:space="preserve">
          <source>Inner document can only be used before items. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca5fb7f033a9d40e84c1a1a0c29b149dc2c2561" translate="yes" xml:space="preserve">
          <source>Inner functions do not have access to their containing environment. To fix this error, you can replace the function with a closure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10264f133a74f365cfab7999c77a7091803d2786" translate="yes" xml:space="preserve">
          <source>Inner items do not inherit type or const parameters from the functions they are embedded in.</source>
          <target state="translated">内项不继承它们所嵌入的函数的类型或常量参数。</target>
        </trans-unit>
        <trans-unit id="6909dc9a044dcde9a4fe7603daf0a9a52557aba3" translate="yes" xml:space="preserve">
          <source>Inner line doc comment</source>
          <target state="translated">内行文档注释</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">输入格式</target>
        </trans-unit>
        <trans-unit id="daf107c7f6d6d3a06676862d762621e314a3de24" translate="yes" xml:space="preserve">
          <source>Insert and complex keys</source>
          <target state="translated">插入键和复合键</target>
        </trans-unit>
        <trans-unit id="3d9eeb934e6164d2c24b6394e6758d068509ccb2" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;code&gt;O(log n)&lt;/code&gt; time complexity. Checking the largest element is &lt;code&gt;O(1)&lt;/code&gt;. Converting a vector to a binary heap can be done in-place, and has &lt;code&gt;O(n)&lt;/code&gt; complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;code&gt;O(n log n)&lt;/code&gt; in-place heapsort.</source>
          <target state="translated">插入和弹出最大元素的时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 。检查最大的元素是 &lt;code&gt;O(1)&lt;/code&gt; 。将向量转换为二进制堆可以就地完成，并且复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 。二进制堆也可以就地转换为排序向量，从而可以将其用于 &lt;code&gt;O(n log n)&lt;/code&gt; 就地堆排序。</target>
        </trans-unit>
        <trans-unit id="e3054fc5d210400311e9f74c38361908c7518246" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) time complexity. Checking the largest element is &lt;em&gt;O&lt;/em&gt;(1). Converting a vector to a binary heap can be done in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) in-place heapsort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b51cb1a3f7392b32f519dbb88d97e332d11c69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">插入 &lt;code&gt;v&lt;/code&gt; 入选项，如果它是&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，然后返回一个可变参考包含的值。</target>
        </trans-unit>
        <trans-unit id="ea064b5e532406cd5efbee55897b1c3c1824866f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94836515b3818e2e9860b9063cc6b9696a633f85" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec673856ac415b2c56f7363563f20a74b9ab6742" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option then returns a mutable reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633ef776ac14fc1a5ba3722ac27ba6e3e9e74927" translate="yes" xml:space="preserve">
          <source>Inserts a character into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">在此 &lt;code&gt;String&lt;/code&gt; 中的字节位置插入一个字符。</target>
        </trans-unit>
        <trans-unit id="0a96531a2ad16ab4c68e8dd30a04fcb8b88d0c9e" translate="yes" xml:space="preserve">
          <source>Inserts a key-value pair into the map.</source>
          <target state="translated">在地图中插入键值对。</target>
        </trans-unit>
        <trans-unit id="bc42a512a6b6856f7f8d324cb00ee4762d1d8f2a" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the &lt;code&gt;LinkedList&lt;/code&gt; after the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f7ad47cd6a43af311ed7238acb4e8855c0abcd" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the &lt;code&gt;LinkedList&lt;/code&gt; before the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f07650e645ae306862b323d418b09fad3b7f7a0" translate="yes" xml:space="preserve">
          <source>Inserts a string slice into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">将一个字符串切片插入此 &lt;code&gt;String&lt;/code&gt; 中某个字节的位置。</target>
        </trans-unit>
        <trans-unit id="7d8655d30bbaeaee48aa3f55378c0fe2a4d62e4c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">如果从 &lt;code&gt;f&lt;/code&gt; 计算的值插入&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则将其插入选项，然后返回对包含值的可变引用。</target>
        </trans-unit>
        <trans-unit id="cf859e7e91bd94533ccef650a59dbaf129cf0d1c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd878e1d7609b46228a7e1a93fb6e8fa8ab178e1" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the set if the given &lt;code&gt;value&lt;/code&gt; is not present, then returns a reference to the value in the set.</source>
          <target state="translated">如果给定 &lt;code&gt;value&lt;/code&gt; 不存在，则将从 &lt;code&gt;f&lt;/code&gt; 计算的值插入到集合中，然后返回对该集合中值的引用。</target>
        </trans-unit>
        <trans-unit id="e4c367e5c15ba31d0f216cb7099e2418408fa476" translate="yes" xml:space="preserve">
          <source>Inserts all new key-values from the iterator and replaces values with existing keys with new values returned from the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033e5469d3495f120ca34f88432068fa89f314f7" translate="yes" xml:space="preserve">
          <source>Inserts an element at &lt;code&gt;index&lt;/code&gt; within the &lt;code&gt;VecDeque&lt;/code&gt;, shifting all elements with indices greater than or equal to &lt;code&gt;index&lt;/code&gt; towards the back.</source>
          <target state="translated">在 &lt;code&gt;VecDeque&lt;/code&gt; 中的 &lt;code&gt;index&lt;/code&gt; 处插入一个元素，将索引大于或等于 &lt;code&gt;index&lt;/code&gt; 的所有元素向后移动。</target>
        </trans-unit>
        <trans-unit id="12d5beb4f208ab2afd01a906d06c0928be9bf9f4" translate="yes" xml:space="preserve">
          <source>Inserts an element at position &lt;code&gt;index&lt;/code&gt; within the vector, shifting all elements after it to the right.</source>
          <target state="translated">在向量中的位置 &lt;code&gt;index&lt;/code&gt; 处插入一个元素，将其后的所有元素向右移动。</target>
        </trans-unit>
        <trans-unit id="9bb4759e4324e0dbf38962bc28c2aed1b8022c83" translate="yes" xml:space="preserve">
          <source>Inserts an owned copy of the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32004441f1f355a905cf795d20839963739fd9b1" translate="yes" xml:space="preserve">
          <source>Inserts or updates an environment variable mapping.</source>
          <target state="translated">插入或更新环境变量映射。</target>
        </trans-unit>
        <trans-unit id="d407882b4597c3f9cc373c79e663633b3651a26e" translate="yes" xml:space="preserve">
          <source>Inserts the elements from the given &lt;code&gt;LinkedList&lt;/code&gt; after the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f751f427f5a00ba1f4ba152bfd16fef910d4b118" translate="yes" xml:space="preserve">
          <source>Inserts the elements from the given &lt;code&gt;LinkedList&lt;/code&gt; before the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec935fc4eff4c401230b5e9494768220ac04ae85" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="translated">如果给定 &lt;code&gt;value&lt;/code&gt; 不存在，则将其插入集合中，然后返回对该集合中值的引用。</target>
        </trans-unit>
        <trans-unit id="10a95bea4ce01379ab8d7b752bb3fe35f6abf8b1" translate="yes" xml:space="preserve">
          <source>Inserts the given element just after the element most recently returned by &lt;code&gt;.next()&lt;/code&gt;. The inserted element does not appear in the iteration.</source>
          <target state="translated">在 &lt;code&gt;.next()&lt;/code&gt; 最近返回的元素之后插入给定元素。插入的元素不会出现在迭代中。</target>
        </trans-unit>
        <trans-unit id="af470e35471ccbf3c83cd6c715dc2e1540c10617" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;for&lt;/code&gt; loop, we search for the byte that represents the space by using the byte literal syntax. If we find a space, we return the position. Otherwise, we return the length of the string by using &lt;code&gt;s.len()&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;for&lt;/code&gt; 循环内，我们使用字节文字语法搜索表示空间的字节。如果找到空间，则返回该位置。否则，我们使用 &lt;code&gt;s.len()&lt;/code&gt; 返回字符串的长度：</target>
        </trans-unit>
        <trans-unit id="49f499d15e7cb0aca0c18bf8de68e4d96c591f23" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;main&lt;/code&gt; function is the following code:</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 函数内部是以下代码：</target>
        </trans-unit>
        <trans-unit id="743099d758832aebc06d09f96504a2db95574113" translate="yes" xml:space="preserve">
          <source>Inside the function signature and body, the name of the type parameter can be used as a type name. &lt;a href=&quot;traits&quot;&gt;Trait&lt;/a&gt; bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the &lt;code&gt;where&lt;/code&gt; syntax:</source>
          <target state="translated">在函数签名和主体内部，可以将type参数的名称用作类型名称。可以为类型参数指定&lt;a href=&quot;traits&quot;&gt;特征&lt;/a&gt;范围，以允许对该类型的值调用具有该特征的方法。这是使用 &lt;code&gt;where&lt;/code&gt; 语法指定的：</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="82ab79e7a84c19ee615f55de9576c57f6039cbaf" translate="yes" xml:space="preserve">
          <source>Inspect::all</source>
          <target state="translated">Inspect::all</target>
        </trans-unit>
        <trans-unit id="af62c7ee7c236c7e17a30a78c2b4fcf9f79c0b4b" translate="yes" xml:space="preserve">
          <source>Inspect::any</source>
          <target state="translated">Inspect::any</target>
        </trans-unit>
        <trans-unit id="b077905231123238f4a7bb9fcc60ce75f6089a93" translate="yes" xml:space="preserve">
          <source>Inspect::borrow</source>
          <target state="translated">Inspect::borrow</target>
        </trans-unit>
        <trans-unit id="dac186ed9d0b7d57d599f5ce890d1950aca83d7e" translate="yes" xml:space="preserve">
          <source>Inspect::borrow_mut</source>
          <target state="translated">Inspect::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eff030734cfa782924c1060ba45ae2c9617ddff7" translate="yes" xml:space="preserve">
          <source>Inspect::by_ref</source>
          <target state="translated">Inspect::by_ref</target>
        </trans-unit>
        <trans-unit id="c6e04f66ee740f870c7db51ddce5c394c1f5b366" translate="yes" xml:space="preserve">
          <source>Inspect::chain</source>
          <target state="translated">Inspect::chain</target>
        </trans-unit>
        <trans-unit id="af5a3161569b3cc4b1af16e096368ee36af988fd" translate="yes" xml:space="preserve">
          <source>Inspect::clone</source>
          <target state="translated">Inspect::clone</target>
        </trans-unit>
        <trans-unit id="4b8f1150495fa883babb18b3738d6b381ca35719" translate="yes" xml:space="preserve">
          <source>Inspect::clone_from</source>
          <target state="translated">Inspect::clone_from</target>
        </trans-unit>
        <trans-unit id="f20fee187ea64cd2682fd76ef634f46c65ea7337" translate="yes" xml:space="preserve">
          <source>Inspect::clone_into</source>
          <target state="translated">Inspect::clone_into</target>
        </trans-unit>
        <trans-unit id="91d60f6fbbeb3649b6191055cd46e14268f30490" translate="yes" xml:space="preserve">
          <source>Inspect::cloned</source>
          <target state="translated">Inspect::cloned</target>
        </trans-unit>
        <trans-unit id="85a2573bc9e0fcf94624c4b800d4b5742004e819" translate="yes" xml:space="preserve">
          <source>Inspect::cmp</source>
          <target state="translated">Inspect::cmp</target>
        </trans-unit>
        <trans-unit id="bb80987b9610829409c7cf311bd83c99cafb9358" translate="yes" xml:space="preserve">
          <source>Inspect::collect</source>
          <target state="translated">Inspect::collect</target>
        </trans-unit>
        <trans-unit id="6c4755e22c04a1a561bd40c8f7ed7cc9e14afdd5" translate="yes" xml:space="preserve">
          <source>Inspect::copied</source>
          <target state="translated">Inspect::copied</target>
        </trans-unit>
        <trans-unit id="d91465c1eb8c20ff2aaf256018f191b4b51027db" translate="yes" xml:space="preserve">
          <source>Inspect::count</source>
          <target state="translated">Inspect::count</target>
        </trans-unit>
        <trans-unit id="f6a3530affc366af3c3031653f04c92d94544c6f" translate="yes" xml:space="preserve">
          <source>Inspect::cycle</source>
          <target state="translated">Inspect::cycle</target>
        </trans-unit>
        <trans-unit id="2ef8727649c440036fbfd895887f256337974360" translate="yes" xml:space="preserve">
          <source>Inspect::enumerate</source>
          <target state="translated">Inspect::enumerate</target>
        </trans-unit>
        <trans-unit id="90d29ac40ce8f2f13585d9242b559870d571b0d2" translate="yes" xml:space="preserve">
          <source>Inspect::eq</source>
          <target state="translated">Inspect::eq</target>
        </trans-unit>
        <trans-unit id="3c8af74b0f8d034e93cc2689eb1582aea35cd194" translate="yes" xml:space="preserve">
          <source>Inspect::filter</source>
          <target state="translated">Inspect::filter</target>
        </trans-unit>
        <trans-unit id="0c1d967d962d5542a61729409b6700ebf061e41a" translate="yes" xml:space="preserve">
          <source>Inspect::filter_map</source>
          <target state="translated">Inspect::filter_map</target>
        </trans-unit>
        <trans-unit id="ef11d99b08eee4456cbbcf30c8d5eaf30c8a59bd" translate="yes" xml:space="preserve">
          <source>Inspect::find</source>
          <target state="translated">Inspect::find</target>
        </trans-unit>
        <trans-unit id="de75c9aaf20b405a1c60fd94f4dbe93e04bb79b9" translate="yes" xml:space="preserve">
          <source>Inspect::find_map</source>
          <target state="translated">Inspect::find_map</target>
        </trans-unit>
        <trans-unit id="4bdd706bdfb04e01d1c9af213d5586e2748a2444" translate="yes" xml:space="preserve">
          <source>Inspect::flat_map</source>
          <target state="translated">Inspect::flat_map</target>
        </trans-unit>
        <trans-unit id="adc62575b9ec6c48f327e8e73d67dd12a37fd54f" translate="yes" xml:space="preserve">
          <source>Inspect::flatten</source>
          <target state="translated">Inspect::flatten</target>
        </trans-unit>
        <trans-unit id="bf64f53f8ddafacb88390ac8654fa5e287a73a7c" translate="yes" xml:space="preserve">
          <source>Inspect::fmt</source>
          <target state="translated">Inspect::fmt</target>
        </trans-unit>
        <trans-unit id="e1203b82ecf5e7d86eeb57728448c3072c4d31ca" translate="yes" xml:space="preserve">
          <source>Inspect::fold</source>
          <target state="translated">Inspect::fold</target>
        </trans-unit>
        <trans-unit id="e36f213246f9d2f573670ffad6151bd06e3fa586" translate="yes" xml:space="preserve">
          <source>Inspect::for_each</source>
          <target state="translated">Inspect::for_each</target>
        </trans-unit>
        <trans-unit id="e7c3f5132be9e5287630addcdee29ef7865ef06d" translate="yes" xml:space="preserve">
          <source>Inspect::from</source>
          <target state="translated">Inspect::from</target>
        </trans-unit>
        <trans-unit id="fe4bfacc82f6be56fbd2cbdacbd9f9c98dbeb4d0" translate="yes" xml:space="preserve">
          <source>Inspect::fuse</source>
          <target state="translated">Inspect::fuse</target>
        </trans-unit>
        <trans-unit id="18e6f5734f2efd739f3505c74a0c0d087a45dc44" translate="yes" xml:space="preserve">
          <source>Inspect::ge</source>
          <target state="translated">Inspect::ge</target>
        </trans-unit>
        <trans-unit id="51b9499c2f6bcf728ec327afb3eadb4e80054ef7" translate="yes" xml:space="preserve">
          <source>Inspect::gt</source>
          <target state="translated">Inspect::gt</target>
        </trans-unit>
        <trans-unit id="df78def6e9a15f9326fc866aa7162363317dfe3c" translate="yes" xml:space="preserve">
          <source>Inspect::inspect</source>
          <target state="translated">Inspect::inspect</target>
        </trans-unit>
        <trans-unit id="cde84bc6a1ac6acfa3ca27e39148f1683f7a639a" translate="yes" xml:space="preserve">
          <source>Inspect::into</source>
          <target state="translated">Inspect::into</target>
        </trans-unit>
        <trans-unit id="0c85f8b299a3868a074eadb647478881cca1f5f2" translate="yes" xml:space="preserve">
          <source>Inspect::into_iter</source>
          <target state="translated">Inspect::into_iter</target>
        </trans-unit>
        <trans-unit id="93bdbca2f9e35d0382950f48be8119f4c4cd8c39" translate="yes" xml:space="preserve">
          <source>Inspect::is_empty</source>
          <target state="translated">Inspect::is_empty</target>
        </trans-unit>
        <trans-unit id="6cb061e34832197156e0eae9b796318c52eae21c" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted</source>
          <target state="translated">Inspect::is_sorted</target>
        </trans-unit>
        <trans-unit id="0b700978aa9715e5aeabd053030f7e06e5dfdbe8" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by</source>
          <target state="translated">Inspect::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="01522e5b03123c9816813cfbecb670d36dcf9bae" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by_key</source>
          <target state="translated">Inspect::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="97c7968340cdbfc55e6279e63210f8319602c3b1" translate="yes" xml:space="preserve">
          <source>Inspect::last</source>
          <target state="translated">Inspect::last</target>
        </trans-unit>
        <trans-unit id="1641c5ab204a86bd76b52647b967fa3844ee555e" translate="yes" xml:space="preserve">
          <source>Inspect::le</source>
          <target state="translated">Inspect::le</target>
        </trans-unit>
        <trans-unit id="8fedbf984d9131a9c32910d0dd8cd507c9ae41f1" translate="yes" xml:space="preserve">
          <source>Inspect::len</source>
          <target state="translated">Inspect::len</target>
        </trans-unit>
        <trans-unit id="2aae13f70bf251eedf4d622e3c8e8d7ebe509466" translate="yes" xml:space="preserve">
          <source>Inspect::lt</source>
          <target state="translated">Inspect::lt</target>
        </trans-unit>
        <trans-unit id="3c10daeba2bb0af4fb652f56b13c4f712081ee60" translate="yes" xml:space="preserve">
          <source>Inspect::map</source>
          <target state="translated">Inspect::map</target>
        </trans-unit>
        <trans-unit id="d7ab985e5175dcb4007a24ad2073cd92e1ee725b" translate="yes" xml:space="preserve">
          <source>Inspect::max</source>
          <target state="translated">Inspect::max</target>
        </trans-unit>
        <trans-unit id="5548cb84f4f36e68e97b0766437c90e71bec388e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by</source>
          <target state="translated">Inspect::max_by</target>
        </trans-unit>
        <trans-unit id="dce539004497e98e80382919f2b44ac4f343a42e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by_key</source>
          <target state="translated">Inspect::max_by_key</target>
        </trans-unit>
        <trans-unit id="588f749d074427554e4d2614e02fff13ad9cd053" translate="yes" xml:space="preserve">
          <source>Inspect::min</source>
          <target state="translated">Inspect::min</target>
        </trans-unit>
        <trans-unit id="60fe678c3fd98d803d7a0a967cf63b451cdaf79c" translate="yes" xml:space="preserve">
          <source>Inspect::min_by</source>
          <target state="translated">Inspect::min_by</target>
        </trans-unit>
        <trans-unit id="2487d43ef493a331b1b717bc22f40361c1ef635a" translate="yes" xml:space="preserve">
          <source>Inspect::min_by_key</source>
          <target state="translated">Inspect::min_by_key</target>
        </trans-unit>
        <trans-unit id="ffc55c77a0a3cf78936319f186df9927df3e0ccd" translate="yes" xml:space="preserve">
          <source>Inspect::ne</source>
          <target state="translated">Inspect::ne</target>
        </trans-unit>
        <trans-unit id="a43fcb5b031c0ce3926f10977d7f6a10a43f6208" translate="yes" xml:space="preserve">
          <source>Inspect::next</source>
          <target state="translated">Inspect::next</target>
        </trans-unit>
        <trans-unit id="6febe3467ee6ea45f701752f64651a80fe8404ab" translate="yes" xml:space="preserve">
          <source>Inspect::next_back</source>
          <target state="translated">Inspect::next_back</target>
        </trans-unit>
        <trans-unit id="0f9d290f3781cb4ac95ed05a1829eb899359b7f9" translate="yes" xml:space="preserve">
          <source>Inspect::nth</source>
          <target state="translated">Inspect::nth</target>
        </trans-unit>
        <trans-unit id="633dbdd78d8cdd2854d53a34adbb447ab4e90331" translate="yes" xml:space="preserve">
          <source>Inspect::nth_back</source>
          <target state="translated">Inspect::nth_back</target>
        </trans-unit>
        <trans-unit id="fc4ec8ac3236397826a770a15ac100842f901223" translate="yes" xml:space="preserve">
          <source>Inspect::partial_cmp</source>
          <target state="translated">Inspect::partial_cmp</target>
        </trans-unit>
        <trans-unit id="40853e163585e56c8285d38aa5808ca70dc06c35" translate="yes" xml:space="preserve">
          <source>Inspect::partition</source>
          <target state="translated">Inspect::partition</target>
        </trans-unit>
        <trans-unit id="9434c28e5a571fffcf6e901ec452b5ae6a98ab38" translate="yes" xml:space="preserve">
          <source>Inspect::peekable</source>
          <target state="translated">Inspect::peekable</target>
        </trans-unit>
        <trans-unit id="43968189a660c3e4fac603b379bde0cd86ad697c" translate="yes" xml:space="preserve">
          <source>Inspect::position</source>
          <target state="translated">Inspect::position</target>
        </trans-unit>
        <trans-unit id="89b4972ffab1f05ea2fbde1d69c01d599123b156" translate="yes" xml:space="preserve">
          <source>Inspect::product</source>
          <target state="translated">Inspect::product</target>
        </trans-unit>
        <trans-unit id="0443653aa8a5d69a1b0d33c9f17e2c9254f5f5d7" translate="yes" xml:space="preserve">
          <source>Inspect::rev</source>
          <target state="translated">Inspect::rev</target>
        </trans-unit>
        <trans-unit id="7cb21ca083cda72535e929cef63f871b4f3cf651" translate="yes" xml:space="preserve">
          <source>Inspect::rfind</source>
          <target state="translated">Inspect::rfind</target>
        </trans-unit>
        <trans-unit id="f79e10ec84996051e8312ada6ac965fccb6846de" translate="yes" xml:space="preserve">
          <source>Inspect::rfold</source>
          <target state="translated">Inspect::rfold</target>
        </trans-unit>
        <trans-unit id="f78976291c9758ab5955ca36b2caedb636e425a2" translate="yes" xml:space="preserve">
          <source>Inspect::rposition</source>
          <target state="translated">Inspect::rposition</target>
        </trans-unit>
        <trans-unit id="2392835414c1e0b5afa2ace3b96de2ef5ff9083c" translate="yes" xml:space="preserve">
          <source>Inspect::scan</source>
          <target state="translated">Inspect::scan</target>
        </trans-unit>
        <trans-unit id="3e468495e996e3f520360765bb1983040761bf4d" translate="yes" xml:space="preserve">
          <source>Inspect::size_hint</source>
          <target state="translated">Inspect::size_hint</target>
        </trans-unit>
        <trans-unit id="65d5d88728cb3772dee70aa6ae26fe906858cdfa" translate="yes" xml:space="preserve">
          <source>Inspect::skip</source>
          <target state="translated">Inspect::skip</target>
        </trans-unit>
        <trans-unit id="e4df02a7fa585f7bf67e2c2e7620ec2b27bf223a" translate="yes" xml:space="preserve">
          <source>Inspect::skip_while</source>
          <target state="translated">Inspect::skip_while</target>
        </trans-unit>
        <trans-unit id="81611aac4ee662fdf8e1bb6309a5396db2852250" translate="yes" xml:space="preserve">
          <source>Inspect::step_by</source>
          <target state="translated">Inspect::step_by</target>
        </trans-unit>
        <trans-unit id="333ad3419c346fac8b8d3c0fd4cc6a07785ed3a9" translate="yes" xml:space="preserve">
          <source>Inspect::sum</source>
          <target state="translated">Inspect::sum</target>
        </trans-unit>
        <trans-unit id="07c4846ffa005c2b497a796ecdc14a564003a4a8" translate="yes" xml:space="preserve">
          <source>Inspect::take</source>
          <target state="translated">Inspect::take</target>
        </trans-unit>
        <trans-unit id="4f28a1534dff8b2e2c944f0bfaafe96286e1baaa" translate="yes" xml:space="preserve">
          <source>Inspect::take_while</source>
          <target state="translated">Inspect::take_while</target>
        </trans-unit>
        <trans-unit id="2a423ad3eae2fec9385b69311ba93e53244f0ad5" translate="yes" xml:space="preserve">
          <source>Inspect::to_owned</source>
          <target state="translated">Inspect::to_owned</target>
        </trans-unit>
        <trans-unit id="a6362c52c757937e435b1eeef2d9ab055596b389" translate="yes" xml:space="preserve">
          <source>Inspect::try_fold</source>
          <target state="translated">Inspect::try_fold</target>
        </trans-unit>
        <trans-unit id="b44f87043be8c6e37fe81b5e52b558de6e2af9af" translate="yes" xml:space="preserve">
          <source>Inspect::try_for_each</source>
          <target state="translated">Inspect::try_for_each</target>
        </trans-unit>
        <trans-unit id="2933e22002dc23a223d51ac3b5541e6507691dd0" translate="yes" xml:space="preserve">
          <source>Inspect::try_from</source>
          <target state="translated">Inspect::try_from</target>
        </trans-unit>
        <trans-unit id="b21cad5abb074d64e5dc5deb026a557335ea6176" translate="yes" xml:space="preserve">
          <source>Inspect::try_into</source>
          <target state="translated">Inspect::try_into</target>
        </trans-unit>
        <trans-unit id="1fd81bf07a71bc1209ac8f8b1e33f27ed1378a45" translate="yes" xml:space="preserve">
          <source>Inspect::try_rfold</source>
          <target state="translated">Inspect::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e9b8b3f317cc849ace42df081dd27ff57c0541e" translate="yes" xml:space="preserve">
          <source>Inspect::type_id</source>
          <target state="translated">Inspect::type_id</target>
        </trans-unit>
        <trans-unit id="41140164c66c290cc48804ad982a4e7115e22da9" translate="yes" xml:space="preserve">
          <source>Inspect::unzip</source>
          <target state="translated">Inspect::unzip</target>
        </trans-unit>
        <trans-unit id="fe0d4b72621d75d8a76f592b0efd07f85c74dca9" translate="yes" xml:space="preserve">
          <source>Inspect::zip</source>
          <target state="translated">Inspect::zip</target>
        </trans-unit>
        <trans-unit id="8a955d8f62cddda7e4b47eb2772b795f5ac4e929" translate="yes" xml:space="preserve">
          <source>Inspecting a foreign C string:</source>
          <target state="translated">检查一个外来的C字符串。</target>
        </trans-unit>
        <trans-unit id="24c028aad5e4f71eb7323a7fdf907c77523124b6" translate="yes" xml:space="preserve">
          <source>Inspection and manipulation of the process's environment.</source>
          <target state="translated">对工艺环境的检查和操纵。</target>
        </trans-unit>
        <trans-unit id="2cc2859dfe537be8955a457d12a963c9483cf55a" translate="yes" xml:space="preserve">
          <source>Inspects an environment variable at compile time.</source>
          <target state="translated">在编译时检查环境变量。</target>
        </trans-unit>
        <trans-unit id="da805945f5409d032b925fa086323fea9942dc3f" translate="yes" xml:space="preserve">
          <source>Install binaries from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;安装二进制文件</target>
        </trans-unit>
        <trans-unit id="27807feadc6086bb00cc2f2fc11c34f918ce0b35" translate="yes" xml:space="preserve">
          <source>Install the latest stable version of Rust using &lt;code&gt;rustup&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;rustup&lt;/code&gt; 安装最新的稳定版Rust</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="8bc95ab544ffc801a72a650102cb1b4b0031b02c" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; on Linux or macOS</source>
          <target state="translated">在Linux或macOS上安装 &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d41546865affb2f20149c73fe77f1fc24d402ca2" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; on Windows</source>
          <target state="translated">在Windows上安装 &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e19f38815d4acff6e4f527222a8aef2789228129" translate="yes" xml:space="preserve">
          <source>Installing Binaries from Crates.io with &lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt;</source>
          <target state="translated">从Crates.io与安装二进制文件 &lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b810516d3307cdf27a35ee79c057d48b6aa21230" translate="yes" xml:space="preserve">
          <source>Installing Rust on Linux, macOS, and Windows</source>
          <target state="translated">在Linux、macOS和Windows上安装Rust。</target>
        </trans-unit>
        <trans-unit id="2c30b9b10b587e1e4e3853ef85ec4740848abbd7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Fn&lt;/code&gt; can be called repeatedly without mutating state.</source>
          <target state="translated">&lt;code&gt;Fn&lt;/code&gt; 的实例可以重复调用而不改变状态。</target>
        </trans-unit>
        <trans-unit id="1322a032825805d3a73d3fe7e3a12985cf1de692" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnMut&lt;/code&gt; can be called repeatedly and may mutate state.</source>
          <target state="translated">&lt;code&gt;FnMut&lt;/code&gt; 的实例可以重复调用，并且可以改变状态。</target>
        </trans-unit>
        <trans-unit id="b9bc8df98d67671ea9af2ebbd9472094277d62c7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnOnce&lt;/code&gt; can be called, but might not be callable multiple times. Because of this, if the only thing known about a type is that it implements &lt;code&gt;FnOnce&lt;/code&gt;, it can only be called once.</source>
          <target state="translated">可以调用 &lt;code&gt;FnOnce&lt;/code&gt; 的实例，但可能无法多次调用。因此，如果关于类型的唯一已知信息是它实现 &lt;code&gt;FnOnce&lt;/code&gt; ，则只能调用一次。</target>
        </trans-unit>
        <trans-unit id="5b9d31413b772c5dc3e318115ee395c8ad114636" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Hasher&lt;/code&gt; usually represent state that is changed while hashing data.</source>
          <target state="translated">&lt;code&gt;Hasher&lt;/code&gt; 的实例通常表示在对数据进行哈希处理时更改的状态。</target>
        </trans-unit>
        <trans-unit id="21ec3e515a993282791572f7098d9de91b54a575" translate="yes" xml:space="preserve">
          <source>Instances of this &lt;code&gt;struct&lt;/code&gt; can be obtained by matching against the &lt;a href=&quot;enum.component#variant.Prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt; variant&lt;/a&gt; on &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过与&lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;enum.component#variant.Prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt;变体匹配来获得此 &lt;code&gt;struct&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="e5dd7083ff5f07cec7b9b34c02884013f777ac05" translate="yes" xml:space="preserve">
          <source>Instant</source>
          <target state="translated">Instant</target>
        </trans-unit>
        <trans-unit id="b5ac78fce22209b999309e8a7436e97b10622104" translate="yes" xml:space="preserve">
          <source>Instant::add</source>
          <target state="translated">Instant::add</target>
        </trans-unit>
        <trans-unit id="e5c83578445bb46f2191fb87fb2e970bfde98993" translate="yes" xml:space="preserve">
          <source>Instant::add_assign</source>
          <target state="translated">Instant::add_assign</target>
        </trans-unit>
        <trans-unit id="0c8c3b63eb155a52c73bfac3155d0197dd1a085d" translate="yes" xml:space="preserve">
          <source>Instant::borrow</source>
          <target state="translated">Instant::borrow</target>
        </trans-unit>
        <trans-unit id="f0f79568d43ec6cff172ef06950242a1e38ab9d4" translate="yes" xml:space="preserve">
          <source>Instant::borrow_mut</source>
          <target state="translated">Instant::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2e29432f378f62b734e945a4acd41b7defd436d4" translate="yes" xml:space="preserve">
          <source>Instant::checked_add</source>
          <target state="translated">Instant::checked_add</target>
        </trans-unit>
        <trans-unit id="eb4f8d11d037399c427f9a46cdb4e74b0b9fb310" translate="yes" xml:space="preserve">
          <source>Instant::checked_duration_since</source>
          <target state="translated">Instant::checked_duration_since</target>
        </trans-unit>
        <trans-unit id="f623e63718dd7f5e08fc4822d3ea1e552e483468" translate="yes" xml:space="preserve">
          <source>Instant::checked_sub</source>
          <target state="translated">Instant::checked_sub</target>
        </trans-unit>
        <trans-unit id="f7961f96937c07d9b42758cbb78758eeb1202726" translate="yes" xml:space="preserve">
          <source>Instant::clamp</source>
          <target state="translated">Instant::clamp</target>
        </trans-unit>
        <trans-unit id="a221c46ded2b61b64dcb1f60bfcb2b2993a3a5c9" translate="yes" xml:space="preserve">
          <source>Instant::clone</source>
          <target state="translated">Instant::clone</target>
        </trans-unit>
        <trans-unit id="0e4e4ec37ffa30c7418b3d4c01f925199339bd78" translate="yes" xml:space="preserve">
          <source>Instant::clone_from</source>
          <target state="translated">Instant::clone_from</target>
        </trans-unit>
        <trans-unit id="8b5bc24c2667bb02ad8d0c988c0c260c44857a92" translate="yes" xml:space="preserve">
          <source>Instant::clone_into</source>
          <target state="translated">Instant::clone_into</target>
        </trans-unit>
        <trans-unit id="e2495f5ad07793d7e77643dd4f486d02627866e1" translate="yes" xml:space="preserve">
          <source>Instant::cmp</source>
          <target state="translated">Instant::cmp</target>
        </trans-unit>
        <trans-unit id="5bb91176ea9d1de93e298e46888f1699788ffa0c" translate="yes" xml:space="preserve">
          <source>Instant::duration_since</source>
          <target state="translated">Instant::duration_since</target>
        </trans-unit>
        <trans-unit id="afcae638aa376f5908f1f30bd28087f8ac6046bd" translate="yes" xml:space="preserve">
          <source>Instant::elapsed</source>
          <target state="translated">Instant::elapsed</target>
        </trans-unit>
        <trans-unit id="243a247fce13eeb9a4a84c1d5fb1dac67574f6d1" translate="yes" xml:space="preserve">
          <source>Instant::eq</source>
          <target state="translated">Instant::eq</target>
        </trans-unit>
        <trans-unit id="c0e9c53ccf6d3d28525b5acc190c32004eb85ec8" translate="yes" xml:space="preserve">
          <source>Instant::fmt</source>
          <target state="translated">Instant::fmt</target>
        </trans-unit>
        <trans-unit id="91e13bb77c7e58f374e2d3daa91a9fc513ccb0bb" translate="yes" xml:space="preserve">
          <source>Instant::from</source>
          <target state="translated">Instant::from</target>
        </trans-unit>
        <trans-unit id="666400c2a2e214fcba1e53bc6d351d576dedbf88" translate="yes" xml:space="preserve">
          <source>Instant::ge</source>
          <target state="translated">Instant::ge</target>
        </trans-unit>
        <trans-unit id="e1545f7a496f8f598ffee1a4b219bdc08ac325eb" translate="yes" xml:space="preserve">
          <source>Instant::gt</source>
          <target state="translated">Instant::gt</target>
        </trans-unit>
        <trans-unit id="41c216d5664a8a7e6d226c8c88076fb379772e86" translate="yes" xml:space="preserve">
          <source>Instant::hash</source>
          <target state="translated">Instant::hash</target>
        </trans-unit>
        <trans-unit id="754e2486a3657aa16f85c8a3399792e46fc3859e" translate="yes" xml:space="preserve">
          <source>Instant::hash_slice</source>
          <target state="translated">Instant::hash_slice</target>
        </trans-unit>
        <trans-unit id="77b8dcf93181fdfb9c2ccd019961362f091bc10d" translate="yes" xml:space="preserve">
          <source>Instant::into</source>
          <target state="translated">Instant::into</target>
        </trans-unit>
        <trans-unit id="27c580d98c20ea09e90f23c4e7129dd284f1e540" translate="yes" xml:space="preserve">
          <source>Instant::le</source>
          <target state="translated">Instant::le</target>
        </trans-unit>
        <trans-unit id="077dca8f66a9fddef8fd3afcd25ba70cba946a7c" translate="yes" xml:space="preserve">
          <source>Instant::lt</source>
          <target state="translated">Instant::lt</target>
        </trans-unit>
        <trans-unit id="5f279b9b945d564222473676176af94a42a66352" translate="yes" xml:space="preserve">
          <source>Instant::max</source>
          <target state="translated">Instant::max</target>
        </trans-unit>
        <trans-unit id="1fef472f05cd2b320ab2c2019b4644689c5cb2f0" translate="yes" xml:space="preserve">
          <source>Instant::min</source>
          <target state="translated">Instant::min</target>
        </trans-unit>
        <trans-unit id="2607167b08c7b923c8543daeccd1a89c638f791c" translate="yes" xml:space="preserve">
          <source>Instant::ne</source>
          <target state="translated">Instant::ne</target>
        </trans-unit>
        <trans-unit id="2e89ed9eeb6e6fedfd76e029598f95d52ac89e9c" translate="yes" xml:space="preserve">
          <source>Instant::now</source>
          <target state="translated">Instant::now</target>
        </trans-unit>
        <trans-unit id="ef217fe283814eb7e0d5fb84203270e40f97b8d2" translate="yes" xml:space="preserve">
          <source>Instant::partial_cmp</source>
          <target state="translated">Instant::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bf1b8520fb2822b3f5cb83bccfd646a516fffcbf" translate="yes" xml:space="preserve">
          <source>Instant::saturating_duration_since</source>
          <target state="translated">Instant::saturating_duration_since</target>
        </trans-unit>
        <trans-unit id="9ed1ccf1a589fe42420c89b940730dc8b7982f7d" translate="yes" xml:space="preserve">
          <source>Instant::sub</source>
          <target state="translated">Instant::sub</target>
        </trans-unit>
        <trans-unit id="57ade0b6d4dcc1517fdb9cf85b73a61857e80559" translate="yes" xml:space="preserve">
          <source>Instant::sub_assign</source>
          <target state="translated">Instant::sub_assign</target>
        </trans-unit>
        <trans-unit id="bdec0c97db20d86ebdd661571569d5a69a65be45" translate="yes" xml:space="preserve">
          <source>Instant::to_owned</source>
          <target state="translated">Instant::to_owned</target>
        </trans-unit>
        <trans-unit id="0901e5a9482040c503269599b849e7e300181ba0" translate="yes" xml:space="preserve">
          <source>Instant::try_from</source>
          <target state="translated">Instant::try_from</target>
        </trans-unit>
        <trans-unit id="5df3e1f653d0b4e8c037a1c9641f59e6a8cbc24c" translate="yes" xml:space="preserve">
          <source>Instant::try_into</source>
          <target state="translated">Instant::try_into</target>
        </trans-unit>
        <trans-unit id="69f76dc23d56db8a52e6e54a74ec2db10116eb78" translate="yes" xml:space="preserve">
          <source>Instant::type_id</source>
          <target state="translated">Instant::type_id</target>
        </trans-unit>
        <trans-unit id="001172aad080d8306d5d4d1b5dc437b8d68f3a48" translate="yes" xml:space="preserve">
          <source>Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; would be an example from above. When data follows along with a variant, such as with rust's built-in &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; type, the data is added as the type describes, for example &lt;code&gt;Option::Some(123)&lt;/code&gt;. The same follows with struct-like variants, with things looking like &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt;. Empty Enums are similar to () in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.</source>
          <target state="translated">实例化枚举变量涉及显式地使用枚举的名称作为其命名空间，后跟一个变量。 &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; 将是上面的一个示例。当数据跟随一个变体（例如rust的内置&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;类型）时，数据将按照类型描述添加，例如 &lt;code&gt;Option::Some(123)&lt;/code&gt; 。类似结构的变体也是如此，事情看起来像 &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt; 。空枚举与（）相似，因为它们根本无法实例化，并且主要用于以有趣的方式弄乱类型系统。</target>
        </trans-unit>
        <trans-unit id="2c525f735dffbb0093cdbc000d1e1854b0b45f32" translate="yes" xml:space="preserve">
          <source>Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; would be an example from above. When data follows along with a variant, such as with rust's built-in &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; type, the data is added as the type describes, for example &lt;code&gt;Option::Some(123)&lt;/code&gt;. The same follows with struct-like variants, with things looking like &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt;. Empty Enums are similar to &lt;a href=&quot;primitive.never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt; in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d417c0066da918ab986006990b8c13e4a1c9d4" translate="yes" xml:space="preserve">
          <source>Instantiation</source>
          <target state="translated">Instantiation</target>
        </trans-unit>
        <trans-unit id="b9d10d744d3b830949e2bf595c80e084be4f440a" translate="yes" xml:space="preserve">
          <source>Instantiations of struct or variant fields</source>
          <target state="translated">结构或变体字段的实例化</target>
        </trans-unit>
        <trans-unit id="052f953d4dc163101293e43033ca426c81cc5b70" translate="yes" xml:space="preserve">
          <source>Instantiations of struct, union, or enum variant fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b4faec33775d5b4afedfc919179e22bbcfd3c9" translate="yes" xml:space="preserve">
          <source>Instants are always guaranteed to be no less than any previously measured instant when created, and are often useful for tasks such as measuring benchmarks or timing how long an operation takes.</source>
          <target state="translated">瞬时总是保证在创建时不低于任何先前测量的瞬时,并且通常对测量基准或对操作所需时间进行计时等任务非常有用。</target>
        </trans-unit>
        <trans-unit id="283f4073d67eb71b9aee283558af89f84e2066b3" translate="yes" xml:space="preserve">
          <source>Instants are opaque types that can only be compared to one another. There is no method to get &quot;the number of seconds&quot; from an instant. Instead, it only allows measuring the duration between two instants (or comparing two instants).</source>
          <target state="translated">瞬时是不透明的类型,只能相互比较。没有任何方法可以从一个瞬时中获得 &quot;秒数&quot;,而只允许测量两个瞬时之间的持续时间(或比较两个瞬时)。相反,它只允许测量两个瞬时之间的持续时间(或比较两个瞬时)。</target>
        </trans-unit>
        <trans-unit id="61804bc8442fc7d7bb4e71e306aef5c0aea1b60a" translate="yes" xml:space="preserve">
          <source>Instead it is used to prevent moves through the type system, by controlling the behavior of pointers &lt;code&gt;P&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper, which &quot;pin&quot; the type in place by not allowing it to be moved out of them. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin module&lt;/code&gt;&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="translated">而是通过控制包装在&lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;包装器中的指针 &lt;code&gt;P&lt;/code&gt; 的行为来防止在类型系统中移动，该包装器通过不允许将其移出类型而将其&amp;ldquo;固定&amp;rdquo;在适当的位置。有关固定的更多信息，请参见&lt;a href=&quot;../pin/index&quot;&gt; &lt;code&gt;pin module&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="3589fb3ebd4ad6821bd6d9b7e8dfdf86bb935287" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ok&lt;/code&gt;, the line &lt;code&gt;test tests::another&lt;/code&gt; shows &lt;code&gt;FAILED&lt;/code&gt;. Two new sections appear between the individual results and the summary: the first section displays the detailed reason for each test failure. In this case, &lt;code&gt;another&lt;/code&gt; failed because it &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt;, which happened on line 10 in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to more easily debug it; we&amp;rsquo;ll talk more about ways to run tests in the &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">而不是 &lt;code&gt;ok&lt;/code&gt; ，行 &lt;code&gt;test tests::another&lt;/code&gt; 显示 &lt;code&gt;FAILED&lt;/code&gt; 。各个结果和摘要之间会出现两个新部分：第一部分显示每个测试失败的详细原因。在这种情况下， &lt;code&gt;another&lt;/code&gt; 失败，因为它对&lt;em&gt;src / lib.rs&lt;/em&gt;文件中的第10行发生了 &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt; 。下一节仅列出所有失败测试的名称，这在有大量测试和大量详细的失败测试输出时很有用。我们可以使用失败测试的名称来运行该测试，以便更轻松地对其进行调试。我们将在&lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;控制测试的运行方式&amp;rdquo;&lt;/a&gt;部分中详细讨论运行测试的方式。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a520d0103dd9e1e65d5d07eb5562a910a387f00" translate="yes" xml:space="preserve">
          <source>Instead of a concrete type for the &lt;code&gt;item&lt;/code&gt; parameter, we specify the &lt;code&gt;impl&lt;/code&gt; keyword and the trait name. This parameter accepts any type that implements the specified trait. In the body of &lt;code&gt;notify&lt;/code&gt;, we can call any methods on &lt;code&gt;item&lt;/code&gt; that come from the &lt;code&gt;Summary&lt;/code&gt; trait, such as &lt;code&gt;summarize&lt;/code&gt;. We can call &lt;code&gt;notify&lt;/code&gt; and pass in any instance of &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt;. Code that calls the function with any other type, such as a &lt;code&gt;String&lt;/code&gt; or an &lt;code&gt;i32&lt;/code&gt;, won&amp;rsquo;t compile because those types don&amp;rsquo;t implement &lt;code&gt;Summary&lt;/code&gt;.</source>
          <target state="translated">我们指定了 &lt;code&gt;impl&lt;/code&gt; 关键字和特征名称，而不是 &lt;code&gt;item&lt;/code&gt; 参数的具体类型。此参数接受实现指定特征的任何类型。在身体 &lt;code&gt;notify&lt;/code&gt; ，我们可以调用任何方法 &lt;code&gt;item&lt;/code&gt; 是来自 &lt;code&gt;Summary&lt;/code&gt; 特质，如 &lt;code&gt;summarize&lt;/code&gt; 。我们可以在 &lt;code&gt;NewsArticle&lt;/code&gt; 或 &lt;code&gt;Tweet&lt;/code&gt; 的任何情况下致电 &lt;code&gt;notify&lt;/code&gt; 和pass 。用其他任何类型（例如 &lt;code&gt;String&lt;/code&gt; 或 &lt;code&gt;i32&lt;/code&gt; )调用该函数的代码都不会编译，因为这些类型没有实现 &lt;code&gt;Summary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c586c2da19eaf29595cd7783a0bdd1aaa4af1f4c" translate="yes" xml:space="preserve">
          <source>Instead of adding the &lt;code&gt;assert!&lt;/code&gt; macro as we&amp;rsquo;ve done here, we could make &lt;code&gt;new&lt;/code&gt; return a &lt;code&gt;Result&lt;/code&gt; like we did with &lt;code&gt;Config::new&lt;/code&gt; in the I/O project in Listing 12-9. But we&amp;rsquo;ve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error. If you&amp;rsquo;re feeling ambitious, try to write a version of &lt;code&gt;new&lt;/code&gt; with the following signature to compare both versions:</source>
          <target state="translated">而不是添加 &lt;code&gt;assert!&lt;/code&gt; 宏，就像清单12-9中I / O项目中的 &lt;code&gt;Config::new&lt;/code&gt; 一样，可以使 &lt;code&gt;new&lt;/code&gt; 返回 &lt;code&gt;Result&lt;/code&gt; 。但是在这种情况下，我们已经决定，尝试创建没有任何线程的线程池应该是不可恢复的错误。如果您有雄心壮志，请尝试编写带有以下签名的 &lt;code&gt;new&lt;/code&gt; 版本以比较两个版本：</target>
        </trans-unit>
        <trans-unit id="9745bfc2f2927dceb9288ed29cf395b852078f44" translate="yes" xml:space="preserve">
          <source>Instead of always calling the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function before the &lt;code&gt;if&lt;/code&gt; blocks, we can define a closure and store the &lt;em&gt;closure&lt;/em&gt; in a variable rather than storing the result of the function call, as shown in Listing 13-5. We can actually move the whole body of &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; within the closure we&amp;rsquo;re introducing here.</source>
          <target state="translated">而不是总是调用 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 的功能之前 &lt;code&gt;if&lt;/code&gt; 块，我们可以定义一个封闭和存储&lt;em&gt;封闭&lt;/em&gt;在一个变量，而不是存储函数调用的结果，如清单13-5英寸 实际上，我们可以在此处介绍的闭包内移动整个 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae67e98f84394870dad9c2dee4383fa199b41a3d" translate="yes" xml:space="preserve">
          <source>Instead of comparing the iterator's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">此函数不是直接比较迭代器的元素，而是比较元素的键（由 &lt;code&gt;f&lt;/code&gt; 确定）。除此之外，它等效于&lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; ; 请参阅其文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="3f4a03c266892c8db13bbe1ed2f70b65c01aa093" translate="yes" xml:space="preserve">
          <source>Instead of comparing the slice's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">此函数不是直接比较切片的元素，而是比较元素的键（由 &lt;code&gt;f&lt;/code&gt; 确定）。除此之外，它等效于&lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; ; 请参阅其文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="ab414c3f0e8d06ac0d388f321dffd0ec64ba1540" translate="yes" xml:space="preserve">
          <source>Instead of defining an inherent implementation on a reference, you could also move the reference inside the implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf669630673f131e83096baf2080a7fff2853dbb" translate="yes" xml:space="preserve">
          <source>Instead of saving the closure in a variable directly, we save a new instance of &lt;code&gt;Cacher&lt;/code&gt; that holds the closure. Then, in each place we want the result, we call the &lt;code&gt;value&lt;/code&gt; method on the &lt;code&gt;Cacher&lt;/code&gt; instance. We can call the &lt;code&gt;value&lt;/code&gt; method as many times as we want, or not call it at all, and the expensive calculation will be run a maximum of once.</source>
          <target state="translated">与其直接将闭包保存在变量中， &lt;code&gt;Cacher&lt;/code&gt; 保存一个保存闭包的新Cacher实例。然后，在每个需要结果的地方，我们在 &lt;code&gt;Cacher&lt;/code&gt; 实例上调用 &lt;code&gt;value&lt;/code&gt; 方法。我们可以根据需要多次调用 &lt;code&gt;value&lt;/code&gt; 方法，或者根本不调用它，而昂贵的计算最多可以运行一次。</target>
        </trans-unit>
        <trans-unit id="007ce9d48190918926ae8e5decfb3ba7fb1ee115" translate="yes" xml:space="preserve">
          <source>Instead of saving the result of the build in the same directory as our code, Cargo stores it in the &lt;em&gt;target/debug&lt;/em&gt; directory.</source>
          <target state="translated">Cargo并未将构建结果与我们的代码保存在同一目录中，而是将其存储在&lt;em&gt;target / debug&lt;/em&gt;目录中。</target>
        </trans-unit>
        <trans-unit id="12c9e09de719f2e7a3f500e0f9b7335d3a4a658d" translate="yes" xml:space="preserve">
          <source>Instead of stopping at &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will instead start again, from the beginning. After iterating again, it will start at the beginning again. And again. And again. Forever.</source>
          <target state="translated">相反，在停止&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，迭代器都将改为重新开始，从一开始。再次迭代后，它将再次从头开始。然后再次。然后再次。永远。</target>
        </trans-unit>
        <trans-unit id="57207c003495c85f3158cd50928c0d6b80c8565c" translate="yes" xml:space="preserve">
          <source>Instead of storing a vector of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances in the thread pool, we&amp;rsquo;ll store instances of the &lt;code&gt;Worker&lt;/code&gt; struct. Each &lt;code&gt;Worker&lt;/code&gt; will store a single &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instance. Then we&amp;rsquo;ll implement a method on &lt;code&gt;Worker&lt;/code&gt; that will take a closure of code to run and send it to the already running thread for execution. We&amp;rsquo;ll also give each worker an &lt;code&gt;id&lt;/code&gt; so we can distinguish between the different workers in the pool when logging or debugging.</source>
          <target state="translated">而不是在线程池中存储 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 实例的向量，我们将存储 &lt;code&gt;Worker&lt;/code&gt; 结构的实例。每个 &lt;code&gt;Worker&lt;/code&gt; 将存储一个单独的 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 实例。然后，我们将在 &lt;code&gt;Worker&lt;/code&gt; 上实现一个方法，该方法将关闭代码以运行并将其发送到已运行的线程中以执行。我们还将为每个工作人员提供一个 &lt;code&gt;id&lt;/code&gt; 以便在记录或调试时可以区分池中的不同工作人员。</target>
        </trans-unit>
        <trans-unit id="e496da216bd15fab37b8868b5d0249983379dbc2" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">代替使用 &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; ，此函数使用给定的 &lt;code&gt;compare&lt;/code&gt; 函数确定两个元素的顺序。除此之外，它等效于&lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; ;请参阅其文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="c10b23d92f193b5b7c4a31db6e9dd35bde4c84df" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">代替使用 &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; ，此函数使用给定的 &lt;code&gt;compare&lt;/code&gt; 函数确定两个元素的顺序。除此之外，它等效于&lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; ;请参阅其文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="78836dae939176c5518d6cb16a8bc88f88e60ed0" translate="yes" xml:space="preserve">
          <source>Instead, the &lt;code&gt;get&lt;/code&gt; method is generic over the type of the underlying key data, called &lt;code&gt;Q&lt;/code&gt; in the method signature above. It states that &lt;code&gt;K&lt;/code&gt; borrows as a &lt;code&gt;Q&lt;/code&gt; by requiring that &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt;. By additionally requiring &lt;code&gt;Q: Hash + Eq&lt;/code&gt;, it signals the requirement that &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; have implementations of the &lt;code&gt;Hash&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; traits that produce identical results.</source>
          <target state="translated">相反， &lt;code&gt;get&lt;/code&gt; 方法在基础密钥数据的类型上是通用的，在上面的方法签名中称为 &lt;code&gt;Q&lt;/code&gt; 。它通过要求 &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt; 声明 &lt;code&gt;K&lt;/code&gt; 作为 &lt;code&gt;Q&lt;/code&gt; 借入。通过额外要求 &lt;code&gt;Q: Hash + Eq&lt;/code&gt; ，它表示要求 &lt;code&gt;K&lt;/code&gt; 和 &lt;code&gt;Q&lt;/code&gt; 具有实现相同结果的 &lt;code&gt;Hash&lt;/code&gt; 和 &lt;code&gt;Eq&lt;/code&gt; 特征的实现。</target>
        </trans-unit>
        <trans-unit id="878f7237ad30bf50b95fb9667897fe778bbcf6bb" translate="yes" xml:space="preserve">
          <source>Instead, we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it&amp;rsquo;s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-10 shows one way to define a &lt;code&gt;Guess&lt;/code&gt; type that will only create an instance of &lt;code&gt;Guess&lt;/code&gt; if the &lt;code&gt;new&lt;/code&gt; function receives a value between 1 and 100.</source>
          <target state="translated">相反，我们可以创建一个新类型并将验证放入函数中以创建该类型的实例，而不是在所有地方重复进行验证。这样，函数在签名中使用新类型并放心使用其接收的值是安全的。清单9-10显示了一种定义 &lt;code&gt;Guess&lt;/code&gt; 类型的方法，该方法仅在 &lt;code&gt;new&lt;/code&gt; 函数接收到1到100之间的值时才创建 &lt;code&gt;Guess&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="4262f2636f484912c23478cb754110e371d9c5c5" translate="yes" xml:space="preserve">
          <source>Instead, we can use nested paths to bring the same items into scope in one line. We do this by specifying the common part of the path, followed by two colons, and then curly brackets around a list of the parts of the paths that differ, as shown in Listing 7-18.</source>
          <target state="translated">相反,我们可以使用嵌套路径,在一行中把相同的项目纳入作用域。我们可以通过指定路径的共同部分,后面跟两个冒号,然后在路径的不同部分列表周围加上大括号来实现,如清单 7-18 所示。</target>
        </trans-unit>
        <trans-unit id="5890f5912d1fb9403515b5a5574c224c2a726c72" translate="yes" xml:space="preserve">
          <source>Instead, we could write this in a shorter way using &lt;code&gt;if let&lt;/code&gt;. The following code behaves the same as the &lt;code&gt;match&lt;/code&gt; in Listing 6-6:</source>
          <target state="translated">相反，我们可以使用 &lt;code&gt;if let&lt;/code&gt; 以更短的方式编写此代码。以下代码的行为 &lt;code&gt;match&lt;/code&gt; 清单6-6中的匹配项相同：</target>
        </trans-unit>
        <trans-unit id="f97c87a1b2b6afb4bd47b58a7850a17ba4dcea9b" translate="yes" xml:space="preserve">
          <source>Instead, we get the following error that talks about lifetimes:</source>
          <target state="translated">相反,我们得到的是下面的错误,说的是寿命。</target>
        </trans-unit>
        <trans-unit id="e71162b50e657665aeaa9b501b8264cb1685df94" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll change our definition of &lt;code&gt;List&lt;/code&gt; to use &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in place of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, as shown in Listing 15-18. Each &lt;code&gt;Cons&lt;/code&gt; variant will now hold a value and an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; pointing to a &lt;code&gt;List&lt;/code&gt;. When we create &lt;code&gt;b&lt;/code&gt;, instead of taking ownership of &lt;code&gt;a&lt;/code&gt;, we&amp;rsquo;ll clone the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that &lt;code&gt;a&lt;/code&gt; is holding, thereby increasing the number of references from one to two and letting &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; share ownership of the data in that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll also clone &lt;code&gt;a&lt;/code&gt; when creating &lt;code&gt;c&lt;/code&gt;, increasing the number of references from two to three. Every time we call &lt;code&gt;Rc::clone&lt;/code&gt;, the reference count to the data within the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; will increase, and the data won&amp;rsquo;t be cleaned up unless there are zero references to it.</source>
          <target state="translated">相反，我们将 &lt;code&gt;List&lt;/code&gt; 的定义更改为使用 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 代替 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ，如清单15-18所示。现在，每个 &lt;code&gt;Cons&lt;/code&gt; 变体将包含一个值和一个指向 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 。当我们创建 &lt;code&gt;b&lt;/code&gt; ，而不是采取的所有权， &lt;code&gt;a&lt;/code&gt; ，我们将克隆 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 是 &lt;code&gt;a&lt;/code&gt; 持有，从而增加了引用的数量从一个增加到两个，让 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的数据的股权在 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 。我们还将在创建 &lt;code&gt;c&lt;/code&gt; 时克隆 &lt;code&gt;a&lt;/code&gt; ，将引用的数量从两个增加到三个。每次我们调用 &lt;code&gt;Rc::clone&lt;/code&gt; ，对 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 数据的引用计数都会增加，除非对该数据的引用为零，否则不会清除该数据。</target>
        </trans-unit>
        <trans-unit id="2890fe24db6f7388a46470ac6834b80784db6337" translate="yes" xml:space="preserve">
          <source>Instructions can execute in a different order from the one we define, due to various reasons:</source>
          <target state="translated">由于各种原因,指令的执行顺序可能与我们定义的顺序不同。</target>
        </trans-unit>
        <trans-unit id="b74294f827b0d4541ba12662271114a470d6d7a4" translate="yes" xml:space="preserve">
          <source>IntErrorKind</source>
          <target state="translated">IntErrorKind</target>
        </trans-unit>
        <trans-unit id="80fb7220d8146322b259aee21dfef8944e427bb7" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow</source>
          <target state="translated">IntErrorKind::borrow</target>
        </trans-unit>
        <trans-unit id="bb7aa40e4b4db6e736d2b09e30f31443f1c9b44c" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow_mut</source>
          <target state="translated">IntErrorKind::borrow_mut</target>
        </trans-unit>
        <trans-unit id="86f2a2b8f3ab0b9d3e18ee8e7279ac3646f5e5b6" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone</source>
          <target state="translated">IntErrorKind::clone</target>
        </trans-unit>
        <trans-unit id="dd987594d4a6731556fb4db2a25b883f8e6e834a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_from</source>
          <target state="translated">IntErrorKind::clone_from</target>
        </trans-unit>
        <trans-unit id="8f1809c6588a2cc665ccd543289e14a938828a70" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_into</source>
          <target state="translated">IntErrorKind::clone_into</target>
        </trans-unit>
        <trans-unit id="a5e2ed2cdfa8d2140437ae0a8783a450793b17a2" translate="yes" xml:space="preserve">
          <source>IntErrorKind::eq</source>
          <target state="translated">IntErrorKind::eq</target>
        </trans-unit>
        <trans-unit id="92fce40d27d225b47d39433e8ff156d8c2c93e18" translate="yes" xml:space="preserve">
          <source>IntErrorKind::fmt</source>
          <target state="translated">IntErrorKind::fmt</target>
        </trans-unit>
        <trans-unit id="cd16b5df7c131824209cf18f2e5abfbebb79b75a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::from</source>
          <target state="translated">IntErrorKind::from</target>
        </trans-unit>
        <trans-unit id="e6625420510ba7fab278784b2593fb38c7566390" translate="yes" xml:space="preserve">
          <source>IntErrorKind::into</source>
          <target state="translated">IntErrorKind::into</target>
        </trans-unit>
        <trans-unit id="9d0115c16bd4f87138d516953bbe461d1bf9ec02" translate="yes" xml:space="preserve">
          <source>IntErrorKind::ne</source>
          <target state="translated">IntErrorKind::ne</target>
        </trans-unit>
        <trans-unit id="14958c3a69f5e70cdde8bcf9555c598ab9bb336b" translate="yes" xml:space="preserve">
          <source>IntErrorKind::to_owned</source>
          <target state="translated">IntErrorKind::to_owned</target>
        </trans-unit>
        <trans-unit id="6415d36e18efe91e53b209d52b6293cb58ff6bfa" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_from</source>
          <target state="translated">IntErrorKind::try_from</target>
        </trans-unit>
        <trans-unit id="03f332b4c41b3659819ff1f646ef37a2e67d10fd" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_into</source>
          <target state="translated">IntErrorKind::try_into</target>
        </trans-unit>
        <trans-unit id="b726776952bee36d5bafae04149385980bc0b309" translate="yes" xml:space="preserve">
          <source>IntErrorKind::type_id</source>
          <target state="translated">IntErrorKind::type_id</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="65424b5083b7bb599ce3d3b760be23e671c074b2" translate="yes" xml:space="preserve">
          <source>Integer Overflow</source>
          <target state="translated">整数溢出</target>
        </trans-unit>
        <trans-unit id="dee2f95e5c81fdaa601cb7ca5b7396c9d7532488" translate="yes" xml:space="preserve">
          <source>Integer Types</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="6977c92d9e82d5b8f471a2623681e1d1d400b4fb" translate="yes" xml:space="preserve">
          <source>Integer and floating point literals are stringified in order to be concatenated.</source>
          <target state="translated">整数和浮点字元被串联起来,以便进行连接。</target>
        </trans-unit>
        <trans-unit id="eea9a8e4af8d6805a657b383a298ba05a67ec8a4" translate="yes" xml:space="preserve">
          <source>Integer is too large to store in target integer type.</source>
          <target state="translated">Integer太大了,无法存储在目标整型中。</target>
        </trans-unit>
        <trans-unit id="25419a68a3cc357926618f13c044ff7b1347aa8b" translate="yes" xml:space="preserve">
          <source>Integer is too small to store in target integer type.</source>
          <target state="translated">Integer太小,无法存储在目标整型中。</target>
        </trans-unit>
        <trans-unit id="13c9f1f069c2155e025409b7880e9bda6c11b765" translate="yes" xml:space="preserve">
          <source>Integer literals</source>
          <target state="translated">整数字数</target>
        </trans-unit>
        <trans-unit id="f64049bb9bdfd33c50813111908ece46c327c630" translate="yes" xml:space="preserve">
          <source>Integer operators will panic when they overflow when compiled in debug mode. The &lt;code&gt;-C debug-assertions&lt;/code&gt; and &lt;code&gt;-C overflow-checks&lt;/code&gt; compiler flags can be used to control this more directly. The following things are considered to be overflow:</source>
          <target state="translated">在调试模式下进行编译时，整数运算符在溢出时会感到恐慌。的 &lt;code&gt;-C debug-assertions&lt;/code&gt; 和 &lt;code&gt;-C overflow-checks&lt;/code&gt; 编译器标记可用于更直接地控制此。以下内容被认为是溢出的：</target>
        </trans-unit>
        <trans-unit id="16d3c89b38e84e433e4fbd3b3a5bad55571258af" translate="yes" xml:space="preserve">
          <source>Integer or Float type</source>
          <target state="translated">整数或浮点型</target>
        </trans-unit>
        <trans-unit id="3a26a4e37ae1b89c4b86a6d96e9ccef63b9ca764" translate="yes" xml:space="preserve">
          <source>Integer overflow</source>
          <target state="translated">整数溢出</target>
        </trans-unit>
        <trans-unit id="60c11385ec83a73512788efd527bda9740331202" translate="yes" xml:space="preserve">
          <source>Integer suffixes</source>
          <target state="translated">整数后缀</target>
        </trans-unit>
        <trans-unit id="f59b20cbbdd5ddf3c9bd85fd552a52f66ae334d9" translate="yes" xml:space="preserve">
          <source>Integer type</source>
          <target state="translated">整数型</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="19f28971f5db0ac7dee3fee9af716d1da8917af3" translate="yes" xml:space="preserve">
          <source>Integer types (u8, i8, u16, i16, usize, isize, etc.).</source>
          <target state="translated">整数类型(u8、i8、u16、i16、usize、isize等)。</target>
        </trans-unit>
        <trans-unit id="a83667e8fbc7d07069b4ce287d78c06adec56630" translate="yes" xml:space="preserve">
          <source>Integers and other types implementing &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; are unaffected by &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">实施&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 的&lt;/a&gt;整数和其他类型不受 &lt;code&gt;drop&lt;/code&gt; 的影响。</target>
        </trans-unit>
        <trans-unit id="036a5d47efaf84af91b96bca27d0e3394108b032" translate="yes" xml:space="preserve">
          <source>Integration Tests</source>
          <target state="translated">集成测试</target>
        </trans-unit>
        <trans-unit id="d9b3c69227b8b09ee6557a63d6eadc1309909958" translate="yes" xml:space="preserve">
          <source>Integration Tests for Binary Crates</source>
          <target state="translated">二进制周转箱的集成测试</target>
        </trans-unit>
        <trans-unit id="22d0f1d4f5d8a4b65c3ed4d1e121eaf3dc6e87d2" translate="yes" xml:space="preserve">
          <source>Intended for use for errors not exposed to the user, where allocating onto the heap (for normal construction via Error::new) is too costly.</source>
          <target state="translated">用于不暴露给用户的错误,在这种情况下,分配到堆上(通过Error::new进行正常构造)的成本太高。</target>
        </trans-unit>
        <trans-unit id="8b67f9d330a2d3ef64e53c30ab32b2a3ac9f06b6" translate="yes" xml:space="preserve">
          <source>Intense! In effect, this error message means that Rust doesn&amp;rsquo;t understand how to add an &lt;code&gt;i8&lt;/code&gt; and an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;, because they&amp;rsquo;re different types. When we have a value of a type like &lt;code&gt;i8&lt;/code&gt; in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; (or whatever type of value we&amp;rsquo;re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</source>
          <target state="translated">激烈！实际上，此错误消息表示Rust不了解如何添加 &lt;code&gt;i8&lt;/code&gt; 和 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; ，因为它们是不同的类型。当我们在Rust 中具有 &lt;code&gt;i8&lt;/code&gt; 之类的值时，编译器将确保我们始终具有有效值。我们可以放心地进行操作，而不必在使用该值之前检查null。只有当我们有一个 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; （或我们正在使用的任何类型的值）时，我们才需要担心可能没有值，并且编译器将确保我们在使用该值之前会处理这种情况。</target>
        </trans-unit>
        <trans-unit id="ffafe2f71610dfdf28d74f6f54bc9015fbb24203" translate="yes" xml:space="preserve">
          <source>Interestingly, the Rust language has &lt;em&gt;very&lt;/em&gt; few concurrency features. Almost every concurrency feature we&amp;rsquo;ve talked about so far in this chapter has been part of the standard library, not the language. Your options for handling concurrency are not limited to the language or the standard library; you can write your own concurrency features or use those written by others.</source>
          <target state="translated">有趣的是，Rust语言&lt;em&gt;几乎&lt;/em&gt;没有并发功能。到目前为止，我们在本章中讨论的几乎所有并发功能都是标准库的一部分，而不是语言的一部分。您处理并发性的选项不仅限于语言或标准库。您可以编写自己的并发功能或使用其他人编写的并发功能。</target>
        </trans-unit>
        <trans-unit id="21bdfe87f76bf3a6413dde02708bb83e04770512" translate="yes" xml:space="preserve">
          <source>Interior Mutability</source>
          <target state="translated">内部突变性</target>
        </trans-unit>
        <trans-unit id="88bf37967a115d0f3e4ede63c58d62ebf4f74d5a" translate="yes" xml:space="preserve">
          <source>Interior Mutability: A Mutable Borrow to an Immutable Value</source>
          <target state="translated">内部互变性。可变的借贷到不可变的价值。</target>
        </trans-unit>
        <trans-unit id="bb56d65f2c6cb59165a8429fad875c4b21a44fc9" translate="yes" xml:space="preserve">
          <source>Interior mutability is required.</source>
          <target state="translated">内部突变性是必须的。</target>
        </trans-unit>
        <trans-unit id="ca7ba6473fcf9f5318db96e54bb8153323ab66d4" translate="yes" xml:space="preserve">
          <source>Internal Representation</source>
          <target state="translated">内部代表</target>
        </trans-unit>
        <trans-unit id="951194525a57d9119eb003c4910a0f82fea56f08" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;a href=&quot;trait.ord#method.max&quot;&gt;&lt;code&gt;Ord::max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf9ba348896a745b094371c98fa0f28a4195e87" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;a href=&quot;trait.ord#method.min&quot;&gt;&lt;code&gt;Ord::min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e983bc961f2f79520b6f7bb3705df394320c6d" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::max&lt;/code&gt;.</source>
          <target state="translated">内部使用 &lt;code&gt;Ord::max&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="944d65bab4f9ee9f9e2c120271148593d01f1819" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::min&lt;/code&gt;.</source>
          <target state="translated">内部使用别名 &lt;code&gt;Ord::min&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="068003ac53324bf3f0b64c29929ac10bbe1c05ab" translate="yes" xml:space="preserve">
          <source>Internet socket addresses consist of an &lt;a href=&quot;enum.ipaddr&quot;&gt;IP address&lt;/a&gt;, a 16-bit port number, as well as possibly some version-dependent additional information. See &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;'s respective documentation for more details.</source>
          <target state="translated">Internet套接字地址由&lt;a href=&quot;enum.ipaddr&quot;&gt;IP地址&lt;/a&gt;，16位端口号以及一些与版本有关的附加信息组成。有关更多详细信息，请参见&lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt;的相应文档。</target>
        </trans-unit>
        <trans-unit id="ff358fd17c71b9310a296d32bf0fad9d3ef93b34" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;src&lt;/code&gt; as having type &lt;code&gt;&amp;amp;U&lt;/code&gt;, and then reads &lt;code&gt;src&lt;/code&gt; without moving the contained value.</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 解释为 &lt;code&gt;&amp;amp;U&lt;/code&gt; 类型，然后读取 &lt;code&gt;src&lt;/code&gt; 而不移动包含的值。</target>
        </trans-unit>
        <trans-unit id="6a36b9396eb19f7860ffbd9cb812832709b1a0ee" translate="yes" xml:space="preserve">
          <source>Interrupted operations can typically be retried.</source>
          <target state="translated">被打断的操作通常可以重试。</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="d937d21f811516b74380ee512b99e31251a84531" translate="yes" xml:space="preserve">
          <source>Into</source>
          <target state="translated">Into</target>
        </trans-unit>
        <trans-unit id="5bfe78f7766048c0532cc66994c73d1126acb835" translate="yes" xml:space="preserve">
          <source>Into::into</source>
          <target state="translated">Into::into</target>
        </trans-unit>
        <trans-unit id="44f9db19d74f7cdef0547d820fed0d75c60f0beb" translate="yes" xml:space="preserve">
          <source>IntoFuture</source>
          <target state="translated">IntoFuture</target>
        </trans-unit>
        <trans-unit id="77f5dd8de42c3fb03062223e3c47c92129133f82" translate="yes" xml:space="preserve">
          <source>IntoInnerError</source>
          <target state="translated">IntoInnerError</target>
        </trans-unit>
        <trans-unit id="3f3157b39d55c6291f5fe8213b30cc7d15253d48" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow</source>
          <target state="translated">IntoInnerError::borrow</target>
        </trans-unit>
        <trans-unit id="8dfa8d9b4ac06c1a6626ce8031f10e6de0dc0387" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow_mut</source>
          <target state="translated">IntoInnerError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7c332dec4b157cd5d25efcbb73292737fbcafa2a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::cause</source>
          <target state="translated">IntoInnerError::cause</target>
        </trans-unit>
        <trans-unit id="824ab9811aae7de9a48a47b240a825897e788412" translate="yes" xml:space="preserve">
          <source>IntoInnerError::description</source>
          <target state="translated">IntoInnerError::description</target>
        </trans-unit>
        <trans-unit id="83d6a8f5f81bfae0852073773b72a21c220d1541" translate="yes" xml:space="preserve">
          <source>IntoInnerError::error</source>
          <target state="translated">IntoInnerError::error</target>
        </trans-unit>
        <trans-unit id="b1804b3db5a18e0f8ea6f6cff9edd76e45db12ed" translate="yes" xml:space="preserve">
          <source>IntoInnerError::fmt</source>
          <target state="translated">IntoInnerError::fmt</target>
        </trans-unit>
        <trans-unit id="74ec382ed3daa2186fca394930d62ea36a8c17d2" translate="yes" xml:space="preserve">
          <source>IntoInnerError::from</source>
          <target state="translated">IntoInnerError::from</target>
        </trans-unit>
        <trans-unit id="f77ca8c3b2a09378cb7ab11a7034bfe301502366" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into</source>
          <target state="translated">IntoInnerError::into</target>
        </trans-unit>
        <trans-unit id="b64935fe113c6776466d9f925b72b58f10a95d0a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into_inner</source>
          <target state="translated">IntoInnerError::into_inner</target>
        </trans-unit>
        <trans-unit id="b98cd1e7eff5f2d406e34cac12fb4fec6a0205d4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::source</source>
          <target state="translated">IntoInnerError::source</target>
        </trans-unit>
        <trans-unit id="b27666ff3803b78aee0d747dc0d776b1f36b641a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::to_string</source>
          <target state="translated">IntoInnerError::to_string</target>
        </trans-unit>
        <trans-unit id="0b54c908cc8363881d303f189af2d3a384fbe644" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_from</source>
          <target state="translated">IntoInnerError::try_from</target>
        </trans-unit>
        <trans-unit id="496358b49c2805d5e6526e43d48129b6eb94e5f4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_into</source>
          <target state="translated">IntoInnerError::try_into</target>
        </trans-unit>
        <trans-unit id="b48124715dd42f1aa190750b7aa9535327b5b2db" translate="yes" xml:space="preserve">
          <source>IntoInnerError::type_id</source>
          <target state="translated">IntoInnerError::type_id</target>
        </trans-unit>
        <trans-unit id="d5bc3a63a8bde6cc5fb0c0c11c8f6e6a2d150f75" translate="yes" xml:space="preserve">
          <source>IntoIter</source>
          <target state="translated">IntoIter</target>
        </trans-unit>
        <trans-unit id="169272921e3355905d2215419cf69783d5e1115d" translate="yes" xml:space="preserve">
          <source>IntoIter::all</source>
          <target state="translated">IntoIter::all</target>
        </trans-unit>
        <trans-unit id="a15574f60107e9d0464eff7cacee4bccf74dd72e" translate="yes" xml:space="preserve">
          <source>IntoIter::any</source>
          <target state="translated">IntoIter::any</target>
        </trans-unit>
        <trans-unit id="51c36bf4138559f11f65b74500f686e06c1f07c6" translate="yes" xml:space="preserve">
          <source>IntoIter::as_mut_slice</source>
          <target state="translated">IntoIter::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="375d884ce90ecd76e63b6eebc5d52f38165f98ea" translate="yes" xml:space="preserve">
          <source>IntoIter::as_slice</source>
          <target state="translated">IntoIter::as_slice</target>
        </trans-unit>
        <trans-unit id="945728e84b93878ccde99bc6b6c902e3add25ce9" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow</source>
          <target state="translated">IntoIter::borrow</target>
        </trans-unit>
        <trans-unit id="4db752fa4ec7a9c0d095aaf0baac141df030f531" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow_mut</source>
          <target state="translated">IntoIter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="aaf973384105c3d31f532c4ad4e6dc925ca8038e" translate="yes" xml:space="preserve">
          <source>IntoIter::by_ref</source>
          <target state="translated">IntoIter::by_ref</target>
        </trans-unit>
        <trans-unit id="bcd8f637007c65386e7e2794c338143218170c6f" translate="yes" xml:space="preserve">
          <source>IntoIter::chain</source>
          <target state="translated">IntoIter::chain</target>
        </trans-unit>
        <trans-unit id="4b7971718173fafccbf11a50c2db440035e10f18" translate="yes" xml:space="preserve">
          <source>IntoIter::clone</source>
          <target state="translated">IntoIter::clone</target>
        </trans-unit>
        <trans-unit id="cdb70f02920a7096b80eae8222a39e9acc9946ce" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_from</source>
          <target state="translated">IntoIter::clone_from</target>
        </trans-unit>
        <trans-unit id="a82a0721b8481c0815dcd502e84574a2073e6632" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_into</source>
          <target state="translated">IntoIter::clone_into</target>
        </trans-unit>
        <trans-unit id="50371856061d6c57455d0ce1dfd33e8f9cb33e2b" translate="yes" xml:space="preserve">
          <source>IntoIter::cloned</source>
          <target state="translated">IntoIter::cloned</target>
        </trans-unit>
        <trans-unit id="e8ad516621215eb3804081635021e01bb0d15b51" translate="yes" xml:space="preserve">
          <source>IntoIter::cmp</source>
          <target state="translated">IntoIter::cmp</target>
        </trans-unit>
        <trans-unit id="8fbe1060e2b348d75cd8e260134f4152fb629580" translate="yes" xml:space="preserve">
          <source>IntoIter::collect</source>
          <target state="translated">IntoIter::collect</target>
        </trans-unit>
        <trans-unit id="49b1597675bf50c85b1e156757a3fba15d6379b2" translate="yes" xml:space="preserve">
          <source>IntoIter::copied</source>
          <target state="translated">IntoIter::copied</target>
        </trans-unit>
        <trans-unit id="1b07d7fdfbcbc77dd6f739fc3349c3f2c936082e" translate="yes" xml:space="preserve">
          <source>IntoIter::count</source>
          <target state="translated">IntoIter::count</target>
        </trans-unit>
        <trans-unit id="abc24391b60331e5b16547b639bace5c08a577cf" translate="yes" xml:space="preserve">
          <source>IntoIter::cycle</source>
          <target state="translated">IntoIter::cycle</target>
        </trans-unit>
        <trans-unit id="076c1a1b603e193e4eb4e0757f8c8cf292b8dfb5" translate="yes" xml:space="preserve">
          <source>IntoIter::drop</source>
          <target state="translated">IntoIter::drop</target>
        </trans-unit>
        <trans-unit id="c4d617218636a45df4ca846f67499ffba56d0009" translate="yes" xml:space="preserve">
          <source>IntoIter::enumerate</source>
          <target state="translated">IntoIter::enumerate</target>
        </trans-unit>
        <trans-unit id="203a6dcfb8a13fd0add782bc832058504307c28c" translate="yes" xml:space="preserve">
          <source>IntoIter::eq</source>
          <target state="translated">IntoIter::eq</target>
        </trans-unit>
        <trans-unit id="c908d336a9125db6fbd5e895b62999e14ef83fab" translate="yes" xml:space="preserve">
          <source>IntoIter::filter</source>
          <target state="translated">IntoIter::filter</target>
        </trans-unit>
        <trans-unit id="dffdf83b64aeaec0f8093868f1a7bbb32780e9ca" translate="yes" xml:space="preserve">
          <source>IntoIter::filter_map</source>
          <target state="translated">IntoIter::filter_map</target>
        </trans-unit>
        <trans-unit id="ab410a5d7b7cbc92b7134e524269b1fa848fc30b" translate="yes" xml:space="preserve">
          <source>IntoIter::find</source>
          <target state="translated">IntoIter::find</target>
        </trans-unit>
        <trans-unit id="27ee1265a09c796da003def69a36560ceff2b181" translate="yes" xml:space="preserve">
          <source>IntoIter::find_map</source>
          <target state="translated">IntoIter::find_map</target>
        </trans-unit>
        <trans-unit id="eddd95067e023ebec6158e4fd0749c395bbce3b5" translate="yes" xml:space="preserve">
          <source>IntoIter::flat_map</source>
          <target state="translated">IntoIter::flat_map</target>
        </trans-unit>
        <trans-unit id="24f22711986263a8d0e02c113bb93328c331ce4c" translate="yes" xml:space="preserve">
          <source>IntoIter::flatten</source>
          <target state="translated">IntoIter::flatten</target>
        </trans-unit>
        <trans-unit id="e538b5a92b4ad8916bfeef8710693a5e5266e987" translate="yes" xml:space="preserve">
          <source>IntoIter::fmt</source>
          <target state="translated">IntoIter::fmt</target>
        </trans-unit>
        <trans-unit id="d818332c13e9dac3c39cfd50a50265cfaea983ac" translate="yes" xml:space="preserve">
          <source>IntoIter::fold</source>
          <target state="translated">IntoIter::fold</target>
        </trans-unit>
        <trans-unit id="ebce24dad77f86422316868125c1ce1b1376c47d" translate="yes" xml:space="preserve">
          <source>IntoIter::for_each</source>
          <target state="translated">IntoIter::for_each</target>
        </trans-unit>
        <trans-unit id="63d5fee827e27caa7f9e5b809ff35ace75693193" translate="yes" xml:space="preserve">
          <source>IntoIter::from</source>
          <target state="translated">IntoIter::from</target>
        </trans-unit>
        <trans-unit id="d10213dec7222893569b1e32a4313a41a6aaecb0" translate="yes" xml:space="preserve">
          <source>IntoIter::fuse</source>
          <target state="translated">IntoIter::fuse</target>
        </trans-unit>
        <trans-unit id="2c8a9a1c31b0f9b10030a7c20db1f8dae0614589" translate="yes" xml:space="preserve">
          <source>IntoIter::ge</source>
          <target state="translated">IntoIter::ge</target>
        </trans-unit>
        <trans-unit id="104a30acd770869920244c22e6c1a727cdee6dae" translate="yes" xml:space="preserve">
          <source>IntoIter::gt</source>
          <target state="translated">IntoIter::gt</target>
        </trans-unit>
        <trans-unit id="ab8d2e8c457b63ffae7769711a00e1a87b2a56eb" translate="yes" xml:space="preserve">
          <source>IntoIter::inspect</source>
          <target state="translated">IntoIter::inspect</target>
        </trans-unit>
        <trans-unit id="c0c222348756fc6dca4ff42b109916a4d5aa1041" translate="yes" xml:space="preserve">
          <source>IntoIter::into</source>
          <target state="translated">IntoIter::into</target>
        </trans-unit>
        <trans-unit id="00014741248dda82e6a92af65524e8bc527d5270" translate="yes" xml:space="preserve">
          <source>IntoIter::into_iter</source>
          <target state="translated">IntoIter::into_iter</target>
        </trans-unit>
        <trans-unit id="5136432030a36a1b23033a0d753895604b4149ac" translate="yes" xml:space="preserve">
          <source>IntoIter::is_empty</source>
          <target state="translated">IntoIter::is_empty</target>
        </trans-unit>
        <trans-unit id="cf791dcb18f1b7d93faf9bdd64add013d8076499" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted</source>
          <target state="translated">IntoIter::is_sorted</target>
        </trans-unit>
        <trans-unit id="5c6daaffe95fe047d7827bfe50f3fd317d40c563" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by</source>
          <target state="translated">IntoIter::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="9f7c1ed14fd6d8b0ea5624c99850ff1ba4ac8f4c" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by_key</source>
          <target state="translated">IntoIter::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="e39349aed40aa6fcfd458252b9c0e111206b7d16" translate="yes" xml:space="preserve">
          <source>IntoIter::last</source>
          <target state="translated">IntoIter::last</target>
        </trans-unit>
        <trans-unit id="965a66efe77546764045f5f96e42028dbb177b19" translate="yes" xml:space="preserve">
          <source>IntoIter::le</source>
          <target state="translated">IntoIter::le</target>
        </trans-unit>
        <trans-unit id="22be990e0e582b87c69cd8c67de2cfd9920d77cd" translate="yes" xml:space="preserve">
          <source>IntoIter::len</source>
          <target state="translated">IntoIter::len</target>
        </trans-unit>
        <trans-unit id="8440a9053eaee6916d3cec75da248b9b8410507f" translate="yes" xml:space="preserve">
          <source>IntoIter::lt</source>
          <target state="translated">IntoIter::lt</target>
        </trans-unit>
        <trans-unit id="e3e2d404675aba8735567f55b57c588d0c0c351a" translate="yes" xml:space="preserve">
          <source>IntoIter::map</source>
          <target state="translated">IntoIter::map</target>
        </trans-unit>
        <trans-unit id="181026e325e14528b026dfe68716b7b26ecd2d2d" translate="yes" xml:space="preserve">
          <source>IntoIter::max</source>
          <target state="translated">IntoIter::max</target>
        </trans-unit>
        <trans-unit id="dd9a47d87f8a0e2db21c65ae146ddcfdf6e0f952" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by</source>
          <target state="translated">IntoIter::max_by</target>
        </trans-unit>
        <trans-unit id="32723c1a1514dde11ed20c922fc56eff6425fcc8" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by_key</source>
          <target state="translated">IntoIter::max_by_key</target>
        </trans-unit>
        <trans-unit id="c528958b5dc23955203383c2f66331a5a91f6f86" translate="yes" xml:space="preserve">
          <source>IntoIter::min</source>
          <target state="translated">IntoIter::min</target>
        </trans-unit>
        <trans-unit id="390fd21e220a5da046b34c827add37c65b895f97" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by</source>
          <target state="translated">IntoIter::min_by</target>
        </trans-unit>
        <trans-unit id="05a738d3c9912a808e8d6c464d2a7c6d5e602efc" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by_key</source>
          <target state="translated">IntoIter::min_by_key</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
