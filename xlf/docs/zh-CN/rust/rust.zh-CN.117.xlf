<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2c5134e463153b73435701f263a503592ab3d53a" translate="yes" xml:space="preserve">
          <source>Go into the &lt;em&gt;hello_cargo&lt;/em&gt; directory and list the files. You&amp;rsquo;ll see that Cargo has generated two files and one directory for us: a &lt;em&gt;Cargo.toml&lt;/em&gt; file and a &lt;em&gt;src&lt;/em&gt; directory with a &lt;em&gt;main.rs&lt;/em&gt; file inside. It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file.</source>
          <target state="translated">进入&lt;em&gt;hello_cargo&lt;/em&gt;目录并列出文件。您会看到Cargo为我们生成了两个文件和一个目录：一个&lt;em&gt;Cargo.toml&lt;/em&gt;文件和一个其中带有&lt;em&gt;main.rs&lt;/em&gt;文件的&lt;em&gt;src&lt;/em&gt;目录。它还已经初始化了一个新的Git存储库以及&lt;em&gt;.gitignore&lt;/em&gt;文件。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50e6889164bb8054d882b924cda71582b6d6d180" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6849789947c3320fec7645aaddce84614976c34" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;有限：</target>
        </trans-unit>
        <trans-unit id="62320f24d2e67e3a996b5eb69a47e8e61772abe1" translate="yes" xml:space="preserve">
          <source>Graceful Shutdown and Cleanup</source>
          <target state="translated">优雅的关机和清理</target>
        </trans-unit>
        <trans-unit id="14b567b853879017732fc7e6b51b1225fb2590d3" translate="yes" xml:space="preserve">
          <source>Gradual initialization of an &lt;code&gt;UnsafeCell&lt;/code&gt; requires &lt;code&gt;raw_get&lt;/code&gt;, as calling &lt;code&gt;get&lt;/code&gt; would require creating a reference to uninitialized data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="78e61d853fc7dbe21e195185b06132c0a0b3267c" translate="yes" xml:space="preserve">
          <source>Great! The code read and then printed the contents of the file. But the code has a few flaws. The &lt;code&gt;main&lt;/code&gt; function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we&amp;rsquo;re not handling errors as well as we could. The program is still small, so these flaws aren&amp;rsquo;t a big problem, but as the program grows, it will be harder to fix them cleanly. It&amp;rsquo;s good practice to begin refactoring early on when developing a program, because it&amp;rsquo;s much easier to refactor smaller amounts of code. We&amp;rsquo;ll do that next.</source>
          <target state="translated">大！代码读取并打印了文件的内容。但是代码有一些缺陷。的 &lt;code&gt;main&lt;/code&gt; 功能有多重责任：通常，功能更清晰，更易于维护，如果每个功能只负责一个想法。另一个问题是我们没有尽力处理错误。该程序仍然很小，因此这些缺陷并不是什么大问题，但是随着程序的发展，将很难对其进行彻底修复。在开发程序时尽早开始重构是个好习惯，因为重构少量代码要容易得多。接下来，我们将做。</target>
        </trans-unit>
        <trans-unit id="24a6854de536fe8272a59608dce7cfe696deeaaa" translate="yes" xml:space="preserve">
          <source>Great! They passed. Now, let&amp;rsquo;s call the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function from the &lt;code&gt;run&lt;/code&gt; function. First, we&amp;rsquo;ll add a configuration option to the &lt;code&gt;Config&lt;/code&gt; struct to switch between case-sensitive and case-insensitive search. Adding this field will cause compiler errors because we aren&amp;rsquo;t initializing this field anywhere yet:</source>
          <target state="translated">大！他们通过了。现在，让我们从 &lt;code&gt;run&lt;/code&gt; 函数中调用新的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数。首先，我们将配置选项添加到 &lt;code&gt;Config&lt;/code&gt; 结构中，以在区分大小写的搜索和不区分大小写的搜索之间切换。添加此字段将导致编译器错误，因为我们尚未在任何地方初始化此字段：</target>
        </trans-unit>
        <trans-unit id="64d373f5a71955e4f9210539868f04851ae696bb" translate="yes" xml:space="preserve">
          <source>Great! This error tells us we need a &lt;code&gt;ThreadPool&lt;/code&gt; type or module, so we&amp;rsquo;ll build one now. Our &lt;code&gt;ThreadPool&lt;/code&gt; implementation will be independent of the kind of work our web server is doing. So, let&amp;rsquo;s switch the &lt;code&gt;hello&lt;/code&gt; crate from a binary crate to a library crate to hold our &lt;code&gt;ThreadPool&lt;/code&gt; implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</source>
          <target state="translated">大！这个错误告诉我们我们需要一个 &lt;code&gt;ThreadPool&lt;/code&gt; 类型或模块，因此我们现在将构建一个。我们的 &lt;code&gt;ThreadPool&lt;/code&gt; 实现将独立于Web服务器正在执行的工作。因此，让我们将 &lt;code&gt;hello&lt;/code&gt; 板条箱从二进制板条箱切换到库板条箱以容纳 &lt;code&gt;ThreadPool&lt;/code&gt; 实现。更改为库箱后，我们还可以将单独的线程池库用于我们想要使用线程池进行的任何工作，而不仅仅是服务于Web请求。</target>
        </trans-unit>
        <trans-unit id="99b891e6f196f47f49f63f0b20ce223eaba55683" translate="yes" xml:space="preserve">
          <source>Great! This output is much friendlier for our users.</source>
          <target state="translated">厉害了! 这样的输出对我们的用户来说更友好了。</target>
        </trans-unit>
        <trans-unit id="2929f4d3537f13046a6a6654b391acff14ad5b53" translate="yes" xml:space="preserve">
          <source>Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we&amp;rsquo;ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we&amp;rsquo;ll ignore that situation and work on adding file-reading capabilities instead.</source>
          <target state="translated">很好，程序正在运行！我们需要的参数值将保存到正确的变量中。稍后，我们将添加一些错误处理以处理某些潜在的错误情况，例如当用户不提供参数时；目前，我们将忽略这种情况，而改为添加文件读取功能。</target>
        </trans-unit>
        <trans-unit id="c5f93da0af9ef56fee44e82925405c317fbf7afc" translate="yes" xml:space="preserve">
          <source>Great, the test fails, exactly as we expected. Let&amp;rsquo;s get the test to pass!</source>
          <target state="translated">太好了，测试失败了，完全符合我们的预期。让测试通过！</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">大于</target>
        </trans-unit>
        <trans-unit id="cc21fdb8f5e4e1d5b5c729ed455db20a348682c5" translate="yes" xml:space="preserve">
          <source>Greater than comparison</source>
          <target state="translated">大于比较</target>
        </trans-unit>
        <trans-unit id="a2919540599e9df0beb579ca8d46bdc142657611" translate="yes" xml:space="preserve">
          <source>Greater than or equal to</source>
          <target state="translated">大于或等于</target>
        </trans-unit>
        <trans-unit id="17e61387621cb5a7a3632ffc26d2a8ab3f16e769" translate="yes" xml:space="preserve">
          <source>Greater than or equal to comparison</source>
          <target state="translated">大于或等于比较</target>
        </trans-unit>
        <trans-unit id="d667800b5ed7b98aa0dde326047666b10d805fc3" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">两个 &lt;code&gt;Arc&lt;/code&gt; 的大于比较。</target>
        </trans-unit>
        <trans-unit id="3f06e7136cc69760b0d1c2aa5adb37088b0a0311" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">两个 &lt;code&gt;Rc&lt;/code&gt; 大于比较。</target>
        </trans-unit>
        <trans-unit id="f464c4ed26773e9c5252581a89a104e8de23d490" translate="yes" xml:space="preserve">
          <source>Greek letters &quot;&amp;alpha;&quot; &quot;&amp;beta;&quot; &quot;&amp;gamma;&quot; &quot;&amp;delta;&quot; stand for potentially empty token-tree sequences. (However, the Greek letter &quot;&amp;epsilon;&quot; (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)</source>
          <target state="translated">希腊字母&amp;ldquo;&amp;alpha;&amp;rdquo;，&amp;ldquo;&amp;beta;&amp;rdquo;，&amp;ldquo;&amp;gamma;&amp;rdquo;，&amp;ldquo;&amp;delta;&amp;rdquo;代表可能为空的令牌树序列。（但是，希腊字母&amp;ldquo;&amp;epsilon;&amp;rdquo;（epsilon）在表示中具有特殊作用，并不代表令牌树序列。）</target>
        </trans-unit>
        <trans-unit id="90accf7e4de3f988bebb9b0fcc656094cc41c05f" translate="yes" xml:space="preserve">
          <source>Group expression attributes</source>
          <target state="translated">集团表达式属性</target>
        </trans-unit>
        <trans-unit id="ef7a9bb1a692431ae6d8dff02418977a8053e1b7" translate="yes" xml:space="preserve">
          <source>Grouped expressions</source>
          <target state="translated">分组表达式</target>
        </trans-unit>
        <trans-unit id="13970f54032da4ae14dbff0318664d8c8f7ae9de" translate="yes" xml:space="preserve">
          <source>Grouped patterns</source>
          <target state="translated">分组模式</target>
        </trans-unit>
        <trans-unit id="990b2d14bf2da723821496eca71bc9a4f287e41e" translate="yes" xml:space="preserve">
          <source>Grouping Configuration Values</source>
          <target state="translated">分组配置值</target>
        </trans-unit>
        <trans-unit id="ad08922b155e0f0ecfa878359b6bdba11de6fcc5" translate="yes" xml:space="preserve">
          <source>Groups items</source>
          <target state="translated">分组项目</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="e72af43a28130c6f52db641d01a37aabf78c282e" translate="yes" xml:space="preserve">
          <source>Guarantees</source>
          <target state="translated">Guarantees</target>
        </trans-unit>
        <trans-unit id="643a27fb6062be0d6499f01fc4bde0f4334880b4" translate="yes" xml:space="preserve">
          <source>Guidance on which license is appropriate for your project is beyond the scope of this book. Many people in the Rust community license their projects in the same way as Rust by using a dual license of &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt;. This practice demonstrates that you can also specify multiple license identifiers separated by &lt;code&gt;OR&lt;/code&gt; to have multiple licenses for your project.</source>
          <target state="translated">关于哪种许可证适合您的项目的指导超出了本书的范围。Rust社区中的许多人都使用 &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt; 的双重许可以与Rust相同的方式许可他们的项目。此实践表明，您还可以指定多个许可证标识符，并用 &lt;code&gt;OR&lt;/code&gt; 分隔，以为您的项目拥有多个许可证。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="5662999f81a9d63d43963dff643c8f2e0db48c56" translate="yes" xml:space="preserve">
          <source>Guidelines for Error Handling</source>
          <target state="translated">错误处理指南</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="1a486ce8f36726233061ec65b3f6bda493fd48c9" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;&lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;]</source>
          <target state="translated">16进制数字：[ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; - &lt;code&gt;F&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="e195a9555456bea0e92fe340c3ae06ff639810c6" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</source>
          <target state="translated">HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5f9c36747e4699e63511061195cedb992801b9d3" translate="yes" xml:space="preserve">
          <source>HEX_LITERAL :</source>
          <target state="translated">HEX_LITERAL :</target>
        </trans-unit>
        <trans-unit id="85b770e7ec266276f5de99706626234eb555c7b0" translate="yes" xml:space="preserve">
          <source>HTTP is a text-based protocol, and a request takes this format:</source>
          <target state="translated">HTTP是一种基于文本的协议,请求采用这种格式。</target>
        </trans-unit>
        <trans-unit id="3c47a723a85c131d97bf2d4bd392d2947fe77f70" translate="yes" xml:space="preserve">
          <source>Had &lt;code&gt;path&lt;/code&gt; contained invalid unicode, the &lt;code&gt;to_string_lossy&lt;/code&gt; call might have returned &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 包含无效的unicode，则 &lt;code&gt;to_string_lossy&lt;/code&gt; 调用可能返回了 &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ee4aa46e82881f4a75375987b71c3131634f94f" translate="yes" xml:space="preserve">
          <source>Handling Errors Returned from &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;</source>
          <target state="translated">处理返回的错误从 &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; 在 &lt;code&gt;main&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="187689d6fbeb450bd6ea4e652dae8dbfd0f10e3e" translate="yes" xml:space="preserve">
          <source>Handling I/O</source>
          <target state="translated">处理I/O</target>
        </trans-unit>
        <trans-unit id="f85b58414971efcc7eee439597523a8f745698cd" translate="yes" xml:space="preserve">
          <source>Handling Invalid Input</source>
          <target state="translated">处理无效输入</target>
        </trans-unit>
        <trans-unit id="99ae89ce9129c070f0e68c272cb53e5ebe7623fe" translate="yes" xml:space="preserve">
          <source>Handling Multiple Conditions with &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt; 处理多个条件</target>
        </trans-unit>
        <trans-unit id="59aadebe3071fa59f50f2105cef14ad03fb21914" translate="yes" xml:space="preserve">
          <source>Handling Potential Failure with the &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; Type</source>
          <target state="translated">使用 &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; 类型处理潜在故障</target>
        </trans-unit>
        <trans-unit id="90b8d168f939ff8e48ed694781964a3efae61546" translate="yes" xml:space="preserve">
          <source>Handling concurrent programming safely and efficiently is another of Rust&amp;rsquo;s major goals. &lt;em&gt;Concurrent programming&lt;/em&gt;, where different parts of a program execute independently, and &lt;em&gt;parallel programming&lt;/em&gt;, where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors. Historically, programming in these contexts has been difficult and error prone: Rust hopes to change that.</source>
          <target state="translated">安全有效地处理并发编程是Rust的另一个主要目标。&lt;em&gt;并发编程&lt;/em&gt;，其中一个程序的不同部分独立地执行，以及&lt;em&gt;并行编程&lt;/em&gt;，其中一个程序的不同部分执行的同时，随着越来越多的计算机把他们的多处理器的优点变得越来越重要。从历史上看，在这些情况下进行编程一直很困难且容易出错：Rust希望改变这种情况。</target>
        </trans-unit>
        <trans-unit id="8f7b16e3844bb9bbaa86ba42b5bf793b3b5747f5" translate="yes" xml:space="preserve">
          <source>Handling errors (&lt;a href=&quot;ch09-00-error-handling&quot;&gt;Chapter 9&lt;/a&gt;)</source>
          <target state="translated">处理错误（&lt;a href=&quot;ch09-00-error-handling&quot;&gt;第9章&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a8a516b582d8ee827caa06b852f0927dd7ea1aa9" translate="yes" xml:space="preserve">
          <source>Handling the error if &lt;code&gt;run&lt;/code&gt; returns an error</source>
          <target state="translated">如果 &lt;code&gt;run&lt;/code&gt; 返回错误，则处理错误</target>
        </trans-unit>
        <trans-unit id="9779c3f0bfcc6c7bd84ac8dc1d7d0faaf0886246" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;OnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59701e203928fde4afc37f856c0fe1389efbf77a" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;SyncOnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605c9af0dc3550ddfefeee4d42138a7f1adc2bd1" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f36c92a5a7396e8365dbdfe793e5eef4ad9431" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">同时具有&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;的效果：对于负载，它使用&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;排序。对于商店，它使用&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;顺序。</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="d16b2d08d75092ccdbc53063c23e2c3fe71d7f34" translate="yes" xml:space="preserve">
          <source>Hash Maps and Ownership</source>
          <target state="translated">散列图和所有权</target>
        </trans-unit>
        <trans-unit id="49d09ebb7291bff93c80ac3f381f55fe8a3c4cbf" translate="yes" xml:space="preserve">
          <source>Hash a raw pointer.</source>
          <target state="translated">哈希一个原始指针。</target>
        </trans-unit>
        <trans-unit id="6c5bfe7d7f5d3cec7864d666ab67d3faebb741c0" translate="yes" xml:space="preserve">
          <source>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, in a game, you could keep track of each team&amp;rsquo;s score in a hash map in which each key is a team&amp;rsquo;s name and the values are each team&amp;rsquo;s score. Given a team name, you can retrieve its score.</source>
          <target state="translated">当您不希望像使用向量那样使用索引来查找数据时，而是通过使用可以是任何类型的键来查找数据时，哈希映射很有用。例如，在游戏中，您可以在哈希图中跟踪每个团队的得分，其中每个键是一个团队的名称，值是每个团队的得分。给定一个团队名称，您可以检索其得分。</target>
        </trans-unit>
        <trans-unit id="f26fb9fba1361d959b70bbd8e0907090c8a67651" translate="yes" xml:space="preserve">
          <source>Hash memoization</source>
          <target state="translated">散列记忆</target>
        </trans-unit>
        <trans-unit id="1ca569e43628039695db4d117d37cb0433c51032" translate="yes" xml:space="preserve">
          <source>Hash::hash</source>
          <target state="translated">Hash::hash</target>
        </trans-unit>
        <trans-unit id="bac71fb916a479ac2558a2194819bf301931ca8b" translate="yes" xml:space="preserve">
          <source>Hash::hash_slice</source>
          <target state="translated">Hash::hash_slice</target>
        </trans-unit>
        <trans-unit id="ba62d7b8d0b157f714c6a6132554b38789c6ada5" translate="yes" xml:space="preserve">
          <source>HashMap</source>
          <target state="translated">HashMap</target>
        </trans-unit>
        <trans-unit id="fb7d8a23eadd1e4ece9d9a20a984c6c31289cb8b" translate="yes" xml:space="preserve">
          <source>HashMap::borrow</source>
          <target state="translated">HashMap::borrow</target>
        </trans-unit>
        <trans-unit id="610c174a39c8908fe163a07919237940fc37c1ca" translate="yes" xml:space="preserve">
          <source>HashMap::borrow_mut</source>
          <target state="translated">HashMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5b073a19c1d948d2ff7ea181c3e6faa47ac950b7" translate="yes" xml:space="preserve">
          <source>HashMap::capacity</source>
          <target state="translated">HashMap::capacity</target>
        </trans-unit>
        <trans-unit id="290ef182063e668dbc9d6f81f0f99bd696eaa3ad" translate="yes" xml:space="preserve">
          <source>HashMap::clear</source>
          <target state="translated">HashMap::clear</target>
        </trans-unit>
        <trans-unit id="4504d7762629b3f09d106b8b2c49316387f83111" translate="yes" xml:space="preserve">
          <source>HashMap::clone</source>
          <target state="translated">HashMap::clone</target>
        </trans-unit>
        <trans-unit id="755ecc8e2fe0d53bf8d40f09d15dc41f5c72dee3" translate="yes" xml:space="preserve">
          <source>HashMap::clone_from</source>
          <target state="translated">HashMap::clone_from</target>
        </trans-unit>
        <trans-unit id="18149fd5a2f0ddb0a754ee5b20ae060122824af4" translate="yes" xml:space="preserve">
          <source>HashMap::clone_into</source>
          <target state="translated">HashMap::clone_into</target>
        </trans-unit>
        <trans-unit id="c981dd589a66a9541ad1bd942f956a943a21c776" translate="yes" xml:space="preserve">
          <source>HashMap::contains_key</source>
          <target state="translated">HashMap::contains_key</target>
        </trans-unit>
        <trans-unit id="6790c064706283f72985a00fd5d63757494362ee" translate="yes" xml:space="preserve">
          <source>HashMap::default</source>
          <target state="translated">HashMap::default</target>
        </trans-unit>
        <trans-unit id="ef89e29aa59c76930b39d07bb7c27f4f62ca4bc9" translate="yes" xml:space="preserve">
          <source>HashMap::drain</source>
          <target state="translated">HashMap::drain</target>
        </trans-unit>
        <trans-unit id="5c70bb5f39da25e4a3243cd372f9722cdd0aaa06" translate="yes" xml:space="preserve">
          <source>HashMap::entry</source>
          <target state="translated">HashMap::entry</target>
        </trans-unit>
        <trans-unit id="16580b886dde904eb2189a50aaa2ec8e66754a76" translate="yes" xml:space="preserve">
          <source>HashMap::eq</source>
          <target state="translated">HashMap::eq</target>
        </trans-unit>
        <trans-unit id="006972122bed4c52275751aaa6b1a76aa26a72f6" translate="yes" xml:space="preserve">
          <source>HashMap::extend</source>
          <target state="translated">HashMap::extend</target>
        </trans-unit>
        <trans-unit id="eef27e5aeaaee7ca97ef32c4174c3b7aefbfc638" translate="yes" xml:space="preserve">
          <source>HashMap::fmt</source>
          <target state="translated">HashMap::fmt</target>
        </trans-unit>
        <trans-unit id="2bac685119eec98678bcc3e2df09e34b76b251fb" translate="yes" xml:space="preserve">
          <source>HashMap::from</source>
          <target state="translated">HashMap::from</target>
        </trans-unit>
        <trans-unit id="23702b4af8c6608c05d1fc72b700af47889b23e4" translate="yes" xml:space="preserve">
          <source>HashMap::from_iter</source>
          <target state="translated">HashMap::from_iter</target>
        </trans-unit>
        <trans-unit id="688fd04b9fb0128d305e248d2f3d8f8222392c9c" translate="yes" xml:space="preserve">
          <source>HashMap::get</source>
          <target state="translated">HashMap::get</target>
        </trans-unit>
        <trans-unit id="ecd394b5e97d505b5180c88396d32eb04f7a2ef5" translate="yes" xml:space="preserve">
          <source>HashMap::get_key_value</source>
          <target state="translated">HashMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="59fd726634d31c7b61261668c05f7485bf9decb1" translate="yes" xml:space="preserve">
          <source>HashMap::get_mut</source>
          <target state="translated">HashMap::get_mut</target>
        </trans-unit>
        <trans-unit id="9e2f5e352b69c23e1f8634441216dbbc589410a2" translate="yes" xml:space="preserve">
          <source>HashMap::hasher</source>
          <target state="translated">HashMap::hasher</target>
        </trans-unit>
        <trans-unit id="977407424016d1150ed5a54f71aa720d8b5fc1e0" translate="yes" xml:space="preserve">
          <source>HashMap::index</source>
          <target state="translated">HashMap::index</target>
        </trans-unit>
        <trans-unit id="575b9b99b8b6536e98f82916772ec179324759de" translate="yes" xml:space="preserve">
          <source>HashMap::insert</source>
          <target state="translated">HashMap::insert</target>
        </trans-unit>
        <trans-unit id="4241974ff3713d57ec86ed4fb2960fb964b4c28f" translate="yes" xml:space="preserve">
          <source>HashMap::into</source>
          <target state="translated">HashMap::into</target>
        </trans-unit>
        <trans-unit id="2ee397e85e03d2df5163ed8c1f36f63a8275c934" translate="yes" xml:space="preserve">
          <source>HashMap::into_iter</source>
          <target state="translated">HashMap::into_iter</target>
        </trans-unit>
        <trans-unit id="a649d7141d86759b290a9b727d47ad161b114361" translate="yes" xml:space="preserve">
          <source>HashMap::is_empty</source>
          <target state="translated">HashMap::is_empty</target>
        </trans-unit>
        <trans-unit id="cfdbb20825a41950e4f6625ab41ffc0a12e6cfd4" translate="yes" xml:space="preserve">
          <source>HashMap::iter</source>
          <target state="translated">HashMap::iter</target>
        </trans-unit>
        <trans-unit id="2bfca7b0b17c04d487077c012bec3c640635d95c" translate="yes" xml:space="preserve">
          <source>HashMap::iter_mut</source>
          <target state="translated">HashMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="15748fe38a254ba57dde931f14941b25230915de" translate="yes" xml:space="preserve">
          <source>HashMap::keys</source>
          <target state="translated">HashMap::keys</target>
        </trans-unit>
        <trans-unit id="013a2db0fc0510df2be8bb9a81336355dd6c81f5" translate="yes" xml:space="preserve">
          <source>HashMap::len</source>
          <target state="translated">HashMap::len</target>
        </trans-unit>
        <trans-unit id="bbd14da0450a45b2de193fcab5c00bb0eb5903d6" translate="yes" xml:space="preserve">
          <source>HashMap::ne</source>
          <target state="translated">HashMap::ne</target>
        </trans-unit>
        <trans-unit id="7a43b41cd29931fa0443de6420eab17418a5775e" translate="yes" xml:space="preserve">
          <source>HashMap::new</source>
          <target state="translated">HashMap::new</target>
        </trans-unit>
        <trans-unit id="292e274cb26beafe87f9986cd7a69d6e80f0d70e" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry</source>
          <target state="translated">HashMap::raw_entry</target>
        </trans-unit>
        <trans-unit id="ddac1348f5646998be5c764f10f7f59d986ae24a" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry_mut</source>
          <target state="translated">HashMap::raw_entry_mut</target>
        </trans-unit>
        <trans-unit id="eb7e68ea1cad35b4a180ddda2294c0954904ff9c" translate="yes" xml:space="preserve">
          <source>HashMap::remove</source>
          <target state="translated">HashMap::remove</target>
        </trans-unit>
        <trans-unit id="daa065a9f2946c9de97f049237fe61d1096fd3ad" translate="yes" xml:space="preserve">
          <source>HashMap::remove_entry</source>
          <target state="translated">HashMap::remove_entry</target>
        </trans-unit>
        <trans-unit id="0121bfc051e62887774fc3f9ec592514d686885b" translate="yes" xml:space="preserve">
          <source>HashMap::reserve</source>
          <target state="translated">HashMap::reserve</target>
        </trans-unit>
        <trans-unit id="88a2076f3660ecd79e0adb0243f0e9d4a8862721" translate="yes" xml:space="preserve">
          <source>HashMap::retain</source>
          <target state="translated">HashMap::retain</target>
        </trans-unit>
        <trans-unit id="f4991ea8c7797b408f7805334922bf7e0c8d10d6" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to</source>
          <target state="translated">HashMap::shrink_to</target>
        </trans-unit>
        <trans-unit id="dc8f377e69db6a1e9ed141ae6bf011880bd42c53" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to_fit</source>
          <target state="translated">HashMap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="bab5c2ac135dfe90b9b32c652153883ceeee3b33" translate="yes" xml:space="preserve">
          <source>HashMap::to_owned</source>
          <target state="translated">HashMap::to_owned</target>
        </trans-unit>
        <trans-unit id="391acc19f610e927b497bb4e11b352a7b2af949e" translate="yes" xml:space="preserve">
          <source>HashMap::try_from</source>
          <target state="translated">HashMap::try_from</target>
        </trans-unit>
        <trans-unit id="2893c51bf9c281d2ca7aba047803684d9a1aa860" translate="yes" xml:space="preserve">
          <source>HashMap::try_into</source>
          <target state="translated">HashMap::try_into</target>
        </trans-unit>
        <trans-unit id="9e7015c3cc0d5bc1003d09ff24337d2b0ad55c7b" translate="yes" xml:space="preserve">
          <source>HashMap::try_reserve</source>
          <target state="translated">HashMap::try_reserve</target>
        </trans-unit>
        <trans-unit id="b2ebec04fba53bc16fb11b0073bb6cc66af50890" translate="yes" xml:space="preserve">
          <source>HashMap::type_id</source>
          <target state="translated">HashMap::type_id</target>
        </trans-unit>
        <trans-unit id="d17a786e030134db4f1882f47a85dce856cb6c49" translate="yes" xml:space="preserve">
          <source>HashMap::values</source>
          <target state="translated">HashMap::values</target>
        </trans-unit>
        <trans-unit id="162e585c9055d46d3b3067b924bb60d67e948304" translate="yes" xml:space="preserve">
          <source>HashMap::values_mut</source>
          <target state="translated">HashMap::values_mut</target>
        </trans-unit>
        <trans-unit id="01bde569a6ca247f70b925283ac4eabf1fae164b" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity</source>
          <target state="translated">HashMap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c95ee5e43e53e6378ec649a9c2e69ab43598f8fb" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity_and_hasher</source>
          <target state="translated">HashMap::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="e7c4071d4f77cdf1820942e0c1ab3de0a91ed2cf" translate="yes" xml:space="preserve">
          <source>HashMap::with_hasher</source>
          <target state="translated">HashMap::with_hasher</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b68646e63dfce36d83be9cbaa54a303ef6a007af" translate="yes" xml:space="preserve">
          <source>HashSet::bitand</source>
          <target state="translated">HashSet::bitand</target>
        </trans-unit>
        <trans-unit id="1ab81639812d7d4b62dc39b7419600230fdcf25f" translate="yes" xml:space="preserve">
          <source>HashSet::bitor</source>
          <target state="translated">HashSet::bitor</target>
        </trans-unit>
        <trans-unit id="8075cc2581f90ca9a8938fc5f82b21b6e3d28edf" translate="yes" xml:space="preserve">
          <source>HashSet::bitxor</source>
          <target state="translated">HashSet::bitxor</target>
        </trans-unit>
        <trans-unit id="c77b68f5068bcecde6e8ffd8572dfb041513399a" translate="yes" xml:space="preserve">
          <source>HashSet::borrow</source>
          <target state="translated">HashSet::borrow</target>
        </trans-unit>
        <trans-unit id="03d0b56c31db1f8ba8c12e20646074ec753d52c9" translate="yes" xml:space="preserve">
          <source>HashSet::borrow_mut</source>
          <target state="translated">HashSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="bdd5342708fbc173156c0ad0e7ccdcf72b87bbec" translate="yes" xml:space="preserve">
          <source>HashSet::capacity</source>
          <target state="translated">HashSet::capacity</target>
        </trans-unit>
        <trans-unit id="b496a7fc22db5dfee5a71eb5501bd54af27226af" translate="yes" xml:space="preserve">
          <source>HashSet::clear</source>
          <target state="translated">HashSet::clear</target>
        </trans-unit>
        <trans-unit id="f6f7e84776c0a1492c95ca329cccd559dae22239" translate="yes" xml:space="preserve">
          <source>HashSet::clone</source>
          <target state="translated">HashSet::clone</target>
        </trans-unit>
        <trans-unit id="ad872e535653208fd311ddac1851f60e92c27461" translate="yes" xml:space="preserve">
          <source>HashSet::clone_from</source>
          <target state="translated">HashSet::clone_from</target>
        </trans-unit>
        <trans-unit id="30071df27bb602cc36f2524cd6272f86cf175d82" translate="yes" xml:space="preserve">
          <source>HashSet::clone_into</source>
          <target state="translated">HashSet::clone_into</target>
        </trans-unit>
        <trans-unit id="e9929a76352b9c6c4517057784d174ca502e4659" translate="yes" xml:space="preserve">
          <source>HashSet::contains</source>
          <target state="translated">HashSet::contains</target>
        </trans-unit>
        <trans-unit id="ee9499c5d925a80b927374f5fc18c8cf7acba286" translate="yes" xml:space="preserve">
          <source>HashSet::default</source>
          <target state="translated">HashSet::default</target>
        </trans-unit>
        <trans-unit id="c5666651d6d13e045665faaee91da5ee35aefa99" translate="yes" xml:space="preserve">
          <source>HashSet::difference</source>
          <target state="translated">HashSet::difference</target>
        </trans-unit>
        <trans-unit id="559bf337908631f9dc2cd3ab1c34c4b7158b1609" translate="yes" xml:space="preserve">
          <source>HashSet::drain</source>
          <target state="translated">HashSet::drain</target>
        </trans-unit>
        <trans-unit id="f25e9846b65f287b930b9d456cbbec8f01e240e9" translate="yes" xml:space="preserve">
          <source>HashSet::eq</source>
          <target state="translated">HashSet::eq</target>
        </trans-unit>
        <trans-unit id="6a91f6923c3310862ee3596940ed5b097a1bf087" translate="yes" xml:space="preserve">
          <source>HashSet::extend</source>
          <target state="translated">HashSet::extend</target>
        </trans-unit>
        <trans-unit id="8be48241f0d314ab0acacea29d3d926070bb5fa9" translate="yes" xml:space="preserve">
          <source>HashSet::fmt</source>
          <target state="translated">HashSet::fmt</target>
        </trans-unit>
        <trans-unit id="b4f60277034657d60f3728ccd3956ff96b1819e2" translate="yes" xml:space="preserve">
          <source>HashSet::from</source>
          <target state="translated">HashSet::from</target>
        </trans-unit>
        <trans-unit id="60f387d38899e1b57c8d30e798c352963e26a097" translate="yes" xml:space="preserve">
          <source>HashSet::from_iter</source>
          <target state="translated">HashSet::from_iter</target>
        </trans-unit>
        <trans-unit id="33cae8d46ad9832e17073c4a9f1abb51a6504d81" translate="yes" xml:space="preserve">
          <source>HashSet::get</source>
          <target state="translated">HashSet::get</target>
        </trans-unit>
        <trans-unit id="6c7ba6a45c151f970088dcc70a1b7618e6395baf" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert</source>
          <target state="translated">HashSet::get_or_insert</target>
        </trans-unit>
        <trans-unit id="3c9bf791b1bc89ff50ed8e094f3d77efdc799512" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert_with</source>
          <target state="translated">HashSet::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="01c1744d870244b7145beb071040d269b906cc15" translate="yes" xml:space="preserve">
          <source>HashSet::hasher</source>
          <target state="translated">HashSet::hasher</target>
        </trans-unit>
        <trans-unit id="6f9a670d4aa69b73fdbaf199b1f0dd8253423bff" translate="yes" xml:space="preserve">
          <source>HashSet::insert</source>
          <target state="translated">HashSet::insert</target>
        </trans-unit>
        <trans-unit id="5c5bf765bc94406fc16ab265fee5caf8d4d6d147" translate="yes" xml:space="preserve">
          <source>HashSet::intersection</source>
          <target state="translated">HashSet::intersection</target>
        </trans-unit>
        <trans-unit id="1847c872f1c798ce2ed7fda1f927b3db87be02ae" translate="yes" xml:space="preserve">
          <source>HashSet::into</source>
          <target state="translated">HashSet::into</target>
        </trans-unit>
        <trans-unit id="06dc65fe61329213ae7394dadf80b120758e58bf" translate="yes" xml:space="preserve">
          <source>HashSet::into_iter</source>
          <target state="translated">HashSet::into_iter</target>
        </trans-unit>
        <trans-unit id="67c6eb738c50bfb089cc9e9dd3c556b76c5e5a19" translate="yes" xml:space="preserve">
          <source>HashSet::is_disjoint</source>
          <target state="translated">HashSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="9463f6acefaba610600eb7b086516e06a56e7415" translate="yes" xml:space="preserve">
          <source>HashSet::is_empty</source>
          <target state="translated">HashSet::is_empty</target>
        </trans-unit>
        <trans-unit id="3494ecfcdfcc0fd49b4716ada245492c590484c8" translate="yes" xml:space="preserve">
          <source>HashSet::is_subset</source>
          <target state="translated">HashSet::is_subset</target>
        </trans-unit>
        <trans-unit id="5a5bed7c64ac7bd90ff2fd3978bbf37d738addfa" translate="yes" xml:space="preserve">
          <source>HashSet::is_superset</source>
          <target state="translated">HashSet::is_superset</target>
        </trans-unit>
        <trans-unit id="d4aa44a96215a84918fccfb358fa46f4343aa9e3" translate="yes" xml:space="preserve">
          <source>HashSet::iter</source>
          <target state="translated">HashSet::iter</target>
        </trans-unit>
        <trans-unit id="e772fc3259c95bf6f1d149e4fe5b58f7beb84957" translate="yes" xml:space="preserve">
          <source>HashSet::len</source>
          <target state="translated">HashSet::len</target>
        </trans-unit>
        <trans-unit id="9d950bd82fcd2e87760e296232658decf6487907" translate="yes" xml:space="preserve">
          <source>HashSet::ne</source>
          <target state="translated">HashSet::ne</target>
        </trans-unit>
        <trans-unit id="faff6aa961e961cb5d0e5be8b0c1765f5a91c089" translate="yes" xml:space="preserve">
          <source>HashSet::new</source>
          <target state="translated">HashSet::new</target>
        </trans-unit>
        <trans-unit id="ab12b0529a6e1a5dea72839456e2d81f89fbb648" translate="yes" xml:space="preserve">
          <source>HashSet::remove</source>
          <target state="translated">HashSet::remove</target>
        </trans-unit>
        <trans-unit id="11dfa3918fa59c9dba2c405236023985e68113d1" translate="yes" xml:space="preserve">
          <source>HashSet::replace</source>
          <target state="translated">HashSet::replace</target>
        </trans-unit>
        <trans-unit id="f3111bd9bb9284dd24b994e9c70b335390828fac" translate="yes" xml:space="preserve">
          <source>HashSet::reserve</source>
          <target state="translated">HashSet::reserve</target>
        </trans-unit>
        <trans-unit id="ce64d74e2bc22c15cfa1eaba2edb312838993eda" translate="yes" xml:space="preserve">
          <source>HashSet::retain</source>
          <target state="translated">HashSet::retain</target>
        </trans-unit>
        <trans-unit id="029a9cdc9ae9ee65ed460a0ec02d113e093964b2" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to</source>
          <target state="translated">HashSet::shrink_to</target>
        </trans-unit>
        <trans-unit id="3aba29e196a563c0a26e6c5d67e4388b6713cebf" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to_fit</source>
          <target state="translated">HashSet::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="137d5ee967421f3423450e1436080f3b38640647" translate="yes" xml:space="preserve">
          <source>HashSet::sub</source>
          <target state="translated">HashSet::sub</target>
        </trans-unit>
        <trans-unit id="39cf21ce1dee41e9b1e7cb0c554d9ccf20702455" translate="yes" xml:space="preserve">
          <source>HashSet::symmetric_difference</source>
          <target state="translated">HashSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="b78b12fa7d65d7ed557c2e12c743c86bcbc88775" translate="yes" xml:space="preserve">
          <source>HashSet::take</source>
          <target state="translated">HashSet::take</target>
        </trans-unit>
        <trans-unit id="93138236c5609c2dee4b1e913e9fcc9e3e9fdf44" translate="yes" xml:space="preserve">
          <source>HashSet::to_owned</source>
          <target state="translated">HashSet::to_owned</target>
        </trans-unit>
        <trans-unit id="96f13425b733a2e08673b87dffc523aee111609b" translate="yes" xml:space="preserve">
          <source>HashSet::try_from</source>
          <target state="translated">HashSet::try_from</target>
        </trans-unit>
        <trans-unit id="85d076b1561829592d046d057f0210cf9a4ff355" translate="yes" xml:space="preserve">
          <source>HashSet::try_into</source>
          <target state="translated">HashSet::try_into</target>
        </trans-unit>
        <trans-unit id="a9c0b3c82611415705e046ee581719e01be9eecc" translate="yes" xml:space="preserve">
          <source>HashSet::try_reserve</source>
          <target state="translated">HashSet::try_reserve</target>
        </trans-unit>
        <trans-unit id="105a18b817256119cb17af97da897c56eba29e40" translate="yes" xml:space="preserve">
          <source>HashSet::type_id</source>
          <target state="translated">HashSet::type_id</target>
        </trans-unit>
        <trans-unit id="685fa7682d344986ee2f2ae55086a7531364bc35" translate="yes" xml:space="preserve">
          <source>HashSet::union</source>
          <target state="translated">HashSet::union</target>
        </trans-unit>
        <trans-unit id="c3204331b41dcd6ae424437b8e36081a10f0c506" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity</source>
          <target state="translated">HashSet::with_capacity</target>
        </trans-unit>
        <trans-unit id="6bb25440ddefbed0a8db0d432f23f0ca38d089d8" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity_and_hasher</source>
          <target state="translated">HashSet::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="550d3800dfa4eb2bdb493d733dabf4b1ffabf984" translate="yes" xml:space="preserve">
          <source>HashSet::with_hasher</source>
          <target state="translated">HashSet::with_hasher</target>
        </trans-unit>
        <trans-unit id="fc0f48d98ae0d2092a247d5cee9ccdb867d1d001" translate="yes" xml:space="preserve">
          <source>Hasher</source>
          <target state="translated">Hasher</target>
        </trans-unit>
        <trans-unit id="e9a193bcbf138ba881c64b5b1a29eba015da6009" translate="yes" xml:space="preserve">
          <source>Hasher::finish</source>
          <target state="translated">Hasher::finish</target>
        </trans-unit>
        <trans-unit id="2b1c79f133b4285e8cbe820d3b0dbaa110a81b6c" translate="yes" xml:space="preserve">
          <source>Hasher::write</source>
          <target state="translated">Hasher::write</target>
        </trans-unit>
        <trans-unit id="aea45433ea07ad24495217b0093e410e9770ebb6" translate="yes" xml:space="preserve">
          <source>Hasher::write_i128</source>
          <target state="translated">Hasher::write_i128</target>
        </trans-unit>
        <trans-unit id="f97466e2fd5ec3a618a0b518a5dd39118b1b15e0" translate="yes" xml:space="preserve">
          <source>Hasher::write_i16</source>
          <target state="translated">Hasher::write_i16</target>
        </trans-unit>
        <trans-unit id="10de8ddcd6d092ee0ae793c2f146d59545948d06" translate="yes" xml:space="preserve">
          <source>Hasher::write_i32</source>
          <target state="translated">Hasher::write_i32</target>
        </trans-unit>
        <trans-unit id="fa2e80124215b4059a687baa99ddde7e8adc899d" translate="yes" xml:space="preserve">
          <source>Hasher::write_i64</source>
          <target state="translated">Hasher::write_i64</target>
        </trans-unit>
        <trans-unit id="fe5b0947dfe31def847c17d1e11ec3d408a4124c" translate="yes" xml:space="preserve">
          <source>Hasher::write_i8</source>
          <target state="translated">Hasher::write_i8</target>
        </trans-unit>
        <trans-unit id="53164f3f3dd297fb85292187a041f87e1d16695e" translate="yes" xml:space="preserve">
          <source>Hasher::write_isize</source>
          <target state="translated">Hasher::write_isize</target>
        </trans-unit>
        <trans-unit id="e477fb5169da10ce163639bd122b949d5314f471" translate="yes" xml:space="preserve">
          <source>Hasher::write_u128</source>
          <target state="translated">Hasher::write_u128</target>
        </trans-unit>
        <trans-unit id="05c5de3720de3f253e1541c3b244cb58450b4be2" translate="yes" xml:space="preserve">
          <source>Hasher::write_u16</source>
          <target state="translated">Hasher::write_u16</target>
        </trans-unit>
        <trans-unit id="1cf90d27fda48a3335fb25c8aa60e25c50bc3767" translate="yes" xml:space="preserve">
          <source>Hasher::write_u32</source>
          <target state="translated">Hasher::write_u32</target>
        </trans-unit>
        <trans-unit id="420bdb25cc27d8fac4c5399c4359ccee510eacbd" translate="yes" xml:space="preserve">
          <source>Hasher::write_u64</source>
          <target state="translated">Hasher::write_u64</target>
        </trans-unit>
        <trans-unit id="82a921392efa7001c790d5b80024db7be281f9cb" translate="yes" xml:space="preserve">
          <source>Hasher::write_u8</source>
          <target state="translated">Hasher::write_u8</target>
        </trans-unit>
        <trans-unit id="d1a0408c2f79ae7c9f420468772c41716a5e1a04" translate="yes" xml:space="preserve">
          <source>Hasher::write_usize</source>
          <target state="translated">Hasher::write_usize</target>
        </trans-unit>
        <trans-unit id="461629db972167b8f4c1f8c130db9885c4944304" translate="yes" xml:space="preserve">
          <source>Hashing Functions</source>
          <target state="translated">哈希函数</target>
        </trans-unit>
        <trans-unit id="baf48f49b04e2fe65712d113e9024e4c5a00d1bc" translate="yes" xml:space="preserve">
          <source>Haskell (GHC): typeclasses, type families</source>
          <target state="translated">Haskell (GHC):类型类,类型族。</target>
        </trans-unit>
        <trans-unit id="0561de3a6257f6d36364146fd6581f1315dd2333" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;common&lt;/code&gt; appear in the test results with &lt;code&gt;running 0 tests&lt;/code&gt; displayed for it is not what we wanted. We just wanted to share some code with the other integration test files.</source>
          <target state="translated">在测试结果中出现 &lt;code&gt;common&lt;/code&gt; 变量并显示 &lt;code&gt;running 0 tests&lt;/code&gt; 不是我们想要的。我们只想与其他集成测试文件共享一些代码。</target>
        </trans-unit>
        <trans-unit id="11f087b15a668ce62e66a014863909ef9d55cd94" translate="yes" xml:space="preserve">
          <source>Having Multiple Owners of Mutable Data by Combining &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">通过组合 &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 具有可变数据的多个所有者</target>
        </trans-unit>
        <trans-unit id="b3039ad6abf86928bcfdadaa49d3256f9e624f29" translate="yes" xml:space="preserve">
          <source>Having multiple relaxed default bounds is unsupported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b19652c5d2b3e9984ece4975d1cc403d1ab4a0a" translate="yes" xml:space="preserve">
          <source>Having one mutable reference (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) to the object (also known as &lt;strong&gt;mutability&lt;/strong&gt;).</source>
          <target state="translated">对对象有一个可变引用（ &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）（也称为&lt;strong&gt;mutability&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="08041929016b8a695800e1c093d6357eb61d9428" translate="yes" xml:space="preserve">
          <source>Having several immutable references (&lt;code&gt;&amp;amp;T&lt;/code&gt;) to the object (also known as &lt;strong&gt;aliasing&lt;/strong&gt;).</source>
          <target state="translated">对对象有几个不可变的引用（ &lt;code&gt;&amp;amp;T&lt;/code&gt; ）（也称为&lt;strong&gt;别名&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="89c8fa1c2c4d0b146e76f764a7dc959cbfc87737" translate="yes" xml:space="preserve">
          <source>Having to worry about the index in &lt;code&gt;word&lt;/code&gt; getting out of sync with the data in &lt;code&gt;s&lt;/code&gt; is tedious and error prone! Managing these indices is even more brittle if we write a &lt;code&gt;second_word&lt;/code&gt; function. Its signature would have to look like this:</source>
          <target state="translated">不必担心 &lt;code&gt;word&lt;/code&gt; 中的索引与 &lt;code&gt;s&lt;/code&gt; 中的数据不同步，这既繁琐又容易出错！如果我们编写 &lt;code&gt;second_word&lt;/code&gt; 函数，则管理这些索引的难度更大。其签名必须如下所示：</target>
        </trans-unit>
        <trans-unit id="257810d9a0b57b3d3f2b083b4e88460a9ed6c299" translate="yes" xml:space="preserve">
          <source>Hello, Cargo!</source>
          <target state="translated">你好,货郎!</target>
        </trans-unit>
        <trans-unit id="0a0a9f2a6772942557ab5355d76af442f8f65e01" translate="yes" xml:space="preserve">
          <source>Hello, World!</source>
          <target state="translated">你好,世界!</target>
        </trans-unit>
        <trans-unit id="d9d2b1e388fd73fa4e7cc0203db99342ed1255e1" translate="yes" xml:space="preserve">
          <source>Helper struct for safely printing paths with &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">帮助程序结构，可安全打印带有&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;路径！和 &lt;code&gt;{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8498955fde08da370bacddfd1434e8493282db8" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdd82587ac5843ce3d9f6e79bf40efba742c5a2" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8870a3f309d445b4b67cf35abad15e6e3e773d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;T&lt;/code&gt; is a trait object with two explicit lifetime bounds, 'a and 'b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4fbb21f9ed5068758832ea51d122515fab93c7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; will have already been specified the discriminant 0 by the time &lt;code&gt;Y&lt;/code&gt; is encountered, so a conflict occurs.</source>
          <target state="translated">在这里，到遇到 &lt;code&gt;Y&lt;/code&gt; 时，已经将 &lt;code&gt;X&lt;/code&gt; 指定为判别式0 ，因此发生冲突。</target>
        </trans-unit>
        <trans-unit id="b3f6e00f3163ec48a9acfd477c8ec87919fc2c8c" translate="yes" xml:space="preserve">
          <source>Here are a couple examples of this error:</source>
          <target state="translated">这里有几个例子可以说明这个错误。</target>
        </trans-unit>
        <trans-unit id="8ff34494ac843686469f6f02e338741820201079" translate="yes" xml:space="preserve">
          <source>Here are examples of the comparison operators being used.</source>
          <target state="translated">下面是使用比较运算符的例子。</target>
        </trans-unit>
        <trans-unit id="bca374bff5c3dac21037ded7599cd1fe12249f7d" translate="yes" xml:space="preserve">
          <source>Here are examples of these operators being used.</source>
          <target state="translated">下面是这些运算符的使用实例。</target>
        </trans-unit>
        <trans-unit id="07272e166a1d2e40b130f94ad3a0aa3df774ca3b" translate="yes" xml:space="preserve">
          <source>Here are similar examples but now for LAST.</source>
          <target state="translated">这里有类似的例子,但现在是LAST。</target>
        </trans-unit>
        <trans-unit id="0a1abd5c7569db9404cdcd75f1cc6cdc0c6dca93" translate="yes" xml:space="preserve">
          <source>Here are some example of these operators</source>
          <target state="translated">下面是这些运算符的一些例子</target>
        </trans-unit>
        <trans-unit id="4684b015ded3bc0731a2cef8198e5596403f6b07" translate="yes" xml:space="preserve">
          <source>Here are some examples of elision errors:</source>
          <target state="translated">下面是一些洗脱错误的例子。</target>
        </trans-unit>
        <trans-unit id="4bcc69e7a08f9cc053bd0cff82d93712f586660e" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions don't have extended temporary scopes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92962597dc4ffea4ff897a85b4d5e4dec6ca581" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions have extended temporary scopes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="51de71d79af0f5165810b64b8288dc0e2f418033" translate="yes" xml:space="preserve">
          <source>Here are some examples: a reference to an &lt;code&gt;i32&lt;/code&gt; without a lifetime parameter, a reference to an &lt;code&gt;i32&lt;/code&gt; that has a lifetime parameter named &lt;code&gt;'a&lt;/code&gt;, and a mutable reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">下面是一些例子：一个基准 &lt;code&gt;i32&lt;/code&gt; 没有寿命参数，所涉及的参考 &lt;code&gt;i32&lt;/code&gt; 具有命名为寿命参数 &lt;code&gt;'a&lt;/code&gt; ，和一个可变引用到 &lt;code&gt;i32&lt;/code&gt; 也具有寿命 &lt;code&gt;'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20d5c7a1de98768721ba1e4861f1afaf92322548" translate="yes" xml:space="preserve">
          <source>Here are some of the things this module contains:</source>
          <target state="translated">下面是这个模块包含的一些内容。</target>
        </trans-unit>
        <trans-unit id="2a92602de41a70e7040e9f2a4fb9598c573570c2" translate="yes" xml:space="preserve">
          <source>Here are some simple examples of where you'll run into this error:</source>
          <target state="translated">下面是一些简单的例子,说明你会在哪里遇到这个错误。</target>
        </trans-unit>
        <trans-unit id="3a02d5c5d61bf51906767acca68761775d677fe8" translate="yes" xml:space="preserve">
          <source>Here are the abilities Unsafe Rust has in addition to Safe Rust:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8f26110eb51a4ab181ea0b693d59c927775bab" translate="yes" xml:space="preserve">
          <source>Here are the topics we&amp;rsquo;ll cover in this chapter:</source>
          <target state="translated">以下是本章将涉及的主题：</target>
        </trans-unit>
        <trans-unit id="bc16616a997e1c54d6f12cfc92a13207a77b9160" translate="yes" xml:space="preserve">
          <source>Here are the two primary ways in which &lt;code&gt;entry&lt;/code&gt; is used. First, a simple example where the logic performed on the values is trivial.</source>
          <target state="translated">这是使用 &lt;code&gt;entry&lt;/code&gt; 的两种主要方法。首先，一个简单的示例，其中对值执行的逻辑很简单。</target>
        </trans-unit>
        <trans-unit id="8d3de595e318046b488878fdfd592e24474accd6" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm.</source>
          <target state="translated">在这里执行 &lt;code&gt;x = None&lt;/code&gt; 将修改匹配的值，并要求我们&amp;ldquo;及时&amp;rdquo;返回 &lt;code&gt;None&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="b54fff02e5e3fe8139f3151b798d2ca6781ef79d" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm. To fix it, change the value in the match arm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b503ee6f76be5b3f344961161f897b4c2e8a33" translate="yes" xml:space="preserve">
          <source>Here is a basic example:</source>
          <target state="translated">下面是一个基本的例子。</target>
        </trans-unit>
        <trans-unit id="40d986bccf61bb4616c6b2d5e45138cb6f650868" translate="yes" xml:space="preserve">
          <source>Here is a recap of the reasons to choose &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">这是选择 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 的原因的概述：</target>
        </trans-unit>
        <trans-unit id="2fd70c4f72651018616cf4fae80bda013db29aef" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;Err&lt;/code&gt;.</source>
          <target state="translated">这是前一个示例的变体，显示在第一个 &lt;code&gt;Err&lt;/code&gt; 之后没有从 &lt;code&gt;iter&lt;/code&gt; 中获取其他元素。</target>
        </trans-unit>
        <trans-unit id="f2d33e000bef3fae0bc1e18459c72a6974d4c8ec" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">这是前一个示例的变体，显示在第一个 &lt;code&gt;None&lt;/code&gt; 之后没有从 &lt;code&gt;iter&lt;/code&gt; 中获取其他元素。</target>
        </trans-unit>
        <trans-unit id="64fa9f151e952c55124309eb57d3e7e04cdb27ce" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Add&lt;/code&gt; trait using generics.</source>
          <target state="translated">这是使用泛型实现 &lt;code&gt;Add&lt;/code&gt; trait 的相同 &lt;code&gt;Point&lt;/code&gt; 结构的示例。</target>
        </trans-unit>
        <trans-unit id="f4eeb15c7a7b93e1eb2dc6a8750be5fd94bbc8b2" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Sub&lt;/code&gt; trait using generics.</source>
          <target state="translated">这是使用泛型实现 &lt;code&gt;Sub&lt;/code&gt; trait 的相同 &lt;code&gt;Point&lt;/code&gt; 结构的示例。</target>
        </trans-unit>
        <trans-unit id="e2a455b6868a34c4c660661290fdc27380049549" translate="yes" xml:space="preserve">
          <source>Here is an example response that uses HTTP version 1.1, has a status code of 200, an OK reason phrase, no headers, and no body:</source>
          <target state="translated">下面是一个使用HTTP版本1.1的响应示例,状态码为200,有一个OK的原因短语,没有头信息,也没有正文。</target>
        </trans-unit>
        <trans-unit id="8d3dccad44a11aba4a0bfd15fb7b2845992244bd" translate="yes" xml:space="preserve">
          <source>Here is an example showcasing how to soundly mutate the contents of an &lt;code&gt;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; despite there being multiple references aliasing the cell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c4ae388ef10758f9c1ee112d05af3dedb5a8c1" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the error:</source>
          <target state="translated">这里有一个例子可以证明这个错误。</target>
        </trans-unit>
        <trans-unit id="eb168180e8af601284ef4a6f97cd122e9d48a93f" translate="yes" xml:space="preserve">
          <source>Here is an example using ranges of &lt;code&gt;char&lt;/code&gt; values:</source>
          <target state="translated">这是使用 &lt;code&gt;char&lt;/code&gt; 值范围的示例：</target>
        </trans-unit>
        <trans-unit id="2190806deeaf3eb0d2b99ddd8ded1889adb9e2dc" translate="yes" xml:space="preserve">
          <source>Here is an example where the third lifetime elision rule applies:</source>
          <target state="translated">下面是一个适用于第三种终身洗脱规则的例子。</target>
        </trans-unit>
        <trans-unit id="8be714949bc61ee0dfb58dd8b6d077f499efa300" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector, checking for overflow:</source>
          <target state="translated">下面是一个例子,它对一个向量中的每一个整数进行递增,检查是否有溢出。</target>
        </trans-unit>
        <trans-unit id="b8d2a1ec18a168b45aede187d064b1d87d98387f" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector. We use the checked variant of &lt;code&gt;add&lt;/code&gt; that returns &lt;code&gt;None&lt;/code&gt; when the calculation would result in an overflow.</source>
          <target state="translated">这是一个使向量中的每个整数递增的示例。我们使用选中的 &lt;code&gt;add&lt;/code&gt; 变体，当计算将导致溢出时，该变体返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="669e450458761957293db53fc0e8c919ba0f5a7a" translate="yes" xml:space="preserve">
          <source>Here is an unsafe function named &lt;code&gt;dangerous&lt;/code&gt; that doesn&amp;rsquo;t do anything in its body:</source>
          <target state="translated">这是一个不安全的函数，名称为 &lt;code&gt;dangerous&lt;/code&gt; ，不会在体内起作用：</target>
        </trans-unit>
        <trans-unit id="d9606eca0f59289409929077841f751f72b656be" translate="yes" xml:space="preserve">
          <source>Here is another example that tries to subtract one from another list of integers, this time checking for underflow:</source>
          <target state="translated">下面是另一个试图从另一个整数列表中减去一个的例子,这次是检查是否有下溢。</target>
        </trans-unit>
        <trans-unit id="967e8f702b29651ccfd3eff162bdd1236f185e1b" translate="yes" xml:space="preserve">
          <source>Here is how you would define and use a &lt;code&gt;calculate_length&lt;/code&gt; function that has a reference to an object as a parameter instead of taking ownership of the value:</source>
          <target state="translated">这是定义和使用对对象的引用作为参数而不是拥有值所有权的 &lt;code&gt;calculate_length&lt;/code&gt; 函数的方式：</target>
        </trans-unit>
        <trans-unit id="853cb0e889b6e921d08e41239a16f75171fa3cf1" translate="yes" xml:space="preserve">
          <source>Here is that same example again, with some explanatory comments:</source>
          <target state="translated">下面是同样的例子,再加上一些解释性的评论。</target>
        </trans-unit>
        <trans-unit id="183c940df02f2ac1c7e0b320aa5e4607c7fd14f0" translate="yes" xml:space="preserve">
          <source>Here is the error we get when we compile this code:</source>
          <target state="translated">这是我们编译这段代码时得到的错误。</target>
        </trans-unit>
        <trans-unit id="20e589c1d30a718b69866f0e87eb12f8b53bb806" translate="yes" xml:space="preserve">
          <source>Here is the plan to build the web server:</source>
          <target state="translated">以下是构建Web服务器的计划。</target>
        </trans-unit>
        <trans-unit id="c50f83c6cf619c1c5fb8951e5f26cafe1c807151" translate="yes" xml:space="preserve">
          <source>Here is the previous example again, with the correct order:</source>
          <target state="translated">这里又是前面的例子,顺序正确。</target>
        </trans-unit>
        <trans-unit id="c6b6ce6ac56caf7839b74c32ae618de3ed902bea" translate="yes" xml:space="preserve">
          <source>Here is this algorithm described in pseudocode.</source>
          <target state="translated">下面是用伪代码描述的这个算法。</target>
        </trans-unit>
        <trans-unit id="5ade7d43a649a8f35a37c5c4df50d404ac17d264" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Apple&lt;/code&gt; variant has two fields, and should be matched against like so:</source>
          <target state="translated">在这里， &lt;code&gt;Apple&lt;/code&gt; 变体有两个字段，应该像这样进行匹配：</target>
        </trans-unit>
        <trans-unit id="847a36b4e8f5bc18d0a990ee9501fe6c952a3db3" translate="yes" xml:space="preserve">
          <source>Here the type &lt;code&gt;T&lt;/code&gt; cannot have a relaxed bound for multiple default traits (&lt;code&gt;Sized&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;). This can be fixed by only using one relaxed bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77492962523ab1872ec0db64f3e31206c8e37741" translate="yes" xml:space="preserve">
          <source>Here we create &lt;code&gt;Status::Value&lt;/code&gt; instances using each &lt;code&gt;u32&lt;/code&gt; value in the range that &lt;code&gt;map&lt;/code&gt; is called on by using the initializer function of &lt;code&gt;Status::Value&lt;/code&gt;. Some people prefer this style, and some people prefer to use closures. They compile to the same code, so use whichever style is clearer to you.</source>
          <target state="translated">在这里，我们创建 &lt;code&gt;Status::Value&lt;/code&gt; 使用每个实例 &lt;code&gt;u32&lt;/code&gt; 范围内的值 &lt;code&gt;map&lt;/code&gt; 是通过使用的初始化函数呼吁 &lt;code&gt;Status::Value&lt;/code&gt; 。有些人喜欢这种样式，有些人喜欢使用闭包。它们将编译为相同的代码，因此请使用对您更清晰的样式。</target>
        </trans-unit>
        <trans-unit id="ab78b83024b9be055a5f592dcee8323d7eae1a44" translate="yes" xml:space="preserve">
          <source>Here we get a warning about not using the variable &lt;code&gt;y&lt;/code&gt;, but we don&amp;rsquo;t get a warning about not using the variable preceded by the underscore.</source>
          <target state="translated">在这里，我们收到关于不使用变量 &lt;code&gt;y&lt;/code&gt; 的警告，但没有收到关于不使用下划线开头的变量的警告。</target>
        </trans-unit>
        <trans-unit id="c5caa2018a964f99eaa055d4bd09b35c0163bd0e" translate="yes" xml:space="preserve">
          <source>Here we have an addition of &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;n.into()&lt;/code&gt;. Hence, &lt;code&gt;n.into()&lt;/code&gt; can return any type &lt;code&gt;T&lt;/code&gt; where &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;into&lt;/code&gt; method can return any type where &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c5079a1585dd8c6aa581475ab7d948402fef68" translate="yes" xml:space="preserve">
          <source>Here we have an iterator &lt;code&gt;results&lt;/code&gt; over &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt;. Hence, &lt;code&gt;results.collect()&lt;/code&gt; can return any type implementing &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;?&lt;/code&gt; operator can accept any type implementing &lt;code&gt;Try&lt;/code&gt;.</source>
          <target state="translated">在这里，我们在 &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt; 有一个迭代器 &lt;code&gt;results&lt;/code&gt; 。因此， &lt;code&gt;results.collect()&lt;/code&gt; 可以返回实现 &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; 任何类型。另一方面， &lt;code&gt;?&lt;/code&gt; 操作员可以接受实现 &lt;code&gt;Try&lt;/code&gt; 的任何类型。</target>
        </trans-unit>
        <trans-unit id="cb5b6fe6a43391cbaff0a797a1749d4999cf682c" translate="yes" xml:space="preserve">
          <source>Here we have declared a string literal, also known as a string slice. String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt; is guaranteed to be valid for the duration of the entire program. We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:</source>
          <target state="translated">在这里，我们声明了字符串文字，也称为字符串切片。字符串文字具有静态的生存期，这意味着字符串 &lt;code&gt;hello_world&lt;/code&gt; 在整个程序期间均有效。我们还可以显式指定 &lt;code&gt;hello_world&lt;/code&gt; 的生存期：</target>
        </trans-unit>
        <trans-unit id="4f6025ae753da089e1d8586a3532b960124e6dc6" translate="yes" xml:space="preserve">
          <source>Here we have used the &lt;code&gt;continue&lt;/code&gt; keyword incorrectly. As we have seen above that &lt;code&gt;continue&lt;/code&gt; pointing to a labeled block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a5e69251fb02d97a8da5895df070cb741e7a14" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;flatten()&lt;/code&gt; does not perform a &quot;deep&quot; flatten. Instead, only one level of nesting is removed. That is, if you &lt;code&gt;flatten()&lt;/code&gt; a three-dimensional array the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to &lt;code&gt;flatten()&lt;/code&gt; again.</source>
          <target state="translated">在这里，我们看到 &lt;code&gt;flatten()&lt;/code&gt; 不会执行&amp;ldquo;深度&amp;rdquo;展平。相反，仅删除了一层嵌套。也就是说，如果您 &lt;code&gt;flatten()&lt;/code&gt; 一个三维数组，结果将是二维的，而不是一维的。要获得一维结构，您必须再次 &lt;code&gt;flatten()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72ccb25410f6e8d0ac401f0e115875ab4db2e28c" translate="yes" xml:space="preserve">
          <source>Here we tell Rust that when the result is &lt;code&gt;Ok&lt;/code&gt;, return the inner &lt;code&gt;file&lt;/code&gt; value out of the &lt;code&gt;Ok&lt;/code&gt; variant, and we then assign that file handle value to the variable &lt;code&gt;f&lt;/code&gt;. After the &lt;code&gt;match&lt;/code&gt;, we can use the file handle for reading or writing.</source>
          <target state="translated">在这里，我们告诉Rust，当结果为 &lt;code&gt;Ok&lt;/code&gt; 时，从 &lt;code&gt;Ok&lt;/code&gt; 变量中返回内部 &lt;code&gt;file&lt;/code&gt; 值，然后将文件句柄值分配给变量 &lt;code&gt;f&lt;/code&gt; 。 &lt;code&gt;match&lt;/code&gt; 结束后，我们可以使用文件句柄进行读取或写入。</target>
        </trans-unit>
        <trans-unit id="80012795e5bb9f7fa353370133e88ca78ecd6ec8" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re calling the &lt;code&gt;hello&lt;/code&gt; function with the argument &lt;code&gt;&amp;amp;m&lt;/code&gt;, which is a reference to a &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; value. Because we implemented the &lt;code&gt;Deref&lt;/code&gt; trait on &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 15-10, Rust can turn &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into &lt;code&gt;&amp;amp;String&lt;/code&gt; by calling &lt;code&gt;deref&lt;/code&gt;. The standard library provides an implementation of &lt;code&gt;Deref&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; that returns a string slice, and this is in the API documentation for &lt;code&gt;Deref&lt;/code&gt;. Rust calls &lt;code&gt;deref&lt;/code&gt; again to turn the &lt;code&gt;&amp;amp;String&lt;/code&gt; into &lt;code&gt;&amp;amp;str&lt;/code&gt;, which matches the &lt;code&gt;hello&lt;/code&gt; function&amp;rsquo;s definition.</source>
          <target state="translated">在这里，我们使用参数 &lt;code&gt;&amp;amp;m&lt;/code&gt; 调用 &lt;code&gt;hello&lt;/code&gt; 函数，该参数是对 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 值的引用。因为我们在清单15-10中在 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 上实现了 &lt;code&gt;Deref&lt;/code&gt; 特征，所以Rust可以通过调用 &lt;code&gt;deref&lt;/code&gt; 将 &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 转换为 &lt;code&gt;&amp;amp;String&lt;/code&gt; 。标准库提供了对 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;Deref&lt;/code&gt; 的实现，该实现返回一个字符串切片，这在 &lt;code&gt;Deref&lt;/code&gt; 的API文档中。 Rust 再次调用 &lt;code&gt;deref&lt;/code&gt; 将 &lt;code&gt;&amp;amp;String&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，它与 &lt;code&gt;hello&lt;/code&gt; 匹配 函数的定义。</target>
        </trans-unit>
        <trans-unit id="466e3552c39fe3a92c2d4c054173a56d883575cc" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve defined a struct and named it &lt;code&gt;Rectangle&lt;/code&gt;. Inside the curly brackets, we defined the fields as &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;, both of which have type &lt;code&gt;u32&lt;/code&gt;. Then in &lt;code&gt;main&lt;/code&gt;, we created a particular instance of &lt;code&gt;Rectangle&lt;/code&gt; that has a width of 30 and a height of 50.</source>
          <target state="translated">在这里，我们定义了一个结构并将其命名为 &lt;code&gt;Rectangle&lt;/code&gt; 。在花括号内，我们将字段定义为 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; ，它们的类型均为 &lt;code&gt;u32&lt;/code&gt; 。然后在 &lt;code&gt;main&lt;/code&gt; 中，我们创建了一个 &lt;code&gt;Rectangle&lt;/code&gt; 的特定实例，该实例的宽度为30，高度为50。</target>
        </trans-unit>
        <trans-unit id="817f9efff3a295f34cca74e6a4819cd4626be8b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple comment:</source>
          <target state="translated">这是一个简单的注释：</target>
        </trans-unit>
        <trans-unit id="539936e83a01369f912b07f9a46070e22c533c8a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small programming problem: write a function that takes a string and returns the first word it finds in that string. If the function doesn&amp;rsquo;t find a space in the string, the whole string must be one word, so the entire string should be returned.</source>
          <target state="translated">这是一个小的编程问题：编写一个函数，该函数接受一个字符串并返回在该字符串中找到的第一个单词。如果函数在字符串中找不到空格，则整个字符串必须是一个单词，因此应返回整个字符串。</target>
        </trans-unit>
        <trans-unit id="7f3b7e87f399f43770545cc13990ab6cc8dd6c83" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a constant declaration where the constant&amp;rsquo;s name is &lt;code&gt;MAX_POINTS&lt;/code&gt; and its value is set to 100,000. (Rust&amp;rsquo;s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability):</source>
          <target state="translated">这是一个常量声明的示例，其中常量的名称为 &lt;code&gt;MAX_POINTS&lt;/code&gt; ，其值设置为100,000。 （Rust常量的命名约定是使用所有大写字母在单词之间使用下划线，并且可以在数字文字中插入下划线以提高可读性）：</target>
        </trans-unit>
        <trans-unit id="0e399b9c3b58dba78ca66c0c45518f8657e4f783" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the development and release process works: let&amp;rsquo;s assume that the Rust team is working on the release of Rust 1.5. That release happened in December of 2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a new commit lands on the &lt;code&gt;master&lt;/code&gt; branch. Each night, a new nightly version of Rust is produced. Every day is a release day, and these releases are created by our release infrastructure automatically. So as time passes, our releases look like this, once a night:</source>
          <target state="translated">这是一个开发和发布过程如何工作的示例：假设Rust团队正在研究Rust 1.5的发布。该版本发生在2015年12月，但它将为我们提供实际的版本号。Rust中增加了一个新功能：新的提交位于 &lt;code&gt;master&lt;/code&gt; 分支上。每天晚上，都会产生一个每晚的Rust版本。每天都是发布日，这些发布是由我们的发布基础结构自动创建的。因此，随着时间的流逝，我们的发布会像这样，每晚一次：</target>
        </trans-unit>
        <trans-unit id="dd2c057fc04f01fae93788be5795a76d18a55fe9" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of the &lt;code&gt;clone&lt;/code&gt; method in action:</source>
          <target state="translated">这是运行中的 &lt;code&gt;clone&lt;/code&gt; 方法的示例：</target>
        </trans-unit>
        <trans-unit id="01162de636320bfb3aac73f8ee64a4ca8f8b3f36" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that shows floating-point numbers in action:</source>
          <target state="translated">这是一个显示浮点数的示例：</target>
        </trans-unit>
        <trans-unit id="b756692957834549ddc1e80ed843e1c05120a8e7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how it works: when you call a method with &lt;code&gt;object.something()&lt;/code&gt;, Rust automatically adds in &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; so &lt;code&gt;object&lt;/code&gt; matches the signature of the method. In other words, the following are the same:</source>
          <target state="translated">它的工作方式如下：当使用 &lt;code&gt;object.something()&lt;/code&gt; 调用方法时，Rust自动添加 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;&amp;amp;mut&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; ,从而使 &lt;code&gt;object&lt;/code&gt; 与方法的签名匹配。换句话说，以下是相同的：</target>
        </trans-unit>
        <trans-unit id="bbfc2aa9173a426f43e60848a0174bac37b702fe" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the compiler error:</source>
          <target state="translated">这是编译器错误：</target>
        </trans-unit>
        <trans-unit id="7ba4bf6763c0003ca703ce8f7299229f35cbda9a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the error:</source>
          <target state="translated">这是错误：</target>
        </trans-unit>
        <trans-unit id="916eb038e9d9b0f05a6d2dec1a88d2849aef616b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the full code for reference:</source>
          <target state="translated">这是完整的代码供参考：</target>
        </trans-unit>
        <trans-unit id="815ea8397604a0309cd918e79463e69ce092e31e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the resulting compilation error:</source>
          <target state="translated">这是产生的编译错误：</target>
        </trans-unit>
        <trans-unit id="0221cef214e9504c84ca1c9204c7ee34f36785b0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the scenario we&amp;rsquo;ll test: we&amp;rsquo;ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user&amp;rsquo;s quota for the number of API calls they&amp;rsquo;re allowed to make, for example.</source>
          <target state="translated">我们将测试以下情况：我们将创建一个库，该库针对最大值跟踪值，并根据当前值与最大值的接近程度发送消息。例如，该库可用于跟踪用户允许他们进行的API调用次数的配额。</target>
        </trans-unit>
        <trans-unit id="3d29162aaec04ffdbb58bf12aa825c48d5666dd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what the countdown would look like using a &lt;code&gt;for&lt;/code&gt; loop and another method we&amp;rsquo;ve not yet talked about, &lt;code&gt;rev&lt;/code&gt;, to reverse the range:</source>
          <target state="translated">这是使用 &lt;code&gt;for&lt;/code&gt; 循环和我们尚未讨论的另一种方法 &lt;code&gt;rev&lt;/code&gt; 来倒数范围的倒数形式：</target>
        </trans-unit>
        <trans-unit id="d3bb7457d5469dff80002a12eb2b6537482105f8" translate="yes" xml:space="preserve">
          <source>Here's an example of a program which exemplifies the three cases outlined above:</source>
          <target state="translated">下面是一个程序的例子,它体现了上述三种情况。</target>
        </trans-unit>
        <trans-unit id="8f4d98d4c0a8996c7a0518c8611a7d795ca5c7fb" translate="yes" xml:space="preserve">
          <source>Here's an example of a struct that has this problem:</source>
          <target state="translated">下面是一个存在这个问题的结构的例子。</target>
        </trans-unit>
        <trans-unit id="38707ff87f1d5297f1ba77c802780450fd07e571" translate="yes" xml:space="preserve">
          <source>Here's an example of how a collection might make use of &lt;code&gt;needs_drop&lt;/code&gt;:</source>
          <target state="translated">这是一个示例，说明集合如何利用 &lt;code&gt;needs_drop&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6b4165c575ea75c83f4faaec0830fc7c979ed3b7" translate="yes" xml:space="preserve">
          <source>Here's an example of some in-progress code. We have a trait &lt;code&gt;Foo&lt;/code&gt;:</source>
          <target state="translated">这是一些正在进行的代码的示例。我们有一个特质 &lt;code&gt;Foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f441ef09b0ea3aff9bb06d2bb0621baad2037ee9" translate="yes" xml:space="preserve">
          <source>Here's an example of this error:</source>
          <target state="translated">下面是这个错误的一个例子。</target>
        </trans-unit>
        <trans-unit id="c9ee387ebc736d2db87034681c5da1089287c37d" translate="yes" xml:space="preserve">
          <source>Here's an example where you want to sort people by height only, disregarding &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;:</source>
          <target state="translated">这是一个示例，您只想按身高对人进行排序，而不考虑 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="4cce1c09bcbbaec9487020ee6e7f8025e34bed6b" translate="yes" xml:space="preserve">
          <source>Here's another example but here we do not try and return an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52eb68597e531c606446cb2bd5c17dccc5e369fd" translate="yes" xml:space="preserve">
          <source>Here's another example that will fail:</source>
          <target state="translated">这里还有一个例子,会失败。</target>
        </trans-unit>
        <trans-unit id="cb729976f0325910542c6a857a3758115eda6f00" translate="yes" xml:space="preserve">
          <source>Here's one example of this error:</source>
          <target state="translated">下面是这个错误的一个例子。</target>
        </trans-unit>
        <trans-unit id="4919036b58ea25eeee47e5a5bbcefebd8f5446fd" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这是相同的示例，但带有&lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f461dd8cfe66dce3c71bb1a0db34025a57dc2b4e" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b538038816d2b9d80e3095023dd492b1ae3c134a" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adc3a6ab8335913c0c03d10dd56aa70986ccdbc" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; is mutable, but &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</source>
          <target state="translated">在这里， &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; 是可变的，但 &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; 不是。创建对值的不可变引用将不可变地借用它。可能存在 &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; 送到一部呢一部一部一部一部一部很一部很一部很一部电影作为主角的唱片公司的唱片公司的唱片公司）的唱片公司的公司，才可能出现的唱片公司）的公司的公司，它们的公司。&amp;amp;＆ &amp;amp;＆（＆mut＆M＆T＆T＆GT;＆GT;＆GT;＆GT;＆GT;＆QUOT ;;</target>
        </trans-unit>
        <trans-unit id="ae9903eacaebe1bfadd3100f5d35d502f8c50279" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Grams2&lt;/code&gt; is a not equivalent to &lt;code&gt;Grams&lt;/code&gt; -- the former transparently wraps a (non-transparent) struct containing a single float, while &lt;code&gt;Grams&lt;/code&gt; is a transparent wrapper around a float. This can make a difference for the ABI.</source>
          <target state="translated">在这里， &lt;code&gt;Grams2&lt;/code&gt; 不等同于 &lt;code&gt;Grams&lt;/code&gt; －前者透明地包装包含单个浮点的（非透明）结构，而 &lt;code&gt;Grams&lt;/code&gt; 是围绕浮点的透明包装。这对于ABI可以有所作为。</target>
        </trans-unit>
        <trans-unit id="dc33c2bfb4ee352bfa1ddf50a16705d99896734f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo&lt;/code&gt; tries to borrow the string data held within its argument &lt;code&gt;s&lt;/code&gt; and then return that borrow. However, &lt;code&gt;S&lt;/code&gt; is declared as implementing &lt;code&gt;Drop&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;demo&lt;/code&gt; 尝试借用其参数 &lt;code&gt;s&lt;/code&gt; 中保存的字符串数据，然后返回该借用。但是， &lt;code&gt;S&lt;/code&gt; 被声明为实现 &lt;code&gt;Drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d42c53fe9a57832c14dca225308392012e6122d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;fancy_num&lt;/code&gt; is borrowed by &lt;code&gt;fancy_ref&lt;/code&gt; and so cannot be moved into the closure &lt;code&gt;x&lt;/code&gt;. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</source>
          <target state="translated">在这里， &lt;code&gt;fancy_num&lt;/code&gt; 被借用 &lt;code&gt;fancy_ref&lt;/code&gt; ，所以不能被移动到关闭 &lt;code&gt;x&lt;/code&gt; 。借入值时，无法将其移至封闭中，因为这会使借入无效。</target>
        </trans-unit>
        <trans-unit id="125b181d950db988334868421de4a90fab534474" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;first&lt;/code&gt; has type &lt;code&gt;A&lt;/code&gt;, referring to &lt;code&gt;to_vec&lt;/code&gt;'s &lt;code&gt;A&lt;/code&gt; type parameter; and &lt;code&gt;rest&lt;/code&gt; has type &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt;, a vector with element type &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;first&lt;/code&gt; 具有类型 &lt;code&gt;A&lt;/code&gt; ，引用 &lt;code&gt;to_vec&lt;/code&gt; 的 &lt;code&gt;A&lt;/code&gt; 类型参数；和 &lt;code&gt;rest&lt;/code&gt; 具有类型 &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt; ，与元素类型的载体 &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="843f8d3cb9b3a29d042bd0b638e62192879181c8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the array contains five elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5a4c41f4c7ffd30b5c670cb408c350a9013b94" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the element contains five items.</source>
          <target state="translated">在此， &lt;code&gt;i32&lt;/code&gt; 是每个元素的类型。在分号之后，数字 &lt;code&gt;5&lt;/code&gt; 表示元素包含五项。</target>
        </trans-unit>
        <trans-unit id="1068c0619a68aa52935f67e1c63f9f6ef1422570" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;s&lt;/code&gt; will be a &lt;code&gt;&amp;amp;str&lt;/code&gt; that contains the first 4 bytes of the string. Earlier, we mentioned that each of these characters was 2 bytes, which means &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;Зд&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;s&lt;/code&gt; 将是一个 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，它包含字符串的前4个字节。之前，我们提到了每个字符都是2个字节，这意味着 &lt;code&gt;s&lt;/code&gt; 将是 &lt;code&gt;Зд&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75b866d15247e93817fc99798a57f0ab2950be56" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;score&lt;/code&gt; will have the value that&amp;rsquo;s associated with the Blue team, and the result will be &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt;. The result is wrapped in &lt;code&gt;Some&lt;/code&gt; because &lt;code&gt;get&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt;; if there&amp;rsquo;s no value for that key in the hash map, &lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt;. The program will need to handle the &lt;code&gt;Option&lt;/code&gt; in one of the ways that we covered in Chapter 6.</source>
          <target state="translated">在这里， &lt;code&gt;score&lt;/code&gt; 将具有与Blue团队相关联的值，结果将是 &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt; 。结果包装在 &lt;code&gt;Some&lt;/code&gt; 中,因为 &lt;code&gt;get&lt;/code&gt; 返回 &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt; ;如果哈希图中没有该键的值，则 &lt;code&gt;get&lt;/code&gt; 将返回 &lt;code&gt;None&lt;/code&gt; 。该程序将需要以我们在第6章中介绍的一种方式来处理 &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bd05f4a31a90f3b6414a315addec81f40aa24ad" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; has the lifetime &lt;code&gt;'b&lt;/code&gt;, which in this case is larger than &lt;code&gt;'a&lt;/code&gt;. This means &lt;code&gt;r&lt;/code&gt; can reference &lt;code&gt;x&lt;/code&gt; because Rust knows that the reference in &lt;code&gt;r&lt;/code&gt; will always be valid while &lt;code&gt;x&lt;/code&gt; is valid.</source>
          <target state="translated">在此， &lt;code&gt;x&lt;/code&gt; 具有寿命 &lt;code&gt;'b&lt;/code&gt; ，在这种情况下，寿命大于 &lt;code&gt;'a&lt;/code&gt; 。这意味着 &lt;code&gt;r&lt;/code&gt; 可以引用 &lt;code&gt;x&lt;/code&gt; ,因为Rust知道 &lt;code&gt;r&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt; 有效时将始终有效。</target>
        </trans-unit>
        <trans-unit id="e10c369ea788e27a00713fc168a85308c89bf1c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound by-value in one case and by-reference in the other.</source>
          <target state="translated">在此， &lt;code&gt;y&lt;/code&gt; 在一种情况下受值约束，而在另一种情况下受引用约束。</target>
        </trans-unit>
        <trans-unit id="7d5607669abd7c37655a986b9a8d2fca66769741" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound to the contents of the &lt;code&gt;Some&lt;/code&gt; and can be used within the block corresponding to the match arm. However, in case &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, we have not specified what &lt;code&gt;y&lt;/code&gt; is, and the block will use a nonexistent variable.</source>
          <target state="translated">此处， &lt;code&gt;y&lt;/code&gt; 绑定到 &lt;code&gt;Some&lt;/code&gt; 的内容，并且可以在与匹配臂相对应的块中使用。但是，如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则我们没有指定 &lt;code&gt;y&lt;/code&gt; 是什么，并且该块将使用不存在的变量。</target>
        </trans-unit>
        <trans-unit id="a792c6d2920136f42b2c0328d50b11b4b1f68c36" translate="yes" xml:space="preserve">
          <source>Here, all types implementing &lt;code&gt;Foo&lt;/code&gt; must have a method &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; which can take any type &lt;code&gt;T&lt;/code&gt;. However, in the &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;bool&lt;/code&gt;, we have added an extra bound that &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, which isn't compatible with the original trait.</source>
          <target state="translated">在此，实现所有类型 &lt;code&gt;Foo&lt;/code&gt; 必须有一个方法 &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; 可采取任何类型 &lt;code&gt;T&lt;/code&gt; 。然而，在 &lt;code&gt;impl&lt;/code&gt; 针对 &lt;code&gt;bool&lt;/code&gt; ，我们增加了一个额外的约束，且 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;Copy&lt;/code&gt; ，这是不符合原来的特质兼容。</target>
        </trans-unit>
        <trans-unit id="e86bf62ea38db4534581f774aebf9c330891b88f" translate="yes" xml:space="preserve">
          <source>Here, even though &lt;code&gt;x&lt;/code&gt; is not one of the parameters of &lt;code&gt;equal_to_x&lt;/code&gt;, the &lt;code&gt;equal_to_x&lt;/code&gt; closure is allowed to use the &lt;code&gt;x&lt;/code&gt; variable that&amp;rsquo;s defined in the same scope that &lt;code&gt;equal_to_x&lt;/code&gt; is defined in.</source>
          <target state="translated">在这里，即使 &lt;code&gt;x&lt;/code&gt; 不是 &lt;code&gt;equal_to_x&lt;/code&gt; 的参数之一，也允许 &lt;code&gt;equal_to_x&lt;/code&gt; 闭包使用在与 &lt;code&gt;equal_to_x&lt;/code&gt; 相同的作用域中定义的 &lt;code&gt;x&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="3efa2682153806eb1dbead68e3ef30ae590912ca" translate="yes" xml:space="preserve">
          <source>Here, even though we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all. Here is the error message we get:</source>
          <target state="translated">在这里，即使我们为返回类型指定了生命周期参数 &lt;code&gt;'a&lt;/code&gt; ，该实现也将无法编译，因为返回值生命周期与参数的生命周期完全无关。这是我们得到的错误消息：</target>
        </trans-unit>
        <trans-unit id="da2b63d2db9c34aa4fad7b681faf1cae153440c5" translate="yes" xml:space="preserve">
          <source>Here, our response has a status line with status code 404 and the reason phrase &lt;code&gt;NOT FOUND&lt;/code&gt;. We&amp;rsquo;re still not returning headers, and the body of the response will be the HTML in the file &lt;em&gt;404.html&lt;/em&gt;. You&amp;rsquo;ll need to create a &lt;em&gt;404.html&lt;/em&gt; file next to &lt;em&gt;hello.html&lt;/em&gt; for the error page; again feel free to use any HTML you want or use the example HTML in Listing 20-8.</source>
          <target state="translated">在此，我们的响应包含一条状态行，其状态码为404，原因短语 &lt;code&gt;NOT FOUND&lt;/code&gt; 。我们仍然没有返回标头，响应的主体将是文件&lt;em&gt;404.html中&lt;/em&gt;的HTML 。您需要在&lt;em&gt;hello.html&lt;/em&gt;旁边为错误页面创建&lt;em&gt;404.html&lt;/em&gt;文件；再次随意使用您想要的任何HTML或使用清单20-8中的示例HTML。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2749e5eb8656bede400f4e0b8d184580a4d9adf" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;BitAndAssign&lt;/code&gt; trait is implemented for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在这里，为围绕 &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 的包装器实现了 &lt;code&gt;BitAndAssign&lt;/code&gt; 特性。</target>
        </trans-unit>
        <trans-unit id="73314800534c2c9290a895f1b2e09cd5c74b13fa" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;nothing_is_true&lt;/code&gt; method takes the ownership of &lt;code&gt;self&lt;/code&gt;. However, &lt;code&gt;self&lt;/code&gt; cannot be moved because &lt;code&gt;.borrow()&lt;/code&gt; only provides an &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt;, which is a borrow of the content owned by the &lt;code&gt;RefCell&lt;/code&gt;. To fix this error, you have three choices:</source>
          <target state="translated">在这里， &lt;code&gt;nothing_is_true&lt;/code&gt; 方法采用了 &lt;code&gt;self&lt;/code&gt; 的所有权。但是， &lt;code&gt;self&lt;/code&gt; 不能移动，因为 &lt;code&gt;.borrow()&lt;/code&gt; 仅提供 &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt; ，它是 &lt;code&gt;RefCell&lt;/code&gt; 拥有的内容的借用。要解决此错误，您可以选择三个选项：</target>
        </trans-unit>
        <trans-unit id="9ecdeb34514236dc334d979e1fa6dac1a4f47ca1" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;yield&lt;/code&gt; keyword is used in an &lt;code&gt;async&lt;/code&gt; block, which is not yet supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f1ad21d4790c6fa776cb2d79a7da13085bbb0b" translate="yes" xml:space="preserve">
          <source>Here, the code counts up through the elements in the array. It starts at index &lt;code&gt;0&lt;/code&gt;, and then loops until it reaches the final index in the array (that is, when &lt;code&gt;index &amp;lt; 5&lt;/code&gt; is no longer true). Running this code will print every element in the array:</source>
          <target state="translated">在这里，代码通过数组中的元素递增计数。它从索引 &lt;code&gt;0&lt;/code&gt; 开始，然后循环直到到达数组中的最终索引（也就是说，当 &lt;code&gt;index &amp;lt; 5&lt;/code&gt; 不再为true时）。运行以下代码将打印数组中的每个元素：</target>
        </trans-unit>
        <trans-unit id="f6e9fdb531b1a1a673e70ab403c2068ef72bf3e1" translate="yes" xml:space="preserve">
          <source>Here, the expression &lt;code&gt;&amp;amp;foo()&lt;/code&gt; is borrowing the expression &lt;code&gt;foo()&lt;/code&gt;. As &lt;code&gt;foo()&lt;/code&gt; is a call to a function, and not the name of a variable, this creates a &lt;strong&gt;temporary&lt;/strong&gt; -- that temporary stores the return value from &lt;code&gt;foo()&lt;/code&gt; so that it can be borrowed. You could imagine that &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; is equivalent to this:</source>
          <target state="translated">在这里，表达式 &lt;code&gt;&amp;amp;foo()&lt;/code&gt; 借用了表达式 &lt;code&gt;foo()&lt;/code&gt; 。由于 &lt;code&gt;foo()&lt;/code&gt; 是对函数的调用，而不是变量的名称，因此会创建一个&lt;strong&gt;临时文件&lt;/strong&gt; -该临时文件存储 &lt;code&gt;foo()&lt;/code&gt; 的返回值，以便可以借用它。您可以想象 &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; 等效于此：</target>
        </trans-unit>
        <trans-unit id="408c7fbfdfe961fb58eba63dc21b905f34fe6b5c" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;eat&lt;/code&gt; takes ownership of &lt;code&gt;x&lt;/code&gt;. However, &lt;code&gt;x&lt;/code&gt; cannot be moved because the borrow to &lt;code&gt;_ref_to_val&lt;/code&gt; needs to last till the function &lt;code&gt;borrow&lt;/code&gt;. To fix that you can do a few different things:</source>
          <target state="translated">在这里，函数 &lt;code&gt;eat&lt;/code&gt; 获得 &lt;code&gt;x&lt;/code&gt; 的所有权。但是，不能移动 &lt;code&gt;x&lt;/code&gt; ,因为对 &lt;code&gt;_ref_to_val&lt;/code&gt; 的借用需要持续到函数 &lt;code&gt;borrow&lt;/code&gt; 为止。要解决此问题，您可以做一些不同的事情：</target>
        </trans-unit>
        <trans-unit id="34b4fc7688b4cc55dbce35a5cbba7cf5aa481597" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;foo&lt;/code&gt; returns a value of type &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt;, which references the lifetime &lt;code&gt;'x&lt;/code&gt;. However, the return type is declared as &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; -- this indicates that &lt;code&gt;foo&lt;/code&gt; returns &quot;some type that implements &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt;&quot;, but it also indicates that the return type &lt;strong&gt;only captures data referencing the lifetime &lt;code&gt;'y&lt;/code&gt;&lt;/strong&gt;. In this case, though, we are referencing data with lifetime &lt;code&gt;'x&lt;/code&gt;, so this function is in error.</source>
          <target state="translated">在此，函数 &lt;code&gt;foo&lt;/code&gt; 返回类型为 &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt; ，该值引用生存期 &lt;code&gt;'x&lt;/code&gt; 。但是，返回类型被声明为 &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; －这表明 &lt;code&gt;foo&lt;/code&gt; 返回&amp;ldquo;实现 &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt; 某种类型&amp;rdquo;，但它也表明该返回类型&lt;strong&gt;仅捕获引用生存期 &lt;code&gt;'y&lt;/code&gt; 的数据&lt;/strong&gt;。但是，在这种情况下，我们引用的生命期为 &lt;code&gt;'x&lt;/code&gt; ，因此此函数有错误。</target>
        </trans-unit>
        <trans-unit id="89055a364d466030b4b32dbb99ee9d2965691a35" translate="yes" xml:space="preserve">
          <source>Here, the loop never ends, so &lt;code&gt;!&lt;/code&gt; is the value of the expression. However, this wouldn&amp;rsquo;t be true if we included a &lt;code&gt;break&lt;/code&gt;, because the loop would terminate when it got to the &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">在这里，循环永远不会结束，所以 &lt;code&gt;!&lt;/code&gt; 是表达式的值。但是，如果我们包含 &lt;code&gt;break&lt;/code&gt; ，则情况并非如此，因为循环将在到达 &lt;code&gt;break&lt;/code&gt; 时终止。</target>
        </trans-unit>
        <trans-unit id="df47ee6ed5cabbf7215bb10c59a544458415fee2" translate="yes" xml:space="preserve">
          <source>Here, the problem is that a reference type like &lt;code&gt;&amp;amp;'a T&lt;/code&gt; is only valid if all the data in T outlives the lifetime &lt;code&gt;'a&lt;/code&gt;. But this impl as written is applicable to any lifetime &lt;code&gt;'a&lt;/code&gt; and any type &lt;code&gt;T&lt;/code&gt; -- we have no guarantee that &lt;code&gt;T&lt;/code&gt; outlives &lt;code&gt;'a&lt;/code&gt;. To fix this, you can add a where clause like &lt;code&gt;where T: 'a&lt;/code&gt;.</source>
          <target state="translated">这里的问题是，仅当 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 中的所有数据都超过生存期 &lt;code&gt;'a&lt;/code&gt; 时,类似＆'a T的引用类型才有效。但是，该隐含含义适用于任何生存期 &lt;code&gt;'a&lt;/code&gt; 和任何类型 &lt;code&gt;T&lt;/code&gt; -我们无法保证 &lt;code&gt;T&lt;/code&gt; 的寿命超过 &lt;code&gt;'a&lt;/code&gt; 。要解决此问题，您可以添加where子句，例如 &lt;code&gt;where T: 'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0ef28f4a5284b6e2516b2e042ed2f018d33a029" translate="yes" xml:space="preserve">
          <source>Here, the problem is that the compiler cannot be sure that the &lt;code&gt;'b&lt;/code&gt; lifetime will live longer than &lt;code&gt;'a&lt;/code&gt;, which should be mandatory in order to be sure that &lt;code&gt;Trait::Out&lt;/code&gt; will always have a reference pointing to an existing type. So in this case, we just need to tell the compiler than &lt;code&gt;'b&lt;/code&gt; must outlive &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362d656c8582920eb1fa6e2f837dcd77621e2783" translate="yes" xml:space="preserve">
          <source>Here, the supertrait might have methods as follows:</source>
          <target state="translated">在这里,超纲可能有如下方法。</target>
        </trans-unit>
        <trans-unit id="09d377b97ceff52f388bef9d69ecd4e08de82e8e" translate="yes" xml:space="preserve">
          <source>Here, the type of &lt;code&gt;bar&lt;/code&gt; isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</source>
          <target state="translated">这里， &lt;code&gt;bar&lt;/code&gt; 的类型未知。它可能是任何东西的指针。相反，请为指针指定一种类型（最好是对您要指向的东西有意义的一种）：</target>
        </trans-unit>
        <trans-unit id="6683d46fded95c67df0b49024b3446d80dd204a6" translate="yes" xml:space="preserve">
          <source>Here, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="translated">在这里，不知道在impl上出现的where子句 &lt;code&gt;T: 'a&lt;/code&gt; 在struct上是不满足的。要编译此示例，您必须在结构定义中添加一个类似 &lt;code&gt;T: 'a&lt;/code&gt; 的子句：</target>
        </trans-unit>
        <trans-unit id="5f5bdb12ef17925552b810b20339fc4188e58923" translate="yes" xml:space="preserve">
          <source>Here, there's no need to allocate more memory inside the loop.</source>
          <target state="translated">这里,不需要在循环里面分配更多的内存。</target>
        </trans-unit>
        <trans-unit id="64f50e4beb0199dca819447bd86bfb2e950cfebb" translate="yes" xml:space="preserve">
          <source>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because, because the type of &lt;code&gt;foo&lt;/code&gt; is a function &lt;strong&gt;item&lt;/strong&gt; (&lt;code&gt;typeof(foo)&lt;/code&gt;), which is zero-sized, and the target type (&lt;code&gt;fn()&lt;/code&gt;) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</source>
          <target state="translated">在这里，transmute用于转换fn参数的类型。这种模式是不正确的，因为因为 &lt;code&gt;foo&lt;/code&gt; 的类型是一个零大小的函数&lt;strong&gt;项&lt;/strong&gt;（ &lt;code&gt;typeof(foo)&lt;/code&gt; ），而目标类型（ &lt;code&gt;fn()&lt;/code&gt; ）是一个非零大小的函数指针。此模式应重写。有几种方法可以做到这一点：</target>
        </trans-unit>
        <trans-unit id="11f7e7a9427d5e270e6bb9180be033e23a1b7abb" translate="yes" xml:space="preserve">
          <source>Here, we are still borrowing &lt;code&gt;foo()&lt;/code&gt;, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</source>
          <target state="translated">在这里，我们仍在借用 &lt;code&gt;foo()&lt;/code&gt; ，但是由于借用是直接分配给变量的，因此直到封闭块的末尾，临时变量才会被删除。当临时变量存储到诸如元组或结构的聚合结构中时，适用类似的规则：</target>
        </trans-unit>
        <trans-unit id="2fe93444419186b520c70f702a92a3495d890ab8" translate="yes" xml:space="preserve">
          <source>Here, we create a new variable &lt;code&gt;case_sensitive&lt;/code&gt;. To set its value, we call the &lt;code&gt;env::var&lt;/code&gt; function and pass it the name of the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable. The &lt;code&gt;env::var&lt;/code&gt; function returns a &lt;code&gt;Result&lt;/code&gt; that will be the successful &lt;code&gt;Ok&lt;/code&gt; variant that contains the value of the environment variable if the environment variable is set. It will return the &lt;code&gt;Err&lt;/code&gt; variant if the environment variable is not set.</source>
          <target state="translated">在这里，我们创建一个新变量 &lt;code&gt;case_sensitive&lt;/code&gt; 。要设置其值，我们调用 &lt;code&gt;env::var&lt;/code&gt; 函数并将其传递给 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 环境变量的名称。该 &lt;code&gt;env::var&lt;/code&gt; 函数返回一个 &lt;code&gt;Result&lt;/code&gt; ，这将是成功的 &lt;code&gt;Ok&lt;/code&gt; 包含环境变量的值，如果环境变量设置的变体。如果未设置环境变量，它将返回 &lt;code&gt;Err&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="629de8d4fd404424f68755750d18203229995313" translate="yes" xml:space="preserve">
          <source>Here, we declare a trait using the &lt;code&gt;trait&lt;/code&gt; keyword and then the trait&amp;rsquo;s name, which is &lt;code&gt;Summary&lt;/code&gt; in this case. Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt;.</source>
          <target state="translated">在这里，我们使用 &lt;code&gt;trait&lt;/code&gt; 关键字声明一个特征，然后使用该特征的名称，在本例中为 &lt;code&gt;Summary&lt;/code&gt; 。在大括号内，我们声明方法签名，这些签名描述实现此特征的类型的行为，在这种情况下为 &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5d31c7a816695d5663a1af214bdd61a0f312631" translate="yes" xml:space="preserve">
          <source>Here, we first call &lt;code&gt;lock&lt;/code&gt; on the &lt;code&gt;receiver&lt;/code&gt; to acquire the mutex, and then we call &lt;code&gt;unwrap&lt;/code&gt; to panic on any errors. Acquiring a lock might fail if the mutex is in a &lt;em&gt;poisoned&lt;/em&gt; state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling &lt;code&gt;unwrap&lt;/code&gt; to have this thread panic is the correct action to take. Feel free to change this &lt;code&gt;unwrap&lt;/code&gt; to an &lt;code&gt;expect&lt;/code&gt; with an error message that is meaningful to you.</source>
          <target state="translated">在这里，我们第一个电话 &lt;code&gt;lock&lt;/code&gt; 在 &lt;code&gt;receiver&lt;/code&gt; 获得互斥体，然后我们呼吁 &lt;code&gt;unwrap&lt;/code&gt; 恐慌的任何错误。如果互斥锁处于&lt;em&gt;中毒&lt;/em&gt;状态，则获取锁可能会失败，而如果其他一些线程在持有锁而不是释放锁的情况下发生了恐慌，则可能会发生这种情况。在这种情况下，调用 &lt;code&gt;unwrap&lt;/code&gt; 使此线程紧急状态是正确的操作。随意更改此 &lt;code&gt;unwrap&lt;/code&gt; 来的 &lt;code&gt;expect&lt;/code&gt; 与对您有意义的错误消息。</target>
        </trans-unit>
        <trans-unit id="90ed3acfd08d6add91c92898299f8f082c9b0a5d" translate="yes" xml:space="preserve">
          <source>Here, we give a description of what the &lt;code&gt;add_one&lt;/code&gt; function does, start a section with the heading &lt;code&gt;Examples&lt;/code&gt;, and then provide code that demonstrates how to use the &lt;code&gt;add_one&lt;/code&gt; function. We can generate the HTML documentation from this documentation comment by running &lt;code&gt;cargo doc&lt;/code&gt;. This command runs the &lt;code&gt;rustdoc&lt;/code&gt; tool distributed with Rust and puts the generated HTML documentation in the &lt;em&gt;target/doc&lt;/em&gt; directory.</source>
          <target state="translated">在这里，我们给什么样的描述 &lt;code&gt;add_one&lt;/code&gt; 功能呢，先从标题一节 &lt;code&gt;Examples&lt;/code&gt; ，然后提供演示如何使用代码 &lt;code&gt;add_one&lt;/code&gt; 功能。我们可以通过运行 &lt;code&gt;cargo doc&lt;/code&gt; 从此文档注释生成HTML文档。此命令运行随Rust &lt;code&gt;rustdoc&lt;/code&gt; 分发的rustdoc工具，并将生成的HTML文档放入&lt;em&gt;target / doc&lt;/em&gt;目录。</target>
        </trans-unit>
        <trans-unit id="509084bc1cc2854ecab3677678733d63bccc2260" translate="yes" xml:space="preserve">
          <source>Here, we have a package that only contains &lt;em&gt;src/main.rs&lt;/em&gt;, meaning it only contains a binary crate named &lt;code&gt;my-project&lt;/code&gt;. If a package contains &lt;em&gt;src/main.rs&lt;/em&gt; and &lt;em&gt;src/lib.rs&lt;/em&gt;, it has two crates: a library and a binary, both with the same name as the package. A package can have multiple binary crates by placing files in the &lt;em&gt;src/bin&lt;/em&gt; directory: each file will be a separate binary crate.</source>
          <target state="translated">在这里，我们有一个仅包含&lt;em&gt;src / main.rs&lt;/em&gt;的软件包，这意味着它仅包含一个名为 &lt;code&gt;my-project&lt;/code&gt; 的二进制板条箱。如果软件包包含&lt;em&gt;src / main.rs&lt;/em&gt;和&lt;em&gt;src / lib.rs&lt;/em&gt;，则它有两个包装箱：库和二进制文件，两者的名称与软件包相同。通过将文件放在&lt;em&gt;src / bin&lt;/em&gt;目录中，一个软件包可以具有多个二进制文件&lt;em&gt;箱&lt;/em&gt;：每个文件将是一个单独的二进制文件箱。</target>
        </trans-unit>
        <trans-unit id="214685b848acbf415bb3dbd9186c1466aa631aa7" translate="yes" xml:space="preserve">
          <source>Here, we have two parameters of type &lt;code&gt;TokenStream&lt;/code&gt;. The first is for the contents of the attribute: the &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; part. The second is the body of the item the attribute is attached to: in this case, &lt;code&gt;fn index() {}&lt;/code&gt; and the rest of the function&amp;rsquo;s body.</source>
          <target state="translated">在这里，我们有两个类型为 &lt;code&gt;TokenStream&lt;/code&gt; 的参数。第一个用于属性的内容： &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; 部分。第二个是属性附加到的项目的主体：在这种情况下，为 &lt;code&gt;fn index() {}&lt;/code&gt; 和函数主体的其余部分。</target>
        </trans-unit>
        <trans-unit id="9da25d2edfbc8a834054d09a3a531a79272bf467" translate="yes" xml:space="preserve">
          <source>Here, we match a tuple against a pattern. Rust compares the value &lt;code&gt;(1, 2, 3)&lt;/code&gt; to the pattern &lt;code&gt;(x, y, z)&lt;/code&gt; and sees that the value matches the pattern, so Rust binds &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;. You can think of this tuple pattern as nesting three individual variable patterns inside it.</source>
          <target state="translated">在这里，我们将元组与模式匹配。Rust将值 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 与模式 &lt;code&gt;(x, y, z)&lt;/code&gt; ，发现该值与模式匹配，因此Rust将 &lt;code&gt;1&lt;/code&gt; 绑定到 &lt;code&gt;x&lt;/code&gt; ，将 &lt;code&gt;2&lt;/code&gt; 绑定到 &lt;code&gt;y&lt;/code&gt; ，将 &lt;code&gt;3&lt;/code&gt; 绑定到 &lt;code&gt;z&lt;/code&gt; 。您可以将这个元组模式视为在其中嵌套三个单独的变量模式。</target>
        </trans-unit>
        <trans-unit id="3807aec2b6a72b122da57a852fc8dc8b9b746c8b" translate="yes" xml:space="preserve">
          <source>Here, we tried to move a field out of a struct of type &lt;code&gt;DropStruct&lt;/code&gt; which implements the &lt;code&gt;Drop&lt;/code&gt; trait. However, a struct cannot be dropped if one or more of its fields have been moved.</source>
          <target state="translated">在这里，我们尝试将字段移出实现 &lt;code&gt;Drop&lt;/code&gt; 特性的 &lt;code&gt;DropStruct&lt;/code&gt; 类型的结构。但是，如果一个结构的一个或多个字段已移动，则不能删除该结构。</target>
        </trans-unit>
        <trans-unit id="182fd49127f0c327471148134a76b7aecc6837c0" translate="yes" xml:space="preserve">
          <source>Here, we try to print &lt;code&gt;val&lt;/code&gt; after we&amp;rsquo;ve sent it down the channel via &lt;code&gt;tx.send&lt;/code&gt;. Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread&amp;rsquo;s modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:</source>
          <target state="translated">在这里，我们通过 &lt;code&gt;tx.send&lt;/code&gt; 将其发送到通道后尝试打印 &lt;code&gt;val&lt;/code&gt; 。允许这样做是一个坏主意：一旦将值发送到另一个线程，该线程可以在我们再次尝试使用该值之前对其进行修改或删除。潜在的是，另一个线程的修改可能由于数据不一致或不存在而导致错误或意外结果。但是，如果我们尝试编译清单16-9中的代码，Rust给我们一个错误：</target>
        </trans-unit>
        <trans-unit id="e6e942400049c5831b3b39dbc83c98fc061c7f27" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We&amp;rsquo;ll be sending simple values between threads using a channel to illustrate the feature. Once you&amp;rsquo;re familiar with the technique, you could use channels to implement a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.</source>
          <target state="translated">在这里，我们将处理一个程序，该程序具有一个线程来生成值并将其发送到一个通道，而另一个线程将接收值并打印出来。我们将使用通道来说明功能在线程之间发送简单值。熟悉这项技术后，您就可以使用渠道来实现聊天系统或由许多线程执行一部分计算并将这些部分发送到一个汇总结果的线程的系统。</target>
        </trans-unit>
        <trans-unit id="2b30624caca04c6adde1f0c4c5c0896dda9444b6" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but it has only 3 elements. In this situation, Rust will panic. Using &lt;code&gt;[]&lt;/code&gt; is supposed to return an element, but if you pass an invalid index, there&amp;rsquo;s no element that Rust could return here that would be correct.</source>
          <target state="translated">在这里，我们尝试访问向量的第100个元素（由于索引从零开始，因此位于索引99处），但是它只有3个元素。在这种情况下，Rust会惊慌。应该使用 &lt;code&gt;[]&lt;/code&gt; 返回一个元素，但是如果传递无效索引，则Rust不会在此处返回正确的元素。</target>
        </trans-unit>
        <trans-unit id="5696f367dcde9c29280ed019893b8b93043b4ae3" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re calling the &lt;code&gt;do_something&lt;/code&gt; function 100 times, but we never use the variable &lt;code&gt;i&lt;/code&gt; in the body of the &lt;code&gt;for&lt;/code&gt; loop. Rust warns us about that:</source>
          <target state="translated">在这里，我们要调用 &lt;code&gt;do_something&lt;/code&gt; 函数100次，但是我们永远不会在 &lt;code&gt;for&lt;/code&gt; 循环的主体中使用变量 &lt;code&gt;i&lt;/code&gt; 。Rust对此警告我们：</target>
        </trans-unit>
        <trans-unit id="0738694c0b9e33967ee0ed11850ca18af144e2e8" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re creating a new instance of the &lt;code&gt;User&lt;/code&gt; struct, which has a field named &lt;code&gt;email&lt;/code&gt;. We want to set the &lt;code&gt;email&lt;/code&gt; field&amp;rsquo;s value to the value in the &lt;code&gt;email&lt;/code&gt; parameter of the &lt;code&gt;build_user&lt;/code&gt; function. Because the &lt;code&gt;email&lt;/code&gt; field and the &lt;code&gt;email&lt;/code&gt; parameter have the same name, we only need to write &lt;code&gt;email&lt;/code&gt; rather than &lt;code&gt;email: email&lt;/code&gt;.</source>
          <target state="translated">在这里，我们正在创建 &lt;code&gt;User&lt;/code&gt; 结构的新实例，该实例具有一个名为 &lt;code&gt;email&lt;/code&gt; 的字段。我们想将 &lt;code&gt;email&lt;/code&gt; 字段的值设置为 &lt;code&gt;build_user&lt;/code&gt; 函数的 &lt;code&gt;email&lt;/code&gt; 参数中的值。因为 &lt;code&gt;email&lt;/code&gt; 字段和 &lt;code&gt;email&lt;/code&gt; 参数具有相同的名称，所以我们只需要编写 &lt;code&gt;email&lt;/code&gt; 而不是 &lt;code&gt;email: email&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e907cc8b08cfb8b71a6716a55c4e7e4751a1f7" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve annotated the lifetime of &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;'a&lt;/code&gt; and the lifetime of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;'b&lt;/code&gt;. As you can see, the inner &lt;code&gt;'b&lt;/code&gt; block is much smaller than the outer &lt;code&gt;'a&lt;/code&gt; lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that &lt;code&gt;r&lt;/code&gt; has a lifetime of &lt;code&gt;'a&lt;/code&gt; but that it refers to memory with a lifetime of &lt;code&gt;'b&lt;/code&gt;. The program is rejected because &lt;code&gt;'b&lt;/code&gt; is shorter than &lt;code&gt;'a&lt;/code&gt;: the subject of the reference doesn&amp;rsquo;t live as long as the reference.</source>
          <target state="translated">在这里，我们用 &lt;code&gt;'a&lt;/code&gt; 标注 &lt;code&gt;r&lt;/code&gt; 的生命周期，用 &lt;code&gt;'b&lt;/code&gt; 标注 &lt;code&gt;x&lt;/code&gt; 的生命周期。如您所见，内部的 &lt;code&gt;'b&lt;/code&gt; 块比外部的 &lt;code&gt;'a&lt;/code&gt; 生存期块小得多。在编译时，Rust比较两个生存期的大小，发现 &lt;code&gt;r&lt;/code&gt; 的生存期为 &lt;code&gt;'a&lt;/code&gt; ,但它引用的生存期为 &lt;code&gt;'b&lt;/code&gt; 。该程序被拒绝，因为 &lt;code&gt;'b&lt;/code&gt; 短于 &lt;code&gt;'a&lt;/code&gt; ：引用的主题没有引用那么长。</target>
        </trans-unit>
        <trans-unit id="1d072835ae81d38506d756c212f27d937b407880" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a method named &lt;code&gt;x&lt;/code&gt; on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that returns a reference to the data in the field &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">在这里，我们在 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 上定义了一个名为 &lt;code&gt;x&lt;/code&gt; 的方法，该方法返回对字段 &lt;code&gt;x&lt;/code&gt; 中数据的引用。</target>
        </trans-unit>
        <trans-unit id="b22056ea03c2bfc7c7131245d47003a6d2f7232e" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a struct &lt;code&gt;IpAddr&lt;/code&gt; that has two fields: a &lt;code&gt;kind&lt;/code&gt; field that is of type &lt;code&gt;IpAddrKind&lt;/code&gt; (the enum we defined previously) and an &lt;code&gt;address&lt;/code&gt; field of type &lt;code&gt;String&lt;/code&gt;. We have two instances of this struct. The first, &lt;code&gt;home&lt;/code&gt;, has the value &lt;code&gt;IpAddrKind::V4&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; with associated address data of &lt;code&gt;127.0.0.1&lt;/code&gt;. The second instance, &lt;code&gt;loopback&lt;/code&gt;, has the other variant of &lt;code&gt;IpAddrKind&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; value, &lt;code&gt;V6&lt;/code&gt;, and has address &lt;code&gt;::1&lt;/code&gt; associated with it. We&amp;rsquo;ve used a struct to bundle the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; values together, so now the variant is associated with the value.</source>
          <target state="translated">在这里，我们定义了一个结构 &lt;code&gt;IpAddr&lt;/code&gt; ，它具有两个字段：一个 &lt;code&gt;kind&lt;/code&gt; 字段，其类型为 &lt;code&gt;IpAddrKind&lt;/code&gt; （我们之前定义的枚举），另一个 &lt;code&gt;address&lt;/code&gt; 类型为 &lt;code&gt;String&lt;/code&gt; 。我们有此结构的两个实例。第一个为 &lt;code&gt;home&lt;/code&gt; ，其值为 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 作为其 &lt;code&gt;kind&lt;/code&gt; 具有关联的地址数据 &lt;code&gt;127.0.0.1&lt;/code&gt; 。第二个实例 &lt;code&gt;loopback&lt;/code&gt; 具有 &lt;code&gt;IpAddrKind&lt;/code&gt; 的另一个变体作为其 &lt;code&gt;kind&lt;/code&gt; 值 &lt;code&gt;V6&lt;/code&gt; ，并具有与 &lt;code&gt;::1&lt;/code&gt; 关联的地址。我们使用了一个结构将 &lt;code&gt;kind&lt;/code&gt; 和 &lt;code&gt;address&lt;/code&gt; 值一起使用，因此现在变量与值相关联。</target>
        </trans-unit>
        <trans-unit id="046091a3f10b4e94cc5b7d93ba3518dfd24f4c0f" translate="yes" xml:space="preserve">
          <source>Here, we're saying that the implementation exists on Wrapper only when the wrapped type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;where&lt;/code&gt; clause is important because some types will not implement &lt;code&gt;Clone&lt;/code&gt;, and thus will not get this method.</source>
          <target state="translated">在这里，我们说的是只有包装类型 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Clone&lt;/code&gt; 时，该实现才存在于Wrapper上。在 &lt;code&gt;where&lt;/code&gt; ，因为某些类型将不执行条款是很重要的 &lt;code&gt;Clone&lt;/code&gt; ，因而不会得到这种方法。</target>
        </trans-unit>
        <trans-unit id="84c52d06e43bddd068876e6b5771442213f18d2a" translate="yes" xml:space="preserve">
          <source>Here, you have used the inappropriate lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;, The &lt;code&gt;impl Trait&lt;/code&gt; can only capture lifetimes bound at the fn or impl level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb18b6c522d039c3c0dcd7089256c0ad6492059" translate="yes" xml:space="preserve">
          <source>Hex</source>
          <target state="translated">Hex</target>
        </trans-unit>
        <trans-unit id="91ed5d7ea6cd895e371f61ed45ccc686b068fc10" translate="yes" xml:space="preserve">
          <source>Hex integer</source>
          <target state="translated">十六进制整数</target>
        </trans-unit>
        <trans-unit id="df212c2ac8dde3b394685d24542d906c68321356" translate="yes" xml:space="preserve">
          <source>Higher-level synchronization objects</source>
          <target state="translated">更高级别的同步对象</target>
        </trans-unit>
        <trans-unit id="7319d8cc88397a63e7ae82683fed6023e2ba482c" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetime bounds</source>
          <target state="translated">排名较高的一生界限</target>
        </trans-unit>
        <trans-unit id="699f2601254a23df8fa1d5fed485a0da27f47873" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetimes may also be specified just before the trait, the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</source>
          <target state="translated">也可以在特质之前指定更高等级的寿命,唯一不同的是寿命参数的范围,它只延伸到下面特质的末端,而不是整个边界。这个函数相当于上一个函数。</target>
        </trans-unit>
        <trans-unit id="33df4c2b13cbd6c2495bdbed3c2c401ea9db0b73" translate="yes" xml:space="preserve">
          <source>Higher-ranked trait bounds</source>
          <target state="translated">较高等级的特质界限</target>
        </trans-unit>
        <trans-unit id="02d9e95b138a4fba666ec5899da0c73598dfb07a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized.</source>
          <target state="translated">对编译器的提示,影响代码应该如何发出或优化。</target>
        </trans-unit>
        <trans-unit id="410abe45925442482c6a1847631462e1f9e2aa9a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized. Hints may be compile time or runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa3a5e1e29277a4a2b8f85784650b518cec2c19" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</source>
          <target state="translated">向编译器提示分支条件可能为假。返回传递给它的值。</target>
        </trans-unit>
        <trans-unit id="97a557b0407c848d7b5a674a63e1f75673a72a22" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</source>
          <target state="translated">向编译器提示分支条件可能为真。返回传递给它的值。</target>
        </trans-unit>
        <trans-unit id="80fd9958e4052dae4a04ec25478352520d67b4b8" translate="yes" xml:space="preserve">
          <source>Hooray! Rust 1.5 is done! However, we&amp;rsquo;ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the &lt;em&gt;next&lt;/em&gt; version of Rust, 1.6. So after &lt;code&gt;stable&lt;/code&gt; branches off of &lt;code&gt;beta&lt;/code&gt;, the next version of &lt;code&gt;beta&lt;/code&gt; branches off of &lt;code&gt;nightly&lt;/code&gt; again:</source>
          <target state="translated">万岁！Rust 1.5完成了！但是，我们已经忘记了一件事：由于已经过去了六个星期，因此我们还需要&lt;em&gt;下一个&lt;/em&gt; Rust版本1.6 的新Beta 。因此，在 &lt;code&gt;beta&lt;/code&gt; &lt;code&gt;stable&lt;/code&gt; 分支之后， &lt;code&gt;nightly&lt;/code&gt; 版本的 &lt;code&gt;beta&lt;/code&gt; 再次分支一次：</target>
        </trans-unit>
        <trans-unit id="a341da978b3cbbea425da4874e79958a3be6b854" translate="yes" xml:space="preserve">
          <source>How Deref Coercion Interacts with Mutability</source>
          <target state="translated">Deref Coercion如何与Mutability相互作用?</target>
        </trans-unit>
        <trans-unit id="d344cc5f79b7b6e913f964dbbc4e02bc173d4e92" translate="yes" xml:space="preserve">
          <source>How can I compare two different types?</source>
          <target state="translated">如何比较两种不同的类型?</target>
        </trans-unit>
        <trans-unit id="b9691dd477ecb76d1a6f3d5bbee24f86998a66d9" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;Clone&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a983251965c63473a1e84135e053268152b20692" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;Copy&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="90084b4cc636cc9404dd416f2e580ffcac6958d2" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Default&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;Default&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="d8e36d59adc904734a7c5575517b6fe0eeceec60" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Eq&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;Eq&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="abe50871479611eca84afd8dcffaec7414f4b665" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Ord&lt;/code&gt;?</source>
          <target state="translated">如何实施 &lt;code&gt;Ord&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a86f0c480a53af07a5339e4a6426e55601cb46dc" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialEq&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;PartialEq&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a00e532c303bae49fb14eef74bc7c06484efea04" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialOrd&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;PartialOrd&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="8bcb70d690260ea744efd091583de3413f03f2d0" translate="yes" xml:space="preserve">
          <source>How can we define some default values? You can use &lt;code&gt;Default&lt;/code&gt;:</source>
          <target state="translated">我们如何定义一些默认值？您可以使用 &lt;code&gt;Default&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac97bbda97cfacdb06a7fbecfd828bfbc649940c" translate="yes" xml:space="preserve">
          <source>How do we know &lt;code&gt;File::open&lt;/code&gt; returns a &lt;code&gt;Result&lt;/code&gt;? We could look at the &lt;a href=&quot;../std/index&quot;&gt;standard library API documentation&lt;/a&gt;, or we could ask the compiler! If we give &lt;code&gt;f&lt;/code&gt; a type annotation that we know is &lt;em&gt;not&lt;/em&gt; the return type of the function and then try to compile the code, the compiler will tell us that the types don&amp;rsquo;t match. The error message will then tell us what the type of &lt;code&gt;f&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;. Let&amp;rsquo;s try it! We know that the return type of &lt;code&gt;File::open&lt;/code&gt; isn&amp;rsquo;t of type &lt;code&gt;u32&lt;/code&gt;, so let&amp;rsquo;s change the &lt;code&gt;let f&lt;/code&gt; statement to this:</source>
          <target state="translated">我们怎么知道 &lt;code&gt;File::open&lt;/code&gt; 返回 &lt;code&gt;Result&lt;/code&gt; ？我们可以看一下&lt;a href=&quot;../std/index&quot;&gt;标准库API文档&lt;/a&gt;，也可以询问编译器！如果给 &lt;code&gt;f&lt;/code&gt; 一个我们知道&lt;em&gt;不是&lt;/em&gt;函数的返回类型的类型注释，然后尝试编译代码，则编译器会告诉我们类型不匹配。错误消息将告诉我们 &lt;code&gt;f&lt;/code&gt; 的类型&lt;em&gt;是&lt;/em&gt;什么。试试吧！我们知道 &lt;code&gt;File::open&lt;/code&gt; 的返回类型不是 &lt;code&gt;u32&lt;/code&gt; 类型，因此让我们将 &lt;code&gt;let f&lt;/code&gt; 语句更改为：</target>
        </trans-unit>
        <trans-unit id="c77df57666e7d061d1c5eeb6d1b1b4663f41398a" translate="yes" xml:space="preserve">
          <source>How to Use This Book</source>
          <target state="translated">如何使用这本书</target>
        </trans-unit>
        <trans-unit id="9264c72068f4a42ab4bf1cb16708fbe650c704ec" translate="yes" xml:space="preserve">
          <source>How to Write Tests</source>
          <target state="translated">如何编写测试</target>
        </trans-unit>
        <trans-unit id="fc0a5ea77505e42cd0dd485ee502c0a345de0fc4" translate="yes" xml:space="preserve">
          <source>How to Write a Custom &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; Macro</source>
          <target state="translated">如何编写自定义 &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="ad4a0038f92fbf9afa07ab6d269a6a337b56f053" translate="yes" xml:space="preserve">
          <source>How to combine the sub-expressions' values to obtain the value of the expression</source>
          <target state="translated">如何将子表达式的值组合起来,得到表达式的值</target>
        </trans-unit>
        <trans-unit id="9a65f179439d735746c8cd2892082ebe3669f2c2" translate="yes" xml:space="preserve">
          <source>How to create threads to run multiple pieces of code at the same time</source>
          <target state="translated">如何创建线程来同时运行多段代码?</target>
        </trans-unit>
        <trans-unit id="62c635e88978649a0009198984dfd524bc6937d1" translate="yes" xml:space="preserve">
          <source>How to read this documentation</source>
          <target state="translated">如何阅读本文件</target>
        </trans-unit>
        <trans-unit id="2ef34f8c5ce17d8eb29baa4d5f6535815ba4013f" translate="yes" xml:space="preserve">
          <source>How to use these two features to improve the I/O project in Chapter 12</source>
          <target state="translated">第12章如何使用这两个功能来改进I/O项目?</target>
        </trans-unit>
        <trans-unit id="f5abcbd8d5f910274d31d405f70ebd71158dda69" translate="yes" xml:space="preserve">
          <source>However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;, your software will panic! You cannot do this:</source>
          <target state="translated">但是要当心：如果您尝试访问 &lt;code&gt;Vec&lt;/code&gt; 中没有的索引，则您的软件将崩溃！你不能做这个：</target>
        </trans-unit>
        <trans-unit id="9a3761438ee9135873d2d6c4d19984a1561781e6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">但是要小心：此方法期望 &lt;code&gt;self&lt;/code&gt; 是可变的，通常在使用 &lt;code&gt;RefCell&lt;/code&gt; 时不是这种情况。如果 &lt;code&gt;self&lt;/code&gt; 不可变，请看一下&lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="98f7e0f867227ba5004f997a2d43f7281873ef09" translate="yes" xml:space="preserve">
          <source>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; and &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 section 5.11).</source>
          <target state="translated">但是，对于没有总订单的类型，仍然可以单独实现其他类型。例如，对于浮点数， &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; 和 &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; （请参阅IEEE 754-2008第5.11节）。</target>
        </trans-unit>
        <trans-unit id="06b5f47175aeebdf26128c567eba8d39893966c4" translate="yes" xml:space="preserve">
          <source>However programmers will usually prefer to use &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt;&lt;code&gt;Condvar&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es or &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; for their synchronization routines, as they avoid thinking about thread scheduling.</source>
          <target state="translated">但是，程序员通常更喜欢使用&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../sync/struct.condvar&quot;&gt; &lt;code&gt;Condvar&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;作为其同步例程，因为他们避免考虑线程调度。</target>
        </trans-unit>
        <trans-unit id="99de4c47e704419c664802a54254a42292d00132" translate="yes" xml:space="preserve">
          <source>However remember that a type &lt;em&gt;containing&lt;/em&gt; a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is not necessarily the same layout; Rust does not in general guarantee that the fields of a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; have the same order as a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; even if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size and alignment. Furthermore because any bit value is valid for a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:</source>
          <target state="translated">但是请记住，一个类型&lt;em&gt;包含&lt;/em&gt;一个 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 不一定是相同的布局; Rust通常不保证 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; 的字段具有与 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; 相同的顺序，即使 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 具有相同的大小和对齐方式。此外，由于任何位值对于 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 有效，因此编译器无法应用非零/小生境填充优化，可能会导致更大的尺寸：</target>
        </trans-unit>
        <trans-unit id="78a2c549597916b72868a0675d936d5af7b87a27" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fledged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb72443619bbca435164ca1a76cab29482ce889" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fleged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">但是，有一种情况 &lt;code&gt;!&lt;/code&gt; 语法可以在之前使用 &lt;code&gt;!&lt;/code&gt; 稳定为全功能类型：在函数的返回类型位置。具体来说，可以实现两种不同的函数指针类型：</target>
        </trans-unit>
        <trans-unit id="d670e0e16c2745ec16c6eaa903327038d8c0e422" translate="yes" xml:space="preserve">
          <source>However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</source>
          <target state="translated">然而有一个注意事项:在2008年的IEEE-754版本之前,如何解释NaN信号位实际上并没有被指定。大多数平台(尤其是x86和ARM)选择了最终在2008年标准化的解释,但有些平台没有(尤其是MIPS)。因此,MIPS上所有的信号NaN都是x86上的安静NaN,反之亦然。</target>
        </trans-unit>
        <trans-unit id="0351e6925d735478389ca7fa9374b4cd22a63b09" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</source>
          <target state="translated">但是，&lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;最好用于动态情况。当您提前了解所有组件时，这是一种更好的方法：</target>
        </trans-unit>
        <trans-unit id="3371f3c5522eaf5798eeaab8876eaa7be0179a80" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dyn Trait&lt;/code&gt; is likely to produce smaller code than &lt;code&gt;impl Trait&lt;/code&gt; / generic parameters as the method won't be duplicated for each concrete type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9143c027c4bd572f82aee5fcf41df94d158757" translate="yes" xml:space="preserve">
          <source>However, a better solution would be using fully explicit naming of type and trait:</source>
          <target state="translated">然而,更好的解决方案是使用类型和特质的完全显式命名。</target>
        </trans-unit>
        <trans-unit id="ee975de6dd0772652ad342b32f8653a59db9e61f" translate="yes" xml:space="preserve">
          <source>However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:</source>
          <target state="translated">但是,带尾部逗号的单个参数仍然不会被视为元组,遵循在宏调用中忽略尾部逗号的惯例。如果需要的话,可以直接使用1-元组。</target>
        </trans-unit>
        <trans-unit id="b007fe5fc274829b5c0d27c599f3eea8f9ba132a" translate="yes" xml:space="preserve">
          <source>However, associated functions that are part of traits don&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter. When two types in the same scope implement that trait, Rust can&amp;rsquo;t figure out which type you mean unless you use &lt;em&gt;fully qualified syntax&lt;/em&gt;. For example, the &lt;code&gt;Animal&lt;/code&gt; trait in Listing 19-19 has the associated function &lt;code&gt;baby_name&lt;/code&gt;, the implementation of &lt;code&gt;Animal&lt;/code&gt; for the struct &lt;code&gt;Dog&lt;/code&gt;, and the associated function &lt;code&gt;baby_name&lt;/code&gt; defined on &lt;code&gt;Dog&lt;/code&gt; directly.</source>
          <target state="translated">但是，作为特征的一部分的关联函数没有 &lt;code&gt;self&lt;/code&gt; 参数。当同一作用域中的两个类型实现该特性时，Rust无法确定您指的是哪种类型，除非您使用&lt;em&gt;完全限定的语法&lt;/em&gt;。例如，清单19-19中的 &lt;code&gt;Animal&lt;/code&gt; trait具有关联的功能 &lt;code&gt;baby_name&lt;/code&gt; ，结构 &lt;code&gt;Dog&lt;/code&gt; 的 &lt;code&gt;Animal&lt;/code&gt; 的实现以及直接在 &lt;code&gt;Dog&lt;/code&gt; 上定义的关联的功能 &lt;code&gt;baby_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8a92146e9c361c007de32df04115100977209af" translate="yes" xml:space="preserve">
          <source>However, be careful when two types have a common associated type:</source>
          <target state="translated">但是,当两种类型具有共同的关联类型时,要注意。</target>
        </trans-unit>
        <trans-unit id="7c05de5702d4d9921eaeead5a04ffacda460142d" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;a&lt;/code&gt; is still referencing the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that was in &lt;code&gt;b&lt;/code&gt;, that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has a count of 1 rather than 0, so the memory the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped. The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">但是，因为 &lt;code&gt;a&lt;/code&gt; 仍然引用 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 这是在 &lt;code&gt;b&lt;/code&gt; ，即 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 具有1，而不是0的计数，所以存储器中的 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 对堆将不被丢弃。内存将永远坐在那里，计数为1。为了可视化该参考周期，我们在图15-4中创建了一个图表。</target>
        </trans-unit>
        <trans-unit id="0161534a8ade8082b05e52cb4b19d957b4c686da" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc86d5089c69372edd80eafac68df3ec0dbaefb7" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note, however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75f8c79454007f698be22ee125cb88b1db6c03c" translate="yes" xml:space="preserve">
          <source>However, for clients that do not wish to track the capacity returned by &lt;code&gt;alloc_excess&lt;/code&gt; locally, this method is likely to produce useful results.</source>
          <target state="translated">但是，对于不希望在本地跟踪 &lt;code&gt;alloc_excess&lt;/code&gt; 返回的容量的客户端，此方法可能会产生有用的结果。</target>
        </trans-unit>
        <trans-unit id="c6f1d589fbc14406ddd7e944ec737df44d57ed77" translate="yes" xml:space="preserve">
          <source>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust&amp;rsquo;s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code&amp;rsquo;s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an &lt;code&gt;Option&lt;/code&gt;, your program expects to have &lt;em&gt;something&lt;/em&gt; rather than &lt;em&gt;nothing&lt;/em&gt;. Your code then doesn&amp;rsquo;t have to handle two cases for the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won&amp;rsquo;t even compile, so your function doesn&amp;rsquo;t have to check for that case at runtime. Another example is using an unsigned integer type such as &lt;code&gt;u32&lt;/code&gt;, which ensures the parameter is never negative.</source>
          <target state="translated">但是，在所有功能中进行大量错误检查会很麻烦。幸运的是，您可以使用Rust的类型系统（从而检查编译器的类型）来为您做许多检查。如果您的函数具有特定类型的参数，则可以在知道编译器已经确保您具有有效值的情况下继续执行代码的逻辑。例如，如果您使用类型而不是 &lt;code&gt;Option&lt;/code&gt; ，则程序期望的是&lt;em&gt;某些内容&lt;/em&gt;而不是&lt;em&gt;没有内容&lt;/em&gt;。然后，您的代码不必处理 &lt;code&gt;Some&lt;/code&gt; 和 &lt;code&gt;None&lt;/code&gt; 的两种情况变体：只有一种情况肯定具有价值。尝试不向函数传递任何内容的代码甚至不会编译，因此您的函数不必在运行时检查这种情况。另一个示例是使用无符号整数类型（例如 &lt;code&gt;u32&lt;/code&gt; )，以确保参数永远不会为负。</target>
        </trans-unit>
        <trans-unit id="c47ddb353392208fbaf5c29553d62da521ea2e56" translate="yes" xml:space="preserve">
          <source>However, if a type implements &lt;code&gt;Copy&lt;/code&gt;, it instead has 'copy semantics':</source>
          <target state="translated">但是，如果类型实现 &lt;code&gt;Copy&lt;/code&gt; ，则它具有&amp;ldquo;复制语义&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="601ae6aeca914c05ec96fb8df8c9c4178c5a0a78" translate="yes" xml:space="preserve">
          <source>However, if it derives from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;, even though &lt;code&gt;Super&lt;/code&gt; is object safe, the method &lt;code&gt;get_a()&lt;/code&gt; would return an object of unknown type when called on the function. &lt;code&gt;Self&lt;/code&gt; type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</source>
          <target state="translated">但是，即使它是从 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; 派生的，即使 &lt;code&gt;Super&lt;/code&gt; 是对象安全的，方法 &lt;code&gt;get_a()&lt;/code&gt; 也会在函数上调用时返回未知类型的对象。 &lt;code&gt;Self&lt;/code&gt; 类型参数使我们可以使对象安全特征不再安全，因此在指定超级特征时将其禁止使用。</target>
        </trans-unit>
        <trans-unit id="7fad1dff57715fb5c533987e92e806ddbde896cc" translate="yes" xml:space="preserve">
          <source>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</source>
          <target state="translated">但是,如果你仍然希望使用这些类型,你可以通过一个不安全的封装器来实现。</target>
        </trans-unit>
        <trans-unit id="2f1b0df6bf40f54deee89e8870694822d74c8932" translate="yes" xml:space="preserve">
          <source>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</source>
          <target state="translated">但是,如果你想访问一个结构的字段,请检查字段名的拼写是否正确。例子:如果你想访问一个结构的字段,请检查字段名的拼写是否正确。</target>
        </trans-unit>
        <trans-unit id="692ecbc0723f2163cd918161474068cb36f04e45" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26830adb8373fabf090d221485ccd723186cf9b8" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it: two lines for two method calls. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">但是，一长行很难阅读，因此最好将其划分：用于两个方法调用的两行。现在让我们讨论一下这行代码的作用。</target>
        </trans-unit>
        <trans-unit id="dd472996f3f286211f48a487c70490ad383642d1" translate="yes" xml:space="preserve">
          <source>However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We&amp;rsquo;ll write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</source>
          <target state="translated">但是，本章的目的是帮助您学习，而不是走简单的路线。因为Rust是一种系统编程语言，所以我们可以选择我们要使用的抽象级别，并且可以将其降到比其他语言可能或实用的更低的级别。我们将手动编写基本的HTTP服务器和线程池，以便您学习将来可能使用的板条箱背后的一般思想和技术。</target>
        </trans-unit>
        <trans-unit id="a3c7769e69d54d27cbd8d165bbdf117ddc427c2b" translate="yes" xml:space="preserve">
          <source>However, please keep in mind that the first solution should be preferred.</source>
          <target state="translated">但是,请记住,应该首选第一种解决方案。</target>
        </trans-unit>
        <trans-unit id="9e7ca595910d369d04059d59dd0f26ad24257742" translate="yes" xml:space="preserve">
          <source>However, some higher-level allocation methods (&lt;code&gt;alloc_one&lt;/code&gt;, &lt;code&gt;alloc_array&lt;/code&gt;) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return &lt;code&gt;Err&lt;/code&gt;, or to return &lt;code&gt;Ok&lt;/code&gt; with some pointer.</source>
          <target state="translated">但是，一些较高级别的分配方法（ &lt;code&gt;alloc_one&lt;/code&gt; ， &lt;code&gt;alloc_array&lt;/code&gt; ）在零大小的类型上定义良好，并且可以选择支持它们：是否返回 &lt;code&gt;Err&lt;/code&gt; 或使用某些指针返回 &lt;code&gt;Ok&lt;/code&gt; 取决于实现者。</target>
        </trans-unit>
        <trans-unit id="bb26cd270c81cacb615098ed7b7796b24ddb7cc6" translate="yes" xml:space="preserve">
          <source>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we&amp;rsquo;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a &lt;code&gt;draw&lt;/code&gt; method on each one to draw it to the screen&amp;mdash;a common technique for GUI tools. We&amp;rsquo;ll create a library crate called &lt;code&gt;gui&lt;/code&gt; that contains the structure of a GUI library. This crate might include some types for people to use, such as &lt;code&gt;Button&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;. In addition, &lt;code&gt;gui&lt;/code&gt; users will want to create their own types that can be drawn: for instance, one programmer might add an &lt;code&gt;Image&lt;/code&gt; and another might add a &lt;code&gt;SelectBox&lt;/code&gt;.</source>
          <target state="translated">但是，有时我们希望我们的库用户能够扩展在特定情况下有效的类型集。为了显示如何实现此目的，我们将创建一个示例图形用户界面（GUI）工具，该工具可遍历项目列表，在每个项目上调用一个 &lt;code&gt;draw&lt;/code&gt; 方法以将其绘制到屏幕上-这是GUI工具的一种常用技术。我们将创建一个名为 &lt;code&gt;gui&lt;/code&gt; 的库箱，其中包含GUI库的结构。此板条箱可能包括一些供人们使用的类型，例如 &lt;code&gt;Button&lt;/code&gt; 或 &lt;code&gt;TextField&lt;/code&gt; 。此外， &lt;code&gt;gui&lt;/code&gt; 用户将需要创建自己可以绘制的类型：例如，一个程序员可能添加一个 &lt;code&gt;Image&lt;/code&gt; ，另一个程序员可能添加一个Image。 &lt;code&gt;SelectBox&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="090c640dded64692c1c679520894484188072e98" translate="yes" xml:space="preserve">
          <source>However, structural pinning comes with a few extra requirements:</source>
          <target state="translated">但是,结构销路有一些额外的要求。</target>
        </trans-unit>
        <trans-unit id="6446591953c7036afa44804569e6b2a76fecb194" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted.</source>
          <target state="translated">然而,作为Rust代码解析的文字标记的后缀是受限制的。</target>
        </trans-unit>
        <trans-unit id="fd97947a4cfc6a63fedbe7991de9dd273fb032fc" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53d985c5c53455719af4369d5bd75e2e43f4f1b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;match&lt;/code&gt; expression can be a bit wordy in a situation in which we care about only &lt;em&gt;one&lt;/em&gt; of the cases. For this situation, Rust provides &lt;code&gt;if let&lt;/code&gt;.</source>
          <target state="translated">然而， &lt;code&gt;match&lt;/code&gt; 的表达可以在我们所关心的只是一种情况有点罗嗦&lt;em&gt;一个&lt;/em&gt;案件。对于这种情况，Rust提供 &lt;code&gt;if let&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a11b9e584ed4976bfbc4897d2baa5077bb7ad3ff" translate="yes" xml:space="preserve">
          <source>However, the code in Listing 2-4 won&amp;rsquo;t compile yet. Let&amp;rsquo;s try it:</source>
          <target state="translated">但是，清单2-4中的代码尚未编译。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="5ff36d97f387c34f0e3f89e3b84848ea32f28366" translate="yes" xml:space="preserve">
          <source>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</source>
          <target state="translated">不过,null所要表达的概念还是很有用的:null是指一个当前因某种原因而无效或不存在的值。</target>
        </trans-unit>
        <trans-unit id="cda87a9e6a4c7e24911050c4147eddad9fb1a4fd" translate="yes" xml:space="preserve">
          <source>However, the pointer may not actually point to allocated memory. In particular, if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case the &lt;code&gt;Vec&lt;/code&gt; may not report a &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only if &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation details are very subtle &amp;mdash; if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt; and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using &lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.</source>
          <target state="translated">但是，指针可能实际上没有指向已分配的内存。特别是，如果你建立一个 &lt;code&gt;Vec&lt;/code&gt; 通过与容量0 &lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec![]&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity(0)&lt;/code&gt; &lt;/a&gt;，或致电&lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt;上的空白VEC，也不会分配内存。同样，如果将零大小的类型存储在 &lt;code&gt;Vec&lt;/code&gt; 内，则不会为它们分配空间。&lt;em&gt;注意，在这种情况下， &lt;code&gt;Vec&lt;/code&gt; 可能不会报告&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;为0&lt;/em&gt;。仅当&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt; &lt;code&gt;Vec&lt;/code&gt; 才会分配。一般来说， &lt;code&gt;Vec&lt;/code&gt; 的分配细节非常微妙-如果您打算使用 &lt;code&gt;Vec&lt;/code&gt; 分配内存并将其用于其他用途（传递给不安全的代码，或者构建自己的内存支持的集合），请确保使用释放内存。 &lt;code&gt;from_raw_parts&lt;/code&gt; 以恢复 &lt;code&gt;Vec&lt;/code&gt; ，然后将其删除。</target>
        </trans-unit>
        <trans-unit id="71a07da2ac46a34c0d6bf7a73675b61fc8ad742b" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">但是，事实并非如此：并非所有有效的&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;都是有效的&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;。如果输入不是&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;的有效值，则 &lt;code&gt;from_u32()&lt;/code&gt; 将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="627ab6996d8e9eb90f195c27a7e3d742a80e3b8e" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, possibly creating an invalid one.</source>
          <target state="translated">但是，事实并非如此：并非所有有效的&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;都是有效的&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;from_u32_unchecked()&lt;/code&gt; 将忽略此内容，并盲目地将其强制转换为&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;，可能会创建一个无效的字符。</target>
        </trans-unit>
        <trans-unit id="3551f079ee4c6634be3812dc148413baa86b8300" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb7d7f1f319fa36dc03fb6cd45ffdc556ad5b67" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;code&gt;char&lt;/code&gt;, possibly creating an invalid one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5612bf46edfe618e917ff01d32fb9bebb43312" translate="yes" xml:space="preserve">
          <source>However, the second part is different. In languages with a &lt;em&gt;garbage collector (GC)&lt;/em&gt;, the GC keeps track and cleans up memory that isn&amp;rsquo;t being used anymore, and we don&amp;rsquo;t need to think about it. Without a GC, it&amp;rsquo;s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we&amp;rsquo;ll waste memory. If we do it too early, we&amp;rsquo;ll have an invalid variable. If we do it twice, that&amp;rsquo;s a bug too. We need to pair exactly one &lt;code&gt;allocate&lt;/code&gt; with exactly one &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">但是，第二部分是不同的。在具有&lt;em&gt;垃圾收集器（GC）的&lt;/em&gt;语言中，GC会跟踪并清理不再使用的内存，因此我们无需考虑它。如果没有GC，我们有责任确定何时不再使用内存，并像调用请求一样调用代码以显式返回内存。从历史上看，正确执行此操作一直是编程难题。如果我们忘记了，我们将浪费内存。如果我们做得太早，我们将有一个无效的变量。如果我们做两次，那也是一个错误。我们需要将一个 &lt;code&gt;allocate&lt;/code&gt; 恰好与一个 &lt;code&gt;free&lt;/code&gt; 分配配对。</target>
        </trans-unit>
        <trans-unit id="af229bc0a48ef0630b724d21dd6f456c48e60c69" translate="yes" xml:space="preserve">
          <source>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value&amp;rsquo;s methods would not be able to mutate the value. Using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is one way to get the ability to have interior mutability. But &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you&amp;rsquo;ll get a &lt;code&gt;panic!&lt;/code&gt; instead of a compiler error.</source>
          <target state="translated">但是，在某些情况下，值在其方法中进行自身变异会很有用，但对于其他代码而言却是不变的。值方法之外的代码将无法更改值。使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 是获得内部可变性的一种方法。但是 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 不能完全绕开借用规则：编译器中的借用检查器允许这种内部可变性，而是在运行时检查借用规则。如果您违反规则，就会感到 &lt;code&gt;panic!&lt;/code&gt; 而不是编译器错误。</target>
        </trans-unit>
        <trans-unit id="a0d46c846b73ae9a30e6ec8307068cbd57726662" translate="yes" xml:space="preserve">
          <source>However, there is a &lt;a href=&quot;../type-coercions&quot;&gt;coercion&lt;/a&gt; from function items to &lt;a href=&quot;function-pointer&quot;&gt;function pointers&lt;/a&gt; with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">但是，从功能项到具有相同签名的&lt;a href=&quot;function-pointer&quot;&gt;功能指针&lt;/a&gt;存在&lt;a href=&quot;../type-coercions&quot;&gt;强制&lt;/a&gt;转换，这不仅会在直接期望功能指针时使用功能项时触发，而且在具有相同签名的不同功能项类型遇到不同时也会触发相同的 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;match&lt;/code&gt; 的手臂：</target>
        </trans-unit>
        <trans-unit id="a66a1dddad283613aaa962e121910c064ac30ef0" translate="yes" xml:space="preserve">
          <source>However, there&amp;rsquo;s one problem with this test, as shown here:</source>
          <target state="translated">但是，此测试存在一个问题，如下所示：</target>
        </trans-unit>
        <trans-unit id="18f90c271b4c818c9717e731f31d20c5d63240c8" translate="yes" xml:space="preserve">
          <source>However, they would need to write the implementation block for each type they wanted to use with &lt;code&gt;hello_macro&lt;/code&gt;; we want to spare them from having to do this work.</source>
          <target state="translated">但是，他们需要为要与 &lt;code&gt;hello_macro&lt;/code&gt; 一起使用的每种类型编写实现块；我们想让他们不必做这项工作。</target>
        </trans-unit>
        <trans-unit id="4c27a12b4f8451e9cc5839d83f04460a9e92623c" translate="yes" xml:space="preserve">
          <source>However, this &quot;zombie&quot; value should not be exposed to safe code, and this function should not be called more than once. To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what &lt;code&gt;drop&lt;/code&gt; does). This is normally prevented by the type system, but users of &lt;code&gt;ManuallyDrop&lt;/code&gt; must uphold those guarantees without assistance from the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313fc636d6ceb50d6fb43efb8c2726a3510a1c57" translate="yes" xml:space="preserve">
          <source>However, this extra power comes with extra responsibilities: it is now up to you to ensure soundness. The &lt;code&gt;unsafe&lt;/code&gt; keyword helps by clearly marking the pieces of code that need to worry about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b75e55302f15f6020a4b2831ab78b8a9cd134e" translate="yes" xml:space="preserve">
          <source>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</source>
          <target state="translated">然而,这并不是一个理想的解决方案:如果程序只对1和100之间的值进行操作是绝对重要的,而且它有许多函数有这样的要求,那么在每个函数中都要进行这样的检查就会很繁琐(而且可能会影响性能)。</target>
        </trans-unit>
        <trans-unit id="a824bb12ed66d349d925794b2e3920170b4c275c" translate="yes" xml:space="preserve">
          <source>However, this pattern is so common that Rust has a built-in language construct for it, called a &lt;code&gt;while&lt;/code&gt; loop. Listing 3-3 uses &lt;code&gt;while&lt;/code&gt;: the program loops three times, counting down each time, and then, after the loop, it prints another message and exits.</source>
          <target state="translated">但是，这种模式非常普遍，Rust具有内置的语言构造，称为 &lt;code&gt;while&lt;/code&gt; 循环。清单3-3使用 &lt;code&gt;while&lt;/code&gt; ：该程序循环循环3次，每次递减计数，然后在循环之后打印另一条消息并退出。</target>
        </trans-unit>
        <trans-unit id="ada98a89852cf14a520ca2427888843bc3fd0869" translate="yes" xml:space="preserve">
          <source>However, this won't:</source>
          <target state="translated">然而,这不会。</target>
        </trans-unit>
        <trans-unit id="2ba8355a99e10032076801bb58aaec6886066a15" translate="yes" xml:space="preserve">
          <source>However, two concurrency concepts are embedded in the language: the &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">但是，该语言中嵌入了两个并发概念： &lt;code&gt;std::marker&lt;/code&gt; 特性 &lt;code&gt;Sync&lt;/code&gt; 和 &lt;code&gt;Send&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fad3453f67fa7a8abf1de710cc99507cae5f79c" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;..&lt;/code&gt; must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using &lt;code&gt;..&lt;/code&gt; ambiguously, so it will not compile.</source>
          <target state="translated">但是，使用 &lt;code&gt;..&lt;/code&gt; 必须是明确的。如果不清楚哪些值适合匹配，哪些值应忽略，Rust会给我们一个错误。清单18-25显示了一个示例性地使用 &lt;code&gt;..&lt;/code&gt; 的示例，因此它不会被编译。</target>
        </trans-unit>
        <trans-unit id="f1a26fc372d073b9ed76f398473c3b964914605f" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ve reintroduced one of the problems from Listing 13-3: we&amp;rsquo;re still calling the closure twice in the first &lt;code&gt;if&lt;/code&gt; block, which will call the expensive code twice and make the user wait twice as long as they need to. We could fix this problem by creating a variable local to that &lt;code&gt;if&lt;/code&gt; block to hold the result of calling the closure, but closures provide us with another solution. We&amp;rsquo;ll talk about that solution in a bit. But first let&amp;rsquo;s talk about why there aren&amp;rsquo;t type annotations in the closure definition and the traits involved with closures.</source>
          <target state="translated">但是，我们重新引入了清单13-3中的一个问题：我们仍然在第一个 &lt;code&gt;if&lt;/code&gt; 块中两次调用闭包，这将两次调用昂贵的代码，并使用户等待所需时间两次。我们可以通过在 &lt;code&gt;if&lt;/code&gt; 块的局部创建一个变量来解决此问题，以保存调用闭包的结果，但是闭包为我们提供了另一种解决方案。我们将稍后讨论该解决方案。但是首先让我们讨论一下为什么闭包定义中没有类型注释以及闭包所涉及的特征。</target>
        </trans-unit>
        <trans-unit id="aeba4f050e04fdf1cf910571a9c79d642b8343c4" translate="yes" xml:space="preserve">
          <source>However, when failure is expected, it&amp;rsquo;s more appropriate to return a &lt;code&gt;Result&lt;/code&gt; than to make a &lt;code&gt;panic!&lt;/code&gt; call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a &lt;code&gt;Result&lt;/code&gt; indicates that failure is an expected possibility that the calling code must decide how to handle.</source>
          <target state="translated">但是，如果预期会失败，则返回 &lt;code&gt;Result&lt;/code&gt; 比 &lt;code&gt;panic!&lt;/code&gt; 更合适！呼叫。示例包括向解析器提供格式错误的数据或HTTP请求，返回的状态表明您已达到速率限制。在这些情况下，返回 &lt;code&gt;Result&lt;/code&gt; 表示失败是调用代码必须决定如何处理的预期可能性。</target>
        </trans-unit>
        <trans-unit id="bd1b29ca1d0594e55daa86076890956a32cf494f" translate="yes" xml:space="preserve">
          <source>However, with trait objects we have to make a table containing &lt;em&gt;every&lt;/em&gt; object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</source>
          <target state="translated">但是，对于特征对象，我们必须创建一个表，其中包含实现该特征的&lt;em&gt;每个&lt;/em&gt;对象。现在，如果它具有类型参数，则需要为实现该特征的每个类型添加实现，并且理论上可以有无数个类型。</target>
        </trans-unit>
        <trans-unit id="c83a1e89e4828f4c8e8c03978096139099426f82" translate="yes" xml:space="preserve">
          <source>However, you can only use &lt;code&gt;impl Trait&lt;/code&gt; if you&amp;rsquo;re returning a single type. For example, this code that returns either a &lt;code&gt;NewsArticle&lt;/code&gt; or a &lt;code&gt;Tweet&lt;/code&gt; with the return type specified as &lt;code&gt;impl Summary&lt;/code&gt; wouldn&amp;rsquo;t work:</source>
          <target state="translated">但是，如果要返回单个类型，则只能使用 &lt;code&gt;impl Trait&lt;/code&gt; 。例如，此代码返回的 &lt;code&gt;NewsArticle&lt;/code&gt; 或 &lt;code&gt;Tweet&lt;/code&gt; 的返回类型指定为 &lt;code&gt;impl Summary&lt;/code&gt; 将不起作用：</target>
        </trans-unit>
        <trans-unit id="e2fcea022d94a9775aabc30c1a2c51d018156b80" translate="yes" xml:space="preserve">
          <source>Hundreds of companies, large and small, use Rust in production for a variety of tasks. Those tasks include command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</source>
          <target state="translated">成百上千的公司,无论大小,都在生产中使用Rust完成各种任务。这些任务包括命令行工具、网络服务、DevOps工具、嵌入式设备、音频和视频分析和转码、加密货币、生物信息学、搜索引擎、物联网应用、机器学习,甚至Firefox网络浏览器的主要部分。</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="ad65c5b3b86039ac673217b5d774ea59d147e7b7" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine function.</source>
          <target state="translated">双曲余弦函数。</target>
        </trans-unit>
        <trans-unit id="c686c752760e59aa04f64bbe28ff2dbeca59fd00" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine function.</source>
          <target state="translated">双曲正弦函数。</target>
        </trans-unit>
        <trans-unit id="78df70baad8c07fe855fe47101a5902c14b1e359" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent function.</source>
          <target state="translated">双曲正切函数。</target>
        </trans-unit>
        <trans-unit id="bdf6cba1852f21a59de6863b8e6d7784db0851c8" translate="yes" xml:space="preserve">
          <source>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</source>
          <target state="translated">我称之为我的十亿美元错误。当时，我正在设计第一个全面的类型系统，以面向对象的语言进行引用。我的目标是确保所有对引用的使用都绝对安全，并由编译器自动执行检查。但是我无法抗拒引入空引用的诱惑，仅仅是因为它是如此易于实现。这导致了无数错误，漏洞和系统崩溃，在最近四十年中可能造成十亿美元的痛苦和破坏。</target>
        </trans-unit>
        <trans-unit id="e7c23cd87ff8917afb8c94f0de55718d338f0dac" translate="yes" xml:space="preserve">
          <source>IDE Integration Using the Rust Language Server</source>
          <target state="translated">使用Rust语言服务器的IDE集成</target>
        </trans-unit>
        <trans-unit id="0e3b1f1fb38a7fe314d2f472da7f442366e6c3f3" translate="yes" xml:space="preserve">
          <source>IDENTIFIER</source>
          <target state="translated">IDENTIFIER</target>
        </trans-unit>
        <trans-unit id="55b1203af6cad8ae52e0d0a37f140db7910d8eda" translate="yes" xml:space="preserve">
          <source>IDENTIFIER :</source>
          <target state="translated">IDENTIFIER :</target>
        </trans-unit>
        <trans-unit id="c0fcd90425d895f40b307f4c7f56f5df18b1668f" translate="yes" xml:space="preserve">
          <source>IDENTIFIER_OR_KEYWORD :</source>
          <target state="translated">IDENTIFIER_OR_KEYWORD :</target>
        </trans-unit>
        <trans-unit id="b8dae77b24288c011d2b9b755b9a1a42811917e3" translate="yes" xml:space="preserve">
          <source>IEEE-754 very precisely specifies the bit layout of floats.</source>
          <target state="translated">IEEE-754非常精确地规定了浮点数的位布局。</target>
        </trans-unit>
        <trans-unit id="1852814b8596efd4647ef533b868ea9c6f371594" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.4</source>
          <target state="translated">IETF RFC 4291第2.4节</target>
        </trans-unit>
        <trans-unit id="aa0c0f5169dc17cce987a2ba8ef3419dba45ba72" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.5.6</source>
          <target state="translated">IETF RFC 4291第2.5.6条</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="a1a3b8cc81502982ba95837302feb61e65dd8a3d" translate="yes" xml:space="preserve">
          <source>INNER_BLOCK_DOC :</source>
          <target state="translated">INNER_BLOCK_DOC 。</target>
        </trans-unit>
        <trans-unit id="53a0430947a0edbae0af7f9e49d8f2dfe4e9afb4" translate="yes" xml:space="preserve">
          <source>INNER_LINE_DOC :</source>
          <target state="translated">INNER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="cfbd240cfc0633423b9847728303e0a704bcd5d5" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL</source>
          <target state="translated">INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="3f9135bee30f70c629387b1f17caf9d0de0eb83e" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL :</source>
          <target state="translated">INTEGER_LITERAL :</target>
        </trans-unit>
        <trans-unit id="6371ddd611a0269a5bb8329b8b5ad2906b65b001" translate="yes" xml:space="preserve">
          <source>INTEGER_SUFFIX :</source>
          <target state="translated">INTEGER_SUFFIX :</target>
        </trans-unit>
        <trans-unit id="11cbb1f84a9535024b6452829b5548dd25b90335" translate="yes" xml:space="preserve">
          <source>IPv4 addresses are defined as 32-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;. They are usually represented as four octets.</source>
          <target state="translated">IPv4地址在&lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;中定义为32位整数。它们通常表示为四个八位位组。</target>
        </trans-unit>
        <trans-unit id="f61d67f908f166f992bd96ab7aae0433beeddddf" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt; address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125cc8de0dff730e4520fc003986c19a1b8554df" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793中&lt;/a&gt;所述，IPv4套接字地址由一个&lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4地址&lt;/a&gt;和一个16位端口号组成。</target>
        </trans-unit>
        <trans-unit id="0fb594a9f230f62a93a2d236d355fee291f5f0ed" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are defined as 128-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;. They are usually represented as eight 16-bit segments.</source>
          <target state="translated">IPv6地址在&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;中定义为128位整数。它们通常表示为八个16位段。</target>
        </trans-unit>
        <trans-unit id="9506a43966237e091295db561358da8326a23b09" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt; address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a88c8ad7ac15b70173172e130a9df32e2c85f47" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6套接字地址包括一个&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6地址&lt;/a&gt;，一个16位端口号以及包含流量类别，流标签和作用域标识符的字段（有关更多详细信息&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;，&lt;/a&gt;请参见IETF RFC 2553，第3.3节）。</target>
        </trans-unit>
        <trans-unit id="5e75cacea0fd3b6b14f0b4659c3bb43c233b1bc1" translate="yes" xml:space="preserve">
          <source>Identifier patterns</source>
          <target state="translated">识别符模式</target>
        </trans-unit>
        <trans-unit id="2871ae9886988ebe4584f71645f1cfa54c50fb26" translate="yes" xml:space="preserve">
          <source>Identifier patterns are irrefutable if the &lt;code&gt;@&lt;/code&gt; subpattern is irrefutable or the subpattern is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14c125598d88502f5133a3afc5b567be6c1a2d3" translate="yes" xml:space="preserve">
          <source>Identifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a &lt;code&gt;let&lt;/code&gt; binding or a &lt;code&gt;match&lt;/code&gt; arm).</source>
          <target state="translated">标识符模式将它们匹配的值绑定到变量。标识符在模式中必须唯一。该变量将在作用域中隐藏任何同名变量。新绑定的范围取决于使用模式的上下文（如 &lt;code&gt;let&lt;/code&gt; 绑定或 &lt;code&gt;match&lt;/code&gt; 臂）。</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="a28f079910fa2727e597ae224c9f3f8cbc529307" translate="yes" xml:space="preserve">
          <source>Identify duplicate code.</source>
          <target state="translated">识别重复的代码。</target>
        </trans-unit>
        <trans-unit id="9f0d27a694b397b392e1c0d4d2916d104a364051" translate="yes" xml:space="preserve">
          <source>If &amp;epsilon; &amp;isin; LAST(&lt;code&gt;uu ...&lt;/code&gt;), then LAST(M) = LAST(&lt;code&gt;tt&lt;/code&gt;) &amp;cup; (LAST(&lt;code&gt;uu ...&lt;/code&gt;) \ { &amp;epsilon; }).</source>
          <target state="translated">如果&amp;epsilon;&amp;isin;LAST（ &lt;code&gt;uu ...&lt;/code&gt; ），则LAST（M）= LAST（ &lt;code&gt;tt&lt;/code&gt; ）&amp;cup;（LAST（ &lt;code&gt;uu ...&lt;/code&gt; ）\ {&amp;epsilon;}）。</target>
        </trans-unit>
        <trans-unit id="96acc5da5a6cbbd203437fa84771d338d67204aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed811da5d2f26e42527abd7d7393051a81f9fad7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e801c0aa2cecddf4c1a1f7baf739c356c501f4d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534c6252638c1abdb91099e943245185bc915d7e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">如果&lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则添加扩展名。否则将被替换。</target>
        </trans-unit>
        <trans-unit id="01a2757701a9695cb15304f9062c5f6fe543e1d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则等效于推送 &lt;code&gt;file_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29376b60b0b5a1ec52b8a24373266c830da3ba88" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4087b2407c0523ab27c22d69edd0438fe2e50815" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'static&lt;/code&gt; is used for any lifetime bound then &lt;code&gt;'static&lt;/code&gt; is used.</source>
          <target state="translated">如果将 &lt;code&gt;'static&lt;/code&gt; 用于任何生命周期限制，则使用 &lt;code&gt;'static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2299b8f75754da8b24aff81fd36ddb6f9ef90ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;..&lt;/code&gt; is not used, it is required to match all fields:</source>
          <target state="translated">如果不使用 &lt;code&gt;..&lt;/code&gt; ，则必须匹配所有字段：</target>
        </trans-unit>
        <trans-unit id="f3b5be9d19759c8147145d2b3c53249ad84a368f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">如果设置了 &lt;code&gt;.create_new(true)&lt;/code&gt; ，&lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt;忽略.create（）和&lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29bc21e0c15798e73a6dbc2093728d2f6a268b72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad0cab5b7af8f6f0d802cf376de0871197cd2fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Complete&lt;/code&gt; is returned then the generator has completely finished with the value provided. It is invalid for the generator to be resumed again.</source>
          <target state="translated">如果返回 &lt;code&gt;Complete&lt;/code&gt; ，则生成器将使用提供的值完全完成。再次恢复发电机无效。</target>
        </trans-unit>
        <trans-unit id="ac903d4e63c4f5e9053aaefd66eff84df6124016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ForeignTrait&lt;/code&gt; is a trait defined in some external crate &lt;code&gt;foo&lt;/code&gt;, then the following trait &lt;code&gt;impl&lt;/code&gt; is an error:</source>
          <target state="translated">如果 &lt;code&gt;ForeignTrait&lt;/code&gt; 是在某些外部包装箱 &lt;code&gt;foo&lt;/code&gt; 中定义的特征，则以下特征 &lt;code&gt;impl&lt;/code&gt; 是错误：</target>
        </trans-unit>
        <trans-unit id="c1fd05b3bcfcb4d8ea20c271d94557cb3d13d52d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hello, world!&lt;/code&gt; did print, congratulations! You&amp;rsquo;ve officially written a Rust program. That makes you a Rust programmer&amp;mdash;welcome!</source>
          <target state="translated">如果 &lt;code&gt;Hello, world!&lt;/code&gt; 确实打印了，恭喜！您已经正式编写了一个Rust程序。这使您成为Rust程序员-欢迎您！</target>
        </trans-unit>
        <trans-unit id="7eb14007d446b8ddd9ae89463ae1a1d31374e8ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is greater than the size of the slice, it will return no windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ac605f741ebf773252ac24fa49e72ab712c9a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T: Drop&lt;/code&gt;, calling &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3c7b96cb91a4bbdb1b6896643ea9e9a3c22921" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeac29050d6596e7248fbdb56f4b4514db570609" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e2b122febd728f5d8f178462e020b9f40dc3b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a40f9d20e095dacb94b9b37bf7db5ad95d17e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are never unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6043d2d9c915604d4623e46635d9a9a232a5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; ，则指向相同值的两个 &lt;code&gt;Arc&lt;/code&gt; 始终相等。</target>
        </trans-unit>
        <trans-unit id="ec82a111c6092884516e8540e107bb1534de81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; ，则指向相同值的两个 &lt;code&gt;Arc&lt;/code&gt; 永远不会相等。</target>
        </trans-unit>
        <trans-unit id="21cc57c8697439642e0504b016521d59698b000c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; ，则指向相同值的两个 &lt;code&gt;Rc&lt;/code&gt; 始终相等。</target>
        </trans-unit>
        <trans-unit id="79dd19ff096e35ccdc8e2994890606a0f2b80c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; ，则指向相同值的两个 &lt;code&gt;Rc&lt;/code&gt; 永远不会相等。</target>
        </trans-unit>
        <trans-unit id="f0097c8e2ff22a2b90e167d6c061fa3e59f58a62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c4dc3d013511006bc6b284a2d4db3c7148b968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aad32f156303fc5a2bc63ee3fa5dad5cc0ca6bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 类型的值，则：</target>
        </trans-unit>
        <trans-unit id="95d72afe0884b2306850bd095670df15024528ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 类型的值，则：</target>
        </trans-unit>
        <trans-unit id="23971030fbeb1cad27f55d0399b6d51a892fe825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sized&lt;/code&gt;, this function is always safe to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6c90a17aa05dcdf98932b5f27171dbd2de33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is FFI-safe, then so is &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是FFI安全的，则 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="49964ef73f44405d2ac7053108ae2569108b6abf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不是一个枚举，则调用此函数不会导致未定义的行为，但返回值未指定。</target>
        </trans-unit>
        <trans-unit id="8dca1b3ef01a1ffebdb81541f8580fb6c5190017" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified. Equally, if &lt;code&gt;T&lt;/code&gt; is an enum with more variants than &lt;code&gt;usize::MAX&lt;/code&gt; the return value is unspecified. Uninhabited variants will be counted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70442d0f7a75e13703c9f3f655e0ebf8ba235584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Ti&lt;/code&gt; can be coerced to the current target type &lt;code&gt;T_t&lt;/code&gt;, then no change is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81fb6d8ced60b0cd6b321f060ac68460468aa0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">如果 &lt;code&gt;addr&lt;/code&gt; 产生多个地址，则将尝试与每个地址 &lt;code&gt;bind&lt;/code&gt; ，直到一个成功并返回侦听器为止。如果没有一个地址成功创建侦听器，则返回从上次尝试（最后一个地址）返回的错误。</target>
        </trans-unit>
        <trans-unit id="7f3c01a32008b38d419c728226a54e01a7d962fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">如果 &lt;code&gt;addr&lt;/code&gt; 产生多个地址，则将尝试与每个地址 &lt;code&gt;bind&lt;/code&gt; ，直到一个成功并返回套接字为止。如果没有一个地址成功创建套接字，则返回上一次尝试返回的错误（最后一个地址）。</target>
        </trans-unit>
        <trans-unit id="0c53eddc64c1e675eb29f0974efda41f4b33efd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">如果 &lt;code&gt;addr&lt;/code&gt; 产生多个地址， &lt;code&gt;connect&lt;/code&gt; 将尝试与每个地址，直到连接成功。如果没有一个地址导致连接成功，则返回从上次连接尝试（最后一个地址）返回的错误。</target>
        </trans-unit>
        <trans-unit id="07f5c20249e5fa3260da27a7df45155885f3dd08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful &lt;code&gt;connect&lt;/code&gt; call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">如果 &lt;code&gt;addr&lt;/code&gt; 产生多个地址，则将尝试使用每个地址进行 &lt;code&gt;connect&lt;/code&gt; ，直到基础OS函数未返回错误为止。请注意，通常，成功的 &lt;code&gt;connect&lt;/code&gt; 调用不会指定在端口上侦听远程服务器，而是仅在首次发送后才检测到此错误。如果操作系统为每个指定的地址返回错误，则返回从上次连接尝试（最后一个地址）返回的错误。</target>
        </trans-unit>
        <trans-unit id="acfc45781f88c4761baec8897c0ca4cf03d5120d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;base&lt;/code&gt; 不是 &lt;code&gt;self&lt;/code&gt; 的前缀（即，&lt;a href=&quot;#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;false&lt;/code&gt; ），则返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c33668a2d69ed6be4cc49feb7054f832229cf3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;struct.path#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b461fd46fdb1045defa6bb08692a4c2d8f4230a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; start with the bytes in &lt;code&gt;get&lt;/code&gt;, it means we&amp;rsquo;ve received some other request. We&amp;rsquo;ll add code to the &lt;code&gt;else&lt;/code&gt; block in a moment to respond to all other requests.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;与该字节的初始 &lt;code&gt;get&lt;/code&gt; ，这意味着我们已经收到了一些其他的要求。我们将在稍后将代码添加到 &lt;code&gt;else&lt;/code&gt; 块中，以响应所有其他请求。</target>
        </trans-unit>
        <trans-unit id="65de2dbca56069ac5ddb30aad7c8e3292f2e853a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; panics, the panic is propagated to the caller, and the cell remains uninitialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00643b3b6dd6ef6ea56050255f61c8e0b9bb9ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for the next value of this iterator, consume and return it. Otherwise, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb805fab8234f3a9b02923cee55ae95cc32673cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;k == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">如果 &lt;code&gt;k&lt;/code&gt; 大于 &lt;code&gt;len()&lt;/code&gt; 。需要注意的是 &lt;code&gt;k == len()&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，是一种无操作旋转。</target>
        </trans-unit>
        <trans-unit id="f9e7bcd447817a79430b03e0a66dfa67f1d0816a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the &lt;code&gt;VecDeque&lt;/code&gt;'s current length, this has no effect.</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 大于 &lt;code&gt;VecDeque&lt;/code&gt; 的当前长度，则无效。</target>
        </trans-unit>
        <trans-unit id="3d4f7e3b9010f5f85b09ea6a7879139a55bd516a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length, this has no effect.</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 大于矢量的当前长度，则无效。</target>
        </trans-unit>
        <trans-unit id="1cf8419e86a3170a30c5b069909ed1f0302b608f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mid&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;mid == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">如果 &lt;code&gt;mid&lt;/code&gt; 大于 &lt;code&gt;len()&lt;/code&gt; 。需要注意的是 &lt;code&gt;mid == len()&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，是一种无操作旋转。</target>
        </trans-unit>
        <trans-unit id="5a6e0913f28771cf69b8d16954b1cc061c4e770a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; substrings are returned, the last substring (the &lt;code&gt;n&lt;/code&gt;th substring) will contain the remainder of the string.</source>
          <target state="translated">如果返回 &lt;code&gt;n&lt;/code&gt; 个子字符串，则最后一个子字符串（第 &lt;code&gt;n&lt;/code&gt; 个子字符串）将包含字符串的其余部分。</target>
        </trans-unit>
        <trans-unit id="705ee37ce1f2981d5872c521c36f0e77f17b6dcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 大于 &lt;code&gt;len&lt;/code&gt; ，则将 &lt;code&gt;Vec&lt;/code&gt; 扩展差值，每个其他插槽都填充&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;new_len&lt;/code&gt; 小于 &lt;code&gt;len&lt;/code&gt; ，则仅将 &lt;code&gt;Vec&lt;/code&gt; 截断。</target>
        </trans-unit>
        <trans-unit id="ad28de2b804b7bf236f81edae0db607218d0ac6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 大于 &lt;code&gt;len&lt;/code&gt; ，则 &lt;code&gt;Vec&lt;/code&gt; 扩展差值，每个附加插槽均填充 &lt;code&gt;value&lt;/code&gt; 。如果 &lt;code&gt;new_len&lt;/code&gt; 小于 &lt;code&gt;len&lt;/code&gt; ，则仅将 &lt;code&gt;Vec&lt;/code&gt; 截断。</target>
        </trans-unit>
        <trans-unit id="c6a8aec540c240a392d0120d56829bf27ca15fcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with the result of calling the closure &lt;code&gt;f&lt;/code&gt;. The return values from &lt;code&gt;f&lt;/code&gt; will end up in the &lt;code&gt;Vec&lt;/code&gt; in the order they have been generated.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 大于 &lt;code&gt;len&lt;/code&gt; ，则将 &lt;code&gt;Vec&lt;/code&gt; 扩展该差值，并在每个附加插槽中填充调用闭包 &lt;code&gt;f&lt;/code&gt; 的结果。 &lt;code&gt;f&lt;/code&gt; 的返回值将按照生成顺序返回到 &lt;code&gt;Vec&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="57261354a67401e0b42f57fdd95ec00fffeda84c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than the string's current length, this has no effect.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 大于字符串的当前长度，则无效。</target>
        </trans-unit>
        <trans-unit id="8e6148a2ee667e899f4bb89c993862e7efe20971" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 小于 &lt;code&gt;len&lt;/code&gt; ，则仅将 &lt;code&gt;Vec&lt;/code&gt; 截断。</target>
        </trans-unit>
        <trans-unit id="abb4fe85675ce478754ece04841053fa5e5c6a3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; had been &lt;code&gt;Some(10)&lt;/code&gt; instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&amp;rsquo;t have a match guard and therefore matches any &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">如果 &lt;code&gt;num&lt;/code&gt; 已经 &lt;code&gt;Some(10)&lt;/code&gt; 代替，在第一臂比赛后卫本来是假的，因为10不小于5锈会然后进入第二臂，这将匹配，因为第二臂不有匹配卫队，因此匹配任何 &lt;code&gt;Some&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="b32b62b97ea86132915f7572c0fc7127777250a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; able to turn the string into a number, it will return an &lt;code&gt;Err&lt;/code&gt; value that contains more information about the error. The &lt;code&gt;Err&lt;/code&gt; value does not match the &lt;code&gt;Ok(num)&lt;/code&gt; pattern in the first &lt;code&gt;match&lt;/code&gt; arm, but it does match the &lt;code&gt;Err(_)&lt;/code&gt; pattern in the second arm. The underscore, &lt;code&gt;_&lt;/code&gt;, is a catchall value; in this example, we&amp;rsquo;re saying we want to match all &lt;code&gt;Err&lt;/code&gt; values, no matter what information they have inside them. So the program will execute the second arm&amp;rsquo;s code, &lt;code&gt;continue&lt;/code&gt;, which tells the program to go to the next iteration of the &lt;code&gt;loop&lt;/code&gt; and ask for another guess. So, effectively, the program ignores all errors that &lt;code&gt;parse&lt;/code&gt; might encounter!</source>
          <target state="translated">如果 &lt;code&gt;parse&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt;能够把字符串转换成一个数字，它会返回一个 &lt;code&gt;Err&lt;/code&gt; ，其中包含有关错误的详细信息的价值。的 &lt;code&gt;Err&lt;/code&gt; 值不匹配 &lt;code&gt;Ok(num)&lt;/code&gt; 在第一图案 &lt;code&gt;match&lt;/code&gt; 臂，但它确实匹配 &lt;code&gt;Err(_)&lt;/code&gt; 在所述第二臂的图案。下划线 &lt;code&gt;_&lt;/code&gt; 是一个通用值；在本例中，我们要匹配所有 &lt;code&gt;Err&lt;/code&gt; 值，无论它们内部包含什么信息。因此，程序将执行第二臂代码， &lt;code&gt;continue&lt;/code&gt; ，告诉程序进入 &lt;code&gt;loop&lt;/code&gt; 的下一个迭代并要求另一个猜测。因此，有效地，程序将忽略 &lt;code&gt;parse&lt;/code&gt; 可能遇到的所有错误！</target>
        </trans-unit>
        <trans-unit id="40e42a10c4724a12b9d742d659e990cc0a90590e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is able to successfully turn the string into a number, it will return an &lt;code&gt;Ok&lt;/code&gt; value that contains the resulting number. That &lt;code&gt;Ok&lt;/code&gt; value will match the first arm&amp;rsquo;s pattern, and the &lt;code&gt;match&lt;/code&gt; expression will just return the &lt;code&gt;num&lt;/code&gt; value that &lt;code&gt;parse&lt;/code&gt; produced and put inside the &lt;code&gt;Ok&lt;/code&gt; value. That number will end up right where we want it in the new &lt;code&gt;guess&lt;/code&gt; variable we&amp;rsquo;re creating.</source>
          <target state="translated">如果 &lt;code&gt;parse&lt;/code&gt; 能够成功将字符串转换为数字，则它将返回包含结果数字的 &lt;code&gt;Ok&lt;/code&gt; 值。那 &lt;code&gt;Ok&lt;/code&gt; 值将匹配第一臂的模式，以及 &lt;code&gt;match&lt;/code&gt; 表达式将只返回 &lt;code&gt;num&lt;/code&gt; 该值 &lt;code&gt;parse&lt;/code&gt; 生产，并把里面 &lt;code&gt;Ok&lt;/code&gt; 价值。该数字将最终在我们要创建的新 &lt;code&gt;guess&lt;/code&gt; 变量中的所需位置结束。</target>
        </trans-unit>
        <trans-unit id="a78bf9200d69e40c9e7de71399af9b041b718f05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is absolute, it replaces the current path.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是绝对路径，它将替换当前路径。</target>
        </trans-unit>
        <trans-unit id="73e4e153f655353974f6e6f2c813b5b3915ef1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pointer&lt;/code&gt; dereferences to an &lt;code&gt;Unpin&lt;/code&gt; type, &lt;code&gt;Pin::new&lt;/code&gt; should be used instead.</source>
          <target state="translated">如果 &lt;code&gt;pointer&lt;/code&gt; 取消引用了 &lt;code&gt;Unpin&lt;/code&gt; 类型，则应使用 &lt;code&gt;Pin::new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac86606be8e832102840dbcc4086a1857a76012b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;program&lt;/code&gt; is not an absolute path, the &lt;code&gt;PATH&lt;/code&gt; will be searched in an OS-defined way.</source>
          <target state="translated">如果 &lt;code&gt;program&lt;/code&gt; 不是绝对路径，则将以OS定义的方式搜索 &lt;code&gt;PATH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a98fb4db9993bb6b25528d614208eeeedcf64c3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self &amp;lt;= other&lt;/code&gt;: &lt;code&gt;0:0&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;self &amp;lt;= other&lt;/code&gt; ： &lt;code&gt;0:0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="822bf36472f08b6c870c4a7eb729d5b79300c331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the code calls the closure stored in &lt;code&gt;self.calculation&lt;/code&gt;, saves the result in &lt;code&gt;self.value&lt;/code&gt; for future use, and returns the value as well.</source>
          <target state="translated">如果 &lt;code&gt;self.value&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则代码将调用存储在 &lt;code&gt;self.calculation&lt;/code&gt; 中的闭包，将结果保存在 &lt;code&gt;self.value&lt;/code&gt; 中以备将来使用，并返回该值。</target>
        </trans-unit>
        <trans-unit id="0f62f6b36639e7064e0402d98d3c38179c58dd42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; already meets the prescribed alignment, then returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 已经满足指定的对齐方式，则返回 &lt;code&gt;self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d19aaaae1a7aca6f98e6ea7cfd2e6a369fd25fbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some((s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9687d508d768393d6014b090a450d643c5917f35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some(f(s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14fb52988b52fdaf20fd6eb41395b17915e1caaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">如果使用&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;创建 &lt;code&gt;self&lt;/code&gt; ，则将返回0。</target>
        </trans-unit>
        <trans-unit id="ffe2ed689988d142674d1aa54b3aa925c7f0ceb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是使用&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;创建的，则返回0。否则，返回值至少为1，因为 &lt;code&gt;self&lt;/code&gt; 仍指向该值。</target>
        </trans-unit>
        <trans-unit id="f7cf04a558af40a8692e8d38e72f630ad0f921d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return &lt;code&gt;None&lt;/code&gt;. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">如果使用&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;创建 &lt;code&gt;self&lt;/code&gt; ，则将返回 &lt;code&gt;None&lt;/code&gt; 。如果不是，则返回值至少为1，因为 &lt;code&gt;self&lt;/code&gt; 仍指向该值。</target>
        </trans-unit>
        <trans-unit id="3bc7bb1c65b4b00e05db4f8ca6614cdf9fe6dd50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, or if there are no remaining strong pointers, this will return 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cfa0b57fd172f30232192cc8919edcc309955f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab90cc43346ebf820e0570ac8953d279713fad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;some_option_value&lt;/code&gt; was a &lt;code&gt;None&lt;/code&gt; value, it would fail to match the pattern &lt;code&gt;Some(x)&lt;/code&gt;, meaning the pattern is refutable. However, the &lt;code&gt;let&lt;/code&gt; statement can only accept an irrefutable pattern because there is nothing valid the code can do with a &lt;code&gt;None&lt;/code&gt; value. At compile time, Rust will complain that we&amp;rsquo;ve tried to use a refutable pattern where an irrefutable pattern is required:</source>
          <target state="translated">如果 &lt;code&gt;some_option_value&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; 值，它将无法匹配 &lt;code&gt;Some(x)&lt;/code&gt; 模式，这意味着该模式是可重复使用的。但是， &lt;code&gt;let&lt;/code&gt; 语句只能接受一个不可辩驳的模式，因为代码对 &lt;code&gt;None&lt;/code&gt; 值不能执行任何有效的操作。在编译时，Rust会抱怨我们试图在需要不可辩驳的模式的情况下使用可辩驳的模式：</target>
        </trans-unit>
        <trans-unit id="7912a0b36bd857714b86c8f65975fd42323403e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 没有实现 &lt;code&gt;Copy&lt;/code&gt; ，请使用&lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d89aaab24b69c1dc1835d5c53542bd5dee44e824" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 实现了 &lt;code&gt;Copy&lt;/code&gt; ，则使用&lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt;可能会更有效。</target>
        </trans-unit>
        <trans-unit id="f2fb513c03fabfd0da48ed321e5c2ec7c086217d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; names a symbolic link, it is platform-specific whether the symbolic link is followed. On platforms where it's possible to not follow it, it is not followed, and the created hard link points to the symbolic link itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f26bdddcd85ded44fb8dcca9f30dea327428d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; had been a &lt;code&gt;None&lt;/code&gt; value instead of &lt;code&gt;Some(5)&lt;/code&gt;, the patterns in the first two arms wouldn&amp;rsquo;t have matched, so the value would have matched to the underscore. We didn&amp;rsquo;t introduce the &lt;code&gt;x&lt;/code&gt; variable in the pattern of the underscore arm, so the &lt;code&gt;x&lt;/code&gt; in the expression is still the outer &lt;code&gt;x&lt;/code&gt; that hasn&amp;rsquo;t been shadowed. In this hypothetical case, the &lt;code&gt;match&lt;/code&gt; would print &lt;code&gt;Default case, x = None&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;None&lt;/code&gt; 值而不是 &lt;code&gt;Some(5)&lt;/code&gt; ，则前两个臂中的模式将不匹配，因此该值将与下划线匹配。我们没有引进 &lt;code&gt;x&lt;/code&gt; 在下划线臂的图案可变的，所以 &lt;code&gt;x&lt;/code&gt; 中的表达仍然是外 &lt;code&gt;x&lt;/code&gt; 尚未阴影。在这种假设的情况下， &lt;code&gt;match&lt;/code&gt; 将显示 &lt;code&gt;Default case, x = None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18bf4b6aafae989a7516ceac94bb945e71eddb6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1...5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为1、2、3、4或5，则第一个手臂会匹配。此语法比使用 &lt;code&gt;|&lt;/code&gt; 更方便。操作员表达相同的想法；而不是 &lt;code&gt;1...5&lt;/code&gt; ，我们必须指定 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; 如果我们使用过 &lt;code&gt;|&lt;/code&gt; 。指定范围要短得多，特别是如果我们要匹配（例如1到1,000之间的任何数字）！</target>
        </trans-unit>
        <trans-unit id="03b71537ced2e70a9ffd0edf12930fd86baf512b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1..=5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dff0302c86fb6267157aaf01cdfa14adc4d52ab" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your &amp;ldquo;Hello, world!&amp;rdquo; program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2cf548505fabb01a736215a09d7eb4359e58a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your Hello, world! program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">如果&lt;em&gt;main.rs&lt;/em&gt;是您的世界，您好！程序，此行将打印 &lt;code&gt;Hello, world!&lt;/code&gt; 到您的终端。</target>
        </trans-unit>
        <trans-unit id="d9079a0efb2b14490cdc2479436c152fdb5fa1c2" translate="yes" xml:space="preserve">
          <source>If Rust code &lt;em&gt;does&lt;/em&gt; need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;, as is conventionally done in other Rust APIs that deal with string encodings.</source>
          <target state="translated">如果Rust代码&lt;em&gt;确实&lt;/em&gt;需要查看这些字符串，则可以使用&lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt;替换无效的序列，从而可能有损地将它们转换为有效的UTF-8，这与其他处理字符串编码的Rust API常规上一样。</target>
        </trans-unit>
        <trans-unit id="197312fbd3b9939e66c78499e206ee75ae2c0258" translate="yes" xml:space="preserve">
          <source>If Rust didn&amp;rsquo;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call &lt;code&gt;hello&lt;/code&gt; with a value of type &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果Rust没有实现deref强制，我们将不得不编写清单15-13中的代码而不是清单15-12中的代码来调用值为 &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 类型的 &lt;code&gt;hello&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b87cf1a5022226b7cc21cca4d2b0d16ec46dac6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er does not override the default &lt;code&gt;read_vectored&lt;/code&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ff52226d48b491c91c2959c2741fe1a5e96b46" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er guarantees that it can work properly with uninitialized memory, it should call &lt;a href=&quot;struct.initializer#method.nop&quot;&gt;&lt;code&gt;Initializer::nop()&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;struct.initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">如果 &lt;code&gt;Read&lt;/code&gt; 保证它可以与未初始化的内存一起正常工作，则应调用&lt;a href=&quot;struct.initializer#method.nop&quot;&gt; &lt;code&gt;Initializer::nop()&lt;/code&gt; &lt;/a&gt;。有关详细信息，请参见&lt;a href=&quot;struct.initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="6f382719afa245fe22b4489961298212f0dd9d4d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</source>
          <target state="translated">如果 &lt;code&gt;String&lt;/code&gt; 具有足够的容量，则向其添加元素不会重新分配。例如，考虑以下程序：</target>
        </trans-unit>
        <trans-unit id="9fa35bc4f2bce6280405afd54339a1d6674f6de7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</source>
          <target state="translated">如果 &lt;code&gt;Vacant(entry)&lt;/code&gt; 的产生，那么关键&lt;em&gt;是没有&lt;/em&gt;找到。在这种情况下，唯一有效的操作是在条目中 &lt;code&gt;insert&lt;/code&gt; 一个值。完成此操作后，将使用空条目并将其转换为对插入值的可变引用。这允许在搜索本身的生命周期之外对值进行进一步操作。如果无论是否刚刚插入值都需要对值执行复杂的逻辑，这将很有用。</target>
        </trans-unit>
        <trans-unit id="cda87c5518b5b9027cd10d7cda1ac0257185a449" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vec&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to &lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-&lt;/code&gt;&lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; logically uninitialized, contiguous elements.</source>
          <target state="translated">如果 &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;已&lt;/em&gt;分配内存，则它指向的内存在堆上（由分配器Rust定义为默认使用），并且其指针按顺序指向&lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;初始化的连续元素（您将看到什么）你它强制转换为片），随后&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-&lt;/code&gt; &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; 个&lt;/a&gt;逻辑上未初始化的，连续的元件。</target>
        </trans-unit>
        <trans-unit id="dd0874f4a42c7a12d138cfaedb4f719f3af9227c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Write&lt;/code&gt;er does not override the default &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887bcf39fbff642c3b328187978b79bee02328d7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;const&lt;/code&gt; item contains some type that does not implement this trait, then that type either (1.) does not implement &lt;code&gt;PartialEq&lt;/code&gt; (which means the constant will not provide that comparison method, which code generation assumes is available), or (2.) it implements &lt;em&gt;its own&lt;/em&gt; version of &lt;code&gt;PartialEq&lt;/code&gt; (which we assume does not conform to a structural-equality comparison).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7756c2df57a46e8ffe41d330e37036f813dca05f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;static&lt;/code&gt; item is declared with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword, then it is allowed to be modified by the program. However, accessing mutable &lt;code&gt;static&lt;/code&gt;s can cause undefined behavior in a number of ways, for example due to data races in a multithreaded context. As such, all accesses to mutable &lt;code&gt;static&lt;/code&gt;s require an &lt;a href=&quot;keyword.unsafe&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0ce05d92f7c594a3a90bea8f233df56be2f1d6" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;new&lt;/em&gt; file is created because it does not yet exist and &lt;code&gt;.create(true)&lt;/code&gt; or &lt;code&gt;.create_new(true)&lt;/code&gt; are specified, the new file is given the attributes declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">如果由于尚不存在而创建了&lt;em&gt;新&lt;/em&gt;文件，并且 &lt;code&gt;.create(true)&lt;/code&gt; 或 &lt;code&gt;.create_new(true)&lt;/code&gt; ，则将为新文件提供使用 &lt;code&gt;.attributes()&lt;/code&gt; 声明的属性。</target>
        </trans-unit>
        <trans-unit id="16c8daede20373077d8ff711c94e64a0b59b67bb" translate="yes" xml:space="preserve">
          <source>If a binding pattern does not explicitly have &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ref mut&lt;/code&gt;, or &lt;code&gt;mut&lt;/code&gt;, then it uses the &lt;em&gt;default binding mode&lt;/em&gt; to determine how the variable is bound. The default binding mode starts in &quot;move&quot; mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to &lt;code&gt;ref&lt;/code&gt;. Mutable references will set the mode to &lt;code&gt;ref mut&lt;/code&gt; unless the mode is already &lt;code&gt;ref&lt;/code&gt; in which case it remains &lt;code&gt;ref&lt;/code&gt;. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</source>
          <target state="translated">如果绑定模式没有显式具有 &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;ref mut&lt;/code&gt; 或 &lt;code&gt;mut&lt;/code&gt; ，则它将使用&lt;em&gt;默认绑定模式&lt;/em&gt;来确定如何绑定变量。默认绑定模式从使用移动语义的&amp;ldquo;移动&amp;rdquo;模式开始。匹配模式时，编译器从模式外部开始并向内工作。每次使用非参考模式匹配参考时，它将自动取消参考值并更新默认绑定模式。引用会将默认绑定模式设置为 &lt;code&gt;ref&lt;/code&gt; 。可变引用会将模式设置为 &lt;code&gt;ref mut&lt;/code&gt; ,除非该模式已经是 &lt;code&gt;ref&lt;/code&gt; ,在这种情况下它将保持为 &lt;code&gt;ref&lt;/code&gt; 。如果自动取消引用的值仍然是引用，则将其取消引用，然后重复此过程。</target>
        </trans-unit>
        <trans-unit id="9479998c1b13e05b48032e25e7379b48f06d377a" translate="yes" xml:space="preserve">
          <source>If a borrow, dereference, field, or tuple indexing expression has an extended temporary scope then so does its operand. If an indexing expression has an extended temporary scope then the indexed expression also has an extended temporary scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cce383f10beb57ed085cf340ccb835736dad8de" translate="yes" xml:space="preserve">
          <source>If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">如果一个字符没有对应的小写字母,迭代器将返回相同的字符。</target>
        </trans-unit>
        <trans-unit id="ef2f005976fec5c6467e7bb3fc454eb0cb7f06ed" translate="yes" xml:space="preserve">
          <source>If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">如果一个字符没有等价的大写字母,迭代器将返回相同的字符。</target>
        </trans-unit>
        <trans-unit id="d0d13af4b33d582574dec6432db47608e7a6fcac" translate="yes" xml:space="preserve">
          <source>If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">如果需要干净的关机,建议只在一个已知的点上调用这个函数,在这个点上已经没有更多的destructors可以运行。</target>
        </trans-unit>
        <trans-unit id="90545bafc06a46b5933ce2daa0969b441705a55d" translate="yes" xml:space="preserve">
          <source>If a const function is called outside a &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">如果在&lt;a href=&quot;../const_eval#const-context&quot;&gt;const上下文&lt;/a&gt;之外调用const函数，则它与任何其他函数都没有区别。您可以使用const函数自由地执行任何操作，就像使用常规函数一样。</target>
        </trans-unit>
        <trans-unit id="ba510c5879ea4cc171f31422ae04de034d50983c" translate="yes" xml:space="preserve">
          <source>If a destructor must be run manually, such as when implementing your own smart pointer, &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;std::ptr::drop_in_place&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">如果析构函数必须手动运行（例如在实现自己的智能指针时），则可以使用&lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;std::ptr::drop_in_place&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aac87c21fcf6474549d65e03ca36c8ec59d12740" translate="yes" xml:space="preserve">
          <source>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</source>
          <target state="translated">如果正在生成一个动态库或正在动态链接的可执行文件,那么编译器将尝试以rlib或dylib格式协调可用的依赖关系,以创建最终产品。</target>
        </trans-unit>
        <trans-unit id="5cf3f34eab79e2589477387981185c179654267a" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25b09268442abcdc7a1f9b2c36f533d27627828" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;struct.file#method.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">如果打开文件同时具有读取和附加访问权限，请注意在打开之后以及每次写入之后，都可以在文件末尾设置读取位置。因此，在写入之前，请保存当前位置（使用&lt;a href=&quot;struct.file#method.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; ），并在下一次读取之前将其还原。</target>
        </trans-unit>
        <trans-unit id="7ae8e9b37b3fae0e90c2e27255beba504df5f00d" translate="yes" xml:space="preserve">
          <source>If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.</source>
          <target state="translated">如果一个文件在设置了这个选项的情况下被成功打开,如果文件已经存在,它将把文件截断为0长度。</target>
        </trans-unit>
        <trans-unit id="d0abbc43e6eb90b8c51d1b76b304256ddf0362aa" translate="yes" xml:space="preserve">
          <source>If a floating-point type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed floating-point literal has that type.</source>
          <target state="translated">如果可以从周围的程序上下文中&lt;em&gt;唯一&lt;/em&gt;确定浮点类型，则未加后缀的浮点文字将具有该类型。</target>
        </trans-unit>
        <trans-unit id="04efa2d88cc29b968e806cf715e0ee4d0b695c80" translate="yes" xml:space="preserve">
          <source>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct&amp;rsquo;s fields and method implementations. However, if you&amp;rsquo;re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</source>
          <target state="translated">如果一种语言必须具有继承才能成为面向对象的语言，那么Rust就是其中之一。无法定义继承父结构的字段和方法实现的结构。但是，如果您习惯在编程工具箱中继承继承，则可以在Rust中使用其他解决方案，这取决于您首先要继承的原因。</target>
        </trans-unit>
        <trans-unit id="442a02939139d9c59cef162a2647bac06f4e1997" translate="yes" xml:space="preserve">
          <source>If a method call fails in a test, you&amp;rsquo;d want the whole test to fail, even if that method isn&amp;rsquo;t the functionality under test. Because &lt;code&gt;panic!&lt;/code&gt; is how a test is marked as a failure, calling &lt;code&gt;unwrap&lt;/code&gt; or &lt;code&gt;expect&lt;/code&gt; is exactly what should happen.</source>
          <target state="translated">如果某个方法调用在测试中失败，则您希望整个测试都失败，即使该方法不是受测试的功能。因为 &lt;code&gt;panic!&lt;/code&gt; 测试被标记为失败，调用 &lt;code&gt;unwrap&lt;/code&gt; 或 &lt;code&gt;expect&lt;/code&gt; 方式正是应该发生的情况。</target>
        </trans-unit>
        <trans-unit id="9d96dca6a8141f4e31a24310383d3fa9b46a981c" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of a &lt;code&gt;File::open_opts&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the systems &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">如果在 &lt;code&gt;File::open_opts&lt;/code&gt; 调用中创建了一个新文件，则此指定的 &lt;code&gt;mode&lt;/code&gt; 将用作新文件的权限位。如果未设置任何 &lt;code&gt;mode&lt;/code&gt; ，则将使用默认值 &lt;code&gt;0o666&lt;/code&gt; 。操作系统使用系统 &lt;code&gt;umask&lt;/code&gt; 屏蔽掉某些位，以产生最终权限。</target>
        </trans-unit>
        <trans-unit id="29baa09d14f6cfea0e9d752b0246ef9148a54b0e" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of an &lt;code&gt;OpenOptions::open&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the system's &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a088dab2a65affaf69dc6a26afc8c56ddf7d23" translate="yes" xml:space="preserve">
          <source>If a nul byte is present and not the last element or no nul bytes is present, an error will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf29e89879313dc8e8b20d286c6fbf984a0c2ff" translate="yes" xml:space="preserve">
          <source>If a panic occurs in a named thread, the thread name will be printed in the panic message.</source>
          <target state="translated">如果在命名的线程中发生恐慌,线程名称将被打印在恐慌信息中。</target>
        </trans-unit>
        <trans-unit id="ae66f71517007a8faed7e8f14069d9743a8fc1d6" translate="yes" xml:space="preserve">
          <source>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</source>
          <target state="translated">如果一个程序中包含算术溢出,则说明程序员犯了错误。在下面的讨论中,我们保持对算术溢出和封装算术的区分。第一种是错误的,而第二种是故意的。</target>
        </trans-unit>
        <trans-unit id="9ed92fa5e7088a3110b1cc9346594a14bbfacbbf" translate="yes" xml:space="preserve">
          <source>If a static item is declared with the &lt;code&gt;mut&lt;/code&gt; keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an &lt;code&gt;unsafe&lt;/code&gt; block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</source>
          <target state="translated">如果使用 &lt;code&gt;mut&lt;/code&gt; 关键字声明了静态项目，则程序允许对其进行修改。Rust的目标之一是使并发错误难以运行，这显然是竞争条件或其他错误的很大来源。因此，在读取或写入可变静态变量时需要一个 &lt;code&gt;unsafe&lt;/code&gt; 块。应注意确保对可变静态变量的修改相对于在同一进程中运行的其他线程是安全的。</target>
        </trans-unit>
        <trans-unit id="a1766ce77343ee3ad45def8d871224ac057e5320" translate="yes" xml:space="preserve">
          <source>If a static library is being produced, all upstream dependencies are required to be available in &lt;code&gt;rlib&lt;/code&gt; formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</source>
          <target state="translated">如果要生成静态库，则所有上游依赖项都必须以 &lt;code&gt;rlib&lt;/code&gt; 格式可用。此要求源于无法将动态库转换为静态格式的原因。</target>
        </trans-unit>
        <trans-unit id="7bac0e8b6805f499b0c443af2ab6fa54c5aa649c" translate="yes" xml:space="preserve">
          <source>If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt; for method and function invocation.</source>
          <target state="translated">如果在一个步骤中有多个可能的方法（例如，将通用方法或特性视为相同），则会导致编译器错误。这些情况需要用于方法和函数调用的&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;歧义函数调用语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f3fff7995601b35f7065fae1e640e2f2eeb6214" translate="yes" xml:space="preserve">
          <source>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</source>
          <target state="translated">如果一个字符串包含多个连续的分隔符,你将在输出中以空字符串结束。</target>
        </trans-unit>
        <trans-unit id="4ab14222518e8fb43884627c81d597c32a8700e2" translate="yes" xml:space="preserve">
          <source>If a type &lt;code&gt;Item&lt;/code&gt; has an associated type &lt;code&gt;Assoc&lt;/code&gt; from a trait &lt;code&gt;Trait&lt;/code&gt;, then &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; is a type that is an alias of the type specified in the associated type definition. Furthermore, if &lt;code&gt;Item&lt;/code&gt; is a type parameter, then &lt;code&gt;Item::Assoc&lt;/code&gt; can be used in type parameters.</source>
          <target state="translated">如果类型 &lt;code&gt;Item&lt;/code&gt; 具有来自特征 &lt;code&gt;Trait&lt;/code&gt; 的关联类型 &lt;code&gt;Assoc&lt;/code&gt; ，则 &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; 是作为关联类型定义中指定的类型的别名的类型。此外，如果 &lt;code&gt;Item&lt;/code&gt; 是类型参数，则可以在类型参数中使用 &lt;code&gt;Item::Assoc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98ce79152874ad30a4163310f54c79462c6fb1d7" translate="yes" xml:space="preserve">
          <source>If a type contains a &lt;code&gt;PhantomPinned&lt;/code&gt;, it will not implement &lt;code&gt;Unpin&lt;/code&gt; by default.</source>
          <target state="translated">如果类型包含 &lt;code&gt;PhantomPinned&lt;/code&gt; ，则默认情况下不会实现 &lt;code&gt;Unpin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1433c5d355e130cd227bc3635eea7b7161e572f3" translate="yes" xml:space="preserve">
          <source>If all goes well, &lt;code&gt;Hello, world!&lt;/code&gt; should print to the terminal. Running &lt;code&gt;cargo build&lt;/code&gt; for the first time also causes Cargo to create a new file at the top level: &lt;em&gt;Cargo.lock&lt;/em&gt;. This file keeps track of the exact versions of dependencies in your project. This project doesn&amp;rsquo;t have dependencies, so the file is a bit sparse. You won&amp;rsquo;t ever need to change this file manually; Cargo manages its contents for you.</source>
          <target state="translated">如果一切顺利， &lt;code&gt;Hello, world!&lt;/code&gt; 应该打印到终端。首次运行 &lt;code&gt;cargo build&lt;/code&gt; 还会使Cargo在顶层创建一个新文件：&lt;em&gt;Cargo.lock&lt;/em&gt;。此文件跟踪项目中依赖项的确切版本。该项目没有依赖项，因此文件有点稀疏。您将不再需要手动更改此文件。货运为您管理其内容。</target>
        </trans-unit>
        <trans-unit id="5ace79993641886b01cac522412b514b142053ea" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Alloc&lt;/code&gt; implementation chooses to return &lt;code&gt;Ok&lt;/code&gt; in this case (i.e., the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered &quot;currently allocated&quot;. On such an allocator, &lt;em&gt;all&lt;/em&gt; methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, &lt;em&gt;without&lt;/em&gt; causing undefined behavior.</source>
          <target state="translated">如果在这种情况下 &lt;code&gt;Alloc&lt;/code&gt; 实现选择返回 &lt;code&gt;Ok&lt;/code&gt; （即，指针表示大小为零的不可访问块），则必须将返回的指针视为&amp;ldquo;当前分配&amp;rdquo;。在这样的分配器上，&lt;em&gt;所有&lt;/em&gt;将当前分配的指针作为输入的方法必须接受这些零大小的指针，&lt;em&gt;而不会&lt;/em&gt;引起未定义的行为。</target>
        </trans-unit>
        <trans-unit id="766a342529319b1e212f056deacbe904859bc648" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Err(e)&lt;/code&gt; result is returned, the value &lt;code&gt;e&lt;/code&gt; will be &quot;wrapped&quot; in the return type of the enclosing scope (which must itself implement &lt;code&gt;Try&lt;/code&gt;). Specifically, the value &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; is returned, where &lt;code&gt;X&lt;/code&gt; is the return type of the enclosing function.</source>
          <target state="translated">如果返回 &lt;code&gt;Err(e)&lt;/code&gt; 结果，则值 &lt;code&gt;e&lt;/code&gt; 将&amp;ldquo;封装&amp;rdquo;在封闭范围的返回类型中（该范围本身必须实现 &lt;code&gt;Try&lt;/code&gt; ）。具体来说，将返回值 &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是封闭函数的返回类型。</target>
        </trans-unit>
        <trans-unit id="d07fb8a7b5eba0666b8e8c43c71f4a92c4cff59d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case, the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant &lt;code&gt;insert&lt;/code&gt; case.</source>
          <target state="translated">如果 &lt;code&gt;Occupied(entry)&lt;/code&gt; 的产生，那么关键&lt;em&gt;是&lt;/em&gt;找到。在这种情况下，用户有几个选项：他们可以 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;insert&lt;/code&gt; 或 &lt;code&gt;remove&lt;/code&gt; 占用项的值。此外，他们可以将占用的条目转换为其值的可变引用，从而为空的 &lt;code&gt;insert&lt;/code&gt; 情况提供对称性。</target>
        </trans-unit>
        <trans-unit id="6496ceefd96285c8c2e145eb325b81df30982dd9" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;rlib&lt;/code&gt; file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</source>
          <target state="translated">如果正在生成 &lt;code&gt;rlib&lt;/code&gt; 文件，则对上游依赖项可用的格式没有任何限制。仅要求所有上游依赖项都可用于读取元数据。</target>
        </trans-unit>
        <trans-unit id="c8e60161efc2f2d7cfcdc0d31414bc493321f65f" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;existing&lt;/em&gt; file is opened with &lt;code&gt;.create(true).truncate(true)&lt;/code&gt;, its existing attributes are preserved and combined with the ones declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;.create(true).truncate(true)&lt;/code&gt; 打开&lt;em&gt;现有&lt;/em&gt;文件，则将保留其现有属性，并将其与 &lt;code&gt;.attributes()&lt;/code&gt; 声明的属性合并。</target>
        </trans-unit>
        <trans-unit id="f270e545d597563858cae4afcff9e37ad4508d2c" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered then all bytes read so far will be present in &lt;code&gt;buf&lt;/code&gt; and its length will have been adjusted appropriately.</source>
          <target state="translated">如果遇到I / O错误，那么到目前为止，所有读取的字节都将存在于 &lt;code&gt;buf&lt;/code&gt; 中,并且其长度已经适当调整。</target>
        </trans-unit>
        <trans-unit id="ace1a7d9bf9ec54c3308257f201a03fece98ab35" translate="yes" xml:space="preserve">
          <source>If an executable is being produced and the &lt;code&gt;-C prefer-dynamic&lt;/code&gt; flag is not specified, then dependencies are first attempted to be found in the &lt;code&gt;rlib&lt;/code&gt; format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</source>
          <target state="translated">如果正在生成可执行文件，但未指定 &lt;code&gt;-C prefer-dynamic&lt;/code&gt; &lt;code&gt;rlib&lt;/code&gt; -dynamic标志，则首先尝试以rlib格式找到依赖项。如果某些依赖项无法以rlib格式提供，则尝试进行动态链接（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="45d869ce1ba972ba36ff54baa74eb31c5112c34d" translate="yes" xml:space="preserve">
          <source>If an executor supports a cheaper way to wake without consuming the waker, it should override this method. By default, it clones the &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;wake&lt;/code&gt; on the clone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246eecf3cfe47d66c6f45d4fd6c99d8afcbf27a5" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an &lt;code&gt;unsafe impl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e13abdce3cf8ba0eee5f3efa1352739a357002e" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an `unsafe impl.</source>
          <target state="translated">如果impl具有带有 &lt;code&gt;#[may_dangle]&lt;/code&gt; 属性的通用参数，则必须将该impl声明为&amp;ldquo;不安全的impl&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="11945bca4b49d81520c3d9de6a4cbb63f81941bb" translate="yes" xml:space="preserve">
          <source>If an integer type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed integer literal has that type.</source>
          <target state="translated">如果可以从周围的程序上下文中&lt;em&gt;唯一&lt;/em&gt;确定整数类型，则未加后缀的整数文字将具有该类型。</target>
        </trans-unit>
        <trans-unit id="8e63390dbf4949c326a2cfedfadab303b53fa34d" translate="yes" xml:space="preserve">
          <source>If an intrinsic is supposed to be used from a &lt;code&gt;const fn&lt;/code&gt; with a &lt;code&gt;rustc_const_stable&lt;/code&gt; attribute, the intrinsic's attribute must be &lt;code&gt;rustc_const_stable&lt;/code&gt;, too. Such a change should not be done without T-lang consultation, because it bakes a feature into the language that cannot be replicated in user code without compiler support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39805e5d14d8cab59f3ec2eabeee9744560e1fb2" translate="yes" xml:space="preserve">
          <source>If an item is private, it may be accessed by the current module and its descendants.</source>
          <target state="translated">如果一个项目是私有的,那么它可以被当前模块和它的后代访问。</target>
        </trans-unit>
        <trans-unit id="727527b77e366466861dd6da815129cfeb9a9374" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's ancestor modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07080131ca18f6d9e5b13a9d88dcf93cd9dc48cd" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's parent modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">如果某个项目是公共项目，那么如果您可以从 &lt;code&gt;m&lt;/code&gt; 访问该项目的所有父模块，则可以从某个模块 &lt;code&gt;m&lt;/code&gt; 对其进行外部访问。您也可能可以通过重新导出来命名商品。见下文。</target>
        </trans-unit>
        <trans-unit id="d8864aae63bb3ba2da5620b13b08d971e5c9ff9b" translate="yes" xml:space="preserve">
          <source>If an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63585324ac753447dc7a54f44e90a00d790fca2c" translate="yes" xml:space="preserve">
          <source>If another thread is active, the lock can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">如果另一个线程处于活动状态，则锁定仍可能随时中毒。如果没有其他同步，则不应信任 &lt;code&gt;false&lt;/code&gt; 的程序正确性值。</target>
        </trans-unit>
        <trans-unit id="109588b2017fbb996d88327d5cc6be15dd8d4ba0" translate="yes" xml:space="preserve">
          <source>If another thread is active, the mutex can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">如果另一个线程处于活动状态，则互斥体仍然可以随时中毒。如果没有其他同步，则不应信任 &lt;code&gt;false&lt;/code&gt; 的程序正确性值。</target>
        </trans-unit>
        <trans-unit id="78ea9516ec8ea7a6ed978cbfe197fc08ae18d0c1" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error if the mutex would otherwise be acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8114d3ac34051321d85f9acd763dd0f154fb356" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error instead.</source>
          <target state="translated">如果这个mutex的另一个用户在持有mutex的时候惊慌失措,那么这个调用将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="937c1840433dcebbb1b2c20629e7140489485c5e" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.</source>
          <target state="translated">如果这个mutex的另一个用户在持有mutex时惊慌失措,那么这个调用将在获取mutex后返回一个错误。</target>
        </trans-unit>
        <trans-unit id="94a8b260ae2fd91c20d30826f0ac290f20d42663" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.</source>
          <target state="translated">如果这个mutex的另一个用户在持有mutex时惊慌失措,那么如果这个mutex在其他情况下会被获取,这个调用将返回失败。</target>
        </trans-unit>
        <trans-unit id="b8a9fd6020c6344c3b4ec789d5cdc75685b6c76f" translate="yes" xml:space="preserve">
          <source>If any directory in the path specified by &lt;code&gt;path&lt;/code&gt; does not already exist and it could not be created otherwise. The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by &lt;a href=&quot;fn.create_dir&quot;&gt;&lt;code&gt;fs::create_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果path指定的 &lt;code&gt;path&lt;/code&gt; 中的任何目录都不存在，否则无法创建。&lt;a href=&quot;fn.create_dir&quot;&gt; &lt;code&gt;fs::create_dir&lt;/code&gt; &lt;/a&gt;概述了创建目录时（确定目录不存在后）的特定错误情况。</target>
        </trans-unit>
        <trans-unit id="8c9733a4a8648c17f076f404425858c19e3e7e60" translate="yes" xml:space="preserve">
          <source>If any of the following conditions are violated, the result is Undefined Behavior:</source>
          <target state="translated">如果违反了以下任何一个条件,结果就是未定义行为。</target>
        </trans-unit>
        <trans-unit id="abfc6e25813ef681d155e66f1a056df288816b17" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. Any bytes which have already been read will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">如果遇到任何其他读取错误，则此函数将立即返回。任何已读取的字节都将附加到 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc672b538a09f0d8b7133f8175c1bdde7ae9dbbb" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">如果遇到任何其他读取错误，则此函数将立即返回。在这种情况下，未指定 &lt;code&gt;buf&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="c60fca22bff6a233bf25c6e3874996a91aad3287" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddacadc60603d21344f24b6aa894045e4936178f" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">如果两者都不存在，则使用&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt;返回路径。</target>
        </trans-unit>
        <trans-unit id="7fce57c290d26a88e07f0e0c3e4758aa4174e90c" translate="yes" xml:space="preserve">
          <source>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</source>
          <target state="translated">如果编译成dylib,那么产生的.so可以从C库中链接到,并且函数可以像其他库一样使用。</target>
        </trans-unit>
        <trans-unit id="e7b59b345b11e01a4787fa859ca6ad581aae3ad3" translate="yes" xml:space="preserve">
          <source>If either iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. If the first iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;zip&lt;/code&gt; will short-circuit and &lt;code&gt;next&lt;/code&gt; will not be called on the second iterator.</source>
          <target state="translated">如果任一迭代器返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则压缩的迭代器中的&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;迭代器将返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果第一个迭代器返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;zip&lt;/code&gt; 将短路，第二个迭代器将不调用 &lt;code&gt;next&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84103f8a5cb4506a8862655c59a4b3682ff15678" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">如果启用,多播数据包将被循环回本地套接字。注意,这对IPv6套接字可能没有任何影响。</target>
        </trans-unit>
        <trans-unit id="2ee8e080132486e2d1085bc2a52cb053b7cbc535" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any effect on IPv6 sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb4d55515faf0167f284803093db70ba6bdf600" translate="yes" xml:space="preserve">
          <source>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use &lt;code&gt;pub&lt;/code&gt; or not for different parts of code enables encapsulation of implementation details.</source>
          <target state="translated">如果封装是将语言视为面向对象的必需方面，则Rust满足该要求。选择是否对不同的代码部分使用 &lt;code&gt;pub&lt;/code&gt; 选项可以实现实现细节的封装。</target>
        </trans-unit>
        <trans-unit id="f88c3e80e7b4d154c2577f1e634c78e02c1c42d5" translate="yes" xml:space="preserve">
          <source>If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.</source>
          <target state="translated">如果一个元组中的每个类型都实现了下面的一个特性,那么一个元组本身也实现了它。</target>
        </trans-unit>
        <trans-unit id="b8129e0ab4f408174bb11267c05f089405b50c77" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as more types can safely implement it.</source>
          <target state="translated">如果通用代码仅需要为可以提供对相关类型 &lt;code&gt;T&lt;/code&gt; 的引用的所有类型工作，则通常最好使用&lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;因为更多类型可以安全地实现它。</target>
        </trans-unit>
        <trans-unit id="281313906bc5aa3fa055587412d6aee7b2eda929" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use [&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;] as more types can safely implement it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c986c219a8db1074aab149e63ad254d155df91" translate="yes" xml:space="preserve">
          <source>If given a position, returns a reference to the element at that position or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">如果给定位置，则返回对该位置处元素的引用；如果超出范围，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0807d56f2c6d8607e36641ca45b2207a499de182" translate="yes" xml:space="preserve">
          <source>If given a range, returns the subslice corresponding to that range, or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">如果给定范围，则返回与该范围相对应的子切片；如果超出范围，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfe4ffb9dd92d20a6a4139ebde5c4444a81b450b" translate="yes" xml:space="preserve">
          <source>If interpreted as the number of actual hardware threads, it may undercount on Windows systems with more than 64 hardware threads. If interpreted as the available concurrency for that process, it may overcount on Windows systems when limited by a process wide affinity mask or job object limitations, and it may overcount on Linux systems when limited by a process wide affinity mask or affected by cgroups limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78c81075548342c17a3cb41f1d7c207afd16e82" translate="yes" xml:space="preserve">
          <source>If it does, add it to the list of values we&amp;rsquo;re returning.</source>
          <target state="translated">如果是这样，请将其添加到我们要返回的值列表中。</target>
        </trans-unit>
        <trans-unit id="6eb8349ae4604f3200e1b12d72175fa1292b930e" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t, do nothing.</source>
          <target state="translated">如果没有，则什么也不做。</target>
        </trans-unit>
        <trans-unit id="77f0c7f8e7e8804708118486c51110234f91b9ca" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::MAX&lt;/code&gt;. It is permissible for the implementation to &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;usize::MAX&lt;/code&gt;. Only your algorithm's performance can depend on getting a usable offset here, not its correctness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9651a04b746a289895c0ff4ac7dbbd9c6c4bd1d9" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::max_value()&lt;/code&gt;.</source>
          <target state="translated">如果无法对齐指针，则实现返回 &lt;code&gt;usize::max_value()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36c410707c8ca092b792e6807c748e0afad6b271" translate="yes" xml:space="preserve">
          <source>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</source>
          <target state="translated">如果可能的话,通过为每一个可能的类型替换写函数来手工变形代码。可以使用特质来干净利落地完成这项工作,例如:。</target>
        </trans-unit>
        <trans-unit id="8fae40cdb468d4e5d03de42a624dd09250a5c8c7" translate="yes" xml:space="preserve">
          <source>If less than &lt;code&gt;n&lt;/code&gt; elements are available, &lt;code&gt;take&lt;/code&gt; will limit itself to the size of the underlying iterator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e5a61966add37320ef9414096df3e05db3ac2b" translate="yes" xml:space="preserve">
          <source>If more code were added between the construction of &lt;code&gt;String&lt;/code&gt; and the invocation of &lt;code&gt;mem::forget()&lt;/code&gt;, a panic within it would cause a double free because the same memory is handled by both &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbc54548355fd2192a8ba719e27f659cd206c5b" translate="yes" xml:space="preserve">
          <source>If multiple patterns are used in the same arm for a &lt;code&gt;match&lt;/code&gt; expression, then an unspecified pattern will be used to determine the drop order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4391f80fe19e3beba14af1b68f867a8deafde6" translate="yes" xml:space="preserve">
          <source>If necessary, you can circumvent this check using custom target specifications.</source>
          <target state="translated">如果有必要,你可以使用自定义目标规格来规避这个检查。</target>
        </trans-unit>
        <trans-unit id="7c94321a1ed561693d40d9b66f1f46aeaaecd3c4" translate="yes" xml:space="preserve">
          <source>If neither of the above env vars are set, then &lt;code&gt;Backtrace::capture&lt;/code&gt; will be disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e62341b0bd62d9e8cebd223a1dae7b6e2b460b" translate="yes" xml:space="preserve">
          <source>If neither of those rules apply, then the bounds on the trait are used:</source>
          <target state="translated">如果这两条规则都不适用,那么就使用性状的界限。</target>
        </trans-unit>
        <trans-unit id="f04e4c83d03462bae231d396fbd6bc133f04e581" translate="yes" xml:space="preserve">
          <source>If no custom hook is registered, the default hook will be returned.</source>
          <target state="translated">如果没有注册自定义钩子,将返回默认钩子。</target>
        </trans-unit>
        <trans-unit id="3ea6cae08b251d423319bdb503b4761220cd47ba" translate="yes" xml:space="preserve">
          <source>If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</source>
          <target state="translated">如果没有为给定类型的自动特征写出显式实现或否定式实现,那么编译器就会根据以下规则自动实现它。</target>
        </trans-unit>
        <trans-unit id="5d4b1cf8f992f711595955dfbd04de1463c70def" translate="yes" xml:space="preserve">
          <source>If no strong pointers remain, this will return zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f530d6d6508b49e7ed96395312e1b09be42668f" translate="yes" xml:space="preserve">
          <source>If not, just run closures one at a time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7fa92522a250a6d3be880c3209e2e00d855d4b" translate="yes" xml:space="preserve">
          <source>If not, try to compute a mutual supertype of &lt;code&gt;T_t&lt;/code&gt; and &lt;code&gt;Ti&lt;/code&gt;, which will become the new target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902fe9b3f2f74127ecf6007749394b452c7a24b7" translate="yes" xml:space="preserve">
          <source>If one of the arguments is NaN, then the other argument is returned.</source>
          <target state="translated">如果其中一个参数是NaN,则返回另一个参数。</target>
        </trans-unit>
        <trans-unit id="fd66bf5358b1619dbf93c578d3488d32d0c0fca1" translate="yes" xml:space="preserve">
          <source>If one sequence is a prefix of another, the shorter sequence is lexicographically less than the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae9dd3ada03870a6668bdcb11d4ca3933501dde" translate="yes" xml:space="preserve">
          <source>If only some methods aren't object-safe, you can add a &lt;code&gt;where Self: Sized&lt;/code&gt; bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; which is itself sized (assuming you &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">如果只有某些方法不是对象安全的，则可以在它们上添加一个 &lt;code&gt;where Self: Sized&lt;/code&gt; ，以将其标记为特征对象明确不可用。该功能仍将对所有其他实现者可用，包括 &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 本身的大小（假定您 &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df3400bc60a85af8ff3ace18e07d7c2d1864912a" translate="yes" xml:space="preserve">
          <source>If our project is a binary crate that only contains a &lt;em&gt;src/main.rs&lt;/em&gt; file and doesn&amp;rsquo;t have a &lt;em&gt;src/lib.rs&lt;/em&gt; file, we can&amp;rsquo;t create integration tests in the &lt;em&gt;tests&lt;/em&gt; directory and bring functions defined in the &lt;em&gt;src/main.rs&lt;/em&gt; file into scope with a &lt;code&gt;use&lt;/code&gt; statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</source>
          <target state="translated">如果我们的项目是一个二进制箱只包含一个&lt;em&gt;SRC / main.rs&lt;/em&gt;文件，不具有&lt;em&gt;的src / lib.rs&lt;/em&gt;文件，我们不能建立在集成测试&lt;em&gt;的测试&lt;/em&gt;目录，并在规定带来功能&lt;em&gt;的src / main .rs&lt;/em&gt;通过 &lt;code&gt;use&lt;/code&gt; 语句进入作用域。只有库文件箱才能显示其他文件箱可以使用的功能；二进制板条箱应单独运行。</target>
        </trans-unit>
        <trans-unit id="e6324fa8ddd04d1618f1aebd83b3f76a15a2cd28" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle between the values. This means that their reference counts can never reach 0, and the values will remain allocated forever: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">如果我们的要求发生变化，并且我们还需要能够从 &lt;code&gt;Owner&lt;/code&gt; 到 &lt;code&gt;Gadget&lt;/code&gt; 遍历，我们将遇到问题。从 &lt;code&gt;Owner&lt;/code&gt; 到 &lt;code&gt;Gadget&lt;/code&gt; 的&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针会在值之间引入一个循环。这意味着它们的引用计数永远不会达到0，并且这些值将永远分配：内存泄漏。为了解决这个问题，我们可以使用&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。</target>
        </trans-unit>
        <trans-unit id="921a182084c11bc25c06cdc6fb33da8acc45c85b" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle. This means that their reference counts can never reach 0, and the allocation will never be destroyed: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b786199b10d931840d1086948f15c121bb97b51" translate="yes" xml:space="preserve">
          <source>If parsing succeeds, return the value inside &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise when the string is ill-formatted return an error specific to the inside &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. The error type is specific to implementation of the trait.</source>
          <target state="translated">如果解析成功，则返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;内部的值，否则，当字符串格式错误时，返回内部&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;特定的错误。错误类型特定于特征的实现。</target>
        </trans-unit>
        <trans-unit id="1260ea15bf2742af82873380ef5cdc057469a6e9" translate="yes" xml:space="preserve">
          <source>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</source>
          <target state="translated">如果设置,该选项将禁用Nagle算法。这意味着,即使只有少量数据,也总是尽快发送段。如果不设置,则会对数据进行缓冲,直到有足够的数据量发送出去,从而避免频繁发送小数据包。</target>
        </trans-unit>
        <trans-unit id="0161295a4165e472097a556bd12e3cb8153ce739" translate="yes" xml:space="preserve">
          <source>If several elements are equally maximum, the last element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果几个元素相等地最大，则返回最后一个元素。如果迭代器为空，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="949e58f9ba98c6ec3b36a7ff32fc3bb4b305461a" translate="yes" xml:space="preserve">
          <source>If several elements are equally minimum, the first element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果几个元素相等地最小，则返回第一个元素。如果迭代器为空，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b831b3eb60862f2e083acd74777a5de0ed02dd83" translate="yes" xml:space="preserve">
          <source>If someone calls your code and passes in values that don&amp;rsquo;t make sense, the best choice might be to call &lt;code&gt;panic!&lt;/code&gt; and alert the person using your library to the bug in their code so they can fix it during development. Similarly, &lt;code&gt;panic!&lt;/code&gt; is often appropriate if you&amp;rsquo;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</source>
          <target state="translated">如果有人调用您的代码并传递了没有意义的值，那么最好的选择就是调用 &lt;code&gt;panic!&lt;/code&gt; 并提醒使用您的库的人员代码中的错误，以便他们可以在开发期间进行修复。同样， &lt;code&gt;panic!&lt;/code&gt; 如果您正在调用无法控制的外部代码，并且返回的是无法修复的无效状态，则通常是合适的。</target>
        </trans-unit>
        <trans-unit id="acb94f3e0ba146c655ce1db4be8cf7e52d6ff088" translate="yes" xml:space="preserve">
          <source>If someone using our library decides to implement a &lt;code&gt;SelectBox&lt;/code&gt; struct that has &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;options&lt;/code&gt; fields, they implement the &lt;code&gt;Draw&lt;/code&gt; trait on the &lt;code&gt;SelectBox&lt;/code&gt; type as well, as shown in Listing 17-8:</source>
          <target state="translated">如果使用我们库的某人决定实现具有 &lt;code&gt;width&lt;/code&gt; ， &lt;code&gt;height&lt;/code&gt; 和 &lt;code&gt;options&lt;/code&gt; 字段的 &lt;code&gt;SelectBox&lt;/code&gt; 结构，那么他们也对 &lt;code&gt;SelectBox&lt;/code&gt; 类型实现 &lt;code&gt;Draw&lt;/code&gt; trait ，如清单17-8所示：</target>
        </trans-unit>
        <trans-unit id="c3e301e4e887fd636487b5cc6eb192ded20f6d8f" translate="yes" xml:space="preserve">
          <source>If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from the specified measurement to this one.</source>
          <target state="translated">如果成功，则返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; ，其中持续时间表示从指定的度量到此度量所经过的时间。</target>
        </trans-unit>
        <trans-unit id="89f232794c16a32779f42828429fca7b54b7471f" translate="yes" xml:space="preserve">
          <source>If successful, this function returns the number of bytes which were read and appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将返回已读取并附加到 &lt;code&gt;buf&lt;/code&gt; 的字节数。</target>
        </trans-unit>
        <trans-unit id="dbb9443efd5c60b83bc142aff81add19921534e6" translate="yes" xml:space="preserve">
          <source>If successful, this function will return the total number of bytes read.</source>
          <target state="translated">如果成功,该函数将返回读取的总字节数。</target>
        </trans-unit>
        <trans-unit id="8f3b4d7781f3d86f3d03470464550aa348524451" translate="yes" xml:space="preserve">
          <source>If taking ownership is not an option, using indices can work too:</source>
          <target state="translated">如果不能选择所有权,使用指数也可以。</target>
        </trans-unit>
        <trans-unit id="bf999049465c29583e4954eb5930504df7197d78" translate="yes" xml:space="preserve">
          <source>If that field has type &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, then &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果该字段的类型为 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; ，则 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 实现 &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9156e468bccd98925a16dabd42948c9bf77880b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, if the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;在尝试使用&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;进行发送时断开连接，则&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;方法将返回&lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt;。同样，如果&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;试图断开&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;时，&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; 的&lt;/a&gt;方法将返回一个&lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84c875b11ce397c9d5300f965f6f873d7aacf46f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;documentation&lt;/code&gt; environment variable is not defined, you'll get the following error:</source>
          <target state="translated">如果未定义 &lt;code&gt;documentation&lt;/code&gt; 环境变量，则会出现以下错误：</target>
        </trans-unit>
        <trans-unit id="772ba2d0efb42bb291361897234d8c41bb1fcad0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;move&lt;/code&gt; keyword is used, then all captures are by move or, for &lt;code&gt;Copy&lt;/code&gt; types, by copy, regardless of whether a borrow would work. The &lt;code&gt;move&lt;/code&gt; keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</source>
          <target state="translated">如果使用 &lt;code&gt;move&lt;/code&gt; 关键字，则所有捕获都是通过移动进行的，对于 &lt;code&gt;Copy&lt;/code&gt; 类型，则是通过复制进行的，而不管借用是否有效。该 &lt;code&gt;move&lt;/code&gt; 关键字通常用于允许闭合活得比捕获的值，例如，如果被返回或用于产生新线程关闭。</target>
        </trans-unit>
        <trans-unit id="9d0e8d596c36d8fd761ca63dbd3e067a9bd6e058" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;panic!&lt;/code&gt; macro from the &lt;code&gt;core&lt;/code&gt; crate (not from &lt;code&gt;std&lt;/code&gt;) was used with a formatting string and some additional arguments, returns that message ready to be used for example with &lt;a href=&quot;../fmt/fn.write&quot;&gt;&lt;code&gt;fmt::write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果 &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;core&lt;/code&gt; 板条箱（不是 &lt;code&gt;std&lt;/code&gt; ）中的宏与格式化字符串和一些其他参数一起使用，返回该消息准备好与&lt;a href=&quot;../fmt/fn.write&quot;&gt; &lt;code&gt;fmt::write&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1aa7728f06aa3a7a4db7dd1c33587c7078d8308d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;push_str&lt;/code&gt; method took ownership of &lt;code&gt;s2&lt;/code&gt;, we wouldn&amp;rsquo;t be able to print its value on the last line. However, this code works as we&amp;rsquo;d expect!</source>
          <target state="translated">如果 &lt;code&gt;push_str&lt;/code&gt; 方法拥有 &lt;code&gt;s2&lt;/code&gt; 的所有权，我们将无法在最后一行打印其值。但是，此代码可以按我们期望的那样工作！</target>
        </trans-unit>
        <trans-unit id="dced1236ce3e008b86324aaba64ac8eb311fb832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; parameter is prefixed with &lt;code&gt;mut&lt;/code&gt;, it becomes a mutable variable, similar to regular parameters using a &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt;. For example:</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 参数以 &lt;code&gt;mut&lt;/code&gt; 作为前缀，则它变为可变变量，类似于使用 &lt;code&gt;mut&lt;/code&gt; &lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;标识符模式的&lt;/a&gt;常规参数。例如：</target>
        </trans-unit>
        <trans-unit id="7d8f23d79fbc7e291c341b29a3b5a67aa2ad2d40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to &lt;code&gt;size&lt;/code&gt; and have all of the intermediate data filled in with 0s.</source>
          <target state="translated">如果 &lt;code&gt;size&lt;/code&gt; 小于当前文件的大小，则文件将缩小。如果它大于当前文件的大小，则该文件将扩展为 &lt;code&gt;size&lt;/code&gt; ，并且所有中间数据都用0填充。</target>
        </trans-unit>
        <trans-unit id="d57ee1700b4eb4f8d7a231756f83fc0d2f0976ae" translate="yes" xml:space="preserve">
          <source>If the access could not be granted at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.</source>
          <target state="translated">如果此时不能授予访问权限，则返回 &lt;code&gt;Err&lt;/code&gt; 。否则，将返回RAII保护，当该保护被删除时，该保护将释放共享访问。</target>
        </trans-unit>
        <trans-unit id="21bd5a18cb6b77fd8278b94aa3db19219a263b12" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then may return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果实际类型既不需要滴胶也不需要实现 &lt;code&gt;Copy&lt;/code&gt; ，则可能返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0291a87b80d4892b3b8beac10c94678155d9e30" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then the return value of this function is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc42b30b1c7732695b4b3457f14e9c116c60ba57" translate="yes" xml:space="preserve">
          <source>If the address different between the two pointers is not a multiple of &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; then the result of the division is rounded towards zero.</source>
          <target state="translated">如果两个指针之间的地址不同不是 &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 的倍数，则除法结果将取整为零。</target>
        </trans-unit>
        <trans-unit id="521a07de2e3c6e68db23d9d0aa394b57d65a9c91" translate="yes" xml:space="preserve">
          <source>If the array has 32 or fewer elements (see above), you can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">如果数组包含32个或更少的元素（请参见上文），则还可以使用数组引用的&lt;a href=&quot;iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;实现：</target>
        </trans-unit>
        <trans-unit id="cfb58ffddaf17c8830de11935999affae3277e66" translate="yes" xml:space="preserve">
          <source>If the author information that Cargo obtained from your environment is not correct, fix that in the file and save it again.</source>
          <target state="translated">如果Cargo从你的环境中获取的作者信息不正确,请在文件中修正,然后再保存。</target>
        </trans-unit>
        <trans-unit id="ff4681586c0fae7d47f1330c0decf48c60236eb4" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e707e84e6d9e2a09dcbe7b44964291bac9543c0" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2baf63139a4a500a73ca143a78e4d4794de4fa4c" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;poll&lt;/code&gt; returns &lt;a href=&quot;../../std/task/enum.poll#variant.Pending&quot;&gt;&lt;code&gt;Poll::Pending&lt;/code&gt;&lt;/a&gt;, then the future returns &lt;code&gt;Poll::Pending&lt;/code&gt;, suspending its state so that, when the surrounding async context is re-polled, execution returns to step 2;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f8dad0e6e0ed1617e67254f63f3538d64e8eee" translate="yes" xml:space="preserve">
          <source>If the capacity overflows &lt;code&gt;usize&lt;/code&gt;, or the allocator reports a failure, then an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a413f73c6a00e8ec27d7656a64c0041d810a18fb" translate="yes" xml:space="preserve">
          <source>If the capacity overflows, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">如果容量溢出,或者分配器报告失败,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="d22b2ac0a0ad8bf3c9d2af95eda6c6dcbfb7f5e8" translate="yes" xml:space="preserve">
          <source>If the child has exited, then &lt;code&gt;Ok(Some(status))&lt;/code&gt; is returned. If the exit status is not available at this time then &lt;code&gt;Ok(None)&lt;/code&gt; is returned. If an error occurs, then that error is returned.</source>
          <target state="translated">如果孩子已经退出，则返回 &lt;code&gt;Ok(Some(status))&lt;/code&gt; 。如果此时退出状态不可用，则返回 &lt;code&gt;Ok(None)&lt;/code&gt; 。如果发生错误，则返回该错误。</target>
        </trans-unit>
        <trans-unit id="1f183ab05bb99521927fd36b3e847b7c523cd3b5" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11de405bba2eb95a67f5ddf98e8d367a826811a" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果子线程出现紧急情况，则使用指定给&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt;的参数返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="611996f7840618a761ac96c392b8f31568d8ec31" translate="yes" xml:space="preserve">
          <source>If the closure can't outlive the value being moved, try using a reference rather than moving:</source>
          <target state="translated">如果闭合不能超过被移动的值,可以尝试使用一个引用而不是移动。</target>
        </trans-unit>
        <trans-unit id="0f3013a1be5e1908d0fd59aee1eeb2a1559501d9" translate="yes" xml:space="preserve">
          <source>If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned.</source>
          <target state="translated">如果闭包返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt;，则返回该元素。</target>
        </trans-unit>
        <trans-unit id="1cc29c4e531aec77355dc3263edbde0e02717ace" translate="yes" xml:space="preserve">
          <source>If the closure returns true, the element is removed from the map and yielded. If the closure returns false, or panics, the element remains in the map and will not be yielded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb67b7c500cdec79f1ce3d7841c806209783608e" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">如果闭包返回true,那么该元素将被移除并产生。如果闭包返回false,则该元素将保留在列表中,不会被迭代器产生。</target>
        </trans-unit>
        <trans-unit id="6dd010d31dbb3764b4ed75ed86f6e32953c1d0d8" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the vector and will not be yielded by the iterator.</source>
          <target state="translated">如果闭包返回true,那么该元素将被移除并产生。如果闭包返回false,元素将保留在向量中,不会被迭代器产生。</target>
        </trans-unit>
        <trans-unit id="2a139e146ec9f48fd19a95af86148618a4801924" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the value is removed and yielded. If the closure returns false, the value will remain in the list and will not be yielded by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214ba23b863f161492d3f9635dec38066733211c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31dba64d7d22c597dfce03fd7cdb2b9f96c2ab94" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;[&lt;code&gt;&amp;amp;str&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt; with the corresponding [&lt;code&gt;&amp;amp;str&lt;/code&gt;] slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">如果 &lt;code&gt;CStr&lt;/code&gt; 的内容是有效的UTF-8数据，则此函数将返回&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt; 和相应的[ &lt;code&gt;&amp;amp;str&lt;/code&gt; ]切片。否则，它将用&lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt;替换所有无效的UTF-8序列，并返回带有结果的&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db9461413b5ee9b4f01c463f0ad906b75913f24c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">如果 &lt;code&gt;CStr&lt;/code&gt; 的内容是有效的UTF-8数据，则此函数将返回相应的&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;切片。否则，它将返回错误，并详细说明UTF-8验证失败的位置。</target>
        </trans-unit>
        <trans-unit id="baae7bb665c0286cfaf2cbea5e20bdf6cf34d67d" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99bd91603a025b03597fd1f9cbdd0b5e23a815bb" translate="yes" xml:space="preserve">
          <source>If the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; has disconnected, or it disconnects while this call is blocking, this call will wake up and return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.</source>
          <target state="translated">如果相应的&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;已断开连接，或者在此呼叫阻塞时断开了连接，则此呼叫将唤醒并返回&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt;以指示该通道上再也不会收到任何消息。但是，由于通道已缓冲，因此在断开连接之前发送的消息仍将正确接收。</target>
        </trans-unit>
        <trans-unit id="91ebc4eb9040370bb60e1b55cb245ed551a2b766" translate="yes" xml:space="preserve">
          <source>If the cursor is currently pointing to the &quot;ghost&quot; non-element then no element is removed and &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4624b3463b579ff38cd7090e939e0664781afc4a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the entire contents of the &lt;code&gt;LinkedList&lt;/code&gt; are moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d335a3b2bd9233a3fbdf7c96e469f75d1c5e365d" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31375a5dbf525938d61772845c72aab093fab9cf" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the front of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58963dd2948fd819f86fd5e461e02e99ecc3a20a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f945e6d3050ed5d918eb8a5e109487061da86ff" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the start of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9708432e377fc3315ff2743a227e5ee6ae976fb7" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a515e2eb729ab1875351c8ecfe7942b25cd004cc" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bf96ffdc655962850c81ce839b17c859f11a67" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825c50dec4e26dcdffad5ec9a6866af450b9f9e9" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9097bc3fc6399fb3bc83c93071781dffb279d65" translate="yes" xml:space="preserve">
          <source>If the data in this stream is &lt;em&gt;not&lt;/em&gt; valid UTF-8 then an error is returned and &lt;code&gt;buf&lt;/code&gt; is unchanged.</source>
          <target state="translated">如果此流中的数据&lt;em&gt;不是&lt;/em&gt;有效的UTF-8，则返回错误，并且 &lt;code&gt;buf&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="10754b248a576fdba9d5228dc71f26ade299f007" translate="yes" xml:space="preserve">
          <source>If the definition of &lt;code&gt;foo&lt;/code&gt; is under your control, the simplest solution is to capture the data mutably. This can be done by defining &lt;code&gt;foo&lt;/code&gt; to take FnMut rather than Fn:</source>
          <target state="translated">如果 &lt;code&gt;foo&lt;/code&gt; 的定义在您的控制之下，则最简单的解决方案是可变捕获数据。这可以通过将 &lt;code&gt;foo&lt;/code&gt; 定义为采用FnMut而不是Fn来完成：</target>
        </trans-unit>
        <trans-unit id="42bdc1ae118555b88ae881099abace5a191c0219" translate="yes" xml:space="preserve">
          <source>If the destination type is not part of the current crate then you can't implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; directly. For example, take this code:</source>
          <target state="translated">如果目标类型不属于当前包装箱，则不能直接实现&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;。例如，使用以下代码：</target>
        </trans-unit>
        <trans-unit id="587511482f256e8f952acfee186e5aefae6cf9ca" translate="yes" xml:space="preserve">
          <source>If the determination that the code is unreachable proves incorrect, the program immediately terminates with a &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果确定无法访问该代码是不正确的，则该程序会立即&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;终止！。</target>
        </trans-unit>
        <trans-unit id="4c5ab8621c8a741eb7e90c657432848573f050ef" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480ada98c1c5ece146ecdc077a3e40775d89fd0e" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果所需的迭代器元素类型未实现 &lt;code&gt;Clone&lt;/code&gt; ，或者不想将重复的元素保留在内存中，则可以使用&lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="156fcf0995b1088c12c501a80ad16ba6aab2c6f4" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5563e722ef79a66827ad237de3ff713088f72a" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;code&gt;Clone&lt;/code&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果您需要的迭代器的元素类型实现 &lt;code&gt;Clone&lt;/code&gt; ，并且可以将源元素保留在内存中，则应该使用&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="fdfbdf49a01ecb81ac4dd4acab163dbc68e7e8c0" translate="yes" xml:space="preserve">
          <source>If the environment variable is not defined, then a compilation error will be emitted. To not emit a compile error, use the &lt;a href=&quot;macro.option_env&quot;&gt;&lt;code&gt;option_env!&lt;/code&gt;&lt;/a&gt; macro instead.</source>
          <target state="translated">如果未定义环境变量，则将发出编译错误。&lt;a href=&quot;macro.option_env&quot;&gt; &lt;code&gt;option_env!&lt;/code&gt; &lt;/a&gt;产生编译错误，请使用option_env！宏代替。</target>
        </trans-unit>
        <trans-unit id="6e8972418288b27e60b8fafe88d7c99a7d59e984" translate="yes" xml:space="preserve">
          <source>If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link&amp;rsquo;s target.</source>
          <target state="translated">如果可执行文件是通过符号链接调用的，则某些平台将返回符号链接的路径，而其他平台将返回符号链接目标的路径。</target>
        </trans-unit>
        <trans-unit id="fd55e486394dd1866434bdc5faf39742bfb2a2d4" translate="yes" xml:space="preserve">
          <source>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</source>
          <target state="translated">如果这些胁迫位点中的一个表达是一个胁迫传播的表达,那么该表达中的相关子表达也是胁迫位点。传播从这些新的胁迫位点出发,反复进行。传播表达式及其相关的子表达式是:。</target>
        </trans-unit>
        <trans-unit id="da06749df21ae19d99c10837b4fef8698354acfb" translate="yes" xml:space="preserve">
          <source>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the &lt;code&gt;master&lt;/code&gt; branch behind a feature gate, as we discussed in the &lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;Unstable Features&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">如果该功能被接受，则将在Rust存储库上打开一个问题，并且有人可以实现它。实施得很好的人可能不是最初提出该功能的人！如我们在&lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;不稳定的功能&amp;rdquo;&lt;/a&gt;部分中所述，实现准备就绪后，它会落在功能门后面的 &lt;code&gt;master&lt;/code&gt; 分支上。</target>
        </trans-unit>
        <trans-unit id="3414a33407bd3dac73209f0f3c8c87238661b1ca" translate="yes" xml:space="preserve">
          <source>If the file already exists, any write calls on it will overwrite its contents, without truncating it.</source>
          <target state="translated">如果文件已经存在,对它的任何写入调用都会覆盖它的内容,而不会截断它。</target>
        </trans-unit>
        <trans-unit id="9132b3e3ab7219a34cb586c6f14321ce888d6773" translate="yes" xml:space="preserve">
          <source>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</source>
          <target state="translated">如果第一个元素被匹配,空分片将是迭代器返回的第一个项目。同样,如果分片中的最后一个元素被匹配,那么空分片将是迭代器返回的最后一个项目。</target>
        </trans-unit>
        <trans-unit id="a3fd11d96e62e4df934fdc1fa4662261ba86625c" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果给定容量为 &lt;code&gt;0&lt;/code&gt; ，则不会进行分配，并且此方法与&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法相同。</target>
        </trans-unit>
        <trans-unit id="c71e4086428a9289ae6841638f980514baf4e1e2" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;struct.string#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23f42fcc2aeb440c3d587979f6b3a221b95c0ef" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e650fcb37c79e73b248840291059fa9ab82facc" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;code&gt;Once&lt;/code&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">如果给定的闭包在同一&amp;ldquo; &lt;code&gt;Once&lt;/code&gt; 实例上递归调用 &lt;code&gt;call_once&lt;/code&gt; ，则未指定确切的行为，则允许的结果是恐慌或死锁。</target>
        </trans-unit>
        <trans-unit id="82cd743013a3edab20be44d34d8b246c9798bdd1" translate="yes" xml:space="preserve">
          <source>If the input isn't NaN, then there is no portability concern.</source>
          <target state="translated">如果输入的不是NaN,那么就不存在可移植性的问题。</target>
        </trans-unit>
        <trans-unit id="678a91cbb4ec06d73442b77832f91bad809fe51b" translate="yes" xml:space="preserve">
          <source>If the item is a function, you may use a closure:</source>
          <target state="translated">如果该项目是一个函数,你可以使用一个闭合。</target>
        </trans-unit>
        <trans-unit id="3955594d420a5299baca31b21b74e398d9cdcfd9" translate="yes" xml:space="preserve">
          <source>If the item is modified then the worst case time complexity is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)), otherwise it's &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e29e02642c9eb9601c44c59f05b7d126f43b3f4" translate="yes" xml:space="preserve">
          <source>If the item is not defined in the current module, it must be imported using a &lt;code&gt;use&lt;/code&gt; statement, like so:</source>
          <target state="translated">如果该项目未在当前模块中定义，则必须使用 &lt;code&gt;use&lt;/code&gt; 语句将其导入，如下所示：</target>
        </trans-unit>
        <trans-unit id="5030e30e9a190114fd41d37b0c1ba92d9eec8bbd" translate="yes" xml:space="preserve">
          <source>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., &lt;code&gt;pub fn&lt;/code&gt;).</source>
          <target state="translated">如果要导入的项目未在当前模块的某些超级模块中定义，则还必须将其声明为public（例如 &lt;code&gt;pub fn&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="719a1576fd9e7210e99462a559c7958169595ce7" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining elements will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d63a01b8d322a8870de0053bcaa4759ed12bae" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining values will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc64622999ffaef4c074c0b3f6d2b93d8dbc840b" translate="yes" xml:space="preserve">
          <source>If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice will be the last item returned by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e75edbffb14b1f9cbe211ae39152c93cbfb5b3" translate="yes" xml:space="preserve">
          <source>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2eb24f388c4f9da46dc55e06c2973845737ad4" translate="yes" xml:space="preserve">
          <source>If the length doesn't match, the input comes back in &lt;code&gt;Err&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f0b78af6a1f2b8da54724cc60c89fb090afb8c" translate="yes" xml:space="preserve">
          <source>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an &lt;code&gt;Arc&lt;/code&gt; to create a reference-counted value:</source>
          <target state="translated">如果引用的生存期不够，例如在使用线程的情况下，请考虑使用 &lt;code&gt;Arc&lt;/code&gt; 来创建引用计数的值：</target>
        </trans-unit>
        <trans-unit id="0e305a8484a9cd9dc5c8361f54c572219ec9804c" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.</source>
          <target state="translated">如果此时无法获取锁，则返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。否则，将返回RAII警卫。放下防护装置时，锁将解锁。</target>
        </trans-unit>
        <trans-unit id="f8b222d65f3e5a011a407bdb03d5df29adfec456" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the lock when it is dropped.</source>
          <target state="translated">如果此时无法获取锁，则返回 &lt;code&gt;Err&lt;/code&gt; 。否则，将返回RAII保护器，该保护器在被释放时将释放该锁。</target>
        </trans-unit>
        <trans-unit id="ecf781a8afe2a0c63a1d40b96befbc6c4dce088d" translate="yes" xml:space="preserve">
          <source>If the main thread panics it will terminate all your threads and end your program with code &lt;code&gt;101&lt;/code&gt;.</source>
          <target state="translated">如果主线程崩溃，它将终止所有线程并以代码 &lt;code&gt;101&lt;/code&gt; 结束程序。</target>
        </trans-unit>
        <trans-unit id="fedf3b811ad1f7726933bad19dd231acecc809fc" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96d894c9cb755e3982e02a5fa557e27c759b559" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">如果地图确实存在此键，则更新值，并返回旧值。但是，密钥不会更新。这对于可以 &lt;code&gt;==&lt;/code&gt; 但不相同的类型很重要。有关更多信息，请参见&lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a660d0d730c1d18357284ffbb42b24c56c1fea09" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果地图上没有此密钥，则返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22fc8ad8eb7527fa9d4557d1bcf87a2d2bd7edcb" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果地图上没有此密钥，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce6ece3326d8becac91cb49d0dcc5a346e703bba" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">如果地图上没有此密钥，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c00b93ea8ff90e66022ac61d150c9d932705572a" translate="yes" xml:space="preserve">
          <source>If the named environment variable is present at compile time, this will expand into an expression of type &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; whose value is &lt;code&gt;Some&lt;/code&gt; of the value of the environment variable. If the environment variable is not present, then this will expand to &lt;code&gt;None&lt;/code&gt;. See &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on this type.</source>
          <target state="translated">如果在编译时存在指定的环境变量，则它将扩展为 &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; 类型的表达式，其值是环境变量的 &lt;code&gt;Some&lt;/code&gt; 值。如果不存在环境变量，那么它将扩展为 &lt;code&gt;None&lt;/code&gt; 。有关此类型的更多信息，请参见&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6575b526f3c9f6ff8f51c0abc90eb128dc80c26" translate="yes" xml:space="preserve">
          <source>If the number of elements in the pattern doesn&amp;rsquo;t match the number of elements in the tuple, the overall type won&amp;rsquo;t match and we&amp;rsquo;ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&amp;rsquo;t work.</source>
          <target state="translated">如果模式中的元素数量与元组中的元素数量不匹配，则整体类型将不匹配，并且会出现编译器错误。例如，清单18-5展示了将三个元素的元组分解为两个变量的尝试，但这种方法无效。</target>
        </trans-unit>
        <trans-unit id="0d2c1202b42295052cad83d3a70ac58e5c8cc86e" translate="yes" xml:space="preserve">
          <source>If the number of hardware threads is not known for the target platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f255ea3f66f81885c9b2fd50418cdf94440a9b" translate="yes" xml:space="preserve">
          <source>If the number of nanoseconds is greater than 1 billion (the number of nanoseconds in a second), then it will carry over into the seconds provided.</source>
          <target state="translated">如果纳秒数大于10亿(一秒内的纳秒数),则会延续到提供的秒数中。</target>
        </trans-unit>
        <trans-unit id="c7b893dcc899fca09569911e017ff49f116f8bab" translate="yes" xml:space="preserve">
          <source>If the option already contains a value, the old value is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7587948fbc56d5936df283dc95c30a87905bc378" translate="yes" xml:space="preserve">
          <source>If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.</source>
          <target state="translated">如果路径是普通文件,这是文件名。如果是目录的路径,这是目录名。</target>
        </trans-unit>
        <trans-unit id="a7ef120bc4e6081962026d321af347e6c4f9a831" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatch_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;#method.rmatch_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="04680e781abdf689365df53a980b052d9694289c" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;#method.rmatches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="fdde1b4f273f0ed1e791a6fe885f57ab847c6655" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7628f0f92ea01c70ac165a6fae25950d70760fc1" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果该模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7b1dfc3434853d3f01995d02cf2021fd9cea4f38" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2b2d41067456cd5ce092b8da0d00cd9c018667" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa780fe3ad5330a6d715d8c1d30bd41ddfacfc03" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8ae88e59c6bfa2a36b4a334a350ee9f55b8244" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcaec8982083667c5c84f44fc799e4d051fed01" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c97ecf08e8a57f300f06fbed8336fddc8673ad" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3f51e25e82602ab5224623c59019342d6d26f3" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ae87480dd359d1fa21ebc1f6510a38a90b5d25" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eda760b5bfe240d7c8b8f222a4d4b7100d666e" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，则可以使用&lt;a href=&quot;#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">如果谓词为true，则将事物重写为不具有 &lt;code&gt;cfg&lt;/code&gt; 属性。如果谓词为假，则事物将从源代码中删除。</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">如果进程被一个信号终止,则返回该信号。</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">如果程序上下文过度限制类型,则认为是静态类型错误。</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">如果程序上下文对类型的约束不足，则默认为 &lt;code&gt;f64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">如果程序上下文对类型的约束不足，则默认为带符号的32位整数 &lt;code&gt;i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">如果程序路径是相对的（例如 &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ），则是相对于父级的工作目录还是相对于 &lt;code&gt;current_dir&lt;/code&gt; 来解释路径。这种情况下的行为是特定于平台且不稳定的，因此建议使用&lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt;来获取绝对程序路径。</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果提供的值为&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">如果接收器的类型为 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; ，则将对 &lt;code&gt;Self&lt;/code&gt; 的引用的生存期分配给所有省略的输出生存期参数。</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">如果重复次数可以匹配零次（ &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; ），则后面的内容必须能够跟随之前的内容。</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">如果重复可以重复多次（ &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; ），则内容必须能够跟随自己。</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">如果重复包括一个分隔符,该分隔符必须能够跟随重复的内容。</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">如果这个方法的结果只是由产生它们的同一个架构来操作,那么就不存在可移植性问题。</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">如果返回值为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; ,&lt;/a&gt;则必须保证 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 。返回值 &lt;code&gt;0&lt;/code&gt; 通常表示基础对象不再能够接受字节，将来也可能无法接受字节，或者提供的缓冲区为空。</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">如果此方法的返回值为&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt;，则必须保证 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 。 &lt;code&gt;n&lt;/code&gt; 值非零表示缓冲区 &lt;code&gt;buf&lt;/code&gt; 已被来自该源的 &lt;code&gt;n&lt;/code&gt; 个字节的数据填充。如果 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则可以指示以下两种情况之一：</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果查找操作成功完成，则此方法从流的开头返回新位置。该位置可以稍后与&lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">如果集合确实存在此值，则返回 &lt;code&gt;false&lt;/code&gt; ，并且不会更新该条目。有关更多信息，请参见&lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果集合确实存在此值，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果集合中不存在该值，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f392e4742f25190cbf5e3351752daf379a0be61" translate="yes" xml:space="preserve">
          <source>If the slice does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43a87008e53f4a6466f036fda4975d20f3ad011" translate="yes" xml:space="preserve">
          <source>If the slice does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad3d774a6e0ccaa727d17e721cc10badd0ba8e6" translate="yes" xml:space="preserve">
          <source>If the slice ends with &lt;code&gt;suffix&lt;/code&gt;, returns the subslice before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;suffix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">如果切片比 &lt;code&gt;size&lt;/code&gt; 短：</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">如果分片是排序的,则第一个返回的分片不包含重复的内容。</target>
        </trans-unit>
        <trans-unit id="c27d8278e5200cca20b3d013d5698cf10c18fe2f" translate="yes" xml:space="preserve">
          <source>If the slice starts with &lt;code&gt;prefix&lt;/code&gt;, returns the subslice after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;prefix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">如果未连接套接字，则将返回&lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果源和目标&lt;em&gt;永远不会&lt;/em&gt;重叠，&lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt;可以使用copy_nonoverlapping。</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00699a6c688425007189014e64bb10c087e7cc42" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c5d3aa960799aefa6afdc31361ee8f07d50151" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e6ef23293e24078530c7881fe300a2cd50dbd2" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, returns the substring before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2971983ae4e5fda25d513b0c8f02476f9d89865" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, returns substring after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">如果超时为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">如果超时为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">如果特征 &lt;code&gt;Foo&lt;/code&gt; 源自 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; （其中 &lt;code&gt;Foo&lt;/code&gt; 本身是 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; ），那么这是可以的，因为给定类型 &lt;code&gt;get_a()&lt;/code&gt; 肯定会返回该类型的对象。</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">如果特征没有生存期边界，则生存期可以在表达式中推断出来，并且在表达式之外是 &lt;code&gt;'static&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">如果特征是用单个生存期&lt;em&gt;绑定&lt;/em&gt;定义的，则使用该绑定。</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">如果特质对象被用作通用类型的类型参数,那么首先使用包含的类型来尝试推断一个约束。</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">如果指定了 &lt;code&gt;self&lt;/code&gt; 参数的类型，则限于以下类型之一：</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">如果错误地包含了类型参数,可以通过简单地删除类型参数来解决这个错误,如下图所示。</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">如果基础数据是&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt;应改为使用。</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">如果基础数据是 &lt;code&gt;Unpin&lt;/code&gt; ， &lt;code&gt;Pin::get_mut&lt;/code&gt; 应改为使用。</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">如果底层文件系统不支持创建时间,返回值为0。</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">如果底层文件系统不支持最后访问时间,则返回值为0。</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">如果底层文件系统不支持最后一次写入时间,返回值为0。</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">如果用户指定了一个喜欢的颜色,这个颜色就是背景色。如果今天是星期二,背景色就是绿色。如果用户将自己的年龄指定为一个字符串,并且我们可以成功地将其解析为一个数字,那么根据数字的值,颜色是紫色或橙色。如果这些条件都不适用,则背景色为蓝色。</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">如果用户想要进行高强度的锻炼，则还有一些其他逻辑：如果应用程序生成的随机数的值恰好为3，则该应用程序将建议您休息和补水。否则，用户将基于复杂算法获得几分钟的运行时间。</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">如果必须先借入价值,然后再移动,可以尝试使用scoped block来限制借入的寿命。</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">如果该值必须被借用,可以尝试使用scoped block限制借用的寿命。</target>
        </trans-unit>
        <trans-unit id="f9c557d25b585efde62c6ddbcee6fee7ec33bf65" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">如果找到该值，则返回&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，其中包含匹配元素的索引。如果有多个匹配项，则可以返回任何一个匹配项。如果未找到该值，则返回&lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;，其中包含在保留排序顺序的同时可以在其中插入匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">如果找到该值，则返回&lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;，其中包含匹配元素的索引。如果有多个匹配项，则可以返回任何一个匹配项。如果未找到该值，则返回&lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;，其中包含在保留排序顺序的同时可以在其中插入匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果指定的值为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">如果指定的值为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用将无限期阻塞。一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法。</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">如果该值将在模式卫士中消耗,使用它的克隆不会移动它的所有权,所以代码有效。</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">如果向量是排序的,则会删除所有重复的内容。</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">如果没有其他指向该值的 &lt;code&gt;Rc&lt;/code&gt; 指针，则该值的&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针将被取消关联。</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">如果还有其他指向同一值的 &lt;code&gt;Arc&lt;/code&gt; 或&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针，那么 &lt;code&gt;make_mut&lt;/code&gt; 将在内部值上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;以确保唯一的所有权。这也称为写时克隆。</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">如果还有其他 &lt;code&gt;Rc&lt;/code&gt; 指针指向相同的值，那么 &lt;code&gt;make_mut&lt;/code&gt; 将&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;内部值以确保唯一的所有权。这也称为写时克隆。</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">如果此条件变量上有阻塞的线程，则它将从其调用&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt;唤醒。不会以任何方式缓冲对 &lt;code&gt;notify_one&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">如果有一个来自包含类型的唯一绑定,那么这就是默认的</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">如果参数中恰好使用了一个寿命（是否消除），则将该寿命分配给&lt;em&gt;所有&lt;/em&gt;消除的输出寿命。</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">如果有多个来自包含类型的绑定,那么必须指定一个显式绑定。</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">如果没有数据附加到枚举的&lt;em&gt;任何&lt;/em&gt;变体，则可以直接选择和访问判别式。</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">如果在 &lt;code&gt;LineWriter&lt;/code&gt; 时缓冲区中仍然有部分行，它将刷新这些内容。</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Error&lt;/code&gt; 是通过 &lt;code&gt;last_os_error&lt;/code&gt; 或 &lt;code&gt;from_raw_os_error&lt;/code&gt; 构造的，则此函数将返回 &lt;code&gt;Some&lt;/code&gt; ，否则将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Error&lt;/code&gt; 是通过 &lt;code&gt;new&lt;/code&gt; 构造的，则此函数将返回 &lt;code&gt;Some&lt;/code&gt; ，否则将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">如果本章引起了您的兴趣，并且您想实现自己的智能指针，请查看&lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo; The Rustonomicon&amp;rdquo;&lt;/a&gt;以获取更多有用的信息。</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">如果此函数在完全填充缓冲区之前遇到&amp;ldquo;文件末尾&amp;rdquo;，它将返回&lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;类型的错误。在这种情况下，未指定 &lt;code&gt;buf&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">如果此函数在完全填充缓冲区之前遇到&amp;ldquo;文件末尾&amp;rdquo;，它将返回&lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;类型的错误。在这种情况下，未指定 &lt;code&gt;buf&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">如果此函数遇到类型为&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;的错误，则将忽略该错误，并且该操作将继续。</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">如果此函数遇到类型为&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;的错误，则将忽略该错误，并且该操作将继续。</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">如果这个函数遇到任何形式的I/O或其他错误,将返回一个错误变量。如果返回一个错误,那么必须保证没有读取任何字节。</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">如果此函数返回 &lt;code&gt;Ok(0)&lt;/code&gt; ，则流已达到EOF。</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">如果该函数返回错误,则未说明它读取了多少字节,但它读取的字节数绝不会超过完全填满缓冲区所需的数量。</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">如果这是一个缓冲通道，则此时缓冲区已满。如果这不是缓冲通道，则没有&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;可用于获取数据。</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">如果这不是一个选择，请考虑将type参数替换为另一个特征对象（例如，如果 &lt;code&gt;T: OtherTrait&lt;/code&gt; ，请使用 &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; ）。如果打算提供给该方法的类型数量有限，请考虑手动列出不同类型的方法。</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">如果你是第一次来,标准库的文档是写给你随意浏览的。点击有趣的东西,一般来说应该会把你带到有趣的地方。不过,有些重要的部分你还是不要错过,所以请继续阅读标准库和它的文档之旅吧!</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">如果此方法返回 &lt;code&gt;Err&lt;/code&gt; ，则该存储块的所有权尚未转移到此分配器，并且该存储块的内容不会更改。</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">如果此方法返回 &lt;code&gt;Ok(addr)&lt;/code&gt; ，则返回的 &lt;code&gt;addr&lt;/code&gt; 将是非空地址，该地址指向适合于保存 &lt;code&gt;layout&lt;/code&gt; 实例的存储块。</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">如果这个方法返回null,那么内存块的所有权还没有转移到这个分配器上,内存块的内容没有被改变。</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">如果这导致多个可能的候选者，那么这是一个错误，并且必须将接收方&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;转换&lt;/a&gt;为适当的接收方类型以进行方法调用。</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">如果返回 &lt;code&gt;Err&lt;/code&gt; ，则认为该存储块仍表示原始（较大） &lt;code&gt;layout&lt;/code&gt; 。没有一个块被分割出来供其他地方重用，该存储块的所有权尚未转移，并且该存储块的内容未更改。</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">如果返回 &lt;code&gt;Ok&lt;/code&gt; ，则 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块的所有权已转移到此分配器。内存可能已释放，也可能尚未释放，应被视为不可用（除非通过此方法的返回值再次将其转移回调用方）。</target>
        </trans-unit>
        <trans-unit id="d418fdb16ac3dec6f2998c32246199d93bd8ccd1" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">如果返回 &lt;code&gt;Ok&lt;/code&gt; ，则分配器断言 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块现在适合 &lt;code&gt;new_size&lt;/code&gt; ，因此可用于承载具有该大小且与 &lt;code&gt;layout&lt;/code&gt; 对齐的布局数据。（允许分配器花费更多的精力来完成此任务，例如将内存块扩展为包括后继块或虚拟内存技巧。）</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">如果返回 &lt;code&gt;Ok&lt;/code&gt; ，则分配器断言 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块现在适合 &lt;code&gt;new_size&lt;/code&gt; ，因此只能用于承载较小布局的数据。（允许分配器利用这一点，将块的一部分切掉，以便在其他地方重用。）较小布局中的块的截断内容未更改，并且块的所有权尚未转移。</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">如果返回非空指针，则 &lt;code&gt;ptr&lt;/code&gt; 引用的内存块的所有权已转移到此分配器。内存可能已释放，也可能尚未释放，应将其视为不可用的（除非当然已通过此方法的返回值再次将其转移回调用方）。</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果使用此语法，&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;打印的字符数要在要格式化的实际对象之前，并且字符数必须具有类型usize。</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">如果两个匹配的元素直接相邻,则它们之间会出现一个空片。</target>
        </trans-unit>
        <trans-unit id="aba72b6261d8cf54f8817ecf4602e9f657125528" translate="yes" xml:space="preserve">
          <source>If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">如果我们&lt;em&gt;确实&lt;/em&gt;想深入复制 &lt;code&gt;String&lt;/code&gt; 的堆数据，而不仅仅是堆栈数据，则可以使用一种称为 &lt;code&gt;clone&lt;/code&gt; 的通用方法。我们将在第5章中讨论方法语法，但是由于方法是许多编程语言中的常见功能，因此您以前可能已经看过它们。</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">如果我们现在编译此代码，则会收到此错误：</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">如果我们继续阅读错误，则会发现以下有用的注释：</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">如果我们控制类型的定义，则可以使用 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 在其上实现 &lt;code&gt;Clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">如果我们不在此处添加类型注释，Rust将显示以下错误，这意味着编译器需要我们提供更多信息来了解我们要使用的类型：</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">如果我们不想将 &lt;code&gt;largest&lt;/code&gt; 函数限制为实现 &lt;code&gt;Copy&lt;/code&gt; 特征的类型，则可以指定 &lt;code&gt;T&lt;/code&gt; 具有绑定 &lt;code&gt;Clone&lt;/code&gt; 的特征，而不是 &lt;code&gt;Copy&lt;/code&gt; 。然后，当我们希望 &lt;code&gt;largest&lt;/code&gt; 函数拥有所有权时，我们可以克隆切片中的每个值。使用 &lt;code&gt;clone&lt;/code&gt; 函数意味着，在拥有堆数据（如 &lt;code&gt;String&lt;/code&gt; )的类型的情况下，我们可能会进行更多的堆分配，如果处理大量数据，堆分配可能会很慢。</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">如果我们忘记了生命周期批注并尝试编译此函数，则会收到此错误：</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">如果我们获得了互斥锁，则调用 &lt;code&gt;recv&lt;/code&gt; 以从通道接收 &lt;code&gt;Job&lt;/code&gt; 。最终的 &lt;code&gt;unwrap&lt;/code&gt; 将移过所有错误，如果保留通道发送方的线程已关闭，则可能会发生错误，类似于在接收方关闭时 &lt;code&gt;send&lt;/code&gt; 方法返回 &lt;code&gt;Err&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">如果我们没有在程序开始时列出 &lt;code&gt;use std::io&lt;/code&gt; 行，则可以将此函数调用编写为 &lt;code&gt;std::io::stdin&lt;/code&gt; 。的 &lt;code&gt;stdin&lt;/code&gt; 函数返回的一个实例&lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt;，这是表示一个把手为您的终端标准输入一个类型。</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">如果我们有更复杂的键，则调用 &lt;code&gt;insert&lt;/code&gt; 不会更新键的值。例如：</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个 &lt;code&gt;String&lt;/code&gt; ，我们可以传递整个 &lt;code&gt;String&lt;/code&gt; 的一部分。定义一个函数以采用字符串切片而不是对 &lt;code&gt;String&lt;/code&gt; 的引用使我们的API更通用和有用，而不会丢失任何功能：</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">如果我们将一个键和一个值插入到哈希图中，然后将相同的键插入一个不同的值，则与该键关联的值将被替换。即使清单8-24中的代码两次 &lt;code&gt;insert&lt;/code&gt; ，哈希表也将只包含一个键/值对，因为我们两次都插入了Blue团队键的值。</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">如果我们将对值的引用插入到哈希图中，则这些值将不会移入哈希图中。引用所指向的值必须至少在哈希映射有效期间才有效。我们将在第10章的&lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;使用生命周期验证参考&amp;rdquo;&lt;/a&gt;部分中详细讨论这些问题。</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">如果我们看一下Devanagari脚本中写的北印度语单词&amp;ldquo;नमस्غे&amp;rdquo;，它会存储为 &lt;code&gt;u8&lt;/code&gt; 值的向量，如下所示：</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">如果需要连接多个字符串，则 &lt;code&gt;+&lt;/code&gt; 运算符的行为会变得笨拙：</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">如果我们在不传递任何参数的情况下运行测试,就像我们前面看到的那样,所有的测试都会并行运行。</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">如果我们在没有&lt;em&gt;hello.txt&lt;/em&gt;文件的情况下运行此代码，则会从 &lt;code&gt;panic!&lt;/code&gt; 看到错误消息！调用 &lt;code&gt;unwrap&lt;/code&gt; 方法使：</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">如果我们运行这段代码,我们会得到这样的错误信息。</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">如果我们在调用 &lt;code&gt;takes_ownership&lt;/code&gt; 之后尝试使用 &lt;code&gt;s&lt;/code&gt; ，Rust会抛出编译时错误。这些静态检查可以防止我们犯错误。尝试将代码添加到使用 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;main&lt;/code&gt; 中，以查看可以在何处使用它们以及所有权规则阻止您这样做。</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">如果我们试图写 &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; 相反，我们会收到以下编译错误：</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">如果尝试在作用域结束后访问 &lt;code&gt;leaf&lt;/code&gt; 的父级，则将再次获得 &lt;code&gt;None&lt;/code&gt; 。在程序结束时， &lt;code&gt;leaf&lt;/code&gt; 的 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 的强计数为1，而弱计数为0，因为变量 &lt;code&gt;leaf&lt;/code&gt; 现在再次是对 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 的唯一引用。</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">如果尝试通过修改清单15-14中的 &lt;code&gt;main&lt;/code&gt; 函数来手动调用 &lt;code&gt;Drop&lt;/code&gt; trait的 &lt;code&gt;drop&lt;/code&gt; 方法，如清单15-15所示，则会出现编译器错误：</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">如果我们尝试编译清单15-3中的代码,得到清单15-4所示的错误。</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">如果我们尝试实现清单10-21所示的 &lt;code&gt;longest&lt;/code&gt; 函数，它将无法编译。</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">如果我们试图违反这些规则，而不是像使用引用那样遇到编译器错误，则 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 的实现将在运行时出现恐慌。清单15-23显示了清单15-22 中 &lt;code&gt;send&lt;/code&gt; 的实现的修改。我们故意尝试为同一作用域创建两个活动的活动借位，以说明 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 阻止我们在运行时执行此操作。</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">如果我们使用 &lt;code&gt;None&lt;/code&gt; 而不是 &lt;code&gt;Some&lt;/code&gt; ，则需要告诉Rust 我们拥有哪种 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 类型，因为编译器无法通过仅查看 &lt;code&gt;None&lt;/code&gt; 值来推断 &lt;code&gt;Some&lt;/code&gt; 变量将持有的类型。</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">如果我们要依次访问向量中的每个元素，则可以遍历所有元素，而不必一次使用索引来访问一个。清单8-8显示了如何使用 &lt;code&gt;for&lt;/code&gt; 循环获取对 &lt;code&gt;i32&lt;/code&gt; 值向量中每个元素的不可变引用并进行打印。</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">如果要将路径中定义的&lt;em&gt;所有&lt;/em&gt;公共项目&lt;em&gt;都&lt;/em&gt;纳入范围，可以指定该路径，后跟 &lt;code&gt;*&lt;/code&gt; ，即glob运算符：</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">如果我们也想查看通过测试的打印值，则可以使用 &lt;code&gt;--nocapture&lt;/code&gt; 标志来禁用输出捕获行为：</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">如果我们希望此函数允许 &lt;code&gt;item1&lt;/code&gt; 和 &lt;code&gt;item2&lt;/code&gt; 具有不同的类型，则使用 &lt;code&gt;impl Trait&lt;/code&gt; 是合适的（只要这两种类型都实现 &lt;code&gt;Summary&lt;/code&gt; ）。如果我们想强制两个参数具有相同的类型，则只能使用特征绑定来表示，如下所示：</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">如果我们想忽略元组中的一个或多个值，可以使用 &lt;code&gt;_&lt;/code&gt; 或 &lt;code&gt;..&lt;/code&gt; ，您将在&lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;忽略模式中的值&amp;rdquo;&lt;/a&gt;部分中看到。如果问题在于模式中的变量太多，则解决方案是通过删除变量来使类型匹配，以便变量的数量等于元组中的元素数量。</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">如果允许我们运行此代码，则有可能将生成的线程立即放在后台而根本不运行。生成的线程内部引用了 &lt;code&gt;v&lt;/code&gt; ，但是主线程使用我们在第15章中讨论的 &lt;code&gt;drop&lt;/code&gt; 函数立即删除了 &lt;code&gt;v&lt;/code&gt; 。然后，当生成的线程开始执行时， &lt;code&gt;v&lt;/code&gt; 不再有效，因此对其的引用为也无效。不好了！</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">如果我们调用 &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; ， &lt;code&gt;coin&lt;/code&gt; 将是 &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; 。当我们将该值与每个匹配臂进行比较时，直到我们到达 &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; 之前，它们都不匹配。那时， &lt;code&gt;state&lt;/code&gt; 的绑定将是值 &lt;code&gt;UsState::Alaska&lt;/code&gt; 。然后，我们可以在 &lt;code&gt;println!&lt;/code&gt; 使用该绑定！表达式，从而从 &lt;code&gt;Quarter&lt;/code&gt; 的 &lt;code&gt;Coin&lt;/code&gt; 枚举变量中获取内部状态值。</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">如果要创建一个不使用状态模式的替代实现，则可以在 &lt;code&gt;Post&lt;/code&gt; 的方法中甚至在检查Post的状态并更改这些位置的行为的 &lt;code&gt;main&lt;/code&gt; 代码中使用 &lt;code&gt;match&lt;/code&gt; 表达式。这意味着我们将不得不在多个地方查看以了解帖子处于已发布状态的所有含义！这只会增加我们添加的更多状态：每个 &lt;code&gt;match&lt;/code&gt; 表达式都需要另一个分支。</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">如果我们使用在同一个程序包或同一个模块中定义的多个项目，则将每个项目单独列出会在我们的文件中占用很多垂直空间。例如，我们在Guessing Game清单2-4中具有的这两个 &lt;code&gt;use&lt;/code&gt; 语句将 &lt;code&gt;std&lt;/code&gt; 中的项目带入范围：</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">如果您&lt;em&gt;确实&lt;/em&gt;在Rust中编写了该代码，则编译器会向您发出警告（默认情况下，此值由未使用的 &lt;code&gt;unused_must_use&lt;/code&gt; lint 控制）。</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">如果你已经知道你要找的东西的名字,最快的方法是使用页面顶部的搜索栏来查找。</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要定义自己的智能指针类型，并希望使用&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST强制系统&lt;/a&gt;从大小转换为未大小转换，请改用&lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">如果您善于考虑类型，则可以这样考虑 &lt;code&gt;map()&lt;/code&gt; ：如果您有一个迭代器为您提供了一些类型 &lt;code&gt;A&lt;/code&gt; 的元素，并且您想要一个其他类型为 &lt;code&gt;B&lt;/code&gt; 的迭代器，则可以使用 &lt;code&gt;map()&lt;/code&gt; ，传递一个采用 &lt;code&gt;A&lt;/code&gt; 并返回 &lt;code&gt;B&lt;/code&gt; 的闭包。</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">如果您确定字节片是有效的UTF-8，并且不想增加转换的开销，则此函数有一个不安全的版本&lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;，它具有相同的行为，但是会跳过检查。</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">如果您确定字节片是有效的UTF-8，并且不想引起有效性检查的开销，则此函数有一个不安全的版本&lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;，它具有相同的行为，但是会跳过该检查。</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">如果您确定字节片是有效的UTF-8，并且不想引起有效性检查的开销，则此函数有一个不安全的版本&lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;，它具有相同的行为，但是会跳过该检查。</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">如果您确定指针永远不会为空，并且正在寻找某种类型的 &lt;code&gt;as_ref_unchecked&lt;/code&gt; 来返回 &lt;code&gt;&amp;amp;T&lt;/code&gt; 而不是 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ，请知道您可以直接取消引用该指针。</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">如果你正在使用速记字段模式,但想用不同的名称来引用结构字段,你应该明确地重命名它。</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">如果你正在编写一个将处理现有文件格式的程序,在使用这个函数之前,请检查该格式对whitespace的定义是什么。</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果由于权限错误而无法访问包含文件的目录，则将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">如果您不能使用 &lt;code&gt;derive&lt;/code&gt; 策略，请指定您的类型实现 &lt;code&gt;Eq&lt;/code&gt; ，该方法没有方法：</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">如果您创建一个生命周期为 &lt;code&gt;'a&lt;/code&gt; 的安全引用（ &lt;code&gt;&amp;amp;T&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 引用），并且可以通过安全代码访问（例如，因为返回了它），那么您不得以任何与该引用冲突的方式访问数据 &lt;code&gt;'a&lt;/code&gt; 的其余部分。例如，这意味着，如果你把 &lt;code&gt;*mut T&lt;/code&gt; 从 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 并将其投射到一个 &lt;code&gt;&amp;amp;T&lt;/code&gt; ，则在数据 &lt;code&gt;T&lt;/code&gt; 必须保持不变（模任何 &lt;code&gt;UnsafeCell&lt;/code&gt; 内的数据发现 &lt;code&gt;T&lt;/code&gt; ，当然），直到该参考的寿命到期。同样，如果您创建 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 释放给安全代码的引用，那么在该引用过期之前，您不得访问 &lt;code&gt;UnsafeCell&lt;/code&gt; 中的数据。</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">如果创建变量但不在任何地方使用，Rust通常会发出警告，因为这可能是一个错误。但是有时创建一个尚未使用的变量很有用，例如在进行原型设计或刚开始一个项目时。在这种情况下，可以通过用下划线开头变量的名称来告诉Rust不要警告您未使用的变量。在清单18-20中，我们创建了两个未使用的变量，但是在运行此代码时，我们应该只收到关于其中一个的警告。</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果您不希望这种&amp;ldquo;至少&amp;rdquo;行为，请参见&lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">如果您不调用 &lt;code&gt;expect&lt;/code&gt; ，该程序将编译，但是您会收到警告：</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">如果您不想并行运行测试，或者想要对使用的线程数进行更细粒度的控制，则可以将 &lt;code&gt;--test-threads&lt;/code&gt; 标志和要使用的线程数发送给测试二进制 看下面的例子：</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">如果你不在乎信号性(很有可能),那么就不存在便携性的问题。</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">如果你不知道Rust的基础知识,可以去找Rust书来入门:https://doc.rust-lang.org/book/。</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">如果您没有限定名称，那么代码将绑定名为&amp;ldquo; GET&amp;rdquo;和&amp;ldquo; POST&amp;rdquo;的新变量。这种行为可能不是您想要的，因此 &lt;code&gt;rustc&lt;/code&gt; 在发生这种情况时会发出警告。</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">如果遇到此错误，则必须更改模式，以便匹配输入类型的每个可能值。对于具有少量变体的类型（例如枚举），您可能应该明确涵盖所有情况。或者，可以在所有其他模式之后添加下划线 &lt;code&gt;_&lt;/code&gt; 通配符模式以匹配&amp;ldquo;其他&amp;rdquo;。例：</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">如果遇到此错误，则可能需要使用 &lt;code&gt;match&lt;/code&gt; 或者 &lt;code&gt;if let&lt;/code&gt; 处理失败的可能性。例：</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">如果您具有C或C ++背景，则会注意到这与 &lt;code&gt;gcc&lt;/code&gt; 或 &lt;code&gt;clang&lt;/code&gt; 相似。成功编译后，Rust输出二进制可执行文件。</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">如果您有一个&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;的列表，则可以使用 &lt;code&gt;collect()&lt;/code&gt; 来查看它们是否失败：</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">如果您具有引用 &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; ，则通常在Rust中 &lt;code&gt;SomeStruct&lt;/code&gt; 的所有字段都是不可变的。编译器基于以下知识进行优化： &lt;code&gt;&amp;amp;T&lt;/code&gt; 没有可变别名或突变，并且 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 是唯一的。 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 是唯一可以解决此限制的核心语言功能。所有其他允许内部可变的类型，例如 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，都使用 &lt;code&gt;UnsafeCell&lt;/code&gt; 来包装其内部数据。</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">如果您的程序中的逻辑过于冗长而无法使用 &lt;code&gt;match&lt;/code&gt; 来表达，请记住，Rust工具箱中也包含 &lt;code&gt;if let&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">如果您有一个UTF-8字节的向量，则可以使用&lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;方法从中创建一个 &lt;code&gt;String&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">如果您有一个有效UTF-8字节的向量，则可以使用它制作一个&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。您也可以相反。</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您拥有该容器的所有权，则可以改用&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您拥有该值的所有权，则可以改用&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">如果您具有实现&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; 的功能&lt;/a&gt;，则可以使用&lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; 类型&lt;/a&gt;将其转换为 &lt;code&gt;BufRead&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">如果您立即重新运行 &lt;code&gt;cargo build&lt;/code&gt; 而没有进行任何更改，则除了&amp;ldquo; &lt;code&gt;Finished&lt;/code&gt; 行以外，您将不会获得任何输出。Cargo知道它已经下载并编译了依赖项，并且您在&lt;em&gt;Cargo.toml&lt;/em&gt;文件中没有更改任何&lt;em&gt;相关性&lt;/em&gt;。Cargo还知道您没有对代码进行任何更改，因此也不会重新编译。无事可做，它只是退出。</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;而不是 &lt;code&gt;String&lt;/code&gt; ，请考虑&lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您需要&lt;em&gt;带有&lt;/em&gt; nul终止符的 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;，&lt;/em&gt;则可以使用&lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要 &lt;code&gt;String&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，请考虑&lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的引用，该引用可能比 &lt;code&gt;Entry&lt;/code&gt; 值的销毁更&lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;，请参阅into_mut。</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的引用，该引用可能会比 &lt;code&gt;Entry&lt;/code&gt; 值的破坏更&lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;，请参阅into_mut。</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">如果您需要对值的散列方式进行更多控制，则当然可以自己实现 &lt;code&gt;Hash&lt;/code&gt; 特征：</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">如果需要更多控制值散列的方式，则需要实现&lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性：</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要对 &lt;code&gt;OccupiedEntry&lt;/code&gt; 的多个引用，请参见&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">如果你需要该功能,请确保使用夜间发布的编译器(但要注意该功能可能在未来被删除或更改)。</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">如果你需要这个,你很有可能做错了什么。请记住,Rust并不能保证不同结构的布局(即使是两个具有相同声明的结构也可能有不同的布局)。如果有一种解决方案可以完全避免transmute,可以试试。</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">如果您需要获取&lt;em&gt;许多&lt;/em&gt;流的长度，并且以后不再关心查找位置，则可以通过简单地调用 &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; 并使用其返回值（它来减少查找操作的数量）也是流的长度）。</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">如果需要对单个Unicode标量值执行操作，最好的方法是使用 &lt;code&gt;chars&lt;/code&gt; 方法。在&amp;ldquo;नमस्غे&amp;rdquo;上调用 &lt;code&gt;chars&lt;/code&gt; 分离出并返回 &lt;code&gt;char&lt;/code&gt; 类型的六个值，您可以遍历结果以访问每个元素：</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">如果你只想导入命名空间,就直接导入。</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">如果打开&lt;em&gt;src / main.rs&lt;/em&gt;文件，进行小改动，然后保存并再次构建，则只会看到两行输出：</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">如果你愿意,可以随时下载该脚本,并在运行前检查它。</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">如果将工作箱中的板条箱发布到&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;，则工作区中的每个板条箱都需要单独发布。该 &lt;code&gt;cargo publish&lt;/code&gt; 命令没有一个 &lt;code&gt;--all&lt;/code&gt; 标志或 &lt;code&gt;-p&lt;/code&gt; 标志，所以你必须改变每个箱子的目录并运行 &lt;code&gt;cargo publish&lt;/code&gt; 工作区中的每个箱子发布的板条箱。</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">如果您确实想要全局可变状态，请尝试使用 &lt;code&gt;static mut&lt;/code&gt; 或全局 &lt;code&gt;UnsafeCell&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">如果运行此代码并且仅看到主线程的输出，或者看不到任何重叠，请尝试增加范围内的数字，以为操作系统创造更多机会在线程之间进行切换。</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">如果看到版本号，就知道了！如果看到错误（例如 &lt;code&gt;command not found&lt;/code&gt; ，请查看您的安装方法文档，以确定如何分别安装Cargo。</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">如果您看到此信息，则说明您已成功安装Rust！如果您没有看到此信息，并且在Windows上，请检查Rust是否在 &lt;code&gt;%PATH%&lt;/code&gt; 系统变量中。如果一切正确，但Rust仍然无法正常工作，您可以在许多地方获得帮助。最简单的是&lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;官方Rust Discord&lt;/a&gt;上的#beginners频道。在这里，您可以与其他可以帮助您的Rustaceans（我们称为自己的傻昵称）聊天。其他很棒的资源包括&lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;Users论坛&lt;/a&gt;和&lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">如果您像我们使用Hello World那样开始了一个不使用Cargo的项目！项目，您可以将其转换为使用Cargo的项目。将项目代码移到&lt;em&gt;src&lt;/em&gt;目录中，并创建一个适当的&lt;em&gt;Cargo.toml&lt;/em&gt;文件。</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">如果您尝试编译此代码，则会出现以下错误：</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">如果尝试在包含非 &lt;code&gt;Copy&lt;/code&gt; 数据的结构或枚举上实现 &lt;code&gt;Copy&lt;/code&gt; ，则会收到错误&lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">如果您取消注释最后的 &lt;code&gt;println!&lt;/code&gt; 并运行程序，生锈尝试打印这个周期， &lt;code&gt;a&lt;/code&gt; 指向 &lt;code&gt;b&lt;/code&gt; 指向 &lt;code&gt;a&lt;/code&gt; 依此类推，直到它溢出堆栈。</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">如果您想要的行为与 &lt;code&gt;derive&lt;/code&gt; 属性提供的行为不同，请查阅每个特征的&lt;a href=&quot;../std/index&quot;&gt;标准库文档，&lt;/a&gt;以获取有关如何手动实现它们的详细信息。</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">如果您希望其他人能够直接从您的模块导入变体，请使用 &lt;code&gt;pub use&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">如果你想访问这个字段,你有两个选择。</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要正确处理某个值，请运行其析构函数，请参阅&lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">如果要强制闭包对其在环境中使用的值拥有所有权，则可以在参数列表之前使用 &lt;code&gt;move&lt;/code&gt; 关键字。将闭包传递到新线程以移动数据，使其归新线程所有时，此技术最有用。</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">如果要获取命令行参数，请使用 &lt;code&gt;std::env::args&lt;/code&gt; 。要使用指定的退出代码退出，请使用 &lt;code&gt;std::process::exit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c9a2ec635fa6b00d5880ff9292416d8dca9a7fc" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted &lt;code&gt;VecDeque&lt;/code&gt;, while maintaining sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">如果要继续使用第一个 &lt;code&gt;String&lt;/code&gt; ，可以对其进行克隆，然后追加到克隆中：</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要泄漏内存，请参阅&lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">如果要与 &lt;code&gt;static&lt;/code&gt; 匹配，请考虑改用防护罩：</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要获取指向内存的原始指针，请参见&lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">如果你想一步到位获得最大值,可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">如果你想一步到位地获得最小值,可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926fba741a818eca51e737d7fa3523921dbd4a71" translate="yes" xml:space="preserve">
          <source>If you want to omit the initial error and only process its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">如果你想覆盖一个特定的选项,但仍然保留其他默认值。</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">如果要使用SPDX中未显示的许可证，则需要将该许可证的文本放置在文件中，在项目中包含该文件，然后使用 &lt;code&gt;license-file&lt;/code&gt; 指定该文件的名称。使用 &lt;code&gt;license&lt;/code&gt; 密钥。</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">如果要使用方法，请在其后添加 &lt;code&gt;()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">如果要使用 &lt;code&gt;rand&lt;/code&gt; 版本 &lt;code&gt;0.4.0&lt;/code&gt; 或 &lt;code&gt;0.4.x&lt;/code&gt; 系列中的任何版本，则必须更新&lt;em&gt;Cargo.toml&lt;/em&gt;文件，使其看起来像这样：</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">如果您希望将此属性应用于impl中的所有方法，请手动注释每个方法。无法使用 &lt;code&gt;#[inline]&lt;/code&gt; 属性注释整个impl 。</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">如果你想了解更多关于Rust的所有权,请从本书的章节开始。</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">如果要导入所有导出的宏，请编写 &lt;code&gt;macro_use&lt;/code&gt; 带参数的macro_use。</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">如果您对诸如Ruby，Python或JavaScript之类的动态语言更加熟悉，则可能不习惯将它们作为单独的步骤来编译和运行程序。Rust是一种&lt;em&gt;提前编译的&lt;/em&gt;语言，这意味着您可以编译程序并将可执行文件提供给其他人，即使他们没有安装Rust也可以运行它。如果为某人提供&lt;em&gt;.rb&lt;/em&gt;，&lt;em&gt;.py&lt;/em&gt;或&lt;em&gt;.js&lt;/em&gt;文件，则他们需要分别安装Ruby，Python或JavaScript实现。但是在这些语言中，您只需要一个命令即可编译和运行程序。一切都需要在语言设计中进行权衡。</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">如果您面临挑战，请尝试自己执行这些更改，然后再查看清单20-15中的代码。</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">如果您使用的是Linux或macOS，请打开一个终端并输入以下命令：</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">如果使用PowerShell，则需要设置环境变量并以两个命令而不是一个命令运行程序：</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">如果您使用Beta或稳定版的Rust，则不能使用任何功能标志。这是使我们在永久宣布新功能稳定之前就可以对其进行实际使用的关键。那些希望选择最前沿技术的人可以这样做，而那些希望获得坚如磐石经验的人可以坚持不懈，并知道他们的代码不会被破坏。稳定而无停滞。</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果要将一个文件的内容复制到另一个文件，并且正在使用&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，请参见&lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果您想将一个文件的内容复制到另一个文件，并且正在使用文件系统路径，请参见&lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">如果您在使用其他语言时听到过&lt;em&gt;浅复制&lt;/em&gt;和&lt;em&gt;深复制&lt;/em&gt;这两个术语，那么复制指针，长度和容量而不复制数据的概念可能听起来像是进行浅复制。但是由于Rust也使第一个变量无效，而不是被称为浅表副本，因此被称为&lt;em&gt;move&lt;/em&gt;。在这个例子中，我们可以说， &lt;code&gt;s1&lt;/code&gt; 被&lt;em&gt;移动&lt;/em&gt;到 &lt;code&gt;s2&lt;/code&gt; 。因此实际发生的情况如图4-4所示。</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
