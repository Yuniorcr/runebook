<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="6e589b43f3082da98ca0e4f046ea8ace2906bf51" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="translated">与&lt;a href=&quot;#method.from_utf8_lossy&quot;&gt; &lt;code&gt;from_utf8_lossy&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;from_utf16_lossy&lt;/code&gt; 返回 &lt;code&gt;String&lt;/code&gt; ,因为从UTF-16到UTF-8的转换需要分配内存。</target>
        </trans-unit>
        <trans-unit id="1e5e6606c716b7d8ea23880ff26dd47bb4cb772b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="translated">与&lt;a href=&quot;#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt;不同，这通常意味着操作参数有效，但是错误是由格式错误的输入数据引起的。</target>
        </trans-unit>
        <trans-unit id="42150160f2ba583b7d6c6990db7fe7b9390515b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../convert/fn.identity&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fe9eebd36a2bd7140bc3ec3fdc0c32e569dabf" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted allocations between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398c5c34b191e4676dc6961558a4a76db9314267" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted values between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="translated">与&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 使用原子运算进行引用计数。这意味着它是线程安全的。缺点是原子操作比普通的内存访问更昂贵。如果不在线程之间共享引用计数的值，请考虑使用&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;来降低开销。&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;是安全的默认设置，因为编译器将捕获在线程之间发送&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;任何尝试。但是，图书馆可能选择 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 以便为图书馆使用者提供更大的灵活性。</target>
        </trans-unit>
        <trans-unit id="e29ce9f9179b04ed1ae04e60eaff67bddb9bd1a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.errorkind#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977087ec8c6cc227ec1b23f036b52a53ba5572b7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;, this method is known to never panic on the result types it is implemented for. Therefore, it can be used instead of &lt;code&gt;unwrap&lt;/code&gt; as a maintainability safeguard that will fail to compile if the error type of the &lt;code&gt;Result&lt;/code&gt; is later changed to an error that can actually occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0ba302caf06a67df91ba9d9ffb499576009fcd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once()&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18aaa1337521f474ebf73b2e843073b1e6c1a48" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="translated">与&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once&lt;/code&gt; &lt;/a&gt;不同，此函数将根据要求延迟生成值。</target>
        </trans-unit>
        <trans-unit id="f9a90d0a5de7f0a5dcb5f54e9d3e2cfa25b0db2a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; works with unaligned pointers.</source>
          <target state="translated">与&lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;read_unaligned&lt;/code&gt; 使用未对齐的指针。</target>
        </trans-unit>
        <trans-unit id="45376ed6cd7ba7a1378a0b53a56bfa0037e236a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f193c98cf25a325eda25618a82a356c0b0cf6349" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="translated">与&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;不同，指针可能未对齐。</target>
        </trans-unit>
        <trans-unit id="6eb0fda1ae28c8f30f8d9d31bf06172d448763b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://doc.rust-lang.org/core/convert/fn.identity.html&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d4ccc7c19b4e12670ef1bb1f42a0a03d42f849" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert!&lt;/code&gt; is always type checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c003bf6ddb754586528cac314e476dba52106915" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将省略所有 &lt;code&gt;debug_assert!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert!&lt;/code&gt; 对于检查成本太高而无法在发行版本中进行显示的检查很有用，但在开发过程中可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="c7b2f5bacfdb6fe8fd35fce9254ebaf2411b3683" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_eq!&lt;/code&gt; is always type checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3263afd688aea4401eb3df7127fbabe1b1fe028e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert_eq&quot;&gt; &lt;code&gt;assert_eq!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert_eq!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将省略所有 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 对于检查成本太高而无法在发行版本中提供的检查很有用，但在开发过程中可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="dacd029d3cc2c2a10a75c84ef45c21166b5ba90a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_ne!&lt;/code&gt; is always type checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d1e96304d1bbf7140b253d02ca2ad39e16daa5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">不像&lt;a href=&quot;macro.assert_ne&quot;&gt; &lt;code&gt;assert_ne!&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;debug_assert_ne!&lt;/code&gt; 默认情况下，仅在未优化的构建中启用这些语句。优化的构建将省略所有 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 语句，除非将 &lt;code&gt;-C debug-assertions&lt;/code&gt; 传递给编译器。这使得 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 对于检查成本太高而无法在发行版本中提供的检查很有用，但在开发过程中可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="6cce36d9c22bd93c2a41b7e0597974f3cee7e7ac" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9ddf39955f900e36cc1e90f2b549ad7472a5bd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36949a10789f440243db02c27d7a2a4839d4968" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541167404f49247535e6737ca512feb21f2cf377" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac30468509752a4dadb45b544078909afc04dd2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e77b06d8fc7bb242ede2586728e20cd5ec38f2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicisize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicIsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1cb338dee4d9a50fbbd7a4ca8f1d9671b92ea5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicptr#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicPtr::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcca6a9c5592b18a67aa751975baab86b8d73470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8564dc4303f86be3afe445dd42ac378dde93ba88" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f28ad76976058589a61b38b753ee6ff0210850" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76887ce7cd48ec3a42bf06e1a6d5d6113a38547a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb26d7e8cfff635de8d1457d1dfb96fc541fdd8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicusize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicUsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0f6d29be16ce7f6bbb39d8f34d156c5bad7880" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt;, if this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; has been poisoned (i.e., a previous call to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; caused a panic), calling &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will no longer be in a poison state and all future calls to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will be no-ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97444204f29f9f8d725d9dd412f9b1cb5f20d4e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once&lt;/code&gt;&lt;/a&gt;, if this &lt;code&gt;Once&lt;/code&gt; has been poisoned (i.e., a previous call to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_once_force&lt;/code&gt; caused a panic), calling &lt;code&gt;call_once_force&lt;/code&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;code&gt;Once&lt;/code&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;code&gt;Once&lt;/code&gt; will no longer be in a poison state and all future calls to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_one_force&lt;/code&gt; will be no-ops.</source>
          <target state="translated">与&lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once&lt;/code&gt; &lt;/a&gt;不同，如果 &lt;code&gt;Once&lt;/code&gt; 中毒（即，先前对 &lt;code&gt;call_once&lt;/code&gt; 或 &lt;code&gt;call_once_force&lt;/code&gt; 的调用引起了恐慌），则调用 &lt;code&gt;call_once_force&lt;/code&gt; 仍将调用闭包 &lt;code&gt;f&lt;/code&gt; 并且&lt;em&gt;不会&lt;/em&gt;立即引起恐慌。如果 &lt;code&gt;f&lt;/code&gt; 恐慌中， &lt;code&gt;Once&lt;/code&gt; 将保持在一个毒状态。如果 &lt;code&gt;f&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌， &lt;code&gt;Once&lt;/code&gt; 将不再是一剂毒药状态和所有将来呼叫 &lt;code&gt;call_once&lt;/code&gt; 的或 &lt;code&gt;call_one_force&lt;/code&gt; 将是空操作。</target>
        </trans-unit>
        <trans-unit id="69bf1113333b0a6b470f760044140ccfaef050a0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9701139045e2ad48d71d09c86c7eff61381e89c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb694c3e76472c257054ea4932b6e425a8976f9f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt;, zero-sized allocations are allowed in &lt;code&gt;AllocRef&lt;/code&gt;. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as &lt;code&gt;libc::malloc&lt;/code&gt;), this must be caught by the implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53e5897fa59de78d867c186db4554c739885b98" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_match&quot;&gt;&lt;code&gt;next_match&lt;/code&gt;&lt;/a&gt; will overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5b411ac352c96a1edc968b7e49d8e28ffb6bde" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_reject&quot;&gt;&lt;code&gt;next_reject&lt;/code&gt;&lt;/a&gt; will overlap. This will return &lt;code&gt;(start_match, end_match)&lt;/code&gt;, where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07cc87b6de700e95562f870286c85dae89d1a54" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;, this takes a &lt;em&gt;mutable&lt;/em&gt; reference to a slice of &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s, not an immutable one. That's because we need to modify the slice to keep track of the bytes already written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee6890d64168a6d63a327f53d097426ab508e0a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; is covariant over &lt;code&gt;T&lt;/code&gt;. If this is incorrect for your use case, you should include some &lt;a href=&quot;../marker/struct.phantomdata&quot;&gt;&lt;code&gt;PhantomData&lt;/code&gt;&lt;/a&gt; in your type to provide invariance, such as &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt;. Usually this won't be necessary; covariance is correct for most safe abstractions, such as &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt;, &lt;code&gt;Vec&lt;/code&gt;, and &lt;code&gt;LinkedList&lt;/code&gt;. This is the case because they provide a public API that follows the normal shared XOR mutable rules of Rust.</source>
          <target state="translated">与 &lt;code&gt;*mut T&lt;/code&gt; 不同， &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;code&gt;T&lt;/code&gt; 上是协变的。如果这对于您的用例是不正确的，则应在您的类型中包括一些&lt;a href=&quot;../marker/struct.phantomdata&quot;&gt; &lt;code&gt;PhantomData&lt;/code&gt; &lt;/a&gt;以提供不变性，例如 &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt; 。通常这是没有必要的。协方差对于大多数安全抽象都是正确的，例如 &lt;code&gt;Box&lt;/code&gt; ， &lt;code&gt;Rc&lt;/code&gt; ， &lt;code&gt;Arc&lt;/code&gt; ， &lt;code&gt;Vec&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 。之所以如此，是因为它们提供了遵循Rust的常规共享XOR可变规则的公共API。</target>
        </trans-unit>
        <trans-unit id="da5b9cd95305c47f8c2680144fa717b64a77ae08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; has the same size as &lt;code&gt;*mut T&lt;/code&gt;. However the pointer may still dangle if it isn't dereferenced.</source>
          <target state="translated">与 &lt;code&gt;*mut T&lt;/code&gt; 不同，即使从未取消引用指针，指针也必须始终为非null。这样一来，枚举就可以将此禁止值用作判别式 &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 具有与 &lt;code&gt;*mut T&lt;/code&gt; 相同的大小。但是，如果指针未取消引用，它可能仍会悬垂。</target>
        </trans-unit>
        <trans-unit id="2af92ae1d7844362d4deb8a5a097d647449edca7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;a href=&quot;../borrow/trait.borrow&quot;&gt;&lt;code&gt;Borrow&lt;/code&gt;&lt;/a&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b18281654acc984643104c10e5e6c721877239" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;code&gt;Borrow&lt;/code&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="translated">与 &lt;code&gt;AsRef&lt;/code&gt; 不同， &lt;code&gt;Borrow&lt;/code&gt; 对任何 &lt;code&gt;T&lt;/code&gt; 都有一个毯子式暗示，可以用来接受引用或值。</target>
        </trans-unit>
        <trans-unit id="5ceb8d46ab7abd8b54416adda315f1d04158fc52" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized structs are not rounded up to one byte in size.</source>
          <target state="translated">与 &lt;code&gt;C&lt;/code&gt; 不同，零大小的结构不会四舍五入为一个字节。</target>
        </trans-unit>
        <trans-unit id="02f8b77aa6c48466699ca8ee968807c87cf6172e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized unions are not rounded up to one byte in size.</source>
          <target state="translated">与 &lt;code&gt;C&lt;/code&gt; 不同，零大小的并集不舍入到一个字节的大小。</target>
        </trans-unit>
        <trans-unit id="af8a23b1549826352efacb218921580838863fd0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, this method is safe because the pointer &lt;code&gt;P&lt;/code&gt; dereferences to an &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; type, which cancels the pinning guarantees.</source>
          <target state="translated">与 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 不同，此方法很安全，因为指针 &lt;code&gt;P&lt;/code&gt; 取消引用了&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;类型，这取消了锁定保证。</target>
        </trans-unit>
        <trans-unit id="f597f0fe6680930140f1186767bedc7add8ce577" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type represents single ownership over the data it holds. So, what makes &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; different from a type like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;? Recall the borrowing rules you learned in Chapter 4:</source>
          <target state="translated">与 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 不同， &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型表示对其拥有的数据的单一所有权。那么，是什么使 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 与 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 类的类型不同呢？回忆一下您在第4章中学到的借用规则：</target>
        </trans-unit>
        <trans-unit id="926eeb30ef8b029d9a554336169dcbfbccf0209b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell::borrow&lt;/code&gt;, this method is unsafe because it does not return a &lt;code&gt;Ref&lt;/code&gt;, thus leaving the borrow flag untouched. Mutably borrowing the &lt;code&gt;RefCell&lt;/code&gt; while the reference returned by this method is alive is undefined behaviour.</source>
          <target state="translated">与 &lt;code&gt;RefCell::borrow&lt;/code&gt; 不同，此方法是不安全的，因为它不返回 &lt;code&gt;Ref&lt;/code&gt; ，从而使借位标志保持不变。在此方法返回的引用处于活动 &lt;code&gt;RefCell&lt;/code&gt; 时，以可变方式借用RefCell是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="42c8dcf936cacded32e38266231efc7d97352aa2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; only provides shared &lt;code&gt;&amp;amp;T&lt;/code&gt; references to its value. Unlike &lt;code&gt;Cell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; doesn't require copying or replacing the value to access it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57c88d683b5f207c6b40e5f43b3334b288246db" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;connect_timeout&lt;/code&gt; takes a single &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; since timeout must be applied to individual addresses.</source>
          <target state="translated">与 &lt;code&gt;connect&lt;/code&gt; 不同， &lt;code&gt;connect_timeout&lt;/code&gt; 需要一个&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; ,&lt;/a&gt;因为必须将超时应用于单个地址。</target>
        </trans-unit>
        <trans-unit id="1ac28d4f87c8eadd078ff1fbd83c69852aa4b470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;fill_buf&lt;/code&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="translated">与 &lt;code&gt;fill_buf&lt;/code&gt; 不同，如果缓冲区为空，它将不会尝试填充缓冲区。</target>
        </trans-unit>
        <trans-unit id="c33686d3ffa81ffa69b98b7573a09c025985a84a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">与 &lt;code&gt;read&lt;/code&gt; 不同，指针可能未对齐。</target>
        </trans-unit>
        <trans-unit id="5074eaba30dfa9d17ab40b89f4a8cde3f2ff28d5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;write&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">与 &lt;code&gt;write&lt;/code&gt; 不同，指针可能未对齐。</target>
        </trans-unit>
        <trans-unit id="0869ce408d434adce2ac58f521663bfd0e76626c" translate="yes" xml:space="preserve">
          <source>Unlike an &lt;a href=&quot;../glossary#associated-item&quot;&gt;associated&lt;/a&gt; constant, a &lt;a href=&quot;../glossary#free-item&quot;&gt;free&lt;/a&gt; constant may be unnamed by using an underscore instead of the name. For example:</source>
          <target state="translated">与&lt;a href=&quot;../glossary#associated-item&quot;&gt;关联的&lt;/a&gt;常量不同，可以使用下划线代替名称来命名&lt;a href=&quot;../glossary#free-item&quot;&gt;自由&lt;/a&gt;常量。例如：</target>
        </trans-unit>
        <trans-unit id="c1df7fba2918a10b0657219d3fc33575209df6ce" translate="yes" xml:space="preserve">
          <source>Unlike arithmetic and logical operators, the traits for overloading the operators the traits for these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety). Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression context&lt;/a&gt;:</source>
          <target state="translated">与算术和逻辑运算符不同，用于重载运算符的特征更普遍地用于显示这些运算符的特征，以显示如何比较类型，并且可能会假定使用这些特征作为边界的函数来定义实际比较。然后，标准库中的许多函数和宏都可以使用该假设（尽管不是为了确保安全性）。与上面的算术和逻辑运算符不同，这些运算符隐式地使用它们的操作数的共享借位，并在&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;位置表达式上下文中&lt;/a&gt;对其进行求值：</target>
        </trans-unit>
        <trans-unit id="121561ea59642cbf851a475739b422a107512b01" translate="yes" xml:space="preserve">
          <source>Unlike closures, &lt;code&gt;fn&lt;/code&gt; is a type rather than a trait, so we specify &lt;code&gt;fn&lt;/code&gt; as the parameter type directly rather than declaring a generic type parameter with one of the &lt;code&gt;Fn&lt;/code&gt; traits as a trait bound.</source>
          <target state="translated">与闭包不同， &lt;code&gt;fn&lt;/code&gt; 是类型而不是特征，因此我们直接将 &lt;code&gt;fn&lt;/code&gt; 指定为参数类型，而不是声明以 &lt;code&gt;Fn&lt;/code&gt; 特征之一作为特征绑定的泛型类型参数。</target>
        </trans-unit>
        <trans-unit id="ddb54f325fe389efa56003444a2d405f87525e97" translate="yes" xml:space="preserve">
          <source>Unlike for structs, local variables are dropped in reverse order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64287ed646615b0f4f1dbe6a0afd166352be3fa4" translate="yes" xml:space="preserve">
          <source>Unlike generic parameters or &lt;code&gt;impl Trait&lt;/code&gt;, the compiler does not know the concrete type that is being passed. That is, the type has been &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_erasure&quot;&gt;erased&lt;/a&gt;. As such, a &lt;code&gt;dyn Trait&lt;/code&gt; reference contains &lt;em&gt;two&lt;/em&gt; pointers. One pointer goes to the data (e.g., an instance of a struct). Another pointer goes to a map of method call names to function pointers (known as a virtual method table or vtable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac0121efe5c81f6ee999aad45c525acd80438be" translate="yes" xml:space="preserve">
          <source>Unlike in the TCP case, passing an array of addresses to the &lt;code&gt;connect&lt;/code&gt; function of a UDP socket is not a useful thing to do: The OS will be unable to determine whether something is listening on the remote address without the application sending data.</source>
          <target state="translated">与TCP情况不同，将地址数组传递给UDP套接字的 &lt;code&gt;connect&lt;/code&gt; 功能不是一件有用的事情：在没有应用程序发送数据的情况下，操作系统将无法确定是否有人在监听远程地址。</target>
        </trans-unit>
        <trans-unit id="a7c8893077e685528bec1188265b9f18660f72cd" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_match will overlap.</source>
          <target state="translated">与next()不同,不能保证this和next_match的返回范围会重叠。</target>
        </trans-unit>
        <trans-unit id="d71db212c677479519bbb6e79cc1b75787a4617d" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_reject will overlap. This will return (start_match, end_match), where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="translated">与 next()不同,不能保证 this 和 next_reject 的返回范围会重叠。这将返回(start_match,end_match),其中start_match是匹配开始的索引,end_match是匹配结束后的索引。</target>
        </trans-unit>
        <trans-unit id="6692903ae621839ab645be72d216172c7413d4a0" translate="yes" xml:space="preserve">
          <source>Unlike normal functions, extern fns have type &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt;. This is the same type as the functions declared in an extern block.</source>
          <target state="translated">与普通函数不同，extern fns具有类型 &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt; 。这与extern块中声明的函数的类型相同。</target>
        </trans-unit>
        <trans-unit id="36f4ada6278b2f8caced444ea3301e8d71339c65" translate="yes" xml:space="preserve">
          <source>Unlike other methods on &lt;code&gt;TcpStream&lt;/code&gt;, this does not correspond to a single system call. It instead calls &lt;code&gt;connect&lt;/code&gt; in nonblocking mode and then uses an OS-specific mechanism to await the completion of the connection request.</source>
          <target state="translated">与 &lt;code&gt;TcpStream&lt;/code&gt; 上的其他方法不同，这并不对应于单个系统调用。相反，它以非阻塞模式调用 &lt;code&gt;connect&lt;/code&gt; ，然后使用特定于OS的机制来等待连接请求的完成。</target>
        </trans-unit>
        <trans-unit id="d70fcfde3feb0ab38dc2fc9e1a50deff87be8c12" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; free function, this method yields an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to capture any failure to create the thread at the OS level.</source>
          <target state="translated">不同于免费&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;功能，此方法产生&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;来捕获在操作系统级别创建线程的任何失败。</target>
        </trans-unit>
        <trans-unit id="f0b436366c65f5f44a2751625381a1b624985a04" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;offset&lt;/code&gt; intrinsic, this intrinsic does not restrict the resulting pointer to point into or one byte past the end of an allocated object, and it wraps with two's complement arithmetic. The resulting value is not necessarily valid to be used to actually access memory.</source>
          <target state="translated">与 &lt;code&gt;offset&lt;/code&gt; 内在函数不同，此内在函数不会限制结果指针指向已分配对象的末尾或末尾一个字节，并且使用二进制补码算法进行换行。结果值不一定有效地用于实际访问内存。</target>
        </trans-unit>
        <trans-unit id="6faf47afea7f3d6a44a9251fcf64aa5fc01a6de0" translate="yes" xml:space="preserve">
          <source>Unlike the other kinds of loops in Rust (&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;while let&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;), loops can be used as expressions that return values via &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">与Rust中其他类型的循环（ &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;while let&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; ）不同，循环可以用作通过 &lt;code&gt;break&lt;/code&gt; 返回值的表达式。</target>
        </trans-unit>
        <trans-unit id="3c816b7f283c34ee4cf6d4ad3a434746ee09b413" translate="yes" xml:space="preserve">
          <source>Unnamed constant</source>
          <target state="translated">未命名常数</target>
        </trans-unit>
        <trans-unit id="2eba6a03b89a9ddb19e9cb15699a8737f8bab076" translate="yes" xml:space="preserve">
          <source>Unpin</source>
          <target state="translated">Unpin</target>
        </trans-unit>
        <trans-unit id="5ea7d63651b5ab2fca876bb44555b1ae728096be" translate="yes" xml:space="preserve">
          <source>Unqualified path patterns can refer to:</source>
          <target state="translated">非限定路径模式可以指:</target>
        </trans-unit>
        <trans-unit id="76194078e8e620ab2e92b2710e1b86b55aa19577" translate="yes" xml:space="preserve">
          <source>Unrecoverable Errors with &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</source>
          <target state="translated">不可挽回的错误与 &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70558ee42c96fb4886d205abf6563d627dc6cb30" translate="yes" xml:space="preserve">
          <source>Unregisters the current allocation error hook, returning it.</source>
          <target state="translated">解除对当前分配错误钩子的注册,返回它。</target>
        </trans-unit>
        <trans-unit id="0b233b52323b31980ad438994ac81379bf159f10" translate="yes" xml:space="preserve">
          <source>Unregisters the current panic hook, returning it.</source>
          <target state="translated">解除注册当前的恐慌钩,将其返回。</target>
        </trans-unit>
        <trans-unit id="4ad2c25804ae1c9519924b3333558a84852f9759" translate="yes" xml:space="preserve">
          <source>Unsafe Rust</source>
          <target state="translated">不安全的铁锈</target>
        </trans-unit>
        <trans-unit id="2bf8239af3f464752ec2490794f409624c78c660" translate="yes" xml:space="preserve">
          <source>Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it&amp;rsquo;s better for it to reject some valid programs rather than accept some invalid programs. Although the code might be okay, as far as Rust is able to tell, it&amp;rsquo;s not! In these cases, you can use unsafe code to tell the compiler, &amp;ldquo;Trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</source>
          <target state="translated">存在不安全Rust的原因是，从本质上讲，静态分析是保守的。当编译器试图确定代码是否遵守保证时，最好拒绝一些有效程序，而不是接受一些无效程序。尽管代码可能还不错，但就Rust所能证明的来说，不是！在这种情况下，您可以使用不安全的代码告诉编译器：&amp;ldquo;相信我，我知道我在做什么。&amp;rdquo; 缺点是使用它的风险自负：如果错误地使用了不安全的代码，则可能会发生由于内存不安全而引起的问题，例如空指针取消引用。</target>
        </trans-unit>
        <trans-unit id="b6d976facee53ef7685c3c2e196f51896ea84263" translate="yes" xml:space="preserve">
          <source>Unsafe Rust: how to opt out of some of Rust&amp;rsquo;s guarantees and take responsibility for manually upholding those guarantees</source>
          <target state="translated">不安全的Rust：如何选择退出Rust的某些保证并承担手动维护这些保证的责任</target>
        </trans-unit>
        <trans-unit id="fe954ab5c7d2bf81229af474f3df1f82baf2452e" translate="yes" xml:space="preserve">
          <source>Unsafe Superpowers</source>
          <target state="translated">不安全的超能力</target>
        </trans-unit>
        <trans-unit id="213dd70d91f9e41a9bf1846e9c631a99cd907b6a" translate="yes" xml:space="preserve">
          <source>Unsafe abilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baac6e0b0340f8475119715946cbe8c2961f1b1b" translate="yes" xml:space="preserve">
          <source>Unsafe blocks</source>
          <target state="translated">不安全区块</target>
        </trans-unit>
        <trans-unit id="14b175946b1bbc439b9bcf446b898eb6bb255e29" translate="yes" xml:space="preserve">
          <source>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language. For example, Rust provides the language features necessary to implement memory-safe concurrency in the language but the implementation of threads and message passing is in the standard library.</source>
          <target state="translated">不安全区块用于包裹外来库,直接使用硬件或实现语言中不直接存在的功能。例如,Rust提供了在语言中实现内存安全并发所需的语言特性,但线程和消息传递的实现是在标准库中。</target>
        </trans-unit>
        <trans-unit id="22664c4ba89e060c3e51b8ae88cd58e9bfacca10" translate="yes" xml:space="preserve">
          <source>Unsafe code may rely on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67e2a049687812f1b206c18f80d4f4b930977c1" translate="yes" xml:space="preserve">
          <source>Unsafe code relies on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="translated">不安全的代码依赖于 &lt;code&gt;assert!&lt;/code&gt; 强制执行运行时不变式，如果违反该规定可能会导致不安全。</target>
        </trans-unit>
        <trans-unit id="4155a1ec65a094fcbe134a0c2768d51a34c574a8" translate="yes" xml:space="preserve">
          <source>Unsafe code should not rely on the correctness of behavior after overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53274f3a611843db2cae74ec90f381fafeb9213" translate="yes" xml:space="preserve">
          <source>Unsafe code was used outside of an unsafe function or block.</source>
          <target state="translated">在不安全函数或代码块之外使用了不安全代码。</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">不安全功能</target>
        </trans-unit>
        <trans-unit id="10b765166af116817c2643c79030e41920ee70d7" translate="yes" xml:space="preserve">
          <source>Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. Such a function must be prefixed with the keyword &lt;code&gt;unsafe&lt;/code&gt; and can only be called from an &lt;code&gt;unsafe&lt;/code&gt; block or another &lt;code&gt;unsafe&lt;/code&gt; function.</source>
          <target state="translated">不安全功能是指在所有情况下和/或所有可能的输入中都不安全的功能。这样的函数必须以关键字 &lt;code&gt;unsafe&lt;/code&gt; 开头，并且只能从不 &lt;code&gt;unsafe&lt;/code&gt; 块或另一个 &lt;code&gt;unsafe&lt;/code&gt; 函数中调用。</target>
        </trans-unit>
        <trans-unit id="d33167b0116d560739d43b19ab027e220d852053" translate="yes" xml:space="preserve">
          <source>Unsafe is used on an async function in precisely the same way that it is used on other functions: it indicates that the function imposes some additional obligations on its caller to ensure soundness. As in any other unsafe function, these conditions may extend beyond the initial call itself -- in the snippet above, for example, the &lt;code&gt;unsafe_example&lt;/code&gt; function took a pointer &lt;code&gt;x&lt;/code&gt; as argument, and then (when awaited) dereferenced that pointer. This implies that &lt;code&gt;x&lt;/code&gt; would have to be valid until the future is finished executing, and it is the callers responsibility to ensure that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d7f0c36d2323b4760c5854a9da5e93bff496e9" translate="yes" xml:space="preserve">
          <source>Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust's static semantics.</source>
          <target state="translated">不安全的操作是指那些有可能违反Rust静态语义的内存安全保证的操作。</target>
        </trans-unit>
        <trans-unit id="bf164d180d2c3d60fa72dcb8309415b858fb3ef4" translate="yes" xml:space="preserve">
          <source>Unsafe traits</source>
          <target state="translated">不安全的特征</target>
        </trans-unit>
        <trans-unit id="3f92b08e3c34ebb357bc1ad626c86bb44dccf639" translate="yes" xml:space="preserve">
          <source>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</source>
          <target state="translated">不安全的特质必须有不安全的实现。当一个不安全性状的实现没有标记为不安全时,就会出现这个错误。这可以通过将不安全实现标记为不安全来解决。</target>
        </trans-unit>
        <trans-unit id="5115d7bdd1417d736db11b27ea37e8ee82718f27" translate="yes" xml:space="preserve">
          <source>UnsafeCell</source>
          <target state="translated">UnsafeCell</target>
        </trans-unit>
        <trans-unit id="2c35a285bb852cf3e62f32e3633426c0ef4631a3" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow</source>
          <target state="translated">UnsafeCell::borrow</target>
        </trans-unit>
        <trans-unit id="75bc0d417d751ed027f53b28049e848ca0749b51" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow_mut</source>
          <target state="translated">UnsafeCell::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a881f13247abe21c6a44c037b8dd96d764dbe3f6" translate="yes" xml:space="preserve">
          <source>UnsafeCell::default</source>
          <target state="translated">UnsafeCell::default</target>
        </trans-unit>
        <trans-unit id="dff2508a0e8759e4bdb101a66e3d4f193575af5f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::fmt</source>
          <target state="translated">UnsafeCell::fmt</target>
        </trans-unit>
        <trans-unit id="fdaf457db9ff90155c2c22c46f8d7d84bbcf495e" translate="yes" xml:space="preserve">
          <source>UnsafeCell::from</source>
          <target state="translated">UnsafeCell::from</target>
        </trans-unit>
        <trans-unit id="3345a29406bcc11d2b5b8b2bbebd7e4e0bd82ec5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::get</source>
          <target state="translated">UnsafeCell::get</target>
        </trans-unit>
        <trans-unit id="c9466ca2fc8e49b6dbd92183423a4c8fa163622c" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into</source>
          <target state="translated">UnsafeCell::into</target>
        </trans-unit>
        <trans-unit id="f93e09df9c8216c70f11ba4964e183b8a07e1fb7" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into_inner</source>
          <target state="translated">UnsafeCell::into_inner</target>
        </trans-unit>
        <trans-unit id="b09cd160b3ecd626dee4e6ef60b717116e682ae5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::new</source>
          <target state="translated">UnsafeCell::new</target>
        </trans-unit>
        <trans-unit id="4a93c833e143a391e62488b530430f04d10a5b76" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_from</source>
          <target state="translated">UnsafeCell::try_from</target>
        </trans-unit>
        <trans-unit id="cde666e236559ffd66009b3fdec4a7ed6f2c1d9f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_into</source>
          <target state="translated">UnsafeCell::try_into</target>
        </trans-unit>
        <trans-unit id="3b8d314be6e0f9f234457b987c6cbb99be6adc66" translate="yes" xml:space="preserve">
          <source>UnsafeCell::type_id</source>
          <target state="translated">UnsafeCell::type_id</target>
        </trans-unit>
        <trans-unit id="e0539de3e0de023b7e2dd1485ffa3c4a0acc8d49" translate="yes" xml:space="preserve">
          <source>Unsafely creates a C string wrapper from a byte slice.</source>
          <target state="translated">不安全地从一个字节分片创建一个C字符串包装器。</target>
        </trans-unit>
        <trans-unit id="80d75cb6c5a344f6eadb72b7d847c31a12dc80ca" translate="yes" xml:space="preserve">
          <source>Unsafety</source>
          <target state="translated">Unsafety</target>
        </trans-unit>
        <trans-unit id="e91344ea16120944c87d0e0635826ca2b1e1956c" translate="yes" xml:space="preserve">
          <source>Unsigned</source>
          <target state="translated">Unsigned</target>
        </trans-unit>
        <trans-unit id="ec69039d9aace16bc0675cab4f4e5d7118fc67b0" translate="yes" xml:space="preserve">
          <source>Unsize</source>
          <target state="translated">Unsize</target>
        </trans-unit>
        <trans-unit id="8702197dc32e4fc5986508c97d9597351056f2bf" translate="yes" xml:space="preserve">
          <source>Unsized Coercions</source>
          <target state="translated">无规模的胁迫</target>
        </trans-unit>
        <trans-unit id="a090334da83d2c5e2a98abcbd42c6af2bf5571a1" translate="yes" xml:space="preserve">
          <source>Unsized data:</source>
          <target state="translated">不大的数据。</target>
        </trans-unit>
        <trans-unit id="ea2569aaa33eada2280795d75f286bd6771924fe" translate="yes" xml:space="preserve">
          <source>Unstable Features</source>
          <target state="translated">不稳定的特点</target>
        </trans-unit>
        <trans-unit id="92ffa7782162b2b301a0b11d2aefb00ca2f2a2f0" translate="yes" xml:space="preserve">
          <source>Until now, all our examples have been matching structs or enums that were one level deep. Matching can work on nested items too!</source>
          <target state="translated">到目前为止,我们所有的例子都是在匹配一层深的结构或枚举。匹配也可以在嵌套的项目上工作。</target>
        </trans-unit>
        <trans-unit id="9a0d085fdd50abbdcb3c17611b8692b87c3b02d5" translate="yes" xml:space="preserve">
          <source>Until now, we&amp;rsquo;ve not talked about &lt;em&gt;global variables&lt;/em&gt;, which Rust does support but can be problematic with Rust&amp;rsquo;s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</source>
          <target state="translated">到目前为止，我们还没有讨论过Rust所支持的&lt;em&gt;全局变量&lt;/em&gt;，但是对于Rust的所有权规则可能会出现问题。如果两个线程正在访问相同的可变全局变量，则可能导致数据争用。</target>
        </trans-unit>
        <trans-unit id="bef75503876861f1652d24e0b101fc042661d7b5" translate="yes" xml:space="preserve">
          <source>Until these issues are resolved, you can use the &lt;a href=&quot;https://crates.io/crates/async-trait&quot;&gt;&lt;code&gt;async-trait&lt;/code&gt; crate&lt;/a&gt;, allowing you to use &lt;code&gt;async fn&lt;/code&gt; in traits by desugaring to &quot;boxed futures&quot; (&lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future + Send + 'async&amp;gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a466dbcb07d272a4827d08399fcc579473f95bac" translate="yes" xml:space="preserve">
          <source>Unused lifetime parameters</source>
          <target state="translated">未使用的寿命参数</target>
        </trans-unit>
        <trans-unit id="67f29d2fd70384a80fd94676bef420c60ec02613" translate="yes" xml:space="preserve">
          <source>Unused type parameters</source>
          <target state="translated">未使用的类型参数</target>
        </trans-unit>
        <trans-unit id="4309bf93c467874d67ac366ea9fc690edd209fc3" translate="yes" xml:space="preserve">
          <source>UnwindSafe</source>
          <target state="translated">UnwindSafe</target>
        </trans-unit>
        <trans-unit id="cbc02d75adc1ffc39fd3a16b3b4074d157341ccf" translate="yes" xml:space="preserve">
          <source>Unwinding the Stack or Aborting in Response to a Panic</source>
          <target state="translated">解除堆栈或因慌乱而中止操作</target>
        </trans-unit>
        <trans-unit id="2789441f00b1b852b1abc369acfc06188469d312" translate="yes" xml:space="preserve">
          <source>Unwraps a result or propagates its error.</source>
          <target state="translated">解开一个结果或传播其错误。</target>
        </trans-unit>
        <trans-unit id="bf154983f21c606f5ed175df0a60de13c896591a" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解开结果，得到&lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;的内容。</target>
        </trans-unit>
        <trans-unit id="88ae872ed59ebfa48f0864e25ba0455dd8b90e15" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解开结果，产生&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;的内容。</target>
        </trans-unit>
        <trans-unit id="f6bb0d8e70fa6dd56dc1322239dbf82a2df0a4ac" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. Else, it returns &lt;code&gt;optb&lt;/code&gt;.</source>
          <target state="translated">解开结果，产生&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;的内容。否则，它返回 &lt;code&gt;optb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="117016b46649ef00153af6f7350c9138ecc67dda" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. If the value is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; then it calls &lt;code&gt;op&lt;/code&gt; with its value.</source>
          <target state="translated">解开结果，产生&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;的内容。如果该值为&lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt;则使用其值调用 &lt;code&gt;op&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d656a32648587effa39921eb330f108c0675d59" translate="yes" xml:space="preserve">
          <source>Unwraps an option, yielding the content of a &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解开一个选项，产生&lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;的内容。</target>
        </trans-unit>
        <trans-unit id="44e46942e6b3560b76547c4068197f656ff8557f" translate="yes" xml:space="preserve">
          <source>Unwraps the value.</source>
          <target state="translated">解开值。</target>
        </trans-unit>
        <trans-unit id="cbbcbd99f909cf5773cc2f8cf87cdd95f999143d" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;, returning the underlying reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c0f60884f81c191ed8a1499ae68b62ce7e7ea6" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&lt;/code&gt;, returning the underlying reader.</source>
          <target state="translated">解开此 &lt;code&gt;BufReader&lt;/code&gt; ，返回基础阅读器。</target>
        </trans-unit>
        <trans-unit id="d79f711284b065af6b4e74f8652871df33141f21" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;, returning the underlying writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69524452be5afea8f11639be9af1a3cd4b2bfb03" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">解开此 &lt;code&gt;BufWriter&lt;/code&gt; ，返回基础编写器。</target>
        </trans-unit>
        <trans-unit id="935d143678423728d032f85b20c66b89ea1e5a53" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;LineWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">解包此 &lt;code&gt;LineWriter&lt;/code&gt; ，返回基础编写器。</target>
        </trans-unit>
        <trans-unit id="2e3b12243482f11a01fe101039b067f041f66124" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; returning the underlying pointer.</source>
          <target state="translated">解开此 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 并返回基础指针。</target>
        </trans-unit>
        <trans-unit id="9b17789b43e82ba91c88e4d986c1f5d5ba8289b4" translate="yes" xml:space="preserve">
          <source>Update the two instances of duplicated code to call the function instead.</source>
          <target state="translated">更新两个重复的代码实例来代替调用函数。</target>
        </trans-unit>
        <trans-unit id="9d8edb0cba2f3c71c929550f878ec6f1ab95a982" translate="yes" xml:space="preserve">
          <source>Update to a newer Rust version</source>
          <target state="translated">更新到更新的Rust版本</target>
        </trans-unit>
        <trans-unit id="a37ad606755c045819fc66433cff2f591c85b628" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39de9c5b81e5a6bb6d85d389439d91c0bfb9619" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383cb3a84b0a57cded7c0258c7e1a49880c35c95" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="translated">将&lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt;更新为 &lt;code&gt;extension&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3c4a6fdd4244e071cb1f5b4ee0c1015487b2074" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">将&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt;更新为 &lt;code&gt;file_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="499d5f0f7c8875ae92624d65ec97b14c16b89ea7" translate="yes" xml:space="preserve">
          <source>Updates the contained value using a function and returns the new value.</source>
          <target state="translated">使用函数更新包含的值并返回新的值。</target>
        </trans-unit>
        <trans-unit id="54c400ee034681ba4f94547c1f9e6d6c6ae60547" translate="yes" xml:space="preserve">
          <source>Updating a Crate to Get a New Version</source>
          <target state="translated">更新箱子以获得新版本</target>
        </trans-unit>
        <trans-unit id="230bbf8ccb89f28d643435c51ba717b409f87480" translate="yes" xml:space="preserve">
          <source>Updating a Hash Map</source>
          <target state="translated">更新哈希图</target>
        </trans-unit>
        <trans-unit id="83885ba9f035a9010b4b1ccae0e7e7d6ed9f8e1e" translate="yes" xml:space="preserve">
          <source>Updating a String</source>
          <target state="translated">更新一个字符串</target>
        </trans-unit>
        <trans-unit id="d2ba6d88a1646ea3bcd8516dafee00edcea72844" translate="yes" xml:space="preserve">
          <source>Updating a Value Based on the Old Value</source>
          <target state="translated">更新基于旧值的值</target>
        </trans-unit>
        <trans-unit id="923fa3af760fbaa62e4ad240ccab4df3cf7cd0e1" translate="yes" xml:space="preserve">
          <source>Updating a Vector</source>
          <target state="translated">更新向量</target>
        </trans-unit>
        <trans-unit id="e383c87cdb72887f6744a78bd78fa459e44a666d" translate="yes" xml:space="preserve">
          <source>Updating and Uninstalling</source>
          <target state="translated">更新和卸载</target>
        </trans-unit>
        <trans-unit id="874862d7b95e02718d554f979aec41adae9c4cee" translate="yes" xml:space="preserve">
          <source>Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="translated">在接收到自旋环信号后,处理器可以通过诸如省电或切换超线程来优化其行为。</target>
        </trans-unit>
        <trans-unit id="a0b0bd731b8e15bb23bd7cc76d2aa724aa6bbacd" translate="yes" xml:space="preserve">
          <source>Upon receiving the spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22415b6a3d0c513d757498ec107592efc88cd6e4" translate="yes" xml:space="preserve">
          <source>UpperExp</source>
          <target state="translated">UpperExp</target>
        </trans-unit>
        <trans-unit id="fcfc7b5ea59d907143490b4156e6805ce49d5515" translate="yes" xml:space="preserve">
          <source>UpperExp::fmt</source>
          <target state="translated">UpperExp::fmt</target>
        </trans-unit>
        <trans-unit id="f690e8510e34f299255dfcc6523578488db8db3e" translate="yes" xml:space="preserve">
          <source>UpperHex</source>
          <target state="translated">UpperHex</target>
        </trans-unit>
        <trans-unit id="2bafd282159acd4fe944a3d1a0e5e2492ec2091e" translate="yes" xml:space="preserve">
          <source>UpperHex::fmt</source>
          <target state="translated">UpperHex::fmt</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="8139f3704cf1ae8bc1b831776ef1b322f4905331" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">为此行为使用&lt;a href=&quot;#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31c647ca0e64548e5df242f616757ada55c0dfbe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687f0dae29440086643b86ae5972f2641cdbdfdb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;park_timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;park_timeout&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebca8bdf54e76e24d82dc68f6b0bc04c50c7f47f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e960174a6840a72333f0c4af39164868fd34c4f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;struct.vec#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vec#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in the &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bbc8b66ff470f012eb3c0cc67e657fee2b3c01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Fn&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly and without mutating state (e.g., when calling it concurrently). If you do not need such strict requirements, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as bounds.</source>
          <target state="translated">当您要接受类似函数的类型的参数并且需要重复调​​用且不改变状态（例如，同时调用它）时，请使用 &lt;code&gt;Fn&lt;/code&gt; 作为绑定。如果不需要严格的要求，请使用&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;作为边界。</target>
        </trans-unit>
        <trans-unit id="606e32d3718b3ad9261ab53d0c58fffdae2c3eb7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnMut&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly, while allowing it to mutate state. If you don't want the parameter to mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a bound; if you don't need to call it repeatedly, use &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当您要接受类似函数类型的参数并需要反复调用它，同时允许其改变状态时，请使用 &lt;code&gt;FnMut&lt;/code&gt; 作为绑定。如果您不希望参数改变状态，请使用&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;作为绑定；如果您不需要重复调​​用它，请使用&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0490417243191fd2b7e8ec23e8ffa3dcdc8fa81b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnOnce&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and only need to call it once. If you need to call the parameter repeatedly, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a bound; if you also need it to not mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当您想接受类似函数的类型的参数并且只需要调用一次时，可以使用 &lt;code&gt;FnOnce&lt;/code&gt; 作为绑定。如果需要重复调​​用该参数，请使用&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;作为绑定；如果还需要它不改变状态，请使用&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58e9a37a75f6d151dc00d0d282a3a92ae64a1400" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ThreadPool&lt;/code&gt; to perform some task other than serving web requests.</source>
          <target state="translated">使用 &lt;code&gt;ThreadPool&lt;/code&gt; 来执行某些任务，而不是处理Web请求。</target>
        </trans-unit>
        <trans-unit id="d84e22d164ffb7c941231da29582df4847d529a7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;async&lt;/code&gt; in front of &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;closure&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; to turn the marked code into a &lt;code&gt;Future&lt;/code&gt;. As such the code will not be run immediately, but will only be evaluated when the returned future is &lt;code&gt;.await&lt;/code&gt;ed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14f208baffea7d1c86f95f732b3ef39c695038a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprint!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;print!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">使用 &lt;code&gt;eprint!&lt;/code&gt; 仅用于错误和进度消息。使用 &lt;code&gt;print!&lt;/code&gt; 而是用于程序的主要输出。</target>
        </trans-unit>
        <trans-unit id="22665c8a7bbb569c824fae1113f4c37d6c60b38a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprintln!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;println!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">使用 &lt;code&gt;eprintln!&lt;/code&gt; 仅用于错误和进度消息。使用 &lt;code&gt;println!&lt;/code&gt; 而是用于程序的主要输出。</target>
        </trans-unit>
        <trans-unit id="c5580c57c536b501604c5a18501909570a4f8755" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mod&lt;/code&gt; to create new &lt;a href=&quot;../reference/items/modules&quot;&gt;modules&lt;/a&gt; to encapsulate code, including other modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ead4795448020930657e9470aadfc30b6e379b7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;print!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">使用 &lt;code&gt;print!&lt;/code&gt; 仅用于程序的主要输出。使用&lt;a href=&quot;macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt;而是打印错误和进度消息。</target>
        </trans-unit>
        <trans-unit id="8622f52bbce3eafc5d53c96e1ec31dc91867c0d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;println!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">使用 &lt;code&gt;println!&lt;/code&gt; 仅用于程序的主要输出。使用&lt;a href=&quot;macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt;而是打印错误和进度消息。</target>
        </trans-unit>
        <trans-unit id="4a325d56085ed8734f6810e0ff71ad595b95fd50" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BTreeMap&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;BTreeMap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c5b8b83e450ccf5b057f6e9cdd558c50e56abe87" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BinaryHeap&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;BinaryHeap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c44210c4cd02de7b469e04353c99013251f0bdb6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;HashMap&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;HashMap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="461b6ce24b45cd8f2525e7819f63e5f3b7e5d4c8" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;LinkedList&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;LinkedList&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f8effe57e9b8b3183f9d4a4c43ec54816a50215a" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:</source>
          <target state="translated">使用 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 作为有效的堆栈：</target>
        </trans-unit>
        <trans-unit id="18acad408e22b76af330889473712392d945f0e6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;Vec&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="610593fe7c0408bbb0f35796499627c6f2245b92" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;VecDeque&lt;/code&gt; when:</source>
          <target state="translated">在以下情况下使用 &lt;code&gt;VecDeque&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="928e71deb9616cde37637c874eca1ef7178b77b4" translate="yes" xml:space="preserve">
          <source>Use a slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c1eb662164587065262615f820c57ffe90b9ef" translate="yes" xml:space="preserve">
          <source>Use an array with a fixed length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa019f3006a2c79cffd1cb8f757987c40c32ebd5" translate="yes" xml:space="preserve">
          <source>Use declarations</source>
          <target state="translated">使用声明</target>
        </trans-unit>
        <trans-unit id="4285ed0690ab255637e0ac148f5c792cd6b8149b" translate="yes" xml:space="preserve">
          <source>Use declarations support a number of convenient shortcuts:</source>
          <target state="translated">使用声明支持一些方便的快捷方式。</target>
        </trans-unit>
        <trans-unit id="1d940a95921bf352b68ae08ab069e2750541ca02" translate="yes" xml:space="preserve">
          <source>Use of a &lt;code&gt;str&lt;/code&gt; whose contents are not valid UTF-8 is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d154502a3f5f6795f896efa6e13908d9370d8f9a" translate="yes" xml:space="preserve">
          <source>Use of generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5acc62e88ff47e84c111044c30c66db333ca88" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax to write data to the standard output. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">使用&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;将数据写入标准输出的语法。有关更多信息，请参见&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fbe9e80ba417914254163793e464ee62322f093" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ptr/fn.null_mut&quot;&gt;&lt;code&gt;null_mut&lt;/code&gt;&lt;/a&gt; functions to create null pointers, and the &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt;&lt;code&gt;is_null&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types to check for null. The &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types also define the &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; method, for pointer math.</source>
          <target state="translated">使用&lt;a href=&quot;ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ptr/fn.null_mut&quot;&gt; &lt;code&gt;null_mut&lt;/code&gt; &lt;/a&gt;函数创建空指针，并使用 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 类型的&lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt; &lt;code&gt;is_null&lt;/code&gt; &lt;/a&gt;方法检查空值。的 &lt;code&gt;*const T&lt;/code&gt; 和 &lt;code&gt;*mut T&lt;/code&gt; 类型还定义了&lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;法中，指针数学。</target>
        </trans-unit>
        <trans-unit id="2e570be59fc7fd5ff7530405783a29f5828f0fe8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Set&lt;/code&gt; variant of any of these &lt;code&gt;Map&lt;/code&gt;s when:</source>
          <target state="translated">在以下情况下，请使用任何这些 &lt;code&gt;Map&lt;/code&gt; 的 &lt;code&gt;Set&lt;/code&gt; 变体：</target>
        </trans-unit>
        <trans-unit id="e80c04da83a86a4ecbf94ec7503d652753e12266" translate="yes" xml:space="preserve">
          <source>Use the code in Listing 12-1 to allow your &lt;code&gt;minigrep&lt;/code&gt; program to read any command line arguments passed to it and then collect the values into a vector.</source>
          <target state="translated">使用清单12-1中的代码，您的 &lt;code&gt;minigrep&lt;/code&gt; 程序可以读取传递给它的任何命令行参数，然后将值收集到向量中。</target>
        </trans-unit>
        <trans-unit id="b7e242e19e576b066c1fbe08cfb0b75455ae8cac" translate="yes" xml:space="preserve">
          <source>Use the same lifetime requirement for both input and output values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a96fe96ad1c2ec9146b51dd14fea6aa97e8389" translate="yes" xml:space="preserve">
          <source>Use this function only when you can prove that the code will never call it. Otherwise, consider using the &lt;a href=&quot;../macro.unreachable&quot;&gt;&lt;code&gt;unreachable!&lt;/code&gt;&lt;/a&gt; macro, which does not allow optimizations but will panic when executed.</source>
          <target state="translated">仅在可以证明代码永远不会调用它时，才使用此函数。否则，请考虑使用&lt;a href=&quot;../macro.unreachable&quot;&gt; &lt;code&gt;unreachable!&lt;/code&gt; &lt;/a&gt;宏，该宏不允许进行优化，但在执行时会出现恐慌。</target>
        </trans-unit>
        <trans-unit id="d6a3c9f03120ec47a98d4a452b1e2127aae8581a" translate="yes" xml:space="preserve">
          <source>Used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeFull&lt;/code&gt; produces the full array as a slice.</source>
          <target state="translated">用作&lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;切片索引时&lt;/a&gt;， &lt;code&gt;RangeFull&lt;/code&gt; 产生完整的数组作为切片。</target>
        </trans-unit>
        <trans-unit id="0ee0968c281548e8c4956da0bb80d17ce6a46d94" translate="yes" xml:space="preserve">
          <source>Used for immutable dereferencing operations, like &lt;code&gt;*v&lt;/code&gt;.</source>
          <target state="translated">用于不可变的取消引用操作，例如 &lt;code&gt;*v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4b9aeea072b24e3f199cbe699727a85aca473bd" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in immutable contexts.</source>
          <target state="translated">用于不可变上下文中的索引操作（ &lt;code&gt;container[index]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6a6db850fe7a0893deca48224e890877525cf009" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in mutable contexts.</source>
          <target state="translated">用于可变上下文中的索引操作（ &lt;code&gt;container[index]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b8ea53757bb98a6b5189506b4ea7e3a3e9a3ec16" translate="yes" xml:space="preserve">
          <source>Used for mutable dereferencing operations, like in &lt;code&gt;*v = 1;&lt;/code&gt;.</source>
          <target state="translated">用于可变的解除引用操作，例如 &lt;code&gt;*v = 1;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fe043543944b7d7b206d45160cd5299a8af93e5" translate="yes" xml:space="preserve">
          <source>Used to create a default &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; instance for types that implement &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于为实现&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; 的&lt;/a&gt;类型创建默认的&lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="8e28b1efed767d7b3e60d0a7700706d6642dda67" translate="yes" xml:space="preserve">
          <source>Used to do a cheap mutable-to-mutable reference conversion.</source>
          <target state="translated">用来做廉价的可变到可变的参考转换。</target>
        </trans-unit>
        <trans-unit id="f1b7626a3b6465a294975154f6e043096ec5995f" translate="yes" xml:space="preserve">
          <source>Used to do a cheap reference-to-reference conversion.</source>
          <target state="translated">用来做廉价的参考文献到参考文献的转换。</target>
        </trans-unit>
        <trans-unit id="14c0b7ffa101db42d6f394a0ed0a2a772e18316c" translate="yes" xml:space="preserve">
          <source>Used to do value-to-value conversions while consuming the input value. It is the reciprocal of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于在消耗输入值的同时进行值到值的转换。这是&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;的倒数。</target>
        </trans-unit>
        <trans-unit id="87832790df189d88ca8070bb6de895ef1d392b7c" translate="yes" xml:space="preserve">
          <source>Used to make try_fold closures more like normal loops</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e26b00e1661d4c5dea648883f63653b80651f39" translate="yes" xml:space="preserve">
          <source>Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.</source>
          <target state="translated">当一个值超出范围时,用来运行一些代码。这有时被称为 &quot;destructor&quot;。</target>
        </trans-unit>
        <trans-unit id="5dc9662fcc8a7efba76268741a2aa91414af229f" translate="yes" xml:space="preserve">
          <source>Useful synchronization primitives.</source>
          <target state="translated">有用的同步基元。</target>
        </trans-unit>
        <trans-unit id="b05cb9060bef7e9cf540890d5647fd3ffbac6f9d" translate="yes" xml:space="preserve">
          <source>User lacks permissions to create directory at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">用户缺乏在 &lt;code&gt;path&lt;/code&gt; 创建目录的权限。</target>
        </trans-unit>
        <trans-unit id="01ed5872aedec24d23d900d1581e6ff53ed21665" translate="yes" xml:space="preserve">
          <source>User-defined types:</source>
          <target state="translated">用户定义的类型。</target>
        </trans-unit>
        <trans-unit id="62be4731dedfbbc70aa7fa30d6649d816af8ca4b" translate="yes" xml:space="preserve">
          <source>Uses</source>
          <target state="translated">Uses</target>
        </trans-unit>
        <trans-unit id="55cf66299b4b2f9f7eb9ea6abdf809a42de50634" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning.</source>
          <target state="translated">使用借来的数据来替换拥有的数据,通常是通过克隆。</target>
        </trans-unit>
        <trans-unit id="01c085ac9a4eda7ad0e1fc8b863d1b23ac3713d3" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1a7e308c9ce8c72dc79594fe592d8ac0e474a60" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41f5a93c96209d01bd88a54a350a97a8859d2caf" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="527bd4367972a752863741d60fd99d8435d00fca" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb87bc230d96c818f8f39be65a97f0f0c56ca879" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使用借来的数据来替换拥有的数据，通常通过克隆。&lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e92ce0c09d5d2c377945a784545c389cc7e9354" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt;&lt;/a&gt;, a.k.a. the &lt;code&gt;memcpy32&lt;/code&gt;and &lt;code&gt;memcpy64&lt;/code&gt; intrinsics, on overlapping buffers.</source>
          <target state="translated">在重叠缓冲区上使用&lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt; &lt;/a&gt;，也称为 &lt;code&gt;memcpy32&lt;/code&gt; 和 &lt;code&gt;memcpy64&lt;/code&gt; 内部函数。</target>
        </trans-unit>
        <trans-unit id="6e1dcc3d8137ddd7e3681f9bc104f285826b7f48" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; as success ordering makes the store part of this operation &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;, and using &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; makes the final successful load &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;. The (failed) load ordering can only be &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; and must be equivalent to or weaker than the success ordering.</source>
          <target state="translated">利用&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;的成功订货，使该操作的商店部分&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;，并利用&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;使得最终成功加载&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;。（失败）负载排序只能是&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; ,&lt;/a&gt;并且必须等于或弱于成功排序。</target>
        </trans-unit>
        <trans-unit id="7a6e8bfcb648c037a665b572caa617368582e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;Iterator::collect()&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6057ce3700db1903febbd4571a9030f98dccb52" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;隐式使用 &lt;code&gt;FromIterator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8581b668b89dc42d1d55734cab92752391e678b" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; Like a Reference</source>
          <target state="translated">像参考一样使用 &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2786f97dc365e66bda997868734cec33ef9fcf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Get a Recursive Type with a Known Size</source>
          <target state="translated">使用 &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 获取已知大小的递归类型</target>
        </trans-unit>
        <trans-unit id="8300c99c1ff66e26c9f9b017e5522a93d571ce81" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Point to Data on the Heap</source>
          <target state="translated">使用 &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 指向堆上的数据</target>
        </trans-unit>
        <trans-unit id="c4104bedba70839a84674c526e20638655c760d0" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; Functions to Call External Code</source>
          <target state="translated">使用 &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; 函数调用外部代码</target>
        </trans-unit>
        <trans-unit id="39a61fb39b0b2c2b47e27003fb9ca80ee4d7ca24" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; in a &lt;code&gt;let&lt;/code&gt; Statement</source>
          <target state="translated">在 &lt;code&gt;let&lt;/code&gt; 语句中使用 &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17f21cd4682f3498e05d46c9ba5f0db1ecf73ca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; Trait Methods Instead of Indexing</source>
          <target state="translated">使用 &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; 特征方法代替索引</target>
        </trans-unit>
        <trans-unit id="cd4dbe3102cc8a86458c21a6edcf0745a3880b2c" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; Closures with Threads</source>
          <target state="translated">在线程中使用 &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; 闭包</target>
        </trans-unit>
        <trans-unit id="bcb24e74610f11ffcd8b36fc02251143626de877" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to Share Data</source>
          <target state="translated">使用 &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 共享数据</target>
        </trans-unit>
        <trans-unit id="4bedcde0cd8963bedfb716621a284a40e61ba006" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in Tests</source>
          <target state="translated">在测试中使用 &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d4e8a0abd2628d1463a51e66037adf55b78b3eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;#[repr(C)]&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;#[repr(C)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfc71d2f097570894eba309d1d3e23fc1440f195" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ，其中右手参数大于或等于左手参数类型中的位数，或者为负数。</target>
        </trans-unit>
        <trans-unit id="b645209e67cee4f9f92c20f0e033dab698fba2f2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; ，其中左手参数是有符号整数类型的最小整数，右手参数为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d0998ec9f168a2eeef48fd713f566a42f1d1993" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@&lt;/code&gt; lets us test a value and save it in a variable within one pattern.</source>
          <target state="translated">使用 &lt;code&gt;@&lt;/code&gt; 让我们测试一个值并将其保存在一个模式内的变量中。</target>
        </trans-unit>
        <trans-unit id="1ae9824a370d1fed45ea9444f749e0c2d3a71823" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;AsMut&lt;/code&gt; as trait bound for a generic function we can accept all mutable references that can be converted to type &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; we can write a function &lt;code&gt;add_one&lt;/code&gt; that takes all arguments that can be converted to &lt;code&gt;&amp;amp;mut u64&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;add_one&lt;/code&gt; accepts arguments of type &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; as well:</source>
          <target state="translated">使用 &lt;code&gt;AsMut&lt;/code&gt; 作为通用函数的特征绑定，我们可以接受所有可以转换为 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 类型的可变引用。因为&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;实现了 &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; 我们可以编写一个函数 &lt;code&gt;add_one&lt;/code&gt; ，该函数接受可以转换为 &lt;code&gt;&amp;amp;mut u64&lt;/code&gt; 的所有参数。因为&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;实现 &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;add_one&lt;/code&gt; 接受 &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; 类型的参数：</target>
        </trans-unit>
        <trans-unit id="e5f61609aec29d1aa58bf125645b7b8bf1c8648b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BuildHasherDefault&lt;/code&gt; to specify a custom &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 为&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;指定自定义&lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="741ce1478263e946f77de5614872f7257f7d9bd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;TcpListener&lt;/code&gt;, we can listen for TCP connections at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt;. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn&amp;rsquo;t represent the authors&amp;rsquo; computer specifically), and &lt;code&gt;7878&lt;/code&gt; is the port. We&amp;rsquo;ve chosen this port for two reasons: HTTP is normally accepted on this port, and 7878 is &lt;em&gt;rust&lt;/em&gt; typed on a telephone.</source>
          <target state="translated">使用 &lt;code&gt;TcpListener&lt;/code&gt; ，我们可以在地址 &lt;code&gt;127.0.0.1:7878&lt;/code&gt; 侦听TCP连接。在地址中，冒号前的部分是代表您的计算机的IP地址（每台计算机上的IP地址都相同，并且并不特别代表作者的计算机），端口 &lt;code&gt;7878&lt;/code&gt; 是该端口。我们选择此端口的原因有两个：通常在此端口上接受HTTP，而在电话上键入7878则为&lt;em&gt;rust&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9d282af0a0db5a0f3935d90926c6551a24490d56" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cargo&lt;/code&gt;, Rust&amp;rsquo;s package manager and build system</source>
          <target state="translated">使用 &lt;code&gt;cargo&lt;/code&gt; ，Rust的包裹管理器和构建系统</target>
        </trans-unit>
        <trans-unit id="063f2ebb8c76224924321e7e9857525474aed57a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用 &lt;code&gt;collect()&lt;/code&gt; 创建一个&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="781d7dd79f196f5deffe456d6e4de88c8628e79c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths()&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb72794ee8412b2ec8c4ed130b77aa3fe94a4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">结合使用 &lt;code&gt;env::join_paths&lt;/code&gt; 和&lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths&lt;/code&gt; &lt;/a&gt;可以将项目附加到 &lt;code&gt;PATH&lt;/code&gt; 环境变量中：</target>
        </trans-unit>
        <trans-unit id="883e296f0933a9796d7609478617eb9fc57e41d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; as a &quot;do nothing&quot; base case in a conditional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145643f8069cc90bb1d66393cde6c665263c5694" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing among other interesting functions:</source>
          <target state="translated">在其他有趣的功能中，使用 &lt;code&gt;identity&lt;/code&gt; 不做任何事情：</target>
        </trans-unit>
        <trans-unit id="f1235a5ac3f06cf39c5a154506b55894e72fe10a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing in a sequence of other, interesting, functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c92b7b9d3a5d2fd97452ae43966326ca17955c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to get a function that changes nothing in a conditional:</source>
          <target state="translated">使用 &lt;code&gt;identity&lt;/code&gt; 获取在条件中不变的函数：</target>
        </trans-unit>
        <trans-unit id="8a03c63b02cfcec88b468a3f0a4f356859de8742" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to keep the &lt;code&gt;Some&lt;/code&gt; variants of an iterator of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;identity&lt;/code&gt; 保留 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 的迭代器的 &lt;code&gt;Some&lt;/code&gt; 变体：</target>
        </trans-unit>
        <trans-unit id="b86b145b4aec4479f3e7888989e9c6f53ce3db7d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;if let&lt;/code&gt; means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that &lt;code&gt;match&lt;/code&gt; enforces. Choosing between &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;if let&lt;/code&gt; depends on what you&amp;rsquo;re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</source>
          <target state="translated">使用 &lt;code&gt;if let&lt;/code&gt; 意味着更少的键入，更少的缩进和更少的样板代码。但是，您将丢失 &lt;code&gt;match&lt;/code&gt; 实施的详尽检查。在 &lt;code&gt;match&lt;/code&gt; 和 &lt;code&gt;if let&lt;/code&gt; 进行比赛之间进行选择取决于您在特定情况下的工作方式以及是否获得简洁性是失去详尽检查的适当权衡。</target>
        </trans-unit>
        <trans-unit id="7b98e766b3b912d79bb4b0c519c379c12d658619" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;match&lt;/code&gt; works well enough, but it can be a bit verbose and doesn&amp;rsquo;t always communicate intent well. The &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many helper methods defined on it to do various tasks. One of those methods, called &lt;code&gt;unwrap&lt;/code&gt;, is a shortcut method that is implemented just like the &lt;code&gt;match&lt;/code&gt; expression we wrote in Listing 9-4. If the &lt;code&gt;Result&lt;/code&gt; value is the &lt;code&gt;Ok&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will return the value inside the &lt;code&gt;Ok&lt;/code&gt;. If the &lt;code&gt;Result&lt;/code&gt; is the &lt;code&gt;Err&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will call the &lt;code&gt;panic!&lt;/code&gt; macro for us. Here is an example of &lt;code&gt;unwrap&lt;/code&gt; in action:</source>
          <target state="translated">使用 &lt;code&gt;match&lt;/code&gt; 效果很好，但是可能有点冗长，而且不一定总是很好地传达意图。该 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 类型上定义执行各种任务的许多辅助方法。其中一种方法称为 &lt;code&gt;unwrap&lt;/code&gt; ，是一种快捷方法，其实现方式 &lt;code&gt;match&lt;/code&gt; 清单9-4中编写的match表达式相同。如果 &lt;code&gt;Result&lt;/code&gt; 值是 &lt;code&gt;Ok&lt;/code&gt; 变量，则 &lt;code&gt;unwrap&lt;/code&gt; 将在 &lt;code&gt;Ok&lt;/code&gt; 内部返回值。如果 &lt;code&gt;Result&lt;/code&gt; 是 &lt;code&gt;Err&lt;/code&gt; 变体，则 &lt;code&gt;unwrap&lt;/code&gt; 将引起 &lt;code&gt;panic!&lt;/code&gt; 对我们来说是宏。这里是一个例子 &lt;code&gt;unwrap&lt;/code&gt; 实际上：</target>
        </trans-unit>
        <trans-unit id="716d3b2c36a0e8f26b1196bb5c8509c4d656cdaa" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mul_add&lt;/code&gt; can be more performant than an unfused multiply-add if the target architecture has a dedicated &lt;code&gt;fma&lt;/code&gt; CPU instruction.</source>
          <target state="translated">如果目标体系结构具有专用的 &lt;code&gt;fma&lt;/code&gt; CPU指令，则使用 &lt;code&gt;mul_add&lt;/code&gt; 会比未融合的乘法加法更具性能。</target>
        </trans-unit>
        <trans-unit id="b8c91e11b4f888f4c592a35e44ac17004a0fb755" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;println!&lt;/code&gt; directly:</source>
          <target state="translated">使用 &lt;code&gt;println!&lt;/code&gt; 直：</target>
        </trans-unit>
        <trans-unit id="4e19595061858aceb197932ab33548b4e2d9024e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;to_string&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;to_string&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9355d5eaee5786ccc5834b09b61c0a558e231c8f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe {}&lt;/code&gt; blocks and &lt;code&gt;impl&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd1e2fb0a495ca1deedb73f663b2b41b48287c3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the five actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems when they occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e77887900c6717f9133b9abc150eed86948327" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the four actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems if they occur.</source>
          <target state="translated">使用 &lt;code&gt;unsafe&lt;/code&gt; 行为采取上述四个动作（超级大国）之一并没有错，甚至没有皱眉。但是正确获取 &lt;code&gt;unsafe&lt;/code&gt; 代码比较棘手，因为编译器无法帮助维护内存安全性。当您有理由使用 &lt;code&gt;unsafe&lt;/code&gt; 代码时，可以这样做，并且拥有显式的 &lt;code&gt;unsafe&lt;/code&gt; 注释可以更容易地找出问题的根源。</target>
        </trans-unit>
        <trans-unit id="079ef6902b572fab1f5b45933254dfd23aa7b9b5" translate="yes" xml:space="preserve">
          <source>Using Closures that Capture Their Environment</source>
          <target state="translated">使用能捕捉环境的闭合装置</target>
        </trans-unit>
        <trans-unit id="356483451b80563e823eec07c158f3c0e2a19756" translate="yes" xml:space="preserve">
          <source>Using External Packages</source>
          <target state="translated">使用外部包</target>
        </trans-unit>
        <trans-unit id="195ec6c54d68d4bc74c1c0e9e4aa71e8ed1d66dc" translate="yes" xml:space="preserve">
          <source>Using Message Passing to Transfer Data Between Threads</source>
          <target state="translated">使用消息传递在线程之间传输数据。</target>
        </trans-unit>
        <trans-unit id="1f1119d00f411f28a788c634b094f7830af90354" translate="yes" xml:space="preserve">
          <source>Using Mutexes to Allow Access to Data from One Thread at a Time</source>
          <target state="translated">使用互斥允许一次访问一个线程的数据</target>
        </trans-unit>
        <trans-unit id="0f71d9d6c5e4eb6b3d84f4f1645f9d37c7834e08" translate="yes" xml:space="preserve">
          <source>Using Nested Paths to Clean Up Large &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; Lists</source>
          <target state="translated">使用嵌套路径清理大型 &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; 列表</target>
        </trans-unit>
        <trans-unit id="d061dfad64af5ced98da4099941d9962a4cf4ab6" translate="yes" xml:space="preserve">
          <source>Using Other &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; Trait Methods</source>
          <target state="translated">使用其他 &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; 特征方法</target>
        </trans-unit>
        <trans-unit id="90caab8414681ad380cd72175835d7d3a714a974" translate="yes" xml:space="preserve">
          <source>Using Our &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; Iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">使用我们的 &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; 迭代器的 &lt;code&gt;next&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="4a36ca6063affef138895d5e70695435940c7941" translate="yes" xml:space="preserve">
          <source>Using Statics or Consts</source>
          <target state="translated">使用静态或静态</target>
        </trans-unit>
        <trans-unit id="1d80a86fe9446545a29df6fe583694b8305fad7f" translate="yes" xml:space="preserve">
          <source>Using Structs to Structure Related Data</source>
          <target state="translated">使用Structs来构建相关数据</target>
        </trans-unit>
        <trans-unit id="1725c7720c6951cb5321da47bdec76e1efb5b498" translate="yes" xml:space="preserve">
          <source>Using Supertraits to Require One Trait&amp;rsquo;s Functionality Within Another Trait</source>
          <target state="translated">使用超性要求一个特质在另一个特质内的功能</target>
        </trans-unit>
        <trans-unit id="e5f7eb8898bb60910740832d2142728eab94b626" translate="yes" xml:space="preserve">
          <source>Using Threads to Run Code Simultaneously</source>
          <target state="translated">使用线程同时运行代码</target>
        </trans-unit>
        <trans-unit id="9c88360016895ec6069e43a4e277e7bdb51ba9ed" translate="yes" xml:space="preserve">
          <source>Using Trait Bounds to Conditionally Implement Methods</source>
          <target state="translated">使用特质边界来有条件地实现方法</target>
        </trans-unit>
        <trans-unit id="b4544e80831327296977b0f0c1bed06cd890a1fd" translate="yes" xml:space="preserve">
          <source>Using Trait Objects That Allow for Values of Different Types</source>
          <target state="translated">使用允许不同类型值的特征对象。</target>
        </trans-unit>
        <trans-unit id="735958a37951062c949a84a063e5b1d398369b00" translate="yes" xml:space="preserve">
          <source>Using Tuple Structs without Named Fields to Create Different Types</source>
          <target state="translated">使用没有命名字段的元组结构来创建不同的类型。</target>
        </trans-unit>
        <trans-unit id="675231858eb84206141ae12e664714cc21d2c19b" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Store Data on the Heap</source>
          <target state="translated">使用 &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 将数据存储在堆上</target>
        </trans-unit>
        <trans-unit id="f84a17c2b7b640800d3c95a6c6874936d40e4172" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; Backtrace</source>
          <target state="translated">使用 &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; 回溯</target>
        </trans-unit>
        <trans-unit id="fa90ed41bcf90ab01a0c0386a65d7892a205380d" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Fn&lt;/code&gt; parameter</source>
          <target state="translated">使用 &lt;code&gt;Fn&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="c233f257ce2f61e1743d09ba4202b368e77eac25" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnMut&lt;/code&gt; parameter</source>
          <target state="translated">使用 &lt;code&gt;FnMut&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="c47fce11968d69df2be1beb510ac309f7cc7fe1c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnOnce&lt;/code&gt; parameter</source>
          <target state="translated">使用 &lt;code&gt;FnOnce&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="eaa2ddbdb2af4f1c7b600386f3ab5d07fb639266" translate="yes" xml:space="preserve">
          <source>Using a Crate to Get More Functionality</source>
          <target state="translated">使用木箱获得更多功能</target>
        </trans-unit>
        <trans-unit id="5490ba3cbb37583be424e7381702b1ad23cc8d1f" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在将争用锁由在不同CPU上执行的另一个线程持有竞争锁并且等待时间相对较短的情况下，理想地使用带有 &lt;code&gt;spin_loop&lt;/code&gt; 的繁忙等待自旋循环。因为进入忙等待自旋循环不会触发系统的调度程序，所以切换线程不会产生任何开销。但是，如果持有竞争锁的线程在同一CPU上运行，则自旋循环可能会在切换到持有锁的线程之前占据整个CPU片。如果竞争锁由同一CPU上的线程持有，或者获取锁的等待时间较长，则通常最好使用&lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c1ce34ae6a3ca80d5e3bf4a0b0c41abaf191eae" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop_hint&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">理想情况下，将忙等待自旋循环与 &lt;code&gt;spin_loop_hint&lt;/code&gt; 一起使用时，争执的锁由在不同CPU上执行的另一个线程持有，并且等待时间相对较短。由于进入忙等待自旋循环不会触发系统的调度程序，因此不会发生切换线程的开销。但是，如果持有竞争锁的线程在同一CPU上运行，则自旋循环可能会在切换到持有锁的线程之前占据整个CPU片。如果竞争锁由同一CPU上的线程持有，或者获取锁的等待时间较长，则通常最好使用&lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b1ac01f9a3840dc6d78887aac134760ed5ceafe" translate="yes" xml:space="preserve">
          <source>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, &amp;ldquo;Add Sally to Engineering&amp;rdquo; or &amp;ldquo;Add Amir to Sales.&amp;rdquo; Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</source>
          <target state="translated">使用哈希图和向量创建一个文本界面，以允许用户将员工姓名添加到公司的部门中。例如，&amp;ldquo;将Sally添加到工程&amp;rdquo;或&amp;ldquo;将Amir添加到销售&amp;rdquo;。然后让用户检索部门中所有人员或部门中公司所有人员的列表，并按字母顺序排序。</target>
        </trans-unit>
        <trans-unit id="09dacd7c78dbd0bf44dabf88b33b52973a393ac8" translate="yes" xml:space="preserve">
          <source>Using a primitive representation in addition to &lt;code&gt;repr(C)&lt;/code&gt; can change the size of an enum from the &lt;code&gt;repr(C)&lt;/code&gt; form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c37907d281b1198f03324a18111844e539d53d" translate="yes" xml:space="preserve">
          <source>Using a search key that doesn't work with the Borrow trait</source>
          <target state="translated">使用搜索键不能与 &quot;借用 &quot;特性一起使用。</target>
        </trans-unit>
        <trans-unit id="cd14ecb207f28002c37a4e53dc6c1cebfa5f2ee9" translate="yes" xml:space="preserve">
          <source>Using a semicolon after &lt;code&gt;mod front_of_house&lt;/code&gt; rather than using a block tells Rust to load the contents of the module from another file with the same name as the module. To continue with our example and extract the &lt;code&gt;hosting&lt;/code&gt; module to its own file as well, we change &lt;em&gt;src/front_of_house.rs&lt;/em&gt; to contain only the declaration of the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="translated">在 &lt;code&gt;mod front_of_house&lt;/code&gt; 之后使用分号（而不是使用块）会告诉Rust从另一个与模块同名的文件中加载模块的内容。为了继续我们的示例并将 &lt;code&gt;hosting&lt;/code&gt; 模块也提取到其自己的文件中，我们将&lt;em&gt;src / front_of_house.rs&lt;/em&gt;更改为仅包含 &lt;code&gt;hosting&lt;/code&gt; 模块的声明：</target>
        </trans-unit>
        <trans-unit id="fe93078130b3109ad5108e782dba78cf01903057" translate="yes" xml:space="preserve">
          <source>Using a tuple of &lt;code&gt;Bound&lt;/code&gt;s as an argument to &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt;&lt;code&gt;BTreeMap::range&lt;/code&gt;&lt;/a&gt;. Note that in most cases, it's better to use range syntax (&lt;code&gt;1..5&lt;/code&gt;) instead.</source>
          <target state="translated">使用 &lt;code&gt;Bound&lt;/code&gt; 的元组作为&lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt; &lt;code&gt;BTreeMap::range&lt;/code&gt; &lt;/a&gt;的参数。请注意，在大多数情况下，最好使用范围语法（ &lt;code&gt;1..5&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="015c01b29f1c8ebb6c4c8943a2dc3adcbae06181" translate="yes" xml:space="preserve">
          <source>Using an Enum to Store Multiple Types</source>
          <target state="translated">使用一个枚举来存储多个类型</target>
        </trans-unit>
        <trans-unit id="b5882a2dc057a0d8d156ec2e30b99dd996e5bdcc" translate="yes" xml:space="preserve">
          <source>Using built-in default values:</source>
          <target state="translated">使用内置的默认值。</target>
        </trans-unit>
        <trans-unit id="f3dacd0d875f3e763ce98391694ffe59eeffec43" translate="yes" xml:space="preserve">
          <source>Using custom comparison logic without newtype wrappers</source>
          <target state="translated">使用自定义比较逻辑而不使用新类型包装器</target>
        </trans-unit>
        <trans-unit id="a4db67f6f9b0784800ae988e7704553e6de06b09" translate="yes" xml:space="preserve">
          <source>Using default values:</source>
          <target state="translated">使用默认值。</target>
        </trans-unit>
        <trans-unit id="8ec600b0ec907749b0fdd372e79b0c70b7b0dce0" translate="yes" xml:space="preserve">
          <source>Using enums has even more advantages. Thinking more about our IP address type, at the moment we don&amp;rsquo;t have a way to store the actual IP address &lt;em&gt;data&lt;/em&gt;; we only know what &lt;em&gt;kind&lt;/em&gt; it is. Given that you just learned about structs in Chapter 5, you might tackle this problem as shown in Listing 6-1.</source>
          <target state="translated">使用枚举具有更多优势。考虑更多关于我们的IP地址类型的信息，目前我们还没有办法存储实际的IP地址&lt;em&gt;数据&lt;/em&gt;；我们只知道什么&lt;em&gt;样&lt;/em&gt;是。既然您刚刚在第5章中了解了结构，就可以解决此问题，如清单6-1所示。</target>
        </trans-unit>
        <trans-unit id="3e92abb62f29a9ab743c0868201fc7c6f7cc104c" translate="yes" xml:space="preserve">
          <source>Using explicit synchronization:</source>
          <target state="translated">使用显性同步。</target>
        </trans-unit>
        <trans-unit id="26140a4b00b6db68bc5c08aa7b59f4de9a496d44" translate="yes" xml:space="preserve">
          <source>Using implicit synchronization:</source>
          <target state="translated">使用隐性同步。</target>
        </trans-unit>
        <trans-unit id="0964494ac4fd47f86d6e1abd134d8f88a80450c7" translate="yes" xml:space="preserve">
          <source>Using mutation and going finite:</source>
          <target state="translated">利用突变和去有限。</target>
        </trans-unit>
        <trans-unit id="c5cfc67f6bee08fd41a46b1d08f1ad9861c6e196" translate="yes" xml:space="preserve">
          <source>Using path qualifiers like &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword.super&quot;&gt;&lt;code&gt;super&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.self&quot;&gt;&lt;code&gt;self&lt;/code&gt;&lt;/a&gt; is supported: &lt;code&gt;use crate::a::b;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5b3892671b9cc1bcba84f83ea8ba99412282b3" translate="yes" xml:space="preserve">
          <source>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax &lt;code&gt;..&lt;/code&gt; specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</source>
          <target state="translated">使用struct update语法，我们可以用更少的代码来达到相同的效果，如清单5-7所示。语法 &lt;code&gt;..&lt;/code&gt; 指定未明确设置的其余字段应与给定实例中的字段具有相同的值。</target>
        </trans-unit>
        <trans-unit id="149131436ae6fcc58b9d3b44704c0a4f62b58b80" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:</source>
          <target state="translated">使用&amp;ldquo; turbofish&amp;rdquo;而不是注释 &lt;code&gt;doubled&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1fee5723d61f0a87e52c62c70350b33d4a2c1211" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;four&lt;/code&gt;:</source>
          <target state="translated">使用&amp;ldquo; turbofish&amp;rdquo;而不是注释 &lt;code&gt;four&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8dca1dfea48258776a757d0e7fdd52e32ddc6d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; Function in the &lt;code&gt;run&lt;/code&gt; Function</source>
          <target state="translated">在 &lt;code&gt;run&lt;/code&gt; 功能中使用 &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="73cb7c6eceba8574fdab292dc3c5b0a2f2322727" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&lt;/code&gt; type to store the list &lt;code&gt;1, 2, 3&lt;/code&gt; would look like the code in Listing 15-3:</source>
          <target state="translated">使用 &lt;code&gt;List&lt;/code&gt; 类型存储列表 &lt;code&gt;1, 2, 3&lt;/code&gt; 类似于清单15-3中的代码：</target>
        </trans-unit>
        <trans-unit id="707e73f8481ac39cdfa5e294240c14e577bab80b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;ref&lt;/code&gt; keyword, the value is only borrowed, not moved, making it available for use after the &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2545ef2f465dd4b2bb1fca4f7b62b633439903e" translate="yes" xml:space="preserve">
          <source>Using the Field Init Shorthand when Variables and Fields Have the Same Name</source>
          <target state="translated">当变量和字段名称相同时,使用字段初始化速记。</target>
        </trans-unit>
        <trans-unit id="527c6fc37f2c7ff511bb334d8bc01dfd4d796198" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern for Type Safety and Abstraction</source>
          <target state="translated">使用Newtype模式实现类型安全和抽象化</target>
        </trans-unit>
        <trans-unit id="0445dab15f95bbaf439f12315a2f6c2606b64d6c" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern to Implement External Traits on External Types</source>
          <target state="translated">使用Newtype模式在外部类型上实现外部特征。</target>
        </trans-unit>
        <trans-unit id="6efe08dd70627a6ae791a8f3c7e219c91abdce73" translate="yes" xml:space="preserve">
          <source>Using the Returned Iterator Directly</source>
          <target state="translated">直接使用返回的迭代器</target>
        </trans-unit>
        <trans-unit id="bfe1a641af30e378f1440126b6876e787e3aeb21" translate="yes" xml:space="preserve">
          <source>Using the state pattern means when the business requirements of the program change, we won&amp;rsquo;t need to change the code of the value holding the state or the code that uses the value. We&amp;rsquo;ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects. Let&amp;rsquo;s look at an example of the state design pattern and how to use it in Rust.</source>
          <target state="translated">使用状态模式意味着当程序的业务需求发生变化时，我们不需要更改保存状态的值的代码或使用该值的代码。我们只需要更新其中一个状态对象中的代码即可更改其规则或添加更多状态对象。让我们看一下状态设计模式的示例以及如何在Rust中使用它。</target>
        </trans-unit>
        <trans-unit id="f27958ea70e4427546613b6470c7b4a627139188" translate="yes" xml:space="preserve">
          <source>Using this declaration, it must be called with at least one argument, so simply calling &lt;code&gt;printf()&lt;/code&gt; is invalid. But the following uses are allowed:</source>
          <target state="translated">使用此声明，必须使用至少一个参数来调用它，因此简单地调用 &lt;code&gt;printf()&lt;/code&gt; 是无效的。但是允许以下用途：</target>
        </trans-unit>
        <trans-unit id="3febf8421408faebfe197da05a42aac2ff47af45" translate="yes" xml:space="preserve">
          <source>Using this definition, Rust is object oriented: structs and enums have data, and &lt;code&gt;impl&lt;/code&gt; blocks provide methods on structs and enums. Even though structs and enums with methods aren&amp;rsquo;t &lt;em&gt;called&lt;/em&gt; objects, they provide the same functionality, according to the Gang of Four&amp;rsquo;s definition of objects.</source>
          <target state="translated">使用此定义，Rust是面向对象的：结构和枚举具有数据，而 &lt;code&gt;impl&lt;/code&gt; 块提供有关结构和枚举的方法。根据&amp;ldquo;四人帮&amp;rdquo;对对象的定义，即使带有方法的结构和枚举不&lt;em&gt;被称为&lt;/em&gt;对象，它们也提供相同的功能。</target>
        </trans-unit>
        <trans-unit id="4bd35f75969eee3d765cd1e9dcbd0cf13c21dc8a" translate="yes" xml:space="preserve">
          <source>Using this function is generally faster than using &lt;code&gt;powf&lt;/code&gt;</source>
          <target state="translated">使用此功能通常比使用 &lt;code&gt;powf&lt;/code&gt; 更快</target>
        </trans-unit>
        <trans-unit id="c548fba9d029d6e16cb5aeebbb487347aada0fef" translate="yes" xml:space="preserve">
          <source>Using this macro is often a bad idea, because if the file is parsed as an expression, it is going to be placed in the surrounding code unhygienically. This could result in variables or functions being different from what the file expected if there are variables or functions that have the same name in the current file.</source>
          <target state="translated">使用这个宏通常是一个坏主意,因为如果文件被解析为表达式,它将被不卫生地放在周围的代码中。如果当前文件中存在名称相同的变量或函数,这可能会导致变量或函数与文件的预期不同。</target>
        </trans-unit>
        <trans-unit id="a7c45efccaaa01e2feb082b19ddba5a32324e6fa" translate="yes" xml:space="preserve">
          <source>Using this method is equivalent to the following code:</source>
          <target state="translated">使用这种方法相当于下面的代码。</target>
        </trans-unit>
        <trans-unit id="15e11a1b79c37f9d667f56c8b714852cef36b238" translate="yes" xml:space="preserve">
          <source>Using too many &lt;code&gt;else if&lt;/code&gt; expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called &lt;code&gt;match&lt;/code&gt; for these cases.</source>
          <target state="translated">&lt;code&gt;else if&lt;/code&gt; 表达式太多，可能会使代码混乱，因此如果使用多个表达式，则可能需要重构代码。第6章介绍了针对这些情况的功能强大的Rust分支构造，称为 &lt;code&gt;match&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e52bd27c5d26825ad08651412fd660a16f020f77" translate="yes" xml:space="preserve">
          <source>Using too many trait bounds has its downsides. Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function&amp;rsquo;s name and its parameter list, making the function signature hard to read. For this reason, Rust has alternate syntax for specifying trait bounds inside a &lt;code&gt;where&lt;/code&gt; clause after the function signature. So instead of writing this:</source>
          <target state="translated">使用太多特质界限有其缺点。每个泛型都有其自己的特征范围，因此具有多个泛型类型参数的函数可以在函数名称与其参数列表之间包含许多特征绑定信息，从而使函数签名难以阅读。因此，Rust具有备用语法，用于在函数签名后的 &lt;code&gt;where&lt;/code&gt; 子句中指定特征范围。所以不用写这个：</target>
        </trans-unit>
        <trans-unit id="e8270120e8e5872b95f691e94134c3c38cbe49b0" translate="yes" xml:space="preserve">
          <source>Using traits and lifetimes where appropriate (&lt;a href=&quot;ch10-00-generics&quot;&gt;Chapter 10&lt;/a&gt;)</source>
          <target state="translated">在适当的地方使用特征和寿命（&lt;a href=&quot;ch10-00-generics&quot;&gt;第10章&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1c8fe76861637e35d40bd85f3825d619bc84eadf" translate="yes" xml:space="preserve">
          <source>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</source>
          <target state="translated">使用不安全的功能有潜在的危险性,是安全检查所不允许的。例如:</target>
        </trans-unit>
        <trans-unit id="f903dfb928504d5e71a1ab430366f1a7eae7e14e" translate="yes" xml:space="preserve">
          <source>Using vectors and strings (collections, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;Chapter 8&lt;/a&gt;)</source>
          <target state="translated">使用向量和字符串（集合，&lt;a href=&quot;ch08-00-common-collections&quot;&gt;第8章&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="d6513e8f7510d42121946e2407ba6c2011fc2c1c" translate="yes" xml:space="preserve">
          <source>Usually a &lt;code&gt;use&lt;/code&gt; keyword is used to shorten the path required to refer to a module item. The keyword may appear in modules, blocks and even functions, usually at the top.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83a4fba159bee344e91cbe040d6123421c523d3" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't literally use &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; from Rust, but C APIs hand out a lot of pointers generally, so are a common source of raw pointers in Rust.</source>
          <target state="translated">通常，您实际上不会使用 &lt;code&gt;malloc&lt;/code&gt; 并从Rust中 &lt;code&gt;free&lt;/code&gt; 出来，但是C API通常会发出很多指针，因此Rust中的原始指针也很常见。</target>
        </trans-unit>
        <trans-unit id="906d4775d8872c7dc79527063674165dda2ccbc0" translate="yes" xml:space="preserve">
          <source>Usually, generic parameters get &lt;em&gt;monomorphized&lt;/em&gt;. For example, if I have</source>
          <target state="translated">通常，通用参数会&lt;em&gt;被单态化&lt;/em&gt;。例如，如果我有</target>
        </trans-unit>
        <trans-unit id="d259bb65f469f691c60fbc1cce6f48ae71721980" translate="yes" xml:space="preserve">
          <source>Usually, iterators iterate from left to right. After using &lt;code&gt;rev()&lt;/code&gt;, an iterator will instead iterate from right to left.</source>
          <target state="translated">通常，迭代器从左到右进行迭代。使用 &lt;code&gt;rev()&lt;/code&gt; 之后，迭代器将改为从右向左迭代。</target>
        </trans-unit>
        <trans-unit id="71c8b88aacf28ce47b0a58b2d2bc8a3fb05b911b" translate="yes" xml:space="preserve">
          <source>Utf8Error</source>
          <target state="translated">Utf8Error</target>
        </trans-unit>
        <trans-unit id="0dc56eae851492c66ecabf78d1bbaf00296acfbe" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow</source>
          <target state="translated">Utf8Error::borrow</target>
        </trans-unit>
        <trans-unit id="62c9947a079483bdf0d15d01617213826dc02f38" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow_mut</source>
          <target state="translated">Utf8Error::borrow_mut</target>
        </trans-unit>
        <trans-unit id="3f5e10da6a480e49a740c45c14fd97e4e299d73d" translate="yes" xml:space="preserve">
          <source>Utf8Error::cause</source>
          <target state="translated">Utf8Error::cause</target>
        </trans-unit>
        <trans-unit id="aba276798126f3d9e88abbf114717adc671724b0" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone</source>
          <target state="translated">Utf8Error::clone</target>
        </trans-unit>
        <trans-unit id="d9f741fd3eb062e41262e053f0eb1a689e8b68c8" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_from</source>
          <target state="translated">Utf8Error::clone_from</target>
        </trans-unit>
        <trans-unit id="6fb618053c3a87e8372bf0b005ef3aee33a2be29" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_into</source>
          <target state="translated">Utf8Error::clone_into</target>
        </trans-unit>
        <trans-unit id="5eb848f299ba96b5c68a3de5bf02961b034fb439" translate="yes" xml:space="preserve">
          <source>Utf8Error::description</source>
          <target state="translated">Utf8Error::description</target>
        </trans-unit>
        <trans-unit id="1e357eccf69d01f74bf39edbfab63655804a87a8" translate="yes" xml:space="preserve">
          <source>Utf8Error::eq</source>
          <target state="translated">Utf8Error::eq</target>
        </trans-unit>
        <trans-unit id="88f730d875142fa4beddb68ae32ca749e55c5da0" translate="yes" xml:space="preserve">
          <source>Utf8Error::error_len</source>
          <target state="translated">Utf8Error::error_len</target>
        </trans-unit>
        <trans-unit id="81707f4d43116cddc3b6180c7d1812770aa6aabd" translate="yes" xml:space="preserve">
          <source>Utf8Error::fmt</source>
          <target state="translated">Utf8Error::fmt</target>
        </trans-unit>
        <trans-unit id="80d9f3c5cc9b436bfc54741853eb348edcd31923" translate="yes" xml:space="preserve">
          <source>Utf8Error::from</source>
          <target state="translated">Utf8Error::from</target>
        </trans-unit>
        <trans-unit id="186ae2f6ff2c38ceed80692f48587dd9073b281b" translate="yes" xml:space="preserve">
          <source>Utf8Error::into</source>
          <target state="translated">Utf8Error::into</target>
        </trans-unit>
        <trans-unit id="da5d217600f498b06be2479022d36a4a5c15449b" translate="yes" xml:space="preserve">
          <source>Utf8Error::ne</source>
          <target state="translated">Utf8Error::ne</target>
        </trans-unit>
        <trans-unit id="65ff32fff52c3afe8fd1470fd4590b2fae222e96" translate="yes" xml:space="preserve">
          <source>Utf8Error::source</source>
          <target state="translated">Utf8Error::source</target>
        </trans-unit>
        <trans-unit id="d542954047d8755ad1a4e9a853bcf03561cdf1c9" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_owned</source>
          <target state="translated">Utf8Error::to_owned</target>
        </trans-unit>
        <trans-unit id="ef5e78b58ef441d19d975802cc905ce882b752c7" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_string</source>
          <target state="translated">Utf8Error::to_string</target>
        </trans-unit>
        <trans-unit id="eb1790431a34016d236cceca893cabedf79794fa" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_from</source>
          <target state="translated">Utf8Error::try_from</target>
        </trans-unit>
        <trans-unit id="d78057a09376f581ad70dcf23d55b916b4ec76d6" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_into</source>
          <target state="translated">Utf8Error::try_into</target>
        </trans-unit>
        <trans-unit id="77455bd6cede93b6937284b56ca0ee7128f3fcd5" translate="yes" xml:space="preserve">
          <source>Utf8Error::type_id</source>
          <target state="translated">Utf8Error::type_id</target>
        </trans-unit>
        <trans-unit id="061f930ae2881081028ec6f4738788ea0386348a" translate="yes" xml:space="preserve">
          <source>Utf8Error::valid_up_to</source>
          <target state="translated">Utf8Error::valid_up_to</target>
        </trans-unit>
        <trans-unit id="098996f33abfeafe0fd0a1060966a3bd981c2d4c" translate="yes" xml:space="preserve">
          <source>Utilities for formatting and printing &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">格式化和打印 &lt;code&gt;String&lt;/code&gt; 的实用程序。</target>
        </trans-unit>
        <trans-unit id="bbf05f92621e129ba6a9d6d71f520f94619321a3" translate="yes" xml:space="preserve">
          <source>Utilities related to FFI bindings.</source>
          <target state="translated">与FFI绑定有关的实用程序。</target>
        </trans-unit>
        <trans-unit id="2cfce7b7e1bbf22d999dd679513efd8dd1774d5b" translate="yes" xml:space="preserve">
          <source>Utility trait implemented only on arrays of fixed size</source>
          <target state="translated">仅在固定大小的数组上实现实用性特征。</target>
        </trans-unit>
        <trans-unit id="f4dc02e287a9f4de99799a5c31108f51723830a7" translate="yes" xml:space="preserve">
          <source>VXWorks</source>
          <target state="translated">VXWorks</target>
        </trans-unit>
        <trans-unit id="2a62ae9e6e10d5b4d844ad431e3d12dd6181892a" translate="yes" xml:space="preserve">
          <source>VaList</source>
          <target state="translated">VaList</target>
        </trans-unit>
        <trans-unit id="d3dc417a5e809aff4e928e1c2ccc9e1476eea745" translate="yes" xml:space="preserve">
          <source>VaList::arg</source>
          <target state="translated">VaList::arg</target>
        </trans-unit>
        <trans-unit id="e56bcc6610b1a8196319373f5b202bf4d9783931" translate="yes" xml:space="preserve">
          <source>VaList::as_va_list</source>
          <target state="translated">VaList::as_va_list</target>
        </trans-unit>
        <trans-unit id="93ccd0479992f30997a13f7a0291305d4a7bcf8f" translate="yes" xml:space="preserve">
          <source>VaList::borrow</source>
          <target state="translated">VaList::borrow</target>
        </trans-unit>
        <trans-unit id="14c647375c9b8191c6015d7e9763130b93ea3cb0" translate="yes" xml:space="preserve">
          <source>VaList::borrow_mut</source>
          <target state="translated">VaList::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c8adb5d15703c32cb6620339a1ad3a830f1ad937" translate="yes" xml:space="preserve">
          <source>VaList::deref</source>
          <target state="translated">VaList::deref</target>
        </trans-unit>
        <trans-unit id="ef4f8c0aefca94cf0351ab804dcb1192072b3317" translate="yes" xml:space="preserve">
          <source>VaList::deref_mut</source>
          <target state="translated">VaList::deref_mut</target>
        </trans-unit>
        <trans-unit id="4df0a82f8196ee6c8e34acaf7e521f5043ecc3f2" translate="yes" xml:space="preserve">
          <source>VaList::fmt</source>
          <target state="translated">VaList::fmt</target>
        </trans-unit>
        <trans-unit id="03cb0ba45ef46a478c6e89bd3b44e1281a4d5eb6" translate="yes" xml:space="preserve">
          <source>VaList::from</source>
          <target state="translated">VaList::from</target>
        </trans-unit>
        <trans-unit id="2b7cbe3710d07592cd359bf917b0387f4e9e9c5d" translate="yes" xml:space="preserve">
          <source>VaList::into</source>
          <target state="translated">VaList::into</target>
        </trans-unit>
        <trans-unit id="006354eed9f82fbe26fc29d15037b46b80c2b68d" translate="yes" xml:space="preserve">
          <source>VaList::try_from</source>
          <target state="translated">VaList::try_from</target>
        </trans-unit>
        <trans-unit id="cb8a2fefa105254fc69713249a582cf152da5fab" translate="yes" xml:space="preserve">
          <source>VaList::try_into</source>
          <target state="translated">VaList::try_into</target>
        </trans-unit>
        <trans-unit id="00466fb65a3743839a76ad49fc45873af21ac5b5" translate="yes" xml:space="preserve">
          <source>VaList::type_id</source>
          <target state="translated">VaList::type_id</target>
        </trans-unit>
        <trans-unit id="c8012d496381feb2e9a104eb4daca8ce56213794" translate="yes" xml:space="preserve">
          <source>VaList::with_copy</source>
          <target state="translated">VaList::with_copy</target>
        </trans-unit>
        <trans-unit id="cda940b5210ef6c9c3a6f85409e7dfeabc36a58a" translate="yes" xml:space="preserve">
          <source>VaListImpl</source>
          <target state="translated">VaListImpl</target>
        </trans-unit>
        <trans-unit id="3ca16b32106de1b77aafe6c23653b3844b349ae2" translate="yes" xml:space="preserve">
          <source>VaListImpl::arg</source>
          <target state="translated">VaListImpl::arg</target>
        </trans-unit>
        <trans-unit id="f4173f47c545e4746400db7076f692fc8d564b6d" translate="yes" xml:space="preserve">
          <source>VaListImpl::as_va_list</source>
          <target state="translated">VaListImpl::as_va_list</target>
        </trans-unit>
        <trans-unit id="d4f4feeb2f49c83d41fa723579047ba246044ff7" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow</source>
          <target state="translated">VaListImpl::borrow</target>
        </trans-unit>
        <trans-unit id="12efac9fbc832f37c148aabeed63349a1f5126dd" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow_mut</source>
          <target state="translated">VaListImpl::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3f6404a6c3b18f2e79cb5750c66a38cba6e8a6c" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone</source>
          <target state="translated">VaListImpl::clone</target>
        </trans-unit>
        <trans-unit id="c95d8d0d76cdd92d3789595b002435cb8b173ba3" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_from</source>
          <target state="translated">VaListImpl::clone_from</target>
        </trans-unit>
        <trans-unit id="b7e21123ef8eeecb128af522573adb35c0d73ae7" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_into</source>
          <target state="translated">VaListImpl::clone_into</target>
        </trans-unit>
        <trans-unit id="8cc867e3d0ec9d7fb9edb3f064cbe3324e06efce" translate="yes" xml:space="preserve">
          <source>VaListImpl::drop</source>
          <target state="translated">VaListImpl::drop</target>
        </trans-unit>
        <trans-unit id="c61984180c1cbdf98ccebd337221adae24339007" translate="yes" xml:space="preserve">
          <source>VaListImpl::fmt</source>
          <target state="translated">VaListImpl::fmt</target>
        </trans-unit>
        <trans-unit id="5914da98901e40d1b7387569cc8698d5354eda2d" translate="yes" xml:space="preserve">
          <source>VaListImpl::from</source>
          <target state="translated">VaListImpl::from</target>
        </trans-unit>
        <trans-unit id="69d61c23655b32b3d7479d5b9b6a68338cf35be2" translate="yes" xml:space="preserve">
          <source>VaListImpl::into</source>
          <target state="translated">VaListImpl::into</target>
        </trans-unit>
        <trans-unit id="5bfd2cfab7029ef58c310f856c3da54cb4b8f66b" translate="yes" xml:space="preserve">
          <source>VaListImpl::to_owned</source>
          <target state="translated">VaListImpl::to_owned</target>
        </trans-unit>
        <trans-unit id="2a010a2b25dc2ad1ab26cc514156dc9263f6a636" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_from</source>
          <target state="translated">VaListImpl::try_from</target>
        </trans-unit>
        <trans-unit id="d69de8fd6c5d1bc620b9f394404b1608c17d118f" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_into</source>
          <target state="translated">VaListImpl::try_into</target>
        </trans-unit>
        <trans-unit id="d07770d2e23a78895791cb1ceaf87ef62f25d60c" translate="yes" xml:space="preserve">
          <source>VaListImpl::type_id</source>
          <target state="translated">VaListImpl::type_id</target>
        </trans-unit>
        <trans-unit id="d2fa0e7319df7d0644b9ea0a44af083d4b6e723c" translate="yes" xml:space="preserve">
          <source>VaListImpl::with_copy</source>
          <target state="translated">VaListImpl::with_copy</target>
        </trans-unit>
        <trans-unit id="4e28dc650ae01219c2816ac14486f89634c8fc55" translate="yes" xml:space="preserve">
          <source>VacantEntry</source>
          <target state="translated">VacantEntry</target>
        </trans-unit>
        <trans-unit id="c96052bd94ad047ad8849208c48bf71c8e89ef7c" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">宏定义中的有效模式语法与第18章中介绍的模式语法不同，因为宏模式是针对Rust代码结构而不是值进行匹配的。让我们看一下清单19-28中的模式含义。有关完整的宏模式语法，请参见&lt;a href=&quot;../reference/macros&quot;&gt;参考资料&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7af7dd6d571b7430a0f3a804a2823ff5e3b34175" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros-by-example&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e50fbff8c8b7744c52b295c7fbf72559544494" translate="yes" xml:space="preserve">
          <source>Valid raw pointers as defined above are not necessarily properly aligned (where &quot;proper&quot; alignment is defined by the pointee type, i.e., &lt;code&gt;*const T&lt;/code&gt; must be aligned to &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt;). However, most functions require their arguments to be properly aligned, and will explicitly state this requirement in their documentation. Notable exceptions to this are &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">上面定义的有效原始指针不一定正确对齐（其中&amp;ldquo;适当的&amp;rdquo;对齐是由pointee类型定义的，即 &lt;code&gt;*const T&lt;/code&gt; 必须与 &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 对齐）。但是，大多数函数要求其参数正确对齐，并将在其文档中明确说明此要求。值得注意的例外是&lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.write_unaligned&quot;&gt; &lt;code&gt;write_unaligned&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c48f78e987c312ef821adcc0d7ee75c56d9144ac" translate="yes" xml:space="preserve">
          <source>Validating References with Lifetimes</source>
          <target state="translated">用寿命验证引用</target>
        </trans-unit>
        <trans-unit id="9bbb454d5a41c8f26ec9fb9b367e97c6b19c2f83" translate="yes" xml:space="preserve">
          <source>Validating the Number of Threads in &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt;</source>
          <target state="translated">验证 &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt; 线程数</target>
        </trans-unit>
        <trans-unit id="b5528864ad5f1464447c6381f31faab679eb55d8" translate="yes" xml:space="preserve">
          <source>Validating the Request and Selectively Responding</source>
          <target state="translated">验证请求和有选择的响应</target>
        </trans-unit>
        <trans-unit id="c4d75c989017ceaea555b5cb2f965e9a31a0f2ae" translate="yes" xml:space="preserve">
          <source>Value being parsed is empty.</source>
          <target state="translated">被解析的值为空。</target>
        </trans-unit>
        <trans-unit id="202eac546e1cca5cc40fbd1aa3d448b11c2717ed" translate="yes" xml:space="preserve">
          <source>Value was Zero</source>
          <target state="translated">价值为零</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="0c9f5af2d57c101875a9c09b9e64f7ab67e3fee1" translate="yes" xml:space="preserve">
          <source>Values larger than the maximum integer value will saturate to the maximum value of the integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb37a0444183e3bd07455b2f462b02a3823b4ce" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; types may be mutated through shared references (i.e. the common &lt;code&gt;&amp;amp;T&lt;/code&gt; type), whereas most Rust types can only be mutated through unique (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) references. We say that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.</source>
          <target state="translated">所述的值 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型可以通过共享引用被突变（即，共同 &lt;code&gt;&amp;amp;T&lt;/code&gt; 型），而大多数锈病类型只能通过独特的（被突变 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）的引用。我们说 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 提供了&amp;ldquo;内部可变性&amp;rdquo;，而典型的Rust类型则表现出&amp;ldquo;继承的可变性&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="df0b0235c50fdaa3c200fefa43bc29bd936a024f" translate="yes" xml:space="preserve">
          <source>Values of this type are constructed using a &lt;a href=&quot;../expressions/tuple-expr#tuple-expressions&quot;&gt;tuple expression&lt;/a&gt;. Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to. Tuple elements can be accessed by either a &lt;a href=&quot;../expressions/tuple-expr#tuple-indexing-expressions&quot;&gt;tuple index expression&lt;/a&gt; or &lt;a href=&quot;../patterns#tuple-patterns&quot;&gt;pattern matching&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ead0c6d8884038da5a1c37b81bd9ecdfeb765f5" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;U&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;T&lt;/code&gt; 类型的值被强制为 &lt;code&gt;&amp;amp;U&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="dd64aa37983b87ea2f61bdac9618cf696e12dc47" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</source>
          <target state="translated">类型的值 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 被强制为类型的值 &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e8a037908d83b45e7c8a2c2c4fe0fb372c4e345" translate="yes" xml:space="preserve">
          <source>Values returned by the iterator are returned in ascending order:</source>
          <target state="translated">迭代器返回的值按升序返回。</target>
        </trans-unit>
        <trans-unit id="7d470a568e8e665e2abbc283ee00bd48e19164d9" translate="yes" xml:space="preserve">
          <source>Values smaller than the minimum integer value will saturate to the minimum value of the integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7afb9932010efa26617ba00942998437043da478" translate="yes" xml:space="preserve">
          <source>ValuesMut</source>
          <target state="translated">ValuesMut</target>
        </trans-unit>
        <trans-unit id="6f7df0e9c5abd887cbbca9fb8a84f3706f71be4d" translate="yes" xml:space="preserve">
          <source>VarError</source>
          <target state="translated">VarError</target>
        </trans-unit>
        <trans-unit id="b2249943fec1979f3539ebcd42bc0163bc44ee0a" translate="yes" xml:space="preserve">
          <source>VarError::borrow</source>
          <target state="translated">VarError::borrow</target>
        </trans-unit>
        <trans-unit id="e76b4c157350bd5d1faf74dc1a04fc95858ad1b0" translate="yes" xml:space="preserve">
          <source>VarError::borrow_mut</source>
          <target state="translated">VarError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8102864035147256ef0e364c15593289f8d64dc2" translate="yes" xml:space="preserve">
          <source>VarError::cause</source>
          <target state="translated">VarError::cause</target>
        </trans-unit>
        <trans-unit id="7077379d5b4387ff8ef4d01332e0c9cb99aeba54" translate="yes" xml:space="preserve">
          <source>VarError::clone</source>
          <target state="translated">VarError::clone</target>
        </trans-unit>
        <trans-unit id="0632068939784835c82259892b18fa3851d349ae" translate="yes" xml:space="preserve">
          <source>VarError::clone_from</source>
          <target state="translated">VarError::clone_from</target>
        </trans-unit>
        <trans-unit id="3e4c81dcadc33c305fcb9909e431adbde92a23e1" translate="yes" xml:space="preserve">
          <source>VarError::clone_into</source>
          <target state="translated">VarError::clone_into</target>
        </trans-unit>
        <trans-unit id="ec42cb6e55e02863f7703ec026731824032ed4c6" translate="yes" xml:space="preserve">
          <source>VarError::description</source>
          <target state="translated">VarError::description</target>
        </trans-unit>
        <trans-unit id="8d65ad24989288d2260d520733e5b865bcae5729" translate="yes" xml:space="preserve">
          <source>VarError::eq</source>
          <target state="translated">VarError::eq</target>
        </trans-unit>
        <trans-unit id="467b0e136a5d88a16831d064cfef40627edbdee5" translate="yes" xml:space="preserve">
          <source>VarError::fmt</source>
          <target state="translated">VarError::fmt</target>
        </trans-unit>
        <trans-unit id="5122b46ea820b54b6d938c3fc817b38fbb3551ec" translate="yes" xml:space="preserve">
          <source>VarError::from</source>
          <target state="translated">VarError::from</target>
        </trans-unit>
        <trans-unit id="489e1a123c276c2da9ec69dea9020703001650ca" translate="yes" xml:space="preserve">
          <source>VarError::into</source>
          <target state="translated">VarError::into</target>
        </trans-unit>
        <trans-unit id="77f840cd95edf89f75e8cbd45132b08b456a0812" translate="yes" xml:space="preserve">
          <source>VarError::ne</source>
          <target state="translated">VarError::ne</target>
        </trans-unit>
        <trans-unit id="0c18e774293ad67a8f9a9531c4cd7c614981cf63" translate="yes" xml:space="preserve">
          <source>VarError::source</source>
          <target state="translated">VarError::source</target>
        </trans-unit>
        <trans-unit id="e8289e8f0efbef22ac2ef6d43d6c953e17d68e73" translate="yes" xml:space="preserve">
          <source>VarError::to_owned</source>
          <target state="translated">VarError::to_owned</target>
        </trans-unit>
        <trans-unit id="3b34bb1f1ce27eec8b875707ed1773dc9147c967" translate="yes" xml:space="preserve">
          <source>VarError::to_string</source>
          <target state="translated">VarError::to_string</target>
        </trans-unit>
        <trans-unit id="2d14c21b020fdc28d154a0e06cc4cefbc03f8bd7" translate="yes" xml:space="preserve">
          <source>VarError::try_from</source>
          <target state="translated">VarError::try_from</target>
        </trans-unit>
        <trans-unit id="20dfa7580a9574a0ffa43df49fcb51fd1edef1e7" translate="yes" xml:space="preserve">
          <source>VarError::try_into</source>
          <target state="translated">VarError::try_into</target>
        </trans-unit>
        <trans-unit id="67e6d907fb202086a0226ec13ebdeab6dee225b8" translate="yes" xml:space="preserve">
          <source>VarError::type_id</source>
          <target state="translated">VarError::type_id</target>
        </trans-unit>
        <trans-unit id="b280dc1f4f1b58422609af96e60af9910ffc1aac" translate="yes" xml:space="preserve">
          <source>Variable Scope</source>
          <target state="translated">可变范围</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="732411588a5167f463feab941a8f9ac01a5767df" translate="yes" xml:space="preserve">
          <source>Variables and Mutability</source>
          <target state="translated">变量和变异性</target>
        </trans-unit>
        <trans-unit id="3aa41db4c47f6adb669361c7bd5c456d22e65ea3" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration</source>
          <target state="translated">变量按声明的相反顺序删除</target>
        </trans-unit>
        <trans-unit id="be65562327a4b52bee54dc313d949d1238b35a3e" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration. Variables declared in the same pattern drop in an unspecified ordered.</source>
          <target state="translated">变量按声明的相反顺序掉落。在同一模式下声明的变量按不指定的顺序放弃。</target>
        </trans-unit>
        <trans-unit id="098937ab2cfb527e074d853750f7a28c47a33f35" translate="yes" xml:space="preserve">
          <source>Variables bound within the pattern are scoped to the match guard and the arm's expression. The &lt;a href=&quot;../patterns#binding-modes&quot;&gt;binding mode&lt;/a&gt; (move, copy, or reference) depends on the pattern.</source>
          <target state="translated">绑定在模式中的变量的范围仅限于比赛防护装置和手臂的表情。的&lt;a href=&quot;../patterns#binding-modes&quot;&gt;结合模式&lt;/a&gt;（移动，复制，或参考）取决于图案。</target>
        </trans-unit>
        <trans-unit id="3c4d82fabad7ffdf2edb09b215e05fb61c4a456f" translate="yes" xml:space="preserve">
          <source>Variables in Rust are immutable by default, and require the &lt;code&gt;mut&lt;/code&gt; keyword to be made mutable.</source>
          <target state="translated">默认情况下，Rust中的变量是不可变的，并且需要使 &lt;code&gt;mut&lt;/code&gt; 关键字可变。</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">变量函数</target>
        </trans-unit>
        <trans-unit id="09181b83bd980777906a8422efadb22af2c263db" translate="yes" xml:space="preserve">
          <source>Variadic parameters can only be specified with &lt;a href=&quot;../items/external-blocks&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; function types with the &lt;code&gt;&quot;C&quot;&lt;/code&gt; or &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; calling convention.</source>
          <target state="translated">可变参数只能使用带有 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; 调用约定的&lt;a href=&quot;../items/external-blocks&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt;函数类型指定。</target>
        </trans-unit>
        <trans-unit id="4c86f67a7083ae244751a61c00202e2c7bd69682" translate="yes" xml:space="preserve">
          <source>Variadic parameters have been used on a non-C ABI function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="8a62a01b810204975c3451044bb90c7a71ef1cde" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;'a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 的差异</target>
        </trans-unit>
        <trans-unit id="34a3731e86c04bcba14d808de4b083ba9ec18ab8" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的方差</target>
        </trans-unit>
        <trans-unit id="13ea9443937d9e6015e5a5cffcafae425d987b1a" translate="yes" xml:space="preserve">
          <source>Variance is a property that generic types have with respect to their arguments. A generic type's &lt;em&gt;variance&lt;/em&gt; in a parameter is how the subtyping of the parameter affects the subtyping of the type.</source>
          <target state="translated">差异是泛型类型对其参数具有的属性。泛型类型在参数中的&lt;em&gt;差异&lt;/em&gt;在于参数的子类型如何影响类型的子类型。</target>
        </trans-unit>
        <trans-unit id="9c74b0f6448f867bdf1be672d84dbe75d3a10d26" translate="yes" xml:space="preserve">
          <source>Variance of types is automatically determined as follows</source>
          <target state="translated">类型的差异自动确定如下</target>
        </trans-unit>
        <trans-unit id="59640c3e0b061bd7062f06a5f01816c4cfbcbe86" translate="yes" xml:space="preserve">
          <source>Variant visibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc3d368f8ad61e91648458829240a7efefcd2c1" translate="yes" xml:space="preserve">
          <source>Variants</source>
          <target state="translated">Variants</target>
        </trans-unit>
        <trans-unit id="1cec834cdc1b08e2f3ed59d65a8026d0864fc5b4" translate="yes" xml:space="preserve">
          <source>Variants (Non-exhaustive)</source>
          <target state="translated">差异(非详尽)</target>
        </trans-unit>
        <trans-unit id="b3fbdc730db8eecbbf239ec3967489785ffcc13f" translate="yes" xml:space="preserve">
          <source>Various built-in attributes use different subsets of the meta item syntax to specify their inputs. The following grammar rules show some commonly used forms:</source>
          <target state="translated">各种内置属性使用元项语法的不同子集来指定它们的输入。下面的语法规则显示了一些常用的形式。</target>
        </trans-unit>
        <trans-unit id="18d5bf7e0fee25c311080dec74d574b65c4b0764" translate="yes" xml:space="preserve">
          <source>Various separators</source>
          <target state="translated">各种分离器</target>
        </trans-unit>
        <trans-unit id="d4251864c293c17029bfa74793ffa95136fcec6d" translate="yes" xml:space="preserve">
          <source>Various things in the standard library may implement one or more of the three, where appropriate.</source>
          <target state="translated">标准库中的各种事物可以在适当的情况下实现三者中的一种或多种。</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="1c47de6b16a76ec820d60a85839ecc1cbf5e4457" translate="yes" xml:space="preserve">
          <source>Vars::all</source>
          <target state="translated">Vars::all</target>
        </trans-unit>
        <trans-unit id="b398eaf22edd2ef7aed1c4f858c613d773d5dd59" translate="yes" xml:space="preserve">
          <source>Vars::any</source>
          <target state="translated">Vars::any</target>
        </trans-unit>
        <trans-unit id="80450fe90037366e6900e0207a00a0ff5399c353" translate="yes" xml:space="preserve">
          <source>Vars::borrow</source>
          <target state="translated">Vars::borrow</target>
        </trans-unit>
        <trans-unit id="21a23559330914e11672cfb421023160c25aceab" translate="yes" xml:space="preserve">
          <source>Vars::borrow_mut</source>
          <target state="translated">Vars::borrow_mut</target>
        </trans-unit>
        <trans-unit id="781b07302eb0ba1fcc3cf935ec319d0ab20b1f65" translate="yes" xml:space="preserve">
          <source>Vars::by_ref</source>
          <target state="translated">Vars::by_ref</target>
        </trans-unit>
        <trans-unit id="9951d905bdeb385924f734897456db259730b15b" translate="yes" xml:space="preserve">
          <source>Vars::chain</source>
          <target state="translated">Vars::chain</target>
        </trans-unit>
        <trans-unit id="b7b0b3926db3e290b2a0c4b07b1ac73606da0d40" translate="yes" xml:space="preserve">
          <source>Vars::cloned</source>
          <target state="translated">Vars::cloned</target>
        </trans-unit>
        <trans-unit id="af8d7407e3b763504a144307a7303f5603d6229f" translate="yes" xml:space="preserve">
          <source>Vars::cmp</source>
          <target state="translated">Vars::cmp</target>
        </trans-unit>
        <trans-unit id="5a55a34bc63ca6a0899a5379932cae28b637a085" translate="yes" xml:space="preserve">
          <source>Vars::collect</source>
          <target state="translated">Vars::collect</target>
        </trans-unit>
        <trans-unit id="4eb06a4620fc01558a8bd2f2bf2b0ca80dc89a4b" translate="yes" xml:space="preserve">
          <source>Vars::copied</source>
          <target state="translated">Vars::copied</target>
        </trans-unit>
        <trans-unit id="bfb7648d61e3607bf3caff921735ae88f75f92ef" translate="yes" xml:space="preserve">
          <source>Vars::count</source>
          <target state="translated">Vars::count</target>
        </trans-unit>
        <trans-unit id="f6b7790787f62ef8a6724b8647c199f3e9fc0e6f" translate="yes" xml:space="preserve">
          <source>Vars::cycle</source>
          <target state="translated">Vars::cycle</target>
        </trans-unit>
        <trans-unit id="c728f5f416f691b01f40cd87af7f9137219eb03f" translate="yes" xml:space="preserve">
          <source>Vars::enumerate</source>
          <target state="translated">Vars::enumerate</target>
        </trans-unit>
        <trans-unit id="0a270124e47b9e2828a920edca2e2e533038569f" translate="yes" xml:space="preserve">
          <source>Vars::eq</source>
          <target state="translated">Vars::eq</target>
        </trans-unit>
        <trans-unit id="7080a20dc333e44166a8558123ba98d85eb6ded3" translate="yes" xml:space="preserve">
          <source>Vars::filter</source>
          <target state="translated">Vars::filter</target>
        </trans-unit>
        <trans-unit id="d41dd539031344f9e7e7bb6171c556fc42ef1957" translate="yes" xml:space="preserve">
          <source>Vars::filter_map</source>
          <target state="translated">Vars::filter_map</target>
        </trans-unit>
        <trans-unit id="78b0b6d5abfd7026b83ef665a619f46c392d69ed" translate="yes" xml:space="preserve">
          <source>Vars::find</source>
          <target state="translated">Vars::find</target>
        </trans-unit>
        <trans-unit id="7044c163171ec6f76f077a2bec8324df3677eec1" translate="yes" xml:space="preserve">
          <source>Vars::find_map</source>
          <target state="translated">Vars::find_map</target>
        </trans-unit>
        <trans-unit id="3b73b80a39e593c77029fbb50e77a9c267cde8cd" translate="yes" xml:space="preserve">
          <source>Vars::flat_map</source>
          <target state="translated">Vars::flat_map</target>
        </trans-unit>
        <trans-unit id="804f30eccc2a282312bcb332187a328e639337a6" translate="yes" xml:space="preserve">
          <source>Vars::flatten</source>
          <target state="translated">Vars::flatten</target>
        </trans-unit>
        <trans-unit id="4534d320518c99c9f5ec34ac48943387ea6be6eb" translate="yes" xml:space="preserve">
          <source>Vars::fmt</source>
          <target state="translated">Vars::fmt</target>
        </trans-unit>
        <trans-unit id="dcbe8ef4d0dae4b0a34ef3131b548dcabe7f720d" translate="yes" xml:space="preserve">
          <source>Vars::fold</source>
          <target state="translated">Vars::fold</target>
        </trans-unit>
        <trans-unit id="c0ce61b83b4e9c664534b8dfbab835e7e489b655" translate="yes" xml:space="preserve">
          <source>Vars::for_each</source>
          <target state="translated">Vars::for_each</target>
        </trans-unit>
        <trans-unit id="5dd1e805808b1f032c733423cbf4ac8a4c5a6981" translate="yes" xml:space="preserve">
          <source>Vars::from</source>
          <target state="translated">Vars::from</target>
        </trans-unit>
        <trans-unit id="af8c15b94b4468f337a1725be34d5554460f0a04" translate="yes" xml:space="preserve">
          <source>Vars::fuse</source>
          <target state="translated">Vars::fuse</target>
        </trans-unit>
        <trans-unit id="51bb1a81fecead1d604391ae02d739a62889b8ac" translate="yes" xml:space="preserve">
          <source>Vars::ge</source>
          <target state="translated">Vars::ge</target>
        </trans-unit>
        <trans-unit id="5b570a759e39ddbf689c5b76c7875f777d223503" translate="yes" xml:space="preserve">
          <source>Vars::gt</source>
          <target state="translated">Vars::gt</target>
        </trans-unit>
        <trans-unit id="e0b5b9d9e5ab4d21c95b05a37ba730388417d6b6" translate="yes" xml:space="preserve">
          <source>Vars::inspect</source>
          <target state="translated">Vars::inspect</target>
        </trans-unit>
        <trans-unit id="b8b6b4992b9eef91d9d506454c1498ee57011e6a" translate="yes" xml:space="preserve">
          <source>Vars::into</source>
          <target state="translated">Vars::into</target>
        </trans-unit>
        <trans-unit id="c48afb05fd046801df4e6edbf9f840dd304b60e1" translate="yes" xml:space="preserve">
          <source>Vars::into_iter</source>
          <target state="translated">Vars::into_iter</target>
        </trans-unit>
        <trans-unit id="e0ccc72484b281423161007f22d8a9293e1ba907" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted</source>
          <target state="translated">Vars::is_sorted</target>
        </trans-unit>
        <trans-unit id="e191fd1f8c7ce00d777cb35f9c5c82504bbe7781" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by</source>
          <target state="translated">Vars::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="eb9ca2ba30c83815b850a09d3feb972dfdc158e2" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by_key</source>
          <target state="translated">Vars::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6141318cc3ccabd5ae05e4611a7c5181f6046637" translate="yes" xml:space="preserve">
          <source>Vars::last</source>
          <target state="translated">Vars::last</target>
        </trans-unit>
        <trans-unit id="eecce1750e26f1ae1d749a4bae2b92eade287d53" translate="yes" xml:space="preserve">
          <source>Vars::le</source>
          <target state="translated">Vars::le</target>
        </trans-unit>
        <trans-unit id="b0904ac784f88af599fae6febadea78be6bd22be" translate="yes" xml:space="preserve">
          <source>Vars::lt</source>
          <target state="translated">Vars::lt</target>
        </trans-unit>
        <trans-unit id="aed51bf24598897e8d0ea447d651f3de39248cdc" translate="yes" xml:space="preserve">
          <source>Vars::map</source>
          <target state="translated">Vars::map</target>
        </trans-unit>
        <trans-unit id="8ab4e4308d5f56473c748138761d5bb14402ca33" translate="yes" xml:space="preserve">
          <source>Vars::max</source>
          <target state="translated">Vars::max</target>
        </trans-unit>
        <trans-unit id="5fbff539f6d31b21ce7158f6c6c1edd461357314" translate="yes" xml:space="preserve">
          <source>Vars::max_by</source>
          <target state="translated">Vars::max_by</target>
        </trans-unit>
        <trans-unit id="09ad51f2df0437fa8ff5bd6b68362c0cd8c5cfca" translate="yes" xml:space="preserve">
          <source>Vars::max_by_key</source>
          <target state="translated">Vars::max_by_key</target>
        </trans-unit>
        <trans-unit id="0ea5634589a7714b3ce13a9b994859ddc43c1472" translate="yes" xml:space="preserve">
          <source>Vars::min</source>
          <target state="translated">Vars::min</target>
        </trans-unit>
        <trans-unit id="84ccbe5bb178770383b19523a56c94a1a328c579" translate="yes" xml:space="preserve">
          <source>Vars::min_by</source>
          <target state="translated">Vars::min_by</target>
        </trans-unit>
        <trans-unit id="ef0e80e93b2480afa1eef5654b1d44253416e329" translate="yes" xml:space="preserve">
          <source>Vars::min_by_key</source>
          <target state="translated">Vars::min_by_key</target>
        </trans-unit>
        <trans-unit id="ed5f11b0702d02069bbdec987cd8231701e2f83d" translate="yes" xml:space="preserve">
          <source>Vars::ne</source>
          <target state="translated">Vars::ne</target>
        </trans-unit>
        <trans-unit id="5507ff5e66b6d746ac06bacbd6adfad687952f9d" translate="yes" xml:space="preserve">
          <source>Vars::next</source>
          <target state="translated">Vars::next</target>
        </trans-unit>
        <trans-unit id="aec94ecfda5dc5e8fd928e072a549d3135f6ad84" translate="yes" xml:space="preserve">
          <source>Vars::nth</source>
          <target state="translated">Vars::nth</target>
        </trans-unit>
        <trans-unit id="7b9faff88b13bea2403bdb806528b1b03e775923" translate="yes" xml:space="preserve">
          <source>Vars::partial_cmp</source>
          <target state="translated">Vars::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2c2aef1b9bc3af83507c48a9bec747732d905de4" translate="yes" xml:space="preserve">
          <source>Vars::partition</source>
          <target state="translated">Vars::partition</target>
        </trans-unit>
        <trans-unit id="86900414ba1e745a10275dfdac62d2d9717049f6" translate="yes" xml:space="preserve">
          <source>Vars::peekable</source>
          <target state="translated">Vars::peekable</target>
        </trans-unit>
        <trans-unit id="20b949f960f581abec205874631185ffb7bb5fa1" translate="yes" xml:space="preserve">
          <source>Vars::position</source>
          <target state="translated">Vars::position</target>
        </trans-unit>
        <trans-unit id="8f8bd9d5815bdec99dfe7927fb90687bd92fab9b" translate="yes" xml:space="preserve">
          <source>Vars::product</source>
          <target state="translated">Vars::product</target>
        </trans-unit>
        <trans-unit id="9f0f47f9e4c4906312f7cde7ba18939a86f5931f" translate="yes" xml:space="preserve">
          <source>Vars::rev</source>
          <target state="translated">Vars::rev</target>
        </trans-unit>
        <trans-unit id="4a55d6ece90a2e102e6248bacf85b746657dbf67" translate="yes" xml:space="preserve">
          <source>Vars::rposition</source>
          <target state="translated">Vars::rposition</target>
        </trans-unit>
        <trans-unit id="ef63b4a7e167047c985114917f57fd0d737537fe" translate="yes" xml:space="preserve">
          <source>Vars::scan</source>
          <target state="translated">Vars::scan</target>
        </trans-unit>
        <trans-unit id="3551c9199efbcf81653d617970dabf0cd9ed3d99" translate="yes" xml:space="preserve">
          <source>Vars::size_hint</source>
          <target state="translated">Vars::size_hint</target>
        </trans-unit>
        <trans-unit id="7943d6f84fa998209693b43046c7975775eb51cd" translate="yes" xml:space="preserve">
          <source>Vars::skip</source>
          <target state="translated">Vars::skip</target>
        </trans-unit>
        <trans-unit id="2d1337e0ea678c9a71cefd99de6b48cd2e8b1203" translate="yes" xml:space="preserve">
          <source>Vars::skip_while</source>
          <target state="translated">Vars::skip_while</target>
        </trans-unit>
        <trans-unit id="9ad1eaaaf974f3fa2bff01f61e628ff1dd93b8e7" translate="yes" xml:space="preserve">
          <source>Vars::step_by</source>
          <target state="translated">Vars::step_by</target>
        </trans-unit>
        <trans-unit id="3cfd4ab54ebdd5fc54ce1f5c5cd82d3493150512" translate="yes" xml:space="preserve">
          <source>Vars::sum</source>
          <target state="translated">Vars::sum</target>
        </trans-unit>
        <trans-unit id="b11b3042c11657cd454ca8548f85ff8aeb32a4fd" translate="yes" xml:space="preserve">
          <source>Vars::take</source>
          <target state="translated">Vars::take</target>
        </trans-unit>
        <trans-unit id="70f8ea67196cc23888fa00b81267afd9a27d3c32" translate="yes" xml:space="preserve">
          <source>Vars::take_while</source>
          <target state="translated">Vars::take_while</target>
        </trans-unit>
        <trans-unit id="288b6c944d7368cdf54e313b28e14e5725efaa9b" translate="yes" xml:space="preserve">
          <source>Vars::try_fold</source>
          <target state="translated">Vars::try_fold</target>
        </trans-unit>
        <trans-unit id="cf043e48c60478e52e24f6c062f28fb96fba6f9d" translate="yes" xml:space="preserve">
          <source>Vars::try_for_each</source>
          <target state="translated">Vars::try_for_each</target>
        </trans-unit>
        <trans-unit id="b4fd24921ed57ce691083c1322eaf0856a89e518" translate="yes" xml:space="preserve">
          <source>Vars::try_from</source>
          <target state="translated">Vars::try_from</target>
        </trans-unit>
        <trans-unit id="1daadb045ef158df87f592275c11205ecf5af378" translate="yes" xml:space="preserve">
          <source>Vars::try_into</source>
          <target state="translated">Vars::try_into</target>
        </trans-unit>
        <trans-unit id="2e2cb28cd54a254643d5c8595fc8be18813e9b3a" translate="yes" xml:space="preserve">
          <source>Vars::type_id</source>
          <target state="translated">Vars::type_id</target>
        </trans-unit>
        <trans-unit id="6b38c485c26bfb440ab87bcbfba50961f6cb40d6" translate="yes" xml:space="preserve">
          <source>Vars::unzip</source>
          <target state="translated">Vars::unzip</target>
        </trans-unit>
        <trans-unit id="bbe99efeecd60ccb331cf47e045d9299f8d35e6e" translate="yes" xml:space="preserve">
          <source>Vars::zip</source>
          <target state="translated">Vars::zip</target>
        </trans-unit>
        <trans-unit id="b3dd49122e36d39473d927caf75a7a1efe1ad95f" translate="yes" xml:space="preserve">
          <source>VarsOs</source>
          <target state="translated">VarsOs</target>
        </trans-unit>
        <trans-unit id="0be42997f9c0fa87236d029096ab1f10b322e7b9" translate="yes" xml:space="preserve">
          <source>VarsOs::all</source>
          <target state="translated">VarsOs::all</target>
        </trans-unit>
        <trans-unit id="2f3479491bf53557e01f4e76c184381ed836098b" translate="yes" xml:space="preserve">
          <source>VarsOs::any</source>
          <target state="translated">VarsOs::any</target>
        </trans-unit>
        <trans-unit id="434053241a0ce77b4a57a19b617f9cd0e0d5e814" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow</source>
          <target state="translated">VarsOs::borrow</target>
        </trans-unit>
        <trans-unit id="2d141f266e89d234f18a990d5d607d1646f48aee" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow_mut</source>
          <target state="translated">VarsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="425cc86c692b838ef921c23811c4e3302d1bdfc4" translate="yes" xml:space="preserve">
          <source>VarsOs::by_ref</source>
          <target state="translated">VarsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="2ea472498ef341c6fb344b9d8ee413b4e6235be7" translate="yes" xml:space="preserve">
          <source>VarsOs::chain</source>
          <target state="translated">VarsOs::chain</target>
        </trans-unit>
        <trans-unit id="a8c6d8c806adad2da3dacb9238da96bf328655bd" translate="yes" xml:space="preserve">
          <source>VarsOs::cloned</source>
          <target state="translated">VarsOs::cloned</target>
        </trans-unit>
        <trans-unit id="fda36a1ed84216068b1296731249e671c956362c" translate="yes" xml:space="preserve">
          <source>VarsOs::cmp</source>
          <target state="translated">VarsOs::cmp</target>
        </trans-unit>
        <trans-unit id="2db35bab4983e6e4d87a02ad263efa15ddb43d0d" translate="yes" xml:space="preserve">
          <source>VarsOs::collect</source>
          <target state="translated">VarsOs::collect</target>
        </trans-unit>
        <trans-unit id="e1850e83c9e256bacb297e01d179d1197cc0db06" translate="yes" xml:space="preserve">
          <source>VarsOs::copied</source>
          <target state="translated">VarsOs::copied</target>
        </trans-unit>
        <trans-unit id="5c6630d2555a45d97d28a5536655aff9f9e9d3b8" translate="yes" xml:space="preserve">
          <source>VarsOs::count</source>
          <target state="translated">VarsOs::count</target>
        </trans-unit>
        <trans-unit id="f0ac502bdac4e93b09bdc50516564d5e56dc7727" translate="yes" xml:space="preserve">
          <source>VarsOs::cycle</source>
          <target state="translated">VarsOs::cycle</target>
        </trans-unit>
        <trans-unit id="a5e0728a5c9381105cc966f06f76ab6ed5f65903" translate="yes" xml:space="preserve">
          <source>VarsOs::enumerate</source>
          <target state="translated">VarsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="0d4efb3a8d96184d450211631b5b79b1a60ab789" translate="yes" xml:space="preserve">
          <source>VarsOs::eq</source>
          <target state="translated">VarsOs::eq</target>
        </trans-unit>
        <trans-unit id="31db361add8338260d55916657c39337f09b86d7" translate="yes" xml:space="preserve">
          <source>VarsOs::filter</source>
          <target state="translated">VarsOs::filter</target>
        </trans-unit>
        <trans-unit id="0d0a62d2dca8a37393e2c92243786aaf41313690" translate="yes" xml:space="preserve">
          <source>VarsOs::filter_map</source>
          <target state="translated">VarsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="ae7d5fede6f36ca665efd08ae94669cbd14b7cc6" translate="yes" xml:space="preserve">
          <source>VarsOs::find</source>
          <target state="translated">VarsOs::find</target>
        </trans-unit>
        <trans-unit id="a97602f19f448bb335f850af073a9ce84cd5d88f" translate="yes" xml:space="preserve">
          <source>VarsOs::find_map</source>
          <target state="translated">VarsOs::find_map</target>
        </trans-unit>
        <trans-unit id="3678c5ef82f2cb08bc3b287c092316a2ada00a18" translate="yes" xml:space="preserve">
          <source>VarsOs::flat_map</source>
          <target state="translated">VarsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="e8a42aa17639bc96d10468e86951b455866c4904" translate="yes" xml:space="preserve">
          <source>VarsOs::flatten</source>
          <target state="translated">VarsOs::flatten</target>
        </trans-unit>
        <trans-unit id="46320ba9ecbf055cb2e56af08cec6e628a336f92" translate="yes" xml:space="preserve">
          <source>VarsOs::fmt</source>
          <target state="translated">VarsOs::fmt</target>
        </trans-unit>
        <trans-unit id="7bcbf2e75da1a46894beb596faa2a485d58f6a2d" translate="yes" xml:space="preserve">
          <source>VarsOs::fold</source>
          <target state="translated">VarsOs::fold</target>
        </trans-unit>
        <trans-unit id="51b69162489f5329a52d08395d177be1d60cb6a5" translate="yes" xml:space="preserve">
          <source>VarsOs::for_each</source>
          <target state="translated">VarsOs::for_each</target>
        </trans-unit>
        <trans-unit id="e06ff647273899d3fd4ea62e139dbf757cf3d8cc" translate="yes" xml:space="preserve">
          <source>VarsOs::from</source>
          <target state="translated">VarsOs::from</target>
        </trans-unit>
        <trans-unit id="0245bbf420434587e8ec6bdf35d9cf62a6cde011" translate="yes" xml:space="preserve">
          <source>VarsOs::fuse</source>
          <target state="translated">VarsOs::fuse</target>
        </trans-unit>
        <trans-unit id="479913c8896a1c5102d2a5ea1234f740bfde2328" translate="yes" xml:space="preserve">
          <source>VarsOs::ge</source>
          <target state="translated">VarsOs::ge</target>
        </trans-unit>
        <trans-unit id="17feba1de0fe9c2331df5c53c185c7617b4b8cc1" translate="yes" xml:space="preserve">
          <source>VarsOs::gt</source>
          <target state="translated">VarsOs::gt</target>
        </trans-unit>
        <trans-unit id="3033c2aeecf938c398013c5ab0852cd122a7d6b0" translate="yes" xml:space="preserve">
          <source>VarsOs::inspect</source>
          <target state="translated">VarsOs::inspect</target>
        </trans-unit>
        <trans-unit id="3f0b3d392367dab2dc143ca178da7b4d778bbd17" translate="yes" xml:space="preserve">
          <source>VarsOs::into</source>
          <target state="translated">VarsOs::into</target>
        </trans-unit>
        <trans-unit id="16fa54e40b1321bab910ef3ac287342748aea056" translate="yes" xml:space="preserve">
          <source>VarsOs::into_iter</source>
          <target state="translated">VarsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="5c63504ce660906345551dba943ce8d045612e95" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted</source>
          <target state="translated">VarsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="0fdd66d1bfafd9226a154278db222c3aee97c735" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by</source>
          <target state="translated">VarsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="204163a740d898b80542e502e7da9a7661337b36" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by_key</source>
          <target state="translated">VarsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="ae35eac698343e1ee4eeec512aed1c16a136d0c7" translate="yes" xml:space="preserve">
          <source>VarsOs::last</source>
          <target state="translated">VarsOs::last</target>
        </trans-unit>
        <trans-unit id="c01f90cf460a2003e266fcb0b34415121c12b736" translate="yes" xml:space="preserve">
          <source>VarsOs::le</source>
          <target state="translated">VarsOs::le</target>
        </trans-unit>
        <trans-unit id="c0cd86a67a36a78ad1451aca611b8fd991760e20" translate="yes" xml:space="preserve">
          <source>VarsOs::lt</source>
          <target state="translated">VarsOs::lt</target>
        </trans-unit>
        <trans-unit id="1cefab93b3f7c14142541eedb899ab5e71be9fc4" translate="yes" xml:space="preserve">
          <source>VarsOs::map</source>
          <target state="translated">VarsOs::map</target>
        </trans-unit>
        <trans-unit id="e6a8c9754fd49b2d51cbf24ecf6d94304e8e64c3" translate="yes" xml:space="preserve">
          <source>VarsOs::max</source>
          <target state="translated">VarsOs::max</target>
        </trans-unit>
        <trans-unit id="1f1f50d119da0ed96c40d44ea09ef96812375781" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by</source>
          <target state="translated">VarsOs::max_by</target>
        </trans-unit>
        <trans-unit id="0f2e6793ee02c5031cf6cc652fab9884db10bbdb" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by_key</source>
          <target state="translated">VarsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="af3d6a04943a8cf3ad8a6978c4e20520bbd7810c" translate="yes" xml:space="preserve">
          <source>VarsOs::min</source>
          <target state="translated">VarsOs::min</target>
        </trans-unit>
        <trans-unit id="65325562c65c7a37d9553910d80a4c50713493e5" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by</source>
          <target state="translated">VarsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce454f9015d8cd8601694fb53b1aac058cf4ec7c" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by_key</source>
          <target state="translated">VarsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="1c7e1099c4b87dd8e83e87ef896a8fe06530c255" translate="yes" xml:space="preserve">
          <source>VarsOs::ne</source>
          <target state="translated">VarsOs::ne</target>
        </trans-unit>
        <trans-unit id="abe200e7a70bbf42fbb261f3d6ecb1a850953161" translate="yes" xml:space="preserve">
          <source>VarsOs::next</source>
          <target state="translated">VarsOs::next</target>
        </trans-unit>
        <trans-unit id="753f8e880e8ece081c8080be088d05ec0d200f80" translate="yes" xml:space="preserve">
          <source>VarsOs::nth</source>
          <target state="translated">VarsOs::nth</target>
        </trans-unit>
        <trans-unit id="b6af18bf99508b4a2d5aac1fbdfad4b5780a6f74" translate="yes" xml:space="preserve">
          <source>VarsOs::partial_cmp</source>
          <target state="translated">VarsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="ba0322e8a281d2965f09dafdfe9b78ec1f84e172" translate="yes" xml:space="preserve">
          <source>VarsOs::partition</source>
          <target state="translated">VarsOs::partition</target>
        </trans-unit>
        <trans-unit id="91938a0453fc3e7b7813e5df0009b7580ef490d3" translate="yes" xml:space="preserve">
          <source>VarsOs::peekable</source>
          <target state="translated">VarsOs::peekable</target>
        </trans-unit>
        <trans-unit id="7a37b0e06b2930dc5a294f234caa4a16804177d0" translate="yes" xml:space="preserve">
          <source>VarsOs::position</source>
          <target state="translated">VarsOs::position</target>
        </trans-unit>
        <trans-unit id="4f098ada18205fbc46f5cd22be9968ee3d7b0363" translate="yes" xml:space="preserve">
          <source>VarsOs::product</source>
          <target state="translated">VarsOs::product</target>
        </trans-unit>
        <trans-unit id="6bf84c68f9daffbf302bd074f0e8be5a6ea7823d" translate="yes" xml:space="preserve">
          <source>VarsOs::rev</source>
          <target state="translated">VarsOs::rev</target>
        </trans-unit>
        <trans-unit id="1c60d42a9413b8a7c101dc83c2565f5d37b81a2a" translate="yes" xml:space="preserve">
          <source>VarsOs::rposition</source>
          <target state="translated">VarsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f65790ae1d5619919415f11aef0fe2aee47448a6" translate="yes" xml:space="preserve">
          <source>VarsOs::scan</source>
          <target state="translated">VarsOs::scan</target>
        </trans-unit>
        <trans-unit id="cb8748c599d4e59ff120199769de64e5786ad929" translate="yes" xml:space="preserve">
          <source>VarsOs::size_hint</source>
          <target state="translated">VarsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="3ea59b4b1aae9dc7c132d58be49e094fc8eaa95f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip</source>
          <target state="translated">VarsOs::skip</target>
        </trans-unit>
        <trans-unit id="02c1e6608b48c61896af2016b5b52d75d023957f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip_while</source>
          <target state="translated">VarsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="a0d6c6ad525cb20f675d004819c2121e056f42c8" translate="yes" xml:space="preserve">
          <source>VarsOs::step_by</source>
          <target state="translated">VarsOs::step_by</target>
        </trans-unit>
        <trans-unit id="6846222d088cefb1075c2f24c4eadbd7aed705eb" translate="yes" xml:space="preserve">
          <source>VarsOs::sum</source>
          <target state="translated">VarsOs::sum</target>
        </trans-unit>
        <trans-unit id="91c3203375fe48ab0d3fa32901ee5de67c77a411" translate="yes" xml:space="preserve">
          <source>VarsOs::take</source>
          <target state="translated">VarsOs::take</target>
        </trans-unit>
        <trans-unit id="144ba83f71bf339d2fc7ce6106d27d858be059f1" translate="yes" xml:space="preserve">
          <source>VarsOs::take_while</source>
          <target state="translated">VarsOs::take_while</target>
        </trans-unit>
        <trans-unit id="330e5de6bdd0923300ee2e19673f82661fe3b5aa" translate="yes" xml:space="preserve">
          <source>VarsOs::try_fold</source>
          <target state="translated">VarsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="7f9b1fb25f2d8dc898d57dd0ad57aa6074d0db25" translate="yes" xml:space="preserve">
          <source>VarsOs::try_for_each</source>
          <target state="translated">VarsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="0371b8d74af891c05681249ef7f32d83f6e8d3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::try_from</source>
          <target state="translated">VarsOs::try_from</target>
        </trans-unit>
        <trans-unit id="45aa3acec5ebcabeaf089da80e453c0f5f80cd2d" translate="yes" xml:space="preserve">
          <source>VarsOs::try_into</source>
          <target state="translated">VarsOs::try_into</target>
        </trans-unit>
        <trans-unit id="24d5d9ef2bba5983d72962681554163d3cc0d7ea" translate="yes" xml:space="preserve">
          <source>VarsOs::type_id</source>
          <target state="translated">VarsOs::type_id</target>
        </trans-unit>
        <trans-unit id="3e592311e132f7aa730baaf56aa5dd0ae220e3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::unzip</source>
          <target state="translated">VarsOs::unzip</target>
        </trans-unit>
        <trans-unit id="e4769bb4e270bd8e779d33f3cae641957c2527b8" translate="yes" xml:space="preserve">
          <source>VarsOs::zip</source>
          <target state="translated">VarsOs::zip</target>
        </trans-unit>
        <trans-unit id="3e8f48ebd55451a20501b45af4a4265976d600b6" translate="yes" xml:space="preserve">
          <source>Vec</source>
          <target state="translated">Vec</target>
        </trans-unit>
        <trans-unit id="9e8ec9d213a0da31ccaaba571b14789e42b08935" translate="yes" xml:space="preserve">
          <source>Vec::align_to</source>
          <target state="translated">Vec::align_to</target>
        </trans-unit>
        <trans-unit id="a6107ed66afb53f802511a5a643ee8656e497b0a" translate="yes" xml:space="preserve">
          <source>Vec::align_to_mut</source>
          <target state="translated">Vec::align_to_mut</target>
        </trans-unit>
        <trans-unit id="f61abeec7dd01f8c47bf83db4b4d0456a9af5e0b" translate="yes" xml:space="preserve">
          <source>Vec::append</source>
          <target state="translated">Vec::append</target>
        </trans-unit>
        <trans-unit id="966721890fa8492f6b4046bd9708da68c72adc73" translate="yes" xml:space="preserve">
          <source>Vec::as_mut</source>
          <target state="translated">Vec::as_mut</target>
        </trans-unit>
        <trans-unit id="831194353af948439212b65f5180ee63686be5ff" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_ptr</source>
          <target state="translated">Vec::as_mut_ptr</target>
        </trans-unit>
        <trans-unit id="2cd229f1c1c1c67e55b523142a4b5506c79ab5e4" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_slice</source>
          <target state="translated">Vec::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="c1e6da016e5f4ce35006127886b4b180eede68b8" translate="yes" xml:space="preserve">
          <source>Vec::as_ptr</source>
          <target state="translated">Vec::as_ptr</target>
        </trans-unit>
        <trans-unit id="8b5099d8e9c3e715862b2b38f181235c7cc24477" translate="yes" xml:space="preserve">
          <source>Vec::as_ref</source>
          <target state="translated">Vec::as_ref</target>
        </trans-unit>
        <trans-unit id="e50619a5c819f0a35e08edd227565f793562e4c8" translate="yes" xml:space="preserve">
          <source>Vec::as_slice</source>
          <target state="translated">Vec::as_slice</target>
        </trans-unit>
        <trans-unit id="0fd5dd3c29cf93dd4e97ef65f08a9644b11adf66" translate="yes" xml:space="preserve">
          <source>Vec::binary_search</source>
          <target state="translated">Vec::binary_search</target>
        </trans-unit>
        <trans-unit id="b52fc5259d9a5986689a231729ba2250dccdf822" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by</source>
          <target state="translated">Vec::binary_search_by</target>
        </trans-unit>
        <trans-unit id="c25875b591cdd49de2d27d47ee6d7ac1e21d9162" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by_key</source>
          <target state="translated">Vec::binary_search_by_key</target>
        </trans-unit>
        <trans-unit id="85bd126983a102e0968ff3a77e6cc098a02d6d2b" translate="yes" xml:space="preserve">
          <source>Vec::borrow</source>
          <target state="translated">Vec::borrow</target>
        </trans-unit>
        <trans-unit id="ce949f50884f71dd9c3bd065b3e9f2fac3e1b9b1" translate="yes" xml:space="preserve">
          <source>Vec::borrow_mut</source>
          <target state="translated">Vec::borrow_mut</target>
        </trans-unit>
        <trans-unit id="adf16c9ee55ed12543d9f09958b2da182d391549" translate="yes" xml:space="preserve">
          <source>Vec::by_ref</source>
          <target state="translated">Vec::by_ref</target>
        </trans-unit>
        <trans-unit id="879e3baf25a9301dece592c8e2fe831ab282b68c" translate="yes" xml:space="preserve">
          <source>Vec::capacity</source>
          <target state="translated">Vec::capacity</target>
        </trans-unit>
        <trans-unit id="0008361e288cf11981ce829d1646ffd8fcfd353d" translate="yes" xml:space="preserve">
          <source>Vec::chunks</source>
          <target state="translated">Vec::chunks</target>
        </trans-unit>
        <trans-unit id="753b8583ee481b3421bba7d981070ec72378a929" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact</source>
          <target state="translated">Vec::chunks_exact</target>
        </trans-unit>
        <trans-unit id="c16f1e8e4bdb33b2b62eb139dbdd695cce8cd9cb" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact_mut</source>
          <target state="translated">Vec::chunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="5129df9df37eeb41ed7c2d7d9a8c46bfb809e00b" translate="yes" xml:space="preserve">
          <source>Vec::chunks_mut</source>
          <target state="translated">Vec::chunks_mut</target>
        </trans-unit>
        <trans-unit id="b0c0c66afeddeab3613458326ddff56179dee6c6" translate="yes" xml:space="preserve">
          <source>Vec::clamp</source>
          <target state="translated">Vec::clamp</target>
        </trans-unit>
        <trans-unit id="2c2fbd7321fb15ce32f39380f1451dd1d8285167" translate="yes" xml:space="preserve">
          <source>Vec::clear</source>
          <target state="translated">Vec::clear</target>
        </trans-unit>
        <trans-unit id="f74617c56b1b4cb0ac739e41c8d386b187a932a0" translate="yes" xml:space="preserve">
          <source>Vec::clone</source>
          <target state="translated">Vec::clone</target>
        </trans-unit>
        <trans-unit id="7d2eba94d2d4e553221edef828d32477a74ec086" translate="yes" xml:space="preserve">
          <source>Vec::clone_from</source>
          <target state="translated">Vec::clone_from</target>
        </trans-unit>
        <trans-unit id="d765a16b06a09ff23e51adef46f6c11da8454339" translate="yes" xml:space="preserve">
          <source>Vec::clone_from_slice</source>
          <target state="translated">Vec::clone_from_slice</target>
        </trans-unit>
        <trans-unit id="33b8cb435611a78c3d465aaa7784c2b37cbb74e7" translate="yes" xml:space="preserve">
          <source>Vec::clone_into</source>
          <target state="translated">Vec::clone_into</target>
        </trans-unit>
        <trans-unit id="54c91e49e772a616e17900001275475155f0db86" translate="yes" xml:space="preserve">
          <source>Vec::cmp</source>
          <target state="translated">Vec::cmp</target>
        </trans-unit>
        <trans-unit id="0a3297559d1b2d0f5e9d86fb8e4f2702a52aed73" translate="yes" xml:space="preserve">
          <source>Vec::contains</source>
          <target state="translated">Vec::contains</target>
        </trans-unit>
        <trans-unit id="15b499228e83cdfe5d9bacf8f2717eb38b48f38b" translate="yes" xml:space="preserve">
          <source>Vec::copy_from_slice</source>
          <target state="translated">Vec::copy_from_slice</target>
        </trans-unit>
        <trans-unit id="b8ba6b02b6ab7d9e4a58c6ff8c4f8ed29c394009" translate="yes" xml:space="preserve">
          <source>Vec::copy_within</source>
          <target state="translated">Vec::copy_within</target>
        </trans-unit>
        <trans-unit id="789846c5e092b1b0a4c096dc5aa2920af554cadf" translate="yes" xml:space="preserve">
          <source>Vec::dedup</source>
          <target state="translated">Vec::dedup</target>
        </trans-unit>
        <trans-unit id="ef8409a58825c28ce8665f515341da99406dc45e" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by</source>
          <target state="translated">Vec::dedup_by</target>
        </trans-unit>
        <trans-unit id="363d4ee344588ea07c6bc5cfb25580f99e4e6fc4" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by_key</source>
          <target state="translated">Vec::dedup_by_key</target>
        </trans-unit>
        <trans-unit id="1a3c24e46d01efcb53b2e47b9f9fe05604eec885" translate="yes" xml:space="preserve">
          <source>Vec::default</source>
          <target state="translated">Vec::default</target>
        </trans-unit>
        <trans-unit id="b1a2319f3d6321033c9832ada871bb0364c41d6d" translate="yes" xml:space="preserve">
          <source>Vec::deref</source>
          <target state="translated">Vec::deref</target>
        </trans-unit>
        <trans-unit id="700ab6732dec0f913d9f30592a8a083e6275f0e9" translate="yes" xml:space="preserve">
          <source>Vec::deref_mut</source>
          <target state="translated">Vec::deref_mut</target>
        </trans-unit>
        <trans-unit id="5b692065705c3002050f3bc84600cd18eab70011" translate="yes" xml:space="preserve">
          <source>Vec::drain</source>
          <target state="translated">Vec::drain</target>
        </trans-unit>
        <trans-unit id="b56f02a07b5d1e06767ba9089e5a26237d2b6e96" translate="yes" xml:space="preserve">
          <source>Vec::drain_filter</source>
          <target state="translated">Vec::drain_filter</target>
        </trans-unit>
        <trans-unit id="1590e7c585be22084bde77caac361ebaa4d26167" translate="yes" xml:space="preserve">
          <source>Vec::drop</source>
          <target state="translated">Vec::drop</target>
        </trans-unit>
        <trans-unit id="c4e9c1a11aab0c3fbaa646a64a22f3069178f1e1" translate="yes" xml:space="preserve">
          <source>Vec::ends_with</source>
          <target state="translated">Vec::ends_with</target>
        </trans-unit>
        <trans-unit id="6460efc15d9228e5937dc4d9b4bb45990d32a27e" translate="yes" xml:space="preserve">
          <source>Vec::eq</source>
          <target state="translated">Vec::eq</target>
        </trans-unit>
        <trans-unit id="8e07e8d35672a19e43e8097f16c00d816c5cbe97" translate="yes" xml:space="preserve">
          <source>Vec::eq_ignore_ascii_case</source>
          <target state="translated">Vec::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="e46b7aa4e045855309d716fccf00cabd75a21e77" translate="yes" xml:space="preserve">
          <source>Vec::extend</source>
          <target state="translated">Vec::extend</target>
        </trans-unit>
        <trans-unit id="bb82f4df3cb27f5fbf87e6541ca1f465f414d3a5" translate="yes" xml:space="preserve">
          <source>Vec::extend_from_slice</source>
          <target state="translated">Vec::extend_from_slice</target>
        </trans-unit>
        <trans-unit id="87732cce3e95948f8d258db19ab24839895b0f76" translate="yes" xml:space="preserve">
          <source>Vec::first</source>
          <target state="translated">Vec::first</target>
        </trans-unit>
        <trans-unit id="fd582f0cbcb6e9f15ed28c1811608a7720bbbf52" translate="yes" xml:space="preserve">
          <source>Vec::first_mut</source>
          <target state="translated">Vec::first_mut</target>
        </trans-unit>
        <trans-unit id="cea112245a192a2715a4ac0d0d4ca6f9f0c88d11" translate="yes" xml:space="preserve">
          <source>Vec::flush</source>
          <target state="translated">Vec::flush</target>
        </trans-unit>
        <trans-unit id="74c0bff699639364b714e18c5e924ebe36d7bbb8" translate="yes" xml:space="preserve">
          <source>Vec::fmt</source>
          <target state="translated">Vec::fmt</target>
        </trans-unit>
        <trans-unit id="3b03e0120686cad397d6fe329718262a73208e9a" translate="yes" xml:space="preserve">
          <source>Vec::from</source>
          <target state="translated">Vec::from</target>
        </trans-unit>
        <trans-unit id="d2409bb7c2f488110f44be1023fc83c93200bfb1" translate="yes" xml:space="preserve">
          <source>Vec::from_iter</source>
          <target state="translated">Vec::from_iter</target>
        </trans-unit>
        <trans-unit id="e5b23b921224c968a51d83bca668d1740812f940" translate="yes" xml:space="preserve">
          <source>Vec::from_raw_parts</source>
          <target state="translated">Vec::from_raw_parts</target>
        </trans-unit>
        <trans-unit id="1b86c87d45b678c05eaedfa482e8e125c09283aa" translate="yes" xml:space="preserve">
          <source>Vec::ge</source>
          <target state="translated">Vec::ge</target>
        </trans-unit>
        <trans-unit id="a36985c63a8174e8d6e9d553daa519abe7ef73a3" translate="yes" xml:space="preserve">
          <source>Vec::get</source>
          <target state="translated">Vec::get</target>
        </trans-unit>
        <trans-unit id="55451d4c9012f0e9dc2705a9a20313c583cbad02" translate="yes" xml:space="preserve">
          <source>Vec::get_mut</source>
          <target state="translated">Vec::get_mut</target>
        </trans-unit>
        <trans-unit id="fbd1dbfc28f1dbf35081eb8a3b624e1ddb17a7d4" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked</source>
          <target state="translated">Vec::get_unchecked</target>
        </trans-unit>
        <trans-unit id="17aa782943cb8ba6f59f4076d63241b08687fe04" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked_mut</source>
          <target state="translated">Vec::get_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="12e2684fc2a72b4cdaf5511139faebcd74106115" translate="yes" xml:space="preserve">
          <source>Vec::gt</source>
          <target state="translated">Vec::gt</target>
        </trans-unit>
        <trans-unit id="3214576db0b2f915d4813a780951e762d0453108" translate="yes" xml:space="preserve">
          <source>Vec::hash</source>
          <target state="translated">Vec::hash</target>
        </trans-unit>
        <trans-unit id="cbad63e4de555a52c1156aacfa7acaa37d288f2d" translate="yes" xml:space="preserve">
          <source>Vec::hash_slice</source>
          <target state="translated">Vec::hash_slice</target>
        </trans-unit>
        <trans-unit id="817acc1f56c6b7266c14b400f36bd6915fc69aa9" translate="yes" xml:space="preserve">
          <source>Vec::index</source>
          <target state="translated">Vec::index</target>
        </trans-unit>
        <trans-unit id="255317cd139deae7b3798accef614b86d687af60" translate="yes" xml:space="preserve">
          <source>Vec::index_mut</source>
          <target state="translated">Vec::index_mut</target>
        </trans-unit>
        <trans-unit id="dae9879e89996749967d788919fd3919726095e5" translate="yes" xml:space="preserve">
          <source>Vec::insert</source>
          <target state="translated">Vec::insert</target>
        </trans-unit>
        <trans-unit id="4607993cbee4135669d2825495742a160937c51e" translate="yes" xml:space="preserve">
          <source>Vec::into</source>
          <target state="translated">Vec::into</target>
        </trans-unit>
        <trans-unit id="349c4bbf0cf7617a82524fff4ab6dd6dc12191ae" translate="yes" xml:space="preserve">
          <source>Vec::into_boxed_slice</source>
          <target state="translated">Vec::into_boxed_slice</target>
        </trans-unit>
        <trans-unit id="a2683d7c8a491dd1d14d82cbf394796000e6a7fa" translate="yes" xml:space="preserve">
          <source>Vec::into_iter</source>
          <target state="translated">Vec::into_iter</target>
        </trans-unit>
        <trans-unit id="0617d70073dd3ee36b70acc3469082e13a466d03" translate="yes" xml:space="preserve">
          <source>Vec::is_ascii</source>
          <target state="translated">Vec::is_ascii</target>
        </trans-unit>
        <trans-unit id="03169a81c036f8a9e76093b58242f30ae578d6e1" translate="yes" xml:space="preserve">
          <source>Vec::is_empty</source>
          <target state="translated">Vec::is_empty</target>
        </trans-unit>
        <trans-unit id="61e088912bf7c1fb5b0f0a806c372825ce419a0f" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted</source>
          <target state="translated">Vec::is_sorted</target>
        </trans-unit>
        <trans-unit id="2f71d97de0d886a25068ec904913d5f995b9ec67" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by</source>
          <target state="translated">Vec::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="13b69e903c4a68fcfe01f0c6f71a43d7cffcb8d2" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by_key</source>
          <target state="translated">Vec::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="67f810a4a6906d879a0e5bcdbd0629cdca0805fc" translate="yes" xml:space="preserve">
          <source>Vec::iter</source>
          <target state="translated">Vec::iter</target>
        </trans-unit>
        <trans-unit id="de14eea28b8af3ebd1fa7277134614ec35bede5f" translate="yes" xml:space="preserve">
          <source>Vec::iter_mut</source>
          <target state="translated">Vec::iter_mut</target>
        </trans-unit>
        <trans-unit id="89cb435951d0739bd80a43fd6eff389c96ea9137" translate="yes" xml:space="preserve">
          <source>Vec::last</source>
          <target state="translated">Vec::last</target>
        </trans-unit>
        <trans-unit id="8ec2cd17a9007516bf67a64facc2086a511ddabc" translate="yes" xml:space="preserve">
          <source>Vec::last_mut</source>
          <target state="translated">Vec::last_mut</target>
        </trans-unit>
        <trans-unit id="fbceeb72cec6860fa83702dbf07c61c0fba92768" translate="yes" xml:space="preserve">
          <source>Vec::le</source>
          <target state="translated">Vec::le</target>
        </trans-unit>
        <trans-unit id="525552cdf64c17bf1df49d77d5e10db05c4a1e65" translate="yes" xml:space="preserve">
          <source>Vec::len</source>
          <target state="translated">Vec::len</target>
        </trans-unit>
        <trans-unit id="1987ee0ae7df89f62926afad448cc8dcba8deb75" translate="yes" xml:space="preserve">
          <source>Vec::lt</source>
          <target state="translated">Vec::lt</target>
        </trans-unit>
        <trans-unit id="d73c1ce0cf0d3ba3f02694929282ef1ce4003f43" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_lowercase</source>
          <target state="translated">Vec::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="c984649eda1457369a83cadb8cb7cced71d85e8a" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_uppercase</source>
          <target state="translated">Vec::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="a14d3f9cce464f0a15bfb1ccdba70544cd9996dc" translate="yes" xml:space="preserve">
          <source>Vec::max</source>
          <target state="translated">Vec::max</target>
        </trans-unit>
        <trans-unit id="b7e2ddaad5a1e72a47531993b322493826992f01" translate="yes" xml:space="preserve">
          <source>Vec::min</source>
          <target state="translated">Vec::min</target>
        </trans-unit>
        <trans-unit id="27ac869c9c4d65022ccbe3db59b454048dac5d01" translate="yes" xml:space="preserve">
          <source>Vec::ne</source>
          <target state="translated">Vec::ne</target>
        </trans-unit>
        <trans-unit id="6fd848867337ba44b23b17c9fe00c94d829ea233" translate="yes" xml:space="preserve">
          <source>Vec::new</source>
          <target state="translated">Vec::new</target>
        </trans-unit>
        <trans-unit id="dcf8d5a328aa406810dabf32cd5ae01b3697decb" translate="yes" xml:space="preserve">
          <source>Vec::partial_cmp</source>
          <target state="translated">Vec::partial_cmp</target>
        </trans-unit>
        <trans-unit id="9694e7862ef0e60d886fd728679d90a8ee9470af" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index</source>
          <target state="translated">Vec::partition_at_index</target>
        </trans-unit>
        <trans-unit id="0bf6ca8cb659d720aa701bffc2851bc20dd39575" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by</source>
          <target state="translated">Vec::partition_at_index_by</target>
        </trans-unit>
        <trans-unit id="e14cd1ff21e7d949dfbecf45a57afb30d74ae935" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by_key</source>
          <target state="translated">Vec::partition_at_index_by_key</target>
        </trans-unit>
        <trans-unit id="a3bcf68a32491f6ce459bed1b83a0728f8d3facb" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup</source>
          <target state="translated">Vec::partition_dedup</target>
        </trans-unit>
        <trans-unit id="b33b907d031cab1a9f82dfabed52b3ec36a0bec7" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by</source>
          <target state="translated">Vec::partition_dedup_by</target>
        </trans-unit>
        <trans-unit id="e9042527cd9f8f7b837ac9979689f102fa5b9413" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by_key</source>
          <target state="translated">Vec::partition_dedup_by_key</target>
        </trans-unit>
        <trans-unit id="bb66cba5fa2c2be8852cc1be9f1f0442c400f3c1" translate="yes" xml:space="preserve">
          <source>Vec::pop</source>
          <target state="translated">Vec::pop</target>
        </trans-unit>
        <trans-unit id="015702c3beb31216ec8635f66c58b2dd6c7ce7d3" translate="yes" xml:space="preserve">
          <source>Vec::push</source>
          <target state="translated">Vec::push</target>
        </trans-unit>
        <trans-unit id="2a4ecb67c06267aff12807a92f7519558492cac3" translate="yes" xml:space="preserve">
          <source>Vec::rchunks</source>
          <target state="translated">Vec::rchunks</target>
        </trans-unit>
        <trans-unit id="2190a180c9e13d2c97a99729fb1cab9822f2b367" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact</source>
          <target state="translated">Vec::rchunks_exact</target>
        </trans-unit>
        <trans-unit id="8817d4c686ebb9e3df7649dc1ef10bbfc99e5a0f" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact_mut</source>
          <target state="translated">Vec::rchunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="d8b31989d0600b79568eabfbd02443e705c374f4" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_mut</source>
          <target state="translated">Vec::rchunks_mut</target>
        </trans-unit>
        <trans-unit id="845831747d56f3eeb00bb35e02809974b407e592" translate="yes" xml:space="preserve">
          <source>Vec::remove</source>
          <target state="translated">Vec::remove</target>
        </trans-unit>
        <trans-unit id="f2019e8c59ea1c039539318392c79102cc50f496" translate="yes" xml:space="preserve">
          <source>Vec::remove_item</source>
          <target state="translated">Vec::remove_item</target>
        </trans-unit>
        <trans-unit id="2a5af4f0d9906283d3505112b8edea1ff6aa8327" translate="yes" xml:space="preserve">
          <source>Vec::repeat</source>
          <target state="translated">Vec::repeat</target>
        </trans-unit>
        <trans-unit id="4030131e8b0f427754fca9b6fc2438b48ee132aa" translate="yes" xml:space="preserve">
          <source>Vec::reserve</source>
          <target state="translated">Vec::reserve</target>
        </trans-unit>
        <trans-unit id="c585b5b6b44dd8ead3846dfe6ff450a1d78b7ca4" translate="yes" xml:space="preserve">
          <source>Vec::reserve_exact</source>
          <target state="translated">Vec::reserve_exact</target>
        </trans-unit>
        <trans-unit id="abcfd065a68ab661075eb65973b1c2983f76906b" translate="yes" xml:space="preserve">
          <source>Vec::resize</source>
          <target state="translated">Vec::resize</target>
        </trans-unit>
        <trans-unit id="f9f7275b35ba8425eb32e3d8e98e0b77a08d75b9" translate="yes" xml:space="preserve">
          <source>Vec::resize_default</source>
          <target state="translated">Vec::resize_default</target>
        </trans-unit>
        <trans-unit id="9f1a1a7d355751c7299454f0938fedf8e60dd549" translate="yes" xml:space="preserve">
          <source>Vec::resize_with</source>
          <target state="translated">Vec::resize_with</target>
        </trans-unit>
        <trans-unit id="fd564ef5b54702a40658f77d501d340f02796c3b" translate="yes" xml:space="preserve">
          <source>Vec::retain</source>
          <target state="translated">Vec::retain</target>
        </trans-unit>
        <trans-unit id="020a2b7b3ef0fc23c178b5a1d57cf3220ce5e5ff" translate="yes" xml:space="preserve">
          <source>Vec::reverse</source>
          <target state="translated">Vec::reverse</target>
        </trans-unit>
        <trans-unit id="b4c1d9424701ec16b3d33474bf2a08c4a985a07b" translate="yes" xml:space="preserve">
          <source>Vec::rotate_left</source>
          <target state="translated">Vec::rotate_left</target>
        </trans-unit>
        <trans-unit id="a21a400e9268e082bb2ce482e8a8dfc6ab09fcf1" translate="yes" xml:space="preserve">
          <source>Vec::rotate_right</source>
          <target state="translated">Vec::rotate_right</target>
        </trans-unit>
        <trans-unit id="230272571f5aeb260545461fbf996bc487081e16" translate="yes" xml:space="preserve">
          <source>Vec::rsplit</source>
          <target state="translated">Vec::rsplit</target>
        </trans-unit>
        <trans-unit id="7588b43de214dc9942b6ec718d4f47a2bcedcba0" translate="yes" xml:space="preserve">
          <source>Vec::rsplit_mut</source>
          <target state="translated">Vec::rsplit_mut</target>
        </trans-unit>
        <trans-unit id="7d1297a0cd4e2ea121ae3252d869a3ab0996a1d6" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn</source>
          <target state="translated">Vec::rsplitn</target>
        </trans-unit>
        <trans-unit id="62a275a0772dd8dc1d1984c12daaf575f3aeeba5" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn_mut</source>
          <target state="translated">Vec::rsplitn_mut</target>
        </trans-unit>
        <trans-unit id="b0b31a5d59982433104183b210cdc7f9a7187cc9" translate="yes" xml:space="preserve">
          <source>Vec::set_len</source>
          <target state="translated">Vec::set_len</target>
        </trans-unit>
        <trans-unit id="dcf4c0bec18deb050ca3760e0ffcb5fbdd9b508d" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to</source>
          <target state="translated">Vec::shrink_to</target>
        </trans-unit>
        <trans-unit id="85ba0030d7417692c1610e814b9b07a58d76e77c" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to_fit</source>
          <target state="translated">Vec::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="16d167d14ba9fe06f16ed99bae2a2c03419b826b" translate="yes" xml:space="preserve">
          <source>Vec::sort</source>
          <target state="translated">Vec::sort</target>
        </trans-unit>
        <trans-unit id="81d8d3adb266cd3ddbf5075796bf792188963e60" translate="yes" xml:space="preserve">
          <source>Vec::sort_by</source>
          <target state="translated">Vec::sort_by</target>
        </trans-unit>
        <trans-unit id="fdaa89a60d5801892ad1d2af91cf732bf0fa3243" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_cached_key</source>
          <target state="translated">Vec::sort_by_cached_key</target>
        </trans-unit>
        <trans-unit id="d7a763e74650730d9254a393db15ca96341ce8b4" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_key</source>
          <target state="translated">Vec::sort_by_key</target>
        </trans-unit>
        <trans-unit id="abf375eb46a47b0a7dc0651c427daa5777cdc87d" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable</source>
          <target state="translated">Vec::sort_unstable</target>
        </trans-unit>
        <trans-unit id="6b1b6c683e214a704567cbb4866e258d5339b1a6" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by</source>
          <target state="translated">Vec::sort_unstable_by</target>
        </trans-unit>
        <trans-unit id="98bc35f1fee62d3c06dfa775a7a509e42577ec92" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by_key</source>
          <target state="translated">Vec::sort_unstable_by_key</target>
        </trans-unit>
        <trans-unit id="32db21414779495d647f8b90a008c9ef3267c648" translate="yes" xml:space="preserve">
          <source>Vec::splice</source>
          <target state="translated">Vec::splice</target>
        </trans-unit>
        <trans-unit id="a29a88b90b2283fcc62467ac92b894872c49e16c" translate="yes" xml:space="preserve">
          <source>Vec::split</source>
          <target state="translated">Vec::split</target>
        </trans-unit>
        <trans-unit id="6850cc7f3a18a5ae8795a517214f52bd03e37d1b" translate="yes" xml:space="preserve">
          <source>Vec::split_at</source>
          <target state="translated">Vec::split_at</target>
        </trans-unit>
        <trans-unit id="fffa7968cc458ceca06542d5bd41cbc6ab30cf0c" translate="yes" xml:space="preserve">
          <source>Vec::split_at_mut</source>
          <target state="translated">Vec::split_at_mut</target>
        </trans-unit>
        <trans-unit id="a158f5776929dc5fa591347c97af279ee6f308b5" translate="yes" xml:space="preserve">
          <source>Vec::split_first</source>
          <target state="translated">Vec::split_first</target>
        </trans-unit>
        <trans-unit id="6bc5d749a8be60dd619275925ca3abe61e1f1d9c" translate="yes" xml:space="preserve">
          <source>Vec::split_first_mut</source>
          <target state="translated">Vec::split_first_mut</target>
        </trans-unit>
        <trans-unit id="37a2c9e4c660e48769312c66dd3af4005f29a265" translate="yes" xml:space="preserve">
          <source>Vec::split_last</source>
          <target state="translated">Vec::split_last</target>
        </trans-unit>
        <trans-unit id="18a1b33cf122a212120639e6c43b624cc50e7d15" translate="yes" xml:space="preserve">
          <source>Vec::split_last_mut</source>
          <target state="translated">Vec::split_last_mut</target>
        </trans-unit>
        <trans-unit id="cf6ca76593d5b57fc21960139169843fb9cd7b00" translate="yes" xml:space="preserve">
          <source>Vec::split_mut</source>
          <target state="translated">Vec::split_mut</target>
        </trans-unit>
        <trans-unit id="03a916c0fcda14cb715141144403e9cf172139de" translate="yes" xml:space="preserve">
          <source>Vec::split_off</source>
          <target state="translated">Vec::split_off</target>
        </trans-unit>
        <trans-unit id="07108e7065deeacdbce3703bf0867dca70e0aa63" translate="yes" xml:space="preserve">
          <source>Vec::splitn</source>
          <target state="translated">Vec::splitn</target>
        </trans-unit>
        <trans-unit id="670a558b46826ad5134c813b4ea72c5f594e6c9a" translate="yes" xml:space="preserve">
          <source>Vec::splitn_mut</source>
          <target state="translated">Vec::splitn_mut</target>
        </trans-unit>
        <trans-unit id="0c0afbd8febc9c5f973424fd46f0e38ed59ccbe9" translate="yes" xml:space="preserve">
          <source>Vec::starts_with</source>
          <target state="translated">Vec::starts_with</target>
        </trans-unit>
        <trans-unit id="ad111eb0f36abc808f9f63d831dd393671b7d60f" translate="yes" xml:space="preserve">
          <source>Vec::swap</source>
          <target state="translated">Vec::swap</target>
        </trans-unit>
        <trans-unit id="c2d87a017cf8d077c99bd71bef846182121ea2f2" translate="yes" xml:space="preserve">
          <source>Vec::swap_remove</source>
          <target state="translated">Vec::swap_remove</target>
        </trans-unit>
        <trans-unit id="65ba4dcc752fbaf145dfc393c0ebd072c03850f4" translate="yes" xml:space="preserve">
          <source>Vec::swap_with_slice</source>
          <target state="translated">Vec::swap_with_slice</target>
        </trans-unit>
        <trans-unit id="187dcbc4c913473ea9ecc0da0ece64f155078f4d" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_lowercase</source>
          <target state="translated">Vec::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="9e994a24d814eaa773517353561f7db1763ba8c8" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_uppercase</source>
          <target state="translated">Vec::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="2d58122faa3b804afda87ac1afe94b0c2cf49a62" translate="yes" xml:space="preserve">
          <source>Vec::to_owned</source>
          <target state="translated">Vec::to_owned</target>
        </trans-unit>
        <trans-unit id="8295dc906018a2b87ebb59e81316a74736c8fba2" translate="yes" xml:space="preserve">
          <source>Vec::to_vec</source>
          <target state="translated">Vec::to_vec</target>
        </trans-unit>
        <trans-unit id="bbcf834cd40bf8d351710e8898b52c0706e47891" translate="yes" xml:space="preserve">
          <source>Vec::truncate</source>
          <target state="translated">Vec::truncate</target>
        </trans-unit>
        <trans-unit id="b539d40fa6817c484aec79eab2f72f8b069cd61a" translate="yes" xml:space="preserve">
          <source>Vec::try_from</source>
          <target state="translated">Vec::try_from</target>
        </trans-unit>
        <trans-unit id="edfbddcc1f5344a46cf8226a51d4480baae3f991" translate="yes" xml:space="preserve">
          <source>Vec::try_into</source>
          <target state="translated">Vec::try_into</target>
        </trans-unit>
        <trans-unit id="5c86c8fb54973c689718f247d2725be10c514476" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve</source>
          <target state="translated">Vec::try_reserve</target>
        </trans-unit>
        <trans-unit id="31147313c7e8fcea891f9a87a61ed1563dcc2831" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve_exact</source>
          <target state="translated">Vec::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="eed582f83a9d0aa9e1d0f2c268a23f8e413a6328" translate="yes" xml:space="preserve">
          <source>Vec::type_id</source>
          <target state="translated">Vec::type_id</target>
        </trans-unit>
        <trans-unit id="464742f01bb0869c25eb2800b7d8db8a1c7aac11" translate="yes" xml:space="preserve">
          <source>Vec::windows</source>
          <target state="translated">Vec::windows</target>
        </trans-unit>
        <trans-unit id="5728e3095df170ba310bd22e53f060f7088cdde8" translate="yes" xml:space="preserve">
          <source>Vec::with_capacity</source>
          <target state="translated">Vec::with_capacity</target>
        </trans-unit>
        <trans-unit id="265d2eb25b96552c36adc69855110dc3fd58c9aa" translate="yes" xml:space="preserve">
          <source>Vec::write</source>
          <target state="translated">Vec::write</target>
        </trans-unit>
        <trans-unit id="aeb1c503a25270fdde3115b7ad8a988a9c161a9d" translate="yes" xml:space="preserve">
          <source>Vec::write_all</source>
          <target state="translated">Vec::write_all</target>
        </trans-unit>
        <trans-unit id="bdef50740c7daaafaaf5156f90836f0887c73803" translate="yes" xml:space="preserve">
          <source>Vec::write_fmt</source>
          <target state="translated">Vec::write_fmt</target>
        </trans-unit>
        <trans-unit id="fb5d72587567483189e25ea2273df15eb40edb69" translate="yes" xml:space="preserve">
          <source>Vec::write_vectored</source>
          <target state="translated">Vec::write_vectored</target>
        </trans-unit>
        <trans-unit id="d8b188dca79494d553b4a25f8e7ba135fd059e06" translate="yes" xml:space="preserve">
          <source>VecDeque</source>
          <target state="translated">VecDeque</target>
        </trans-unit>
        <trans-unit id="daac388a0835b2f7f116ce4b930ba45f24e2d4f5" translate="yes" xml:space="preserve">
          <source>VecDeque::append</source>
          <target state="translated">VecDeque::append</target>
        </trans-unit>
        <trans-unit id="131f1606d9fb60120a570fc56345c3b4206cde68" translate="yes" xml:space="preserve">
          <source>VecDeque::as_mut_slices</source>
          <target state="translated">VecDeque::as_mut_slices</target>
        </trans-unit>
        <trans-unit id="e9e3cfebdd186278d399abad0a429053157088f8" translate="yes" xml:space="preserve">
          <source>VecDeque::as_slices</source>
          <target state="translated">VecDeque::as_slices</target>
        </trans-unit>
        <trans-unit id="0edc19e4ca1884e4aacf2a2a4380274826fb2740" translate="yes" xml:space="preserve">
          <source>VecDeque::back</source>
          <target state="translated">VecDeque::back</target>
        </trans-unit>
        <trans-unit id="ccf30a4382ae9328f9552afa5c5dfcfb35aef1b4" translate="yes" xml:space="preserve">
          <source>VecDeque::back_mut</source>
          <target state="translated">VecDeque::back_mut</target>
        </trans-unit>
        <trans-unit id="1d2610cb9f7282ea37e182a5f5c322a259c73e56" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow</source>
          <target state="translated">VecDeque::borrow</target>
        </trans-unit>
        <trans-unit id="c85001c25549712efa3bc4037af617403882f850" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow_mut</source>
          <target state="translated">VecDeque::borrow_mut</target>
        </trans-unit>
        <trans-unit id="50c2744064aa2c0045027447f96537e071e16754" translate="yes" xml:space="preserve">
          <source>VecDeque::capacity</source>
          <target state="translated">VecDeque::capacity</target>
        </trans-unit>
        <trans-unit id="d9ea40fef888b1aa5e6f0be9bc6eb9c5f0603d26" translate="yes" xml:space="preserve">
          <source>VecDeque::clamp</source>
          <target state="translated">VecDeque::clamp</target>
        </trans-unit>
        <trans-unit id="cef7bd89bf4a4eb9ba33004328fb058621269fe0" translate="yes" xml:space="preserve">
          <source>VecDeque::clear</source>
          <target state="translated">VecDeque::clear</target>
        </trans-unit>
        <trans-unit id="7e47848a7466bf6f810550e555917863d0558598" translate="yes" xml:space="preserve">
          <source>VecDeque::clone</source>
          <target state="translated">VecDeque::clone</target>
        </trans-unit>
        <trans-unit id="b0049440019ab3255550d699f8fa2c7e984241f3" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_from</source>
          <target state="translated">VecDeque::clone_from</target>
        </trans-unit>
        <trans-unit id="5a931f3dab8ce84e0c1498215e0a5ee5c312dbc4" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_into</source>
          <target state="translated">VecDeque::clone_into</target>
        </trans-unit>
        <trans-unit id="fd9dee766072ccb51f39babcce6cdd2ca35cde93" translate="yes" xml:space="preserve">
          <source>VecDeque::cmp</source>
          <target state="translated">VecDeque::cmp</target>
        </trans-unit>
        <trans-unit id="95d4c1d4f7170dca761e595f58227ed371676262" translate="yes" xml:space="preserve">
          <source>VecDeque::contains</source>
          <target state="translated">VecDeque::contains</target>
        </trans-unit>
        <trans-unit id="551608dce97aa0630c90774ad10f52c70cb6f3f6" translate="yes" xml:space="preserve">
          <source>VecDeque::default</source>
          <target state="translated">VecDeque::default</target>
        </trans-unit>
        <trans-unit id="6f86475df434e68c6dc113b2e5b2233f287a6033" translate="yes" xml:space="preserve">
          <source>VecDeque::drain</source>
          <target state="translated">VecDeque::drain</target>
        </trans-unit>
        <trans-unit id="4fddce3df4c9fe156f475165f3f4d5240f0afce4" translate="yes" xml:space="preserve">
          <source>VecDeque::drop</source>
          <target state="translated">VecDeque::drop</target>
        </trans-unit>
        <trans-unit id="0fcb62d0015e3066aec7a6e38e31f65772d5501d" translate="yes" xml:space="preserve">
          <source>VecDeque::eq</source>
          <target state="translated">VecDeque::eq</target>
        </trans-unit>
        <trans-unit id="075a7bfccff36cfa5ad77b2a00e19382093a8565" translate="yes" xml:space="preserve">
          <source>VecDeque::extend</source>
          <target state="translated">VecDeque::extend</target>
        </trans-unit>
        <trans-unit id="e054fa9bced4f47898e926baffbc0c60a08459c0" translate="yes" xml:space="preserve">
          <source>VecDeque::fmt</source>
          <target state="translated">VecDeque::fmt</target>
        </trans-unit>
        <trans-unit id="19d255ee2f123a37e942fb29c84911a9f64f017f" translate="yes" xml:space="preserve">
          <source>VecDeque::from</source>
          <target state="translated">VecDeque::from</target>
        </trans-unit>
        <trans-unit id="242a52440e095905c36864a3c86c19da0f44a3fd" translate="yes" xml:space="preserve">
          <source>VecDeque::from_iter</source>
          <target state="translated">VecDeque::from_iter</target>
        </trans-unit>
        <trans-unit id="29993bead69617ad206973adb616d88cb8d89425" translate="yes" xml:space="preserve">
          <source>VecDeque::front</source>
          <target state="translated">VecDeque::front</target>
        </trans-unit>
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="translated">向量还支持索引（通过&lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../ops/trait.indexmut&quot;&gt; &lt;code&gt;IndexMut&lt;/code&gt; &lt;/a&gt;特性）：</target>
        </trans-unit>
        <trans-unit id="10bd4ec04f26e95aeb5bf4a6ea31710e8b61d3aa" translate="yes" xml:space="preserve">
          <source>Vectors ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="translated">向量具有 &lt;code&gt;O(1)&lt;/code&gt; 索引，已摊销的 &lt;code&gt;O(1)&lt;/code&gt; 推送（到末尾）和 &lt;code&gt;O(1)&lt;/code&gt; pop（从末尾开始）。</target>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="translated">当你需要存储、访问和修改数据时,矢量、字符串和哈希图将在程序中提供大量必要的功能。下面是一些你现在应该具备解决的练习。</target>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">Verbatim UNC前缀由 &lt;code&gt;\?\UNC\&lt;/code&gt; 组成，后跟服务器的主机名和共享名。</target>
        </trans-unit>
        <trans-unit id="deeec6948b9b0c7f539defff599e2c9119f209e1" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="translated">逐字磁盘前缀，例如 &lt;code&gt;\?\C:\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc9892a19a8c55087305e1dc4f1a3f3fc14b7bbe" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\\?\C:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="translated">逐字磁盘前缀由 &lt;code&gt;\?\&lt;/code&gt; 紧随其后的是驱动器号和 &lt;code&gt;:\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbcf31c83c72d79322932f64e5c3a662a2b82084" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">逐字前缀使用Windows' &lt;em&gt;&lt;strong&gt;&amp;uuml;&lt;/strong&gt; niform &lt;strong&gt;&amp;ntilde;&lt;/strong&gt;阿明&lt;strong&gt;&amp;Ccedil;&lt;/strong&gt;年公约&lt;/em&gt;，例如， &lt;code&gt;\?\UNC\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d803e02d9c2966256665f4a37fc515a7b6b0270" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">逐字前缀，例如 &lt;code&gt;\?\cat_pics&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec64b930987590c33c18d3b5f5e6cd65655febca" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\\?\cat_pics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">逐字前缀由 &lt;code&gt;\?\&lt;/code&gt; 组成，后跟给定的组件。</target>
        </trans-unit>
        <trans-unit id="6c060304c7d1622fca546ec1708bfccb55b07579" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="translated">确认你没有拼错字段的名称或字段是否存在。例如:</target>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="translated">通过不可变的引用， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 允许您在程序的多个部分之间共享数据，以供只读。如果 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 允许您具有多个可变引用，则您可能违反了第4章中讨论的借用规则之一：到同一位置的多个可变借用可能导致数据争用和不一致。但是能够变异数据非常有用！在下一节中，我们将讨论内部可变性模式和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型，您可以将它们与 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 结合使用以处理这种不变性限制。</target>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="translated">将底层数据视为原始数据的一个子片。</target>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="translated">违反这些规定可能会导致分配器内部数据结构损坏等问题。</target>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">违反这些规则可能会导致问题，例如破坏分配器的内部数据结构。例如，它是&lt;strong&gt;不&lt;/strong&gt;安全建立一个 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 从一个指针到一个C &lt;code&gt;char&lt;/code&gt; 阵列和一个 &lt;code&gt;size_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f4c0ad7ae3e37221747e827bd3d99a0ac9c1516" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array with length &lt;code&gt;size_t&lt;/code&gt;. It's also not safe to build one from a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; and its length, because the allocator cares about the alignment, and these two types have different alignments. The buffer was allocated with alignment 2 (for &lt;code&gt;u16&lt;/code&gt;), but after turning it into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; it'll be deallocated with alignment 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="translated">可见度和隐私</target>
        </trans-unit>
        <trans-unit id="acf880408a272d86a4dffcc14370fa0e4c75f47e" translate="yes" xml:space="preserve">
          <source>Visibility is restricted to a module which isn't an ancestor of the current item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">访问代表差异的值，即以升序访问 &lt;code&gt;self&lt;/code&gt; 而不是 &lt;code&gt;other&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">访问表示差，即值，是在价值观 &lt;code&gt;self&lt;/code&gt; 而不是在 &lt;code&gt;other&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">访问表示相交的值，即以升序形式同时存在于 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 中的值。</target>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">访问表示相交的值，即 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="translated">访问代表对称差异的值，即以升序出现在 &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 但不是两者中的值。</target>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="translated">访问表示对称差异的值，即， &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 但不是两者都存在的值。</target>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="translated">访问表示并集的值，即，以升序访问 &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 中的所有值，没有重复项。</target>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="translated">访问表示联合的值，即 &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 中的所有值，而不重复。</target>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="translated">可视化对 &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; 和 &lt;code&gt;weak_count&lt;/code&gt; 的更改</target>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="translated">挥发性操作的目的是作用于I/O内存,并保证不会被编译器跨越其他挥发性操作而省略或重新排序。</target>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="84367e806ed16f93cd67aba890fbaef52d16a0b0" translate="yes" xml:space="preserve">
          <source>WASI</source>
          <target state="translated">WASI</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="translated">等待所有线程完成使用 &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; 句柄</target>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="translated">等待超时完全结束。</target>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="translated">等待相关的线程结束。</target>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="translated">等待子函数完全退出,返回它退出时的状态。该函数至少被调用一次后,将继续保持相同的返回值。</target>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="translated">在这个条件变量上等待通知,在指定的持续时间后计时。</target>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="translated">在这个条件变量上等待通知,在指定的持续时间后计时。虚假的唤醒不会导致该函数返回。</target>
        </trans-unit>
        <trans-unit id="d6a3650e37b6043ab9616dfc37b87c0ed505a997" translate="yes" xml:space="preserve">
          <source>Wake</source>
          <target state="translated">Wake</target>
        </trans-unit>
        <trans-unit id="2b6971b8cb619ebe6c9f69185b57e5e06726f961" translate="yes" xml:space="preserve">
          <source>Wake this task without consuming the waker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b7b65fb8cc05d38d07b2b178ad74919bff2a82" translate="yes" xml:space="preserve">
          <source>Wake this task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">唤醒与此 &lt;code&gt;Waker&lt;/code&gt; 相关的任务，而不消耗 &lt;code&gt;Waker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">唤醒与此 &lt;code&gt;Waker&lt;/code&gt; 相关的任务。</target>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="translated">唤醒了这个condvar上所有被屏蔽的线程。</target>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="translated">在这个condvar上醒了一个被封锁的线程。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">警告： &lt;code&gt;hash_builder&lt;/code&gt; 通常是随机生成的，旨在允许HashMap抵御导致许多冲突和非常差的性能的攻击。使用此功能手动设置它可以暴露DoS攻击媒介。</target>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">警告： &lt;code&gt;hasher&lt;/code&gt; 器通常是随机生成的，旨在允许 &lt;code&gt;HashSet&lt;/code&gt; 抵抗导致许多冲突和非常差的性能的攻击。使用此功能手动设置它可以暴露DoS攻击媒介。</target>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="translated">警告：任意设置的配置选项可能与编译器设置的配置选项具有相同的值。例如，可以在编译为Windows目标时执行 &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; ，并同时设置 &lt;code&gt;unix&lt;/code&gt; 和 &lt;code&gt;windows&lt;/code&gt; 配置选项。实际上这样做是不明智的。</target>
        </trans-unit>
        <trans-unit id="953fdee2421f57eef922d79cc862ee6e22ccfc48" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; can only legally hold the discrimnant values, everything else is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. Therefore, using a field-less enum in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">警告：有一间重要区别 &lt;code&gt;enum&lt;/code&gt; 在C语言和锈病的C-像这样表示枚举。C中的 &lt;code&gt;enum&lt;/code&gt; 主要是 &lt;code&gt;typedef&lt;/code&gt; 加上一些命名常量；换句话说， &lt;code&gt;enum&lt;/code&gt; 类型的对象可以保存任何整数值。例如，这通常用于 &lt;code&gt;C&lt;/code&gt; 中的位标志。相比之下，Rust的类C枚举只能合法保留判别式值，其他所有行为都是不确定的。因此，在FFI中使用类似C的枚举来建模C &lt;code&gt;enum&lt;/code&gt; 通常是错误的。</target>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">警告：这本书不完整。记录所有内容需要一段时间。有关本书未记录的内容，请参见&lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1f7ce6b6e1db1f6b36ab4dbe1ad4b6e4aa8f982" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="translated">警告:这是一个警告的例子。</target>
        </trans-unit>
        <trans-unit id="0411a6eec332f44831efbc3f9708608318be0eda" translate="yes" xml:space="preserve">
          <source>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="translated">警告：使用 &lt;code&gt;no_std&lt;/code&gt; 。并不妨碍标准库在被链接它仍然是有效投入 &lt;code&gt;extern crate std;&lt;/code&gt; 到板条箱中，依赖项也可以将其链接进来。</target>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="translated">在语言中表现出不健全的行为或可能混淆语言特征的相互作用的警告是在一个特殊的警告框中。</target>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="translated">终止是否成功?信号终止不算成功,成功定义为零退出状态。</target>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="translated">变量和数据的交互方式:克隆。</target>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="translated">变量和数据的交互方式:移动</target>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="translated">我们添加一条 &lt;code&gt;use minigrep::Config&lt;/code&gt; 行，以将库箱的 &lt;code&gt;Config&lt;/code&gt; 类型带入二进制箱的作用域，并在 &lt;code&gt;run&lt;/code&gt; 函数前加上箱名。现在，所有功能都应该已连接并且可以正常工作。 &lt;code&gt;cargo run&lt;/code&gt; 运行该程序，并确保一切正常。</target>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="translated">我们为 &lt;code&gt;content&lt;/code&gt; 方法添加了一个默认实现，该方法返回一个空字符串切片。这意味着我们不需要在 &lt;code&gt;Draft&lt;/code&gt; 和 &lt;code&gt;PendingReview&lt;/code&gt; 结构上实现 &lt;code&gt;content&lt;/code&gt; 。该 &lt;code&gt;Published&lt;/code&gt; 结构将覆盖 &lt;code&gt;content&lt;/code&gt; 方法和返回值 &lt;code&gt;post.content&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="translated">我们添加 &lt;code&gt;approve&lt;/code&gt; 法的 &lt;code&gt;State&lt;/code&gt; 特质，并添加一个新的结构，实现 &lt;code&gt;State&lt;/code&gt; 的 &lt;code&gt;Published&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="translated">我们将类型添加到 &lt;code&gt;Fn&lt;/code&gt; 特征绑定以表示参数的类型，并返回闭包必须匹配此特征绑定的值。在这种情况下，闭包的参数类型为 &lt;code&gt;u32&lt;/code&gt; 并返回 &lt;code&gt;u32&lt;/code&gt; ，因此我们指定的特征范围为 &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="translated">我们还需要一种方法来存储包含查询字符串的行。为此，我们可以在 &lt;code&gt;for&lt;/code&gt; 循环之前创建一个可变的向量，然后调用 &lt;code&gt;push&lt;/code&gt; 方法在向量中存储 &lt;code&gt;line&lt;/code&gt; 。在 &lt;code&gt;for&lt;/code&gt; 循环之后，我们返回向量，如清单12-19所示。</target>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="translated">我们无法运行此测试并看到它失败，因为该测试甚至无法编译： &lt;code&gt;search&lt;/code&gt; 功能尚不存在！因此，现在我们通过添加始终返回一个空向量的 &lt;code&gt;search&lt;/code&gt; 函数的定义，来添加足够的代码以使测试得以编译并运行，如清单12-16所示。然后测试应该编译并失败，因为空向量与包含 &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt; 行的向量不匹配。</target>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="translated">将变量 &lt;code&gt;field_name&lt;/code&gt; 和 &lt;code&gt;field_value&lt;/code&gt; 通过调用 &lt;code&gt;insert&lt;/code&gt; 移入哈希映射后，我们将无法使用它们。</target>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="translated">调用 &lt;code&gt;sum&lt;/code&gt; 之后，不允许使用 &lt;code&gt;v1_iter&lt;/code&gt; ，因为 &lt;code&gt;sum&lt;/code&gt; 获得了我们调用它的迭代器的所有权。</target>
        </trans-unit>
        <trans-unit id="03b218b584e4a8c7465d02aa1590edcd7370cd71" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="translated">我们直接将数据附加到enum的每个变体上,所以不需要额外的结构。</target>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">我们将 &lt;code&gt;guess&lt;/code&gt; 绑定到表达式 &lt;code&gt;guess.trim().parse()&lt;/code&gt; 。表达式中的 &lt;code&gt;guess&lt;/code&gt; 是指原始 &lt;code&gt;guess&lt;/code&gt; ，它是其中包含输入的 &lt;code&gt;String&lt;/code&gt; 。在 &lt;code&gt;String&lt;/code&gt; 实例上的 &lt;code&gt;trim&lt;/code&gt; 方法将消除开头和结尾的任何空格。尽管 &lt;code&gt;u32&lt;/code&gt; 只能包含数字字符，但用户必须按Enter才能满足 &lt;code&gt;read_line&lt;/code&gt; 的要求。当用户按下Enter键时，会将换行符添加到字符串中。例如，如果用户键入5并按Enter，则 &lt;code&gt;guess&lt;/code&gt; 看起来像这样： &lt;code&gt;5\n&lt;/code&gt; 。该 &lt;code&gt;\n&lt;/code&gt; 代表&amp;ldquo;换行符&amp;rdquo;，即按Enter的结果。该 &lt;code&gt;trim&lt;/code&gt; 方法消除 &lt;code&gt;\n&lt;/code&gt; ，导致只是 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="translated">我们将 &lt;code&gt;std::io::prelude&lt;/code&gt; 带入范围，以访问某些使我们可以从流中读取和写入流的特征。在 &lt;code&gt;main&lt;/code&gt; 函数的 &lt;code&gt;for&lt;/code&gt; 循环中，我们现在不调用新的 &lt;code&gt;handle_connection&lt;/code&gt; 函数，而是将 &lt;code&gt;stream&lt;/code&gt; 递给它，而不是显示一条消息说明已建立连接。</target>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="translated">我们称将引用作为函数参数&lt;em&gt;借用&lt;/em&gt;。与现实生活中一样，如果某人拥有某物，则可以向他们借用。完成后，您必须将其归还。</target>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="translated">我们在 &lt;code&gt;Option&lt;/code&gt; 上调用 &lt;code&gt;as_ref&lt;/code&gt; 方法，因为我们希望引用 &lt;code&gt;Option&lt;/code&gt; 内的值而不是值的所有权。因为 &lt;code&gt;state&lt;/code&gt; 是 &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; ，所以当我们调用 &lt;code&gt;as_ref&lt;/code&gt; 时，将返回 &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; 。如果不调用 &lt;code&gt;as_ref&lt;/code&gt; ，则会收到错误消息，因为我们无法将 &lt;code&gt;state&lt;/code&gt; 从函数参数的借用 &lt;code&gt;&amp;amp;self&lt;/code&gt; 中移出。</target>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="translated">对于任何实现了另一个特征的类型，我们也可以有条件地实现一个特征。满足特征界限的任何类型的特征&lt;em&gt;实现&lt;/em&gt;都称为&lt;em&gt;一揽子实现，&lt;/em&gt;并在Rust标准库中广泛使用。例如，标准库在实现 &lt;code&gt;Display&lt;/code&gt; trait的任何类型上实现 &lt;code&gt;ToString&lt;/code&gt; trait。标准库中的 &lt;code&gt;impl&lt;/code&gt; 块看起来类似于以下代码：</target>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="translated">我们还可以通过在路径的开头使用 &lt;code&gt;super&lt;/code&gt; 来构造从父模块开始的相对路径。这就像使用 &lt;code&gt;..&lt;/code&gt; 语法启动文件系统路径。我们为什么要这样做？</target>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="translated">我们还可以使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 语法将结构定义为在一个或多个字段中使用通用类型参数。清单10-6显示了如何定义 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 结构以容纳任何类型的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 坐标值。</target>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="translated">我们也可以使用字面值作为结构模式的一部分进行重构,而不是为所有字段创建变量。这样做可以让我们测试一些字段的特定值,同时创建变量来反构其他字段。</target>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="translated">我们还可以迭代对可变向量中每个元素的可变引用，以对所有元素进行更改。清单8-9中的 &lt;code&gt;for&lt;/code&gt; 循环将向每个元素添加 &lt;code&gt;50&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="translated">我们还可以通过使用 &lt;code&gt;-p&lt;/code&gt; 标志并指定我们要测试的板条箱的名称，从顶级目录中为工作空间中的特定板条箱运行测试：</target>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">我们还可以指定多个特征绑定。假设我们想 &lt;code&gt;notify&lt;/code&gt; 在使用显示器上格式化 &lt;code&gt;item&lt;/code&gt; 以及在 &lt;code&gt;summarize&lt;/code&gt; 方法：我们指定的 &lt;code&gt;notify&lt;/code&gt; 定义， &lt;code&gt;item&lt;/code&gt; 必须实现 &lt;code&gt;Display&lt;/code&gt; 和 &lt;code&gt;Summary&lt;/code&gt; 。我们可以使用 &lt;code&gt;+&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="translated">我们还可以在I / O项目的 &lt;code&gt;search&lt;/code&gt; 功能中利用迭代器，如清单12-19所示，在清单13-28中复制了迭代器：</target>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="translated">我们还可以在另一个模式内使用 &lt;code&gt;_&lt;/code&gt; 来忽略值的一部分，例如，当我们只想测试值的一部分而对要运行的代码中的其他部分没有用处时。清单18-18显示了负责管理设置值的代码。业务要求是不允许用户覆盖设置的现有自定义设置，但可以取消设置并给它提供值（如果当前未设置）。</target>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="translated">我们还可以使用 &lt;code&gt;extern&lt;/code&gt; 创建一个接口，该接口允许其他语言调用Rust函数。代替 &lt;code&gt;extern&lt;/code&gt; 块，我们添加了 &lt;code&gt;extern&lt;/code&gt; 关键字，并指定要在 &lt;code&gt;fn&lt;/code&gt; 关键字之前使用的ABI 。我们还需要添加 &lt;code&gt;#[no_mangle]&lt;/code&gt; 批注以告知Rust编译器不要破坏该函数的名称。&lt;em&gt;g&lt;/em&gt;就是当编译器更改名称时，我们为函数指定了另一个名称，该名称包含更多信息供编译过程的其他部分使用，但人类可读性较低。每个编程语言编译器对名称的处理都略有不同，因此，要使Rust函数能被其他语言命名，我们必须禁用Rust编译器的名称处理。</target>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="translated">我们还可以使用 &lt;code&gt;pub&lt;/code&gt; 将结构和枚举指定为公共，但还有一些其他细节。如果在结构定义之前使用 &lt;code&gt;pub&lt;/code&gt; ，则将结构公开，但结构的字段仍将是私有的。我们可以根据具体情况公开或不公开每个字段。在清单7-9，我们定义了一个公共 &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 结构与公共 &lt;code&gt;toast&lt;/code&gt; 领域，但私人 &lt;code&gt;seasonal_fruit&lt;/code&gt; 领域。这样可以在一家餐馆中为案例建模，顾客可以选择随餐搭配的面包类型，但是厨师会根据季节和库存来决定随餐搭配哪种水果。可用的水果变化很快，因此客户无法选择水果，甚至看不到会得到哪种水果。</target>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="translated">我们也可以像在函数参数列表中一样,在闭包参数列表中使用模式,因为闭包类似于函数,在第13章中已经讨论过。</target>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="translated">我们还可以使用模式来解构结构，枚举，元组和引用，以使用这些值的不同部分。让我们浏览每个值。</target>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="translated">我们还可以在返回位置使用 &lt;code&gt;impl Trait&lt;/code&gt; 语法返回实现特征的某种类型的值，如下所示：</target>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="translated">我们也可以用函数 &lt;code&gt;String::from&lt;/code&gt; 创建一个 &lt;code&gt;String&lt;/code&gt; 从一个字符串文字。清单8-13中的代码与清单8-12中使用 &lt;code&gt;to_string&lt;/code&gt; 的代码等效。</target>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="translated">我们也可以在一个模式中的多个地方使用下划线来忽略特定的值。清单18-19显示了一个忽略五个项目的元组中的第二个和第四个值的例子。</target>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">我们可以使用 &lt;code&gt;cargo build&lt;/code&gt; 或 &lt;code&gt;cargo check&lt;/code&gt; 来建造项目。</target>
        </trans-unit>
        <trans-unit id="838e973f1067e2cb1c1db7ba741330fcbc0ac60a" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce64501de0b20285b589ca7f67901cf5515ef19d" translate="yes" xml:space="preserve">
          <source>We can build a project without producing a binary to check for errors using &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="translated">我们可以使用 &lt;code&gt;cargo run&lt;/code&gt; 一步建立并运行一个项目。</target>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="translated">我们可以通过输入其名称后跟一组括号来调用已定义的任何函数。因为 &lt;code&gt;another_function&lt;/code&gt; 是在程序中定义的，所以可以从 &lt;code&gt;main&lt;/code&gt; 函数内部调用它。注意，我们在源代码中的 &lt;code&gt;main&lt;/code&gt; 函数&lt;em&gt;之后&lt;/em&gt;定义了 &lt;code&gt;another_function&lt;/code&gt; ；我们也可以定义它。Rust不在乎您在何处定义函数，只需在某个地方定义它们即可。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="translated">我们可以使用字符串切片作为参数来调用 &lt;code&gt;hello&lt;/code&gt; 函数，例如 &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; 例如。使用Deref强制可以使用对 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 类型的值的引用来调用 &lt;code&gt;hello&lt;/code&gt; ，如清单15-12所示：</target>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="translated">我们可以直接在迭代器上调用 &lt;code&gt;next&lt;/code&gt; 方法。清单13-15展示了从向量创建的迭代器上，对 &lt;code&gt;next&lt;/code&gt; 的重复调用所返回的值。</target>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="translated">我们可以将清单15-2 中的 &lt;code&gt;List&lt;/code&gt; 枚举的定义和清单15-3 中的 &lt;code&gt;List&lt;/code&gt; 的用法更改为清单15-5中的代码，这些代码将进行编译：</target>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="translated">我们可以将 &lt;code&gt;str&lt;/code&gt; 与各种指针结合使用：例如 &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt; 。实际上，您之前已经看到过这种情况，但是具有不同的动态大小类型：特征。每个特征都是动态大小类型，我们可以使用特征名称来引用。在第17章&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;使用允许使用不同类型值的特性对象&amp;rdquo;&lt;/a&gt;一节中，我们提到了要将特性用作特性对象，必须将它们放在指针后面，例如 &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; 或 &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; （ &lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; 也可以）。</target>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="translated">我们可以像这样创建 &lt;code&gt;IpAddrKind&lt;/code&gt; 的两个变体的每一个的实例：</target>
        </trans-unit>
        <trans-unit id="6778f0bff382e98f9e7494c1dbfeeb8d0d54aa88" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte (counting from 1) of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">通过指定 &lt;code&gt;[starting_index..ending_index]&lt;/code&gt; ，我们可以使用方括号内的范围来创建切片，其中， &lt;code&gt;starting_index&lt;/code&gt; 是切片中的第一个位置，而 &lt;code&gt;ending_index&lt;/code&gt; 比切片中的最后一个位置大。在内部，切片数据结构存储切片的起始位置和长度，其对应于 &lt;code&gt;ending_index&lt;/code&gt; 减去 &lt;code&gt;starting_index&lt;/code&gt; 。因此，在 &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; ， &lt;code&gt;world&lt;/code&gt; 将是一个切片，其中包含指向 &lt;code&gt;s&lt;/code&gt; 的第7个字节的指针，其长度值为5。</target>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="translated">我们可以通过定义 &lt;code&gt;IpAddrKind&lt;/code&gt; 枚举并列出IP地址可能的种类 &lt;code&gt;V4&lt;/code&gt; 和 &lt;code&gt;V6&lt;/code&gt; 来在代码中表达此概念。这些被称为枚举的&lt;em&gt;变体&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="76dc799b358f8c432443282c326218cb637140a7" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are the variants of the enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="translated">我们只需对清单4-6中的代码稍作调整,就可以解决这个错误。</target>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="translated">通过将 &lt;code&gt;thread::spawn&lt;/code&gt; 的返回值保存在变量中，我们可以解决生成的线程无法运行或无法完全运行的问题。 &lt;code&gt;thread::spawn&lt;/code&gt; 的返回类型为 &lt;code&gt;JoinHandle&lt;/code&gt; 。一个 &lt;code&gt;JoinHandle&lt;/code&gt; 是一家拥有值，当我们调用 &lt;code&gt;join&lt;/code&gt; 方法就可以了，就等待它的线程结束。清单16-2显示了如何使用清单16-1中创建的线程的 &lt;code&gt;JoinHandle&lt;/code&gt; 并调用 &lt;code&gt;join&lt;/code&gt; 来确保生成的线程在 &lt;code&gt;main&lt;/code&gt; 出口之前完成：</target>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="translated">我们可以通过将其值提供给 &lt;code&gt;get&lt;/code&gt; 方法来从哈希图中获取值，如清单8-23所示。</target>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="translated">我们可以使用 &lt;code&gt;push_str&lt;/code&gt; 方法添加字符串切片来增长 &lt;code&gt;String&lt;/code&gt; ，如清单8-15所示。</target>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="translated">我们可以在结构和枚举上实现方法（就像我们在第5章中所做的那样），并且也可以在它们的定义中使用泛型类型。清单10-9显示了我们在清单10-6中定义的 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 结构，并在其上实现了名为 &lt;code&gt;x&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="translated">我们可以在 &lt;code&gt;if let&lt;/code&gt; 中包含 &lt;code&gt;else&lt;/code&gt; 。的代码，与去块 &lt;code&gt;else&lt;/code&gt; 相同的代码块，将与去 &lt;code&gt;_&lt;/code&gt; 的情况下 &lt;code&gt;match&lt;/code&gt; 表达式相当于 &lt;code&gt;if let&lt;/code&gt; 与 &lt;code&gt;else&lt;/code&gt; 。回顾清单6-4中的 &lt;code&gt;Coin&lt;/code&gt; 枚举定义，其中 &lt;code&gt;Quarter&lt;/code&gt; 变体也具有 &lt;code&gt;UsState&lt;/code&gt; 值。如果我们想计算我们看到的所有非四分之一硬币，同时还宣布四分之一硬币的状态，则可以使用以下 &lt;code&gt;match&lt;/code&gt; 表达式来实现：</target>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="translated">相反，我们可以返回一个 &lt;code&gt;Result&lt;/code&gt; 值，该值将在成功的情况下包含一个 &lt;code&gt;Config&lt;/code&gt; 实例，并在错误的情况下描述问题。当 &lt;code&gt;Config::new&lt;/code&gt; 与 &lt;code&gt;main&lt;/code&gt; 通讯时，我们可以使用 &lt;code&gt;Result&lt;/code&gt; 类型来表明存在问题。然后，我们可以更改 &lt;code&gt;main&lt;/code&gt; ,以便为我们的用户将 &lt;code&gt;Err&lt;/code&gt; 变体转换为更实际的错误，而无需包含有关 &lt;code&gt;thread 'main'&lt;/code&gt; 和 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 的周围文本，从而避免出现 &lt;code&gt;panic!&lt;/code&gt; 原因。</target>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">我们可以像使用向量一样，使用 &lt;code&gt;for&lt;/code&gt; 循环对哈希映射中的每个键/值对进行迭代：</target>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="translated">我们可以用更复杂的方式混合、匹配和嵌套解构模式。下面的例子显示了一个复杂的重构,我们在一个元组中嵌套结构和元组,并将所有的基元值重构出来。</target>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="translated">我们现在可以添加 &lt;code&gt;use rand;&lt;/code&gt; 到&lt;em&gt;add-one / src / lib.rs&lt;/em&gt;文件，并通过在&lt;em&gt;add&lt;/em&gt;目录中运行 &lt;code&gt;cargo build&lt;/code&gt; 来构建整个工作区，将引入并编译 &lt;code&gt;rand&lt;/code&gt; crate：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="translated">我们可以将任何测试函数的名称传递给 &lt;code&gt;cargo test&lt;/code&gt; 以仅运行该测试：</target>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="translated">我们可能会猜到它在做什么：&amp;ldquo;将值 &lt;code&gt;5&lt;/code&gt; 绑定到 &lt;code&gt;x&lt;/code&gt; ；然后在 &lt;code&gt;x&lt;/code&gt; 中复制值并将其绑定到 &lt;code&gt;y&lt;/code&gt; 。&amp;rdquo;现在，我们有两个变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，它们都等于 &lt;code&gt;5&lt;/code&gt; 。确实发生了这种情况，因为整数是具有已知固定大小的简单值，并且这两个 &lt;code&gt;5&lt;/code&gt; 值被压入堆栈。</target>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="translated">通过将数据直接放入每个枚举变量中，我们可以仅使用枚举而不是结构内部的枚举以更简洁的方式表示相同的概念。 &lt;code&gt;IpAddr&lt;/code&gt; 枚举的新定义表明 &lt;code&gt;V4&lt;/code&gt; 和 &lt;code&gt;V6&lt;/code&gt; 变体都将具有关联的 &lt;code&gt;String&lt;/code&gt; 值：</target>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="translated">我们可以重写清单15-6中的代码，以使用 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 代替引用。解除引用运算符的工作方式如清单15-7所示：</target>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="translated">我们可以看到， &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 在 &lt;code&gt;a&lt;/code&gt; 具有1的初始参考计数; 然后每次调用 &lt;code&gt;clone&lt;/code&gt; 时，计数都会增加1。当 &lt;code&gt;c&lt;/code&gt; 超出范围时，计数将减少1。我们不必像调用 &lt;code&gt;Rc::clone&lt;/code&gt; 那样调用函数来减少引用计数。克隆以增加引用计数：当 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值超出范围时， &lt;code&gt;Drop&lt;/code&gt; trait 的实现会自动减少引用计数。</target>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="translated">我们可以在测试输出中看到我们实际得到的值,这将帮助我们调试发生了什么,而不是我们期望发生的事情。</target>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="translated">我们可以指定测试名称的一部分，然后运行任何名称与该值匹配的测试。例如，由于我们的两个测试名称包含 &lt;code&gt;add&lt;/code&gt; ，我们可以通过运行 &lt;code&gt;cargo test add&lt;/code&gt; 来运行这两个：</target>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="translated">我们仍然可以做得更好！由于这些都是字符串，因此我们可以使用 &lt;code&gt;From::from&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="translated">通过将测试函数的名称指定为 &lt;code&gt;cargo test&lt;/code&gt; 的参数，我们仍然可以运行特定的集成测试函数。要在特定的集成测试文件中运行所有测试，请使用 &lt;code&gt;cargo test&lt;/code&gt; 的 &lt;code&gt;--test&lt;/code&gt; 参数后跟文件名：</target>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="translated">我们可以采取另一个小步骤来进一步改进 &lt;code&gt;parse_config&lt;/code&gt; 函数。目前，我们正在返回一个元组，但是随后我们立即将该元组再次分解为各个部分。这表明也许我们还没有正确的抽象。</target>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="translated">我们可以使用 &lt;code&gt;LineWriter&lt;/code&gt; 一次写入一行，从而大大减少了实际写入文件的次数。</target>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">我们可以在路径的任何级别上使用嵌套路径，这在组合两个共享一个子路径的 &lt;code&gt;use&lt;/code&gt; 语句时很有用。例如，清单7-19显示了两个 &lt;code&gt;use&lt;/code&gt; 语句：一个将 &lt;code&gt;std::io&lt;/code&gt; 纳入范围，另一个将 &lt;code&gt;std::io::Write&lt;/code&gt; 纳入范围。</target>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="translated">我们可以使用泛型为诸如函数签名或结构之类的项创建定义，然后可以将其用于许多不同的具体数据类型。首先让我们看看如何使用泛型定义函数，结构，枚举和方法。然后，我们将讨论泛型如何影响代码性能。</target>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="translated">我们可以编写测试来断言例如，当我们将 &lt;code&gt;3&lt;/code&gt; 传递给 &lt;code&gt;add_two&lt;/code&gt; 函数时，返回的值为 &lt;code&gt;5&lt;/code&gt; 。只要对代码进行更改，就可以运行这些测试，以确保任何现有的正确行为都没有更改。</target>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="translated">我们可以使用迭代器适配器方法以更简洁的方式编写此代码。这样做还使我们避免了可变的中间 &lt;code&gt;results&lt;/code&gt; 向量。函数式编程风格倾向于将可变状态的数量减到最少，以使代码更清晰。删除可变状态可以使将来的增强功能使搜索并行进行，因为我们不必管理对 &lt;code&gt;results&lt;/code&gt; 向量的并发访问。清单13-29显示了此更改：</target>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="translated">当值超出范围时，我们不能禁用 &lt;code&gt;drop&lt;/code&gt; 的自动插入，也不能显式调用 &lt;code&gt;drop&lt;/code&gt; 方法。因此，如果需要强制早期清除某个值，则可以使用 &lt;code&gt;std::mem::drop&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="translated">我们不能对函数做同样的事情。如果我们尝试下面的示例，我们的代码将无法编译：</target>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">我们不能仅使用安全的Rust来实现此功能。尝试可能类似于清单19-5，但无法编译。为简单起见，我们将实现 &lt;code&gt;split_at_mut&lt;/code&gt; 的功能，而不是一种方法，只对切片 &lt;code&gt;i32&lt;/code&gt; 值，而不是一个泛型类型 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="translated">我们无法修改 &lt;code&gt;MockMessenger&lt;/code&gt; 来跟踪消息，因为 &lt;code&gt;send&lt;/code&gt; 方法对 &lt;code&gt;self&lt;/code&gt; 进行了不可变的引用。我们也不能接受错误文本中的建议来改用 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ，因为 &lt;code&gt;send&lt;/code&gt; 的签名与 &lt;code&gt;Messenger&lt;/code&gt; trait定义中的签名不匹配（可以随意尝试并查看收到的错误消息）。</target>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="translated">我们不能以这种方式指定多个测试的名称。仅使用提供给 &lt;code&gt;cargo test&lt;/code&gt; 的第一个值。但是有一种方法可以运行多个测试。</target>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">我们无法创建 &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;Foo&lt;/code&gt; 类型的对象，因为在这种情况下，将不会调整 &lt;code&gt;Self&lt;/code&gt; 的 &lt;code&gt;Sized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">我们选择 &lt;code&gt;usize&lt;/code&gt; 作为 &lt;code&gt;size&lt;/code&gt; 参数的类型，因为我们知道负数的线程没有任何意义。我们也知道我们将使用这4作为线程集合中的元素数量，这就是 &lt;code&gt;usize&lt;/code&gt; 类型的用途，如第3章的&lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;整数类型&amp;rdquo;&lt;/a&gt;部分所述。</target>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="translated">我们克隆 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 在 &lt;code&gt;leaf&lt;/code&gt; 和存储在 &lt;code&gt;branch&lt;/code&gt; ，这意味着 &lt;code&gt;Node&lt;/code&gt; 在 &lt;code&gt;leaf&lt;/code&gt; 现在有两个主人： &lt;code&gt;leaf&lt;/code&gt; 和 &lt;code&gt;branch&lt;/code&gt; 。我们可以从获得 &lt;code&gt;branch&lt;/code&gt; 到 &lt;code&gt;leaf&lt;/code&gt; 通过 &lt;code&gt;branch.children&lt;/code&gt; ，但有没有办法让从 &lt;code&gt;leaf&lt;/code&gt; 到 &lt;code&gt;branch&lt;/code&gt; 。原因是 &lt;code&gt;leaf&lt;/code&gt; 没有对 &lt;code&gt;branch&lt;/code&gt; 引用，也不知道它们之间的关系。我们希望 &lt;code&gt;leaf&lt;/code&gt; 知道 &lt;code&gt;branch&lt;/code&gt; 是其父级。接下来，我们将做。</target>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="translated">我们也可以使用 &lt;code&gt;vec!&lt;/code&gt; 宏以生成两个整数的向量或五个字符串切片的向量。我们将无法使用函数来执行相同的操作，因为我们不预先知道值的数量或类型。</target>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="translated">我们可以改为更改 &lt;code&gt;Cons&lt;/code&gt; 的定义以保留引用，但是随后我们必须指定生存期参数。通过指定生命周期参数，我们将指定列表中的每个元素的寿命至少与整个列表一样长。借位检查器不会让我们编译 &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; 例如，由于暂时 &lt;code&gt;Nil&lt;/code&gt; 值将之前被丢弃 &lt;code&gt;a&lt;/code&gt; 可能需要对它的引用。</target>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="translated">我们可以在这里做更多的事情!如果你想继续加强这个项目,这里有一些想法:如果你想继续加强这个项目,这里有一些想法。</target>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="translated">我们可以调用 &lt;code&gt;a.clone()&lt;/code&gt; 而不是 &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt; ，但是Rust的约定是在这种情况下使用 &lt;code&gt;Rc::clone&lt;/code&gt; 。实施 &lt;code&gt;Rc::clone&lt;/code&gt; 并不能使所有的深层副本最喜欢的类型的实现数据 &lt;code&gt;clone&lt;/code&gt; 做。对 &lt;code&gt;Rc::clone&lt;/code&gt; 的调用只会增加引用计数，而不会花费很多时间。数据的深拷贝可能会花费很多时间。通过使用 &lt;code&gt;Rc::clone&lt;/code&gt; 进行引用计数，我们可以在视觉上区分深复制类型的克隆和增加引用计数的克隆类型。在代码中查找性能问题时，我们只需要考虑深拷贝克隆，就可以忽略对 &lt;code&gt;Rc::clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="translated">我们可以通过许多不同的方法来管理 &lt;code&gt;String&lt;/code&gt; 数据，但是最简单的方法（尽管效率低下）是在值上调用 &lt;code&gt;clone&lt;/code&gt; 方法。这将为 &lt;code&gt;Config&lt;/code&gt; 实例拥有一个完整的数据副本，这比存储对字符串数据的引用要花更多的时间和内存。但是，克隆数据也使我们的代码非常简单，因为我们不必管理引用的生存期。在这种情况下，为了获得简单性而放弃一些性能是一个值得权衡的选择。</target>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="translated">我们可以通过多种方式重组锻炼计划。首先，我们将尝试将对 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 函数的重复调用提取到一个变量中，如清单13-4所示。</target>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">例如，我们可以仅在 &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; 实例上实现方法，而不能在具有任何泛型类型的 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 实例上实现方法。在清单10-10中，我们使用具体类型 &lt;code&gt;f32&lt;/code&gt; ，这意味着我们在 &lt;code&gt;impl&lt;/code&gt; 之后不声明任何类型。</target>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="translated">本章涵盖了很多内容！既然您已经了解了通用类型参数，特征和特征边界以及通用生命周期参数，那么您就可以编写无需重复的代码了，这些代码在许多不同的情况下都有效。通用类型参数使您可以将代码应用于不同类型。特质和特征界限确保即使类型是通用的，它们也将具有代码所需的行为。您学习了如何使用生命周期注释，以确保此灵活的代码不会有任何悬而未决的引用。而且所有这些分析都是在编译时进行的，这不会影响运行时性能！</target>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="translated">我们创建了一个 &lt;code&gt;counter&lt;/code&gt; 变量来将 &lt;code&gt;i32&lt;/code&gt; 容纳在 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ，如清单16-12所示。接下来，我们通过迭代一系列数字来创建10个线程。我们使用 &lt;code&gt;thread::spawn&lt;/code&gt; 并为所有线程赋予相同的闭包，该闭包将计数器移入线程，通过调用 &lt;code&gt;lock&lt;/code&gt; 方法获得 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 的锁，然后将1加到互斥锁中的值上。当一个线程完成其关闭操作后， &lt;code&gt;num&lt;/code&gt; 将超出范围并释放锁，以便另一个线程可以获取它。</target>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="translated">我们在项目目录的顶部&lt;em&gt;src&lt;/em&gt;旁边创建一个&lt;em&gt;测试&lt;/em&gt;目录。 Cargo知道要在此目录中查找集成测试文件。然后，我们可以在此目录中创建任意数量的测试文件，而Cargo会将每个文件作为单独的板条箱进行编译。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="translated">我们使用 &lt;code&gt;mpsc::channel&lt;/code&gt; 函数创建一个新通道； &lt;code&gt;mpsc&lt;/code&gt; 代表&lt;em&gt;多个生产者，一个消费者&lt;/em&gt;。简而言之，Rust的标准库实现通道的方式意味着一个通道可以具有多个产生值的&lt;em&gt;发送&lt;/em&gt;端，但只有一个&lt;em&gt;接收&lt;/em&gt;这些值的&lt;em&gt;接收&lt;/em&gt;端。想象一下，多股河流汇聚成一条大河：从任何一条河中流下来的一切最终都将最终汇入一条河流。现在，我们将从一个生产者开始，但是当我们使此示例运行时，我们将添加多个生产者。</target>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="translated">我们通过在括号内编写逗号分隔的值列表来创建元组。元组中的每个位置都有一个类型，并且元组中不同值的类型不必相同。在此示例中，我们添加了可选的类型注释：</target>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">我们创建一个作为 &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; 实例的值，并将其存储在名为 &lt;code&gt;value&lt;/code&gt; 的变量中，以便以后可以直接访问它。然后，我们在 &lt;code&gt;a&lt;/code&gt; 具有 &lt;code&gt;Cons&lt;/code&gt; 变体的 &lt;code&gt;List&lt;/code&gt; 中创建一个列表，该列表包含 &lt;code&gt;value&lt;/code&gt; 。我们需要克隆 &lt;code&gt;value&lt;/code&gt; 所以无论 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 有内部的所有权 &lt;code&gt;5&lt;/code&gt; 值而不是所有权转让 &lt;code&gt;value&lt;/code&gt; ，以 &lt;code&gt;a&lt;/code&gt; 或有 &lt;code&gt;a&lt;/code&gt; 从借 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="translated">我们创建了一个可变 &lt;code&gt;one_borrow&lt;/code&gt; 为 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 从返回智能指针 &lt;code&gt;borrow_mut&lt;/code&gt; 。然后，我们以相同的方式在变量 &lt;code&gt;two_borrow&lt;/code&gt; 中创建另一个可变借位。这使得两个可变引用在同一范围内，这是不允许的。当我们为库运行测试时，清单15-23中的代码将编译而没有任何错误，但是测试将失败：</target>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="translated">我们创建一个名为 &lt;code&gt;guess&lt;/code&gt; 的变量。但是，等等，程序是否已经没有名为 &lt;code&gt;guess&lt;/code&gt; 的变量？可以，但是Rust允许我们用一个新值来&lt;em&gt;掩盖&lt;/em&gt;以前的 &lt;code&gt;guess&lt;/code&gt; 值。此功能通常用于要将值从一种类型转换为另一种类型的情况。阴影使我们可以重用 &lt;code&gt;guess&lt;/code&gt; 变量名称，而不是强迫我们创建两个唯一变量，例如 &lt;code&gt;guess_str&lt;/code&gt; 和 &lt;code&gt;guess&lt;/code&gt; 。 （第3章将详细介绍阴影。）</target>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">我们创建一个 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 实例，该实例在变量 &lt;code&gt;a&lt;/code&gt; 中保存一个 &lt;code&gt;List&lt;/code&gt; 值，其初始列表为 &lt;code&gt;5, Nil&lt;/code&gt; 。然后，我们创建一个 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 实例保持另一个 &lt;code&gt;List&lt;/code&gt; 中的变量值 &lt;code&gt;b&lt;/code&gt; 包含值10，并指向列表中的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="translated">我们以 &lt;code&gt;mod&lt;/code&gt; 关键字开头定义模块，然后指定模块名称（在本例中为 &lt;code&gt;front_of_house&lt;/code&gt; ），并将大括号放在模块主体周围。在模块内部，我们可以有其他模块，在这种情况下，模块可以是 &lt;code&gt;hosting&lt;/code&gt; 和 &lt;code&gt;serving&lt;/code&gt; 。模块还可以保存其他项的定义，例如结构，枚举，常量，特征或功能（如清单7-1所示）。</target>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="translated">我们定义一个名为 &lt;code&gt;MyBox&lt;/code&gt; 的结构并声明一个泛型参数 &lt;code&gt;T&lt;/code&gt; ，因为我们希望我们的类型保存任何类型的值。所述 &lt;code&gt;MyBox&lt;/code&gt; 类型是一个元组与结构类型的一个元件 &lt;code&gt;T&lt;/code&gt; 。该 &lt;code&gt;MyBox::new&lt;/code&gt; 功能需要一个类型的一个参数 &lt;code&gt;T&lt;/code&gt; ，并返回一个 &lt;code&gt;MyBox&lt;/code&gt; 保存传入的值实例。</target>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="translated">我们定义变量 &lt;code&gt;b&lt;/code&gt; ,使其 &lt;code&gt;Box&lt;/code&gt; 的值指向在堆上分配的值 &lt;code&gt;5&lt;/code&gt; 。该程序将打印 &lt;code&gt;b = 5&lt;/code&gt; ;在这种情况下，我们可以像访问堆栈中的数据一样访问框中的数据。就像任何拥有的值一样，当某个框超出范围时（如 &lt;code&gt;b&lt;/code&gt; 在 &lt;code&gt;main&lt;/code&gt; 的结尾处一样），它将被释放。对该盒（存储在堆栈上）及其指向的数据（存储在堆上）进行释放。</target>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="translated">我们做到了！我们从0到10进行了计数，这似乎并不令人印象深刻，但是它确实为我们提供了很多有关 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 和线程安全性的知识。您还可以使用该程序的结构来执行更复杂的操作，而不仅仅是增加计数器。使用这种策略，您可以将计算分为独立的部分，将这些部分拆分为多个线程，然后使用 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 使每个线程用其部分更新最终结果。</target>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">我们没有处理 &lt;code&gt;None&lt;/code&gt; 情况，因此此代码将导致错误。幸运的是，这是Rust知道如何捕捉的错误。如果我们尝试编译此代码，则会收到此错误：</target>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="translated">我们在第7章中讨论了如何控制封装：我们可以使用 &lt;code&gt;pub&lt;/code&gt; 关键字来确定代码中哪些模块，类型，函数和方法应该是公共的，默认情况下其他所有内容都是私有的。例如，我们可以定义一个结构 &lt;code&gt;AveragedCollection&lt;/code&gt; 具有包含的矢量的场 &lt;code&gt;i32&lt;/code&gt; 值。该结构还可以包含一个包含向量值平均值的字段，这意味着不必在任何时候都需要按需计算平均值。换句话说， &lt;code&gt;AveragedCollection&lt;/code&gt; 将为我们缓存计算的平均值。清单17-1定义了 &lt;code&gt;AveragedCollection&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; ，我们向测试函数添加了另一个属性should_panic。如果函数内部的代码出现紧急情况，则此属性通过测试；如果函数内部的代码没有发生错误，则测试将失败。</target>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="translated">在这种情况下，我们没有得到非常有用的消息，但是当我们查看测试函数时，我们看到它用 &lt;code&gt;#[should_panic]&lt;/code&gt; 进行了注释。我们得到的失败意味着测试功能中的代码没有引起恐慌。</target>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="translated">我们不需要使用 &lt;code&gt;#[cfg(test)]&lt;/code&gt; 注释&lt;em&gt;test / integration_test.rs中的&lt;/em&gt;任何代码。Cargo会特别对待 &lt;code&gt;tests&lt;/code&gt; 目录，仅在我们运行 &lt;code&gt;cargo test&lt;/code&gt; 时才编译该目录中的文件。立即运行 &lt;code&gt;cargo test&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="translated">我们不拥有此任意位置的内存，并且不能保证此代码创建的切片包含有效的 &lt;code&gt;i32&lt;/code&gt; 值。尝试像使用 &lt;code&gt;slice&lt;/code&gt; 一样将其视为有效切片会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="translated">我们不仅需要为 &lt;code&gt;Trait&lt;/code&gt; 所有方法的所有实现创建一个表，还需要为馈给 &lt;code&gt;foo()&lt;/code&gt; 的每种不同类型创建一个这样的表。在这种情况下，结果是（实现 &lt;code&gt;Trait&lt;/code&gt; 10种类型）*（馈给 &lt;code&gt;foo()&lt;/code&gt; 的 3种类型）= 30种实现！</target>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="translated">我们最终会有不同的输出。</target>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="translated">我们用 &lt;code&gt;&amp;amp;self.0&lt;/code&gt; 填充 &lt;code&gt;deref&lt;/code&gt; 方法的主体，因此 &lt;code&gt;deref&lt;/code&gt; 返回对要使用 &lt;code&gt;*&lt;/code&gt; 运算符访问的值的引用。清单15-9中的 &lt;code&gt;main&lt;/code&gt; 函数在 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 值上调用 &lt;code&gt;*&lt;/code&gt; ，现在可以编译，并且断言可以通过！</target>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="translated">我们首先在第10章的&lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;特征：定义共享行为&amp;rdquo;&lt;/a&gt;部分介绍了特征，但与生命周期一样，我们没有讨论更高级的细节。现在，您对Rust有了更多的了解，我们可以深入了解。</target>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="translated">我们修正了全书中的一些小错误和不准确的文字。感谢举报的读者!</target>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="translated">我们使用 &lt;code&gt;ast.ident&lt;/code&gt; 获得了一个 &lt;code&gt;Ident&lt;/code&gt; 结构实例，其中包含带注释类型的名称（标识符）。清单19-32表明，当我们运行中的结构 &lt;code&gt;impl_hello_macro&lt;/code&gt; 对上市19-30中的代码功能， &lt;code&gt;ident&lt;/code&gt; 我们得到的将有 &lt;code&gt;ident&lt;/code&gt; 字段的值 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; 。因此，清单19-33中的 &lt;code&gt;name&lt;/code&gt; 变量将包含一个 &lt;code&gt;Ident&lt;/code&gt; struct实例，该实例在打印时将是字符串 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; ，即清单19-30中该结构的名称。</target>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="translated">我们收到一条错误消息，指出 &lt;code&gt;Display&lt;/code&gt; 是必需的，但尚未实现：</target>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="translated">我们得到一个错误。</target>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="translated">我们用与清单4-7中相同的方法,通过寻找第一次出现的空格来获取词尾的索引。当我们找到一个空格时,我们使用字符串的开始和空格的索引作为开始和结束的索引,返回一个字符串片断。</target>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="translated">我们为 &lt;code&gt;Post&lt;/code&gt; 提供了一个名为 &lt;code&gt;request_review&lt;/code&gt; 的公共方法，该方法将可变引用 &lt;code&gt;self&lt;/code&gt; 。然后，我们在 &lt;code&gt;Post&lt;/code&gt; 的当前状态上调用内部 &lt;code&gt;request_review&lt;/code&gt; 方法，此第二个 &lt;code&gt;request_review&lt;/code&gt; 方法使用当前状态并返回新状态。</target>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="translated">我们有一个特质和它的功能。这时,我们的箱子用户就可以通过实现特质来实现所需的功能,比如这样。</target>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="translated">我们还有另一个有用的模式，该模式利用了元组结构和元组结构枚举变量的实现细节。这些类型使用 &lt;code&gt;()&lt;/code&gt; 作为初始化语法，看起来像一个函数调用。初始化程序实际上是作为返回由其参数构造的实例的函数实现的。我们可以将这些初始化函数用作实现闭包特征的函数指针，这意味着我们可以将初始化函数指定为采用闭包的方法的参数，如下所示：</target>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="translated">现在，我们可以运行大多数游戏，但是用户只能做出一个猜测。让我们通过添加一个循环来改变它！</target>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">我们有两个结构， &lt;code&gt;Millimeters&lt;/code&gt; 和 &lt;code&gt;Meters&lt;/code&gt; ，以不同的单位保存值。我们想要将以毫米为单位的值与以米为单位的值相加，并使 &lt;code&gt;Add&lt;/code&gt; 的实现正确执行转换。我们可以实现 &lt;code&gt;Add&lt;/code&gt; 为 &lt;code&gt;Millimeters&lt;/code&gt; 与 &lt;code&gt;Meters&lt;/code&gt; 的 &lt;code&gt;RHS&lt;/code&gt; ，如清单19-15英寸</target>
        </trans-unit>
        <trans-unit id="d8a3dea7c52bc3f0b1a5887645fbfc3ac18bf504" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;Rhs&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160ceff2ab6cdd2b56a8bbd9402294ab3fbd2021" translate="yes" xml:space="preserve">
          <source>We have written an &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;async book&lt;/a&gt; detailing async/await and trade-offs compared to using threads.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
