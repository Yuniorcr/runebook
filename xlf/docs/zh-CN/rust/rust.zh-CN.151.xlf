<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="184f5f1102022e13bc531fc4c3a2f314884b9200" translate="yes" xml:space="preserve">
          <source>The solution is to coerce the array to a slice by calling a slice method:</source>
          <target state="translated">解决的办法是通过调用分片方法将数组胁迫成一个分片。</target>
        </trans-unit>
        <trans-unit id="4b8f691075403fc3cc04a12f17630d0a22222627" translate="yes" xml:space="preserve">
          <source>The solution is to declare the imports at the top of the block, function, or file.</source>
          <target state="translated">解决方法是在块、函数或文件的顶部声明导入。</target>
        </trans-unit>
        <trans-unit id="6d341bfc87265fdb3200162c1071f84eb34afeb9" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the items that you are re-exporting are themselves marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">解决此问题的方法是确保您要重新导出的项目本身都用 &lt;code&gt;pub&lt;/code&gt; 标记：</target>
        </trans-unit>
        <trans-unit id="ca1c4540563346f3ae5ba53810b40773e7e12128" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the module that you are re-exporting is itself marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">解决此问题的方法是确保要重新导出的模块本身已标记为 &lt;code&gt;pub&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ca9d7e79f3cd051af83e1b93c6feb0514cb1adc8" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated constant:</source>
          <target state="translated">解决这个问题的方法是去掉无关的关联常数。</target>
        </trans-unit>
        <trans-unit id="b66ecfc5844845f6ce826665530fcbac23beb458" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated type:</source>
          <target state="translated">解决这个问题的方法是删除无关的关联类型。</target>
        </trans-unit>
        <trans-unit id="f5e669f80a825dd22d2d4e3f89464bdf72e0692e" translate="yes" xml:space="preserve">
          <source>The solution to this problem is usually to switch to using a &lt;code&gt;move&lt;/code&gt; closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</source>
          <target state="translated">解决此问题的方法通常是切换到使用 &lt;code&gt;move&lt;/code&gt; 闭包。这种方法将数据移动（或复制，如果可能的话）到闭包中，而不是引用它。例如：</target>
        </trans-unit>
        <trans-unit id="4bc18e7ccda6a6b48c7507cdd496e8030bd28ca8" translate="yes" xml:space="preserve">
          <source>The source files from which this book is generated can be found on &lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">生成本书的源文件可以在&lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt;上找到。</target>
        </trans-unit>
        <trans-unit id="a49d6b47901cd19039274da891afacb7623398fb" translate="yes" xml:space="preserve">
          <source>The spawned thread may outlive the caller (unless the caller thread is the main thread; the whole process is terminated when the main thread finishes). The join handle can be used to block on termination of the child thread, including recovering its panics.</source>
          <target state="translated">生成的线程可能比调用者的寿命长(除非调用者线程是主线程;当主线程结束时,整个进程就会被终止)。加入句柄可以在子线程终止时进行阻塞,包括恢复其恐慌。</target>
        </trans-unit>
        <trans-unit id="3de206631f62d211730a1cc35e89663e7062bcfa" translate="yes" xml:space="preserve">
          <source>The specified environment variable was found, but it did not contain valid unicode data. The found data is returned as a payload of this variant.</source>
          <target state="translated">找到了指定的环境变量,但它不包含有效的unicode数据。找到的数据将作为该变量的有效载荷返回。</target>
        </trans-unit>
        <trans-unit id="ea36c8e1fa9f0022c16977222444b4a3c0ab84f9" translate="yes" xml:space="preserve">
          <source>The specified environment variable was not present in the current process's environment.</source>
          <target state="translated">在当前进程的环境中不存在指定的环境变量。</target>
        </trans-unit>
        <trans-unit id="9c4c268712a390c3c5b86d16dfd79086d462c7e5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;core::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../any/fn.type_name&quot;&gt; &lt;code&gt;core::any::type_name&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45eb3e7f185d35fea76d0fcc8feefcf81bfa67b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;crate::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../any/fn.type_name&quot;&gt; &lt;code&gt;crate::any::type_name&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89d879802905e96d1dbbee3b2bc193bcd1e8d256" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;core::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt; &lt;code&gt;core::any::TypeId::of&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd9900dab1e575f89f6a70cab38ccde57d12f174" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;crate::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt; &lt;code&gt;crate::any::TypeId::of&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57f913c926721dcfb858ba0f49073ea9578b8b3f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;core::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;core::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="176610383e559ab75c30b3e60918dcf39baa4491" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="769e7a49a82fbc73600ab216f157a9a4edfed6d2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68bf1becb5538df04aef3bc27ba3a8fc1c5f4d80" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;core::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.align_of&quot;&gt; &lt;code&gt;core::mem::align_of&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f707ad710f27d4a519df162d93207b489b43663" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;crate::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.align_of&quot;&gt; &lt;code&gt;crate::mem::align_of&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb235568e3ec680a5ddbb056614a4544c534c3b1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;core::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.align_of_val&quot;&gt; &lt;code&gt;core::mem::align_of_val&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bb92f5b8279175442866093e128f5cb80c5d7d4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;crate::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.align_of_val&quot;&gt; &lt;code&gt;crate::mem::align_of_val&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b63712fb966ee55e431373c44ee70e5bdcc0d5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;core::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.discriminant&quot;&gt; &lt;code&gt;core::mem::discriminant&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0a9a6b3a12732480c74ccdbdd6c6cd441416852" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;crate::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.discriminant&quot;&gt; &lt;code&gt;crate::mem::discriminant&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f183bce94483cede38b2e29f8c8da04b39e389f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.needs_drop&quot;&gt; &lt;code&gt;mem::needs_drop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="626a03e32989e459202fcca2e29d114287d2e779" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;std::mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../mem/fn.needs_drop&quot;&gt; &lt;code&gt;std::mem::needs_drop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf0f4e1682c5598721794a53177e6ce27697d607" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;core::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;core::mem::size_of&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b581000bfc2472e309baf4b78516cb35a337926" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;std::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;std::mem::size_of&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4df5be2153e7097fd8b00742eff3c445821681d5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../mem/fn.size_of_val&quot;&gt; &lt;code&gt;mem::size_of_val&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5867b1e1c4944c1f7ed32488f5be2fa294b4986f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;std::mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../mem/fn.size_of_val&quot;&gt; &lt;code&gt;std::mem::size_of_val&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c59076c6d4d0031edb1c4f415f280b4da6dafbd0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.abs&quot;&gt;&lt;code&gt;f32::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.abs&quot;&gt; &lt;code&gt;f32::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1746aa772dc9c98fd4e848556bc017af5d5a5814" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.abs&quot;&gt;&lt;code&gt;std::f32::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.abs&quot;&gt; &lt;code&gt;std::f32::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="47013c0ec935095e1a4e5659f91e1818366ac3e5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt;&lt;code&gt;f32::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt; &lt;code&gt;f32::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd019f674bd918f6d03e4b0946395283db961b78" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt;&lt;code&gt;std::f32::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt; &lt;code&gt;std::f32::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff2a20e7040f371886fddde3d5d0aea49e7b9e75" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt;&lt;code&gt;f32::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt; &lt;code&gt;f32::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26bbd19c72d02740271e9c35e7a28be8dc08d048" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt;&lt;code&gt;std::f32::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt; &lt;code&gt;std::f32::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec5cc01e5c172311009522a07ac5d183750d6d81" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.cos&quot;&gt;&lt;code&gt;f32::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.cos&quot;&gt; &lt;code&gt;f32::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61c494ecc8ddd36d321a87c24568cbae459fddb9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.cos&quot;&gt;&lt;code&gt;std::f32::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f32#method.cos&quot;&gt; &lt;code&gt;std::f32::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f06ef82a78f7a4024acdcdb7d73d0d0ac173270a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp&quot;&gt;&lt;code&gt;f32::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.exp&quot;&gt; &lt;code&gt;f32::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94b0a8ab3fca707be3b5a4c013197b6ace7d6752" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp&quot;&gt;&lt;code&gt;std::f32::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.exp&quot;&gt; &lt;code&gt;std::f32::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e71b674a8b3daccfabfde5a3327bc5ce0e9a7433" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt;&lt;code&gt;f32::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt; &lt;code&gt;f32::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="336a8852727ebc5c24637be3db7e37b682324956" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt;&lt;code&gt;std::f32::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt; &lt;code&gt;std::f32::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef999425e063cf922fc52c938e7f64b251f8528a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.floor&quot;&gt;&lt;code&gt;f32::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.floor&quot;&gt; &lt;code&gt;f32::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46e4b0f6edf39422d28e3db71bd5ccc4aa08c8f3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.floor&quot;&gt;&lt;code&gt;std::f32::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.floor&quot;&gt; &lt;code&gt;std::f32::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b4e945064f35f2cb6d90bc10c0ca36ea2ce1fc5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ln&quot;&gt;&lt;code&gt;f32::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.ln&quot;&gt; &lt;code&gt;f32::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c54f6e18bc6b7c8320c4a68ccd5c641025d11b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ln&quot;&gt;&lt;code&gt;std::f32::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.ln&quot;&gt; &lt;code&gt;std::f32::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9f4ef290bee69ae88378d994f355ffa4fb435beb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log10&quot;&gt;&lt;code&gt;f32::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.log10&quot;&gt; &lt;code&gt;f32::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8fbd8555b23fb5da5a31c3691aceae539093012" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log10&quot;&gt;&lt;code&gt;std::f32::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.log10&quot;&gt; &lt;code&gt;std::f32::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="47c9c0a841eaf6a6f0fa9aa6dc7785deb7fd8ac5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log2&quot;&gt;&lt;code&gt;f32::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.log2&quot;&gt; &lt;code&gt;f32::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="163981a463a3f186e653d8b1d906aacc60bb507a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log2&quot;&gt;&lt;code&gt;std::f32::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.log2&quot;&gt; &lt;code&gt;std::f32::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aad71542a1a997b3c3c61f5ecfa210cbb95931d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.max&quot;&gt;&lt;code&gt;f32::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.max&quot;&gt; &lt;code&gt;f32::max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="275c6f9b837c44f59265b27a725f706ea01e4d88" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.min&quot;&gt;&lt;code&gt;f32::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.min&quot;&gt; &lt;code&gt;f32::min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f2f31fe43255d310cae69c74b408f6410f5ded2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt;&lt;code&gt;f32::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt; &lt;code&gt;f32::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37a1adc351bf8541ff50457503f42947d2223aa1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt;&lt;code&gt;std::f32::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt; &lt;code&gt;std::f32::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d06b2fdd5487c383c0b421cebefc28c6a24ea36" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powf&quot;&gt;&lt;code&gt;f32::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f32#method.powf&quot;&gt; &lt;code&gt;f32::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="824767dc22e0a666300f3bbc86838e9e982d5929" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powf&quot;&gt;&lt;code&gt;std::f32::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.powf&quot;&gt; &lt;code&gt;std::f32::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7d21f72d00e2760827f66a8c462f67a27736316" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powi&quot;&gt;&lt;code&gt;f32::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f32#method.powi&quot;&gt; &lt;code&gt;f32::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a9c8c235c9463f3bd3c7f8d97084f0aa09a4e6b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powi&quot;&gt;&lt;code&gt;std::f32::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f32#method.powi&quot;&gt; &lt;code&gt;std::f32::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c881538f43f115b6ccda31fbe918dd558ba56f8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.round&quot;&gt;&lt;code&gt;f32::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.round&quot;&gt; &lt;code&gt;f32::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f7c21362121499d029cb16e6e1a0c1b3f1e8a1a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.round&quot;&gt;&lt;code&gt;std::f32::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.round&quot;&gt; &lt;code&gt;std::f32::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="675171a011c1c0dfda9fdb538a7b419773cfeee8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sin&quot;&gt;&lt;code&gt;f32::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.sin&quot;&gt; &lt;code&gt;f32::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4af107006e6e31e8e831e5d5f7bf515b2e1cc7d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sin&quot;&gt;&lt;code&gt;std::f32::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.sin&quot;&gt; &lt;code&gt;std::f32::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d0e62ce93ec102c4eead3eff69bc612612edb07" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt;&lt;code&gt;f32::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt; &lt;code&gt;f32::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34b79ebb4c8dc7ee3e2e853d2ae83194460b52cd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt;&lt;code&gt;std::f32::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt; &lt;code&gt;std::f32::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b0f76f9eba1cda2a09785fdd498932063401952" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt;&lt;code&gt;f32::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt; &lt;code&gt;f32::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f3efeb8ac74af1f762963525599c78dfb84b4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt;&lt;code&gt;std::f32::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt; &lt;code&gt;std::f32::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d88a568ad8f8f15ad581e2d5ef7c8ca62ce8387a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.abs&quot;&gt;&lt;code&gt;f64::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.abs&quot;&gt; &lt;code&gt;f64::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f50e2d709a0ab57a5af9a3d0b85809c7253cdbbe" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.abs&quot;&gt;&lt;code&gt;std::f64::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.abs&quot;&gt; &lt;code&gt;std::f64::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ac445ccfe25309fd842b9fe20592468190678f7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt;&lt;code&gt;f64::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt; &lt;code&gt;f64::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8077c0447a55f70ad3a41280e7cdad8b5a596e3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt;&lt;code&gt;std::f64::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt; &lt;code&gt;std::f64::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d43f75605bcf4ddc2af35ee89730b68b196c9219" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt;&lt;code&gt;f64::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt; &lt;code&gt;f64::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c784852d478dc5b87ed608a83b4485e61ffaa08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt;&lt;code&gt;std::f64::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt; &lt;code&gt;std::f64::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3550799fc1b021ace5a8f1df4ae70f43d6163e8d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.cos&quot;&gt;&lt;code&gt;f64::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.cos&quot;&gt; &lt;code&gt;f64::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3706879950fc2f859ec3405d83c39468b3d127b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.cos&quot;&gt;&lt;code&gt;std::f64::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f64#method.cos&quot;&gt; &lt;code&gt;std::f64::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcb9280b04f00b11f52eea8164711ab78a092d25" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp&quot;&gt;&lt;code&gt;f64::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.exp&quot;&gt; &lt;code&gt;f64::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fe60787bdb5a14582899986ea8a8eb5151f047a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp&quot;&gt;&lt;code&gt;std::f64::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.exp&quot;&gt; &lt;code&gt;std::f64::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7f04aba7f3a4beeef49c10ce9640ff19e53f34b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt;&lt;code&gt;f64::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt; &lt;code&gt;f64::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d57c3217aae4fa0b39647c7df0a1a27ba3ce04c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt;&lt;code&gt;std::f64::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt; &lt;code&gt;std::f64::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fae80008b865720f6e13bfbc5cb79b02660d2353" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.floor&quot;&gt;&lt;code&gt;f64::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.floor&quot;&gt; &lt;code&gt;f64::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06ec2f6c9475943bd6d7a554d14049a4e570f218" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.floor&quot;&gt;&lt;code&gt;std::f64::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.floor&quot;&gt; &lt;code&gt;std::f64::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="afd11870530d9075c63b4f2c171a0c02c8ef5bd2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ln&quot;&gt;&lt;code&gt;f64::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.ln&quot;&gt; &lt;code&gt;f64::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95c322d0525dc747c93c991f848c51c52ac90096" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ln&quot;&gt;&lt;code&gt;std::f64::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.ln&quot;&gt; &lt;code&gt;std::f64::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a849c91cc9020bd1712dfc308a1d7d29fd8face" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log10&quot;&gt;&lt;code&gt;f64::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.log10&quot;&gt; &lt;code&gt;f64::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85342dac467b551f64948da385b26bae5ec304e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log10&quot;&gt;&lt;code&gt;std::f64::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.log10&quot;&gt; &lt;code&gt;std::f64::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9055c0969c2b78cf9771c996a47a48e0769baeb7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log2&quot;&gt;&lt;code&gt;f64::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.log2&quot;&gt; &lt;code&gt;f64::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1fcf5615e4f3f284291f587c194c0ee80f02e1b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log2&quot;&gt;&lt;code&gt;std::f64::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.log2&quot;&gt; &lt;code&gt;std::f64::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a33d40ec03fc6fd7670da5d91bb3dff1514508d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.max&quot;&gt;&lt;code&gt;f64::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.max&quot;&gt; &lt;code&gt;f64::max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c5caceb4a4959b387b99fbf4eb4112cfa719de9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.min&quot;&gt;&lt;code&gt;f64::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.min&quot;&gt; &lt;code&gt;f64::min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="518adc096d165e8f401829826bfaabd640d9a726" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt;&lt;code&gt;f64::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt; &lt;code&gt;f64::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="184af9c54cafa84b2f1da9d8430a1cc45e2501b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt;&lt;code&gt;std::f64::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt; &lt;code&gt;std::f64::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1cdfbf12432c22c607219d187794a3b529a7e2e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powf&quot;&gt;&lt;code&gt;f64::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f64#method.powf&quot;&gt; &lt;code&gt;f64::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8a62ab1447e5a688dfc2804caf90414ec922c3e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powf&quot;&gt;&lt;code&gt;std::f64::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.powf&quot;&gt; &lt;code&gt;std::f64::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d54daeba51c0c9cfed548b84a0682e9821fb0b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powi&quot;&gt;&lt;code&gt;f64::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f64#method.powi&quot;&gt; &lt;code&gt;f64::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53fa85dcefba2eba944e099df5e0b7568320b594" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powi&quot;&gt;&lt;code&gt;std::f64::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../primitive.f64#method.powi&quot;&gt; &lt;code&gt;std::f64::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa845dfec19ebaf2ac42966a984b43ad55a0ddad" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.round&quot;&gt;&lt;code&gt;f64::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.round&quot;&gt; &lt;code&gt;f64::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab11dcc6899cdf3c196ec2500a4f98d80cd92c0f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.round&quot;&gt;&lt;code&gt;std::f64::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.round&quot;&gt; &lt;code&gt;std::f64::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e47e25508412a5764ef644028828d65890164d90" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sin&quot;&gt;&lt;code&gt;f64::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.sin&quot;&gt; &lt;code&gt;f64::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbc17db1c9e9aeccadbae543736abc641bf19581" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sin&quot;&gt;&lt;code&gt;std::f64::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.sin&quot;&gt; &lt;code&gt;std::f64::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aab8fda9ab2f4c6fd89c1ca7b171ffb239f10245" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt;&lt;code&gt;f64::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt; &lt;code&gt;f64::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9259a474b9633d2c178bcfa8945b9cf932f9b62" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt;&lt;code&gt;std::f64::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt; &lt;code&gt;std::f64::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcd69b9cb458bcc7c40b2d8d643f01b68bc057b5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt;&lt;code&gt;f64::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt; &lt;code&gt;f64::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09d46fbb4d6dd94cb20b274b64fb45bedd897ee1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt;&lt;code&gt;std::f64::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt; &lt;code&gt;std::f64::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e24ba042f8ed9a32e5152ef40108b6331e9ff075" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;std::pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;std::pointer::offset&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8ef8497ee38f892bb72694c3c391e01cf452f3c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt;&lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt; &lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93a878abfa4b4b05965b5ed62c9134a4b23816af" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f777a2d25d61f2a8a030aed5ab4e20e176d153a8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;core::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt; &lt;code&gt;core::ptr::read_volatile&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc0344746e9b397b268af814908260e075e04e91" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;crate::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt; &lt;code&gt;crate::ptr::read_volatile&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05ad03e9160cb2408f7bd5aa45c03727935da29f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;core::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;core::ptr::write&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="118ab008d64be2589235ff02dc721d1434d90f79" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;crate::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;crate::ptr::write&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aac108773792d7b27741d0ad608d7eda680fdf09" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;core::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt; &lt;code&gt;core::ptr::write_volatile&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70902b9a0728e1e3dbaf882574f3b031e91654e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;crate::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本是&lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt; &lt;code&gt;crate::ptr::write_volatile&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="625b254ad12639bd7cf3b4b8d18b0e6a86ce6669" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.needs_drop&quot;&gt;&lt;code&gt;needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;fn.needs_drop&quot;&gt; &lt;code&gt;needs_drop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4decf20d903cd057fdbbe638ed8d8e3f26c756a4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4c9dc52f1e3d1631dde7d53032bcc39a6df9f72" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本为&lt;a href=&quot;fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58429d40c9c7f24b0a6d088073711682d0c11242" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ,可以在&lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt;使用此内在函数的稳定版本。</target>
        </trans-unit>
        <trans-unit id="5311916c06b10b8c928d0abda98be268ace4e6d6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ,可以在&lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt;使用此内在函数的稳定版本。</target>
        </trans-unit>
        <trans-unit id="3081645830dba10410e4d31cc6a792e5fa76abfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; 传递，可以在&lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt;使用此内在函数的稳定版本。</target>
        </trans-unit>
        <trans-unit id="5e8d39a214853d9287e37063d7cab0006a733cdd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ,可以在&lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt;使用此内在函数的稳定版本。</target>
        </trans-unit>
        <trans-unit id="2cb2b502c2611a7e2eb731a194ab104f5f862370" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ,可以在&lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt;使用此内在函数的稳定版本。</target>
        </trans-unit>
        <trans-unit id="365e7e84eb752771b266d7d9e0c92f84d3398fe0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ,可以在&lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt;使用此内在函数的稳定版本。</target>
        </trans-unit>
        <trans-unit id="7f323b62e22f70b85a5b00e81ad1dd75f18bb93e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ,可以在&lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt;使用此内在函数的稳定版本。</target>
        </trans-unit>
        <trans-unit id="c1bdf72440b67a4b60d0cb051b353e1a1e5f17d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ,可以在&lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt;使用此内在函数的稳定版本。</target>
        </trans-unit>
        <trans-unit id="dfb231858cd4689ec5627a23d29186ff8d439dec" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba45a4ad89ca37d142fe08556abef04250897691" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f793986afe8163ac71ccb416509b9ce1b93b28a7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11f793b659028e7642830af52530c7830ca89493" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49aafe40a8bc9c4c0d4799be407063a6be2f80b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1036b996bdd682cf46fc64099bdeb270500f551" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb8002438bcf3c0d48b47c6879f85d416ab04436" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a7b18952940b9b8182e6a6746cc4d6878e30de3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2bf12a3e1dda34bbe1170fb23b2c7e3980fa2e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9e3416a187e1174aeae58104e7efc1c7ee03ff6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17459feca9539df018355d8750621e9dbfee25c8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;success&lt;/code&gt; 参数，并将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;failure&lt;/code&gt; 参数，可以通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84bb6ebc113b49007d6fcfdfafa151470c4d97fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;success&lt;/code&gt; 参数，并将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;failure&lt;/code&gt; 参数参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b287de0c6ccb4c255ae592a699ddf51d510069e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;success&lt;/code&gt; 参数和 &lt;code&gt;failure&lt;/code&gt; 参数，可以通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc152c646978658d528a198a309e91d74e54a326" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上获得，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;用作 &lt;code&gt;success&lt;/code&gt; 参数，并将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;用作 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c1db276c3b3b4fd7ceb4e380bed1da5745f7ffc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;success&lt;/code&gt; 参数和 &lt;code&gt;failure&lt;/code&gt; 参数，可以通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="951c50a3c5ccad37a2e3fca1e84b631f4373b483" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上获得，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;success&lt;/code&gt; 并将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="128d2037df6a05cf07d2834b7655c68820b3bd26" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可以通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;success&lt;/code&gt; 和 &lt;code&gt;failure&lt;/code&gt; 参数传递给&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ab03d58d5f671c0a0db830b6b05ae77f18309c3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上获得此内在函数的稳定版本，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;success&lt;/code&gt; ，将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88060a6c5fb7a5ab11e95c384921daa2c4d4f5bf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;compare_exchange&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;success&lt;/code&gt; ，将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd12eff27bb275374d877eb262054ae1c853f908" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上获得此内在函数的稳定版本，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;success&lt;/code&gt; 参数，并将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;用作 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af1fc10d6447bc6c5afd961766bf358a30dcbdba" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;success&lt;/code&gt; 参数，并将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;failure&lt;/code&gt; 参数参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00f0f125817ae56a57898beaed413be79b5a5f7f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;success&lt;/code&gt; 参数和 &lt;code&gt;failure&lt;/code&gt; 参数，可以通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a4f22637924c144abe1815857665dade4d3c51b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上获得，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;success&lt;/code&gt; ，将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="862ae83bdd80acbffd544e29d0952bfef39ef310" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;用作 &lt;code&gt;success&lt;/code&gt; 参数和 &lt;code&gt;failure&lt;/code&gt; 参数，可以通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="301da9988d8a43a17c9bdfe746d0d24a87f91ac5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;success&lt;/code&gt; 并将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e408b07db98e8ee6804e680f2894d658fb2f63fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;success&lt;/code&gt; 和 &lt;code&gt;failure&lt;/code&gt; 参数，可以通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d2ce54b599780814ddae4cc41ff6842ce0dffc8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上获得此内在函数的稳定版本，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;success&lt;/code&gt; ，将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3c44a7a6b16b40cf235a33892e670e0a8bc5178" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用，方法是将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;success&lt;/code&gt; ，将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;failure&lt;/code&gt; 参数。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eae6f5127b74d22ebf6510c20a59c81a3de0cdfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="695ca0d01b208d0e14efcb78593ea9daca909ab8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4a2657e5f8e4cdd6d19f74f32446cf634f2c708" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b27a067a3ca05d7ed184ca857f007a3ba758dcd5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f042c7aafd7bdff469934311d53691a7a1a1045" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91da36591ebb40c0553e91c9f934d905043cb8a9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e00a651851675118139e87206d58986105c4eb0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18a857da52573d4e17b52a7e7c33c2b45cbcba5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af7b5f35485a9f9923b0a484a1951a30bb3a1887" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="993970aa50aa2516408dfe30230dc45762d3f244" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_and&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="460da953958feb4d29ef7b565f8bb84fe0c27874" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe64adf45d801b3817879d281caf34973915fca3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30017d261ccaa47677175bc1d115dd370a15f192" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b88f8c0000bb8e04847190fb1bea4c60b0d2d4b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5515cfd3dce0baaa5d0933d153812410aa18e81b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_or&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94f2a12d751dc3a744709ca812719eed5be6639d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_sub&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7b08115a886002f8e0b6d94070bb4e793dcb17c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_sub&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65021746bc3a29e483b54a665e8fe3993f3b7531" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_sub&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9074d1309228123f0a179daab86adda956d06578" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_sub&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf31a4dfb044ce9c3c11fede562f450062e8cb70" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_sub&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a08ca4aeb864c545fa763c7c1bc0c6adeca1e10" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23e04028b595d303c299af1a09560b78dc738b23" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d03d95dd3b76208c05df63103f2a4773075d06c7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="527ff76b4c308bdfc8590a98e3e2f36b010f0a65" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ecf9233457e6140afc96f591e6de39578ed746f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_xor&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b72330976c1ede5cb1f5f36f1315049842fbbb63" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;load&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07780502f5ae712c09c48bfbf053afbea4b8cc74" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;load&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61ddb64e96ce0f4ae971acf4e42bb38eda10bc9a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; 传递，可以通过 &lt;code&gt;load&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd50153000fdd2e98065597c848234d48c5ae7ef" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;store&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a6dbd5587aa433e73f8c34d35d442568a18d942" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; 传递，可以通过 &lt;code&gt;store&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83f72e56df4940284d7926cf923d2abdf7ea9bb4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;store&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52da2c5cb5cf0d647cd3855825f192673441bdbd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;swap&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b30bfb1f2876b5af31915eef811a342ebcdd3b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;swap&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4382bd14df2effe7e74aa90568e6832848eea4e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;swap&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c61255cb553ed1c231e1f72bb0423d91f01ae315" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;swap&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a69be96162b6a1c17ecee094d784c23706a36adc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;swap&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;类型上使用此内部函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f289d7def13530cb2e5c5d7eaa967ea0cbc29ea7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4eb5f9b2cac38e545e679417e0916b9477cb828c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aedb9c670fb8b498f17ad50461be8607159cf171" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="044d7d27fe09f49e2ad99740d35c149e3d409936" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c22889aedce154435ee258d0c40e6448efdbc64" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_max&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a58dd280c30118ad91cca00ca18fbb4a646d3fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89f1a35ffbfc66293f3ecb009316545b57e972fd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f36baf03828badd5e395776499479459fdf74dd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7b26c022d9640d58bf0ee1df55fea1127cc8b08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b715010a7a857987bd13e4e2c7860444d5f72aff" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_min&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;无符号整数类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5f8d269b525f2aa0c49880dc3986476498a5a32" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45b7d1ba04947e0d60fd8323f25d9cb851df4d45" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0f46b18b5f9509f4b838f2cd1cc47b1cca4ac44" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; 传递，可以通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6eee377d6930faac324afa2f516a7fca7070547e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c150f5488b1c18a2f570344ce5e7e4fbf333ebdf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过将&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_nand&lt;/code&gt; 方法在&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt;类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4467e4d025c942d0e46a8d42d28e9cb70772aadf" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;count_ones&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt;&lt;code&gt;u32::count_ones&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;count_ones&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt; &lt;code&gt;u32::count_ones&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f49764c7bf099d11524ff3ae31ea8122bd687603" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;leading_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt;&lt;code&gt;u32::leading_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;leading_zeros&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt; &lt;code&gt;u32::leading_zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94453dce8a2a385d273d4c54481b7123c231b9e1" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt;&lt;code&gt;u32::overflowing_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;overflowing_add&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt; &lt;code&gt;u32::overflowing_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="975a6bc8f0eb314f9e1b240024dd857b1481fb4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt;&lt;code&gt;u32::overflowing_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;overflowing_mul&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt; &lt;code&gt;u32::overflowing_mul&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05ac2c8d4649564823e71195e6e1991816e3c134" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt;&lt;code&gt;u32::overflowing_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;overflowing_sub&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt; &lt;code&gt;u32::overflowing_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cea1555efef9a893424297cca53eccdff2cb4c12" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;reverse_bits&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt;&lt;code&gt;u32::reverse_bits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;reverse_bits&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt; &lt;code&gt;u32::reverse_bits&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02b9a60eaad995a8b508e08e5f720afcfb3cdf4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_left&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt;&lt;code&gt;u32::rotate_left&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;rotate_left&lt;/code&gt; 方法在整数基元上使用。例如，&lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt; &lt;code&gt;u32::rotate_left&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a39d8d5e922a37bc7cb7a4273c351e3237285524" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_right&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt;&lt;code&gt;u32::rotate_right&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">此内在函数的稳定版本可通过 &lt;code&gt;rotate_right&lt;/code&gt; 方法在整数基元上使用。例如，&lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt; &lt;code&gt;u32::rotate_right&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c9cb80ab093ca12a015c158de3a354687ef2774" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt;&lt;code&gt;u32::saturating_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;saturating_add&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt; &lt;code&gt;u32::saturating_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0dfb3fdba827a384aada0939a551d1f733164685" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt;&lt;code&gt;u32::saturating_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;saturating_sub&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt; &lt;code&gt;u32::saturating_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7476e3eb126b1478bcad495831ba6637eb3d2b14" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;swap_bytes&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt;&lt;code&gt;u32::swap_bytes&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;swap_bytes&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt; &lt;code&gt;u32::swap_bytes&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e398694f9fea1333665249a1e9c25a4d94f59367" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;trailing_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt;&lt;code&gt;u32::trailing_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;trailing_zeros&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt; &lt;code&gt;u32::trailing_zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c77154ad25fdd3e2bc406487defdcb53ca75726" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_add&quot;&gt;&lt;code&gt;u32::wrapping_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;wrapping_add&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.wrapping_add&quot;&gt; &lt;code&gt;u32::wrapping_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc2b20ca06dc1c8110b4d0397b1994d813ffed56" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_mul&quot;&gt;&lt;code&gt;u32::wrapping_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;wrapping_mul&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.wrapping_mul&quot;&gt; &lt;code&gt;u32::wrapping_mul&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00df89161b3ee01f6671c6eedc0e25647116beb0" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_sub&quot;&gt;&lt;code&gt;u32::wrapping_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可通过 &lt;code&gt;wrapping_sub&lt;/code&gt; 方法在整数基元上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../primitive.u32#method.wrapping_sub&quot;&gt; &lt;code&gt;u32::wrapping_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07e69ca4af06caf0678a0eb7f58dbb4160ebfce9" translate="yes" xml:space="preserve">
          <source>The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</source>
          <target state="translated">标准库API文档描述了向量、字符串和哈希图所具有的方法,这些方法将对这些练习有所帮助!</target>
        </trans-unit>
        <trans-unit id="ecfac3d3b7b498f942f6cc167a3014bcca50e8db" translate="yes" xml:space="preserve">
          <source>The standard library also provides a &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; newtype which ensures all standard arithmetic operations for &lt;code&gt;T&lt;/code&gt; have wrapping semantics.</source>
          <target state="translated">标准库还提供了一种 &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; NEWTYPE它保证了对所有标准算术运算 &lt;code&gt;T&lt;/code&gt; 有包裹语义。</target>
        </trans-unit>
        <trans-unit id="e62bb358494cb55da1b597b5302098f7179da4a8" translate="yes" xml:space="preserve">
          <source>The standard library contains additional 'smart pointer' types beyond references and raw pointers.</source>
          <target state="translated">除了引用和原始指针之外,标准库还包含额外的 &quot;智能指针 &quot;类型。</target>
        </trans-unit>
        <trans-unit id="4aeb001acf27f60d5c3f4949174f0ea7b98815a0" translate="yes" xml:space="preserve">
          <source>The standard library documentation for the &lt;code&gt;env::args&lt;/code&gt; function shows that the type of the iterator it returns is &lt;code&gt;std::env::Args&lt;/code&gt;. We&amp;rsquo;ve updated the signature of the &lt;code&gt;Config::new&lt;/code&gt; function so the parameter &lt;code&gt;args&lt;/code&gt; has the type &lt;code&gt;std::env::Args&lt;/code&gt; instead of &lt;code&gt;&amp;amp;[String]&lt;/code&gt;. Because we&amp;rsquo;re taking ownership of &lt;code&gt;args&lt;/code&gt; and we&amp;rsquo;ll be mutating &lt;code&gt;args&lt;/code&gt; by iterating over it, we can add the &lt;code&gt;mut&lt;/code&gt; keyword into the specification of the &lt;code&gt;args&lt;/code&gt; parameter to make it mutable.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; 函数的标准库文档显示，它返回的迭代器的类型为 &lt;code&gt;std::env::Args&lt;/code&gt; 。我们已经更新了 &lt;code&gt;Config::new&lt;/code&gt; 函数的签名，因此参数 &lt;code&gt;args&lt;/code&gt; 的类型为 &lt;code&gt;std::env::Args&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;[String]&lt;/code&gt; 。因为我们拥有 &lt;code&gt;args&lt;/code&gt; 的所有权，并且将通过对其进行迭代来使 &lt;code&gt;args&lt;/code&gt; 发生变异，所以我们可以将 &lt;code&gt;mut&lt;/code&gt; 关键字添加到 &lt;code&gt;args&lt;/code&gt; 参数的规范中以使其可变。</target>
        </trans-unit>
        <trans-unit id="0ac01984afb710ebee7af9fdef959461335b5771" translate="yes" xml:space="preserve">
          <source>The standard library does &lt;em&gt;not&lt;/em&gt; automatically wait on child processes (not even if the &lt;code&gt;Child&lt;/code&gt; is dropped), it is up to the application developer to do so. As a consequence, dropping &lt;code&gt;Child&lt;/code&gt; handles without waiting on them first is not recommended in long-running applications.</source>
          <target state="translated">标准库并&lt;em&gt;不能&lt;/em&gt;自动地等待子进程（甚至没有，如果 &lt;code&gt;Child&lt;/code&gt; 被丢弃），它是由应用程序开发人员这样做。因此，在长时间运行的应用程序中，建议不要先等待 &lt;code&gt;Child&lt;/code&gt; 句柄就删除它。</target>
        </trans-unit>
        <trans-unit id="c3da8861a8cd359749d019429f14004546548517" translate="yes" xml:space="preserve">
          <source>The standard library exports many modules &lt;em&gt;with the same name as primitive types&lt;/em&gt;. These define additional items related to the primitive type, but not the all-important methods.</source>
          <target state="translated">标准库导出了许多&lt;em&gt;与基本类型同名的&lt;/em&gt;模块。这些定义了与基本类型相关的其他项，但没有定义所有重要方法。</target>
        </trans-unit>
        <trans-unit id="be570bfc11d12183d4ccfc099e5e91a1312fadce" translate="yes" xml:space="preserve">
          <source>The standard library exposes three common ways to deal with contiguous regions of memory:</source>
          <target state="translated">标准库公开了三种处理内存连续区域的常见方法。</target>
        </trans-unit>
        <trans-unit id="d66210e7b423f4f4e31543419e308e2c95ac4c07" translate="yes" xml:space="preserve">
          <source>The standard library has other types that provide interior mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar except that instead of giving references to the inner value, the value is copied in and out of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;. There&amp;rsquo;s also &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, which offers interior mutability that&amp;rsquo;s safe to use across threads; we&amp;rsquo;ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</source>
          <target state="translated">标准库具有其它类型的提供内部可变性，如 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; ，这是不同之处在于代替给到内值的引用，该值和移出的复制类似 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 。还有 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ，它提供内部可变性，可以在线程之间安全使用。我们将在第16章中讨论它的用法。有关这些类型之间差异的更多信息，请查看标准库文档。</target>
        </trans-unit>
        <trans-unit id="a3eb5ea324c5e016fa7225e0db42ddd0287496a0" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">标准库在通常用作缓冲区的各种类型上实现一些I / O特性，例如 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac69e8dd1e3e493ce33a798e654cad2d62974e3" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../slice/index&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">标准库在通常用作缓冲区的各种类型上实现了一些I / O特性，例如 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../slice/index&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd43fc91f30c20105f33015f4862eaa4ba469ffd" translate="yes" xml:space="preserve">
          <source>The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate. For example the &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; and &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; targets typically come with both runtimes and the user selects which one they'd like. All targets in the compiler have a default mode of linking to the C runtime. Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</source>
          <target state="translated">通常，标准库会努力为目标适当地支持静态链接和动态链接的C运行时。例如， &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; 和 &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; 目标通常随两个运行时一起提供，用户可以选择所需的运行时。编译器中的所有目标都有链接到C运行时的默认模式。通常，目标默认情况下是动态链接的，但是默认情况下存在静态的例外，例如：</target>
        </trans-unit>
        <trans-unit id="e62009a1ff01cf79d8a5846c788aa68bf271141c" translate="yes" xml:space="preserve">
          <source>The standard library provides an implementation of &lt;code&gt;panic_handler&lt;/code&gt; that defaults to unwinding the stack but that can be &lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;changed to abort the process&lt;/a&gt;. The standard library's panic behavior can be modified at runtime with the &lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt; function.</source>
          <target state="translated">标准库提供 &lt;code&gt;panic_handler&lt;/code&gt; 的实现，该实现默认为展开堆栈，但可以&lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;更改以中止该进程&lt;/a&gt;。可以在运行时使用&lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt;函数修改标准库的紧急行为。</target>
        </trans-unit>
        <trans-unit id="a6bfe00112d50ce1df3b69fa8e0f97c99e921c7e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s &lt;code&gt;Add&lt;/code&gt; trait is an example of the second purpose: usually, you&amp;rsquo;ll add two like types, but the &lt;code&gt;Add&lt;/code&gt; trait provides the ability to customize beyond that. Using a default type parameter in the &lt;code&gt;Add&lt;/code&gt; trait definition means you don&amp;rsquo;t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn&amp;rsquo;t needed, making it easier to use the trait.</source>
          <target state="translated">标准库的 &lt;code&gt;Add&lt;/code&gt; trait是第二个目的的示例：通常，您将添加两个类似的类型，但是 &lt;code&gt;Add&lt;/code&gt; trait可以提供自定义功能。在&amp;ldquo; &lt;code&gt;Add&lt;/code&gt; 特征&amp;rdquo;定义中使用默认类型参数意味着您不必在大多数时间指定额外的参数。换句话说，不需要一些实现样板，从而更容易使用该特征。</target>
        </trans-unit>
        <trans-unit id="0eb239c2b2b429ca2fb24dfb5a68ef2028451c54" translate="yes" xml:space="preserve">
          <source>The start and end of the string (when &lt;code&gt;index == self.len()&lt;/code&gt;) are considered to be boundaries.</source>
          <target state="translated">字符串的开始和结束（当 &lt;code&gt;index == self.len()&lt;/code&gt; ）被视为边界。</target>
        </trans-unit>
        <trans-unit id="cc00d65ec1e11702c522241a5699948a50675d34" translate="yes" xml:space="preserve">
          <source>The starting index must come before the ending index;</source>
          <target state="translated">起始索引必须在结束索引之前。</target>
        </trans-unit>
        <trans-unit id="7d09dcb9f35a47d4d0374a51c368ed9570b886f1" translate="yes" xml:space="preserve">
          <source>The starting index must not exceed the ending index;</source>
          <target state="translated">起始指数不得超过结束指数。</target>
        </trans-unit>
        <trans-unit id="71f319cd135ed3830fb0df0009e873ba0d9d3bd8" translate="yes" xml:space="preserve">
          <source>The static initializer is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt; evaluated at compile time. Static initializers may refer to other statics.</source>
          <target state="translated">静态初始值设定项是在编译时评估的&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;常数表达式&lt;/a&gt;。静态初始化器可以引用其他静态变量。</target>
        </trans-unit>
        <trans-unit id="37ec0e6627e56520c118b2a4c9fe270333b4a9ac" translate="yes" xml:space="preserve">
          <source>The status (exit code) of the process.</source>
          <target state="translated">进程的状态(退出代码)。</target>
        </trans-unit>
        <trans-unit id="2deb263189905df596d3c94b6a6e46fb7fad91f4" translate="yes" xml:space="preserve">
          <source>The status code 200 is the standard success response. The text is a tiny successful HTTP response. Let&amp;rsquo;s write this to the stream as our response to a successful request! From the &lt;code&gt;handle_connection&lt;/code&gt; function, remove the &lt;code&gt;println!&lt;/code&gt; that was printing the request data and replace it with the code in Listing 20-3.</source>
          <target state="translated">状态码200是标准成功响应。文本是一个很小的成功HTTP响应。让我们将其写入流中，作为对成功请求的响应！从 &lt;code&gt;handle_connection&lt;/code&gt; 函数中，删除 &lt;code&gt;println!&lt;/code&gt; 它正在打印请求数据，并将其替换为清单20-3中的代码。</target>
        </trans-unit>
        <trans-unit id="121dc7dfe8e1f05a50f59cc42ea3919e004fbd87" translate="yes" xml:space="preserve">
          <source>The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.</source>
          <target state="translated">子进程的stdin句柄(如果有的话)将在等待之前被关闭。这有助于避免死锁:它确保子进程在等待父进程的输入时不会阻塞,而父进程则等待子进程退出。</target>
        </trans-unit>
        <trans-unit id="9e925de820aa28eb2278cfb5b172897339fec44e" translate="yes" xml:space="preserve">
          <source>The stem is:</source>
          <target state="translated">茎是。</target>
        </trans-unit>
        <trans-unit id="f0b062427634e6f3b4d22b8847d4a85e632115c3" translate="yes" xml:space="preserve">
          <source>The stream of &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; values up to a &lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt;&lt;code&gt;Done&lt;/code&gt;&lt;/a&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">直到&lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt; &lt;code&gt;Done&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt; &lt;code&gt;Match&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt; &lt;code&gt;Reject&lt;/code&gt; &lt;/a&gt;值流将包含相邻，不重叠，覆盖整个干草堆并位于utf8边界上的索引范围。</target>
        </trans-unit>
        <trans-unit id="29cd101b0d8222a260b75e7043b8f85140377fdb" translate="yes" xml:space="preserve">
          <source>The stream of &lt;code&gt;Match&lt;/code&gt; and &lt;code&gt;Reject&lt;/code&gt; values up to a &lt;code&gt;Done&lt;/code&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">直到 &lt;code&gt;Done&lt;/code&gt; &lt;code&gt;Match&lt;/code&gt; 和 &lt;code&gt;Reject&lt;/code&gt; 值流将包含相邻，不重叠，覆盖整个干草堆并位于utf8边界上的索引范围。</target>
        </trans-unit>
        <trans-unit id="fe598c8b995968505dc48317e5f0bc507dd1c32a" translate="yes" xml:space="preserve">
          <source>The stream typically has a fixed size, allowing seeking relative to either end or the current offset.</source>
          <target state="translated">流通常有一个固定的大小,允许相对于任何一端或当前偏移量寻找。</target>
        </trans-unit>
        <trans-unit id="3f8a9a233edfd6e32f4b57b8721cdb5b1b1aca0a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s3&lt;/code&gt; will contain &lt;code&gt;Hello, world!&lt;/code&gt; as a result of this code. The reason &lt;code&gt;s1&lt;/code&gt; is no longer valid after the addition and the reason we used a reference to &lt;code&gt;s2&lt;/code&gt; has to do with the signature of the method that gets called when we use the &lt;code&gt;+&lt;/code&gt; operator. The &lt;code&gt;+&lt;/code&gt; operator uses the &lt;code&gt;add&lt;/code&gt; method, whose signature looks something like this:</source>
          <target state="translated">字符串 &lt;code&gt;s3&lt;/code&gt; 将包含 &lt;code&gt;Hello, world!&lt;/code&gt; 作为此代码的结果。加完后 &lt;code&gt;s1&lt;/code&gt; 不再有效的原因，而我们引用 &lt;code&gt;s2&lt;/code&gt; 的原因与使用 &lt;code&gt;+&lt;/code&gt; 运算符时调用的方法的签名有关。在 &lt;code&gt;+&lt;/code&gt; 操作员使用 &lt;code&gt;add&lt;/code&gt; 方法，其签名看起来是这样的：</target>
        </trans-unit>
        <trans-unit id="00f2d10e6fe0131d33ac9bca9a600be0160e329e" translate="yes" xml:space="preserve">
          <source>The string Pattern API.</source>
          <target state="translated">字符串Pattern API。</target>
        </trans-unit>
        <trans-unit id="12fed2044893f571a9f644790505d48a15787f1f" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">该字符串应为可选的 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 号，后跟数字。前导和尾随空格表示错误。数字是这些字符的子集，具体取决于 &lt;code&gt;radix&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c23316acb8db6205270f951b08328de7cc2d92db" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">该字符串应为可选的 &lt;code&gt;+&lt;/code&gt; 号，后跟数字。前导和尾随空格表示错误。数字是这些字符的子集，具体取决于 &lt;code&gt;radix&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="468f8218bbd425a57c6d5b5fde91fdb78d951a69" translate="yes" xml:space="preserve">
          <source>The string on the right-hand side is only borrowed; its contents are copied into the returned &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">右侧的字符串仅可借用；它的内容被复制到返回的 &lt;code&gt;String&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="86da74512bec8006d79316da49e5b54d47ae707d" translate="yes" xml:space="preserve">
          <source>The string will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; length units of other OS strings without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the string will not allocate.</source>
          <target state="translated">该字符串将能够准确地 &lt;code&gt;capacity&lt;/code&gt; 其他OS字符串的容量长度单位，而无需重新分配。如果 &lt;code&gt;capacity&lt;/code&gt; 为0，则不会分配该字符串。</target>
        </trans-unit>
        <trans-unit id="b6f927907143ca3f662c21fec70de91f1f0df225" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;PointList&lt;/code&gt; cannot implement &lt;code&gt;Copy&lt;/code&gt;, because &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;Copy&lt;/code&gt;. If we attempt to derive a &lt;code&gt;Copy&lt;/code&gt; implementation, we'll get an error:</source>
          <target state="translated">该结构 &lt;code&gt;PointList&lt;/code&gt; 不能执行 &lt;code&gt;Copy&lt;/code&gt; ，因为&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;不 &lt;code&gt;Copy&lt;/code&gt; 。如果我们尝试派生一个 &lt;code&gt;Copy&lt;/code&gt; 实现，将会得到一个错误：</target>
        </trans-unit>
        <trans-unit id="5c8326afa9ea5c7b5b28789d2c040dda354125af" translate="yes" xml:space="preserve">
          <source>The struct is marked &lt;code&gt;pub&lt;/code&gt; so that other code can use it, but the fields within the struct remain private. This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; methods on the struct, as shown in Listing 17-2:</source>
          <target state="translated">该结构被标记为 &lt;code&gt;pub&lt;/code&gt; ,以便其他代码可以使用它，但是该结构内的字段保持私有。在这种情况下，这一点很重要，因为我们要确保无论何时在列表中添加或删除值，均值也会更新。我们通过在struct上实现 &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;remove&lt;/code&gt; 和 &lt;code&gt;average&lt;/code&gt; 方法来做到这一点，如清单17-2所示：</target>
        </trans-unit>
        <trans-unit id="9c1c27f7e80229e155110850a64cfa98b9973379" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;. This is the default, but &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">该结构只能是&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;如果所有的结构区是&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;。这是默认设置，但是&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;是一个安全特性，因此作为该结构的作者，您有责任&lt;em&gt;不&lt;/em&gt;添加诸如 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; 。（请注意，添加投影操作需要使用不安全的代码，因此&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;是安全的特性这一事实并没有违反以下原则：使用 &lt;code&gt;unsafe&lt;/code&gt; 只需担心其中的任何一项。）</target>
        </trans-unit>
        <trans-unit id="a87dba90688420e84c6cfc3a67588b540866213a" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;code&gt;Unpin&lt;/code&gt;. This is the default, but &lt;code&gt;Unpin&lt;/code&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;code&gt;Unpin&lt;/code&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">该结构只能是&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;如果所有的结构区是 &lt;code&gt;Unpin&lt;/code&gt; 。这是默认设置，但是 &lt;code&gt;Unpin&lt;/code&gt; 是一个安全特性，因此作为该结构的作者，您有责任&lt;em&gt;不&lt;/em&gt;添加诸如 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; 。 （请注意，添加投影操作需要使用不安全的代码，因此 &lt;code&gt;Unpin&lt;/code&gt; 是安全的特性这一事实并没有违反以下原则：使用 &lt;code&gt;unsafe&lt;/code&gt; 只需担心其中的任何一项。）</target>
        </trans-unit>
        <trans-unit id="a32a0dfa31f0f0289e823ec593ac2d0e0186cb3f" translate="yes" xml:space="preserve">
          <source>The structure in the &lt;code&gt;vec!&lt;/code&gt; body is similar to the structure of a &lt;code&gt;match&lt;/code&gt; expression. Here we have one arm with the pattern &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt;, followed by &lt;code&gt;=&amp;gt;&lt;/code&gt; and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.</source>
          <target state="translated">&lt;code&gt;vec!&lt;/code&gt; 的结构！主体类似于 &lt;code&gt;match&lt;/code&gt; 表达式的结构。在这里，我们有一个模式 &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt; 手臂，后跟 &lt;code&gt;=&amp;gt;&lt;/code&gt; 和与此模式相关的代码块。如果模式匹配，则将发出关联的代码块。鉴于这是该宏中唯一的模式，因此只有一种有效的匹配方法；任何其他模式都会导致错误。更复杂的宏将具有多个分支。</target>
        </trans-unit>
        <trans-unit id="feedd74875f823ef27b80e0ba6fe89baf9a484a0" translate="yes" xml:space="preserve">
          <source>The structure of your public API is a major consideration when publishing a crate. People who use your crate are less familiar with the structure than you are and might have difficulty finding the pieces they want to use if your crate has a large module hierarchy.</source>
          <target state="translated">当发布一个 crate 时,你的公共 API 的结构是一个主要的考虑因素。如果你的箱子有一个大的模块层次结构,那么使用你的箱子的人就不如你熟悉结构,可能会很难找到他们想要使用的部分。</target>
        </trans-unit>
        <trans-unit id="8bdec152aa7987052184ceacfeaf61672bfbc336" translate="yes" xml:space="preserve">
          <source>The subtraction assignment operator &lt;code&gt;-=&lt;/code&gt;.</source>
          <target state="translated">减法赋值运算符 &lt;code&gt;-=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9df0e8a4e443e9ee7a165601e70a6b8ea73f8885" translate="yes" xml:space="preserve">
          <source>The subtraction operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">减法运算符 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28fd4d4d9eae938e322b4e3df0e6f419cbd1966d" translate="yes" xml:space="preserve">
          <source>The summary line displays at the end: overall, our test result is &lt;code&gt;FAILED&lt;/code&gt;. We had one test pass and one test fail.</source>
          <target state="translated">摘要行显示在末尾：总体而言，我们的测试结果为 &lt;code&gt;FAILED&lt;/code&gt; 。我们进行了一次测试通过，一次测试失败。</target>
        </trans-unit>
        <trans-unit id="ee42b5387704f2d9fe3e70d6349076680fb579e8" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">提供的密钥可以是地图的密钥类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与密钥类型的匹配。</target>
        </trans-unit>
        <trans-unit id="4d0db9da1f6030ddf936168ba198ea7e2ea2a8e7" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">提供的密钥可以是地图的密钥类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与密钥类型的匹配。</target>
        </trans-unit>
        <trans-unit id="6157ddf403c8a4c61dced75b578898d85ccde0c2" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">提供的密钥可以是地图的密钥类型的任何借用形式，但是借用形式上的顺序&lt;em&gt;必须&lt;/em&gt;与密钥类型上的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="9a3120ffbc7b98288aabd741823275a65245701a" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;^C&lt;/code&gt; represents where you pressed ctrl-c . You may or may not see the word &lt;code&gt;again!&lt;/code&gt; printed after the &lt;code&gt;^C&lt;/code&gt;, depending on where the code was in the loop when it received the interrupt signal.</source>
          <target state="translated">&lt;code&gt;^C&lt;/code&gt; 符号表示您按ctrl-c的位置。您可能会或可能不会 &lt;code&gt;again!&lt;/code&gt; 看到这个词！在 &lt;code&gt;^C&lt;/code&gt; 之后打印，具体取决于代码在接收到中断信号时在循环中的位置。</target>
        </trans-unit>
        <trans-unit id="266a6ae6e0b1b671aa6c8cd7616208233ffe3a4b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;..&lt;/code&gt; will expand to as many values as it needs to be. Listing 18-24 shows how to use &lt;code&gt;..&lt;/code&gt; with a tuple.</source>
          <target state="translated">语法 &lt;code&gt;..&lt;/code&gt; 将扩展为所需的任意多个值。清单18-24显示了如何在元组中使用 &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79fc3d3c405b115d38b7334d712d4081f0801fc2" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;if let&lt;/code&gt; takes a pattern and an expression separated by an equal sign. It works the same way as a &lt;code&gt;match&lt;/code&gt;, where the expression is given to the &lt;code&gt;match&lt;/code&gt; and the pattern is its first arm.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 的语法采用由等号分隔的模式和表达式。它与 &lt;code&gt;match&lt;/code&gt; 的工作方式相同，其中将表达式提供给 &lt;code&gt;match&lt;/code&gt; ，而模式是其第一个分支。</target>
        </trans-unit>
        <trans-unit id="751b24fbac99aa6572c9e1b012dbbe4901f9dd78" translate="yes" xml:space="preserve">
          <source>The syntax and semantics for generators is unstable and will require a further RFC for stabilization. At this time, though, the syntax is closure-like:</source>
          <target state="translated">生成器的语法和语义是不稳定的,需要进一步的RFC来稳定。不过,目前的语法是类似于封闭的。</target>
        </trans-unit>
        <trans-unit id="f94369f4bb8ebdf54603588e1760be815601c761" translate="yes" xml:space="preserve">
          <source>The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by &lt;code&gt;{}&lt;/code&gt; instead of the C-like &lt;code&gt;%&lt;/code&gt;. The actual grammar for the formatting syntax is:</source>
          <target state="translated">所使用的格式语言的语法是从其他语言中提取的，因此不要太陌生。参数使用类似Python的语法格式化，这意味着参数用 &lt;code&gt;{}&lt;/code&gt; 而不是C相似的 &lt;code&gt;%&lt;/code&gt; 包围。格式化语法的实际语法为：</target>
        </trans-unit>
        <trans-unit id="b1fb2c0dcb9e4f22d10669f04073e3418ad44567" translate="yes" xml:space="preserve">
          <source>The syntax for using generics in struct definitions is similar to that used in function definitions. First, we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we can use the generic type in the struct definition where we would otherwise specify concrete data types.</source>
          <target state="translated">在结构体定义中使用泛型的语法与函数定义中使用的语法类似。首先,我们在结构名称之后的角括号内声明类型参数的名称。然后,我们可以在结构定义中使用通用类型,否则我们将指定具体的数据类型。</target>
        </trans-unit>
        <trans-unit id="be667267584bb9b3dbb1d7d6c41e7cff90529baf" translate="yes" xml:space="preserve">
          <source>The syntax given to this macro is the same syntax as the &lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">赋予该宏的语法与&lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;属性的语法相同。</target>
        </trans-unit>
        <trans-unit id="37efe90a09f5adb20955a8d29f6006705ceea1f4" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;code&gt;type Name = ExistingType;&lt;/code&gt;.</source>
          <target state="translated">语法 &lt;code&gt;type Name = ExistingType;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a952c08ff986f0fd0f90d2e270d99cd3e69c17a4" translate="yes" xml:space="preserve">
          <source>The syntax is the following: &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt;. Only one &lt;code&gt;BaseTrait&lt;/code&gt; can be used so this will not compile:</source>
          <target state="translated">语法如下： &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt; 。只能使用一个 &lt;code&gt;BaseTrait&lt;/code&gt; ,因此无法编译：</target>
        </trans-unit>
        <trans-unit id="4a5b87227107115d71da53fde65c7898c2f8a55f" translate="yes" xml:space="preserve">
          <source>The tail (elements in the vector after &lt;code&gt;range&lt;/code&gt;) is empty,</source>
          <target state="translated">尾部（ &lt;code&gt;range&lt;/code&gt; 后面的向量中的元素）为空，</target>
        </trans-unit>
        <trans-unit id="018e9509238447c67e6197a11d4f5ea0ec53b22e" translate="yes" xml:space="preserve">
          <source>The tail expression of &lt;a href=&quot;expressions/block-expr&quot;&gt;block expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;块表达式&lt;/a&gt;的尾部表达式。</target>
        </trans-unit>
        <trans-unit id="73007ab480751859048a54c88693df26b24125bb" translate="yes" xml:space="preserve">
          <source>The task context refers to the &lt;a href=&quot;../../std/task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; which was supplied to the current &lt;a href=&quot;block-expr#async-context&quot;&gt;async context&lt;/a&gt; when the async context itself was polled. Because &lt;code&gt;await&lt;/code&gt; expressions are only legal in an async context, there must be some task context available.</source>
          <target state="translated">任务上下文是指&lt;a href=&quot;../../std/task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;这是提供给当前的&lt;a href=&quot;block-expr#async-context&quot;&gt;异步背景下&lt;/a&gt;，在异步上下文本身轮询。因为 &lt;code&gt;await&lt;/code&gt; 表达式仅在异步上下文中是合法的，所以必须有一些可用的任务上下文。</target>
        </trans-unit>
        <trans-unit id="8066bd3121283d3517acd4ab40b658c1a009321c" translate="yes" xml:space="preserve">
          <source>The temporary scopes for expressions in &lt;code&gt;let&lt;/code&gt; statements are sometimes &lt;em&gt;extended&lt;/em&gt; to the scope of the block containing the &lt;code&gt;let&lt;/code&gt; statement. This is done when the usual temporary scope would be too small, based on certain syntactic rules. For example:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 语句中表达式的临时范围有时会&lt;em&gt;扩展&lt;/em&gt;到包含 &lt;code&gt;let&lt;/code&gt; 语句的块的范围。当基于某些句法规则，通常的临时范围太小时，就会执行此操作。例如：</target>
        </trans-unit>
        <trans-unit id="c615f1f00b080ca7312a1e8d344f8e1a91bfada3" translate="yes" xml:space="preserve">
          <source>The test shows that when we call &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we get back only shoes that have the same size as the value we specified.</source>
          <target state="translated">该测试表明，当我们调用 &lt;code&gt;shoes_in_my_size&lt;/code&gt; 时，我们仅取回与我们指定的值具有相同大小的鞋子。</target>
        </trans-unit>
        <trans-unit id="6d51660220a74ee89098ef8ef16d38d84170be2b" translate="yes" xml:space="preserve">
          <source>The text &lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; is printed between the &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; and &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; text, showing that the &lt;code&gt;drop&lt;/code&gt; method code is called to drop &lt;code&gt;c&lt;/code&gt; at that point.</source>
          <target state="translated">&lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; 的文本Droping CustomSmartPointer！在 &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; 的CustomSmartPointer之间打印。并且 &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; 文本，表明在该点调用了 &lt;code&gt;drop&lt;/code&gt; 方法代码以放置 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9d885657469b7761a884865d71e05fd15d67a2e" translate="yes" xml:space="preserve">
          <source>The text of this string is stored directly in the program&amp;rsquo;s binary, which is always available. Therefore, the lifetime of all string literals is &lt;code&gt;'static&lt;/code&gt;.</source>
          <target state="translated">该字符串的文本直接存储在程序的二进制文件中，该二进制文件始终可用。因此，所有字符串文字的生存期都是 &lt;code&gt;'static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2418c922b0dbbb7a6749b73d736e8d2a5be9d0c" translate="yes" xml:space="preserve">
          <source>The third argument is a function called if a panic occurs. This function takes the data pointer and a pointer to the target-specific exception object that was caught. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">第三个参数是一个在发生恐慌时调用的函数。这个函数接收数据指针和指向被捕获的目标特定异常对象的指针。更多信息请参见编译器的源代码以及std的catch实现。</target>
        </trans-unit>
        <trans-unit id="bb9a02cbbbeece965fc06bf102b3dfcc209b80a8" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">第三种情况比较棘手：Rust还将强制对不可变引用进行可变的引用。但反过来是&lt;em&gt;不是&lt;/em&gt;可能：一成不变的引用绝不会强迫到可变引用。由于有借用规则，如果您有可变引用，则该可变引用必须是对该数据的唯一引用（否则，程序将不会编译）。将一个可变引用转换为一个不可变引用将永远不会违反借用规则。将不可变引用转换为可变引用将要求初始不可变引用是对该数据的唯一不可变引用，但是借用规则不能保证这一点。因此，Rust无法做出将不可变引用转换为可变引用的假设。</target>
        </trans-unit>
        <trans-unit id="f9782d2dad9c654fee52ed918f0366cbe2abfa6a" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">第三种情况比较棘手：Rust还将强制对不可变引用进行可变的引用。但反过来是&lt;em&gt;不是&lt;/em&gt;可能：一成不变的引用绝不会强迫到可变引用。由于有借用规则，如果您有可变引用，则该可变引用必须是对该数据的唯一引用（否则，程序将无法编译）。将一个可变引用转换为一个不可变引用将永远不会违反借用规则。将不可变引用转换为可变引用将需要对该数据只有一个不可变引用，而借用规则并不保证这一点。因此，Rust无法做出将不可变引用转换为可变引用的假设。</target>
        </trans-unit>
        <trans-unit id="25bc1d6b7d2fd810584a49b63e54dae85fbc7654" translate="yes" xml:space="preserve">
          <source>The third invariant says that when we have a complex NT that can match two or more copies of the same thing with no separation in between, it must be permissible for them to be placed next to each other as per the first invariant. This invariant also requires they be nonempty, which eliminates a possible ambiguity.</source>
          <target state="translated">第三个不变性说的是,当我们有一个复杂的NT,可以匹配同一事物的两个或两个以上的副本,中间没有任何分离,按照第一个不变性,必须允许它们彼此相邻。这个不变式还要求它们是非空的,这就消除了一个可能的歧义。</target>
        </trans-unit>
        <trans-unit id="6858985d6a527c37bd8cd37f82674daea04d146f" translate="yes" xml:space="preserve">
          <source>The third pointer is a target-specific data pointer which is filled in with the specifics of the exception that occurred. For examples on Unix platforms this is a &lt;code&gt;*mut *mut T&lt;/code&gt; which is filled in by the compiler and on MSVC it's &lt;code&gt;*mut [usize; 2]&lt;/code&gt;. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">第三个指针是特定于目标的数据指针，其中填充了发生的异常的详细信息。例如，在Unix平台上，这是 &lt;code&gt;*mut *mut T&lt;/code&gt; ，由编译器填充；在MSVC上，它是 &lt;code&gt;*mut [usize; 2]&lt;/code&gt; 。有关更多信息，请参见编译器的源代码以及std的catch实现。</target>
        </trans-unit>
        <trans-unit id="af84a0e541b5cb8aad0df743eb686112ab5e9865" translate="yes" xml:space="preserve">
          <source>The third problem is that we&amp;rsquo;ve used &lt;code&gt;expect&lt;/code&gt; to print an error message when reading the file fails, but the error message just prints &lt;code&gt;Something went wrong reading the file&lt;/code&gt;. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we&amp;rsquo;d print the &lt;code&gt;Something went wrong reading the file&lt;/code&gt; error message, which wouldn&amp;rsquo;t give the user any information!</source>
          <target state="translated">第三个问题是，我们曾经 &lt;code&gt;expect&lt;/code&gt; 在读取文件失败时打印一条错误消息，但是该错误消息只是打印 &lt;code&gt;Something went wrong reading the file&lt;/code&gt; 。读取文件可能会以多种方式失败：例如，文件可能丢失，或者我们可能没有打开文件的权限。现在，无论情况如何，我们都会在 &lt;code&gt;Something went wrong reading the file&lt;/code&gt; 错误消息时打印出问题，这不会为用户提供任何信息！</target>
        </trans-unit>
        <trans-unit id="f9f5c0bd316756e98b375cf7ab85326d6fd86b72" translate="yes" xml:space="preserve">
          <source>The third rule is if there are multiple input lifetime parameters, but one of them is &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; because this is a method, the lifetime of &lt;code&gt;self&lt;/code&gt; is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</source>
          <target state="translated">第三个规则是，如果有多个输入生存期参数，但是其中一个是 &lt;code&gt;&amp;amp;self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ,因为这是一种方法，因此将 &lt;code&gt;self&lt;/code&gt; 的生存期分配给所有输出生存期参数。第三条规则使方法更易于读写，因为需要的符号更少。</target>
        </trans-unit>
        <trans-unit id="c69636ef08912707db1c3ff91b55a817a8ac72a9" translate="yes" xml:space="preserve">
          <source>The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality. It will never sleep less.</source>
          <target state="translated">由于调度的特殊性或平台依赖性功能,线程的睡眠时间可能会比指定的时间长。它永远不会减少睡眠时间。</target>
        </trans-unit>
        <trans-unit id="cd58c0bda6dec6815740b7eed1b811cfbd96ccbb" translate="yes" xml:space="preserve">
          <source>The thread name is provided to the OS where applicable (e.g., &lt;code&gt;pthread_setname_np&lt;/code&gt; in unix-like platforms).</source>
          <target state="translated">线程名称在适用的情况下提供给OS（例如，在类Unix平台中的 &lt;code&gt;pthread_setname_np&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3218fca211a825167101461324b25d4344214224" translate="yes" xml:space="preserve">
          <source>The threading model</source>
          <target state="translated">线程模型</target>
        </trans-unit>
        <trans-unit id="2518c4f037fbaea8573cb319d8682ea0e18ad153" translate="yes" xml:space="preserve">
          <source>The three forms of iteration</source>
          <target state="translated">迭代的三种形式</target>
        </trans-unit>
        <trans-unit id="6e441e5631d84f73392a981b4df2ae8555997336" translate="yes" xml:space="preserve">
          <source>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</source>
          <target state="translated">三种程序宏(自定义派生、属性类、函数类)的工作方式都很相似。</target>
        </trans-unit>
        <trans-unit id="d7a7ac48a6db407723719df4ec95a88c69119a40" translate="yes" xml:space="preserve">
          <source>The three sections of output include the unit tests, the integration test, and the doc tests. The first section for the unit tests is the same as we&amp;rsquo;ve been seeing: one line for each unit test (one named &lt;code&gt;internal&lt;/code&gt; that we added in Listing 11-12) and then a summary line for the unit tests.</source>
          <target state="translated">输出的三个部分包括单元测试，集成测试和doc测试。单元测试的第一部分与我们所见的相同：每个单元测试一行（在清单11-12中添加了一个名为 &lt;code&gt;internal&lt;/code&gt; 的行），然后是单元测试的摘要行。</target>
        </trans-unit>
        <trans-unit id="779ae776bee7c2504118b220c1641bc64af7f7ac" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">如果元素主要以升序推入，则时间复杂度会降低。在最坏的情况下，元素按升序排序推入，而每次推入的摊销成本对于包含&lt;em&gt;n个&lt;/em&gt;元素的堆为&lt;em&gt;O&lt;/em&gt;（log（&lt;em&gt;n&lt;/em&gt;））。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6df380516e9cdddf51f2d5d2da6e443a2e517824" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is O(log n) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">如果元素主要以升序推入，则时间复杂度会降低。在最坏的情况下，元素按升序排序推入，相对于包含&lt;em&gt;n个&lt;/em&gt;元素的堆，每次推入的摊销成本为O（log n）。</target>
        </trans-unit>
        <trans-unit id="95e46fd08ac08fd408281a4c8d24f1d26e9263c5" translate="yes" xml:space="preserve">
          <source>The to-be-stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.variant_count&quot;&gt;&lt;code&gt;mem::variant_count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此内在函数的待稳定版本是&lt;a href=&quot;../mem/fn.variant_count&quot;&gt; &lt;code&gt;mem::variant_count&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7075cd0ebc9560a0210fd04b57fb94c1b2316eda" translate="yes" xml:space="preserve">
          <source>The tokens that can begin a type are, as of this writing, {&lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;\*&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, lifetimes, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt;, any non-keyword identifier, &lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;$crate&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;impl&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;unsafe&lt;/code&gt;, &lt;code&gt;typeof&lt;/code&gt;, &lt;code&gt;dyn&lt;/code&gt;}, although this list may not be complete because people won't always remember to update the appendix when new ones are added.</source>
          <target state="translated">在撰写本文时，可以开始类型的标记是{ &lt;code&gt;(&lt;/code&gt; ， &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;!&lt;/code&gt; ， &lt;code&gt;\*&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、、 &lt;code&gt;?&lt;/code&gt; ，lifetimes， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;::&lt;/code&gt; ，任何非关键字标识符， &lt;code&gt;super&lt;/code&gt; ， &lt;code&gt;self&lt;/code&gt; ， &lt;code&gt;Self&lt;/code&gt; ， &lt;code&gt;extern&lt;/code&gt; ， &lt;code&gt;crate&lt;/code&gt; ， &lt;code&gt;$crate&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;impl&lt;/code&gt; ， &lt;code&gt;fn&lt;/code&gt; ， &lt;code&gt;unsafe&lt;/code&gt; ， &lt;code&gt;typeof&lt;/code&gt; ， &lt;code&gt;dyn&lt;/code&gt; }，尽管此列表可能并不完整，因为添加新的附录时人们不会总是记得更新附录。</target>
        </trans-unit>
        <trans-unit id="3d918eb4366eadb0401bfe8b5fc6b1b9ce9e5b76" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate, we&amp;rsquo;ll get an error:</source>
          <target state="translated">现在，顶级&lt;em&gt;Cargo.lock&lt;/em&gt;包含有关 &lt;code&gt;add-one&lt;/code&gt; 对 &lt;code&gt;rand&lt;/code&gt; 的依赖性的信息。但是，即使在工作空间中的某处使用 &lt;code&gt;rand&lt;/code&gt; ，也不能在工作空间的其他板条箱中使用它，除非我们也将 &lt;code&gt;rand&lt;/code&gt; 添加到其&lt;em&gt;Cargo.toml&lt;/em&gt;文件中。例如，如果我们添加 &lt;code&gt;use rand;&lt;/code&gt; 到&lt;em&gt;加法&lt;/em&gt; &lt;code&gt;adder&lt;/code&gt; 包装箱的&lt;em&gt;adder / src / main.rs&lt;/em&gt;文件中，我们将收到错误消息：</target>
        </trans-unit>
        <trans-unit id="c0d4e33f5ea540060f03c5345b86c179052a0077" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package, we&amp;rsquo;ll get an error:</source>
          <target state="translated">现在，顶级&lt;em&gt;Cargo.lock&lt;/em&gt;包含有关 &lt;code&gt;add-one&lt;/code&gt; 对 &lt;code&gt;rand&lt;/code&gt; 的依赖关系的信息。但是，即使将 &lt;code&gt;rand&lt;/code&gt; 用于工作区中的某个地方，我们也不能在工作区中的其他板条箱中使用它，除非我们也将 &lt;code&gt;rand&lt;/code&gt; 添加到其&lt;em&gt;Cargo.toml&lt;/em&gt;文件中。例如，如果我们添加 &lt;code&gt;use rand;&lt;/code&gt; 到 &lt;code&gt;adder&lt;/code&gt; 包的&lt;em&gt;adder / src / main.rs&lt;/em&gt;文件中，我们将收到错误消息：</target>
        </trans-unit>
        <trans-unit id="ad3286fb14b7fd80e70223a9fcdf3dbb91a27203" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">切片的总大小 &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 必须不大于 &lt;code&gt;isize::MAX&lt;/code&gt; 。请参阅&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;的安全文档。</target>
        </trans-unit>
        <trans-unit id="cb4d3d21f95395d566b73337877fe60f19b91950" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 的总大小ptr.len（）* mem :: size_of :: &amp;lt;T&amp;gt;（）必须不大于 &lt;code&gt;isize::MAX&lt;/code&gt; 。请参阅&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;的安全文档。</target>
        </trans-unit>
        <trans-unit id="f198377d0780cd2ae0fe23c39d58fa6a11c3ce1b" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 的总大小ptr.len（）* mem :: size_of :: &amp;lt;T&amp;gt;（）必须不大于 &lt;code&gt;isize::MAX&lt;/code&gt; 。请参阅&lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;的安全文档。</target>
        </trans-unit>
        <trans-unit id="8c818e1dc9d477cbb1ce03a32e397d907f841e91" translate="yes" xml:space="preserve">
          <source>The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">切片的总大小不得大于内存中的 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;字节&lt;/strong&gt;。请参阅&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;的安全文档。</target>
        </trans-unit>
        <trans-unit id="4da1db74e1e609ac8cd961cdfb0fa46bfc3d2c9d" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">该特征还提供了便捷的方法，例如&lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;，它会在循环中调用 &lt;code&gt;write&lt;/code&gt; ，直到其整个输入都被写入为止。</target>
        </trans-unit>
        <trans-unit id="903fc77fd3444aa853b4918c8904a108213ce8a6" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">该特征还提供了便捷的方法，例如&lt;a href=&quot;trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;，它在循环中调用 &lt;code&gt;write&lt;/code&gt; ，直到其整个输入都被写入为止。</target>
        </trans-unit>
        <trans-unit id="ddef280ba8303b75d43b99adadcdec8f8b461c8f" translate="yes" xml:space="preserve">
          <source>The trait being implemented is defined in the same crate.</source>
          <target state="translated">正在实施的性状是在同一个箱子里定义的。</target>
        </trans-unit>
        <trans-unit id="fe160012593c71ba4d94a64501b55cb584b3c84d" translate="yes" xml:space="preserve">
          <source>The trait cannot contain associated constants</source>
          <target state="translated">性状不能包含相关常量</target>
        </trans-unit>
        <trans-unit id="f49c4617e26c7a90e7ceb5715737675232c71e5c" translate="yes" xml:space="preserve">
          <source>The trait cannot require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">特质不能要求 &lt;code&gt;Self: Sized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bbcc07233474a5558580dca4726567afce0f2c1" translate="yes" xml:space="preserve">
          <source>The trait cannot use &lt;code&gt;Self&lt;/code&gt; as a type parameter in the supertrait listing</source>
          <target state="translated">特质不能在上级特征列表中使用 &lt;code&gt;Self&lt;/code&gt; 作为类型参数</target>
        </trans-unit>
        <trans-unit id="6c46ccc8f602f9dc98f8190aa7e9cb78c7a8a015" translate="yes" xml:space="preserve">
          <source>The trait implemented by builtin generator types.</source>
          <target state="translated">由内置生成器类型实现的特性。</target>
        </trans-unit>
        <trans-unit id="0c6838569af8d3e59a65e8aec127e2d3a1e1e919" translate="yes" xml:space="preserve">
          <source>The trait is known as the &lt;em&gt;implemented trait&lt;/em&gt;. The implementing type implements the implemented trait.</source>
          <target state="translated">该特性被称为已&lt;em&gt;实现特性&lt;/em&gt;。实现类型实现已实现的特征。</target>
        </trans-unit>
        <trans-unit id="8cf3ab6548fb883dab5c1d88de8c77fdb3ccf054" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">该特征被标记为不安全，因为需要&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;方法返回的索引位于干草堆中的有效utf8边界上。这使具有此特征的使用者无需进行额外的运行时检查即可切入干草堆。</target>
        </trans-unit>
        <trans-unit id="478884f7bada94b695fbee645bd59c060678235f" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;code&gt;next()&lt;/code&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">该特征被标记为不安全，因为需要 &lt;code&gt;next()&lt;/code&gt; 方法返回的索引位于干草堆中的有效utf8边界上。这使具有此特征的使用者无需进行额外的运行时检查即可切入干草堆。</target>
        </trans-unit>
        <trans-unit id="6d63a097c314f3198ade51464ed8a948cd1d46d3" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe in order to restrict implementors to fixed-size arrays. User of this trait can assume that implementors have the exact layout in memory of a fixed size array (for example, for unsafe initialization).</source>
          <target state="translated">这个特性被标记为不安全,以限制实现者使用固定大小的数组。这个特性的用户可以假设实现者在内存中拥有固定大小数组的精确布局(例如,为了不安全的初始化)。</target>
        </trans-unit>
        <trans-unit id="6234c814e87094f91726f24487a4768fa303bb49" translate="yes" xml:space="preserve">
          <source>The trait is unsafe because implementers must uphold additional safety properties. See &lt;a href=&quot;trait.sourceiter#tymethod.as_inner&quot;&gt;&lt;code&gt;as_inner&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">该特性是不安全的，因为实施者必须维护其他安全属性。有关详细信息，请参见&lt;a href=&quot;trait.sourceiter#tymethod.as_inner&quot;&gt; &lt;code&gt;as_inner&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffd4884c0b4bf389a086599eb28e009d3c721bad" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">特征本身可以充当关联的&lt;a href=&quot;trait.searcher&quot;&gt; &lt;code&gt;Searcher&lt;/code&gt; &lt;/a&gt;类型的构建器，该搜索器类型实际工作是查找字符串中模式的出现。</target>
        </trans-unit>
        <trans-unit id="bf58bfdb142c3e3e2fca00b9412242993f764d14" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;code&gt;Searcher&lt;/code&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">特征本身可以充当关联的 &lt;code&gt;Searcher&lt;/code&gt; 类型的构建器，后者可以实际查找字符串中模式的出现。</target>
        </trans-unit>
        <trans-unit id="4f44d782a6ca223ce6d84156fccfcf74f2f98110" translate="yes" xml:space="preserve">
          <source>The trait with a supertrait is called a &lt;strong&gt;subtrait&lt;/strong&gt; of its supertrait.</source>
          <target state="translated">具有超特征的特征称为其&lt;strong&gt;超&lt;/strong&gt;特征的子特征。</target>
        </trans-unit>
        <trans-unit id="d7357f4482763332c4dcdb5f743346a154d2e9c6" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt; and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">在性状&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt;用于超负荷&lt;a href=&quot;expressions/operator-expr&quot;&gt;运营&lt;/a&gt;，&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;索引表达式&lt;/a&gt;和&lt;a href=&quot;expressions/call-expr&quot;&gt;调用表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ada4715a52a3666c1e6ea1e317fd6cc2974a5b0" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt;, and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">在性状&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt;用于超负荷&lt;a href=&quot;expressions/operator-expr&quot;&gt;运营&lt;/a&gt;，&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;索引表达式中&lt;/a&gt;，以及&lt;a href=&quot;expressions/call-expr&quot;&gt;通话的表达&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f43292c5d9ba5055790b8cc673c3ce1d90efd4b3" translate="yes" xml:space="preserve">
          <source>The traits in this module are often used as trait bounds for generic functions such that to arguments of multiple types are supported. See the documentation of each trait for examples.</source>
          <target state="translated">本模块中的特质通常被用作通用函数的特质边界,这样就可以支持多个类型的参数。请参阅每个特质的文档中的例子。</target>
        </trans-unit>
        <trans-unit id="bbf2160d65d5756f9a6fd20c174d5b77d26006ee" translate="yes" xml:space="preserve">
          <source>The traits in this module provide a way to convert from one type to another type. Each trait serves a different purpose:</source>
          <target state="translated">本模块中的特质提供了一种从一种类型转换到另一种类型的方法。每个特征都有不同的用途。</target>
        </trans-unit>
        <trans-unit id="be87d5e421f146f48239b20f0b61521f853fc415" translate="yes" xml:space="preserve">
          <source>The transmitting end has a &lt;code&gt;send&lt;/code&gt; method that takes the value we want to send. The &lt;code&gt;send&lt;/code&gt; method returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, so if the receiving end has already been dropped and there&amp;rsquo;s nowhere to send a value, the send operation will return an error. In this example, we&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.</source>
          <target state="translated">发送端有一个 &lt;code&gt;send&lt;/code&gt; 方法，它采用我们要发送的值。所述 &lt;code&gt;send&lt;/code&gt; 方法返回一个 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 类型，因此，如果该接收端已经下降，有无处送的值，则发送操作将返回错误。在此示例中，我们将在发生错误时调用 &lt;code&gt;unwrap&lt;/code&gt; 进行恐慌。但是在实际的应用程序中，我们会正确地处理它：返回第9章，回顾正确处理错误的策略。</target>
        </trans-unit>
        <trans-unit id="358565a5dd8811594d3e7971e93dfbda2791693b" translate="yes" xml:space="preserve">
          <source>The tuple pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">当元组模式的一个子模式是可反驳的。</target>
        </trans-unit>
        <trans-unit id="8b3273a21950fc06ce8b8962828961e34d0be457" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过在其内部值上调用 &lt;code&gt;&amp;gt;&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="de2c6ddac182efa31cffea571db9b44146fe9838" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过调用其内部值 &lt;code&gt;&amp;gt;=&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="9c699eaaa968f03f7073bd19cfb4a4bc4c553e9a" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过在其内部值上调用 &lt;code&gt;&amp;lt;&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="169dd7de97da6fed33fb4c7fffa1d0926634fd12" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过对它们的内部值调用 &lt;code&gt;&amp;lt;=&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="4559f811138e10e2014d510114ff2517b250941f" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过在其内部值上调用 &lt;code&gt;cmp()&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="39163b76dc0823f8bfd4c0f4a8969c804a3f8075" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;partial_cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">通过调用其内部值的 &lt;code&gt;partial_cmp()&lt;/code&gt; 来比较两者。</target>
        </trans-unit>
        <trans-unit id="a9f918beee4f5cf9d1253c5c05628d38cf96954a" translate="yes" xml:space="preserve">
          <source>The two configurations available are:</source>
          <target state="translated">现有的两种配置是:</target>
        </trans-unit>
        <trans-unit id="450583e125671dcb6a167d6b29518dd2bf3867fb" translate="yes" xml:space="preserve">
          <source>The two kinds of declaration statements are item declarations and &lt;code&gt;let&lt;/code&gt; statements.</source>
          <target state="translated">两种声明语句是项声明和 &lt;code&gt;let&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="29e11129b6c15c504dcd359f5946098de2a818e8" translate="yes" xml:space="preserve">
          <source>The two main protocols involved in web servers are the &lt;em&gt;Hypertext Transfer Protocol&lt;/em&gt;&lt;em&gt;(HTTP)&lt;/em&gt; and the &lt;em&gt;Transmission Control Protocol&lt;/em&gt;&lt;em&gt;(TCP)&lt;/em&gt;. Both protocols are &lt;em&gt;request-response&lt;/em&gt; protocols, meaning a &lt;em&gt;client&lt;/em&gt; initiates requests and a &lt;em&gt;server&lt;/em&gt; listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.</source>
          <target state="translated">Web服务器中涉及的两个主要协议是&lt;em&gt;超文本传输​​协议&lt;/em&gt;&lt;em&gt;（HTTP）&lt;/em&gt;和&lt;em&gt;传输控制协议&lt;/em&gt;&lt;em&gt;（TCP）&lt;/em&gt;。两种协议都是&lt;em&gt;请求-响应&lt;/em&gt;协议，这意味着&lt;em&gt;客户端&lt;/em&gt;发起请求，&lt;em&gt;服务器&lt;/em&gt;监听请求并向客户端提供响应。这些请求和响应的内容由协议定义。</target>
        </trans-unit>
        <trans-unit id="203df10027d062d490c4fbf35780fe4d1eed13fd" translate="yes" xml:space="preserve">
          <source>The two most common ways to evaluate an iterator are to use a &lt;code&gt;for&lt;/code&gt; loop like this, or using the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">评估迭代器的两种最常见方法是使用这样的 &lt;code&gt;for&lt;/code&gt; 循环，或使用&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;方法产生新的集合。</target>
        </trans-unit>
        <trans-unit id="f0616989ceb9af09d65c6d30395a15645c3fb4ed" translate="yes" xml:space="preserve">
          <source>The two new lines are:</source>
          <target state="translated">这两条新线是:</target>
        </trans-unit>
        <trans-unit id="e483fee205c9c53971b14b5a333e04a44a6db99b" translate="yes" xml:space="preserve">
          <source>The two pointed-to values may overlap. If the values do overlap, then the overlapping region of memory from &lt;code&gt;x&lt;/code&gt; will be used. This is demonstrated in the second example below.</source>
          <target state="translated">两个指向的值可能会重叠。如果值确实重叠，则将使用 &lt;code&gt;x&lt;/code&gt; 的内存重叠区域。下面的第二个示例对此进行了说明。</target>
        </trans-unit>
        <trans-unit id="7540e3538a7ee2b354c6ad5eceba51e063d25c18" translate="yes" xml:space="preserve">
          <source>The two slices returned go from the start of the string slice to &lt;code&gt;mid&lt;/code&gt;, and from &lt;code&gt;mid&lt;/code&gt; to the end of the string slice.</source>
          <target state="translated">返回的两个切片从字符串切片的开始到 &lt;code&gt;mid&lt;/code&gt; ，从字符串切片的 &lt;code&gt;mid&lt;/code&gt; 到结尾。</target>
        </trans-unit>
        <trans-unit id="643186e43b6d06589052d125f62e5365b9c9a558" translate="yes" xml:space="preserve">
          <source>The two threads continue alternating, but the main thread waits because of the call to &lt;code&gt;handle.join()&lt;/code&gt; and does not end until the spawned thread is finished.</source>
          <target state="translated">这两个线程继续交替，但是主线程由于对 &lt;code&gt;handle.join()&lt;/code&gt; 的调用而等待，直到生成的线程完成后才结束。</target>
        </trans-unit>
        <trans-unit id="6005b5c0e8b9fae85cf0f2f496cddef96188c2e3" translate="yes" xml:space="preserve">
          <source>The two values of the boolean type are written &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">布尔类型的两个值分别写为 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b6bd47b4f42af9e321626a41d3ac1a949889256" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same allocation in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="translated">类型&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;提供了在堆中分配的类型 &lt;code&gt;T&lt;/code&gt; 的值的共享所有权。在&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;会产生一个指向堆中相同分配的新指针。当指向给定分配的最后一个&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针被破坏时，存储在该分配中的值（通常称为&amp;ldquo;内部值&amp;rdquo;）也会被删除。</target>
        </trans-unit>
        <trans-unit id="372e682a79086a952e254015d9198d707b3497b2" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same value in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">类型&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;提供了在堆中分配的类型 &lt;code&gt;T&lt;/code&gt; 的值的共享所有权。在&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;会产生一个指向堆中相同值的新指针。当指向给定值的最后一个&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针被破坏时，指向的值也被破坏。</target>
        </trans-unit>
        <trans-unit id="061bd0bf671c2d672c454254d90151c86753f8be" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same allocation on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="translated">类型 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 提供了在堆中分配的类型 &lt;code&gt;T&lt;/code&gt; 的值的共享所有权。在 &lt;code&gt;Arc&lt;/code&gt; 上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;会生成一个新的 &lt;code&gt;Arc&lt;/code&gt; 实例，该实例指向堆上与源 &lt;code&gt;Arc&lt;/code&gt; 相同的分配，同时增加了引用计数。当销毁给定分配的最后一个 &lt;code&gt;Arc&lt;/code&gt; 指针时，存储在该分配中的值（通常称为&amp;ldquo;内部值&amp;rdquo;）也会被删除。</target>
        </trans-unit>
        <trans-unit id="6e13391af6d4685735ce2468fa0b2df950149996" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same value on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">类型 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 提供了在堆中分配的类型 &lt;code&gt;T&lt;/code&gt; 的值的共享所有权。在 &lt;code&gt;Arc&lt;/code&gt; 上调用&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;会产生一个新的 &lt;code&gt;Arc&lt;/code&gt; 实例，该实例在堆上指向与源 &lt;code&gt;Arc&lt;/code&gt; 相同的值，同时增加引用计数。当指向给定值的最后一个 &lt;code&gt;Arc&lt;/code&gt; 指针被破坏时，指向的值也被破坏。</target>
        </trans-unit>
        <trans-unit id="c30f5ce28986d51c472e8b2cb793889a1cf9299e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Cow&lt;/code&gt; is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the &lt;code&gt;Borrow&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Cow&lt;/code&gt; 类型是一种智能指针，提供了写时克隆功能：它可以封装并提供对借入数据的不变访问，并在需要突变或所有权时懒惰地克隆数据。该类型旨在通过 &lt;code&gt;Borrow&lt;/code&gt; 特征与一般借用数据一起使用。</target>
        </trans-unit>
        <trans-unit id="9f7d7514bdc86a24a5ff52dd05fe5c13a9b5c0e6" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Item&lt;/code&gt; is a placeholder type, and the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s definition shows that it will return values of type &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt;. Implementors of the &lt;code&gt;Iterator&lt;/code&gt; trait will specify the concrete type for &lt;code&gt;Item&lt;/code&gt;, and the &lt;code&gt;next&lt;/code&gt; method will return an &lt;code&gt;Option&lt;/code&gt; containing a value of that concrete type.</source>
          <target state="translated">&lt;code&gt;Item&lt;/code&gt; 类型是一个占位符类型， &lt;code&gt;next&lt;/code&gt; 方法的定义表明它将返回 &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt; 类型的值。 &lt;code&gt;Iterator&lt;/code&gt; 特性的实现者将为 &lt;code&gt;Item&lt;/code&gt; 指定具体类型， &lt;code&gt;next&lt;/code&gt; 方法将返回包含该具体类型值的 &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b50c152c5140d221fbe925adaec14a20d6c4527c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Self&lt;/code&gt; acts as an alias to the type of the current trait implementer, or &quot;receiver type&quot;. Besides the already mentioned &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt; and &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; valid receiver types, the following are also valid: &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt;, and &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; (where P is one of the previous types except &lt;code&gt;Self&lt;/code&gt;). Note that &lt;code&gt;Self&lt;/code&gt; can also be the underlying implementing type, like &lt;code&gt;Foo&lt;/code&gt; in the following example:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 类型充当当前特征实施者类型或&amp;ldquo;接收者类型&amp;rdquo;的别名。除了已经提到的 &lt;code&gt;Self&lt;/code&gt; ， &lt;code&gt;&amp;amp;Self&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; 有效接收器类型之外，以下内容也有效： &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; ， &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt; ， &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt; 和 &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; （其中P是除 &lt;code&gt;Self&lt;/code&gt; 之外的先前类型之一。请注意， &lt;code&gt;Self&lt;/code&gt; 也可以是基础实现类型，如以下示例中的 &lt;code&gt;Foo&lt;/code&gt; 所示：</target>
        </trans-unit>
        <trans-unit id="86f527297d32ae3d914332f31c2f8f0967b4e336" translate="yes" xml:space="preserve">
          <source>The type alias helps in two ways: it makes code easier to write &lt;em&gt;and&lt;/em&gt; it gives us a consistent interface across all of &lt;code&gt;std::io&lt;/code&gt;. Because it&amp;rsquo;s an alias, it&amp;rsquo;s just another &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which means we can use any methods that work on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with it, as well as special syntax like the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">类型别名有两个方面的帮助：它使代码更易于编写&lt;em&gt;，&lt;/em&gt;并且为我们提供了贯穿所有 &lt;code&gt;std::io&lt;/code&gt; 的一致接口。因为它是别名，所以它只是另一个 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ，这意味着我们可以使用对 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 起作用的任何方法，以及诸如 &lt;code&gt;?&lt;/code&gt; 的特殊语法。操作员。</target>
        </trans-unit>
        <trans-unit id="ea0e2aaa51d45e0a422d27f3c58e30936523ccce" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors.</source>
          <target state="translated">这里需要使用类型注释 &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; ，因为它可以 &lt;code&gt;collect&lt;/code&gt; 到许多不同的数据结构中，并且Rust除非您指定，否则不知道您想要哪个。但是，对于键和值类型的参数，我们使用下划线，Rust可以根据向量中数据的类型推断哈希映射包含的类型。</target>
        </trans-unit>
        <trans-unit id="19887ad86a95d19b831c6b68bb5aee99f3125dcd" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors. In Listing 8-21, the key type will be &lt;code&gt;String&lt;/code&gt; and the value type will be &lt;code&gt;i32&lt;/code&gt;, just as the types were in Listing 8-20.</source>
          <target state="translated">这里需要类型注释 &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; ，因为它可以 &lt;code&gt;collect&lt;/code&gt; 到许多不同的数据结构中，除非指定，Rust并不知道您想要哪个。但是，对于键和值类型的参数，我们使用下划线，Rust可以根据向量中数据的类型推断哈希映射包含的类型。在清单8-21中，键类型将为 &lt;code&gt;String&lt;/code&gt; ，而值类型将为 &lt;code&gt;i32&lt;/code&gt; ，就像清单8-20中的类型一样。</target>
        </trans-unit>
        <trans-unit id="fdf52c33ab9420faf47eea0ae86189b509c83d56" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in the previous code.</source>
          <target state="translated">类型定义包含一些字段，其类型需要一个有效期的注释。生存期注释（例如 &lt;code&gt;T: 'a&lt;/code&gt; ）用于确保T中的所有数据至少在生存期 &lt;code&gt;'a&lt;/code&gt; 内有效。如上代码所示，当类型包含关联的类型引用（例如 &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; ，通常会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="06a3cc90dfa59efcb3be0ad0da5e31c3b001a903" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in this example:</source>
          <target state="translated">类型定义包含一些字段，其类型需要一个有效期的注释。生存期注释（例如 &lt;code&gt;T: 'a&lt;/code&gt; ）用于确保T中的所有数据至少在生存期 &lt;code&gt;'a&lt;/code&gt; 内有效。当该类型包含关联的类型引用（例如 &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; ，通常会出现这种情况，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="fc99bc0924bfaeb5da14796b8d2b7f81fb11367e" translate="yes" xml:space="preserve">
          <source>The type does not fulfill the required lifetime.</source>
          <target state="translated">该类型不满足要求的寿命。</target>
        </trans-unit>
        <trans-unit id="9e9c0bf21d5e45e81b33f072a97367bb2e667f29" translate="yes" xml:space="preserve">
          <source>The type must have the &lt;code&gt;Sync&lt;/code&gt; trait bound to allow thread-safe access.</source>
          <target state="translated">该类型必须绑定 &lt;code&gt;Sync&lt;/code&gt; 特性，以允许线程安全访问。</target>
        </trans-unit>
        <trans-unit id="5761684433f543db118c22f7a347176798eaf3c5" translate="yes" xml:space="preserve">
          <source>The type name should not be considered a unique identifier of a type; multiple types may share the same type name.</source>
          <target state="translated">类型名称不应该被认为是一个类型的唯一标识符;多个类型可以共享同一个类型名称。</target>
        </trans-unit>
        <trans-unit id="8abd0fc7da623f26ad9fecceeea94f5bfc1f633a" translate="yes" xml:space="preserve">
          <source>The type name used is not in scope.</source>
          <target state="translated">使用的类型名称不在范围内。</target>
        </trans-unit>
        <trans-unit id="89e2360bf1d9e23be29f6ad88e266a77e3f4f82f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;guess&lt;/code&gt; in this code would have to be an integer &lt;em&gt;and&lt;/em&gt; a string, and Rust requires that &lt;code&gt;guess&lt;/code&gt; have only one type. So what does &lt;code&gt;continue&lt;/code&gt; return? How were we allowed to return a &lt;code&gt;u32&lt;/code&gt; from one arm and have another arm that ends with &lt;code&gt;continue&lt;/code&gt; in Listing 19-26?</source>
          <target state="translated">此代码中的 &lt;code&gt;guess&lt;/code&gt; 类型必须是整数&lt;em&gt;和&lt;/em&gt;字符串，Rust要求该 &lt;code&gt;guess&lt;/code&gt; 只有一种类型。那么， &lt;code&gt;continue&lt;/code&gt; 返回什么呢？在清单19-26中，如何允许我们从一个手臂返回 &lt;code&gt;u32&lt;/code&gt; 并让另一个手臂以 &lt;code&gt;continue&lt;/code&gt; 结尾？</target>
        </trans-unit>
        <trans-unit id="ae6cd25ffa500de06212f0c2207844d88b02a6be" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;s&lt;/code&gt; here is &lt;code&gt;&amp;amp;str&lt;/code&gt;: it&amp;rsquo;s a slice pointing to that specific point of the binary. This is also why string literals are immutable; &lt;code&gt;&amp;amp;str&lt;/code&gt; is an immutable reference.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 的类型是 &lt;code&gt;&amp;amp;str&lt;/code&gt; ：它是指向二进制文件的特定点的切片。这也是字符串文字不可变的原因。 &lt;code&gt;&amp;amp;str&lt;/code&gt; 是不可变的引用。</target>
        </trans-unit>
        <trans-unit id="34ca2b2668ed637a52d925af5ee324f0385b2620" translate="yes" xml:space="preserve">
          <source>The type of a block is the type of the final expression, or &lt;code&gt;()&lt;/code&gt; if the final expression is omitted.</source>
          <target state="translated">块的类型是最终表达式的类型，如果省略了最终表达式，则为 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04575cb944f5ba2523fe623e2ff7231ff81edabc" translate="yes" xml:space="preserve">
          <source>The type of a const parameter references other generic parameters.</source>
          <target state="translated">一个const参数的类型会引用其他通用参数。</target>
        </trans-unit>
        <trans-unit id="ed47b86a36c39f67b1e05de4464008d8a1956f2c" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; floating-point literal is determined by type inference:</source>
          <target state="translated">不带&lt;em&gt;后缀的&lt;/em&gt;浮点文字的类型由类型推断确定：</target>
        </trans-unit>
        <trans-unit id="6114cd343a30b85f17666d6fd494268587f7b8ea" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; integer literal is determined by type inference:</source>
          <target state="translated">无&lt;em&gt;后缀&lt;/em&gt;整数文字的类型由类型推断确定：</target>
        </trans-unit>
        <trans-unit id="89c2fbc4e2ada9abaa3500c6a37ddee8522542e8" translate="yes" xml:space="preserve">
          <source>The type of the discriminant, which must satisfy the trait bounds required by &lt;code&gt;mem::Discriminant&lt;/code&gt;.</source>
          <target state="translated">判别类型，必须满足 &lt;code&gt;mem::Discriminant&lt;/code&gt; 要求的特征范围。</target>
        </trans-unit>
        <trans-unit id="f7d869126e3c264254879784374ee68ec03547b9" translate="yes" xml:space="preserve">
          <source>The type of the elements being iterated over.</source>
          <target state="translated">被迭代的元素的类型。</target>
        </trans-unit>
        <trans-unit id="af8245e533db8494bb30cc9dc28768887bbb8570" translate="yes" xml:space="preserve">
          <source>The type of the value that &lt;code&gt;File::open&lt;/code&gt; returns inside the &lt;code&gt;Err&lt;/code&gt; variant is &lt;code&gt;io::Error&lt;/code&gt;, which is a struct provided by the standard library. This struct has a method &lt;code&gt;kind&lt;/code&gt; that we can call to get an &lt;code&gt;io::ErrorKind&lt;/code&gt; value. The enum &lt;code&gt;io::ErrorKind&lt;/code&gt; is provided by the standard library and has variants representing the different kinds of errors that might result from an &lt;code&gt;io&lt;/code&gt; operation. The variant we want to use is &lt;code&gt;ErrorKind::NotFound&lt;/code&gt;, which indicates the file we&amp;rsquo;re trying to open doesn&amp;rsquo;t exist yet. So we match on &lt;code&gt;f&lt;/code&gt;, but we also have an inner match on &lt;code&gt;error.kind()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 在 &lt;code&gt;Err&lt;/code&gt; 变量内部返回的值的类型是 &lt;code&gt;io::Error&lt;/code&gt; ，这是标准库提供的结构。该结构具有一种方法 &lt;code&gt;kind&lt;/code&gt; ，我们可以调用该方法类型以获得 &lt;code&gt;io::ErrorKind&lt;/code&gt; 值。枚举 &lt;code&gt;io::ErrorKind&lt;/code&gt; 由标准库提供，并且具有表示 &lt;code&gt;io&lt;/code&gt; 操作可能导致的各种错误的变体。我们要使用的变体是 &lt;code&gt;ErrorKind::NotFound&lt;/code&gt; ，它指示我们要打开的文件尚不存在。因此，我们在 &lt;code&gt;f&lt;/code&gt; 上进行匹配，但在 &lt;code&gt;error.kind()&lt;/code&gt; 上也进行了内部匹配。</target>
        </trans-unit>
        <trans-unit id="545510a669763ef63063641881497bf7dd3f481a" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as failed.</source>
          <target state="translated">该值被视为失败时的类型。</target>
        </trans-unit>
        <trans-unit id="8b60f120f0bca222851815dfc6ed07a4a0520575" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as successful.</source>
          <target state="translated">此值的类型,当视为成功。</target>
        </trans-unit>
        <trans-unit id="bf039a86046c9f49aceed05895007223ced0c5ff" translate="yes" xml:space="preserve">
          <source>The type of value produced on completion.</source>
          <target state="translated">完成时产生的价值类型。</target>
        </trans-unit>
        <trans-unit id="16751927675b4a2fde8980932985c3b025559cb0" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns.</source>
          <target state="translated">该生成器返回的值的类型。</target>
        </trans-unit>
        <trans-unit id="bf293514c386bb6e45033b7b50e4549a332b83ad" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此生成器返回的值的类型。&lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcbd5cd653d3daa61c5d5d30831f8972d04f844c" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">此生成器返回的值的类型。&lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5e0eda41ab22396cfa2f1334045d1746f855426" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields.</source>
          <target state="translated">这个发生器产生的值的类型。</target>
        </trans-unit>
        <trans-unit id="b8cb8237cc8b58247dbdfe05ac4618d5ded726d1" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">该生成器产生的值的类型。&lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="becf5070fa5e52c8db7c1d497d6f97d2d8cc4f48" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">该生成器产生的值的类型。&lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="586fe8d7efe2a1acc6c511b646a3a08c88efbb26" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;T&lt;/code&gt; represents the data that this lock protects. It is required that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; to be shared across threads and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; to allow concurrent access through readers. The RAII guards returned from the locking methods implement &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;write&lt;/code&gt; methods) to allow access to the content of the lock.</source>
          <target state="translated">类型参数 &lt;code&gt;T&lt;/code&gt; 表示此锁保护的数据。要求 &lt;code&gt;T&lt;/code&gt; 满足&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;要在线程之间共享和&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;以允许通过读取器并发访问。从锁定方法返回的RAII防护实现了&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;（对于 &lt;code&gt;write&lt;/code&gt; 方法，则使用&lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;）以允许访问锁的内容。</target>
        </trans-unit>
        <trans-unit id="f6f9ae50a3ab94a8cf9005786a7b9af006ffe517" translate="yes" xml:space="preserve">
          <source>The type parameters can also be explicitly supplied in a trailing &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt;.</source>
          <target state="translated">类型参数也可以在函数名称之后的尾随&lt;a href=&quot;../paths&quot;&gt;路径&lt;/a&gt;组件中显式提供。如果没有足够的上下文来确定类型参数，则可能有必要。例如， &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="618c44497e554625efd295f7702914ef5292c792" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; can be used outside item's signature as follows:</source>
          <target state="translated">占位符 &lt;code&gt;_&lt;/code&gt; 类型可以在项目签名之外使用，如下所示：</target>
        </trans-unit>
        <trans-unit id="ba2931173dcc6550d705628d261c402eccc53232" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; was used within a type on an item's signature.</source>
          <target state="translated">类型占位符 &lt;code&gt;_&lt;/code&gt; 用于项目签名上的类型。</target>
        </trans-unit>
        <trans-unit id="11d805f97c85ceb05a75d626e5740cb0e2204f44" translate="yes" xml:space="preserve">
          <source>The type returned by formatter methods.</source>
          <target state="translated">由formatter方法返回的类型。</target>
        </trans-unit>
        <trans-unit id="1c16d9adfa415d1c3d1e4550b932c426a82800c2" translate="yes" xml:space="preserve">
          <source>The type returned in the event of a conversion error.</source>
          <target state="translated">发生转换错误时返回的类型。</target>
        </trans-unit>
        <trans-unit id="2d7863bb088ba575c630ae75df049f3bc518eb6c" translate="yes" xml:space="preserve">
          <source>The type that the &lt;code&gt;else&lt;/code&gt; blocks evaluate to must be compatible with the type that the &lt;code&gt;if&lt;/code&gt; block evaluates to.</source>
          <target state="translated">该型 &lt;code&gt;else&lt;/code&gt; 块计算为必须与类型兼容 &lt;code&gt;if&lt;/code&gt; 块计算后得到。</target>
        </trans-unit>
        <trans-unit id="f8e8d68133a2235c54df1609c3fa9dc8e972aa60" translate="yes" xml:space="preserve">
          <source>The type to return is inferred from context; this is equivalent to &lt;code&gt;Default::default()&lt;/code&gt; but shorter to type.</source>
          <target state="translated">从上下文推断要返回的类型。这等效于 &lt;code&gt;Default::default()&lt;/code&gt; 但较短。</target>
        </trans-unit>
        <trans-unit id="6b611879bfea657d3652c629b736393c4b650211" translate="yes" xml:space="preserve">
          <source>The type you are trying to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; for is not a struct. &lt;code&gt;CoerceUnsized&lt;/code&gt; can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of &lt;code&gt;CoerceUnsized&lt;/code&gt; whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">您尝试 &lt;code&gt;CoerceUnsized&lt;/code&gt; 的类型不是结构。 &lt;code&gt;CoerceUnsized&lt;/code&gt; 只能对结构实现。无需执行 &lt;code&gt;CoerceUnsized&lt;/code&gt; 的实现，就可以强制未大小类型，而包含未大小类型的结构需要知道其包含的未大小类型字段是否可以被强制。一个&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;未施胶类型&lt;/a&gt;是任何类型的，该编译器不知道在编译时间的长度或对准。包含未调整大小类型的任何结构也是未调整大小的。</target>
        </trans-unit>
        <trans-unit id="63c27305b7150da660772855aa4571d697d89b10" translate="yes" xml:space="preserve">
          <source>The type you can compare with is controlled by &lt;code&gt;PartialEq&lt;/code&gt;'s type parameter. For example, let's tweak our previous code a bit:</source>
          <target state="translated">您可以比较的类型由 &lt;code&gt;PartialEq&lt;/code&gt; 的type参数控制。例如，让我们稍微调整一下之前的代码：</target>
        </trans-unit>
        <trans-unit id="93ef2caad28212460c75d9146f8dc4d0899b2d98" translate="yes" xml:space="preserve">
          <source>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</source>
          <target state="translated">类型检查员需要知道一个表达式的类型,但该类型还没有被推断出来。</target>
        </trans-unit>
        <trans-unit id="f584bedf990c038f22247101ab8b097fb3a593e8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;*const T&lt;/code&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; all have the same size. If &lt;code&gt;T&lt;/code&gt; is Sized, all of those types have the same size as &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;*const T&lt;/code&gt; ， &lt;code&gt;&amp;amp;T&lt;/code&gt; ， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 全部具有相同的尺寸。如果 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;usize&lt;/code&gt; ，则所有这些类型的大小都与usize相同。</target>
        </trans-unit>
        <trans-unit id="5722d857751fd92f7cd76388f248410597abc535" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; hold textual data.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 类型保存文本数据。</target>
        </trans-unit>
        <trans-unit id="99894423e354dd0b37e0c9ced81c62b48fcf23b2" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition.</source>
          <target state="translated">特质实现中任何关联常量的类型必须与特质定义中的类型相匹配。</target>
        </trans-unit>
        <trans-unit id="ff52a3715390889940af516c60b08b678feeadf3" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition. This error indicates that there was a mismatch.</source>
          <target state="translated">特质实现中任何相关常量的类型必须与特质定义中的类型相匹配。该错误表明存在不匹配的情况。</target>
        </trans-unit>
        <trans-unit id="2a9653c2b160c32821b432c07707efaa597921f1" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;Arc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取 &lt;code&gt;Weak&lt;/code&gt; 指针的典型方法是调用&lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;Arc::downgrade&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7670bf148a2a36a6287e0959f849df36450aeea" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;Rc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取 &lt;code&gt;Weak&lt;/code&gt; 指针的典型方法是调用&lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;Rc::downgrade&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e38264f429668f9c24babca8440ad652db0e6325" translate="yes" xml:space="preserve">
          <source>The unary logical negation operator &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">一元逻辑否定运算符 &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6144b29ea1cdce68ecac471463a0fdc0639b34f9" translate="yes" xml:space="preserve">
          <source>The unary negation operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">一元求反运算符 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7181a66c31dbb848d4da8d3e96055db8ae78d130" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;struct.metadata&quot;&gt;&lt;code&gt;Metadata&lt;/code&gt;&lt;/a&gt; struct needs to be retrieved with the &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt; function and not the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function follows symbolic links, so &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt; would always return &lt;code&gt;false&lt;/code&gt; for the target file.</source>
          <target state="translated">需要使用&lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt;函数而不是&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;函数来检索基础&lt;a href=&quot;struct.metadata&quot;&gt; &lt;code&gt;Metadata&lt;/code&gt; &lt;/a&gt;结构。该&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;功能如下符号链接，所以&lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt;总是会返回 &lt;code&gt;false&lt;/code&gt; 目标文件。</target>
        </trans-unit>
        <trans-unit id="5ba52bb287979fcbe21a62414e5cba80ede6c6c5" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can never be mutably borrowed from again and will always appear already immutably borrowed. It is not a good idea to leak more than a constant number of references. The &lt;code&gt;RefCell&lt;/code&gt; can be immutably borrowed again if only a smaller number of leaks have occurred in total.</source>
          <target state="translated">底层 &lt;code&gt;RefCell&lt;/code&gt; 永远不会再被可变借用，并且总是看起来已经一成不变地借用了。泄漏过多的引用不是一个好主意。如果 &lt;code&gt;RefCell&lt;/code&gt; 只发生了少量的泄漏，则可以再次借用RefCell。</target>
        </trans-unit>
        <trans-unit id="16573dc48843cb6201240052d6b60dde180482de" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can not be borrowed from again and will always appear already mutably borrowed, making the returned reference the only to the interior.</source>
          <target state="translated">基础 &lt;code&gt;RefCell&lt;/code&gt; 不能再次借用，并且总是看起来已经可变地借用了，从而使返回的引用成为内部的唯一引用。</target>
        </trans-unit>
        <trans-unit id="485a92064bc4fcb63908fa7e1b3b1ad970b9f88b" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; will remain mutably borrowed until both returned &lt;code&gt;RefMut&lt;/code&gt;s go out of scope.</source>
          <target state="translated">基础 &lt;code&gt;RefCell&lt;/code&gt; 将保持可变借用状态，直到返回的两个 &lt;code&gt;RefMut&lt;/code&gt; 都超出范围。</target>
        </trans-unit>
        <trans-unit id="9efa2c9dbfc51e4660e725c77fd7efb185f3f6ff" translate="yes" xml:space="preserve">
          <source>The underlying value can be retrieved through the &lt;code&gt;.0&lt;/code&gt; index of the &lt;code&gt;Wrapping&lt;/code&gt; tuple.</source>
          <target state="translated">可以通过 &lt;code&gt;Wrapping&lt;/code&gt; 元组的 &lt;code&gt;.0&lt;/code&gt; 索引检索基础值。</target>
        </trans-unit>
        <trans-unit id="1be4ec15824529c7ce6527861e8c2980ac38212f" translate="yes" xml:space="preserve">
          <source>The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to &lt;code&gt;_&lt;/code&gt; imports. For example, the following should not produce an error:</source>
          <target state="translated">宏扩展后会创建唯一的，无法命名的符号，以便宏可以安全地发出对 &lt;code&gt;_&lt;/code&gt; 导入的多个引用。例如，以下内容不应产生错误：</target>
        </trans-unit>
        <trans-unit id="f4f440ca9518cd96f0fe9c31f85a61d77e18e0f3" translate="yes" xml:space="preserve">
          <source>The unsafe counterpart of this macro is the &lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;unreachable_unchecked&lt;/code&gt;&lt;/a&gt; function, which will cause undefined behavior if the code is reached.</source>
          <target state="translated">此宏的不安全对应项是&lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;unreachable_unchecked&lt;/code&gt; &lt;/a&gt;函数，如果到达代码，它将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c1a83814a7bcbd2091dc90767bec8f24c5d3f1e3" translate="yes" xml:space="preserve">
          <source>The unsigned integer types consist of:</source>
          <target state="translated">无符号整数类型包括:</target>
        </trans-unit>
        <trans-unit id="2d2ce136339d709e77fd2d67b03ff1b69af40d44" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (exclusive).</source>
          <target state="translated">幅度的上界(不含)。</target>
        </trans-unit>
        <trans-unit id="20d82b105410f2577709f06e6539062262a0ca81" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (inclusive)</source>
          <target state="translated">幅度的上限(包括)</target>
        </trans-unit>
        <trans-unit id="e68185f2e9603472a1563c4f776b66b2c6a3b822" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; keyword in this position allows the function writer to hide the concrete type as an implementation detail which can change without breaking user's code.</source>
          <target state="translated">在此位置使用&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt;关键字可以使函数编写器将具体类型隐藏为实现细节，可以在不破坏用户代码的情况下对其进行更改。</target>
        </trans-unit>
        <trans-unit id="39cef1794b05feb8ec892ea4cd89efe908da35c8" translate="yes" xml:space="preserve">
          <source>The user could always interrupt the program by using the keyboard shortcut ctrl-c. But there&amp;rsquo;s another way to escape this insatiable monster, as mentioned in the &lt;code&gt;parse&lt;/code&gt; discussion in &lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt;: if the user enters a non-number answer, the program will crash. The user can take advantage of that in order to quit, as shown here:</source>
          <target state="translated">用户可以始终使用键盘快捷键ctrl-c中断程序。但是，还有另一种逃避这种无法满足的怪物的方法，如&lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;将猜测与秘密数字进行比较&amp;rdquo;&lt;/a&gt;的 &lt;code&gt;parse&lt;/code&gt; 讨论中所提到的：如果用户输入非数字答案，则程序将崩溃。用户可以利用它来退出，如下所示：</target>
        </trans-unit>
        <trans-unit id="e62c088fdd6cf7f93babb9263d9008d71eaadccf" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to perform &lt;code&gt;metadata&lt;/code&gt; call on &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">用户缺乏在 &lt;code&gt;path&lt;/code&gt; 上执行 &lt;code&gt;metadata&lt;/code&gt; 调用的权限。</target>
        </trans-unit>
        <trans-unit id="0dc65bb53b7876e2a52ec0de6c50b31a471724ba" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the directory at the provided &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">用户没有权限在提供的 &lt;code&gt;path&lt;/code&gt; 删除目录。</target>
        </trans-unit>
        <trans-unit id="4ed8999bb1ca133f6f343fbba9eb07d31db22560" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the file.</source>
          <target state="translated">该用户缺乏删除文件的权限。</target>
        </trans-unit>
        <trans-unit id="da243dceea5f741ec03e2474a95470f701358e02" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to view contents.</source>
          <target state="translated">用户没有查看内容的权限。</target>
        </trans-unit>
        <trans-unit id="a0ceecf91cf3de088e4866146d667401fc9825c7" translate="yes" xml:space="preserve">
          <source>The user lacks the permission to change attributes of the file.</source>
          <target state="translated">用户缺乏改变文件属性的权限。</target>
        </trans-unit>
        <trans-unit id="0728943e3f9e2dd60ac0860b5efc3c86277bbcf8" translate="yes" xml:space="preserve">
          <source>The user of &lt;code&gt;from_raw&lt;/code&gt; has to make sure a specific value of &lt;code&gt;T&lt;/code&gt; is only dropped once.</source>
          <target state="translated">&lt;code&gt;from_raw&lt;/code&gt; 的用户必须确保 &lt;code&gt;T&lt;/code&gt; 的特定值仅被删除一次。</target>
        </trans-unit>
        <trans-unit id="8bc0d661ff73b2e7b2da5a4e28c09493dbabbf98" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;to_drop&lt;/code&gt; points to must be valid for dropping, which may mean it must uphold additional invariants - this is type-dependent.</source>
          <target state="translated">&lt;code&gt;to_drop&lt;/code&gt; 指向的值必须对删除有效，这可能意味着它必须支持其他不变式-这与类型有关。</target>
        </trans-unit>
        <trans-unit id="9ef61ff6808c20e3aee33111c7be00b7f9eb3ce9" translate="yes" xml:space="preserve">
          <source>The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.</source>
          <target state="translated">被胁迫的值是实际参数,它被胁迫到形式参数的类型。</target>
        </trans-unit>
        <trans-unit id="a4543ae96f3c210a98b1abf8fa6e1fffb99a3a60" translate="yes" xml:space="preserve">
          <source>The value contained in the &lt;code&gt;Result::Err&lt;/code&gt; variant is the value the thread panicked with; that is, the argument the &lt;code&gt;panic!&lt;/code&gt; macro was called with. Unlike with normal errors, this value doesn't implement the &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">中包含的值 &lt;code&gt;Result::Err&lt;/code&gt; 变种是线程恐慌与价值; 那就是争执 &lt;code&gt;panic!&lt;/code&gt; 宏被调用了。与正常错误不同，此值不会实现&lt;a href=&quot;../error/trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;特征。</target>
        </trans-unit>
        <trans-unit id="3a5a7553814237ff25467a69b929b269b579c5c7" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;push&lt;/code&gt; is an expected cost; the method documentation gives a more detailed analysis.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 的价值是预期成本；方法文档提供了更详细的分析。</target>
        </trans-unit>
        <trans-unit id="7655c33f10da48be510d779b36c1473fc0c444da" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by adding a postfix &lt;code&gt;$&lt;/code&gt;, indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width.</source>
          <target state="translated">通过添加后缀 &lt;code&gt;$&lt;/code&gt; ，也可以在参数列表中将宽度的值用作&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;，指示第二个参数是指定宽度的&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7971e26c81d228c6b498e7c0267b27f63e3a2f0" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by using the dollar syntax indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width, for example:</source>
          <target state="translated">对于宽度的值也可以被提供为&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;通过使用指示所述第二参数是一个美元语法中的参数列表&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;指定宽度，例如：</target>
        </trans-unit>
        <trans-unit id="a708656013343fb0ab99fafd8d21e4229d39b962" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">该值可以是集合值类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与该值类型的值匹配。</target>
        </trans-unit>
        <trans-unit id="6f10fa6eb368dac898013f2276c185e31dd968d4" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">该值可以是集合值类型的任何借用形式，但是借用形式上的&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;&lt;em&gt;必须&lt;/em&gt;与该值类型的值匹配。</target>
        </trans-unit>
        <trans-unit id="cc1bf7113b6ffebee8a5cbda9953ce0f46aa8389" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the value type.</source>
          <target state="translated">该值可以是集合值类型的任何借位形式，但是借位形式上的顺序&lt;em&gt;必须&lt;/em&gt;与值类型上的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="5386004ae808f6aad83668aa6e791c4916959b45" translate="yes" xml:space="preserve">
          <source>The value must not be zero.</source>
          <target state="translated">该值不得为零。</target>
        </trans-unit>
        <trans-unit id="72b7ccc4c541479713442aeb6f9117133107de5e" translate="yes" xml:space="preserve">
          <source>The value must:</source>
          <target state="translated">该值必须:</target>
        </trans-unit>
        <trans-unit id="fe1619fc66fbf6e80510234756b7616df221cbcc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;N&lt;/code&gt; that was specified for &lt;code&gt;repr(align(N))&lt;/code&gt; was not a power of two, or was greater than 2^29.</source>
          <target state="translated">为 &lt;code&gt;repr(align(N))&lt;/code&gt; 指定的 &lt;code&gt;N&lt;/code&gt; 的值不是2的幂，或者大于2 ^ 29。</target>
        </trans-unit>
        <trans-unit id="744a6000b03885b8f256f7629c96527779c5f909" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;upper_i&lt;/code&gt; here relies on the language of the text: if we're in &lt;code&gt;en-US&lt;/code&gt;, it should be &lt;code&gt;&quot;I&quot;&lt;/code&gt;, but if we're in &lt;code&gt;tr_TR&lt;/code&gt;, it should be &lt;code&gt;&quot;İ&quot;&lt;/code&gt;. &lt;code&gt;to_uppercase()&lt;/code&gt; does not take this into account, and so:</source>
          <target state="translated">这里的 &lt;code&gt;upper_i&lt;/code&gt; 的值取决于文本的语言：如果我们在 &lt;code&gt;en-US&lt;/code&gt; 中，则应为 &lt;code&gt;&quot;I&quot;&lt;/code&gt; ，但如果我们在 &lt;code&gt;tr_TR&lt;/code&gt; 中，则应为 &lt;code&gt;&quot;İ&quot;&lt;/code&gt; 。 &lt;code&gt;to_uppercase()&lt;/code&gt; 没有考虑到这一点，因此：</target>
        </trans-unit>
        <trans-unit id="5ddda6614ea7e3e67438b2aae41a24ac0eb3ff50" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.</source>
          <target state="translated">静态和常量的值必须在编译时知道,它们在程序的整个生命周期中都是存在的。创建一个框定值会在运行时在堆上分配内存,因此不能在编译时进行。</target>
        </trans-unit>
        <trans-unit id="b739d6552c67cec966b03a294f348b71a38926c7" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time. Erroneous code example:</source>
          <target state="translated">静态和常量的值必须在编译时知道,它们在程序的整个生命周期中都是存在的。创建一个框定值会在运行时在堆上分配内存,因此不能在编译时进行。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="4b2ff9e347c3c08ba8e806ad69a147ed48871d42" translate="yes" xml:space="preserve">
          <source>The value returned is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; but does not flush the internal buffer. Due to this optimization the function does not guarantee that calling &lt;code&gt;.into_inner()&lt;/code&gt; immediately afterwards will yield the underlying reader at the same position. Use &lt;a href=&quot;struct.bufreader#method.seek&quot;&gt;&lt;code&gt;BufReader::seek&lt;/code&gt;&lt;/a&gt; instead if you require that guarantee.</source>
          <target state="translated">返回的值等效于 &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; 但不刷新内部缓冲区。由于进行了这种优化，该函数不能保证之后立即调用 &lt;code&gt;.into_inner()&lt;/code&gt; 会在相同位置产生底层阅读器。如果需要保证，请改用&lt;a href=&quot;struct.bufreader#method.seek&quot;&gt; &lt;code&gt;BufReader::seek&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39c061cf746d3ba8e95a5a5598de09efb58fb7b8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; has type &lt;code&gt;String&lt;/code&gt;, and its use in the guard is as a variable of type &lt;code&gt;String&lt;/code&gt;. The guard code effectively executes in a separate scope to the body of the arm, so the value would be moved into this anonymous scope and therefore becomes unavailable in the body of the arm.</source>
          <target state="translated">变量 &lt;code&gt;s&lt;/code&gt; 的类型为 &lt;code&gt;String&lt;/code&gt; ，它在防护中的用途为 &lt;code&gt;String&lt;/code&gt; 类型的变量。保护代码有效地在手臂主体的单独范围内执行，因此该值将移至该匿名范围，因此在手臂主体中变得不可用。</target>
        </trans-unit>
        <trans-unit id="8e557a8691f00e33607a16e96773df5a29940a13" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it&amp;rsquo;s declared until the end of the current &lt;em&gt;scope&lt;/em&gt;. Listing 4-1 has comments annotating where the variable &lt;code&gt;s&lt;/code&gt; is valid.</source>
          <target state="translated">变量 &lt;code&gt;s&lt;/code&gt; 表示字符串文字，其中字符串的值被硬编码到程序的文本中。从声明变量到当前&lt;em&gt;范围&lt;/em&gt;的结尾，变量一直有效。清单4-1带有注释，说明变量 &lt;code&gt;s&lt;/code&gt; 在何处有效。</target>
        </trans-unit>
        <trans-unit id="5e699bc2ac5d00c87b2c7f3b8e3a9da4a553a5d0" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;tup&lt;/code&gt; binds to the entire tuple, because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</source>
          <target state="translated">变量 &lt;code&gt;tup&lt;/code&gt; 绑定到整个元组，因为元组被视为单个复合元素。为了从元组中取出单个值，我们可以使用模式匹配来破坏元组值，如下所示：</target>
        </trans-unit>
        <trans-unit id="b81aa2b0402a0e499f7595712bef15edfd23e380" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; doesn&amp;rsquo;t &amp;ldquo;live long enough.&amp;rdquo; The reason is that &lt;code&gt;x&lt;/code&gt; will be out of scope when the inner scope ends on line 7. But &lt;code&gt;r&lt;/code&gt; is still valid for the outer scope; because its scope is larger, we say that it &amp;ldquo;lives longer.&amp;rdquo; If Rust allowed this code to work, &lt;code&gt;r&lt;/code&gt; would be referencing memory that was deallocated when &lt;code&gt;x&lt;/code&gt; went out of scope, and anything we tried to do with &lt;code&gt;r&lt;/code&gt; wouldn&amp;rsquo;t work correctly. So how does Rust determine that this code is invalid? It uses a borrow checker.</source>
          <target state="translated">变量 &lt;code&gt;x&lt;/code&gt; 的寿命不足。原因是当内部范围在第7行结束时， &lt;code&gt;x&lt;/code&gt; 将不在范围内。但是 &lt;code&gt;r&lt;/code&gt; 对于外部范围仍然有效；因为它的范围更大，所以我们说它的寿命更长。如果Rust允许此代码工作，则 &lt;code&gt;r&lt;/code&gt; 将引用 &lt;code&gt;x&lt;/code&gt; 超出范围时已释放的内存，而我们尝试使用 &lt;code&gt;r&lt;/code&gt; 进行的任何操作均将无法正常工作。那么Rust如何确定该代码无效呢？它使用借阅检查器。</target>
        </trans-unit>
        <trans-unit id="b4588e360f79d1cb0e5f79f31bf6e7bc2ece8336" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; holds an &lt;code&gt;i32&lt;/code&gt; value, &lt;code&gt;5&lt;/code&gt;. We set &lt;code&gt;y&lt;/code&gt; equal to a reference to &lt;code&gt;x&lt;/code&gt;. We can assert that &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;5&lt;/code&gt;. However, if we want to make an assertion about the value in &lt;code&gt;y&lt;/code&gt;, we have to use &lt;code&gt;*y&lt;/code&gt; to follow the reference to the value it&amp;rsquo;s pointing to (hence &lt;em&gt;dereference&lt;/em&gt;). Once we dereference &lt;code&gt;y&lt;/code&gt;, we have access to the integer value &lt;code&gt;y&lt;/code&gt; is pointing to that we can compare with &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">变量 &lt;code&gt;x&lt;/code&gt; 拥有 &lt;code&gt;i32&lt;/code&gt; 值 &lt;code&gt;5&lt;/code&gt; 。我们将 &lt;code&gt;y&lt;/code&gt; 设置为等于 &lt;code&gt;x&lt;/code&gt; 的引用。我们可以断言 &lt;code&gt;x&lt;/code&gt; 等于 &lt;code&gt;5&lt;/code&gt; 。但是，如果要对 &lt;code&gt;y&lt;/code&gt; 中的值进行断言，则必须使用 &lt;code&gt;*y&lt;/code&gt; 跟随对它指向的值的&lt;em&gt;引用&lt;/em&gt;（因此&lt;em&gt;取消引用&lt;/em&gt;）。一旦取消引用 &lt;code&gt;y&lt;/code&gt; ，就可以访问 &lt;code&gt;y&lt;/code&gt; 所指向的整数，该整数可以与 &lt;code&gt;5&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="b7511a7213b8989f428e5bec2c5234f95d46bda2" translate="yes" xml:space="preserve">
          <source>The variables that a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; captures by move are dropped in an unspecified order.</source>
          <target state="translated">&lt;a href=&quot;types/closure&quot;&gt;闭包&lt;/a&gt;通过移动捕获的变量以未指定的顺序删除。</target>
        </trans-unit>
        <trans-unit id="f517012aa2f18b099c9314a6c9154f5976be9a45" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">其他 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;enum&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 和tuple类型的方差是通过查看其字段类型的方差来确定的。如果参数用于具有不同方差的位置，则参数是不变的。例如，以下结构在 &lt;code&gt;'a&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 中是协变的，而在 &lt;code&gt;'b&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 中是不变的。</target>
        </trans-unit>
        <trans-unit id="edea3e36560d105a970958779d2fd8e9db94e633" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">其他 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;enum&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 和tuple类型的方差是通过查看其字段类型的方差来确定的。如果参数用于具有不同方差的位置，则参数是不变的。例如，以下结构在 &lt;code&gt;'a&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 中是协变的，而在 &lt;code&gt;'b&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 中是不变的。</target>
        </trans-unit>
        <trans-unit id="c0eb1ade80b4414ebb3db98e5e4492d2cfa8b829" translate="yes" xml:space="preserve">
          <source>The vector used to create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="translated">用于创建&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;的向量必须位于末尾且只有一个nul字节。</target>
        </trans-unit>
        <trans-unit id="a2a9da86bd97667912e395039b2e850ba36a8d1a" translate="yes" xml:space="preserve">
          <source>The vector will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the vector will not allocate.</source>
          <target state="translated">该向量将能够精确地 &lt;code&gt;capacity&lt;/code&gt; 元素而无需重新分配。如果 &lt;code&gt;capacity&lt;/code&gt; 为0，则不会分配向量。</target>
        </trans-unit>
        <trans-unit id="4a1a063010e523349572dfe2f3d4599fdbf7faf0" translate="yes" xml:space="preserve">
          <source>The vector will not allocate until elements are pushed onto it.</source>
          <target state="translated">在元素被推送到向量上之前,向量不会进行分配。</target>
        </trans-unit>
        <trans-unit id="4d0b594b3c2a18ead8ab96882d29be04515f3b55" translate="yes" xml:space="preserve">
          <source>The version numbering scheme is explained in &lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;Unicode 11.0 or later, Section 3.1 Versions of the Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">版本编号方案在&lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;Unicode 11.0或更高版本的Unicode Standard的3.1节中进行了说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0be7c75604b320ccdf03b29c2cf5dc9816b16f93" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;http://www.unicode.org/&quot;&gt;Unicode&lt;/a&gt; that the Unicode parts of &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods are based on.</source>
          <target state="translated">版本&lt;a href=&quot;http://www.unicode.org/&quot;&gt;的Unicode&lt;/a&gt;说的Unicode部分 &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 方法基础上的。</target>
        </trans-unit>
        <trans-unit id="f1a9780d68fd5f1336a540e5d09603fdf5d5a727" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;https://www.unicode.org/&quot;&gt;Unicode&lt;/a&gt; that the Unicode parts of &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods are based on.</source>
          <target state="translated">版本&lt;a href=&quot;https://www.unicode.org/&quot;&gt;的Unicode&lt;/a&gt;说的Unicode部分 &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 方法基础上的。</target>
        </trans-unit>
        <trans-unit id="2e7d7937a98ae8b5db75096586d34257981a3b35" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a by-value receiver.</source>
          <target state="translated">呼叫运营商的版本,采取按值接收。</target>
        </trans-unit>
        <trans-unit id="98bb0c84eb64933810db44150740704106b58e5b" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a mutable receiver.</source>
          <target state="translated">调用操作符的版本,接受一个可变的接收器。</target>
        </trans-unit>
        <trans-unit id="a10ea779af62c4002732377426c5466fd9b100f8" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes an immutable receiver.</source>
          <target state="translated">呼叫运营商的版本,采取的是不可更改的接收机。</target>
        </trans-unit>
        <trans-unit id="69df36660018fe57f4bfd6fa17c4ad5d9397540f" translate="yes" xml:space="preserve">
          <source>The volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt;].</source>
          <target state="translated">易失性内在函数提供旨在作用于I / O内存的操作，这些操作保证编译器不会跨其他易失性内在函数对它们进行重新排序。请参阅[ &lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt; ] 上的LLVM文档。</target>
        </trans-unit>
        <trans-unit id="dae64c2954322dc51425cf56ba3a3099f9cd4814" translate="yes" xml:space="preserve">
          <source>The volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [&lt;a href=&quot;https://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt;].</source>
          <target state="translated">易失性内在函数提供旨在作用于I / O内存的操作，这些操作保证编译器不会在其他易失性内在函数之间对它们进行重新排序。请参阅[ &lt;a href=&quot;https://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt; ]上的LLVM文档。</target>
        </trans-unit>
        <trans-unit id="3879e8ab569a056c97968189092bda667116aee8" translate="yes" xml:space="preserve">
          <source>The volatile parameter is set to &lt;code&gt;true&lt;/code&gt;, so it will not be optimized out unless size is equal to zero.</source>
          <target state="translated">volatile参数设置为 &lt;code&gt;true&lt;/code&gt; ，因此除非大小等于零，否则不会对其进行优化。</target>
        </trans-unit>
        <trans-unit id="545e192087f2dee8a1244b50285f56354faded13" translate="yes" xml:space="preserve">
          <source>The warning suggests that we use &lt;code&gt;_i&lt;/code&gt; as a name instead: the underscore indicates that we intend for this variable to be unused. We can automatically apply that suggestion using the &lt;code&gt;rustfix&lt;/code&gt; tool by running the command &lt;code&gt;cargo fix&lt;/code&gt;:</source>
          <target state="translated">该警告表明我们改为使用 &lt;code&gt;_i&lt;/code&gt; 作为名称：下划线表示我们打算使该变量不使用。我们可以通过运行command &lt;code&gt;cargo fix&lt;/code&gt; 命令，使用 &lt;code&gt;rustfix&lt;/code&gt; 工具自动应用该建议：</target>
        </trans-unit>
        <trans-unit id="71e5980a6bfd716abaaef858ffaa58512cff6b9e" translate="yes" xml:space="preserve">
          <source>The warning we get is this:</source>
          <target state="translated">我们得到的警告是这样的。</target>
        </trans-unit>
        <trans-unit id="01d3cf24ed7ac31e045df84ed43b543301d5071c" translate="yes" xml:space="preserve">
          <source>The way in which you need to specify lifetime parameters depends on what your function is doing. For example, if we changed the implementation of the &lt;code&gt;longest&lt;/code&gt; function to always return the first parameter rather than the longest string slice, we wouldn&amp;rsquo;t need to specify a lifetime on the &lt;code&gt;y&lt;/code&gt; parameter. The following code will compile:</source>
          <target state="translated">您需要指定生存期参数的方式取决于函数的功能。例如，如果我们将 &lt;code&gt;longest&lt;/code&gt; 函数的实现更改为始终返回第一个参数而不是最长字符串切片，则不需要在 &lt;code&gt;y&lt;/code&gt; 参数上指定生存期。以下代码将编译：</target>
        </trans-unit>
        <trans-unit id="5b549318fc3f4ca028012969aeab8043ad858528" translate="yes" xml:space="preserve">
          <source>The way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default. Items in a parent module can&amp;rsquo;t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. The reason is that child modules wrap and hide their implementation details, but the child modules can see the context in which they&amp;rsquo;re defined. To continue with the restaurant metaphor, think of the privacy rules as being like the back office of a restaurant: what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant in which they operate.</source>
          <target state="translated">Rust中隐私的工作方式是默认情况下所有项目（函数，方法，结构，枚举，模块和常量）都是私有的。父模块中的项目不能使用子模块中的私有项目，但是子模块中的项目可以使用其祖先模块中的项目。原因是子模块包装和隐藏了它们的实现细节，但是子模块可以看到定义它们的上下文。要继续使用餐厅的隐喻，可以将隐私规则视为餐厅的后台办公室：餐厅客户对餐厅的隐私是私密的，但是办公室经理可以在他们经营的餐厅中看到并做所有事情。</target>
        </trans-unit>
        <trans-unit id="c954766baf952dffb19514bc82ccc04508ad4747" translate="yes" xml:space="preserve">
          <source>The way to define helper attributes is to put an &lt;code&gt;attributes&lt;/code&gt; key in the &lt;code&gt;proc_macro_derive&lt;/code&gt; macro with a comma separated list of identifiers that are the names of the helper attributes.</source>
          <target state="translated">定义帮助程序属性的方法是将 &lt;code&gt;attributes&lt;/code&gt; 键放在 &lt;code&gt;proc_macro_derive&lt;/code&gt; 宏中，并用逗号分隔的标识符列表作为帮助程序属性的名称。</target>
        </trans-unit>
        <trans-unit id="b4ad5969b00a7de4e50dcfbec4f420300a121d22" translate="yes" xml:space="preserve">
          <source>The way to demonstrate this behavior is by running the program with &lt;code&gt;&amp;gt;&lt;/code&gt; and the filename, &lt;em&gt;output.txt&lt;/em&gt;, that we want to redirect the standard output stream to. We won&amp;rsquo;t pass any arguments, which should cause an error:</source>
          <target state="translated">演示此行为的方法是使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 和文件名&lt;em&gt;output.txt&lt;/em&gt;运行程序，我们要将标准输出流重定向到该文件名。我们不会传递任何参数，这会导致错误：</target>
        </trans-unit>
        <trans-unit id="4860fccc5b2b1b15ffbccd4a99af016a4e435d30" translate="yes" xml:space="preserve">
          <source>The wildcard pattern is always irrefutable.</source>
          <target state="translated">通配符模式总是无可辩驳的。</target>
        </trans-unit>
        <trans-unit id="6ed876d97357afb4218b62acc26e1fb7fcb7f367" translate="yes" xml:space="preserve">
          <source>The workspace has one &lt;em&gt;target&lt;/em&gt; directory at the top level for the compiled artifacts to be placed into; the &lt;code&gt;adder&lt;/code&gt; crate doesn&amp;rsquo;t have its own &lt;em&gt;target&lt;/em&gt; directory. Even if we were to run &lt;code&gt;cargo build&lt;/code&gt; from inside the &lt;em&gt;adder&lt;/em&gt; directory, the compiled artifacts would still end up in &lt;em&gt;add/target&lt;/em&gt; rather than &lt;em&gt;add/adder/target&lt;/em&gt;. Cargo structures the &lt;em&gt;target&lt;/em&gt; directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own &lt;em&gt;target&lt;/em&gt; directory, each crate would have to recompile each of the other crates in the workspace to have the artifacts in its own &lt;em&gt;target&lt;/em&gt; directory. By sharing one &lt;em&gt;target&lt;/em&gt; directory, the crates can avoid unnecessary rebuilding.</source>
          <target state="translated">工作空间在顶层有一个&lt;em&gt;目标&lt;/em&gt;目录，用于放置编译后的工件。在 &lt;code&gt;adder&lt;/code&gt; 箱没有自己的&lt;em&gt;目标&lt;/em&gt;目录。即使我们要在&lt;em&gt;adder&lt;/em&gt;目录中运行 &lt;code&gt;cargo build&lt;/code&gt; ，编译后的工件仍将以&lt;em&gt;add / target&lt;/em&gt;而不是&lt;em&gt;add / adder / target结束&lt;/em&gt;。 Cargo 像这样在工作区中构造&lt;em&gt;目标&lt;/em&gt;目录，因为工作区中的板条箱相互依赖。如果每个板条箱都有其自己的&lt;em&gt;目标&lt;/em&gt;目录，则每个板条箱都必须重新编译工作空间中的其他每个板条箱，以使工件具有自己的工件&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;目标&lt;/em&gt;目录。通过共享一个&lt;em&gt;目标&lt;/em&gt;目录，板条箱可以避免不必要的重建。</target>
        </trans-unit>
        <trans-unit id="94338f88d478ec6b62411179604be0f6a0e553b2" translate="yes" xml:space="preserve">
          <source>The workspace has one &lt;em&gt;target&lt;/em&gt; directory at the top level for the compiled artifacts to be placed into; the &lt;code&gt;adder&lt;/code&gt; package doesn&amp;rsquo;t have its own &lt;em&gt;target&lt;/em&gt; directory. Even if we were to run &lt;code&gt;cargo build&lt;/code&gt; from inside the &lt;em&gt;adder&lt;/em&gt; directory, the compiled artifacts would still end up in &lt;em&gt;add/target&lt;/em&gt; rather than &lt;em&gt;add/adder/target&lt;/em&gt;. Cargo structures the &lt;em&gt;target&lt;/em&gt; directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own &lt;em&gt;target&lt;/em&gt; directory, each crate would have to recompile each of the other crates in the workspace to have the artifacts in its own &lt;em&gt;target&lt;/em&gt; directory. By sharing one &lt;em&gt;target&lt;/em&gt; directory, the crates can avoid unnecessary rebuilding.</source>
          <target state="translated">工作空间在顶层有一个&lt;em&gt;目标&lt;/em&gt;目录，用于放置编译后的工件。该 &lt;code&gt;adder&lt;/code&gt; 包没有自己的&lt;em&gt;目标&lt;/em&gt;目录。即使我们要在&lt;em&gt;adder&lt;/em&gt;目录中运行 &lt;code&gt;cargo build&lt;/code&gt; ，编译后的工件仍将以&lt;em&gt;add / target&lt;/em&gt;而不是&lt;em&gt;add / adder / target结束&lt;/em&gt;。 Cargo像这样在工作区中构造&lt;em&gt;目标&lt;/em&gt;目录，因为工作区中的板条箱是要相互依赖的。如果每个板条箱都有其自己的&lt;em&gt;目标&lt;/em&gt;目录，则每个板条箱将必须重新编译工作空间中的每个其他板条箱以使工件具有自己的工件&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;目标&lt;/em&gt;目录。通过共享一个&lt;em&gt;目标&lt;/em&gt;目录，板条箱可以避免不必要的重建。</target>
        </trans-unit>
        <trans-unit id="77f8b60c8bbd1e207542248a0d2f457b8e7e406f" translate="yes" xml:space="preserve">
          <source>The worst case cost of &lt;code&gt;pop&lt;/code&gt; on a heap containing &lt;em&gt;n&lt;/em&gt; elements is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)).</source>
          <target state="translated">在包含&lt;em&gt;n个&lt;/em&gt;元素的堆上 &lt;code&gt;pop&lt;/code&gt; 的最坏情况是&lt;em&gt;O&lt;/em&gt;（log（&lt;em&gt;n&lt;/em&gt;））。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99d51b0abe084f304807f0bb44acfa16e7f4af5a" translate="yes" xml:space="preserve">
          <source>The worst case cost of &lt;code&gt;pop&lt;/code&gt; on a heap containing &lt;em&gt;n&lt;/em&gt; elements is O(log n).</source>
          <target state="translated">在包含&lt;em&gt;n个&lt;/em&gt;元素的堆上 &lt;code&gt;pop&lt;/code&gt; 的最坏情况是O（log n）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc0b397ce3728851f33d0ec0d540c025798521e0" translate="yes" xml:space="preserve">
          <source>The worst case cost of a &lt;em&gt;single&lt;/em&gt; call to &lt;code&gt;push&lt;/code&gt; is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</source>
          <target state="translated">&lt;em&gt;单次&lt;/em&gt; &lt;code&gt;push&lt;/code&gt; 请求的最坏情况成本为&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）。最坏的情况发生在容量用尽并需要调整大小时。调整大小成本已在之前的数字中摊销。</target>
        </trans-unit>
        <trans-unit id="238b65c05553bd00df49cce92fea6a1b783b67b3" translate="yes" xml:space="preserve">
          <source>The worst case cost of a &lt;em&gt;single&lt;/em&gt; call to &lt;code&gt;push&lt;/code&gt; is O(n). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</source>
          <target state="translated">&lt;em&gt;单次&lt;/em&gt; &lt;code&gt;push&lt;/code&gt; 请求的最坏情况成本为O（n）。最坏的情况发生在容量用尽并需要调整大小时。调整大小成本已在之前的数字中摊销。</target>
        </trans-unit>
        <trans-unit id="9abd2f24e6d1b46930e8a99311ffd002b596e31a" translate="yes" xml:space="preserve">
          <source>The writing portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;的写入部分应关闭。</target>
        </trans-unit>
        <trans-unit id="4a689baec3acd327f6907f5ce5547d1d13e010a8" translate="yes" xml:space="preserve">
          <source>Their definition should always match the ABI defined in &lt;code&gt;rustc::back::abi&lt;/code&gt;.</source>
          <target state="translated">它们的定义应始终与 &lt;code&gt;rustc::back::abi&lt;/code&gt; 定义的ABI相匹配。</target>
        </trans-unit>
        <trans-unit id="1e1df95ca1bc76e0d356b0c10d06f6035304f599" translate="yes" xml:space="preserve">
          <source>Their definition should always match the ABI defined in &lt;code&gt;rustc_middle::ty::layout&lt;/code&gt;.</source>
          <target state="translated">它们的定义应始终与 &lt;code&gt;rustc_middle::ty::layout&lt;/code&gt; 定义的ABI相匹配。</target>
        </trans-unit>
        <trans-unit id="534bcf9b4ee06ae0b390b746db849c9e3d0f83df" translate="yes" xml:space="preserve">
          <source>Then create a new directory, &lt;em&gt;src/bin&lt;/em&gt;, and move the binary crate rooted in &lt;em&gt;src/main.rs&lt;/em&gt; into &lt;em&gt;src/bin/main.rs&lt;/em&gt;. Doing so will make the library crate the primary crate in the &lt;em&gt;hello&lt;/em&gt; directory; we can still run the binary in &lt;em&gt;src/bin/main.rs&lt;/em&gt; using &lt;code&gt;cargo run&lt;/code&gt;. After moving the &lt;em&gt;main.rs&lt;/em&gt; file, edit it to bring the library crate in and bring &lt;code&gt;ThreadPool&lt;/code&gt; into scope by adding the following code to the top of &lt;em&gt;src/bin/main.rs&lt;/em&gt;:</source>
          <target state="translated">然后创建一个新目录&lt;em&gt;src / bin&lt;/em&gt;，并将以&lt;em&gt;src / main.rs&lt;/em&gt;为根的二进制文件箱移动到&lt;em&gt;src / bin / main.rs中&lt;/em&gt;。这样做将使库箱成为&lt;em&gt;hello&lt;/em&gt;目录中的主箱；我们仍然可以使用 &lt;code&gt;cargo run&lt;/code&gt; 在&lt;em&gt;src / bin / main.rs中&lt;/em&gt;运行二进制文件。移动&lt;em&gt;main.rs&lt;/em&gt;文件后，对其进行编辑以将库文件箱放入其中，并通过在&lt;em&gt;src / bin / main.rs&lt;/em&gt;顶部添加以下代码来将 &lt;code&gt;ThreadPool&lt;/code&gt; 纳入范围：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="848cf8d4f1542ccd5c9500b227f162479dfe2c8c" translate="yes" xml:space="preserve">
          <source>Then generate a new library crate named &lt;code&gt;add-one&lt;/code&gt;:</source>
          <target state="translated">然后生成一个名为 &lt;code&gt;add-one&lt;/code&gt; 的新库箱：</target>
        </trans-unit>
        <trans-unit id="02ec96ae1b226ff410efb69c0d4d60e58a7042ce" translate="yes" xml:space="preserve">
          <source>Then implementing the &lt;code&gt;OutlinePrint&lt;/code&gt; trait on &lt;code&gt;Point&lt;/code&gt; will compile successfully, and we can call &lt;code&gt;outline_print&lt;/code&gt; on a &lt;code&gt;Point&lt;/code&gt; instance to display it within an outline of asterisks.</source>
          <target state="translated">然后在 &lt;code&gt;Point&lt;/code&gt; 上实现 &lt;code&gt;OutlinePrint&lt;/code&gt; 特征将成功编译，我们可以在 &lt;code&gt;Point&lt;/code&gt; 实例上调用 &lt;code&gt;outline_print&lt;/code&gt; ，以在星号轮廓内显示它。</target>
        </trans-unit>
        <trans-unit id="3aac37973a618f0b45f35c262a8297327ce65a0e" translate="yes" xml:space="preserve">
          <source>Then install the language server support in your particular IDE; you&amp;rsquo;ll gain abilities such as autocompletion, jump to definition, and inline errors.</source>
          <target state="translated">然后在特定的IDE中安装语言服务器支持；您将获得自动补全，跳转到定义以及内联错误等功能。</target>
        </trans-unit>
        <trans-unit id="636019afbd1be275dc1f855f27602c31a7743704" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;cargo test&lt;/code&gt; again. The output now shows &lt;code&gt;exploration&lt;/code&gt; instead of &lt;code&gt;it_works&lt;/code&gt;:</source>
          <target state="translated">然后再次运行 &lt;code&gt;cargo test&lt;/code&gt; 。现在，输出显示 &lt;code&gt;exploration&lt;/code&gt; 而不是 &lt;code&gt;it_works&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7eae4a5123d629fb5914cfbce2d33e244889b442" translate="yes" xml:space="preserve">
          <source>Then the compiler applies the first rule, which specifies that each parameter gets its own lifetime. We&amp;rsquo;ll call it &lt;code&gt;'a&lt;/code&gt; as usual, so now the signature is this:</source>
          <target state="translated">然后，编译器将应用第一条规则，该规则指定每个参数都有其自己的生存期。我们将其称为 &lt;code&gt;'a&lt;/code&gt; &amp;rdquo;，因此现在的签名是：</target>
        </trans-unit>
        <trans-unit id="fe1bb69db1725d721fdb3af05034044cb61cb940" translate="yes" xml:space="preserve">
          <source>Then we add five new lines at the bottom that use the &lt;code&gt;Ordering&lt;/code&gt; type. The &lt;code&gt;cmp&lt;/code&gt; method compares two values and can be called on anything that can be compared. It takes a reference to whatever you want to compare with: here it&amp;rsquo;s comparing the &lt;code&gt;guess&lt;/code&gt; to the &lt;code&gt;secret_number&lt;/code&gt;. Then it returns a variant of the &lt;code&gt;Ordering&lt;/code&gt; enum we brought into scope with the &lt;code&gt;use&lt;/code&gt; statement. We use a &lt;a href=&quot;ch06-02-match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; expression to decide what to do next based on which variant of &lt;code&gt;Ordering&lt;/code&gt; was returned from the call to &lt;code&gt;cmp&lt;/code&gt; with the values in &lt;code&gt;guess&lt;/code&gt; and &lt;code&gt;secret_number&lt;/code&gt;.</source>
          <target state="translated">然后，我们在底部添加五行使用 &lt;code&gt;Ordering&lt;/code&gt; 类型的新行。该 &lt;code&gt;cmp&lt;/code&gt; 方法比较两个值，并且可以在任何可以比较被调用。它引用了您想与之进行比较的任何内容：在这里，它将 &lt;code&gt;guess&lt;/code&gt; 与 &lt;code&gt;secret_number&lt;/code&gt; 相比较。然后它返回我们在 &lt;code&gt;use&lt;/code&gt; 语句中纳入范围的 &lt;code&gt;Ordering&lt;/code&gt; 枚举的变体。我们使用&lt;a href=&quot;ch06-02-match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;表达式根据对 &lt;code&gt;cmp&lt;/code&gt; 的调用返回的 &lt;code&gt;Ordering&lt;/code&gt; 的哪个变体（带有 &lt;code&gt;guess&lt;/code&gt; 和 &lt;code&gt;secret_number&lt;/code&gt; 中的值）来决定下一步要做什么。</target>
        </trans-unit>
        <trans-unit id="42504942265ee7c7c73ee70d30a7653d906cc136" translate="yes" xml:space="preserve">
          <source>Then we create a &lt;em&gt;src/front_of_house&lt;/em&gt; directory and a file &lt;em&gt;src/front_of_house/hosting.rs&lt;/em&gt; to contain the definitions made in the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="translated">然后，我们创建一个&lt;em&gt;src / front_of_house&lt;/em&gt;目录和一个文件&lt;em&gt;src / front_of_house / hosting.rs，&lt;/em&gt;以包含在 &lt;code&gt;hosting&lt;/code&gt; 模块中进行的定义：</target>
        </trans-unit>
        <trans-unit id="8c054131a62b68de933e0bf587b858ee6793392b" translate="yes" xml:space="preserve">
          <source>Then we create a new &lt;code&gt;String&lt;/code&gt; in variable &lt;code&gt;s&lt;/code&gt; and call the &lt;code&gt;read_to_string&lt;/code&gt; method on the file handle in &lt;code&gt;f&lt;/code&gt; to read the contents of the file into &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;read_to_string&lt;/code&gt; method also returns a &lt;code&gt;Result&lt;/code&gt; because it might fail, even though &lt;code&gt;File::open&lt;/code&gt; succeeded. So we need another &lt;code&gt;match&lt;/code&gt; to handle that &lt;code&gt;Result&lt;/code&gt;: if &lt;code&gt;read_to_string&lt;/code&gt; succeeds, then our function has succeeded, and we return the username from the file that&amp;rsquo;s now in &lt;code&gt;s&lt;/code&gt; wrapped in an &lt;code&gt;Ok&lt;/code&gt;. If &lt;code&gt;read_to_string&lt;/code&gt; fails, we return the error value in the same way that we returned the error value in the &lt;code&gt;match&lt;/code&gt; that handled the return value of &lt;code&gt;File::open&lt;/code&gt;. However, we don&amp;rsquo;t need to explicitly say &lt;code&gt;return&lt;/code&gt;, because this is the last expression in the function.</source>
          <target state="translated">然后，在变量 &lt;code&gt;s&lt;/code&gt; 中创建一个新的 &lt;code&gt;String&lt;/code&gt; ，并在 &lt;code&gt;f&lt;/code&gt; 中的文件句柄上调用 &lt;code&gt;read_to_string&lt;/code&gt; 方法，以将文件内容读入 &lt;code&gt;s&lt;/code&gt; 。该 &lt;code&gt;read_to_string&lt;/code&gt; 方法也返回一个 &lt;code&gt;Result&lt;/code&gt; ，因为它可能会失败，即使 &lt;code&gt;File::open&lt;/code&gt; 成功。因此，我们需要另一 &lt;code&gt;match&lt;/code&gt; 来处理 &lt;code&gt;Result&lt;/code&gt; ：如果 &lt;code&gt;read_to_string&lt;/code&gt; 成功，那么我们的功能已经成功，并且我们从现在在返回文件中的用户名 &lt;code&gt;s&lt;/code&gt; 包裹在一个 &lt;code&gt;Ok&lt;/code&gt; 。如果 &lt;code&gt;read_to_string&lt;/code&gt; 失败，我们以 &lt;code&gt;match&lt;/code&gt; 处理 &lt;code&gt;File::open&lt;/code&gt; 的返回值的匹配中返回错误值的方式相同的方式返回错误值。但是，我们不需要明确地说 &lt;code&gt;return&lt;/code&gt; ，因为这是函数中的最后一个表达式。</target>
        </trans-unit>
        <trans-unit id="deae9012508053fe94f96907583eae7e4c8a687f" translate="yes" xml:space="preserve">
          <source>Then we implement an associated function named &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;Guess&lt;/code&gt; that creates instances of &lt;code&gt;Guess&lt;/code&gt; values. The &lt;code&gt;new&lt;/code&gt; function is defined to have one parameter named &lt;code&gt;value&lt;/code&gt; of type &lt;code&gt;i32&lt;/code&gt; and to return a &lt;code&gt;Guess&lt;/code&gt;. The code in the body of the &lt;code&gt;new&lt;/code&gt; function tests &lt;code&gt;value&lt;/code&gt; to make sure it&amp;rsquo;s between 1 and 100. If &lt;code&gt;value&lt;/code&gt; doesn&amp;rsquo;t pass this test, we make a &lt;code&gt;panic!&lt;/code&gt; call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a &lt;code&gt;Guess&lt;/code&gt; with a &lt;code&gt;value&lt;/code&gt; outside this range would violate the contract that &lt;code&gt;Guess::new&lt;/code&gt; is relying on. The conditions in which &lt;code&gt;Guess::new&lt;/code&gt; might panic should be discussed in its public-facing API documentation; we&amp;rsquo;ll cover documentation conventions indicating the possibility of a &lt;code&gt;panic!&lt;/code&gt; in the API documentation that you create in Chapter 14. If &lt;code&gt;value&lt;/code&gt; does pass the test, we create a new &lt;code&gt;Guess&lt;/code&gt; with its &lt;code&gt;value&lt;/code&gt; field set to the &lt;code&gt;value&lt;/code&gt; parameter and return the &lt;code&gt;Guess&lt;/code&gt;.</source>
          <target state="translated">然后，我们在 &lt;code&gt;Guess&lt;/code&gt; 上实现一个名为 &lt;code&gt;new&lt;/code&gt; 的关联函数，该函数创建 &lt;code&gt;Guess&lt;/code&gt; 值实例。该 &lt;code&gt;new&lt;/code&gt; 功能被定义为有一个名为参数 &lt;code&gt;value&lt;/code&gt; 类型的 &lt;code&gt;i32&lt;/code&gt; ，并返回一个 &lt;code&gt;Guess&lt;/code&gt; 。 &lt;code&gt;new&lt;/code&gt; 函数主体中的代码将测试 &lt;code&gt;value&lt;/code&gt; 以确保其值在1到100之间。如果 &lt;code&gt;value&lt;/code&gt; 未通过此测试，我们将感到 &lt;code&gt;panic!&lt;/code&gt; 调用，这将警告正在编写调用代码的程序员他们需要修复的错误，因为创建带有 &lt;code&gt;value&lt;/code&gt; 的 &lt;code&gt;Guess&lt;/code&gt; 超出此范围将违反 &lt;code&gt;Guess::new&lt;/code&gt; 所依赖的合同。在何种条件下 &lt;code&gt;Guess::new&lt;/code&gt; 可能出现紧急情况应在其面向公众的API文档中讨论; 我们将介绍表明可能发生 &lt;code&gt;panic!&lt;/code&gt; 文档约定！在您在第14章中创建的API文档中。如果 &lt;code&gt;value&lt;/code&gt; 通过测试，我们将创建一个新的 &lt;code&gt;Guess&lt;/code&gt; ，并将其 &lt;code&gt;value&lt;/code&gt; 字段设置为 &lt;code&gt;value&lt;/code&gt; 参数，并返回 &lt;code&gt;Guess&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06b6b70a87228a4df8ed0e498c6c809f243dabd9" translate="yes" xml:space="preserve">
          <source>Then we return two mutable slices in a tuple: one from the start of the original slice to the &lt;code&gt;mid&lt;/code&gt; index and another from &lt;code&gt;mid&lt;/code&gt; to the end of the slice.</source>
          <target state="translated">然后，我们在一个元组中返回两个可变切片：一个从原始切片的开始到 &lt;code&gt;mid&lt;/code&gt; 索引，另一个从切片的 &lt;code&gt;mid&lt;/code&gt; 到结尾。</target>
        </trans-unit>
        <trans-unit id="d29498b87e97b7beddcde1cb5378fcb2cbabe3a8" translate="yes" xml:space="preserve">
          <source>Then you must define an implementation for &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;. You may find it useful to use &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt; on your type's fields.</source>
          <target state="translated">然后，您必须为&lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;/a&gt;定义一个实现。您可能会发现在类型的字段上使用&lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;/a&gt;很有用。</target>
        </trans-unit>
        <trans-unit id="884190657324310c04e2504f5fc0e76845d895ae" translate="yes" xml:space="preserve">
          <source>Then you must define an implementation for &lt;code&gt;cmp()&lt;/code&gt;. You may find it useful to use &lt;code&gt;cmp()&lt;/code&gt; on your type's fields.</source>
          <target state="translated">然后，您必须为 &lt;code&gt;cmp()&lt;/code&gt; 定义一个实现。您可能会发现在类型的字段上使用 &lt;code&gt;cmp()&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="0d177ce772cf21906084a9438690b47406434422" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll learn how to use &lt;em&gt;traits&lt;/em&gt; to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to only those types that have a particular behavior, as opposed to just any type.</source>
          <target state="translated">然后，您将学习如何使用&lt;em&gt;特征&lt;/em&gt;以一般方式定义行为。您可以将特征与泛型类型结合使用，以将泛型类型限制为仅具有特定行为的那些类型，而不是任何类型。</target>
        </trans-unit>
        <trans-unit id="ddeec83a6e1ebd77d0b40c2a12564ec960334a02" translate="yes" xml:space="preserve">
          <source>Then, for each candidate type &lt;code&gt;T&lt;/code&gt;, search for a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; method with a receiver of that type in the following places:</source>
          <target state="translated">然后，对于每个候选类型 &lt;code&gt;T&lt;/code&gt; ，在以下位置使用该类型的接收器搜索&lt;a href=&quot;../visibility-and-privacy&quot;&gt;可见&lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="c7f32ff9ae959e326529e5b742ae1c333e7b2254" translate="yes" xml:space="preserve">
          <source>Then, in your new &lt;em&gt;variables&lt;/em&gt; directory, open &lt;em&gt;src/main.rs&lt;/em&gt; and replace its code with the following code that won&amp;rsquo;t compile just yet:</source>
          <target state="translated">然后，在新的&lt;em&gt;变量&lt;/em&gt;目录中，打开&lt;em&gt;src / main.rs&lt;/em&gt;并将其代码替换为尚未编译的以下代码：</target>
        </trans-unit>
        <trans-unit id="0c8f840e153942ef31581018e9e810864accdec7" translate="yes" xml:space="preserve">
          <source>Then, to bring &lt;code&gt;rand&lt;/code&gt; definitions into the scope of our package, we added a &lt;code&gt;use&lt;/code&gt; line starting with the name of the crate, &lt;code&gt;rand&lt;/code&gt;, and listed the items we wanted to bring into scope. Recall that in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;Generating a Random Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we brought the &lt;code&gt;Rng&lt;/code&gt; trait into scope and called the &lt;code&gt;rand::thread_rng&lt;/code&gt; function:</source>
          <target state="translated">然后，为了将 &lt;code&gt;rand&lt;/code&gt; 定义带入包的范围，我们添加了一个 &lt;code&gt;use&lt;/code&gt; 行，该行以crate的名称 &lt;code&gt;rand&lt;/code&gt; 开头，并列出了我们想要纳入范围的项目。回想一下，在第2章的&lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;生成随机数&amp;rdquo;&lt;/a&gt;部分中，我们将 &lt;code&gt;Rng&lt;/code&gt; 特征引入了范围，并调用了 &lt;code&gt;rand::thread_rng&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="cbbc8078ba28a9ecb4224d46afd42558773fa640" translate="yes" xml:space="preserve">
          <source>Then, to bring &lt;code&gt;rand&lt;/code&gt; definitions into the scope of our package, we added a &lt;code&gt;use&lt;/code&gt; line starting with the name of the package, &lt;code&gt;rand&lt;/code&gt;, and listed the items we wanted to bring into scope. Recall that in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;Generating a Random Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we brought the &lt;code&gt;Rng&lt;/code&gt; trait into scope and called the &lt;code&gt;rand::thread_rng&lt;/code&gt; function:</source>
          <target state="translated">然后，为了将 &lt;code&gt;rand&lt;/code&gt; 定义带入我们的包范围，我们添加了一个 &lt;code&gt;use&lt;/code&gt; 行，该行以包的名称 &lt;code&gt;rand&lt;/code&gt; 开头，并列出了我们想要纳入范围的项目。回想一下，在第2章的&lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;生成随机数&amp;rdquo;&lt;/a&gt;部分中，我们将 &lt;code&gt;Rng&lt;/code&gt; 特性引入了范围，并调用了 &lt;code&gt;rand::thread_rng&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="ea0671790854fadbc007a7d3ab3c99a7a0c53f74" translate="yes" xml:space="preserve">
          <source>Theoretically, this code should compile. Unfortunately, the Rust compiler isn&amp;rsquo;t perfect yet, and we get this error:</source>
          <target state="translated">从理论上讲，此代码应编译。不幸的是，Rust编译器还不是完美的，我们得到这个错误：</target>
        </trans-unit>
        <trans-unit id="7bb0fb711ce84d52df9718e0b2a2ec2dabc6a07f" translate="yes" xml:space="preserve">
          <source>There are a couple of solutions for this.</source>
          <target state="translated">对此,有几种解决办法。</target>
        </trans-unit>
        <trans-unit id="530488aa6f064fc1ecb7dc7a5a0bf4b2dc63964c" translate="yes" xml:space="preserve">
          <source>There are a few things that &lt;code&gt;transmute&lt;/code&gt; is really useful for.</source>
          <target state="translated">有几件事情， &lt;code&gt;transmute&lt;/code&gt; 为真正有用的。</target>
        </trans-unit>
        <trans-unit id="e38257a0874550d292627aecb2605763613ccaf1" translate="yes" xml:space="preserve">
          <source>There are a handful of shortcuts provided to make writing constructors more convenient, most common of which is the Field Init shorthand. When there is a variable and a field of the same name, the assignment can be simplified from &lt;code&gt;field: field&lt;/code&gt; into simply &lt;code&gt;field&lt;/code&gt;. The following example of a hypothetical constructor demonstrates this:</source>
          <target state="translated">提供了一些快捷方式，使编写构造函数更加方便，其中最常见的是Field Init的简写形式。当存在一个变量和一个同名字段时，可以将分配从 &lt;code&gt;field: field&lt;/code&gt; 简化为 &lt;code&gt;field&lt;/code&gt; 。假设的构造函数的以下示例说明了这一点：</target>
        </trans-unit>
        <trans-unit id="63a966968ec2346aede6a0d18395aa406c237072" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;a href=&quot;#functions-1&quot;&gt;functions&lt;/a&gt; that offer access to various features. For example, we can use three of these functions to copy everything from standard input to standard output:</source>
          <target state="translated">有许多&lt;a href=&quot;#functions-1&quot;&gt;功能&lt;/a&gt;可以访问各种功能。例如，我们可以使用以下三个函数来复制从标准输入到标准输出的所有内容：</target>
        </trans-unit>
        <trans-unit id="1f79d0ffb253cf5d15cccef1c760f3edf4c3cd7b" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;code&gt;debug_*&lt;/code&gt; methods on &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; to help you with manual implementations, such as &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;debug_struct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;上有许多 &lt;code&gt;debug_*&lt;/code&gt; 方法可帮助您实现手动实现，例如&lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt; &lt;code&gt;debug_struct&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e1d6f0ae7b1514d15119ee9f085506bcbaba7ce" translate="yes" xml:space="preserve">
          <source>There are a number of helper methods on the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; struct to help you with manual implementations, such as &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;debug_struct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;结构上有许多帮助程序方法可以帮助您实现手动实现，例如&lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt; &lt;code&gt;debug_struct&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="087920b8740a66ec282180bff3885f708e5bb842" translate="yes" xml:space="preserve">
          <source>There are a number of related macros in the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; family. The ones that are currently implemented are:</source>
          <target state="translated">&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;中有许多相关的宏！家庭。当前实现的是：</target>
        </trans-unit>
        <trans-unit id="28043d56de08a63f7e30e165bfcf6d512b961039" translate="yes" xml:space="preserve">
          <source>There are also some platform-specific ABI strings:</source>
          <target state="translated">还有一些平台特有的ABI字符串。</target>
        </trans-unit>
        <trans-unit id="4e3263bd4c02d9329fee29d313cf8ea903653894" translate="yes" xml:space="preserve">
          <source>There are both a positive and negative trait implementation for the same type.</source>
          <target state="translated">同一种类型的性状有正性和负性两种实现方式。</target>
        </trans-unit>
        <trans-unit id="9dfc0ac14db9531a0dcf3d9f3c7feabed396e9c2" translate="yes" xml:space="preserve">
          <source>There are conflicting trait implementations for the same type.</source>
          <target state="translated">同一类型的性状实现有冲突。</target>
        </trans-unit>
        <trans-unit id="cb600a231699778e7c442e8d1b0c5af1c6ce3e98" translate="yes" xml:space="preserve">
          <source>There are conflicting trait implementations for the same type. Example of erroneous code:</source>
          <target state="translated">同一类型的性状实现有冲突。错误代码的例子。</target>
        </trans-unit>
        <trans-unit id="c7d32d1dc6c93776049af2c0d8da18ad1a5c107b" translate="yes" xml:space="preserve">
          <source>There are insufficient permissions to access the current directory.</source>
          <target state="translated">当前目录的访问权限不足。</target>
        </trans-unit>
        <trans-unit id="320a725df7a67ccef8f0da8b29889ac40ad1812c" translate="yes" xml:space="preserve">
          <source>There are limitations when matching on non-exhaustive types outside of the defining crate:</source>
          <target state="translated">在定义箱外的非穷举类型上进行匹配时,会有一些限制。</target>
        </trans-unit>
        <trans-unit id="c57d9d7a8463095f936949e3bd422fd7ce763db3" translate="yes" xml:space="preserve">
          <source>There are multiple trade-offs to consider in addition to the prevention of bugs. For example, in cases where you&amp;rsquo;re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances. With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.</source>
          <target state="translated">除了防止错误外，还需要考虑多个折衷方案。例如，在使用大型数据结构的情况下，对实例进行原地更改可能比复制并返回新分配的实例要快。对于较小的数据结构，创建新实例并以更具功能性的编程风格进行编写可能更容易考虑，因此，降低性能可能是获得这种清晰度的一个值得付出的代价。</target>
        </trans-unit>
        <trans-unit id="d53022046c1585c76ce2c3d1de0757bc5d58a5d7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to create a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; from a string literal:</source>
          <target state="translated">有多种方法可以创建一个新的&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;从一个字符串：</target>
        </trans-unit>
        <trans-unit id="b89e39f486cb11ae236a0c1ba092d84b1be61d5a" translate="yes" xml:space="preserve">
          <source>There are multiple ways we could change how our web server works to avoid having more requests back up behind a slow request; the one we&amp;rsquo;ll implement is a thread pool.</source>
          <target state="translated">我们可以通过多种方式来更改Web服务器的工作方式，以避免在缓慢的请求后再备份更多的请求。我们将实现的是一个线程池。</target>
        </trans-unit>
        <trans-unit id="cbbb8fb2683dd85eb0ca22283c9bb44fdd37598e" translate="yes" xml:space="preserve">
          <source>There are no function calls, macros, or even &lt;code&gt;let&lt;/code&gt; statements in the &lt;code&gt;five&lt;/code&gt; function&amp;mdash;just the number &lt;code&gt;5&lt;/code&gt; by itself. That&amp;rsquo;s a perfectly valid function in Rust. Note that the function&amp;rsquo;s return type is specified too, as &lt;code&gt;-&amp;gt; i32&lt;/code&gt;. Try running this code; the output should look like this:</source>
          <target state="translated">这 &lt;code&gt;five&lt;/code&gt; 函数中没有函数调用，宏，甚至没有 &lt;code&gt;let&lt;/code&gt; 语句-仅是数字 &lt;code&gt;5&lt;/code&gt; 。在Rust中，这是一个非常有效的函数。注意，函数的返回类型也被指定为 &lt;code&gt;-&amp;gt; i32&lt;/code&gt; 。尝试运行此代码；输出应如下所示：</target>
        </trans-unit>
        <trans-unit id="e3048305fc74fc67f0b28e1af09fa647633b200c" translate="yes" xml:space="preserve">
          <source>There are no generic type parameters.</source>
          <target state="translated">没有通用类型参数。</target>
        </trans-unit>
        <trans-unit id="6dc334d98456ba931a1cb0e3e3cebe2b287fda18" translate="yes" xml:space="preserve">
          <source>There are no guarantees of data layout made by this representation.</source>
          <target state="translated">这种表示方法对数据布局没有任何保证。</target>
        </trans-unit>
        <trans-unit id="73292d3af30172448139b6d5386689eb5562d30e" translate="yes" xml:space="preserve">
          <source>There are no guarantees whatsoever that offsetting the pointer will not overflow or go beyond the allocation that the pointer points into. It is up to the caller to ensure that the returned offset is correct in all terms other than alignment.</source>
          <target state="translated">我们不能保证偏移指针不会溢出或超出指针指向的分配。调用者要确保返回的偏移量在除对齐之外的所有方面都是正确的。</target>
        </trans-unit>
        <trans-unit id="a86100f636fbb472fb5b1863356f0448a9ae85a5" translate="yes" xml:space="preserve">
          <source>There are no guarantees whatsover that offsetting the pointer will not overflow or go beyond the allocation that the pointer points into. It is up to the caller to ensure that the returned offset is correct in all terms other than alignment.</source>
          <target state="translated">我们不能保证偏移指针不会溢出或超出指针指向的分配。调用者要保证返回的偏移量除了对齐以外的所有方面都是正确的。</target>
        </trans-unit>
        <trans-unit id="19e4b768de5872c5fc351b9acc570966e33874d6" translate="yes" xml:space="preserve">
          <source>There are several functions and structs in this module that have a counterpart ending in &lt;code&gt;os&lt;/code&gt;. Those ending in &lt;code&gt;os&lt;/code&gt; will return an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and those without will be returning a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此模块中有几个函数和结构，其对应的结尾是 &lt;code&gt;os&lt;/code&gt; 。那些以 &lt;code&gt;os&lt;/code&gt; 结尾的将返回&lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;，而没有os的将返回&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc0876b472387aa80fcef964fda60c94ca27eb85" translate="yes" xml:space="preserve">
          <source>There are several functions and structs in this module that have a counterpart ending in &lt;code&gt;os&lt;/code&gt;. Those ending in &lt;code&gt;os&lt;/code&gt; will return an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and those without will return a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此模块中有几个函数和结构，其对应的结尾是 &lt;code&gt;os&lt;/code&gt; 。那些以 &lt;code&gt;os&lt;/code&gt; 结尾的将返回&lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;，而没有os的将返回&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="171ee597fab4c6d0bdea510dd3f56d6a9c12c0b6" translate="yes" xml:space="preserve">
          <source>There are several implementations of common traits for slices. Some examples include:</source>
          <target state="translated">片子的常见特征有几种实现方式。一些例子包括:</target>
        </trans-unit>
        <trans-unit id="0f5d6b4dc4e0f0d18f10b896c43b04863d873b17" translate="yes" xml:space="preserve">
          <source>There are several kinds of items:</source>
          <target state="translated">有几种项目。</target>
        </trans-unit>
        <trans-unit id="5ab16cf7d574dfc1dbe1b281f7a85326a916ba94" translate="yes" xml:space="preserve">
          <source>There are several structs that are useful for slices, such as &lt;a href=&quot;struct.iter&quot;&gt;&lt;code&gt;Iter&lt;/code&gt;&lt;/a&gt;, which represents iteration over a slice.</source>
          <target state="translated">有几种对切片有用的结构，例如&lt;a href=&quot;struct.iter&quot;&gt; &lt;code&gt;Iter&lt;/code&gt; &lt;/a&gt;，它表示切片上的迭代。</target>
        </trans-unit>
        <trans-unit id="567ae72d32f4d2be3989eaf8a9904e62f889b537" translate="yes" xml:space="preserve">
          <source>There are six &lt;code&gt;char&lt;/code&gt; values here, but the fourth and sixth are not letters: they&amp;rsquo;re diacritics that don&amp;rsquo;t make sense on their own. Finally, if we look at them as grapheme clusters, we&amp;rsquo;d get what a person would call the four letters that make up the Hindi word:</source>
          <target state="translated">这里有六个 &lt;code&gt;char&lt;/code&gt; 值，但是第四个和第六个不是字母：它们是变音符号，它们自己没有意义。最后，如果我们将它们视为字素簇，我们将得到一个人所说的构成印地语单词的四个字母：</target>
        </trans-unit>
        <trans-unit id="6ce75e9d71dbebf75ae807b3a16056d1528fd37b" translate="yes" xml:space="preserve">
          <source>There are some known bugs that trigger this message.</source>
          <target state="translated">有一些已知的错误会触发此消息。</target>
        </trans-unit>
        <trans-unit id="926439ef5401fe133e30f193394b46730a6ce040" translate="yes" xml:space="preserve">
          <source>There are some strange edge cases with &lt;code&gt;macro_rules!&lt;/code&gt;. In the future, Rust will have a second kind of declarative macro that will work in a similar fashion but fix some of these edge cases. After that update, &lt;code&gt;macro_rules!&lt;/code&gt; will be effectively deprecated. With this in mind, as well as the fact that most Rust programmers will &lt;em&gt;use&lt;/em&gt; macros more than &lt;em&gt;write&lt;/em&gt; macros, we won&amp;rsquo;t discuss &lt;code&gt;macro_rules!&lt;/code&gt; any further. To learn more about how to write macros, consult the online documentation or other resources, such as &lt;a href=&quot;https://danielkeep.github.io/tlborm/book/index.html&quot;&gt;&amp;ldquo;The Little Book of Rust Macros&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;macro_rules!&lt;/code&gt; 有一些奇怪的情况！。将来，Rust将具有第二种声明性宏，该宏将以类似的方式工作，但会修复其中一些极端情况。更新之后，请执行 &lt;code&gt;macro_rules!&lt;/code&gt; 将被弃用。考虑到这一点，以及大多数Rust程序员&lt;em&gt;使用&lt;/em&gt;宏而不是&lt;em&gt;编写&lt;/em&gt;宏的事实，我们不会讨论 &lt;code&gt;macro_rules!&lt;/code&gt; 再进一步。要了解有关如何编写宏的更多信息，请查阅在线文档或其他资源，例如&lt;a href=&quot;https://danielkeep.github.io/tlborm/book/index.html&quot;&gt;&amp;ldquo;锈宏小书&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="720348f040959c3669acec057ca2d47ad7fb3d69" translate="yes" xml:space="preserve">
          <source>There are three ABI strings which are cross-platform, and which all compilers are guaranteed to support:</source>
          <target state="translated">有三个ABI字符串是跨平台的,保证所有编译器都支持。</target>
        </trans-unit>
        <trans-unit id="0142bb3f41cab04708310e3fe823a323c32ee0b3" translate="yes" xml:space="preserve">
          <source>There are three common methods which can create iterators from a collection:</source>
          <target state="translated">有三种常见的方法可以从一个集合中创建迭代器。</target>
        </trans-unit>
        <trans-unit id="987579e087a6ff5bbf6e70931c97c8842a5d0e0c" translate="yes" xml:space="preserve">
          <source>There are three possible ways to specify the desired &lt;code&gt;precision&lt;/code&gt;:</source>
          <target state="translated">有三种方法可以指定所需的 &lt;code&gt;precision&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3a65e426e444ff8c29bebad4488c8514ade91574" translate="yes" xml:space="preserve">
          <source>There are three ways to use the inline attribute:</source>
          <target state="translated">内联属性有三种使用方法。</target>
        </trans-unit>
        <trans-unit id="481486972e8a90ddff463b54cf1c4f208b0477e6" translate="yes" xml:space="preserve">
          <source>There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &lt;code&gt;&amp;amp;self&lt;/code&gt; and &lt;code&gt;announcement&lt;/code&gt; their own lifetimes. Then, because one of the parameters is &lt;code&gt;&amp;amp;self&lt;/code&gt;, the return type gets the lifetime of &lt;code&gt;&amp;amp;self&lt;/code&gt;, and all lifetimes have been accounted for.</source>
          <target state="translated">输入生命周期有两个，因此Rust会应用第一个生命周期省略规则，并给 &lt;code&gt;&amp;amp;self&lt;/code&gt; 和 &lt;code&gt;announcement&lt;/code&gt; 它们自己的生命周期。然后，由于参数之一是 &lt;code&gt;&amp;amp;self&lt;/code&gt; ，返回类型将获得 &lt;code&gt;&amp;amp;self&lt;/code&gt; 的生存期，并且所有生存期均已考虑在内。</target>
        </trans-unit>
        <trans-unit id="ffdf24d7c3a95e9cacfa7c11d178ec9960ec72fd" translate="yes" xml:space="preserve">
          <source>There are two issues with the above example:</source>
          <target state="translated">上面的例子有两个问题。</target>
        </trans-unit>
        <trans-unit id="c1575bd4949a087cd0961e57e825f5b7d2464821" translate="yes" xml:space="preserve">
          <source>There are two main ways to read this document.</source>
          <target state="translated">阅读本文件主要有两种方式。</target>
        </trans-unit>
        <trans-unit id="86663982f114c71c4b638d9b0fa35d92d8fc55c4" translate="yes" xml:space="preserve">
          <source>There are two options that would work instead. The first would be to change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to &lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;struct.string#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt; to explicitly extract the string slice containing the string. The second way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to &lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a &lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion.</source>
          <target state="translated">有两种选择可以代替。第一种是更改 &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; 行。到 &lt;code&gt;example_func(example_string.as_str());&lt;/code&gt; ，使用&lt;a href=&quot;struct.string#method.as_str&quot;&gt; &lt;code&gt;as_str()&lt;/code&gt; &lt;/a&gt;方法显式提取包含字符串的字符串片段。第二种方式更改 &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; 到 &lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt; 。在这种情况下，我们将 &lt;code&gt;String&lt;/code&gt; 引用到&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;，然后将&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;引用回到&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。第二种方法更惯用，但是两种方法都可以显式地进行转换，而不是依赖隐式转换。</target>
        </trans-unit>
        <trans-unit id="022a56e5687a1a83c185eae56c2be99a7be6379c" translate="yes" xml:space="preserve">
          <source>There are two options to work around this issue. The first is simply to rename one of the types. Alternatively, one can specify the intended type using the following syntax:</source>
          <target state="translated">有两种方法可以解决这个问题。第一个是简单地重命名其中一个类型。或者,可以使用下面的语法来指定想要的类型。</target>
        </trans-unit>
        <trans-unit id="7601f9a3aa302729abcf51730ab0dacad11e1f7d" translate="yes" xml:space="preserve">
          <source>There are two possible solutions:</source>
          <target state="translated">有两种可能的解决办法。</target>
        </trans-unit>
        <trans-unit id="3f08d38f311f1d8aebf1cc8c4c04305ba58884d5" translate="yes" xml:space="preserve">
          <source>There are two syntactic forms for creating an array:</source>
          <target state="translated">创建数组有两种语法形式。</target>
        </trans-unit>
        <trans-unit id="63a18bac877b16a7425895e1b31ade8a29a01453" translate="yes" xml:space="preserve">
          <source>There are two types of &lt;code&gt;static&lt;/code&gt; items: those declared in association with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword and those without.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 项目有两种类型：与&lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt;关键字关联声明的静态项目和不带mut关键字的静态项目。</target>
        </trans-unit>
        <trans-unit id="86a631e5c1cd817983c93f98903db4ea59d68db2" translate="yes" xml:space="preserve">
          <source>There are two types of implementations:</source>
          <target state="translated">有两种类型的实施方式。</target>
        </trans-unit>
        <trans-unit id="fa155718008a683c96cef5cc6a71a54ea03f305c" translate="yes" xml:space="preserve">
          <source>There are two ways to define new macros:</source>
          <target state="translated">有两种方法可以定义新的宏。</target>
        </trans-unit>
        <trans-unit id="9880ebdf9a583de2d652297bd89e0b5ff4d36ffb" translate="yes" xml:space="preserve">
          <source>There are two ways to implement &lt;code&gt;Copy&lt;/code&gt; on your type. The simplest is to use &lt;code&gt;derive&lt;/code&gt;:</source>
          <target state="translated">有两种方法可以在您的类型上实现 &lt;code&gt;Copy&lt;/code&gt; 。最简单的方法是使用 &lt;code&gt;derive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b2a9fbbbcf33cff3a0df902072d56db76dfeaf3c" translate="yes" xml:space="preserve">
          <source>There are two ways to solve this error. The first is to make the public type signature only public to a module that also has access to the private type. This is done by using pub(crate) or pub(in crate::my_mod::etc) Example:</source>
          <target state="translated">有两种方法可以解决这个错误。第一种方法是将公有类型的签名只对一个模块公开,而该模块也可以访问私有类型。这可以通过使用 pub(crate)或 pub(in crate::my_mod::etc)例子:</target>
        </trans-unit>
        <trans-unit id="dc647999e3aa70d53b9f18def550d41889259047" translate="yes" xml:space="preserve">
          <source>There are various restrictions on transmuting between types in Rust; for example types being transmuted must have the same size. To apply all these restrictions, the compiler must know the exact types that may be transmuted. When type parameters are involved, this cannot always be done.</source>
          <target state="translated">在 Rust 中,类型之间的转换有各种限制,例如被转换的类型必须具有相同的大小。为了应用所有这些限制,编译器必须知道可能被转换的确切类型。当涉及到类型参数时,就不能总是这样做。</target>
        </trans-unit>
        <trans-unit id="0019607d06d61b11d32e87172ee0ea679ebbb977" translate="yes" xml:space="preserve">
          <source>There are various rules:</source>
          <target state="translated">有各种规则。</target>
        </trans-unit>
        <trans-unit id="0d6ed4037ecbcc5953e35640da903ed6a8a40981" translate="yes" xml:space="preserve">
          <source>There can only be one owner at a time.</source>
          <target state="translated">一次只能有一个主人。</target>
        </trans-unit>
        <trans-unit id="f4471e590e73989497aca327361dde4b0c93c59c" translate="yes" xml:space="preserve">
          <source>There is a difference between what the &lt;code&gt;match&lt;/code&gt; expression from Listing 9-6 and the &lt;code&gt;?&lt;/code&gt; operator do: error values that have the &lt;code&gt;?&lt;/code&gt; operator called on them go through the &lt;code&gt;from&lt;/code&gt; function, defined in the &lt;code&gt;From&lt;/code&gt; trait in the standard library, which is used to convert errors from one type into another. When the &lt;code&gt;?&lt;/code&gt; operator calls the &lt;code&gt;from&lt;/code&gt; function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons. As long as each error type implements the &lt;code&gt;from&lt;/code&gt; function to define how to convert itself to the returned error type, the &lt;code&gt;?&lt;/code&gt; operator takes care of the conversion automatically.</source>
          <target state="translated">清单9-6中的 &lt;code&gt;match&lt;/code&gt; 表达式和 &lt;code&gt;?&lt;/code&gt; 之间有区别。运算符do：具有 &lt;code&gt;?&lt;/code&gt; 的错误值调用它们的运算符通过标准库中 &lt;code&gt;From&lt;/code&gt; 特性定义的 &lt;code&gt;from&lt;/code&gt; 函数，该函数用于将错误从一种类型转换为另一种类型。什么时候 &lt;code&gt;?&lt;/code&gt; 如果操作员调用 &lt;code&gt;from&lt;/code&gt; 函数，则将收到的错误类型转换为在当前函数的返回类型中定义的错误类型。当一个函数返回一种错误类型来表示该函数可能发生故障的所有方式时，即使部件可能由于许多不同的原因而发生故障，这也很有用。只要每种错误类型都实现了 &lt;code&gt;from&lt;/code&gt; 函数定义如何将自身转换为返回的错误类型 &lt;code&gt;?&lt;/code&gt; 操作员会自动进行转换。</target>
        </trans-unit>
        <trans-unit id="42bfb7d2a182c3982d4afcf52f4999394d469590" translate="yes" xml:space="preserve">
          <source>There is a difference between what the &lt;code&gt;match&lt;/code&gt; expression from Listing 9-6 does and what the &lt;code&gt;?&lt;/code&gt; operator does: error values that have the &lt;code&gt;?&lt;/code&gt; operator called on them go through the &lt;code&gt;from&lt;/code&gt; function, defined in the &lt;code&gt;From&lt;/code&gt; trait in the standard library, which is used to convert errors from one type into another. When the &lt;code&gt;?&lt;/code&gt; operator calls the &lt;code&gt;from&lt;/code&gt; function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons. As long as each error type implements the &lt;code&gt;from&lt;/code&gt; function to define how to convert itself to the returned error type, the &lt;code&gt;?&lt;/code&gt; operator takes care of the conversion automatically.</source>
          <target state="translated">清单9-6中的 &lt;code&gt;match&lt;/code&gt; 表达式和the表达式之间有区别 &lt;code&gt;?&lt;/code&gt; 运算符会执行以下操作：具有 &lt;code&gt;?&lt;/code&gt; 的错误值调用它们的运算符通过标准库中 &lt;code&gt;From&lt;/code&gt; 特性定义的 &lt;code&gt;from&lt;/code&gt; 函数，该函数用于将错误从一种类型转换为另一种类型。什么时候 &lt;code&gt;?&lt;/code&gt; 如果操作员调用 &lt;code&gt;from&lt;/code&gt; 函数，则将收到的错误类型转换为当前函数的返回类型中定义的错误类型。当一个函数返回一种错误类型来表示该函数可能发生故障的所有方式时，即使部件可能由于许多不同的原因而发生故障，这也很有用。只要每种错误类型都实现了 &lt;code&gt;from&lt;/code&gt; 函数定义如何将自身转换为返回的错误类型 &lt;code&gt;?&lt;/code&gt; 操作员会自动进行转换。</target>
        </trans-unit>
        <trans-unit id="6b478d4cf3daf7fb5af886fd070b460cffb3f99a" translate="yes" xml:space="preserve">
          <source>There is a large variety of prefix types, see &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt;'s documentation for more.</source>
          <target state="translated">前缀类型种类繁多，有关更多信息，请参见&lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="b6a45e45d5b815dc5996fef1ade397970afb9eee" translate="yes" xml:space="preserve">
          <source>There is a natural point at which we can return the memory our &lt;code&gt;String&lt;/code&gt; needs to the allocator: when &lt;code&gt;s&lt;/code&gt; goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called &lt;code&gt;drop&lt;/code&gt;, and it&amp;rsquo;s where the author of &lt;code&gt;String&lt;/code&gt; can put the code to return the memory. Rust calls &lt;code&gt;drop&lt;/code&gt; automatically at the closing curly bracket.</source>
          <target state="translated">我们可以很自然地将 &lt;code&gt;String&lt;/code&gt; 所需的内存返回给分配器：当 &lt;code&gt;s&lt;/code&gt; 超出范围时。当变量超出范围时，Rust为我们调用一个特殊函数。此函数称为 &lt;code&gt;drop&lt;/code&gt; ，它是 &lt;code&gt;String&lt;/code&gt; 的创建者可以在其中放置代码以返回内存的地方。Rust呼叫 &lt;code&gt;drop&lt;/code&gt; 自动在右大括号处掉线。</target>
        </trans-unit>
        <trans-unit id="9b02d233f669a1e206e4e2c20ce1d2df695bab4c" translate="yes" xml:space="preserve">
          <source>There is a natural point at which we can return the memory our &lt;code&gt;String&lt;/code&gt; needs to the operating system: when &lt;code&gt;s&lt;/code&gt; goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called &lt;code&gt;drop&lt;/code&gt;, and it&amp;rsquo;s where the author of &lt;code&gt;String&lt;/code&gt; can put the code to return the memory. Rust calls &lt;code&gt;drop&lt;/code&gt; automatically at the closing curly bracket.</source>
          <target state="translated">我们可以很自然地将 &lt;code&gt;String&lt;/code&gt; 需要的内存返回给操作系统：当 &lt;code&gt;s&lt;/code&gt; 超出范围时。当变量超出范围时，Rust为我们调用一个特殊函数。此函数称为 &lt;code&gt;drop&lt;/code&gt; ，它是 &lt;code&gt;String&lt;/code&gt; 的作者可以在其中放置代码以返回内存的地方。Rust通话 &lt;code&gt;drop&lt;/code&gt; 自动在右大括号处掉线。</target>
        </trans-unit>
        <trans-unit id="f99c36775b0b7e1c59faa2f7b94f6fd5d85206bb" translate="yes" xml:space="preserve">
          <source>There is a small difference between the two: the &lt;code&gt;derive&lt;/code&gt; strategy will also place a &lt;code&gt;Copy&lt;/code&gt; bound on type parameters, which isn't always desired.</source>
          <target state="translated">两者之间有一个小的区别： &lt;code&gt;derive&lt;/code&gt; 策略还将在类型参数上放置一个 &lt;code&gt;Copy&lt;/code&gt; 绑定，这并不总是需要的。</target>
        </trans-unit>
        <trans-unit id="ba88e1e16f5f4f6fd310c5a8bb2e8dd5b7b7dc78" translate="yes" xml:space="preserve">
          <source>There is currently a known issue (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39364&quot;&gt;&lt;code&gt;#39364&lt;/code&gt;&lt;/a&gt;) that causes &lt;code&gt;recv_timeout&lt;/code&gt; to panic unexpectedly with the following example:</source>
          <target state="translated">当前存在一个已知问题（请参阅&lt;a href=&quot;https://github.com/rust-lang/rust/issues/39364&quot;&gt; &lt;code&gt;#39364&lt;/code&gt; &lt;/a&gt;），该错误导致 &lt;code&gt;recv_timeout&lt;/code&gt; 在以下示例中意外恐慌：</target>
        </trans-unit>
        <trans-unit id="ac69e37cd6f18587422e7c6b701f3aed59b4a925" translate="yes" xml:space="preserve">
          <source>There is currently no supported way to create a raw pointer or reference to a field of a struct inside &lt;code&gt;MaybeUninit&amp;lt;Struct&amp;gt;&lt;/code&gt;. That means it is not possible to create a struct by calling &lt;code&gt;MaybeUninit::uninit::&amp;lt;Struct&amp;gt;()&lt;/code&gt; and then writing to its fields.</source>
          <target state="translated">当前尚不支持在 &lt;code&gt;MaybeUninit&amp;lt;Struct&amp;gt;&lt;/code&gt; 内部创建原始指针或引用结构字段的方法。这意味着无法通过调用 &lt;code&gt;MaybeUninit::uninit::&amp;lt;Struct&amp;gt;()&lt;/code&gt; 然后写入其字段来创建结构。</target>
        </trans-unit>
        <trans-unit id="06e1ced9251455647a44280e8880c2f024531277" translate="yes" xml:space="preserve">
          <source>There is no consensus in the programming community about what features a language must have to be considered object oriented. Rust is influenced by many programming paradigms, including OOP; for example, we explored the features that came from functional programming in Chapter 13. Arguably, OOP languages share certain common characteristics, namely objects, encapsulation, and inheritance. Let&amp;rsquo;s look at what each of those characteristics means and whether Rust supports it.</source>
          <target state="translated">在编程社区中，对于必须将某种语言视为面向对象的功能尚未达成共识。 Rust受许多编程范例（包括OOP）的影响；例如，我们在第13章中探讨了函数式编程的功能。可以说，OOP语言具有某些共同的特征，即对象，封装和继承。让我们看看这些特征的含义以及Rust是否支持它。</target>
        </trans-unit>
        <trans-unit id="3940029042247daa011ed3a6db287dfc70d15650" translate="yes" xml:space="preserve">
          <source>There is no guarantee that an all-zero byte-pattern represents a valid value of some type &lt;code&gt;T&lt;/code&gt;. For example, the all-zero byte-pattern is not a valid value for reference types (&lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt;). Using &lt;code&gt;zeroed&lt;/code&gt; on such types causes immediate &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that there always is a valid value in a variable it considers initialized.</source>
          <target state="translated">无法保证全零字节模式代表某种类型 &lt;code&gt;T&lt;/code&gt; 的有效值。例如，全零字节模式对于引用类型（ &lt;code&gt;&amp;amp;T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）不是有效值。在此类类型上使用 &lt;code&gt;zeroed&lt;/code&gt; 会导致立即发生&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义的行为，&lt;/a&gt;因为&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;Rust编译器假定&lt;/a&gt;在它认为已初始化的变量中始终存在有效值。</target>
        </trans-unit>
        <trans-unit id="3d516718a20e6c51e7b81919f2ed7f10da7e19e0" translate="yes" xml:space="preserve">
          <source>There is no guarantee that an all-zero byte-pattern represents a valid value of some type &lt;code&gt;T&lt;/code&gt;. For example, the all-zero byte-pattern is not a valid value for reference types (&lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) and functions pointers. Using &lt;code&gt;zeroed&lt;/code&gt; on such types causes immediate &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that there always is a valid value in a variable it considers initialized.</source>
          <target state="translated">不能保证全零字节模式代表某种类型 &lt;code&gt;T&lt;/code&gt; 的有效值。例如，全零字节模式对于引用类型（ &lt;code&gt;&amp;amp;T&lt;/code&gt; ， &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）和函数指针不是有效值。在此类类型上使用 &lt;code&gt;zeroed&lt;/code&gt; 会导致立即发生&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义的行为，&lt;/a&gt;因为&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;Rust编译器假定&lt;/a&gt;在它认为已初始化的变量中始终存在有效值。</target>
        </trans-unit>
        <trans-unit id="77cd938f61b73cdc8199024bd862cf47becca43c" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; contains a valid nul terminator byte at the end of the string.</source>
          <target state="translated">无法保证 &lt;code&gt;ptr&lt;/code&gt; 指向的内存在字符串末尾包含有效的nul终止符字节。</target>
        </trans-unit>
        <trans-unit id="37d385330ea581c420be55585ac9b53b42ed4426" translate="yes" xml:space="preserve">
          <source>There is no guarantee to the validity of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">无法保证 &lt;code&gt;ptr&lt;/code&gt; 的有效性。</target>
        </trans-unit>
        <trans-unit id="90b4dcdc90eb015a6d81f3692edc057c91c2b6f8" translate="yes" xml:space="preserve">
          <source>There is no implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; for child processes, so if you do not ensure the &lt;code&gt;Child&lt;/code&gt; has exited then it will continue to run, even after the &lt;code&gt;Child&lt;/code&gt; handle to the child process has gone out of scope.</source>
          <target state="translated">没有执行&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;子进程，因此，如果您不能确保 &lt;code&gt;Child&lt;/code&gt; 已退出然后它会继续运行，偶数后 &lt;code&gt;Child&lt;/code&gt; 句柄子进程已经超出了范围。</target>
        </trans-unit>
        <trans-unit id="96d59d760142fd31188eb3940b02911fcbc69887" translate="yes" xml:space="preserve">
          <source>There is no implementation of &lt;a href=&quot;https://doc.rust-lang.org/core/ops/trait.Drop.html&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; for child processes, so if you do not ensure the &lt;code&gt;Child&lt;/code&gt; has exited then it will continue to run, even after the &lt;code&gt;Child&lt;/code&gt; handle to the child process has gone out of scope.</source>
          <target state="translated">没有执行&lt;a href=&quot;https://doc.rust-lang.org/core/ops/trait.Drop.html&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;子进程，因此，如果您不能确保 &lt;code&gt;Child&lt;/code&gt; 已退出然后它会继续运行，偶数后 &lt;code&gt;Child&lt;/code&gt; 句柄子进程已经超出了范围。</target>
        </trans-unit>
        <trans-unit id="f7865277b670de1ac383b78686d6c6c3ef225ff1" translate="yes" xml:space="preserve">
          <source>There is no implicit capture of the containing function's generic parameters, parameters, and local variables. For example, &lt;code&gt;inner&lt;/code&gt; may not access &lt;code&gt;outer_var&lt;/code&gt;.</source>
          <target state="translated">没有隐式捕获包含函数的通用参数，参数和局部变量。例如， &lt;code&gt;inner&lt;/code&gt; 可能无法访问 &lt;code&gt;outer_var&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98bc5a98bb823e7a07123a40b084c3311e58d239" translate="yes" xml:space="preserve">
          <source>There is no meaningful value to associate with your keys.</source>
          <target state="translated">没有任何有意义的价值与你的钥匙相关联。</target>
        </trans-unit>
        <trans-unit id="e47f071471a1ed59d24ce5598360fe16b663897e" translate="yes" xml:space="preserve">
          <source>There is no syntax that directly refers to a function item type, but the compiler will display the type as something like &lt;code&gt;fn(u32) -&amp;gt; i32 {fn_name}&lt;/code&gt; in error messages.</source>
          <target state="translated">没有语法可以直接引用功能项类型，但是编译器将在错误消息中将类型显示为类似 &lt;code&gt;fn(u32) -&amp;gt; i32 {fn_name}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6352ff90262f746d2ceb9b5382b99f239203c508" translate="yes" xml:space="preserve">
          <source>There is no way to express the &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; condition within a pattern, so the match guard gives us the ability to express this logic.</source>
          <target state="translated">无法在模式中表达 &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; 条件，因此比赛防护使我们能够表达这种逻辑。</target>
        </trans-unit>
        <trans-unit id="f04c5e1cecb9254e859f18bc80c9ad5ecd03b1f1" translate="yes" xml:space="preserve">
          <source>There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like &lt;a href=&quot;../intrinsics/fn.transmute&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;. Similarly, the only way to create a true trait object from a &lt;code&gt;TraitObject&lt;/code&gt; value is with &lt;code&gt;transmute&lt;/code&gt;.</source>
          <target state="translated">无法通用地引用所有特征对象，因此创建此类型值的唯一方法是使用诸如&lt;a href=&quot;../intrinsics/fn.transmute&quot;&gt; &lt;code&gt;std::mem::transmute&lt;/code&gt; &lt;/a&gt;类的函数。同样，创建从一个真正的特质对象的唯一途径 &lt;code&gt;TraitObject&lt;/code&gt; 值与 &lt;code&gt;transmute&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ac27f2fb34cee3cbd54d9db13f601fadc62dc92" translate="yes" xml:space="preserve">
          <source>There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;. Similarly, the only way to create a true trait object from a &lt;code&gt;TraitObject&lt;/code&gt; value is with &lt;code&gt;transmute&lt;/code&gt;.</source>
          <target state="translated">无法通用地引用所有特征对象，因此创建此类型值的唯一方法是使用诸如&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;std::mem::transmute&lt;/code&gt; &lt;/a&gt;类的函数。同样，创建从一个真正的特质对象的唯一途径 &lt;code&gt;TraitObject&lt;/code&gt; 值与 &lt;code&gt;transmute&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9f689cb8e372a1fb3e4dbcf70bbf33a833163e2" translate="yes" xml:space="preserve">
          <source>There is no wrong way to read this book: if you want to skip ahead, go for it! You might have to jump back to earlier chapters if you experience any confusion. But do whatever works for you.</source>
          <target state="translated">阅读本书的方法没有错:如果你想跳过前面的章节,就去吧! 如果你遇到任何困惑,你可能不得不跳回前面的章节。但是,无论做什么都适合你。</target>
        </trans-unit>
        <trans-unit id="f89524ca0c10b9d4f1257c768a5b98aab1c4ca9b" translate="yes" xml:space="preserve">
          <source>There is one more similarity between enums and structs: just as we&amp;rsquo;re able to define methods on structs using &lt;code&gt;impl&lt;/code&gt;, we&amp;rsquo;re also able to define methods on enums. Here&amp;rsquo;s a method named &lt;code&gt;call&lt;/code&gt; that we could define on our &lt;code&gt;Message&lt;/code&gt; enum:</source>
          <target state="translated">枚举和结构之间还有另外一个相似之处：正如我们可以使用 &lt;code&gt;impl&lt;/code&gt; 在结构上定义方法一样，我们也可以在枚举上定义方法。这是一个可以在 &lt;code&gt;Message&lt;/code&gt; 枚举上定义的名为 &lt;code&gt;call&lt;/code&gt; 的方法：</target>
        </trans-unit>
        <trans-unit id="dd5de49f07fcfe0b32f34685bec57fc973c95f95" translate="yes" xml:space="preserve">
          <source>There is possibly no limit to the number of &lt;code&gt;else&lt;/code&gt; blocks that could follow an &lt;code&gt;if&lt;/code&gt; expression however if you have several then a &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; expression might be preferable.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 表达式后面可以包含的 &lt;code&gt;else&lt;/code&gt; 块的数量可能没有限制，但是如果您有多个，则&lt;a href=&quot;keyword.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;表达式可能是更可取的。</target>
        </trans-unit>
        <trans-unit id="602b0e48a3f43914053d4b199337461ae231047f" translate="yes" xml:space="preserve">
          <source>There is usually no need to create a &lt;code&gt;Thread&lt;/code&gt; struct yourself, one should instead use a function like &lt;code&gt;spawn&lt;/code&gt; to create new threads, see the docs of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">通常不需要自己创建 &lt;code&gt;Thread&lt;/code&gt; 结构，而应该使用诸如 &lt;code&gt;spawn&lt;/code&gt; 的函数来创建新线程，有关更多详细信息，请参见&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="f5aa017ba54ffa17080a39771f2c83f220593384" translate="yes" xml:space="preserve">
          <source>There will be an error about &lt;code&gt;bool&lt;/code&gt; not implementing &lt;code&gt;Index&amp;lt;u8&amp;gt;&lt;/code&gt;, followed by a note saying &quot;the type &lt;code&gt;bool&lt;/code&gt; cannot be indexed by &lt;code&gt;u8&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 不实现 &lt;code&gt;Index&amp;lt;u8&amp;gt;&lt;/code&gt; 会出现错误，然后出现一条注释，指出&amp;ldquo; &lt;code&gt;bool&lt;/code&gt; 类型不能被 &lt;code&gt;u8&lt;/code&gt; 索引&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7649fb68743c30fa670731965f40aa4090d73b82" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a lot more to say about &lt;a href=&quot;http://doc.crates.io&quot;&gt;Cargo&lt;/a&gt; and &lt;a href=&quot;http://doc.crates.io/crates-io.html&quot;&gt;its ecosystem&lt;/a&gt; which we&amp;rsquo;ll discuss in Chapter 14, but for now, that&amp;rsquo;s all you need to know. Cargo makes it very easy to reuse libraries, so Rustaceans are able to write smaller projects that are assembled from a number of packages.</source>
          <target state="translated">还有很多更多要说&lt;a href=&quot;http://doc.crates.io&quot;&gt;货物&lt;/a&gt;和&lt;a href=&quot;http://doc.crates.io/crates-io.html&quot;&gt;它的生态系统&lt;/a&gt;，我们将在第14章讨论，但现在，这就是你需要知道的。 Cargo使重用库变得非常容易，因此Rustaceans能够编写由许多程序包组装而成的较小项目。</target>
        </trans-unit>
        <trans-unit id="2bf65550ac389c6cc7469a24526e0ae8bf661af9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a tendency among many Rustaceans to avoid using &lt;code&gt;clone&lt;/code&gt; to fix ownership problems because of its runtime cost. In &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;, you&amp;rsquo;ll learn how to use more efficient methods in this type of situation. But for now, it&amp;rsquo;s okay to copy a few strings to continue making progress because you&amp;rsquo;ll make these copies only once and your filename and query string are very small. It&amp;rsquo;s better to have a working program that&amp;rsquo;s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it&amp;rsquo;ll be easier to start with the most efficient solution, but for now, it&amp;rsquo;s perfectly acceptable to call &lt;code&gt;clone&lt;/code&gt;.</source>
          <target state="translated">由于其运行时成本，许多Rustaceans中有一种避免使用 &lt;code&gt;clone&lt;/code&gt; 来解决所有权问题的趋势。在&lt;a href=&quot;ch13-00-functional-features&quot;&gt;第13章中&lt;/a&gt;，您将学习如何在这种情况下使用更有效的方法。但是就目前而言，可以复制一些字符串以继续取得进展是可以的，因为您将只复制一次这些副本，并且文件名和查询字符串非常小。最好有一个效率低下的工作程序，而不是在初次尝试时就对代码进行超优化。随着您对Rust的使用越来越丰富，从最有效的解决方案开始将变得更加容易，但是就目前而言，调用 &lt;code&gt;clone&lt;/code&gt; 完全可以接受。</target>
        </trans-unit>
        <trans-unit id="66fb5ab158cd4be714eaa0eeb00d2ccbb6eb7bd5" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four type IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store &lt;code&gt;V4&lt;/code&gt; addresses as four &lt;code&gt;u8&lt;/code&gt; values but still express &lt;code&gt;V6&lt;/code&gt; addresses as one &lt;code&gt;String&lt;/code&gt; value, we wouldn&amp;rsquo;t be able to with a struct. Enums handle this case with ease:</source>
          <target state="translated">使用枚举而不是结构还有另一个优点：每个变体可以具有不同类型和数量的关联数据。版本4类型的IP地址将始终具有四个数字部分，其值将介于0到255之间。如果我们想将 &lt;code&gt;V4&lt;/code&gt; 地址存储为四个 &lt;code&gt;u8&lt;/code&gt; 值，但仍将 &lt;code&gt;V6&lt;/code&gt; 地址表示为一个 &lt;code&gt;String&lt;/code&gt; 值，则无法使用结构。枚举可以轻松处理这种情况：</target>
        </trans-unit>
        <trans-unit id="a401bf0a884425f212fc0c2849df8bdacf839a70" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another solution to the problem of bringing two types of the same name into the same scope with &lt;code&gt;use&lt;/code&gt;: after the path, we can specify &lt;code&gt;as&lt;/code&gt; and a new local name, or alias, for the type. Listing 7-16 shows another way to write the code in Listing 7-15 by renaming one of the two &lt;code&gt;Result&lt;/code&gt; types using &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;use&lt;/code&gt; 将相同名称的两种类型引入同一作用域的问题，还有另一种解决方案：在路径之后，我们可以 &lt;code&gt;as&lt;/code&gt; 指定一个新的本地名称或别名。清单7-16显示了另一种编写清单7-15中代码的方法，即使用 &lt;code&gt;as&lt;/code&gt; 重命名两个 &lt;code&gt;Result&lt;/code&gt; 类型之一。</target>
        </trans-unit>
        <trans-unit id="e2494d175673de3a22a42c411f830ff3208f6ec7" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another wrinkle we haven&amp;rsquo;t talked about yet. This code using integers &amp;ndash; part of which was shown in Listing 4-2 &amp;ndash; works and is valid:</source>
          <target state="translated">我们还没有谈论过另一个皱纹。此代码使用整数（清单4-2中显示了其中的一部分）有效且有效：</target>
        </trans-unit>
        <trans-unit id="04733e00c121b49528c905aab2fa6e90d06dc6c3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another wrinkle we haven&amp;rsquo;t talked about yet. This code using integers, part of which was shown in Listing 4-2, works and is valid:</source>
          <target state="translated">我们还没有谈论过另一个皱纹。这段使用整数的代码有效且有效：部分代码如清单4-2所示：</target>
        </trans-unit>
        <trans-unit id="6058c5e16c87f1a91c60dc38f9f510ce010e9805" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Rust&amp;rsquo;s privacy rules do allow you to test private functions. Consider the code in Listing 11-12 with the private function &lt;code&gt;internal_adder&lt;/code&gt;.</source>
          <target state="translated">在测试社区中，关于是否应直接测试私有功能存在争论，而其他语言使测试私有功能变得困难或不可能。无论您遵循哪种测试意识形态，Rust的隐私规则都允许您测试私有功能。考虑清单11-12中带有私有函数 &lt;code&gt;internal_adder&lt;/code&gt; 的代码。</target>
        </trans-unit>
        <trans-unit id="908f1205edb5e08b15769591fe9ecf304d371a0b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no mechanism being used to synchronize access to the data.</source>
          <target state="translated">没有用于同步对数据的访问的机制。</target>
        </trans-unit>
        <trans-unit id="8e1fa626ffc94c26aaee1b60bc06a3539eef3bfd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no reason to separate these methods into multiple &lt;code&gt;impl&lt;/code&gt; blocks here, but this is valid syntax. We&amp;rsquo;ll see a case in which multiple &lt;code&gt;impl&lt;/code&gt; blocks are useful in Chapter 10, where we discuss generic types and traits.</source>
          <target state="translated">这里没有理由将这些方法分为多个 &lt;code&gt;impl&lt;/code&gt; 块，但这是有效的语法。在第10章中，我们将讨论一种情况，其中多个 &lt;code&gt;impl&lt;/code&gt; 块很有用，我们在这里讨论了泛型类型和特征。</target>
        </trans-unit>
        <trans-unit id="68d4631903746cfba7c6e6864ab36c77a56f918c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no strong reason behind this idiom: it&amp;rsquo;s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.</source>
          <target state="translated">这个习惯用法没有充分的理由：这只是惯例的出现，人们已经习惯了以这种方式读取和编写Rust代码。</target>
        </trans-unit>
        <trans-unit id="c6cc13f913f5af22a31d9a866ef0ab4e915bc64e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s not a good way to encode this information in the types you use.</source>
          <target state="translated">没有一种很好的方法将这种信息编码为您使用的类型。</target>
        </trans-unit>
        <trans-unit id="42ede15289d883de11e0a80cc68d82337478321c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one more catch with this release model: unstable features. Rust uses a technique called &amp;ldquo;feature flags&amp;rdquo; to determine what features are enabled in a given release. If a new feature is under active development, it lands on &lt;code&gt;master&lt;/code&gt;, and therefore, in nightly, but behind a &lt;em&gt;feature flag&lt;/em&gt;. If you, as a user, wish to try out the work-in-progress feature, you can, but you must be using a nightly release of Rust and annotate your source code with the appropriate flag to opt in.</source>
          <target state="translated">此发行模型还有另外一个特点：不稳定的功能。Rust使用一种称为&amp;ldquo;功能标记&amp;rdquo;的技术来确定在给定发行版中启用了哪些功能。如果正在积极开发新功能，则它将降落在 &lt;code&gt;master&lt;/code&gt; 上，因此在夜间降落，但位于&lt;em&gt;功能标志的&lt;/em&gt;后面。如果您作为用户希望尝试进行中的功能，则可以，但是您必须使用每晚发布的Rust，并使用适当的标记来注释源代码以选择加入。</target>
        </trans-unit>
        <trans-unit id="daaeaab720a0d66e562ebf5f2bea02ac0a5abbb2" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one more situation involving &lt;code&gt;pub&lt;/code&gt; that we haven&amp;rsquo;t covered, and that is our last module system feature: the &lt;code&gt;use&lt;/code&gt; keyword. We&amp;rsquo;ll cover &lt;code&gt;use&lt;/code&gt; by itself first, and then we&amp;rsquo;ll show how to combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">我们还没有涉及涉及 &lt;code&gt;pub&lt;/code&gt; 的另一种情况，这是我们的最后一个模块系统功能： &lt;code&gt;use&lt;/code&gt; 关键字。我们将首先介绍 &lt;code&gt;use&lt;/code&gt; ，然后说明如何结合 &lt;code&gt;pub&lt;/code&gt; 和 &lt;code&gt;use&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e8c77371d51b56070c8afcedaaaf9336a342d93" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other aspect of &lt;code&gt;match&lt;/code&gt; we need to discuss. Consider this version of our &lt;code&gt;plus_one&lt;/code&gt; function that has a bug and won&amp;rsquo;t compile:</source>
          <target state="translated">我们还需要讨论 &lt;code&gt;match&lt;/code&gt; 另一方面。考虑我们的 &lt;code&gt;plus_one&lt;/code&gt; 函数的此版本，该版本存在错误并且无法编译：</target>
        </trans-unit>
        <trans-unit id="3cab02a3373b42bd604f431d95c5d649fedd71e0" translate="yes" xml:space="preserve">
          <source>There's a trait in the standard library for converting something into an iterator: &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;. This trait has one method, &lt;a href=&quot;trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt;, which converts the thing implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; into an iterator. Let's take a look at that &lt;code&gt;for&lt;/code&gt; loop again, and what the compiler converts it into:</source>
          <target state="translated">标准库中有一个特征，可以将某些东西转换为迭代器：&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;。此特征具有一个方法&lt;a href=&quot;trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;，它将实现&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;的东西转换为迭代器。让我们再次看一下 &lt;code&gt;for&lt;/code&gt; 循环，以及编译器将其转换为什么：</target>
        </trans-unit>
        <trans-unit id="126dd99b7c8920c551aa5435d3f5f50326fcb2aa" translate="yes" xml:space="preserve">
          <source>There's no easy fix for this, generally code will need to be refactored so that you no longer need to derive from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">对此没有简单的解决方法，通常需要重构代码，以使您不再需要从 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; 派生。</target>
        </trans-unit>
        <trans-unit id="488dc2b946582ce5502bb699e0ad78fcce8b394c" translate="yes" xml:space="preserve">
          <source>There's one more subtle bit here: the standard library contains an interesting implementation of &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这里还有一点微妙之处：标准库包含一个有趣的&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;实现：</target>
        </trans-unit>
        <trans-unit id="fd800f0b62b0c62a6a6fb9b356e68d3a2d4685be" translate="yes" xml:space="preserve">
          <source>There, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="translated">那里，在impl上出现的where子句 &lt;code&gt;T: 'a&lt;/code&gt; 尚不满足于该结构。要编译此示例，您必须在结构定义中添加一个类似 &lt;code&gt;T: 'a&lt;/code&gt; 的子句：</target>
        </trans-unit>
        <trans-unit id="943a55d68bc8d1a8af15546966743386da3f91a8" translate="yes" xml:space="preserve">
          <source>Therefore, Rust&amp;rsquo;s type system and trait bounds ensure that you can never accidentally send an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value across threads unsafely. When we tried to do this in Listing 16-14, we got the error &lt;code&gt;the trait Send is not implemented for Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt;. When we switched to &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, which is &lt;code&gt;Send&lt;/code&gt;, the code compiled.</source>
          <target state="translated">因此，Rust的类型系统和特征范围可确保您绝不会不安全地跨线程意外发送 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值。当我们尝试在清单16-14中执行此操作时，遇到错误 &lt;code&gt;the trait Send is not implemented for Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; 。当我们切换到 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; ，即 &lt;code&gt;Send&lt;/code&gt; 时，将编译代码。</target>
        </trans-unit>
        <trans-unit id="92887ab1d8d0b7fee43ce74855c566c18dd9ff66" translate="yes" xml:space="preserve">
          <source>Therefore, pinning also comes with a &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;-related guarantee.</source>
          <target state="translated">因此，固定还附带与&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;相关的保证。</target>
        </trans-unit>
        <trans-unit id="a965d0af2f94e5f3318be18d630d6ce398f8ad8c" translate="yes" xml:space="preserve">
          <source>Therefore, pinning also comes with a &lt;code&gt;drop&lt;/code&gt;-related guarantee.</source>
          <target state="translated">因此，固定还附带与 &lt;code&gt;drop&lt;/code&gt; 相关的保证。</target>
        </trans-unit>
        <trans-unit id="0034e8adfe6fdcd359b83e7e3154391d1a05f64e" translate="yes" xml:space="preserve">
          <source>Therefore, we cannot rely on naive check for &lt;code&gt;StructuralPartialEq&lt;/code&gt; and mere &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">因此，我们不能仅仅依赖于对 &lt;code&gt;StructuralPartialEq&lt;/code&gt; 和仅仅 &lt;code&gt;Eq&lt;/code&gt; 的幼稚检查。</target>
        </trans-unit>
        <trans-unit id="f3da5db36b6a5c8b63c646979b9f9638e2ffed72" translate="yes" xml:space="preserve">
          <source>These abstractions can be built out of lower-level primitives. For efficiency, the sync objects in the standard library are usually implemented with help from the operating system's kernel, which is able to reschedule the threads while they are blocked on acquiring a lock.</source>
          <target state="translated">这些抽象可以从低级基元中构建出来。为了提高效率,标准库中的同步对象通常是在操作系统内核的帮助下实现的,内核能够在线程获取锁时被阻塞的情况下重新安排线程的时间。</target>
        </trans-unit>
        <trans-unit id="0b4543381c3d34027ca13b9d929f743b5e4c9c39" translate="yes" xml:space="preserve">
          <source>These also point to memory owned by some other value. A mutable reference type is written &lt;code&gt;&amp;amp;mut type&lt;/code&gt; or &lt;code&gt;&amp;amp;'a mut type&lt;/code&gt;. A mutable reference (that hasn't been borrowed) is the only way to access the value it points to, so is not &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">这些还指向其他值所拥有的内存。可变的引用类型是 &lt;code&gt;&amp;amp;mut type&lt;/code&gt; 或 &lt;code&gt;&amp;amp;'a mut type&lt;/code&gt; 。可变引用（尚未借用）是访问其指向的值的唯一方法，因此不是 &lt;code&gt;Copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1edbd620f4ea3fb93fdd0d7dd71adad12120dfa7" translate="yes" xml:space="preserve">
          <source>These ampersands are &lt;em&gt;references&lt;/em&gt;, and they allow you to refer to some value without taking ownership of it. Figure 4-5 shows a diagram.</source>
          <target state="translated">这些与符号是&lt;em&gt;reference&lt;/em&gt;，它们使您可以引用某些值而无需拥有所有权。图4-5显示了一个示意图。</target>
        </trans-unit>
        <trans-unit id="c26ef3d23f517e371ad3e5a198bcf65faf103392" translate="yes" xml:space="preserve">
          <source>These are all flags altering the behavior of the formatter.</source>
          <target state="translated">这些都是改变formatter行为的标志。</target>
        </trans-unit>
        <trans-unit id="4fbf8436660d61da218272cb68549a2354d27ae0" translate="yes" xml:space="preserve">
          <source>These are equivalent to the following explicit lifetime annotations:</source>
          <target state="translated">这些相当于以下明确的寿命注释。</target>
        </trans-unit>
        <trans-unit id="3f42eae85e77f8aae9c5335f688c216fd7101df0" translate="yes" xml:space="preserve">
          <source>These are fairly high-level and quick break-downs of when each collection should be considered. Detailed discussions of strengths and weaknesses of individual collections can be found on their own documentation pages.</source>
          <target state="translated">这些都是相当高层次和快速的细分,说明何时应该考虑每个系列。关于各个系列的优缺点的详细讨论可在其各自的文件页上找到。</target>
        </trans-unit>
        <trans-unit id="f5b38a7809c6c63bf242f85f557b82e6e93c16bc" translate="yes" xml:space="preserve">
          <source>These are often used in combination with &lt;a href=&quot;external-blocks&quot;&gt;external block&lt;/a&gt; items which provide function &lt;em&gt;declarations&lt;/em&gt; that can be used to call functions without providing their &lt;em&gt;definition&lt;/em&gt;:</source>
          <target state="translated">这些通常与&lt;a href=&quot;external-blocks&quot;&gt;外部块&lt;/a&gt;项结合使用，这些外部块项提供了可用于调用函数的函数&lt;em&gt;声明&lt;/em&gt;，而无需提供其&lt;em&gt;定义&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="69b2114a065741874c57309ba27c70784c7ddedd" translate="yes" xml:space="preserve">
          <source>These are the last two unary operators. This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="translated">这是最后两个一元运算符。该表总结了它们在原始类型上的行为，以及哪些特征用于使其他类型的这些运算符超载。请记住，带符号整数始终使用二进制补码表示。所有这些运算符的操作数都是在&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;值表达式上下文&lt;/a&gt;中评估的，因此可以移动或复制。</target>
        </trans-unit>
        <trans-unit id="25cb76396a6daa0dab5184b03f4b6697d1acd40a" translate="yes" xml:space="preserve">
          <source>These attributes are meant to only be used by the standard library and are rejected in your own crates.</source>
          <target state="translated">这些属性是为了只被标准库使用,在你自己的箱子里被拒绝。</target>
        </trans-unit>
        <trans-unit id="b6db5a380dbbbf8a2cd7b3c9d1a9637a5d119ab4" translate="yes" xml:space="preserve">
          <source>These attributes do not work on typedefs, since typedefs are just aliases.</source>
          <target state="translated">这些属性对 typedefs 不起作用,因为 typedefs 只是别名。</target>
        </trans-unit>
        <trans-unit id="45e9c8e478d7d23050c1bb7760888996d75acd57" translate="yes" xml:space="preserve">
          <source>These axioms, along with careful use of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; for pointer arithmetic, are enough to correctly implement many useful things in unsafe code. Stronger guarantees will be provided eventually, as the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/aliasing.html&quot;&gt;aliasing&lt;/a&gt; rules are being determined. For more information, see the &lt;a href=&quot;../../book/ch19-01-unsafe-rust#dereferencing-a-raw-pointer&quot;&gt;book&lt;/a&gt; as well as the section in the reference devoted to &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">这些公理以及谨慎地使用&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;进行指针运算，足以在不安全的代码中正确实现许多有用的功能。随着确定&lt;a href=&quot;https://doc.rust-lang.org/nomicon/aliasing.html&quot;&gt;混叠&lt;/a&gt;规则，最终将提供更强有力的保证。有关更多信息，请参见&lt;a href=&quot;../../book/ch19-01-unsafe-rust#dereferencing-a-raw-pointer&quot;&gt;本书&lt;/a&gt;以及参考资料中有关&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义行为的部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7913b3c72a22fc6b243e0539a47297d89428aedf" translate="yes" xml:space="preserve">
          <source>These can all be interpreted as flags for a particular formatter.</source>
          <target state="translated">这些都可以解释为特定格式器的标志。</target>
        </trans-unit>
        <trans-unit id="0e39a0bd16ba8ecfd732cbb117c3248fda60a735" translate="yes" xml:space="preserve">
          <source>These can be fixed by declaring lifetime parameters:</source>
          <target state="translated">这些可以通过声明寿命参数来解决。</target>
        </trans-unit>
        <trans-unit id="d454f3116d0aed2fb7a537cae1b229f52b361113" translate="yes" xml:space="preserve">
          <source>These channels come in two flavors:</source>
          <target state="translated">这些渠道有两种口味。</target>
        </trans-unit>
        <trans-unit id="c31b94922e5b65f02fef2f529b0b7e4859486143" translate="yes" xml:space="preserve">
          <source>These components describe the shape of the data we&amp;rsquo;re working with, which we then match against values to determine whether our program has the correct data to continue running a particular piece of code.</source>
          <target state="translated">这些组件描述了我们正在使用的数据的形状，然后将它们与值进行匹配，以确定我们的程序是否具有正确的数据以继续运行特定的代码。</target>
        </trans-unit>
        <trans-unit id="01d073371ba3433dace28c44e03a57f2a2d8dbcd" translate="yes" xml:space="preserve">
          <source>These default object lifetime bounds are used instead of the lifetime parameter elision rules defined above when the lifetime bound is omitted entirely. If &lt;code&gt;'_&lt;/code&gt; is used as the lifetime bound then the bound follows the usual elision rules.</source>
          <target state="translated">当完全省略生命周期限制时，将使用这些默认对象生命周期界限来代替上面定义的生命周期参数省略规则。如果将 &lt;code&gt;'_&lt;/code&gt; 用作生存期界限，则界限遵循通常的省略规则。</target>
        </trans-unit>
        <trans-unit id="3cb556ed4e688a43a755806e0180a1ae20f4245d" translate="yes" xml:space="preserve">
          <source>These enumerations can be cast to integer types with the &lt;code&gt;as&lt;/code&gt; operator by a &lt;a href=&quot;../expressions/operator-expr#semantics&quot;&gt;numeric cast&lt;/a&gt;. The enumeration can optionally specify which integer each discriminant gets by following the variant name with &lt;code&gt;=&lt;/code&gt; followed by a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;. If the first variant in the declaration is unspecified, then it is set to zero. For every other unspecified discriminant, it is set to one higher than the previous variant in the declaration.</source>
          <target state="translated">这些枚举可以通过&lt;a href=&quot;../expressions/operator-expr#semantics&quot;&gt;数字转换&lt;/a&gt;使用 &lt;code&gt;as&lt;/code&gt; 运算符转换为整数类型。枚举可以有选择地指定每个判别式获得哪个整数，方法是在变量名称之后加上 &lt;code&gt;=&lt;/code&gt; ,后跟一个&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;常量表达式&lt;/a&gt;。如果声明中的第一个变量未指定，则将其设置为零。对于所有其他未指定的判别式，将其设置为比声明中的先前变体高一个。</target>
        </trans-unit>
        <trans-unit id="56f44a74054755cd230d668bfd5dc0a8f5aa2ac0" translate="yes" xml:space="preserve">
          <source>These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords. The reasoning behind this is to make current programs forward compatible with future versions of Rust by forbidding them to use these keywords.</source>
          <target state="translated">这些关键字还没有使用,但它们保留给将来使用。它们与严格关键字有相同的限制。这背后的原因是通过禁止当前程序使用这些关键字,使其与未来版本的Rust兼容。</target>
        </trans-unit>
        <trans-unit id="f2eab53396d35c8dd4df2e3ab58dfee415a7015e" translate="yes" xml:space="preserve">
          <source>These keywords can only be used in their correct contexts. They cannot be used as the names of:</source>
          <target state="translated">这些关键词只能在正确的上下文中使用。它们不能作为下列机构的名称使用:</target>
        </trans-unit>
        <trans-unit id="aec421e6db4795c07bbf5e8ae6411e119af0b089" translate="yes" xml:space="preserve">
          <source>These keywords have special meaning only in certain contexts. For example, it is possible to declare a variable or method with the name &lt;code&gt;union&lt;/code&gt;.</source>
          <target state="translated">这些关键字仅在某些情况下具有特殊含义。例如，可以使用名称 &lt;code&gt;union&lt;/code&gt; 声明变量或方法。</target>
        </trans-unit>
        <trans-unit id="24355b40ed9274fe2bce5ed7512a65c55ffdfb11" translate="yes" xml:space="preserve">
          <source>These lines define a function in Rust. The &lt;code&gt;main&lt;/code&gt; function is special: it is always the first code that runs in every executable Rust program. The first line declares a function named &lt;code&gt;main&lt;/code&gt; that has no parameters and returns nothing. If there were parameters, they would go inside the parentheses, &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">这些行定义了Rust中的功能。的 &lt;code&gt;main&lt;/code&gt; 功能是特殊的：它总是第一个代码，在每个可执行锈程序运行。第一行声明了一个名为 &lt;code&gt;main&lt;/code&gt; 的函数，该函数没有参数，也不返回任何内容。如果有参数，它们将放在括号 &lt;code&gt;()&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="78ee21b3b578a8828b900a4d7bb5e92af7fdfb9f" translate="yes" xml:space="preserve">
          <source>These lines show Cargo only updates the build with your tiny change to the &lt;em&gt;src/main.rs&lt;/em&gt; file. Your dependencies haven&amp;rsquo;t changed, so Cargo knows it can reuse what it has already downloaded and compiled for those. It just rebuilds your part of the code.</source>
          <target state="translated">这些行显示Cargo仅对&lt;em&gt;src / main.rs&lt;/em&gt;文件进行了很小的更改即可更新构建。您的依存关系没有改变，因此Cargo知道它可以重复使用已经为它们下载和编译的内容。它只是重建您的部分代码。</target>
        </trans-unit>
        <trans-unit id="ba54db094123009e0eb01fa8adef8c82df9419e8" translate="yes" xml:space="preserve">
          <source>These macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; and a signature of &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is what is inside the delimiters of the macro invocation and the output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the entire macro invocation.</source>
          <target state="translated">这些宏由具有 &lt;code&gt;proc_macro&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;和 &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 签名的&lt;a href=&quot;visibility-and-privacy&quot;&gt;公共&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;函数&lt;/a&gt;定义。输入的&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;是宏调用的定界符之内，输出的&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;替换整个宏调用。</target>
        </trans-unit>
        <trans-unit id="c77584f3dda90ac8527f5ef32d9ad1f6daeca4c8" translate="yes" xml:space="preserve">
          <source>These macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; and a signature of &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is what is inside the delimiters of the macro invocation and the output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the entire macro invocation. It may contain an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">这些宏由具有 &lt;code&gt;proc_macro&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;和 &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 签名的&lt;a href=&quot;visibility-and-privacy&quot;&gt;公共&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;函数&lt;/a&gt;定义。输入&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;是宏调用的定界符之内，输出&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;替换整个宏调用。它可以包含任意数量的&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;。这些宏不能扩展为定义新的 &lt;code&gt;macro_rules&lt;/code&gt; 样式宏的语法。</target>
        </trans-unit>
        <trans-unit id="254739acb173823a2863a1c41d3ebb09cfa13aeb" translate="yes" xml:space="preserve">
          <source>These macros are only invokable in &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. They cannot even be invoked to create &lt;a href=&quot;statements#item-declarations&quot;&gt;item declaration statements&lt;/a&gt;. Furthermore, they must either be invoked with curly braces and no semicolon or a different delimiter followed by a semicolon. For example, &lt;code&gt;make_answer&lt;/code&gt; from the previous example can be invoked as &lt;code&gt;make_answer!{}&lt;/code&gt;, &lt;code&gt;make_answer!();&lt;/code&gt; or &lt;code&gt;make_answer![];&lt;/code&gt;.</source>
          <target state="translated">这些宏只能在&lt;a href=&quot;items/modules&quot;&gt;模块中&lt;/a&gt;调用。甚至不能调用它们来创建&lt;a href=&quot;statements#item-declarations&quot;&gt;项目声明语句&lt;/a&gt;。此外，必须使用大括号而不使用分号或使用分号后跟分号来调用它们。例如， &lt;code&gt;make_answer&lt;/code&gt; 从前面的例子可被调用 &lt;code&gt;make_answer!{}&lt;/code&gt; ， &lt;code&gt;make_answer!();&lt;/code&gt; 或 &lt;code&gt;make_answer![];&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5391198458bfd8d81a447bc30f66734e6f03394d" translate="yes" xml:space="preserve">
          <source>These markers can be combined, so &lt;code&gt;unsafe extern &quot;stdcall&quot; fn()&lt;/code&gt; is a valid type.</source>
          <target state="translated">这些标记可以组合，因此 &lt;code&gt;unsafe extern &quot;stdcall&quot; fn()&lt;/code&gt; 是有效类型。</target>
        </trans-unit>
        <trans-unit id="8c3ea3ec32e230deeef1943701b442105e65b661" translate="yes" xml:space="preserve">
          <source>These operators cannot be overloaded.</source>
          <target state="translated">这些运算符不能过载。</target>
        </trans-unit>
        <trans-unit id="12f02bfbd76d4dd6ccf6a1d0f95634f64537447a" translate="yes" xml:space="preserve">
          <source>These point to memory &lt;em&gt;owned by some other value&lt;/em&gt;. When a shared reference to a value is created it prevents direct mutation of the value. &lt;a href=&quot;../interior-mutability&quot;&gt;Interior mutability&lt;/a&gt; provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written &lt;code&gt;&amp;amp;type&lt;/code&gt;, or &lt;code&gt;&amp;amp;'a type&lt;/code&gt; when you need to specify an explicit lifetime. Copying a reference is a &quot;shallow&quot; operation: it involves only copying the pointer itself, that is, pointers are &lt;code&gt;Copy&lt;/code&gt;. Releasing a reference has no effect on the value it points to, but referencing of a &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary value&lt;/a&gt; will keep it alive during the scope of the reference itself.</source>
          <target state="translated">这些指向&lt;em&gt;由其他值拥有的&lt;/em&gt;内存。创建对值的共享引用时，它可以防止值的直接突变。&lt;a href=&quot;../interior-mutability&quot;&gt;内部可变性&lt;/a&gt;在某些情况下为此提供了例外。顾名思义，可以存在任意数量的共享引用。当您需要指定显式生存期时，共享引用类型将写为 &lt;code&gt;&amp;amp;type&lt;/code&gt; 或 &lt;code&gt;&amp;amp;'a type&lt;/code&gt; 。复制引用是一项&amp;ldquo;浅&amp;rdquo;操作：它仅涉及复制指针本身，即，指针为 &lt;code&gt;Copy&lt;/code&gt; 。释放引用对其所指向的值没有影响，但是引用&lt;a href=&quot;../expressions#temporaries&quot;&gt;临时值&lt;/a&gt;将使其在引用本身的范围内保持活动状态。</target>
        </trans-unit>
        <trans-unit id="3fc236a778b843e2aeed416fa4b2cc9e1a08823c" translate="yes" xml:space="preserve">
          <source>These point to memory &lt;em&gt;owned by some other value&lt;/em&gt;. When a shared reference to a value is created it prevents direct mutation of the value. &lt;a href=&quot;../interior-mutability&quot;&gt;Interior mutability&lt;/a&gt; provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written &lt;code&gt;&amp;amp;type&lt;/code&gt;, or &lt;code&gt;&amp;amp;'a type&lt;/code&gt; when you need to specify an explicit lifetime. Copying a reference is a &quot;shallow&quot; operation: it involves only copying the pointer itself, that is, pointers are &lt;code&gt;Copy&lt;/code&gt;. Releasing a reference has no effect on the value it points to, but referencing of a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; will keep it alive during the scope of the reference itself.</source>
          <target state="translated">这些指向&lt;em&gt;由其他值拥有的&lt;/em&gt;内存。当创建对值的共享引用时，它将防止值的直接突变。&lt;a href=&quot;../interior-mutability&quot;&gt;内部可变性&lt;/a&gt;在某些情况下为此提供了例外。顾名思义，可以存在任意数量的共享引用。当您需要指定显式生存期时，共享引用类型将写为 &lt;code&gt;&amp;amp;type&lt;/code&gt; 或 &lt;code&gt;&amp;amp;'a type&lt;/code&gt; 。复制引用是一种&amp;ldquo;浅&amp;rdquo;操作：它仅涉及复制指针本身，即指针为 &lt;code&gt;Copy&lt;/code&gt; 。释放引用对其所指向的值没有影响，但是引用&lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;临时值&lt;/a&gt;将使其在引用本身的范围内保持活动状态。</target>
        </trans-unit>
        <trans-unit id="e5e8141a80455494c8061b88eb7d52c5630351cf" translate="yes" xml:space="preserve">
          <source>These profile names might be familiar from the output of your builds:</source>
          <target state="translated">这些配置文件的名字可能在你的构建的输出中很熟悉。</target>
        </trans-unit>
        <trans-unit id="1ad28c50cb4ab16e536724b4f61aca4d7477f454" translate="yes" xml:space="preserve">
          <source>These safety checks can be relaxed for a section of the code by wrapping the unsafe instructions with an &lt;code&gt;unsafe&lt;/code&gt; block. For instance:</source>
          <target state="translated">这些安全检查可通过用包裹不安全的指令来放宽的代码的部分 &lt;code&gt;unsafe&lt;/code&gt; 块。例如：</target>
        </trans-unit>
        <trans-unit id="7c9be14b653ccb0fc4412a262bd32a7bb0662862" translate="yes" xml:space="preserve">
          <source>These traits, along with &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;, work in conjunction so that it is possible to &lt;strong&gt;round-trip&lt;/strong&gt; strings from Windows and back, with no loss of data, even if the strings are ill-formed UTF-16.</source>
          <target state="translated">这些特性与&lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;一起使用，以便即使Windows字符串格式不正确，也可以从Windows &lt;strong&gt;来回&lt;/strong&gt;传递字符串，而不会丢失数据。</target>
        </trans-unit>
        <trans-unit id="0cc726c49519e90aab3de25bfe65c626d294217a" translate="yes" xml:space="preserve">
          <source>These two cases are surprisingly powerful for creating module hierarchies exposing public APIs while hiding internal implementation details. To help explain, here's a few use cases and what they would entail:</source>
          <target state="translated">这两个案例对于创建暴露公共API的模块层次结构,同时隐藏内部实现细节来说,是出奇的强大。为了帮助解释,这里有几个用例以及它们会带来什么。</target>
        </trans-unit>
        <trans-unit id="8ac19292e9dd15d2d45f1f79b996a19bf6206f30" translate="yes" xml:space="preserve">
          <source>These two examples illustrate the problem:</source>
          <target state="translated">这两个例子说明了这个问题。</target>
        </trans-unit>
        <trans-unit id="dca9d4b1de7c5a2be4c4d5727e7917fd8aab654c" translate="yes" xml:space="preserve">
          <source>These two formatting traits have distinct purposes:</source>
          <target state="translated">这两种格式特征有不同的目的。</target>
        </trans-unit>
        <trans-unit id="742fffc208f85aff3d0f6f3059eddfffa585c4ab" translate="yes" xml:space="preserve">
          <source>These two functions might be implemented in Rust as follows. Here, the &lt;code&gt;struct Foo*&lt;/code&gt; type from C is translated to &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt;, which captures the ownership constraints. Note also that the nullable argument to &lt;code&gt;foo_delete&lt;/code&gt; is represented in Rust as &lt;code&gt;Option&amp;lt;Box&amp;lt;Foo&amp;gt;&amp;gt;&lt;/code&gt;, since &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; cannot be null.</source>
          <target state="translated">这两个功能可以在Rust中实现，如下所示。在这里，来自C的 &lt;code&gt;struct Foo*&lt;/code&gt; 类型被转换为 &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; ，它捕获了所有权约束。还要注意，由于 &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; 不能为null ，因此 &lt;code&gt;foo_delete&lt;/code&gt; 的可为null的参数在Rust中表示为 &lt;code&gt;Option&amp;lt;Box&amp;lt;Foo&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f982f08c4e46524b8318daa35d1f6508b56f9c5" translate="yes" xml:space="preserve">
          <source>These two terms are often used interchangeably, and what they are attempting to convey is the answer to the question &quot;Can this item be used at this location?&quot;</source>
          <target state="translated">这两个术语经常交替使用,它们所要表达的是对 &quot;这个项目能否在这个地点使用?&quot;这个问题的回答。</target>
        </trans-unit>
        <trans-unit id="327e657798ef3a0fe98594c42be8998daff24b69" translate="yes" xml:space="preserve">
          <source>These types provide access to the underlying data through references to the type of that data. They are said to be &amp;lsquo;borrowed as&amp;rsquo; that type. For instance, a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be borrowed as &lt;code&gt;T&lt;/code&gt; while a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be borrowed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">这些类型通过对数据类型的引用来提供对基础数据的访问。据说它们是&amp;ldquo;借来的&amp;rdquo;那种类型的。例如，可以将&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;T&lt;/code&gt; 借用，而可以将&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;str&lt;/code&gt; 借用。</target>
        </trans-unit>
        <trans-unit id="a24b18110788da060d08a87d6e0370b2f3f11b2d" translate="yes" xml:space="preserve">
          <source>These will always be ORed with &lt;code&gt;CREATE_UNICODE_ENVIRONMENT&lt;/code&gt;.</source>
          <target state="translated">这些将始终与 &lt;code&gt;CREATE_UNICODE_ENVIRONMENT&lt;/code&gt; 进行&amp;ldquo;或&amp;rdquo;运算。</target>
        </trans-unit>
        <trans-unit id="4d9283345c9b012905e98bac4c4ff6bf77874d49" translate="yes" xml:space="preserve">
          <source>They are &lt;code&gt;'static&lt;/code&gt; because they're stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">它们是 &lt;code&gt;'static&lt;/code&gt; 因为它们直接存储在最终二进制文件中，因此在 &lt;code&gt;'static&lt;/code&gt; 持续时间内有效。</target>
        </trans-unit>
        <trans-unit id="86b3fa967e9ddc952d15703cad09add6ed0fe12c" translate="yes" xml:space="preserve">
          <source>They are never allowed before:</source>
          <target state="translated">他们以前从不允许。</target>
        </trans-unit>
        <trans-unit id="a91c6bc4d714ec79e34b3b499dac181a1c8a5b61" translate="yes" xml:space="preserve">
          <source>They are written as &lt;code&gt;impl&lt;/code&gt; followed by a set of trait bounds.</source>
          <target state="translated">它们被写为 &lt;code&gt;impl&lt;/code&gt; ,后跟一组特征边界。</target>
        </trans-unit>
        <trans-unit id="d6f10b3f0570fbded7ab662d2bff2e38078266a6" translate="yes" xml:space="preserve">
          <source>They can be used as targets of transmutes in unsafe code for manipulating the raw representations directly.</source>
          <target state="translated">它们可以在不安全的代码中作为转码的目标,直接操作原始表示。</target>
        </trans-unit>
        <trans-unit id="81857ae63bf1641ca750521f716199457233e82d" translate="yes" xml:space="preserve">
          <source>They never take parameters and never return types.</source>
          <target state="translated">它们从不接受参数,也从不返回类型。</target>
        </trans-unit>
        <trans-unit id="3eb09871747750e3ee06b75fa9a63f7cfbbd1d29" translate="yes" xml:space="preserve">
          <source>Thin pointers are &quot;simple&quot; pointers: they are purely a reference to a memory address.</source>
          <target state="translated">薄指针是 &quot;简单 &quot;的指针:它们纯粹是对内存地址的引用。</target>
        </trans-unit>
        <trans-unit id="4d4a58caf1c3fd49804715c525d371aaf6cc87c9" translate="yes" xml:space="preserve">
          <source>Things can get a little tricky once you start intermingling the two types of positional specifiers. The &quot;next argument&quot; specifier can be thought of as an iterator over the argument. Each time a &quot;next argument&quot; specifier is seen, the iterator advances. This leads to behavior like this:</source>
          <target state="translated">一旦你开始混合两种类型的位置指定符,事情就会变得有点棘手。&quot;下一个参数 &quot;指定符可以被认为是参数的迭代器。每次看到 &quot;下一个参数 &quot;指定符,迭代器就会前进。这就导致了这样的行为。</target>
        </trans-unit>
        <trans-unit id="9af9ddcb5af382b3006b61fbf3f41b42b2b57797" translate="yes" xml:space="preserve">
          <source>Think of a &lt;code&gt;match&lt;/code&gt; expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a &lt;code&gt;match&lt;/code&gt;, and at the first pattern the value &amp;ldquo;fits,&amp;rdquo; the value falls into the associated code block to be used during execution.</source>
          <target state="translated">可以将 &lt;code&gt;match&lt;/code&gt; 表达式想像成硬币分类机：硬币沿着轨道滑动，轨道上有各种大小的孔，每枚硬币都从它遇到的第一个孔中掉落。以相同的方式，值通过 &lt;code&gt;match&lt;/code&gt; 中的每个模式，并且在第一个模式中值&amp;ldquo;适合&amp;rdquo;，该值落入要在执行期间使用的关联代码块。</target>
        </trans-unit>
        <trans-unit id="1fdd8b4a97ce68f59e33b3f6b509748be1aa6f2f" translate="yes" xml:space="preserve">
          <source>Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you&amp;rsquo;ve been seated to find you.</source>
          <target state="translated">想想坐在餐厅里。输入时，说明组中的人数，工作人员会找到一个适合所有人的空表，并带您到那里。如果您小组中的某人迟到，他们可以询问您在哪里坐下来找到您。</target>
        </trans-unit>
        <trans-unit id="0748eff7f6f3425a675a552a35d84af9fe1be56c" translate="yes" xml:space="preserve">
          <source>Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!</source>
          <target state="translated">从另一个角度思考这些关系,父节点应该拥有它的子节点:如果一个父节点被删除,它的子节点也应该被删除。然而,子节点不应该拥有它的父节点:如果我们放弃一个子节点,父节点应该仍然存在。这就是一个弱引用的案例!</target>
        </trans-unit>
        <trans-unit id="399cffdf26999603bae93a3715241addff90c419" translate="yes" xml:space="preserve">
          <source>Thinking in Terms of Lifetimes</source>
          <target state="translated">从寿命的角度思考</target>
        </trans-unit>
        <trans-unit id="7407b5aadd0d88118f5b7bf8fb59e7e1d6d93882" translate="yes" xml:space="preserve">
          <source>Third, the &lt;code&gt;run&lt;/code&gt; function now returns an &lt;code&gt;Ok&lt;/code&gt; value in the success case. We&amp;rsquo;ve declared the &lt;code&gt;run&lt;/code&gt; function&amp;rsquo;s success type as &lt;code&gt;()&lt;/code&gt; in the signature, which means we need to wrap the unit type value in the &lt;code&gt;Ok&lt;/code&gt; value. This &lt;code&gt;Ok(())&lt;/code&gt; syntax might look a bit strange at first, but using &lt;code&gt;()&lt;/code&gt; like this is the idiomatic way to indicate that we&amp;rsquo;re calling &lt;code&gt;run&lt;/code&gt; for its side effects only; it doesn&amp;rsquo;t return a value we need.</source>
          <target state="translated">第三，在成功情况下， &lt;code&gt;run&lt;/code&gt; 函数现在返回 &lt;code&gt;Ok&lt;/code&gt; 值。我们已经在签名中将 &lt;code&gt;run&lt;/code&gt; 函数的成功类型声明为 &lt;code&gt;()&lt;/code&gt; ，这意味着我们需要将单元类型值包装在 &lt;code&gt;Ok&lt;/code&gt; 值中。这种 &lt;code&gt;Ok(())&lt;/code&gt; 语法起初可能看起来有些奇怪，但是像这样使用 &lt;code&gt;()&lt;/code&gt; 是惯用的方式，它表明我们仅出于其副作用调用 &lt;code&gt;run&lt;/code&gt; 。它不会返回我们需要的值。</target>
        </trans-unit>
        <trans-unit id="5ed975d1877254eff4f647cec29b338bbca64ef4" translate="yes" xml:space="preserve">
          <source>Third, the standard library defines &lt;a href=&quot;prelude/index&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.</source>
          <target state="translated">第三，标准库定义了&lt;a href=&quot;prelude/index&quot;&gt;Rust Prelude&lt;/a&gt;，这是少量物品（主要是特征）的集合，这些物品被导入到每个板条箱的每个模块中。前奏中的特征无处不在，这使前奏文档成为学习图书馆的一个很好的切入点。</target>
        </trans-unit>
        <trans-unit id="2c016402b0d7abec88d04b55dd5a8f4c018ceb4a" translate="yes" xml:space="preserve">
          <source>Third, you see the &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; string. We pass this string as an argument to &lt;code&gt;println!&lt;/code&gt;, and the string is printed to the screen.</source>
          <target state="translated">第三，您看到的是 &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; 串。我们将此字符串作为参数传递给 &lt;code&gt;println!&lt;/code&gt; ，然后字符串将显示在屏幕上。</target>
        </trans-unit>
        <trans-unit id="756c69ab3ae5844d50aa9add76723030b90c2e84" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; will be an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if there's some sort of intermittent IO error during iteration.</source>
          <target state="translated">这个&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;将是一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果有迭代过程中某种间歇IO错误。</target>
        </trans-unit>
        <trans-unit id="45e5b6731a2eea68db70299dc76799ac1e3d8403" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;'s receiving half has disconnected, so the data could not be sent. The data is returned back to the callee in this case.</source>
          <target state="translated">此&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;的接收一半已断开连接，因此无法发送数据。在这种情况下，数据将返回给被调用方。</target>
        </trans-unit>
        <trans-unit id="e029dc532e12308a313b095f5b88bb0b2db85884" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;#[route]&lt;/code&gt; attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</source>
          <target state="translated">该 &lt;code&gt;#[route]&lt;/code&gt; 属性将由框架定义为程序宏。宏定义函数的签名如下所示：</target>
        </trans-unit>
        <trans-unit id="dc8fa4acf3fa662b100c7f01811572d66ca46b05" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Message&lt;/code&gt; enum will either be a &lt;code&gt;NewJob&lt;/code&gt; variant that holds the &lt;code&gt;Job&lt;/code&gt; the thread should run, or it will be a &lt;code&gt;Terminate&lt;/code&gt; variant that will cause the thread to exit its loop and stop.</source>
          <target state="translated">此 &lt;code&gt;Message&lt;/code&gt; 枚举将是一个 &lt;code&gt;NewJob&lt;/code&gt; 变量，该变量保存线程应运行的 &lt;code&gt;Job&lt;/code&gt; ，或者它将是 &lt;code&gt;Terminate&lt;/code&gt; 变量，它将导致线程退出其循环并停止。</target>
        </trans-unit>
        <trans-unit id="2ac2c44f291b0094f7e740b5540fe932bd4487e6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;../struct.btreemap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 是根据&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../struct.btreemap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt;方法构造的。</target>
        </trans-unit>
        <trans-unit id="c64bdd9b3fc3f77ac39443372876ff3d0846511f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;../struct.hashmap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这个 &lt;code&gt;enum&lt;/code&gt; 是从&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../struct.hashmap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt;方法构造的。</target>
        </trans-unit>
        <trans-unit id="df201a49abc9a95b4b9db82dff3855ec3856b74c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;struct.btreemap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这个 &lt;code&gt;enum&lt;/code&gt; 是根据&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreemap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt;方法构造的。</target>
        </trans-unit>
        <trans-unit id="78b77c0bae34af9fbe0dd6db2b8a03354e7c6a07" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;struct.hashmap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这个 &lt;code&gt;enum&lt;/code&gt; 是从&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.hashmap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt;方法构造的。</target>
        </trans-unit>
        <trans-unit id="e4ed5614390f8cd7c309ba2eff1ecf5972023c00" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed through the &lt;a href=&quot;../struct.hashmap#method.raw_entry_mut&quot;&gt;&lt;code&gt;raw_entry_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, then calling one of the methods of that &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt;&lt;code&gt;RawEntryBuilderMut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 是通过&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashmap#method.raw_entry_mut&quot;&gt; &lt;code&gt;raw_entry_mut&lt;/code&gt; &lt;/a&gt;方法构造的，然后调用该&lt;a href=&quot;struct.rawentrybuildermut&quot;&gt; &lt;code&gt;RawEntryBuilderMut&lt;/code&gt; &lt;/a&gt;的方法之一。</target>
        </trans-unit>
        <trans-unit id="e49b2cde36d96ef41241461160aaa7f39ffe4733" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed through the &lt;a href=&quot;struct.hashmap#method.raw_entry_mut&quot;&gt;&lt;code&gt;raw_entry_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, then calling one of the methods of that &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt;&lt;code&gt;RawEntryBuilderMut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 是通过&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.raw_entry_mut&quot;&gt; &lt;code&gt;raw_entry_mut&lt;/code&gt; &lt;/a&gt;方法构造的，然后调用该&lt;a href=&quot;struct.rawentrybuildermut&quot;&gt; &lt;code&gt;RawEntryBuilderMut&lt;/code&gt; &lt;/a&gt;的方法之一。</target>
        </trans-unit>
        <trans-unit id="484cddb60aced3f0fd2c66d36c2d02b11434898c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is created by iterating over &lt;a href=&quot;struct.components&quot;&gt;&lt;code&gt;Components&lt;/code&gt;&lt;/a&gt;, which in turn is created by the &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 是通过对&lt;a href=&quot;struct.components&quot;&gt; &lt;code&gt;Components&lt;/code&gt; &lt;/a&gt;进行迭代来创建的，而Components又由&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.path#method.components&quot;&gt; &lt;code&gt;components&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="94a9ddcdadd6c80893c9aa067a5c5342d16c5ca8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is slightly awkward: it will never actually exist. This error is part of the type signature of the implementation of &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. The return type of &lt;a href=&quot;../str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt;, requires that an error be defined, but, given that a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can always be made into a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; without error, this type will never actually be returned. As such, it is only here to satisfy said signature, and is useless otherwise.</source>
          <target state="translated">这个 &lt;code&gt;enum&lt;/code&gt; 有点尴尬：它实际上不会存在。这个错误的实现的类型签名的一部分&lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。返回类型&lt;a href=&quot;../str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;from_str&lt;/code&gt; &lt;/a&gt;，需要定义一个错误，但是，鉴于始终可以将一个&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;正确地转换为一个新的&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; 且&lt;/a&gt;没有错误，因此这种类型实际上不会返回。这样，只有在这里满足所述签名，否则是没有用的。</target>
        </trans-unit>
        <trans-unit id="7bafcd26f5f930140b3a1e3e5a967a8f857b2aca" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as the return type for &lt;a href=&quot;../primitive.f32#method.classify&quot;&gt;&lt;code&gt;f32::classify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64#method.classify&quot;&gt;&lt;code&gt;f64::classify&lt;/code&gt;&lt;/a&gt;. See their documentation for more.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 用作&lt;a href=&quot;../primitive.f32#method.classify&quot;&gt; &lt;code&gt;f32::classify&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.f64#method.classify&quot;&gt; &lt;code&gt;f64::classify&lt;/code&gt; &lt;/a&gt;的返回类型。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="779a09142baa1b4c0c25a858cbd603a82e00fb14" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;new&lt;/code&gt; function creates a new, empty string. You&amp;rsquo;ll find a &lt;code&gt;new&lt;/code&gt; function on many types, because it&amp;rsquo;s a common name for a function that makes a new value of some kind.</source>
          <target state="translated">此 &lt;code&gt;new&lt;/code&gt; 函数创建一个新的空字符串。您会发现许多类型的 &lt;code&gt;new&lt;/code&gt; 函数，因为它是产生某种新值的函数的通用名称。</target>
        </trans-unit>
        <trans-unit id="87637c77d83fe48f3ea16980edd287161d7c7814" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.drain&quot;&gt;&lt;code&gt;BinaryHeap::drain()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../struct.binaryheap#method.drain&quot;&gt; &lt;code&gt;BinaryHeap::drain()&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="710441e6744b3faabea4c32e6f7f503845ba9cca" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.drain_sorted&quot;&gt;&lt;code&gt;BinaryHeap::drain_sorted()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../struct.binaryheap#method.drain_sorted&quot;&gt; &lt;code&gt;BinaryHeap::drain_sorted()&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="4f1beb7abacff5cc6b2aa66c11f692cb37b24895" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.into_iter&quot;&gt;&lt;code&gt;BinaryHeap::into_iter()&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../struct.binaryheap#method.into_iter&quot;&gt; &lt;code&gt;BinaryHeap::into_iter()&lt;/code&gt; &lt;/a&gt;创建（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="19187356eb493c3adfe1d6a3c45949ebe90718ce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.iter&quot;&gt;&lt;code&gt;BinaryHeap::iter()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../struct.binaryheap#method.iter&quot;&gt; &lt;code&gt;BinaryHeap::iter()&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="ea9db5c8e782224fe1f85e1a720f71f672146c1f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.linkedlist#method.iter&quot;&gt;&lt;code&gt;LinkedList::iter()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../struct.linkedlist#method.iter&quot;&gt; &lt;code&gt;LinkedList::iter()&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="365f4e6ab5c3e3c131d4abcf66926cc6d747c3d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.linkedlist#method.iter_mut&quot;&gt;&lt;code&gt;LinkedList::iter_mut()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.linkedlist#method.iter_mut&quot;&gt; &lt;code&gt;LinkedList::iter_mut()&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1a70b0d26c2b2bbcfc4bcd9397bbda3af835a2c7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;fn.pending&quot;&gt;&lt;code&gt;pending()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.pending&quot;&gt; &lt;code&gt;pending()&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c0010fa18c26eb3966e8839f207aad6f2ebfdb7b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;fn.ready&quot;&gt;&lt;code&gt;ready()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.ready&quot;&gt; &lt;code&gt;ready()&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="ffa5a9dc90635ee7464510b7b23324baed884a35" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt;&lt;code&gt;CString::into_string()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.cstring#method.into_string&quot;&gt; &lt;code&gt;CString::into_string()&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="3a98a7a0b86bcb3ca3daaeceee9ee6241f18b9ac" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;Vec::drain&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.vec#method.drain&quot;&gt; &lt;code&gt;Vec::drain&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="bc70d905416c075e472dedc5615406f53740db49" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;Iterator::chain&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;Iterator::chain&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="05ed5bb9307267a5e340c3a66e14a4d93b6b2120" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;Iterator::flat_map&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt; &lt;code&gt;Iterator::flat_map&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f04b21219d876a2efb53733e31a16e7043a08a65" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt;创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b34a5adfa6d1f401a24be7fc9f321c6bf3e63061" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;Iterator::zip&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这个 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;trait.iterator#method.zip&quot;&gt; &lt;code&gt;Iterator::zip&lt;/code&gt; &lt;/a&gt;创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7f5b4ce43667b25dc7c0338aa4a9d348ba82ad8b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c15db34b76ad48367be1e50fb80a630f7544ccea" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="8af255e3f384d8c63465da3dc3dea71b03731e21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="4e4d6244bc27d0d285cfa54d11b50c87b3df5b10" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2755a24920256090117fe1db3482d286484fdff1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="04527249225c0957b4a2dad0cb713b606320b989" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_debug&quot;&gt;&lt;code&gt;escape_debug&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.char#method.escape_debug&quot;&gt; &lt;code&gt;escape_debug&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="db12edeeb870acc98aa06b33b39a8bb3d306d517" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../primitive.char#method.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="cc81870e647a4c66d45285572c3d1fa6c0473baa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.char#method.escape_unicode&quot;&gt; &lt;code&gt;escape_unicode&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1fe84815a63364d86bf9311c9ac78e8bdb20701b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.char#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="27eb64d64fc617e07c6f09849f8a1efd113c9e7c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.to_uppercase&quot;&gt;&lt;code&gt;to_uppercase&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.char#method.to_uppercase&quot;&gt; &lt;code&gt;to_uppercase&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="23afadfd08d170366a910c9a9eb67a47d53c58e4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.binaryheap#method.peek_mut&quot;&gt;&lt;code&gt;peek_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.binaryheap#method.peek_mut&quot;&gt; &lt;code&gt;peek_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="600939e3b3f6d85fd06ffcedc1a550628427f081" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.into_keys&quot;&gt;&lt;code&gt;into_keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.btreemap#method.into_keys&quot;&gt; &lt;code&gt;into_keys&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="a19a52d05723c4f0efb8bd5c1f2d68262e4edffd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.into_values&quot;&gt;&lt;code&gt;into_values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.btreemap#method.into_values&quot;&gt; &lt;code&gt;into_values&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="3045bd58f26065df50d0790fb43c60769a4e62d7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../struct.btreemap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="946c012883128ea40231fbdcbdc1a628bae08f1e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.btreemap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="74b659096d73f7bbdedbdc8e5c8915fc609d68c8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.btreemap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7dc938cc7827ae09ff7a33e57fec9dc1ea67e47b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.btreemap#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d48ee20f7abe01686d61e8b564a9e2e8709cc261" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.range_mut&quot;&gt;&lt;code&gt;range_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.btreemap#method.range_mut&quot;&gt; &lt;code&gt;range_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7a6de9bc6d12983868c379e76acf4b7b905e3489" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../struct.btreemap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d705a35c8c3bfa5da6919c4661f259de8364f195" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.btreemap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="61f91f31f3bd872cb2fbd24fadf5b75ed09458a4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.btreeset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2e1d52e053b2cbaba0cc8f9612b34ec9509994b9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.btreeset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="954e936cd5243200003d839739bf6bf3e1d2ccbf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.btreeset#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="3c45f5db49cb3dd47f14e3527ee6323bafd674c6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../struct.btreeset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="53de499d6a94e0c9ad1a96537dd61a0c1c130aff" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.btreeset#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c55b8ab08d80bad9c8193338715f67b024c7ee2c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.btreeset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="34001f1785210d90fc10385cb9a1251eed89d761" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../struct.btreeset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="6645dd14e44dee8f928de9c50e60665ec2facacc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.hashmap#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 中&lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="305c738458e34e26e1734f78e5058c6e48d5e7b3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.drain_filter&quot;&gt;&lt;code&gt;drain_filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../struct.hashmap#method.drain_filter&quot;&gt; &lt;code&gt;drain_filter&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="b1bd35d1cd7726da10e33bba8ce8805e4d7d627f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.into_keys&quot;&gt;&lt;code&gt;into_keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashmap#method.into_keys&quot;&gt; &lt;code&gt;into_keys&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="774e7d6c5f4fef0d016668cc714ac56903ab5226" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.into_values&quot;&gt;&lt;code&gt;into_values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashmap#method.into_values&quot;&gt; &lt;code&gt;into_values&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="50fc5746ddfb14a344eb233b7116066c64b4c8c4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashmap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="a09bcc28d870cda3d50f44865ac154f6c773dbcc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashmap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b3485f5d7a78d5f8bb97e7e58730359d2b64777f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashmap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b03cef3dcf96a8183c51975b4910dd74475edf71" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashmap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="53c20090054cf2ac21ecbfded86e3ada5a3c452b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashmap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="92667a13f4b88964b565e8c1428280771a1f58ae" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="8b53023bc8c2f123d3aa8476357c0065c17e5bc5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.hashset#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2f3f79e8e523849b31d44d7222fee9b2cd8c8e08" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.drain_filter&quot;&gt;&lt;code&gt;drain_filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../struct.hashset#method.drain_filter&quot;&gt; &lt;code&gt;drain_filter&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="e0c7b733ae497921c7ee1e58f9d3737d0bc5abf0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7faf396162375db95ee521b7f44471b3dddb5889" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="14c7d030bde45fb3ec268ba764828f4e1837eb77" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="fce08bc41dc77fbc27830928bbf1bf5b41c36d96" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.hashset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="265bcebc25d757509c4b717937ff253a8b8647e5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.linkedlist#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.linkedlist#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="ae30ff0dcb4ca01b32359edc18207fe2e8799225" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.vecdeque#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d0622f000a63c5582f4bf61c6400ba69e79c3e9b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.vecdeque#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="9c39e95770f6e995aeb4f6547fcd0d3b5d042bb7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.vecdeque#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="bd4b5977c5727925e70d8f76687b773a1fdddf98" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;super::VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;super::VecDeque&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.vecdeque#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="a2950ed2e16c6715dede3635ac1905a727cb8d87" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;../struct.vecdeque#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="12f5ffb0f8059183926ec32cc230f390a47befb7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;super::VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;super::VecDeque&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../struct.vecdeque#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="df020e51f3f4500bc1f8be7714b7e55fb7923be6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.into_iter&quot;&gt;&lt;code&gt;Option::into_iter&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;enum.option#method.into_iter&quot;&gt; &lt;code&gt;Option::into_iter&lt;/code&gt; &lt;/a&gt;函数创建。</target>
        </trans-unit>
        <trans-unit id="ed85839c71b9b41d697c086ba092e08ee354cb7a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.iter&quot;&gt;&lt;code&gt;Option::iter&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;enum.option#method.iter&quot;&gt; &lt;code&gt;Option::iter&lt;/code&gt; &lt;/a&gt;函数创建。</target>
        </trans-unit>
        <trans-unit id="f832fbc0a1897989e972bccbdf14ab8c06df2a8b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.iter_mut&quot;&gt;&lt;code&gt;Option::iter_mut&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;enum.option#method.iter_mut&quot;&gt; &lt;code&gt;Option::iter_mut&lt;/code&gt; &lt;/a&gt;函数创建的。</target>
        </trans-unit>
        <trans-unit id="29c33d9d981b66ee3e763795fb7a865338012f4a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f3c09e42d5e7d0d1aee87da5c6a31ae546137c1a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="583b1959fdeeb9dda8ffebe215f3e85158c8bc2e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2441b8d854782799a5af16365bc544396e7a30e1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.from_fn&quot;&gt;&lt;code&gt;iter::from_fn()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.from_fn&quot;&gt; &lt;code&gt;iter::from_fn()&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="be7c13071482b2c3923f2e736bd014b0019bfa3c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.from_fn&quot;&gt;&lt;code&gt;iter::from_fn&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.from_fn&quot;&gt; &lt;code&gt;iter::from_fn&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="94d40c5fdbd8b948ffc41faa923b27505f807e3f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once()&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b2d0d0c848c068f0195f43a41a604e9ed15435ea" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="8bb25d152dad7b00112a30e9ef34eaf19e870657" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once_with&quot;&gt;&lt;code&gt;once_with()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.once_with&quot;&gt; &lt;code&gt;once_with()&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="582110272ac53674cd7341259d0b80e92c531007" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once_with&quot;&gt;&lt;code&gt;once_with&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.once_with&quot;&gt; &lt;code&gt;once_with&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c2e53dc5041d32296d06a4432a5dc5ef029bc8fa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat()&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f750c0f224dd89d4b261959a2e6c2e0e53f46764" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="66f063558b4204049186f9de5672edf7bb33b08f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with()&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="937c3c66fd7a919cfaca746517ec0915d37c92b5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="aab81d3f94443c5e362d592846bb5f615688f696" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;函数和&lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="721e1f5adffa977a66b66d77bbfc4af0a336248f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.successors&quot;&gt;&lt;code&gt;iter::successors()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.successors&quot;&gt; &lt;code&gt;iter::successors()&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2bba3b7b1d3ddee116465f88074412d173b46ad3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.successors&quot;&gt;&lt;code&gt;successors&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.successors&quot;&gt; &lt;code&gt;successors&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="750025df63cee4f9476b600e410c271d4dc26282" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.binaryheap#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e18a9e9bb705ac20d27c1b54b01a06909af9f5aa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.binaryheap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="41506355b29f22e9b8811a8d2b60d92fed5ea6d5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.binaryheap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e9675a6cb1b893dbb78e5cb9089bf79a6f234027" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.peek_mut&quot;&gt;&lt;code&gt;peek_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.binaryheap#method.peek_mut&quot;&gt; &lt;code&gt;peek_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="a3e0e69a8fe926bff3713eb4f60caf8069defb24" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreemap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="514e5b56a0002147cc9f7ac8a43433a6a65225d9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreemap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f716d42a3e459fcee9b6f36db5dc5c8168d480b5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreemap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1f4535b44687ead67d4ff87d0edaec473f93f580" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreemap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d31858adce6dfcdec67ca057f391304b96efe373" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreemap#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="beff4242dfe6af7e412bdc0cbf43b9ab3e974e59" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.range_mut&quot;&gt;&lt;code&gt;range_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreemap#method.range_mut&quot;&gt; &lt;code&gt;range_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="61ccad7bbc2caef64224c9df6c46da6d30f71236" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreemap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="32f656567e75b1c61207668fdcd4fee681fb158f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreemap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="954c25018729177ec5a7cd425af966f38ad45de9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreeset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="311036e0ac34eb0ce755d849d1ee9dcf0da2fa6d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreeset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="cd64d67da228b8471603fbb0b2df44241b404edf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreeset#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b2d51f3eed3f11c0fe92a56c05aa30ba63101b5b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreeset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="4952396a08a80db78884e7472ef4fcdc98f30b89" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreeset#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="03065ec43e94189db8db5b6c22bcd04c4d9e3d5f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreeset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="06c95a89e54823ffe6dff81406fba47c36a4dc6c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreeset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="512853e49000d203253875f2ca8249d15ea7353e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt;&lt;code&gt;into_string&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.cstring#method.into_string&quot;&gt; &lt;code&gt;into_string&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="faa8b1395fad10dcbfc423094256b61e6d205866" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.hashmap#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 中&lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="fa6f9e85339b1a29569ed12beacf3087627ad001" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.drain_filter&quot;&gt;&lt;code&gt;drain_filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.hashmap#method.drain_filter&quot;&gt; &lt;code&gt;drain_filter&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="0800ef408d255e0937c01c82d43d77be20d45343" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="4705ba350d7c8c1275936b511a97c6cd8aba318f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.into_keys&quot;&gt;&lt;code&gt;into_keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.into_keys&quot;&gt; &lt;code&gt;into_keys&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f1b4e82dfb1dab57d4444a18c5890a931db0dff2" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.into_values&quot;&gt;&lt;code&gt;into_values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.into_values&quot;&gt; &lt;code&gt;into_values&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0608e2c033c0bbc3bd28c971540c2b970498e946" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.hashmap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0d3d57080a3c9ea2da73c2cffa1d26e9e4a02705" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="24475378883de5203105dba62856d4abf99e3544" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="9d0295f8ffe26eaa9c9d5777a9c742f561e9829a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.hashmap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="29c5ae45f57800a030c9d11a0a477ba58c24833e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7513d477a389bb5cb5a430e327122b1af796c3fd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="86301ec13deb5075922cbd995e23feac257a9d81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.hashset#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="df914df61467a304488c25085aad0396f75c08a3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.drain_filter&quot;&gt;&lt;code&gt;drain_filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.hashset#method.drain_filter&quot;&gt; &lt;code&gt;drain_filter&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="3ebb8dfa5cf525c05fe6f08d21ee543480482796" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b4fe9a5189ce4199be4828187c5779ad99c77194" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d0c83c37cc0812ff3b4a5b7bded4f379cae37eda" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2eb620627c49c8366b81c168c1e2da24ad0ba352" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="150f20ec4e603307925c0aee02dfd449f9a510cf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2d89966c70887a327798b302de57b322446d731d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.linkedlist#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="58115891c3a0ac7312c6ea2a52ac61968cc4906c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.linkedlist#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f0659eea6bed999fa3680d324080162cd5e8a132" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.linkedlist#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0aae0dd86db056d40eff085617d4cf75e5ca4cd1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.ancestors&quot;&gt;&lt;code&gt;ancestors&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.path#method.ancestors&quot;&gt; &lt;code&gt;ancestors&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="678416258ee794f65fdd4a1cd12a337537c5938c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.path#method.components&quot;&gt; &lt;code&gt;components&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f7998e185f302bc549a882f13518743e61ee46ed" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.path#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2cd612b3807ec02a5c6d66e1f1c48af60492df83" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt;&lt;code&gt;strip_prefix&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt; &lt;code&gt;strip_prefix&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="088542ff6ce5390ea17e8720dd59c0a74e6b5452" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;TcpListener::incoming&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt; &lt;code&gt;TcpListener::incoming&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1b5816e88e64a2f2821568b7180ce9b608c65d11" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1f4d8367fad76ae04d5e19a5385a27f59c0aaf13" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.vec#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f3bc5ceaa1713a6dc6144c9424b5691a097a496" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.vecdeque#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b345fb68ea41cbf5a17dfb308f9d1a6e9820cc06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.vecdeque#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="5c15922d5946c2fdadf8c55e5b28d91817f56274" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.vecdeque#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="6dcf16ee1a7554354a5a44529cc2c194dcf3a513" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.vecdeque#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c378dde9d0a6525bd047bdf905231180a99f3491" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b7e65fcf3ce565260fcf0013397e867c30f8522f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.cloned&quot;&gt;&lt;code&gt;cloned&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.cloned&quot;&gt; &lt;code&gt;cloned&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f5b898ca8f830f2683dbb470bc2669fdcc151557" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.copied&quot;&gt;&lt;code&gt;copied&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.copied&quot;&gt; &lt;code&gt;copied&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="6792715370c3a92e84d28374f5832cff5986bd03" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.cycle&quot;&gt;&lt;code&gt;cycle&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.cycle&quot;&gt; &lt;code&gt;cycle&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="eef34875ae92021a31b6bedf0e5ef3ef03a55346" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.enumerate&quot;&gt; &lt;code&gt;enumerate&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="9fb0d2f619194cb6fd2c5912cd0ab4f8aa1436b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7b10e5f9bf83042ee3e1d8a41324ee574deb204c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.filter_map&quot;&gt;&lt;code&gt;filter_map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.filter_map&quot;&gt; &lt;code&gt;filter_map&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e8efe5c2b3a46412d14b079c4efde7503ec17047" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt; &lt;code&gt;flat_map&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="06ac94503cae6df0f4ea2938d28112afa01fe8f9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b8c0c8898fdf0a69bb894be3b262576aa94693ed" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;fuse&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="16538eabad39936ba061176498ea306e212f6f92" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="a0b5389b001bb0bbe98e28bcb36e5aebd8a66723" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b50dc251fa4cf84989ab18f9a900ba7288f0b114" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.map_while&quot;&gt;&lt;code&gt;map_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.map_while&quot;&gt; &lt;code&gt;map_while&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2a63b8c96bdf4e631228dfff76c51a72895aa1c2" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.peekable&quot;&gt;&lt;code&gt;peekable&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.peekable&quot;&gt; &lt;code&gt;peekable&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="77b9d3dc967cfc65e7923a1d25d998d0359bf8da" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.rev&quot;&gt;&lt;code&gt;rev&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.rev&quot;&gt; &lt;code&gt;rev&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0c534d67b85da417a0620daeb199532327c51e03" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.scan&quot;&gt; &lt;code&gt;scan&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d55ea7e68cc78050a3929f56a9674ef3cbe9031c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.skip&quot;&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.skip&quot;&gt; &lt;code&gt;skip&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="752b3b9ee442b1ede4f01e7280612ee155b893b6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.skip_while&quot;&gt;&lt;code&gt;skip_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.skip_while&quot;&gt; &lt;code&gt;skip_while&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e4194d8e81f0d479a0971b522dc10170de8177ce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.step_by&quot;&gt;&lt;code&gt;step_by&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.step_by&quot;&gt; &lt;code&gt;step_by&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="ae2f32a2383fa23779c3295dfc6285ad6be64c98" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="431a8793b970c81fcc0ab5b7d979a63311ac642a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f6420f53e024dcbfd568efb25b94839f7a579e39" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="8be96a57f8e063c35aa0cfee79161d9fbe1f4027" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;code&gt;into_iter&lt;/code&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;上的 &lt;code&gt;into_iter&lt;/code&gt; 方法创建的（由&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;特性提供）。</target>
        </trans-unit>
        <trans-unit id="75da1f33c5a1b29ca9ce3084de81aca63a2c8c06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is used to represent the exit status of a child process. Child processes are created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct and their exit status is exposed through the &lt;a href=&quot;struct.command#method.status&quot;&gt;&lt;code&gt;status&lt;/code&gt;&lt;/a&gt; method, or the &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 用于表示子进程的退出状态。子进程是通过&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt;结构创建的，其退出状态通过&lt;a href=&quot;struct.command#method.status&quot;&gt; &lt;code&gt;status&lt;/code&gt; &lt;/a&gt;方法或&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt;进程的&lt;a href=&quot;struct.child#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;方法公开。</target>
        </trans-unit>
        <trans-unit id="5f5bb1decbaa26846cd44955c2f8ab7127199a37" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;use&lt;/code&gt; statement brings all public items defined in &lt;code&gt;std::collections&lt;/code&gt; into the current scope. Be careful when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined.</source>
          <target state="translated">该 &lt;code&gt;use&lt;/code&gt; 语句将 &lt;code&gt;std::collections&lt;/code&gt; 定义的所有公共项带入当前范围。使用glob运算符时要小心！Glob使得更难分辨作用域中的名称以及程序中使用的名称的定义位置。</target>
        </trans-unit>
        <trans-unit id="caecafb5a4fb0937d47c4a448338d709acd25fe7" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;channel&lt;/strong&gt; is currently empty, but the &lt;strong&gt;Sender&lt;/strong&gt;(s) have not yet disconnected, so data may yet become available.</source>
          <target state="translated">该&lt;strong&gt;通道&lt;/strong&gt;当前为空，但&lt;strong&gt;发件人&lt;/strong&gt;尚未断开连接，因此数据可能仍可用。</target>
        </trans-unit>
        <trans-unit id="8266d9d9a47bf63d7284fb3019e831be816c08a4" translate="yes" xml:space="preserve">
          <source>This Greek letter convention is usually just employed when the presence of a sequence is a technical detail; in particular, when we wish to &lt;em&gt;emphasize&lt;/em&gt; that we are operating on a sequence of token-trees, we will use the notation &quot;tt ...&quot; for the sequence, not a Greek letter.</source>
          <target state="translated">当序列的存在是技术细节时，通常只使用希腊字母约定。特别是，当我们希望&lt;em&gt;强调&lt;/em&gt;我们正在对令牌树序列进行操作时，我们将对该序列使用符号&amp;ldquo; tt ...&amp;rdquo;，而不是希腊字母。</target>
        </trans-unit>
        <trans-unit id="75b75d5ae6c1390e9d9181dd6cf33a8dbc7fda14" translate="yes" xml:space="preserve">
          <source>This alias exists for backwards compatibility, and may be eventually deprecated.</source>
          <target state="translated">这个别名的存在是为了向后兼容,最终可能会被废弃。</target>
        </trans-unit>
        <trans-unit id="6b20bc4e00b7823d1d79ae42b369f4aec802629c" translate="yes" xml:space="preserve">
          <source>This allows a program to terminate immediately and provide feedback to the caller of the program. &lt;code&gt;panic!&lt;/code&gt; should be used when a program reaches an unrecoverable state.</source>
          <target state="translated">这允许程序立即终止并向程序调用者提供反馈。 &lt;code&gt;panic!&lt;/code&gt; 当程序达到不可恢复的状态时应使用。</target>
        </trans-unit>
        <trans-unit id="720612fc48419da4fea633357e945fe3ab75a62a" translate="yes" xml:space="preserve">
          <source>This allows creating a custom iterator with any behavior without using the more verbose syntax of creating a dedicated type and implementing the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait for it.</source>
          <target state="translated">这允许创建具有任何行为的自定义迭代器，而无需使用更冗长的语法来创建专用类型并为其实现&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;特征。</target>
        </trans-unit>
        <trans-unit id="8257259a712f5169c7b4c3c0a8b238e35c31bcfe" translate="yes" xml:space="preserve">
          <source>This allows creating a custom iterator with any behavior without using the more verbose syntax of creating a dedicated type and implementing the &lt;code&gt;Iterator&lt;/code&gt; trait for it.</source>
          <target state="translated">这允许创建具有任何行为的自定义迭代器，而无需使用更冗长的语法来创建专用类型并为其实现 &lt;code&gt;Iterator&lt;/code&gt; 特征。</target>
        </trans-unit>
        <trans-unit id="df65a862360a6e0bd203ebc75d215550a55a7ec8" translate="yes" xml:space="preserve">
          <source>This allows the value to be dropped again.</source>
          <target state="translated">这样就可以再次放弃该值。</target>
        </trans-unit>
        <trans-unit id="6f7c82b24f94be6c3280942f62546df8a8a85985" translate="yes" xml:space="preserve">
          <source>This allows writing a projection that creates a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt;, thus witnessing that the field is pinned:</source>
          <target state="translated">这允许编写一个创建&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 的投影，从而见证该字段已固定：</target>
        </trans-unit>
        <trans-unit id="e583956f9df46a2ff992eeadbf1d346839209a48" translate="yes" xml:space="preserve">
          <source>This allows writing a projection that creates a &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt;, thus witnessing that the field is pinned:</source>
          <target state="translated">这允许编写一个创建 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 的投影，从而见证该字段已固定：</target>
        </trans-unit>
        <trans-unit id="9ed737638d9ae3e5d76efaebf6336aa8e810e97d" translate="yes" xml:space="preserve">
          <source>This allows your code to type-check, which is useful if you are prototyping or implementing a trait that requires multiple methods which you don't plan of using all of.</source>
          <target state="translated">这允许你的代码进行类型检查,如果你的原型设计或实现一个需要多个方法的特质,而你又不打算使用所有的方法,这很有用。</target>
        </trans-unit>
        <trans-unit id="d056f20cad4a501761c404be3055779184b1614f" translate="yes" xml:space="preserve">
          <source>This also in turn requires the annotation &lt;code&gt;T: 'a&lt;/code&gt;, indicating that any references in &lt;code&gt;T&lt;/code&gt; are valid over the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">这反过来又需要注释 &lt;code&gt;T: 'a&lt;/code&gt; ，指示 &lt;code&gt;T&lt;/code&gt; 中的所有引用在整个生命周期内都是有效 &lt;code&gt;'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60e1ada09db527973a7bebfb74dc7b9bbc576185" translate="yes" xml:space="preserve">
          <source>This also means that all resources such as file descriptors and memory-mapped regions got duplicated. It is your responsibility to make sure that the closure does not violate library invariants by making invalid use of these duplicates.</source>
          <target state="translated">这也意味着所有资源,如文件描述符和内存映射区域都被复制了。你有责任确保闭包不会因为无效使用这些重复的资源而违反库的不变性。</target>
        </trans-unit>
        <trans-unit id="c5dab5f83abd965944fb4f235779eceb37146b12" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt; emit their output to stdout. Similarly to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro, the goal of these macros is to avoid intermediate allocations when printing output. Example usage is:</source>
          <target state="translated">这和&lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;将其输出发送到stdout。类似于&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;宏，这些宏的目标是避免在打印输出时进行中间分配。用法示例是：</target>
        </trans-unit>
        <trans-unit id="acaf201fd6cc02b279b5987151a707c144a7e5c9" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;../macro.writeln&quot;&gt;&lt;code&gt;writeln!&lt;/code&gt;&lt;/a&gt; are two macros which are used to emit the format string to a specified stream. This is used to prevent intermediate allocations of format strings and instead directly write the output. Under the hood, this function is actually invoking the &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;&lt;code&gt;write_fmt&lt;/code&gt;&lt;/a&gt; function defined on the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. Example usage is:</source>
          <target state="translated">这和&lt;a href=&quot;../macro.writeln&quot;&gt; &lt;code&gt;writeln!&lt;/code&gt; &lt;/a&gt;有两个宏，用于将格式字符串发送到指定的流。这用于防止格式字符串的中间分配，而是直接写入输出。在&lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt; &lt;code&gt;write_fmt&lt;/code&gt; &lt;/a&gt;，此函数实际上是调用在&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt;特征上定义的write_fmt函数。用法示例是：</target>
        </trans-unit>
        <trans-unit id="7dd14a6dd33e863c7c3a9afcbc1b94db44474940" translate="yes" xml:space="preserve">
          <source>This appendix contains a glossary of Rust&amp;rsquo;s syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, trait bounds, macros, attributes, comments, tuples, and brackets.</source>
          <target state="translated">本附录包含Rust语法的词汇表，包括单独出现或在路径，泛型，特征范围，宏，属性，注释，元组和括号内出现的运算符和其他符号。</target>
        </trans-unit>
        <trans-unit id="98f7d37c50386fc1a7bc45c602df60e2a6b2f88d" translate="yes" xml:space="preserve">
          <source>This appendix is about how Rust is made and how that affects you as a Rust developer.</source>
          <target state="translated">这个附录是关于Rust是如何制作的,以及如何影响你作为一个Rust开发者。</target>
        </trans-unit>
        <trans-unit id="0a5a5ca6ad8b433739f4a95c725e50e77d092d65" translate="yes" xml:space="preserve">
          <source>This applies even if the result of this method is unused!</source>
          <target state="translated">即使该方法的结果未被使用,这一点也适用!</target>
        </trans-unit>
        <trans-unit id="2b1ddafbbcba87aafd5e8ce9688cb9d0214c48d2" translate="yes" xml:space="preserve">
          <source>This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">即使这个方法的结果未被使用,这也是适用的! (关于被初始化的部分还没有完全决定,但在决定之前,唯一安全的方法是确保它们确实被初始化了。)</target>
        </trans-unit>
        <trans-unit id="cf4d5070c48104546a550c9a051a5f05bc584068" translate="yes" xml:space="preserve">
          <source>This associated type corresponds to the &lt;code&gt;yield&lt;/code&gt; expression and the values which are allowed to be returned each time a generator yields. For example an iterator-as-a-generator would likely have this type as &lt;code&gt;T&lt;/code&gt;, the type being iterated over.</source>
          <target state="translated">这种关联的类型对应于 &lt;code&gt;yield&lt;/code&gt; 表达式和每次生成器yield时允许返回的值。例如，作为迭代器的迭代器可能将这种类型作为 &lt;code&gt;T&lt;/code&gt; 进行迭代。</target>
        </trans-unit>
        <trans-unit id="fe55ae487fde4fa4dff7b2d6d6cdbe76cfbf6518" translate="yes" xml:space="preserve">
          <source>This attribute allows configuring the choice of global allocator. You can use this to implement a completely custom global allocator to route all default allocation requests to a custom object.</source>
          <target state="translated">这个属性允许配置全局分配器的选择。你可以用它来实现一个完全自定义的全局分配器,将所有的默认分配请求路由到一个自定义对象。</target>
        </trans-unit>
        <trans-unit id="ef26e5c3cab23c11bb733ef68934315ad78b85fb" translate="yes" xml:space="preserve">
          <source>This avoids reallocating where possible, but the conditions for that are strict, and subject to change, and so shouldn't be relied upon unless the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; came from &lt;code&gt;From&amp;lt;VecDeque&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and hasn't been reallocated.</source>
          <target state="translated">这样可以避免在可能的情况下进行重新分配，但是这样做的条件很严格，并且随时可能更改，因此除非 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 来自 &lt;code&gt;From&amp;lt;VecDeque&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 并且没有进行重新分配，否则不应该依赖它。</target>
        </trans-unit>
        <trans-unit id="83aca27198b7bcda96ac6aa2d82d76c078c81a23" translate="yes" xml:space="preserve">
          <source>This behavior is no longer valid in edition 2018.</source>
          <target state="translated">这种行为在2018版中不再有效。</target>
        </trans-unit>
        <trans-unit id="c09355cbc8b51304e7c4f53224a50044b1a70814" translate="yes" xml:space="preserve">
          <source>This book also does not serve as a reference to the &lt;a href=&quot;../std/index&quot;&gt;standard library&lt;/a&gt; included in the language distribution. Those libraries are documented separately by extracting documentation attributes from their source code. Many of the features that one might expect to be language features are library features in Rust, so what you're looking for may be there, not here.</source>
          <target state="translated">本书也不用作语言分发中包含的&lt;a href=&quot;../std/index&quot;&gt;标准库&lt;/a&gt;的参考。通过从源代码中提取文档属性来分别记录这些库。Rust的库功能可能是人们可能希望成为语言功能的许多功能，因此您所需要的可能不在这里。</target>
        </trans-unit>
        <trans-unit id="8e20080fb8e1699ed580bf1c766151d2b69a59c9" translate="yes" xml:space="preserve">
          <source>This book also only serves as a reference to what is available in stable Rust. For unstable features being worked on, see the &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/index.html&quot;&gt;Unstable Book&lt;/a&gt;.</source>
          <target state="translated">本书还仅作为稳定Rust中可用的参考。有关正在处理的不稳定功能，请参见&lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/index.html&quot;&gt;不稳定书&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32b7e021bdc132a2756c978c8a1d27d9e8d25d04" translate="yes" xml:space="preserve">
          <source>This book assumes that you&amp;rsquo;ve written code in another programming language but doesn&amp;rsquo;t make any assumptions about which one. We&amp;rsquo;ve tried to make the material broadly accessible to those from a wide variety of programming backgrounds. We don&amp;rsquo;t spend a lot of time talking about what programming &lt;em&gt;is&lt;/em&gt; or how to think about it. If you&amp;rsquo;re entirely new to programming, you would be better served by reading a book that specifically provides an introduction to programming.</source>
          <target state="translated">本书假定您已经用另一种编程语言编写了代码，但是没有对哪种编程语言做任何假设。我们已尝试使各种编程背景的人员都可以广泛使用该材料。我们不会花很多时间来谈论什么编程&lt;em&gt;是&lt;/em&gt;或如何去想它。如果您是编程的新手，那么最好阅读一本专门介绍编程的书，为您提供更好的服务。</target>
        </trans-unit>
        <trans-unit id="fb8d9819998123cf06ddd8f5a1ff9953b5c7298e" translate="yes" xml:space="preserve">
          <source>This book does not assume you are reading this book sequentially. Each chapter generally can be read standalone, but will cross-link to other chapters for facets of the language they refer to, but do not discuss.</source>
          <target state="translated">本书不假设你是按顺序阅读本书。每一章一般都可以单独阅读,但会与其他章节交叉链接,以了解它们所提及但不讨论的语言方面。</target>
        </trans-unit>
        <trans-unit id="74d346bfc5c0837e4df013dba9f47fd4b57ffe9b" translate="yes" xml:space="preserve">
          <source>This book does not serve as an introduction to the language. Background familiarity with the language is assumed. A separate &lt;a href=&quot;../index&quot;&gt;book&lt;/a&gt; is available to help acquire such background familiarity.</source>
          <target state="translated">本书不作为该语言的简介。假定对语言有背景知识。另有&lt;a href=&quot;../index&quot;&gt;一本书&lt;/a&gt;可帮助您获得这种背景知识。</target>
        </trans-unit>
        <trans-unit id="4589512ba2ae3140ba2d5cf22da84c708acf0a3c" translate="yes" xml:space="preserve">
          <source>This book fully embraces the potential of Rust to empower its users. It&amp;rsquo;s a friendly and approachable text intended to help you level up not just your knowledge of Rust, but also your reach and confidence as a programmer in general. So dive in, get ready to learn&amp;mdash;and welcome to the Rust community!</source>
          <target state="translated">本书充分体现了Rust增强用户能力的潜力。这是一种友好且易于理解的文本，旨在帮助您不仅提高对Rust的知识，而且还可以提高您作为程序员的影响力和信心。因此，深入学习，准备学习吧，欢迎加入Rust社区！</target>
        </trans-unit>
        <trans-unit id="5eac84b162d067e7c7224575575cec18251ae81c" translate="yes" xml:space="preserve">
          <source>This book is the primary reference for the Rust programming language. It provides three kinds of material:</source>
          <target state="translated">本书是Rust编程语言的主要参考书。它提供了三种材料。</target>
        </trans-unit>
        <trans-unit id="4dac54ff1b6d498bb0e5ad5ca44a29d6b2c3c87b" translate="yes" xml:space="preserve">
          <source>This book only contains information about stable features, as in-progress features are still changing, and surely they&amp;rsquo;ll be different between when this book was written and when they get enabled in stable builds. You can find documentation for nightly-only features online.</source>
          <target state="translated">本书仅包含有关稳定功能的信息，因为正在开发的功能仍在变化，并且在本书撰写时和在稳定版本中启用它们之间，肯定会有所不同。您可以在线查找仅夜间功能的文档。</target>
        </trans-unit>
        <trans-unit id="9b40452b3457baf6eb9c9eb4c95b596dc78a3493" translate="yes" xml:space="preserve">
          <source>This broken invariant is then later observed.</source>
          <target state="translated">这个破除的不变性后来被观察到了。</target>
        </trans-unit>
        <trans-unit id="626674212943f16d78b9c64b216d4813683d4bcd" translate="yes" xml:space="preserve">
          <source>This buffer is always stored on the heap.</source>
          <target state="translated">这个缓冲区总是存储在堆上。</target>
        </trans-unit>
        <trans-unit id="533f834501c9981cf01926064551726140f691d1" translate="yes" xml:space="preserve">
          <source>This builder also supports platform-specific options.</source>
          <target state="translated">该构建器还支持特定平台的选项。</target>
        </trans-unit>
        <trans-unit id="828127de31395e4a312b7fc3b3384b3f2a31aa51" translate="yes" xml:space="preserve">
          <source>This builder exposes the ability to configure how a &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; is opened and what operations are permitted on the open file. The &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.file#method.create&quot;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt; methods are aliases for commonly used options using this builder.</source>
          <target state="translated">此构建器提供了配置&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;方式以及打开文件所允许的操作的能力。该&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.file#method.create&quot;&gt; &lt;code&gt;File::create&lt;/code&gt; &lt;/a&gt;方法是使用该生成器常用选项的别名。</target>
        </trans-unit>
        <trans-unit id="e3a75e262b3ddd48064e08eaf81396d4af4ef1e5" translate="yes" xml:space="preserve">
          <source>This call borrows &lt;code&gt;Cell&lt;/code&gt; mutably (at compile-time) which guarantees that we possess the only reference.</source>
          <target state="translated">此调用是可变地借用 &lt;code&gt;Cell&lt;/code&gt; 的（在编译时），这保证了我们拥有唯一的引用。</target>
        </trans-unit>
        <trans-unit id="5a4e17ce4bfa3ac12c6fb727cdafac307c2e7b00" translate="yes" xml:space="preserve">
          <source>This call borrows &lt;code&gt;RefCell&lt;/code&gt; mutably (at compile-time) so there is no need for dynamic checks.</source>
          <target state="translated">此调用 &lt;code&gt;RefCell&lt;/code&gt; 借用RefCell（在编译时），因此不需要动态检查。</target>
        </trans-unit>
        <trans-unit id="6f04390b2a6147633d5eca54b6b75468f6c87ab6" translate="yes" xml:space="preserve">
          <source>This call borrows the &lt;code&gt;UnsafeCell&lt;/code&gt; mutably (at compile-time) which guarantees that we possess the only reference.</source>
          <target state="translated">此调用可变地（在编译时）借用了 &lt;code&gt;UnsafeCell&lt;/code&gt; ，这保证了我们拥有唯一的引用。</target>
        </trans-unit>
        <trans-unit id="07dea4d9325843f5f46d2875aa2d7fc09a6140cf" translate="yes" xml:space="preserve">
          <source>This call is similar to &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; but more specialized. It borrows &lt;code&gt;RefCell&lt;/code&gt; mutably to ensure no borrows exist and then resets the state tracking shared borrows. This is relevant if some &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;RefMut&lt;/code&gt; borrows have been leaked.</source>
          <target state="translated">该调用与&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;相似，但更加专业。它 &lt;code&gt;RefCell&lt;/code&gt; 可变方式借用RefCell以确保不存在借用，然后重置状态跟踪共享借用。如果某些 &lt;code&gt;Ref&lt;/code&gt; 或 &lt;code&gt;RefMut&lt;/code&gt; 借项已泄漏，则这是相关的。</target>
        </trans-unit>
        <trans-unit id="e72e4c34a367723e7d0f2fd64a605d769a73a61b" translate="yes" xml:space="preserve">
          <source>This call is similar to &lt;a href=&quot;struct.refcell#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; but more specialized. It borrows &lt;code&gt;RefCell&lt;/code&gt; mutably to ensure no borrows exist and then resets the state tracking shared borrows. This is relevant if some &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;RefMut&lt;/code&gt; borrows have been leaked.</source>
          <target state="translated">该调用与&lt;a href=&quot;struct.refcell#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;相似，但更加专业。它 &lt;code&gt;RefCell&lt;/code&gt; 可变方式借用RefCell以确保不存在借用，然后重置状态跟踪共享借用。如果某些 &lt;code&gt;Ref&lt;/code&gt; 或 &lt;code&gt;RefMut&lt;/code&gt; 借项已泄漏，则这是相关的。</target>
        </trans-unit>
        <trans-unit id="bafb9cba9c70e76a1a3bb46e83a3fb5e4a1e4a73" translate="yes" xml:space="preserve">
          <source>This can also be thought of as the fallible form of &lt;a href=&quot;#method.for_each&quot;&gt;&lt;code&gt;for_each()&lt;/code&gt;&lt;/a&gt; or as the stateless version of &lt;a href=&quot;#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">也可以将其视为&lt;a href=&quot;#method.for_each&quot;&gt; &lt;code&gt;for_each()&lt;/code&gt; &lt;/a&gt;的错误形式或&lt;a href=&quot;#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt;的无状态版本。</target>
        </trans-unit>
        <trans-unit id="561a3555fef68cbba4ae35243cef025c7f810a34" translate="yes" xml:space="preserve">
          <source>This can also be thought of as the fallible form of &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each()&lt;/code&gt;&lt;/a&gt; or as the stateless version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">也可以将其视为&lt;a href=&quot;trait.iterator#method.for_each&quot;&gt; &lt;code&gt;for_each()&lt;/code&gt; &lt;/a&gt;的错误形式或&lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt;的无状态版本。</target>
        </trans-unit>
        <trans-unit id="dc5e7768aa508543b82b361f251df561c08e6d32" translate="yes" xml:space="preserve">
          <source>This can also be used in multithreaded applications, in order to send a message to other threads warning that a thread has panicked (e.g., for monitoring purposes).</source>
          <target state="translated">这也可以在多线程应用程序中使用,以便向其他线程发送消息,警告某个线程已经恐慌(例如,出于监控目的)。</target>
        </trans-unit>
        <trans-unit id="3ff7f3a5aeb76318844d8c8fdfdc79fcab462b99" translate="yes" xml:space="preserve">
          <source>This can also happen when using a type implementing &lt;code&gt;Fn&lt;/code&gt; or &lt;code&gt;FnMut&lt;/code&gt;, as neither allows moving out of them (they usually represent closures which can be called more than once). Much of the text following applies equally well to non-&lt;code&gt;FnOnce&lt;/code&gt; closure bodies.</source>
          <target state="translated">当使用实现 &lt;code&gt;Fn&lt;/code&gt; 或 &lt;code&gt;FnMut&lt;/code&gt; 的类型时，也会发生这种情况，因为它们都不允许移出它们（它们通常表示可以多次调用的闭包）。以下大部分内容同样适用于非 &lt;code&gt;FnOnce&lt;/code&gt; 封闭体。</target>
        </trans-unit>
        <trans-unit id="115ef26a79f6ceeca6376e7547342f4fb025dc8d" translate="yes" xml:space="preserve">
          <source>This can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;</source>
          <target state="translated">可以将其强制转换为任何类型的指针。强制转换为 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 时，确保访问是唯一的（无活动引用，是否可变），并确保转换为 &lt;code&gt;&amp;amp;T&lt;/code&gt; 时没有发生任何突变或可变别名。</target>
        </trans-unit>
        <trans-unit id="214edc09ead3c27edfef862878240910ed92a93e" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_list&quot;&gt;&lt;code&gt;Formatter::debug_list&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_list&quot;&gt; &lt;code&gt;Formatter::debug_list&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="c7514961910752b90460d88f227b5817215d7f6e" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_map&quot;&gt;&lt;code&gt;Formatter::debug_map&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_map&quot;&gt; &lt;code&gt;Formatter::debug_map&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="db45b1697100bb4357e93b4848fb22d93091bccd" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_set&quot;&gt;&lt;code&gt;Formatter::debug_set&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_set&quot;&gt; &lt;code&gt;Formatter::debug_set&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="efbf03337e671dc0f2d75f1c2d72ed7746b99e34" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;Formatter::debug_struct&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt; &lt;code&gt;Formatter::debug_struct&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="daed88198496b5861ca72aa01db8f1e07a7a1fbc" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_tuple&quot;&gt;&lt;code&gt;Formatter::debug_tuple&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_tuple&quot;&gt; &lt;code&gt;Formatter::debug_tuple&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="f00711c55f275b9886eb0ce781693c9e5c9caed4" translate="yes" xml:space="preserve">
          <source>This can be resolved by changing the type annotation or removing it entirely if it can be inferred.</source>
          <target state="translated">这可以通过改变类型注释来解决,如果可以推断,也可以完全删除。</target>
        </trans-unit>
        <trans-unit id="21c003ed23b457ffebe1b7112c3e64636889beae" translate="yes" xml:space="preserve">
          <source>This can be used to avoid allocations in the most trivial case.</source>
          <target state="translated">这可以用来避免在最琐碎的情况下进行分配。</target>
        </trans-unit>
        <trans-unit id="2479ae89d6780ca289ef37404c0461658bc53872" translate="yes" xml:space="preserve">
          <source>This can be used to compare &lt;code&gt;&amp;amp;T&lt;/code&gt; references (which coerce to &lt;code&gt;*const T&lt;/code&gt; implicitly) by their address rather than comparing the values they point to (which is what the &lt;code&gt;PartialEq for &amp;amp;T&lt;/code&gt; implementation does).</source>
          <target state="translated">这可用于按地址比较 &lt;code&gt;&amp;amp;T&lt;/code&gt; 引用（隐式强制为 &lt;code&gt;*const T&lt;/code&gt; ），而不是比较它们指向的值（这是 &lt;code&gt;PartialEq for &amp;amp;T&lt;/code&gt; 实现的PartialEq所做的事情）。</target>
        </trans-unit>
        <trans-unit id="b3720c96ba6b1476408a923be1876044bc567298" translate="yes" xml:space="preserve">
          <source>This can be used to compare enums that carry data, while disregarding the actual data:</source>
          <target state="translated">这可以用来比较携带数据的枚举,而不考虑实际数据。</target>
        </trans-unit>
        <trans-unit id="27925db5758baea8a7b4ada29852f78f4d3d7a94" translate="yes" xml:space="preserve">
          <source>This can be used to handle errors that would otherwise only be caught when the &lt;code&gt;File&lt;/code&gt; is closed. Dropping a file will ignore errors in synchronizing this in-memory data.</source>
          <target state="translated">这可用于处理错误，否则这些错误仅在 &lt;code&gt;File&lt;/code&gt; 关闭时才会被捕获。删除文件将忽略同步此内存中数据的错误。</target>
        </trans-unit>
        <trans-unit id="9856559b29a29e0f25c3e61f2c093f50c7905e19" translate="yes" xml:space="preserve">
          <source>This can be used to hash a &lt;code&gt;&amp;amp;T&lt;/code&gt; reference (which coerces to &lt;code&gt;*const T&lt;/code&gt; implicitly) by its address rather than the value it points to (which is what the &lt;code&gt;Hash for &amp;amp;T&lt;/code&gt; implementation does).</source>
          <target state="translated">这可用于通过其地址而不是其指向的值（这是 &lt;code&gt;Hash for &amp;amp;T&lt;/code&gt; 实现的作用）对 &lt;code&gt;&amp;amp;T&lt;/code&gt; 参考（隐式强制为 &lt;code&gt;*const T&lt;/code&gt; ）进行哈希处理。</target>
        </trans-unit>
        <trans-unit id="13a7b507773148ef054095424c9d9ac4d8251d3e" translate="yes" xml:space="preserve">
          <source>This can be used to safely get a strong reference (by calling &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt; later) or to deallocate the weak count by dropping the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这可用于安全地获得强引用（稍后调用&lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt;）或通过删除 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 来释放弱计数。</target>
        </trans-unit>
        <trans-unit id="d817729d2569d0ddec2d2ba9e954b932bf7153c3" translate="yes" xml:space="preserve">
          <source>This can be used to simply obtain ownership of the underlying error; it can also be used for advanced error recovery.</source>
          <target state="translated">这可以用来简单地获得基本错误的所有权;也可以用来进行高级错误恢复。</target>
        </trans-unit>
        <trans-unit id="fb4c5fc4f14344c508855aa0c67808589d2ea5df" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code type-check, or if you're implementing a trait that requires multiple methods, and you're only planning on using one of them.</source>
          <target state="translated">如果你正在做原型设计,只是想让你的代码进行类型检查,或者如果你正在实现一个需要多个方法的特质,而你只打算使用其中的一个方法,那么这就很有用。</target>
        </trans-unit>
        <trans-unit id="1ab14e32989b6a2b12b8a3fb1b8ae13359f650e9" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code typecheck.</source>
          <target state="translated">如果你正在做原型设计,并且只是想让你的代码进行类型检查,这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="13e97c3892555defded3caf3fd786d6a9bf7c197" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code typecheck. &lt;code&gt;todo!&lt;/code&gt; works exactly like &lt;code&gt;unimplemented!&lt;/code&gt;. The only difference between the two macros is the name.</source>
          <target state="translated">如果您要进行原型设计并且只是在检查代码类型，这可能会很有用。 &lt;code&gt;todo!&lt;/code&gt; 完全像 &lt;code&gt;unimplemented!&lt;/code&gt; 一样工作！。这两个宏之间的唯一区别是名称。</target>
        </trans-unit>
        <trans-unit id="8c8e1855be0fe981425a92585a82ff10846bce81" translate="yes" xml:space="preserve">
          <source>This can be useful when we want to access a &lt;code&gt;MaybeUninit&lt;/code&gt; that has been initialized but don't have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt; (preventing the use of &lt;code&gt;.assume_init()&lt;/code&gt;).</source>
          <target state="translated">当我们想访问这可能是有用 &lt;code&gt;MaybeUninit&lt;/code&gt; 已初始化，但没有所有权 &lt;code&gt;MaybeUninit&lt;/code&gt; （防止使用 &lt;code&gt;.assume_init()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1ab94494ce69e91c90f0acb5a81528e74b707291" translate="yes" xml:space="preserve">
          <source>This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; or &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;) has consequences for your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation as well: if an element of your type could have been pinned, you must treat &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; as implicitly taking &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这永远不会在安全代码中引起问题，因为实现依赖于固定的类型需要不安全的代码，但是请注意，决定在您的类型中使用固定（例如，通过对&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; 或&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 实现一些操作）Self&amp;gt;）也会对&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 的&lt;/a&gt;实现产生影响：如果可以固定您类型的元素，则必须将&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;视为使用&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 隐式地对待。</target>
        </trans-unit>
        <trans-unit id="b8075fc432fec0682f4342dc70f37276a8d8a19f" translate="yes" xml:space="preserve">
          <source>This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on &lt;code&gt;Pin&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; or &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;) has consequences for your &lt;code&gt;Drop&lt;/code&gt; implementation as well: if an element of your type could have been pinned, you must treat Drop as implicitly taking &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这永远不会在安全代码中引起问题，因为实现依赖于固定的类型需要不安全的代码，但是请注意，决定在您的类型中使用固定（例如，通过对 &lt;code&gt;Pin&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 实现一些操作）Self&amp;gt;）也会对 &lt;code&gt;Drop&lt;/code&gt; 的实现产生影响：如果可以固定您类型的元素，则必须将Drop视为使用 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 隐式对待。</target>
        </trans-unit>
        <trans-unit id="cadc6079abb6a4bbc592c234ce0da222e1a2fdc1" translate="yes" xml:space="preserve">
          <source>This change unifies all the calls to &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; and solves the problem of the first &lt;code&gt;if&lt;/code&gt; block unnecessarily calling the function twice. Unfortunately, we&amp;rsquo;re now calling this function and waiting for the result in all cases, which includes the inner &lt;code&gt;if&lt;/code&gt; block that doesn&amp;rsquo;t use the result value at all.</source>
          <target state="translated">此更改统一了对 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 的所有调用，并解决了第一个 &lt;code&gt;if&lt;/code&gt; 块不必要地两次调用该函数的问题。不幸的是，我们现在调用此函数并在所有情况下都等待结果，其中包括内部的 &lt;code&gt;if&lt;/code&gt; 块，它根本不使用结果值。</target>
        </trans-unit>
        <trans-unit id="d160910b055fc36b0155788ef2b0b90383b734d2" translate="yes" xml:space="preserve">
          <source>This channel has an internal buffer on which messages will be queued. &lt;code&gt;bound&lt;/code&gt; specifies the buffer size. When the internal buffer becomes full, future sends will &lt;em&gt;block&lt;/em&gt; waiting for the buffer to open up. Note that a buffer size of 0 is valid, in which case this becomes &quot;rendezvous channel&quot; where each &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; will not return until a &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; is paired with it.</source>
          <target state="translated">该通道具有内部缓冲区，消息将在该缓冲区上排队。 &lt;code&gt;bound&lt;/code&gt; 指定缓冲区大小。当内部缓冲区已满时，将来的发送将&lt;em&gt;阻塞，&lt;/em&gt;等待缓冲区打开。请注意，缓冲区大小为0是有效的，在这种情况下，它变为&amp;ldquo;集合通道&amp;rdquo;，其中每个&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;都不会返回，直到&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;与之配对。</target>
        </trans-unit>
        <trans-unit id="fb1d7eb08fcc70de9ba8181af70c6fc4dce88829" translate="yes" xml:space="preserve">
          <source>This chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type has a known size and points to data allocated on the heap. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to data on the heap so that data can have multiple owners. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.</source>
          <target state="translated">本章介绍了如何使用智能指针与那些默认使用常规引用的Rust做出不同的保证和权衡。的 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 类型具有已知的尺寸和指向在堆上分配数据。所述 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 型跟踪上堆到数据的引用的数目，以使得数据可以有多个拥有者。具有内部可变性的 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型为我们提供了一种类型，当我们需要一个不可变类型但需要更改该类型的内部值时，可以使用该类型。它还在运行时而不是在编译时强制执行借用规则。</target>
        </trans-unit>
        <trans-unit id="d76b58ff9e32a83f32bdf3cb1438b47bc33ded06" translate="yes" xml:space="preserve">
          <source>This chapter covers concepts that appear in almost every programming language and how they work in Rust. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Rust, but we&amp;rsquo;ll discuss them in the context of Rust and explain the conventions around using these concepts.</source>
          <target state="translated">本章涵盖了几乎每种编程语言中出现的概念以及它们在Rust中的工作方式。许多编程语言的核心都有很多共同点。本章介绍的概念都不是Rust独有的，但我们将在Rust的背景下进行讨论，并解释有关使用这些概念的约定。</target>
        </trans-unit>
        <trans-unit id="29ea0fbfb2601396e36f35e6ef2ff2eccf09482a" translate="yes" xml:space="preserve">
          <source>This chapter is a recap of the many skills you&amp;rsquo;ve learned so far and an exploration of a few more standard library features. We&amp;rsquo;ll build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.</source>
          <target state="translated">本章概述了到目前为止您已经学到的许多技能，并探讨了其他一些标准库功能。我们将构建一个命令行工具，与文件和命令行输入/输出交互，以练习您现在掌握的一些Rust概念。</target>
        </trans-unit>
        <trans-unit id="ba9d120769583a2b06ff5bcafb1b013c4c1c420a" translate="yes" xml:space="preserve">
          <source>This chapter is a reference on all things related to patterns. We&amp;rsquo;ll cover the valid places to use patterns, the difference between refutable and irrefutable patterns, and the different kinds of pattern syntax that you might see. By the end of the chapter, you&amp;rsquo;ll know how to use patterns to express many concepts in a clear way.</source>
          <target state="translated">本章是与模式相关的所有内容的参考。我们将介绍使用模式的有效位置，可重用和不可重用模式之间的区别以及您可能会看到的各种类型的语法。在本章结束时，您将了解如何使用模式以清晰的方式表达许多概念。</target>
        </trans-unit>
        <trans-unit id="4ca695707d3d924a4c7520a559258f62a52be801" translate="yes" xml:space="preserve">
          <source>This chapter recapped some of the major concepts you&amp;rsquo;ve learned so far and covered how to perform common I/O operations in Rust. By using command line arguments, files, environment variables, and the &lt;code&gt;eprintln!&lt;/code&gt; macro for printing errors, you&amp;rsquo;re now prepared to write command line applications. By using the concepts in previous chapters, your code will be well organized, store data effectively in the appropriate data structures, handle errors nicely, and be well tested.</source>
          <target state="translated">本章回顾了您到目前为止已学习的一些主要概念，并介绍了如何在Rust中执行常见的I / O操作。通过使用命令行参数，文件，环境变量和 &lt;code&gt;eprintln!&lt;/code&gt; 用于打印错误的宏，现在您准备编写命令行应用程序。通过使用前几章中的概念，您的代码将井井有条，可以将数据有效地存储在适当的数据结构中，可以很好地处理错误，并且可以进行良好的测试。</target>
        </trans-unit>
        <trans-unit id="4f14f23451903925edc1325ae4f6812d472301ab" translate="yes" xml:space="preserve">
          <source>This closure will be run in the context of the child process after a &lt;code&gt;fork&lt;/code&gt;. This primarily means that any modifications made to memory on behalf of this closure will &lt;strong&gt;not&lt;/strong&gt; be visible to the parent process. This is often a very constrained environment where normal operations like &lt;code&gt;malloc&lt;/code&gt; or acquiring a mutex are not guaranteed to work (due to other threads perhaps still running when the &lt;code&gt;fork&lt;/code&gt; was run).</source>
          <target state="translated">在 &lt;code&gt;fork&lt;/code&gt; 之后，此关闭将在子进程的上下文中运行。这主要意味着，代表此闭包对内存所做的任何修改对于父进程都是&lt;strong&gt;不&lt;/strong&gt;可见的。这通常是一个非常受限制的环境，无法保证正常执行诸如 &lt;code&gt;malloc&lt;/code&gt; 或获取互斥锁之类的正常操作（由于在运行 &lt;code&gt;fork&lt;/code&gt; 时可能仍在运行其他线程）。</target>
        </trans-unit>
        <trans-unit id="22a1461b442324db65b2ce2aa52db0c09471bd28" translate="yes" xml:space="preserve">
          <source>This code also sets &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;tic-tac-toe&lt;/code&gt;. The &lt;code&gt;format!&lt;/code&gt; macro works in the same way as &lt;code&gt;println!&lt;/code&gt;, but instead of printing the output to the screen, it returns a &lt;code&gt;String&lt;/code&gt; with the contents. The version of the code using &lt;code&gt;format!&lt;/code&gt; is much easier to read and doesn&amp;rsquo;t take ownership of any of its parameters.</source>
          <target state="translated">此代码还将 &lt;code&gt;s&lt;/code&gt; 设置为 &lt;code&gt;tic-tac-toe&lt;/code&gt; 。该 &lt;code&gt;format!&lt;/code&gt; 宏的工作方式与 &lt;code&gt;println!&lt;/code&gt; 相同！，而不是将输出打印到屏幕上，而是返回包含内容的 &lt;code&gt;String&lt;/code&gt; 。该版本的代码使用 &lt;code&gt;format!&lt;/code&gt; 更容易阅读，并且不拥有任何参数的所有权。</target>
        </trans-unit>
        <trans-unit id="d361c400527932085f404cf9d818fa511cfc4bc4" translate="yes" xml:space="preserve">
          <source>This code block contains unsafe code.</source>
          <target state="translated">此代码块包含不安全代码。</target>
        </trans-unit>
        <trans-unit id="0d78aab047e6dda70e180b20c3bdb5a9c1b43bef" translate="yes" xml:space="preserve">
          <source>This code compiles and runs but doesn&amp;rsquo;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the &lt;code&gt;Mutex&lt;/code&gt; struct has no public &lt;code&gt;unlock&lt;/code&gt; method because the ownership of the lock is based on the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; within the &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that the &lt;code&gt;lock&lt;/code&gt; method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a &lt;code&gt;Mutex&lt;/code&gt; cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don&amp;rsquo;t think carefully about the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该代码可以编译并运行，但不会导致所需的线程行为：慢速请求仍将导致其他请求等待处理。原因有些微妙： &lt;code&gt;Mutex&lt;/code&gt; 结构没有公共 &lt;code&gt;unlock&lt;/code&gt; 方法，因为锁的所有权基于 &lt;code&gt;lock&lt;/code&gt; 方法返回的 &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 中 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 的生存期。然后，在编译时，借用检查器可以强制执行以下规则：除非拥有锁，否则 &lt;code&gt;Mutex&lt;/code&gt; 保护的资源将无法访问。但是，如果我们不仔细考虑 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 的寿命，则此实现也可能导致锁定的持有时间比预期的更长。</target>
        </trans-unit>
        <trans-unit id="d2b577d02f895994167db7646bcb5bc51980294d" translate="yes" xml:space="preserve">
          <source>This code compiles and runs but doesn&amp;rsquo;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the &lt;code&gt;Mutex&lt;/code&gt; struct has no public &lt;code&gt;unlock&lt;/code&gt; method because the ownership of the lock is based on the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; within the &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that the &lt;code&gt;lock&lt;/code&gt; method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a &lt;code&gt;Mutex&lt;/code&gt; cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don&amp;rsquo;t think carefully about the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;. Because the values in the &lt;code&gt;while let&lt;/code&gt; expression remain in scope for the duration of the block, the lock remains held for the duration of the call to &lt;code&gt;job()&lt;/code&gt;, meaning other workers cannot receive jobs.</source>
          <target state="translated">该代码可以编译并运行，但不会导致所需的线程行为：慢速请求仍将导致其他请求等待处理。原因有些微妙： &lt;code&gt;Mutex&lt;/code&gt; 结构没有公共 &lt;code&gt;unlock&lt;/code&gt; 方法，因为锁的所有权基于 &lt;code&gt;lock&lt;/code&gt; 方法返回的 &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 中 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 的生存期。然后，在编译时，借用检查器可以强制执行以下规则：除非拥有锁，否则 &lt;code&gt;Mutex&lt;/code&gt; 保护的资源将无法访问。但是，如果我们不仔细考虑 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 的寿命，则此实现也可能导致锁定的持有时间比预期的更长。因为 &lt;code&gt;while let&lt;/code&gt; 表达式中的值在块的持续时间内处于作用域内，所以在对 &lt;code&gt;job()&lt;/code&gt; 的调用期间将保持锁定，这意味着其他工作程序无法接收作业。</target>
        </trans-unit>
        <trans-unit id="8be923288a70fe6e854b5bc75a5a5f3ea2e87376" translate="yes" xml:space="preserve">
          <source>This code compiles and runs but doesn&amp;rsquo;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the &lt;code&gt;Mutex&lt;/code&gt; struct has no public &lt;code&gt;unlock&lt;/code&gt; method because the ownership of the lock is based on the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; within the &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that the &lt;code&gt;lock&lt;/code&gt; method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a &lt;code&gt;Mutex&lt;/code&gt; cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don&amp;rsquo;t think carefully about the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;. Because the values in the &lt;code&gt;while&lt;/code&gt; expression remain in scope for the duration of the block, the lock remains held for the duration of the call to &lt;code&gt;job.call_box()&lt;/code&gt;, meaning other workers cannot receive jobs.</source>
          <target state="translated">该代码可以编译并运行，但不会导致所需的线程行为：缓慢的请求仍将导致其他请求等待处理。原因有些微妙： &lt;code&gt;Mutex&lt;/code&gt; 结构没有公共 &lt;code&gt;unlock&lt;/code&gt; 方法，因为锁的所有权基于 &lt;code&gt;lock&lt;/code&gt; 方法返回的 &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 中 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 的生存期。然后，在编译时，借用检查器可以执行以下规则：除非拥有锁，否则 &lt;code&gt;Mutex&lt;/code&gt; 保护的资源将无法访问。但是，如果我们不仔细考虑 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 的寿命，则此实现还可能导致锁的持有时间比预期的长。因为 &lt;code&gt;while&lt;/code&gt; 表达式中的值在块的持续时间内保持作用域，所以锁定在对 &lt;code&gt;job.call_box()&lt;/code&gt; 的调用期间保持不变，这意味着其他工作程序无法接收作业。</target>
        </trans-unit>
        <trans-unit id="a9ddcc8d0db1cdd5bd0507394434501db1a0bedf" translate="yes" xml:space="preserve">
          <source>This code contains a lot of information, so let&amp;rsquo;s go over it line by line. To obtain user input and then print the result as output, we need to bring the &lt;code&gt;io&lt;/code&gt; (input/output) library into scope. The &lt;code&gt;io&lt;/code&gt; library comes from the standard library (which is known as &lt;code&gt;std&lt;/code&gt;):</source>
          <target state="translated">这段代码包含很多信息，因此让我们逐行进行介绍。为了获得用户输入，然后将结果打印为输出，我们需要将 &lt;code&gt;io&lt;/code&gt; （输入/输出）库纳入范围。该 &lt;code&gt;io&lt;/code&gt; 库来自标准库（其被称为 &lt;code&gt;std&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="a2cf7c9b3ea591cd958e0136c121e6bf9f333d13" translate="yes" xml:space="preserve">
          <source>This code creates a string containing &lt;code&gt;initial contents&lt;/code&gt;.</source>
          <target state="translated">此代码创建一个包含 &lt;code&gt;initial contents&lt;/code&gt; 的字符串。</target>
        </trans-unit>
        <trans-unit id="37eb73353618177bcb3ef1d909b78d97976287b7" translate="yes" xml:space="preserve">
          <source>This code creates the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that match the values of the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of the &lt;code&gt;p&lt;/code&gt; struct. This example shows that the names of the variables in the pattern don&amp;rsquo;t have to match the field names of the struct. But it&amp;rsquo;s common to want the variable names to match the field names to make it easier to remember which variables came from which fields.</source>
          <target state="translated">该代码创建与 &lt;code&gt;p&lt;/code&gt; 结构的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 字段值匹配的变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。此示例显示了模式中变量的名称不必与该结构的字段名称匹配。但是通常希望变量名与字段名匹配，以便更容易记住哪些变量来自哪个字段。</target>
        </trans-unit>
        <trans-unit id="4c6b27e7fab9563bf2abcf70ff023ebf232f1887" translate="yes" xml:space="preserve">
          <source>This code creates the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; that match the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of the &lt;code&gt;p&lt;/code&gt; variable. The outcome is that the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; contain the values from the &lt;code&gt;p&lt;/code&gt; struct.</source>
          <target state="translated">此代码创建的变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 匹配该 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 所述的字段 &lt;code&gt;p&lt;/code&gt; 可变。结果是变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 包含 &lt;code&gt;p&lt;/code&gt; 结构的值。</target>
        </trans-unit>
        <trans-unit id="519fd3df45d223b502667d31300a65c73f22de3a" translate="yes" xml:space="preserve">
          <source>This code does not compile!</source>
          <target state="translated">这段代码无法编译</target>
        </trans-unit>
        <trans-unit id="a8563da8c7fd875eb235c5cf17bc917dd4b6aba0" translate="yes" xml:space="preserve">
          <source>This code does not produce the desired behavior.</source>
          <target state="translated">这段代码没有产生预期的行为。</target>
        </trans-unit>
        <trans-unit id="0426964d440764948892b9452f7b1a751866e79c" translate="yes" xml:space="preserve">
          <source>This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.</source>
          <target state="translated">这段代码说明了你可以将任何类型的数据放在一个枚举变体中:例如,字符串、数字类型或结构。你甚至可以包含另一个枚举。另外,标准库类型通常不会比你想出来的复杂得多。</target>
        </trans-unit>
        <trans-unit id="23d4be6e177cb0763cfd5315e376249487e60755" translate="yes" xml:space="preserve">
          <source>This code is a bit messy, but it&amp;rsquo;s good enough for simulation purposes. We created a second request &lt;code&gt;sleep&lt;/code&gt;, whose data our server recognizes. We added an &lt;code&gt;else if&lt;/code&gt; after the &lt;code&gt;if&lt;/code&gt; block to check for the request to &lt;em&gt;/sleep&lt;/em&gt;. When that request is received, the server will sleep for 5 seconds before rendering the successful HTML page.</source>
          <target state="translated">这段代码有点凌乱，但是足以用于仿真目的。我们创建了第二个请求 &lt;code&gt;sleep&lt;/code&gt; ，我们的服务器可以识别该数据。我们在 &lt;code&gt;if&lt;/code&gt; 块之后添加了 &lt;code&gt;else if&lt;/code&gt; 来检查对&lt;em&gt;/ sleep&lt;/em&gt;的请求。收到该请求后，服务器将休眠5秒钟，然后呈现成功的HTML页面。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9400019c8ed3d0b61a4a67558c972e785c9498d4" translate="yes" xml:space="preserve">
          <source>This code is a bit nicer, isn&amp;rsquo;t it?</source>
          <target state="translated">这段代码好一点了，不是吗？</target>
        </trans-unit>
        <trans-unit id="a9d573288ab51576cf8efa92e3fc2409e71975a4" translate="yes" xml:space="preserve">
          <source>This code is for an animal shelter that wants to name all puppies Spot, which is implemented in the &lt;code&gt;baby_name&lt;/code&gt; associated function that is defined on &lt;code&gt;Dog&lt;/code&gt;. The &lt;code&gt;Dog&lt;/code&gt; type also implements the trait &lt;code&gt;Animal&lt;/code&gt;, which describes characteristics that all animals have. Baby dogs are called puppies, and that is expressed in the implementation of the &lt;code&gt;Animal&lt;/code&gt; trait on &lt;code&gt;Dog&lt;/code&gt; in the &lt;code&gt;baby_name&lt;/code&gt; function associated with the &lt;code&gt;Animal&lt;/code&gt; trait.</source>
          <target state="translated">该代码用于想要命名所有幼犬Spot的动物收容所，该动物收容所在 &lt;code&gt;Dog&lt;/code&gt; 上定义的 &lt;code&gt;baby_name&lt;/code&gt; 关联函数中实现。该 &lt;code&gt;Dog&lt;/code&gt; 型也实现了性状 &lt;code&gt;Animal&lt;/code&gt; ，它描述的特征，所有的动物都有。宝贝狗被称为小狗，并在实施中表达 &lt;code&gt;Animal&lt;/code&gt; 对性状 &lt;code&gt;Dog&lt;/code&gt; 在 &lt;code&gt;baby_name&lt;/code&gt; 与相关的功能 &lt;code&gt;Animal&lt;/code&gt; 的特征。</target>
        </trans-unit>
        <trans-unit id="28ab5f7e147cb2d4d661943464a31c7e543917cd" translate="yes" xml:space="preserve">
          <source>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well (&lt;em&gt;thunk&lt;/em&gt; is a word for code to be evaluated at a later time, so it&amp;rsquo;s an appropriate name for a closure that gets stored).</source>
          <target state="translated">这段代码更容易阅读和编写！为类型别名选择一个有意义的名称也可以帮助传达您的意图（&lt;em&gt;thunk&lt;/em&gt;是以后要评估的代码的意思，因此它是用于存储闭包的适当名称）。</target>
        </trans-unit>
        <trans-unit id="49a0f8f422e51179065e97042cbf65579f27fccc" translate="yes" xml:space="preserve">
          <source>This code is not legal: it is not possible to specialize &lt;code&gt;Drop&lt;/code&gt; to a subset of implementations of a generic type. In order for this code to work, &lt;code&gt;MyStruct&lt;/code&gt; must also require that &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Foo&lt;/code&gt;. Alternatively, another option is to wrap the generic type in another that specializes appropriately:</source>
          <target state="translated">该代码不合法​​：无法将 &lt;code&gt;Drop&lt;/code&gt; 专用于泛型类型的实现子集。为了使此代码起作用， &lt;code&gt;MyStruct&lt;/code&gt; 还必须要求 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Foo&lt;/code&gt; 。另外，另一种选择是将泛型类型包装在适当专门化的另一种类型中：</target>
        </trans-unit>
        <trans-unit id="e6419e6d86ad5d4d771d701592b7c8059bf718cc" translate="yes" xml:space="preserve">
          <source>This code is not legal: it is not possible to specialize &lt;code&gt;Drop&lt;/code&gt; to a subset of implementations of a generic type. One workaround for this is to wrap the generic type, as shown below:</source>
          <target state="translated">该代码不合法​​：无法将 &lt;code&gt;Drop&lt;/code&gt; 专用于泛型类型的实现子集。一种解决方法是包装通用类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="7561545f94912a4c2f636ef3be71bf5e25ba09fc" translate="yes" xml:space="preserve">
          <source>This code is printing a prompt stating what the game is and requesting input from the user.</source>
          <target state="translated">这段代码是打印一个提示,说明游戏是什么,并要求用户输入。</target>
        </trans-unit>
        <trans-unit id="7103520ca1aa03619df8713fc5365e846d9c5ad3" translate="yes" xml:space="preserve">
          <source>This code is read as &amp;ldquo;the function &lt;code&gt;bar&lt;/code&gt; returns never.&amp;rdquo; Functions that return never are called &lt;em&gt;diverging functions&lt;/em&gt;. We can&amp;rsquo;t create values of the type &lt;code&gt;!&lt;/code&gt; so &lt;code&gt;bar&lt;/code&gt; can never possibly return.</source>
          <target state="translated">将此代码读作&amp;ldquo;功能 &lt;code&gt;bar&lt;/code&gt; 永不返回&amp;rdquo;。永不返回的&lt;em&gt;函数&lt;/em&gt;称为&lt;em&gt;发散函数&lt;/em&gt;。我们无法创建类型的值 &lt;code&gt;!&lt;/code&gt; 所以 &lt;code&gt;bar&lt;/code&gt; 永远不可能回来。</target>
        </trans-unit>
        <trans-unit id="bcd0c3078c2294c0e6fda3c229de0e1561bef882" translate="yes" xml:space="preserve">
          <source>This code is similar to &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#creating-custom-types-for-validation&quot;&gt;the &lt;code&gt;Guess::new&lt;/code&gt; function we wrote in Listing 9-10&lt;/a&gt;, where we called &lt;code&gt;panic!&lt;/code&gt; when the &lt;code&gt;value&lt;/code&gt; argument was out of the range of valid values. Instead of checking for a range of values here, we&amp;rsquo;re checking that the length of &lt;code&gt;args&lt;/code&gt; is at least 3 and the rest of the function can operate under the assumption that this condition has been met. If &lt;code&gt;args&lt;/code&gt; has fewer than three items, this condition will be true, and we call the &lt;code&gt;panic!&lt;/code&gt; macro to end the program immediately.</source>
          <target state="translated">这段代码类似于&lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#creating-custom-types-for-validation&quot;&gt;清单9-10中编写&lt;/a&gt;的 &lt;code&gt;Guess::new&lt;/code&gt; 函数，我们称之为 &lt;code&gt;panic!&lt;/code&gt; 。当 &lt;code&gt;value&lt;/code&gt; 参数超出有效值范围时。在此，我们将检查 &lt;code&gt;args&lt;/code&gt; 的长度至少为3，并且其余功能可以在满足此条件的假设下运行，而不是在此处检查值的范围。如果 &lt;code&gt;args&lt;/code&gt; 少于三个项目，则此条件成立，我们称之为 &lt;code&gt;panic!&lt;/code&gt; 宏以立即结束程序。</target>
        </trans-unit>
        <trans-unit id="7a83ac1e4ecf68353438d16df2a11f1d38c56035" translate="yes" xml:space="preserve">
          <source>This code is the automatically generated test module. The attribute &lt;code&gt;cfg&lt;/code&gt; stands for &lt;em&gt;configuration&lt;/em&gt; and tells Rust that the following item should only be included given a certain configuration option. In this case, the configuration option is &lt;code&gt;test&lt;/code&gt;, which is provided by Rust for compiling and running tests. By using the &lt;code&gt;cfg&lt;/code&gt; attribute, Cargo compiles our test code only if we actively run the tests with &lt;code&gt;cargo test&lt;/code&gt;. This includes any helper functions that might be within this module, in addition to the functions annotated with &lt;code&gt;#[test]&lt;/code&gt;.</source>
          <target state="translated">此代码是自动生成的测试模块。 &lt;code&gt;cfg&lt;/code&gt; 属性代表&lt;em&gt;配置，&lt;/em&gt;并告诉Rust仅在具有特定配置选项的情况下才应包括以下项目。在这种情况下，配置选项是 &lt;code&gt;test&lt;/code&gt; ，由Rust提供，用于编译和运行测试。通过使用 &lt;code&gt;cfg&lt;/code&gt; 属性，仅当我们使用 &lt;code&gt;cargo test&lt;/code&gt; 积极运行测试时，Cargo才会编译测试代码。除了用 &lt;code&gt;#[test]&lt;/code&gt; 注释的功能之外，它还包括此模块中可能包含的所有辅助功能。</target>
        </trans-unit>
        <trans-unit id="fb14b558eed9a012f6129027202f61756e6e0b8d" translate="yes" xml:space="preserve">
          <source>This code lets us break complex types into their component parts so we can use the values we&amp;rsquo;re interested in separately.</source>
          <target state="translated">该代码使我们可以将复杂类型分解为它们的组成部分，以便我们可以分别使用我们感兴趣的值。</target>
        </trans-unit>
        <trans-unit id="bf80b97b3cceef068893acf5a419fa57178f1aed" translate="yes" xml:space="preserve">
          <source>This code means the type &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; will have a method named &lt;code&gt;distance_from_origin&lt;/code&gt; and other instances of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is not of type &lt;code&gt;f32&lt;/code&gt; will not have this method defined. The method measures how far our point is from the point at coordinates (0.0, 0.0) and uses mathematical operations that are available only for floating point types.</source>
          <target state="translated">此代码意味着 &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; 类型将具有一个名为 &lt;code&gt;distance_from_origin&lt;/code&gt; 的方法，而 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 其他实例（其中 &lt;code&gt;T&lt;/code&gt; 不是 &lt;code&gt;f32&lt;/code&gt; 类型）将没有定义此方法。该方法测量我们的点距坐标（0.0，0.0）处的点的距离，并使用仅适用于浮点类型的数学运算。</target>
        </trans-unit>
        <trans-unit id="edb9c9f6097f3c4e5bd16a047b4ef0c91c5eda3e" translate="yes" xml:space="preserve">
          <source>This code overrides the default setting of &lt;code&gt;0&lt;/code&gt;. Now when we run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will use the defaults for the &lt;code&gt;dev&lt;/code&gt; profile plus our customization to &lt;code&gt;opt-level&lt;/code&gt;. Because we set &lt;code&gt;opt-level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, Cargo will apply more optimizations than the default, but not as many as in a release build.</source>
          <target state="translated">此代码将覆盖默认设置 &lt;code&gt;0&lt;/code&gt; 。现在，当我们运行 &lt;code&gt;cargo build&lt;/code&gt; 时，Cargo将使用 &lt;code&gt;dev&lt;/code&gt; 配置文件的默认值以及我们对 &lt;code&gt;opt-level&lt;/code&gt; 的自定义。因为我们将 &lt;code&gt;opt-level&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; ，所以Cargo将应用比默认设置更多的优化，但不如发布版本中的优化多。</target>
        </trans-unit>
        <trans-unit id="cbd474aff68e6272a4d817ab514ba2ba338dc2b1" translate="yes" xml:space="preserve">
          <source>This code panics!</source>
          <target state="translated">这个代码慌了!</target>
        </trans-unit>
        <trans-unit id="1520d0fd722c3577359ba16db239ceb0ddeebd5f" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;1 new tweet: (Read more from @horse_ebooks...)&lt;/code&gt;.</source>
          <target state="translated">这段代码显示了 &lt;code&gt;1 new tweet: (Read more from @horse_ebooks...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d78693e95ef2bffb056748f86ea7d4fd87f6784" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;1 new tweet: horse_ebooks: of course, as you probably already know, people&lt;/code&gt;.</source>
          <target state="translated">这段代码显示了 &lt;code&gt;1 new tweet: horse_ebooks: of course, as you probably already know, people&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4e90b820e3471ed9be465d87743c5461551a7f0" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;Current location: (3, 5)&lt;/code&gt;. The values &lt;code&gt;&amp;amp;(3, 5)&lt;/code&gt; match the pattern &lt;code&gt;&amp;amp;(x, y)&lt;/code&gt;, so &lt;code&gt;x&lt;/code&gt; is the value &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is the value &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">此代码显示 &lt;code&gt;Current location: (3, 5)&lt;/code&gt; 。值 &lt;code&gt;&amp;amp;(3, 5)&lt;/code&gt; 与模式 &lt;code&gt;&amp;amp;(x, y)&lt;/code&gt; ）匹配，因此 &lt;code&gt;x&lt;/code&gt; 是值 &lt;code&gt;3&lt;/code&gt; ,而 &lt;code&gt;y&lt;/code&gt; 是值 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb3c413eeb04880ff8b53ff489dddef4151c97bb" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;New article available! (Read more...)&lt;/code&gt;.</source>
          <target state="translated">此代码可打印 &lt;code&gt;New article available! (Read more...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bdc1d17208e27666bda4fd318b994f6acf7818b" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;The answer is: 12&lt;/code&gt;. We specify that the parameter &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;do_twice&lt;/code&gt; is an &lt;code&gt;fn&lt;/code&gt; that takes one parameter of type &lt;code&gt;i32&lt;/code&gt; and returns an &lt;code&gt;i32&lt;/code&gt;. We can then call &lt;code&gt;f&lt;/code&gt; in the body of &lt;code&gt;do_twice&lt;/code&gt;. In &lt;code&gt;main&lt;/code&gt;, we can pass the function name &lt;code&gt;add_one&lt;/code&gt; as the first argument to &lt;code&gt;do_twice&lt;/code&gt;.</source>
          <target state="translated">这段代码打印出来 &lt;code&gt;The answer is: 12&lt;/code&gt; 。我们指定的参数 &lt;code&gt;f&lt;/code&gt; 在 &lt;code&gt;do_twice&lt;/code&gt; 是 &lt;code&gt;fn&lt;/code&gt; 是需要一个类型的一个参数 &lt;code&gt;i32&lt;/code&gt; ，并返回一个 &lt;code&gt;i32&lt;/code&gt; 。然后，我们可以在 &lt;code&gt;do_twice&lt;/code&gt; 的主体中调用 &lt;code&gt;f&lt;/code&gt; 。在 &lt;code&gt;main&lt;/code&gt; 中，我们可以将函数名称 &lt;code&gt;add_one&lt;/code&gt; 作为第一个参数传递给 &lt;code&gt;do_twice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f51af940300a3743a5ab26b4b6248a93015d25fc" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;one or two&lt;/code&gt;.</source>
          <target state="translated">此代码打印 &lt;code&gt;one or two&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3fc2ca0fc1e2ca4079f6b9c2e26f148c6f028f" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;one&lt;/code&gt; because the value in &lt;code&gt;x&lt;/code&gt; is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.</source>
          <target state="translated">由于 &lt;code&gt;x&lt;/code&gt; 中的值为1，因此此代码将打印 &lt;code&gt;one&lt;/code&gt; 。如果希望代码获得特定的具体值，则该代码很有用。</target>
        </trans-unit>
        <trans-unit id="f76e20cf8d5177f5195a6770ae0f2388492d5a80" translate="yes" xml:space="preserve">
          <source>This code prints the following:</source>
          <target state="translated">这段代码打印的内容如下:</target>
        </trans-unit>
        <trans-unit id="2da1adcf6ac7d40ff872dbb16e9f7a36210c0c52" translate="yes" xml:space="preserve">
          <source>This code should compile and produce the result we want when we use it with the &lt;code&gt;main&lt;/code&gt; function in Listing 10-20.</source>
          <target state="translated">当我们将其与清单10-20中的 &lt;code&gt;main&lt;/code&gt; 函数一起使用时，该代码应编译并产生所需的结果。</target>
        </trans-unit>
        <trans-unit id="fc992e6806cb1bd5a9c534e91522711af45f4b36" translate="yes" xml:space="preserve">
          <source>This code should look generally familiar: a trait with one method and an associated type. The new part is &lt;code&gt;RHS=Self&lt;/code&gt;: this syntax is called &lt;em&gt;default type parameters&lt;/em&gt;. The &lt;code&gt;RHS&lt;/code&gt; generic type parameter (short for &amp;ldquo;right hand side&amp;rdquo;) defines the type of the &lt;code&gt;rhs&lt;/code&gt; parameter in the &lt;code&gt;add&lt;/code&gt; method. If we don&amp;rsquo;t specify a concrete type for &lt;code&gt;RHS&lt;/code&gt; when we implement the &lt;code&gt;Add&lt;/code&gt; trait, the type of &lt;code&gt;RHS&lt;/code&gt; will default to &lt;code&gt;Self&lt;/code&gt;, which will be the type we&amp;rsquo;re implementing &lt;code&gt;Add&lt;/code&gt; on.</source>
          <target state="translated">该代码通常看起来很熟悉：具有一个方法和一个关联类型的特征。新部分是 &lt;code&gt;RHS=Self&lt;/code&gt; ：此语法称为&lt;em&gt;默认类型参数&lt;/em&gt;。在 &lt;code&gt;RHS&lt;/code&gt; 泛型类型参数（以下简称&amp;ldquo;右侧&amp;rdquo;）定义的类型 &lt;code&gt;rhs&lt;/code&gt; 在参数 &lt;code&gt;add&lt;/code&gt; 方法。如果我们不指定具体类型 &lt;code&gt;RHS&lt;/code&gt; 当我们执行的 &lt;code&gt;Add&lt;/code&gt; 特征，类型 &lt;code&gt;RHS&lt;/code&gt; 将默认为 &lt;code&gt;Self&lt;/code&gt; ，这将是我们正在实施的类型 &lt;code&gt;Add&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="58a84861deaa80c4db75f055d7277e059fbe6bb3" translate="yes" xml:space="preserve">
          <source>This code should look generally familiar: a trait with one method and an associated type. The new part is &lt;code&gt;Rhs=Self&lt;/code&gt;: this syntax is called &lt;em&gt;default type parameters&lt;/em&gt;. The &lt;code&gt;Rhs&lt;/code&gt; generic type parameter (short for &amp;ldquo;right hand side&amp;rdquo;) defines the type of the &lt;code&gt;rhs&lt;/code&gt; parameter in the &lt;code&gt;add&lt;/code&gt; method. If we don&amp;rsquo;t specify a concrete type for &lt;code&gt;Rhs&lt;/code&gt; when we implement the &lt;code&gt;Add&lt;/code&gt; trait, the type of &lt;code&gt;Rhs&lt;/code&gt; will default to &lt;code&gt;Self&lt;/code&gt;, which will be the type we&amp;rsquo;re implementing &lt;code&gt;Add&lt;/code&gt; on.</source>
          <target state="translated">这段代码通常看起来很熟悉：具有一个方法和一个关联类型的特征。新部分是 &lt;code&gt;Rhs=Self&lt;/code&gt; ：此语法称为&lt;em&gt;默认类型参数&lt;/em&gt;。该 &lt;code&gt;Rhs&lt;/code&gt; 泛型类型参数（以下简称&amp;ldquo;右侧&amp;rdquo;）定义的类型 &lt;code&gt;rhs&lt;/code&gt; 在参数 &lt;code&gt;add&lt;/code&gt; 方法。如果我们不指定具体类型 &lt;code&gt;Rhs&lt;/code&gt; ，当我们执行 &lt;code&gt;Add&lt;/code&gt; 特征的类型， &lt;code&gt;Rhs&lt;/code&gt; 将默认为 &lt;code&gt;Self&lt;/code&gt; ，这将是我们正在实施的类型 &lt;code&gt;Add&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="9916bd76554811c91bac8fdab30ae1e7bf834537" translate="yes" xml:space="preserve">
          <source>This code still won&amp;rsquo;t work, but let&amp;rsquo;s check it again to get the next error that we need to address:</source>
          <target state="translated">这段代码仍然无法正常工作，但是让我们再次检查一下以获取我们需要解决的下一个错误：</target>
        </trans-unit>
        <trans-unit id="d27513508379ea6cd339c0bb4a46ef6e82c466b9" translate="yes" xml:space="preserve">
          <source>This code stores a list of integers in the variable &lt;code&gt;number_list&lt;/code&gt; and places the first number in the list in a variable named &lt;code&gt;largest&lt;/code&gt;. Then it iterates through all the numbers in the list, and if the current number is greater than the number stored in &lt;code&gt;largest&lt;/code&gt;, it replaces the number in that variable. However, if the current number is less than or equal to the largest number seen so far, the variable doesn&amp;rsquo;t change, and the code moves on to the next number in the list. After considering all the numbers in the list, &lt;code&gt;largest&lt;/code&gt; should hold the largest number, which in this case is 100.</source>
          <target state="translated">此代码存储在变量整数列表 &lt;code&gt;number_list&lt;/code&gt; 并在一个名为变量放在列表中的第一个号码 &lt;code&gt;largest&lt;/code&gt; 。然后，它通过迭代列表中的所有号码，如果当前数目比存储在数量较大的 &lt;code&gt;largest&lt;/code&gt; ，它在变量替换的数量。但是，如果当前数字小于或等于到目前为止所看到的最大数字，则变量不会更改，并且代码将移至列表中的下一个数字。在考虑了列表中的所有数字之后， &lt;code&gt;largest&lt;/code&gt; 应该拥有最大的数字，在这种情况下为100。</target>
        </trans-unit>
        <trans-unit id="65e3fdd29c21c5766164366857eab04eba8f916b" translate="yes" xml:space="preserve">
          <source>This code will compile and will store the number of &lt;code&gt;Worker&lt;/code&gt; instances we specified as an argument to &lt;code&gt;ThreadPool::new&lt;/code&gt;. But we&amp;rsquo;re &lt;em&gt;still&lt;/em&gt; not processing the closure that we get in &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s look at how to do that next.</source>
          <target state="translated">该代码将编译并存储我们指定为 &lt;code&gt;ThreadPool::new&lt;/code&gt; 的参数的 &lt;code&gt;Worker&lt;/code&gt; 实例的数量。但是我们&lt;em&gt;仍然&lt;/em&gt;没有处理 &lt;code&gt;execute&lt;/code&gt; 的闭包。接下来让我们看看如何做。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="045fdd180c10e009660c1c81e0cc6eab5a5aa968" translate="yes" xml:space="preserve">
          <source>This code will compile just fine. For more about trait objects, refer to the section &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; in Chapter 17.</source>
          <target state="translated">这段代码可以很好地编译。有关特征对象的更多信息，请参见第17章中的&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;使用允许使用不同类型值的特征对象&amp;rdquo;&lt;/a&gt;一节。</target>
        </trans-unit>
        <trans-unit id="457c8af0abaf5c3ca5e095102658cc6466fc1c3e" translate="yes" xml:space="preserve">
          <source>This code will compile without any errors. Note the &lt;code&gt;r#&lt;/code&gt; prefix on the function name in its definition as well as where the function is called in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">该代码将编译而没有任何错误。注意函数名称中的 &lt;code&gt;r#&lt;/code&gt; 前缀及其定义，以及在 &lt;code&gt;main&lt;/code&gt; 中调用该函数的位置。</target>
        </trans-unit>
        <trans-unit id="a4e6558f8bd1055ab8e1efd4008b36e362cb01bc" translate="yes" xml:space="preserve">
          <source>This code will completely ignore the value passed as the first argument, &lt;code&gt;3&lt;/code&gt;, and will print &lt;code&gt;This code only uses the y parameter: 4&lt;/code&gt;.</source>
          <target state="translated">该代码将完全忽略作为第一个参数 &lt;code&gt;3&lt;/code&gt; 传递的值，并且将打印 &lt;code&gt;This code only uses the y parameter: 4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f597cb1c1231379b4a9ac9b16a64f6f09dac15f9" translate="yes" xml:space="preserve">
          <source>This code will now print &lt;code&gt;Default case, x = Some(5)&lt;/code&gt;. The pattern in the second match arm doesn&amp;rsquo;t introduce a new variable &lt;code&gt;y&lt;/code&gt; that would shadow the outer &lt;code&gt;y&lt;/code&gt;, meaning we can use the outer &lt;code&gt;y&lt;/code&gt; in the match guard. Instead of specifying the pattern as &lt;code&gt;Some(y)&lt;/code&gt;, which would have shadowed the outer &lt;code&gt;y&lt;/code&gt;, we specify &lt;code&gt;Some(n)&lt;/code&gt;. This creates a new variable &lt;code&gt;n&lt;/code&gt; that doesn&amp;rsquo;t shadow anything because there is no &lt;code&gt;n&lt;/code&gt; variable outside the &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">现在，此代码将显示 &lt;code&gt;Default case, x = Some(5)&lt;/code&gt; 。第二个比赛臂中的模式没有引入新的变量 &lt;code&gt;y&lt;/code&gt; ，该变量会遮蔽外部 &lt;code&gt;y&lt;/code&gt; ，这意味着我们可以在比赛后卫中使用外部 &lt;code&gt;y&lt;/code&gt; 。我们将指定 &lt;code&gt;Some(n)&lt;/code&gt; 而不是将模式指定为 &lt;code&gt;Some(y)&lt;/code&gt; ，该模式会遮盖外部 &lt;code&gt;y&lt;/code&gt; 。这将创建一个新的变量 &lt;code&gt;n&lt;/code&gt; ，该变量不会隐藏任何内容，因为在 &lt;code&gt;match&lt;/code&gt; 之外没有 &lt;code&gt;n&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="1bcf93c595538a9e0c98606ec2aa75cae859981c" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Can't overwrite an existing customized value&lt;/code&gt; and then &lt;code&gt;setting is Some(5)&lt;/code&gt;. In the first match arm, we don&amp;rsquo;t need to match on or use the values inside either &lt;code&gt;Some&lt;/code&gt; variant, but we do need to test for the case when &lt;code&gt;setting_value&lt;/code&gt; and &lt;code&gt;new_setting_value&lt;/code&gt; are the &lt;code&gt;Some&lt;/code&gt; variant. In that case, we print why we&amp;rsquo;re not changing &lt;code&gt;setting_value&lt;/code&gt;, and it doesn&amp;rsquo;t get changed.</source>
          <target state="translated">该代码将打印 &lt;code&gt;Can't overwrite an existing customized value&lt;/code&gt; ，然后 &lt;code&gt;setting is Some(5)&lt;/code&gt; 。在第一场比赛的胳膊，我们并不需要匹配或使用任何内部的价值观 &lt;code&gt;Some&lt;/code&gt; 变形，但我们确实需要测试的情况下 &lt;code&gt;setting_value&lt;/code&gt; 和 &lt;code&gt;new_setting_value&lt;/code&gt; 是 &lt;code&gt;Some&lt;/code&gt; 变种。在这种情况下，我们将打印为什么不更改 &lt;code&gt;setting_value&lt;/code&gt; ，并且不更改它。</target>
        </trans-unit>
        <trans-unit id="59fe6f0c2e0e4f24920973a91f227ffd825f4348" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Change the color to red 0, green 160, and blue 255&lt;/code&gt;. Try changing the value of &lt;code&gt;msg&lt;/code&gt; to see the code from the other arms run.</source>
          <target state="translated">将打印此代码，将 &lt;code&gt;Change the color to red 0, green 160, and blue 255&lt;/code&gt; 。尝试更改 &lt;code&gt;msg&lt;/code&gt; 的值以查看其他程序运行的代码。</target>
        </trans-unit>
        <trans-unit id="3c54f68158af593ed8370c89b1e792c808e333b9" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Hello, Macro! My name is Pancakes!&lt;/code&gt; when we&amp;rsquo;re done. The first step is to make a new library crate, like this:</source>
          <target state="translated">此代码将打印 &lt;code&gt;Hello, Macro! My name is Pancakes!&lt;/code&gt; 当我们完成时。第一步是制作一个新的库条板箱，如下所示：</target>
        </trans-unit>
        <trans-unit id="6ef0c24b1ac6e78f32662fb7a47aa078602f7661" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Some numbers: 2, 8, 32&lt;/code&gt;, and the values 4 and 16 will be ignored.</source>
          <target state="translated">此代码将打印 &lt;code&gt;Some numbers: 2, 8, 32&lt;/code&gt; 和值4和16将被忽略。</target>
        </trans-unit>
        <trans-unit id="6e7f6cc166031d911beb7caaef0389c2805500c8" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;{&quot;Blue&quot;: 25}&lt;/code&gt;. The original value of &lt;code&gt;10&lt;/code&gt; has been overwritten.</source>
          <target state="translated">此代码将打印 &lt;code&gt;{&quot;Blue&quot;: 25}&lt;/code&gt; 。原始值 &lt;code&gt;10&lt;/code&gt; 已被覆盖。</target>
        </trans-unit>
        <trans-unit id="4c7854ef3442e5dc7384d2ebe52264fddb2a172b" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}&lt;/code&gt;. The &lt;code&gt;or_insert&lt;/code&gt; method actually returns a mutable reference (&lt;code&gt;&amp;amp;mut V&lt;/code&gt;) to the value for this key. Here we store that mutable reference in the &lt;code&gt;count&lt;/code&gt; variable, so in order to assign to that value, we must first dereference &lt;code&gt;count&lt;/code&gt; using the asterisk (&lt;code&gt;*&lt;/code&gt;). The mutable reference goes out of scope at the end of the &lt;code&gt;for&lt;/code&gt; loop, so all of these changes are safe and allowed by the borrowing rules.</source>
          <target state="translated">此代码将显示 &lt;code&gt;{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}&lt;/code&gt; 。该 &lt;code&gt;or_insert&lt;/code&gt; 方法实际上返回一个可变的参考（ &lt;code&gt;&amp;amp;mut V&lt;/code&gt; ），以该键的值。在这里，我们将该可变引用存储在 &lt;code&gt;count&lt;/code&gt; 变量中，因此，为了分配给该值，我们必须首先使用星号（ &lt;code&gt;*&lt;/code&gt; ）取消引用 &lt;code&gt;count&lt;/code&gt; 。可变引用在 &lt;code&gt;for&lt;/code&gt; 循环的末尾超出范围，因此所有这些更改都是安全的，并且借用规则允许。</target>
        </trans-unit>
        <trans-unit id="d2527fb52597f9416819ef1fc01a194d639282f6" translate="yes" xml:space="preserve">
          <source>This code will print each pair in an arbitrary order:</source>
          <target state="translated">这段代码将按任意顺序打印每一对。</target>
        </trans-unit>
        <trans-unit id="bacd4441a056463b6c76d4dcb3493a2106b165e0" translate="yes" xml:space="preserve">
          <source>This code will print the 18 bytes that make up this &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="translated">此代码将打印组成此 &lt;code&gt;String&lt;/code&gt; 的18个字节：</target>
        </trans-unit>
        <trans-unit id="df66479dcc3e1d9cca2a55caf3dadeea76d13542" translate="yes" xml:space="preserve">
          <source>This code will print the following:</source>
          <target state="translated">该代码将打印以下内容。</target>
        </trans-unit>
        <trans-unit id="6cf1c1dee0071b4d526326a9881c97e561ec0f1a" translate="yes" xml:space="preserve">
          <source>This code will result in the following error:</source>
          <target state="translated">该代码将导致以下错误。</target>
        </trans-unit>
        <trans-unit id="bd9279581006b04d3fb15d53d9a31240a9bda944" translate="yes" xml:space="preserve">
          <source>This code works just fine because we never bind &lt;code&gt;s&lt;/code&gt; to anything; it isn&amp;rsquo;t moved.</source>
          <target state="translated">这段代码很好用，因为我们永远不会将 &lt;code&gt;s&lt;/code&gt; 绑定到任何东西。它没有动。</target>
        </trans-unit>
        <trans-unit id="a72012f28327d683a9fda9d6b4835b6ec97dd74b" translate="yes" xml:space="preserve">
          <source>This code works the way the business wants it to now, but let&amp;rsquo;s say the data science team decides that we need to make some changes to the way we call the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function in the future. To simplify the update when those changes happen, we want to refactor this code so it calls the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function only once. We also want to cut the place where we&amp;rsquo;re currently unnecessarily calling the function twice without adding any other calls to that function in the process. That is, we don&amp;rsquo;t want to call it if the result isn&amp;rsquo;t needed, and we still want to call it only once.</source>
          <target state="translated">这段代码可以按照企业现在想要的方式工作，但是让我们说，数据科学团队决定，我们需要在未来对调用 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 函数的方式进行一些更改。为了在发生这些更改时简化更新，我们希望重构此代码，以便它仅调用一次 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 函数。我们还希望减少当前不必要地调用该函数两次的位置，而不在该过程中添加对该函数的任何其他调用。也就是说，如果不需要结果，我们不想调用它，而我们仍然只想调用一次。</target>
        </trans-unit>
        <trans-unit id="29594b80ae15e7f3a6760f8d699f1007a88ab197" translate="yes" xml:space="preserve">
          <source>This code would attempt to link with &lt;code&gt;libmy_c_library.so&lt;/code&gt; on unix-like systems and &lt;code&gt;my_c_library.dll&lt;/code&gt; on Windows at runtime, and panic if it can't find something to link to. Rust code could then use &lt;code&gt;my_c_function&lt;/code&gt; as if it were any other unsafe Rust function. Working with non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.</source>
          <target state="translated">此代码将尝试与链接 &lt;code&gt;libmy_c_library.so&lt;/code&gt; 在类Unix系统和 &lt;code&gt;my_c_library.dll&lt;/code&gt; 在运行在Windows和惊恐，如果它不能找点链接。然后，Rust代码可以使用 &lt;code&gt;my_c_function&lt;/code&gt; ，就好像它是其他任何不安全的Rust函数一样。使用非Rust语言和FFI本质上是不安全的，因此包装程序通常围绕C API构建。</target>
        </trans-unit>
        <trans-unit id="94ac7a59ef0f9f139e040ad72861c14b2eb19308" translate="yes" xml:space="preserve">
          <source>This code would print &lt;code&gt;x = 5 and y = 10&lt;/code&gt;.</source>
          <target state="translated">此代码将输出 &lt;code&gt;x = 5 and y = 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0be10b63965c309b87ed0545b477401b58dc21cb" translate="yes" xml:space="preserve">
          <source>This command creates an executable file in &lt;em&gt;target/debug/hello_cargo&lt;/em&gt; (or &lt;em&gt;target\debug\hello_cargo.exe&lt;/em&gt; on Windows) rather than in your current directory. You can run the executable with this command:</source>
          <target state="translated">此命令在&lt;em&gt;target / debug / hello_cargo&lt;/em&gt;（或Windows上的&lt;em&gt;target \ debug \ hello_cargo.exe&lt;/em&gt;）中而非当前目录中创建一个可执行文件。您可以使用以下命令运行可执行文件：</target>
        </trans-unit>
        <trans-unit id="4dd02fcb167dbab5d0f3cc67c54c6c5da2a62c5e" translate="yes" xml:space="preserve">
          <source>This command gives you &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;cargo-fmt&lt;/code&gt;, similar to how Rust gives you both &lt;code&gt;rustc&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;. To format any Cargo project, enter the following:</source>
          <target state="translated">该命令为您提供 &lt;code&gt;rustfmt&lt;/code&gt; 和 &lt;code&gt;cargo-fmt&lt;/code&gt; ，类似于Rust为您提供 &lt;code&gt;rustc&lt;/code&gt; 和 &lt;code&gt;cargo&lt;/code&gt; 的方式。要格式化任何货运项目，请输入以下内容：</target>
        </trans-unit>
        <trans-unit id="616fc540cd704c55f34b7ddb4249c489ab431fea" translate="yes" xml:space="preserve">
          <source>This command ran all tests with &lt;code&gt;add&lt;/code&gt; in the name and filtered out the test named &lt;code&gt;one_hundred&lt;/code&gt;. Also note that the module in which a test appears becomes part of the test&amp;rsquo;s name, so we can run all the tests in a module by filtering on the module&amp;rsquo;s name.</source>
          <target state="translated">该命令使用 &lt;code&gt;add&lt;/code&gt; 名称运行所有测试，并过滤掉名为 &lt;code&gt;one_hundred&lt;/code&gt; 的测试。还要注意，其中出现测试的模块已成为测试名称的一部分，因此我们可以通过过滤模块名称来运行模块中的所有测试。</target>
        </trans-unit>
        <trans-unit id="8ea7582e38a836907de1d30ee5b58334fa20a196" translate="yes" xml:space="preserve">
          <source>This command runs only the tests in the &lt;em&gt;tests/integration_test.rs&lt;/em&gt; file.</source>
          <target state="translated">此命令仅运行&lt;em&gt;tests / integration_test.rs&lt;/em&gt;文件中的&lt;em&gt;测试&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0760093e6150870ee34facc6b7a5327edc5dc69d" translate="yes" xml:space="preserve">
          <source>This command will inform Cargo of your API token and store it locally in &lt;em&gt;~/.cargo/credentials&lt;/em&gt;. Note that this token is a &lt;em&gt;secret&lt;/em&gt;: do not share it with anyone else. If you do share it with anyone for any reason, you should revoke it and generate a new token on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;.</source>
          <target state="translated">此命令会将您的API令牌通知Cargo并将其本地存储在&lt;em&gt;〜/ .cargo / credentials中&lt;/em&gt;。请注意，此令牌是一个&lt;em&gt;秘密&lt;/em&gt;：请勿与其他任何人共享。如果您确实出于任何原因与任何人共享它，则应该撤消它并在&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;上生成一个新令牌。</target>
        </trans-unit>
        <trans-unit id="5e88705efdf159f3ff9b6126f1c10159a182f8df" translate="yes" xml:space="preserve">
          <source>This compiles because &lt;code&gt;longer&lt;/code&gt; outlives &lt;code&gt;shorter&lt;/code&gt;, thus the constraint is respected:</source>
          <target state="translated">这编译因为 &lt;code&gt;longer&lt;/code&gt; 寿命比 &lt;code&gt;shorter&lt;/code&gt; ，从而约束得到尊重：</target>
        </trans-unit>
        <trans-unit id="3f29dc82f5ad5c21f66ea4c65c4df005f9bfa118" translate="yes" xml:space="preserve">
          <source>This computes the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt;, with &lt;code&gt;0 &amp;lt;= self.rem_euclid(rhs) &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">这将计算整数 &lt;code&gt;n&lt;/code&gt; ，使得 &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt; ，且 &lt;code&gt;0 &amp;lt;= self.rem_euclid(rhs) &amp;lt; rhs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92466c99e75537fb86fdcb8b6177060d58e36e85" translate="yes" xml:space="preserve">
          <source>This computes the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt;. In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;.</source>
          <target state="translated">这将计算整数 &lt;code&gt;n&lt;/code&gt; ，使得 &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt; 。换句话说，结果是将 &lt;code&gt;self / rhs&lt;/code&gt; 舍入为整数 &lt;code&gt;n&lt;/code&gt; ,从而使 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30ff452f5fae3358ab149e5ae5cfa16c08f607d2" translate="yes" xml:space="preserve">
          <source>This concept&amp;mdash;of being concerned only with the messages a value responds to rather than the value&amp;rsquo;s concrete type&amp;mdash;is similar to the concept &lt;em&gt;duck typing&lt;/em&gt; in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of &lt;code&gt;run&lt;/code&gt; on &lt;code&gt;Screen&lt;/code&gt; in Listing 17-5, &lt;code&gt;run&lt;/code&gt; doesn&amp;rsquo;t need to know what the concrete type of each component is. It doesn&amp;rsquo;t check whether a component is an instance of a &lt;code&gt;Button&lt;/code&gt; or a &lt;code&gt;SelectBox&lt;/code&gt;, it just calls the &lt;code&gt;draw&lt;/code&gt; method on the component. By specifying &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; as the type of the values in the &lt;code&gt;components&lt;/code&gt; vector, we&amp;rsquo;ve defined &lt;code&gt;Screen&lt;/code&gt; to need values that we can call the &lt;code&gt;draw&lt;/code&gt; method on.</source>
          <target state="translated">这个概念（只关注值响应的消息，而不是值的具体类型）类似于动态输入语言中的&lt;em&gt;鸭子（Duck）&lt;/em&gt;概念：如果它走路像鸭子，而鸭子像鸭子，那么它一定是鸭！在清单17-5中的在 &lt;code&gt;Screen&lt;/code&gt; 上 &lt;code&gt;run&lt;/code&gt; 的实现中， &lt;code&gt;run&lt;/code&gt; 不需要知道每个组件的具体类型是什么。它不检查组件是 &lt;code&gt;Button&lt;/code&gt; 还是 &lt;code&gt;SelectBox&lt;/code&gt; 的实例，它只是在组件上调用 &lt;code&gt;draw&lt;/code&gt; 方法。通过指定 &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; 作为 &lt;code&gt;components&lt;/code&gt; 向量中值的类型，我们定义了 &lt;code&gt;Screen&lt;/code&gt; 上需要我们可以调用 &lt;code&gt;draw&lt;/code&gt; 方法的值。</target>
        </trans-unit>
        <trans-unit id="80fbf38c87a2fe3d71541d31605bf9ab62ed6238" translate="yes" xml:space="preserve">
          <source>This concept&amp;mdash;of being concerned only with the messages a value responds to rather than the value&amp;rsquo;s concrete type&amp;mdash;is similar to the concept of &lt;em&gt;duck typing&lt;/em&gt; in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of &lt;code&gt;run&lt;/code&gt; on &lt;code&gt;Screen&lt;/code&gt; in Listing 17-5, &lt;code&gt;run&lt;/code&gt; doesn&amp;rsquo;t need to know what the concrete type of each component is. It doesn&amp;rsquo;t check whether a component is an instance of a &lt;code&gt;Button&lt;/code&gt; or a &lt;code&gt;SelectBox&lt;/code&gt;, it just calls the &lt;code&gt;draw&lt;/code&gt; method on the component. By specifying &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; as the type of the values in the &lt;code&gt;components&lt;/code&gt; vector, we&amp;rsquo;ve defined &lt;code&gt;Screen&lt;/code&gt; to need values that we can call the &lt;code&gt;draw&lt;/code&gt; method on.</source>
          <target state="translated">这个概念（仅关注值响应的消息而不是值的具体类型）类似于动态类型语言中的&lt;em&gt;鸭子类型&lt;/em&gt;的概念：如果它像鸭子一样走动而像鸭子一样嘎嘎叫，那么它必须鸭子！在清单17-5中的在 &lt;code&gt;Screen&lt;/code&gt; 上 &lt;code&gt;run&lt;/code&gt; 的实现中， &lt;code&gt;run&lt;/code&gt; 不需要知道每个组件的具体类型是什么。它不会检查组件是 &lt;code&gt;Button&lt;/code&gt; 还是 &lt;code&gt;SelectBox&lt;/code&gt; 的实例，它只是在组件上调用 &lt;code&gt;draw&lt;/code&gt; 方法。通过指定 &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; 作为 &lt;code&gt;components&lt;/code&gt; 向量中值的类型，我们定义了 &lt;code&gt;Screen&lt;/code&gt; 上需要我们可以调用 &lt;code&gt;draw&lt;/code&gt; 方法的值。</target>
        </trans-unit>
        <trans-unit id="918897f830b93edc22b990902ff69a6fc36b08cc" translate="yes" xml:space="preserve">
          <source>This conditional structure lets us support complex requirements. With the hardcoded values we have here, this example will print &lt;code&gt;Using purple as the background color&lt;/code&gt;.</source>
          <target state="translated">这种条件结构使我们能够支持复杂的需求。使用此处具有的硬编码值，此示例将打印 &lt;code&gt;Using purple as the background color&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dcd38b0035fd15b13996ae1be8e3f24e8144a2a" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot; on all systems with respect to the system clock. Using &lt;code&gt;duration_since&lt;/code&gt; on an existing &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; instance can tell how far away from this point in time a measurement lies, and using &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; can be used to create a &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; instance to represent another fixed point in time.</source>
          <target state="translated">在所有系统上，相对于系统时钟，此常数定义为&amp;ldquo; 1970-01-01 00:00:00 UTC&amp;rdquo;。在现有的&lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt;实例上使用 &lt;code&gt;duration_since&lt;/code&gt; 可以知道距该时间点的距离，而使用 &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; 可以用来创建&lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt;实例来表示另一个固定时间点。</target>
        </trans-unit>
        <trans-unit id="b5d0e066df6c05d48b8ed4d894544fa1aeed7cdf" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot; on all systems with respect to the system clock. Using &lt;code&gt;duration_since&lt;/code&gt; on an existing &lt;code&gt;SystemTime&lt;/code&gt; instance can tell how far away from this point in time a measurement lies, and using &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; can be used to create a &lt;code&gt;SystemTime&lt;/code&gt; instance to represent another fixed point in time.</source>
          <target state="translated">在所有系统上，相对于系统时钟，此常数定义为&amp;ldquo; 1970-01-01 00:00:00 UTC&amp;rdquo;。在现有的 &lt;code&gt;SystemTime&lt;/code&gt; 实例上使用 &lt;code&gt;duration_since&lt;/code&gt; 可以知道距该时间点的距离，而使用 &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; 可以用来创建 &lt;code&gt;SystemTime&lt;/code&gt; 实例来表示另一个固定时间点。</target>
        </trans-unit>
        <trans-unit id="b2173ef48f94c265cfdd9db0c9cedd205cdc4005" translate="yes" xml:space="preserve">
          <source>This construct eliminates a lot of nesting that would be necessary if you used &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;, and it&amp;rsquo;s clearer. While a condition holds true, the code runs; otherwise, it exits the loop.</source>
          <target state="translated">如果您使用 &lt;code&gt;loop&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; ，则此构造消除了很多嵌套的必要，而且更加清楚。当条件成立时，代码将运行；否则，它退出循环。</target>
        </trans-unit>
        <trans-unit id="0f3921b041a98aaf2f8084439e4ed88136086a63" translate="yes" xml:space="preserve">
          <source>This construct is allowed because the first &lt;code&gt;spaces&lt;/code&gt; variable is a string type and the second &lt;code&gt;spaces&lt;/code&gt; variable, which is a brand-new variable that happens to have the same name as the first one, is a number type. Shadowing thus spares us from having to come up with different names, such as &lt;code&gt;spaces_str&lt;/code&gt; and &lt;code&gt;spaces_num&lt;/code&gt;; instead, we can reuse the simpler &lt;code&gt;spaces&lt;/code&gt; name. However, if we try to use &lt;code&gt;mut&lt;/code&gt; for this, as shown here, we&amp;rsquo;ll get a compile-time error:</source>
          <target state="translated">之所以允许这种构造，是因为第一个 &lt;code&gt;spaces&lt;/code&gt; 变量是字符串类型，而第二个空格变量是数字类型，而第二个 &lt;code&gt;spaces&lt;/code&gt; 变量是一个刚好与第一个名称相同的全新变量。因此，阴影使我们免于不得不提出不同的名称，例如 &lt;code&gt;spaces_str&lt;/code&gt; 和 &lt;code&gt;spaces_num&lt;/code&gt; ；相反，我们可以重用更简单的 &lt;code&gt;spaces&lt;/code&gt; 名称。但是，如果我们尝试为此使用 &lt;code&gt;mut&lt;/code&gt; ，如此处所示，则会收到编译时错误：</target>
        </trans-unit>
        <trans-unit id="2fc6477635d5d363ee444b003b473b1635177727" translate="yes" xml:space="preserve">
          <source>This constructor is unsafe because we cannot guarantee that the data pointed to by &lt;code&gt;pointer&lt;/code&gt; is pinned, meaning that the data will not be moved or its storage invalidated until it gets dropped. If the constructed &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; does not guarantee that the data &lt;code&gt;P&lt;/code&gt; points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.</source>
          <target state="translated">此构造函数是不安全的，因为我们不能保证 &lt;code&gt;pointer&lt;/code&gt; 的数据是固定的，这意味着直到将其删除之前，数据都不会移动或存储无效。如果构造的 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 不能保证数据 &lt;code&gt;P&lt;/code&gt; 指向的是固定的，则违反了API约定，并可能在以后的（安全）操作中导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="ff43397602787e15a0f1ce39d92c367ec0e4e2ba" translate="yes" xml:space="preserve">
          <source>This constructor will panic if &lt;code&gt;secs&lt;/code&gt; is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;secs&lt;/code&gt; 不是有限的，负数或 &lt;code&gt;Duration&lt;/code&gt; ，则此构造函数将感到恐慌。</target>
        </trans-unit>
        <trans-unit id="62c6e72ea916575b1c7e9925b7cd6a1ec78f970b" translate="yes" xml:space="preserve">
          <source>This constructor will panic if the carry from the nanoseconds overflows the seconds counter.</source>
          <target state="translated">如果来自纳秒的携带量超过了秒计数器,这个构造函数将恐慌。</target>
        </trans-unit>
        <trans-unit id="6b22e102a899811cfc691dccd223a5bfd8615f73" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt; on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new &lt;code&gt;String&lt;/code&gt; and copying the entire contents on every operation, which would lead to &lt;code&gt;O(n^2)&lt;/code&gt; running time when building an &lt;code&gt;n&lt;/code&gt;-byte string by repeated concatenation.</source>
          <target state="translated">这将消耗左侧的 &lt;code&gt;String&lt;/code&gt; 并重新使用其缓冲区（如有必要，将其增大）。这样做是为了避免分配新的 &lt;code&gt;String&lt;/code&gt; 并在每个操作上复制整个内容，这在通过重复连接构建 &lt;code&gt;n&lt;/code&gt; 字节的字符串时会导致 &lt;code&gt;O(n^2)&lt;/code&gt; 运行时间。</target>
        </trans-unit>
        <trans-unit id="ff15f14738d56f849296682dc30e5c72af4309e0" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt; on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new &lt;code&gt;String&lt;/code&gt; and copying the entire contents on every operation, which would lead to &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;^2) running time when building an &lt;em&gt;n&lt;/em&gt;-byte string by repeated concatenation.</source>
          <target state="translated">这将消耗左侧的 &lt;code&gt;String&lt;/code&gt; 并重新使用其缓冲区（如有必要，将其增大）。这样做是为了避免分配新的 &lt;code&gt;String&lt;/code&gt; 并在每个操作上复制整个内容，这在通过重复串联构建&lt;em&gt;n&lt;/em&gt;字节的字符串时会导致&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt; ^ 2）运行时间。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c1a59da820eab802e08d64caefd05fd88b5910a" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt;, so we do not need to copy its contents.</source>
          <target state="translated">这消耗了 &lt;code&gt;String&lt;/code&gt; ，因此我们不需要复制其内容。</target>
        </trans-unit>
        <trans-unit id="1fb456c0fbe6b818fcfe6664fed41526ed5a6d4f" translate="yes" xml:space="preserve">
          <source>This control message contains file descriptors.</source>
          <target state="translated">该控制信息包含文件描述符。</target>
        </trans-unit>
        <trans-unit id="aced2a02c36041d35f97f86959c8c51a1e4fb1a8" translate="yes" xml:space="preserve">
          <source>This control message contains unix credentials.</source>
          <target state="translated">该控制信息包含unix凭证。</target>
        </trans-unit>
        <trans-unit id="bdf3d0a305b0dd41c0720025809f7bbdfc2e29a7" translate="yes" xml:space="preserve">
          <source>This conversion allocates a new error with a simple representation of error kind.</source>
          <target state="translated">这个转换分配了一个新的错误,并对错误种类进行了简单的表示。</target>
        </trans-unit>
        <trans-unit id="680616b748f55e8f2a3a0b7bc442fa697101f3ab" translate="yes" xml:space="preserve">
          <source>This conversion allocates on the heap and performs a copy of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">此转换在堆上分配并执行 &lt;code&gt;s&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="9a31c836c91541651df449cd7fae82a0fb324fe3" translate="yes" xml:space="preserve">
          <source>This conversion allocates on the heap and performs a copy of &lt;code&gt;slice&lt;/code&gt;.</source>
          <target state="translated">此转换在堆上分配并执行 &lt;code&gt;slice&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="9fa8116281488d60de9f3c4d7eaa019ecce22d9b" translate="yes" xml:space="preserve">
          <source>This conversion always returns &lt;code&gt;RecvTimeoutError::Disconnected&lt;/code&gt;.</source>
          <target state="translated">此转换始终返回 &lt;code&gt;RecvTimeoutError::Disconnected&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1ed0a334eeab7a53114c9e9ec5ed0ef897b2581" translate="yes" xml:space="preserve">
          <source>This conversion always returns &lt;code&gt;TryRecvError::Disconnected&lt;/code&gt;.</source>
          <target state="translated">此转换始终返回 &lt;code&gt;TryRecvError::Disconnected&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82865c3f0e8956130ac1b56ac62e2b0276fe13c6" translate="yes" xml:space="preserve">
          <source>This conversion always returns a &lt;code&gt;TrySendError::Disconnected&lt;/code&gt; containing the data in the &lt;code&gt;SendError&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此转换始终返回一个 &lt;code&gt;TrySendError::Disconnected&lt;/code&gt; 其中包含 &lt;code&gt;SendError&amp;lt;T&amp;gt;&lt;/code&gt; 中的数据。</target>
        </trans-unit>
        <trans-unit id="191fbbeba587abac9c4a996c422eb2e1a86f8da6" translate="yes" xml:space="preserve">
          <source>This conversion creates a &lt;a href=&quot;../net/enum.socketaddr#variant.V4&quot;&gt;&lt;code&gt;SocketAddr::V4&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;../net/enum.ipaddr#variant.V4&quot;&gt;&lt;code&gt;IpAddr::V4&lt;/code&gt;&lt;/a&gt; and creates a &lt;a href=&quot;../net/enum.socketaddr#variant.V6&quot;&gt;&lt;code&gt;SocketAddr::V6&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;../net/enum.ipaddr#variant.V6&quot;&gt;&lt;code&gt;IpAddr::V6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这种转换将创建一个&lt;a href=&quot;../net/enum.socketaddr#variant.V4&quot;&gt; &lt;code&gt;SocketAddr::V4&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../net/enum.ipaddr#variant.V4&quot;&gt; &lt;code&gt;IpAddr::V4&lt;/code&gt; &lt;/a&gt;，并创建一个&lt;a href=&quot;../net/enum.socketaddr#variant.V6&quot;&gt; &lt;code&gt;SocketAddr::V6&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../net/enum.ipaddr#variant.V6&quot;&gt; &lt;code&gt;IpAddr::V6&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3e202dba3c3f87c15f9baf72668c6b89f20fb13" translate="yes" xml:space="preserve">
          <source>This conversion creates a &lt;a href=&quot;enum.socketaddr#variant.V4&quot;&gt;&lt;code&gt;SocketAddr::V4&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;enum.ipaddr#variant.V4&quot;&gt;&lt;code&gt;IpAddr::V4&lt;/code&gt;&lt;/a&gt; and creates a &lt;a href=&quot;enum.socketaddr#variant.V6&quot;&gt;&lt;code&gt;SocketAddr::V6&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;enum.ipaddr#variant.V6&quot;&gt;&lt;code&gt;IpAddr::V6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这种转换将创建一个&lt;a href=&quot;enum.socketaddr#variant.V4&quot;&gt; &lt;code&gt;SocketAddr::V4&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.ipaddr#variant.V4&quot;&gt; &lt;code&gt;IpAddr::V4&lt;/code&gt; &lt;/a&gt;，并创建一个&lt;a href=&quot;enum.socketaddr#variant.V6&quot;&gt; &lt;code&gt;SocketAddr::V6&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.ipaddr#variant.V6&quot;&gt; &lt;code&gt;IpAddr::V6&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b1a65936a10e1c346d064991eab656396fb2bba" translate="yes" xml:space="preserve">
          <source>This conversion currently should not allocate memory, but this behavior is not guaranteed on all platforms or in all future versions.</source>
          <target state="translated">这种转换目前不应该分配内存,但这种行为在所有平台或所有未来版本中都不能保证。</target>
        </trans-unit>
        <trans-unit id="e7f2cebd3b32b1fc620100acfba14583ac5721f8" translate="yes" xml:space="preserve">
          <source>This conversion does not allocate on the heap and happens in place.</source>
          <target state="translated">这种转换不在堆上分配,而是就地发生。</target>
        </trans-unit>
        <trans-unit id="ece3abafa7c5e7855afc6b2c712b92113a0c3cfa" translate="yes" xml:space="preserve">
          <source>This conversion does not allocate or copy memory.</source>
          <target state="translated">这种转换不会分配或复制内存。</target>
        </trans-unit>
        <trans-unit id="bfaed574bc93990621932481bdc991a5d31277ba" translate="yes" xml:space="preserve">
          <source>This conversion happens in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time complexity.</source>
          <target state="translated">此转换发生在原地，并且具有&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）时间复杂度。</target>
        </trans-unit>
        <trans-unit id="eb0a6b0407963e31db76813c54686486ddeb6e67" translate="yes" xml:space="preserve">
          <source>This conversion may entail doing a check for UTF-8 validity.</source>
          <target state="translated">这种转换可能需要对UTF-8的有效性进行检查。</target>
        </trans-unit>
        <trans-unit id="0fd6ab28cb16ba2dd2d81ceb7549687e9cec1f65" translate="yes" xml:space="preserve">
          <source>This conversion may entail doing a check for UTF-8 validity. Note that validation is performed because non-UTF-8 strings are perfectly valid for some OS.</source>
          <target state="translated">这种转换可能需要进行UTF-8有效性检查。请注意,进行验证是因为非UTF-8的字符串对某些操作系统完全有效。</target>
        </trans-unit>
        <trans-unit id="8330bc0df78d6eb52dcc8484b74d30aa78ea3703" translate="yes" xml:space="preserve">
          <source>This conversion moves the array to newly heap-allocated memory.</source>
          <target state="translated">这个转换将数组移动到新的堆分配的内存中。</target>
        </trans-unit>
        <trans-unit id="0d8209ee4e143c8cb222975b9c2887b40d4af1c6" translate="yes" xml:space="preserve">
          <source>This conversion requires no data movement or allocation, and has constant time complexity.</source>
          <target state="translated">这种转换不需要数据移动或分配,具有恒定的时间复杂性。</target>
        </trans-unit>
        <trans-unit id="a2f146b8b2fc9fbff68e3aacb1296a0b784db40b" translate="yes" xml:space="preserve">
          <source>This converts the weak pointer into a raw pointer, preserving the original weak count. It can be turned back into the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这会将弱指针转换为原始指针，从而保留原始的弱计数。可以使用&lt;a href=&quot;struct.weak#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt;将其转换为 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="068161e531a8b3af305ba6f7bb36fd2b7ca30a9c" translate="yes" xml:space="preserve">
          <source>This converts the weak pointer into a raw pointer, while still preserving the ownership of one weak reference (the weak count is not modified by this operation). It can be turned back into the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这会将弱指针转换为原始指针，同时仍保留一个弱引用的所有权（此操作不会修改弱计数）。可以使用&lt;a href=&quot;struct.weak#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt;将其转换为 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c699db8a5191d953bd2f9a766d34a17f9fc7bd1" translate="yes" xml:space="preserve">
          <source>This corresponds to the type returned from a generator either with a &lt;code&gt;return&lt;/code&gt; statement or implicitly as the last expression of a generator literal. For example futures would use this as &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; as it represents a completed future.</source>
          <target state="translated">这对应于从带有 &lt;code&gt;return&lt;/code&gt; 语句的生成器返回的类型，或者隐式地作为生成器文字的最后一个表达式。例如，期货将其用作 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 因为它表示已完成的期货。</target>
        </trans-unit>
        <trans-unit id="4049b3c18034165d976b921c99656187a99b1c48" translate="yes" xml:space="preserve">
          <source>This could be called as &lt;code&gt;&amp;lt;Foo as Foo&amp;gt;::foo()&lt;/code&gt;, which would not be able to pick an implementation.</source>
          <target state="translated">这可以称为 &lt;code&gt;&amp;lt;Foo as Foo&amp;gt;::foo()&lt;/code&gt; ，它将无法选择实现。</target>
        </trans-unit>
        <trans-unit id="287539a4f23b39a26818b82e9ae17d404cfd326d" translate="yes" xml:space="preserve">
          <source>This could be caused by a typo. Did you misspell the macro's name?</source>
          <target state="translated">这可能是打字错误造成的。你是不是拼错了宏的名字?</target>
        </trans-unit>
        <trans-unit id="13b235947bdbb45d737ce6790102efc941982f83" translate="yes" xml:space="preserve">
          <source>This crate primarily contains a &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; type. Procedural macros operate over &lt;em&gt;token streams&lt;/em&gt; instead of AST nodes, which is a far more stable interface over time for both the compiler and for procedural macros to target. A &lt;em&gt;token stream&lt;/em&gt; is roughly equivalent to &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; where a &lt;code&gt;TokenTree&lt;/code&gt; can roughly be thought of as lexical token. For example &lt;code&gt;foo&lt;/code&gt; is an &lt;code&gt;Ident&lt;/code&gt; token, &lt;code&gt;.&lt;/code&gt; is a &lt;code&gt;Punct&lt;/code&gt; token, and &lt;code&gt;1.2&lt;/code&gt; is a &lt;code&gt;Literal&lt;/code&gt; token. The &lt;code&gt;TokenStream&lt;/code&gt; type, unlike &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt;, is cheap to clone.</source>
          <target state="translated">此板条箱主要包含&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;类型。程序宏通过&lt;em&gt;令牌流&lt;/em&gt;而不是AST节点进行操作，这对于编译器和程序宏而言都是一个长期稳定的接口。甲&lt;em&gt;令牌流&lt;/em&gt;是大致相当于 &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; 其中 &lt;code&gt;TokenTree&lt;/code&gt; 大致可以认为是词法标记。例如 &lt;code&gt;foo&lt;/code&gt; 是一个 &lt;code&gt;Ident&lt;/code&gt; 令牌 &lt;code&gt;.&lt;/code&gt; 是 &lt;code&gt;Punct&lt;/code&gt; 令牌，而 &lt;code&gt;1.2&lt;/code&gt; 是 &lt;code&gt;Literal&lt;/code&gt; 令牌。与 &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; 不同， &lt;code&gt;TokenStream&lt;/code&gt; 类型易于克隆。</target>
        </trans-unit>
        <trans-unit id="5fc5d0b91b345a05b4241830102cb300bf80ef47" translate="yes" xml:space="preserve">
          <source>This creates another pointer to the same allocation, increasing the strong reference count.</source>
          <target state="translated">这将创建另一个指向同一分配的指针,增加强引用数。</target>
        </trans-unit>
        <trans-unit id="cff1a339d3f6091f32453655f9ee1f32c7930920" translate="yes" xml:space="preserve">
          <source>This creates another pointer to the same inner value, increasing the strong reference count.</source>
          <target state="translated">这将创建另一个指向相同内值的指针,增加强引用数。</target>
        </trans-unit>
        <trans-unit id="c793b99248db7ed16f6d7097d8baba33c4688bf2" translate="yes" xml:space="preserve">
          <source>This defines a trait with two methods. All values that have &lt;a href=&quot;implementations&quot;&gt;implementations&lt;/a&gt; of this trait while the trait is in scope can have their &lt;code&gt;draw&lt;/code&gt; and &lt;code&gt;bounding_box&lt;/code&gt; methods called.</source>
          <target state="translated">这用两种方法定义了特征。当特征在范围内时，具有该特征的所有&lt;a href=&quot;implementations&quot;&gt;实现&lt;/a&gt;的值都可以调用其 &lt;code&gt;draw&lt;/code&gt; 和 &lt;code&gt;bounding_box&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1d48ec195193e5a8a6ddc6d7306e5931fc440ce0" translate="yes" xml:space="preserve">
          <source>This definition is similar to the custom derive macro&amp;rsquo;s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.</source>
          <target state="translated">此定义类似于自定义衍生宏的签名：我们收到括号内的标记，并返回要生成的代码。</target>
        </trans-unit>
        <trans-unit id="7ec7ae52304bec8c18c92988cc904eba30640fe1" translate="yes" xml:space="preserve">
          <source>This definition should now make more sense to you. As you can see, &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is an enum that is generic over type &lt;code&gt;T&lt;/code&gt; and has two variants: &lt;code&gt;Some&lt;/code&gt;, which holds one value of type &lt;code&gt;T&lt;/code&gt;, and a &lt;code&gt;None&lt;/code&gt; variant that doesn&amp;rsquo;t hold any value. By using the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum, we can express the abstract concept of having an optional value, and because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is generic, we can use this abstraction no matter what the type of the optional value is.</source>
          <target state="translated">现在，该定义对您应该更有意义。正如你所看到的， &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 是一个枚举是在类型上是通用 &lt;code&gt;T&lt;/code&gt; ，有两个变种： &lt;code&gt;Some&lt;/code&gt; ，持有型的一个值 &lt;code&gt;T&lt;/code&gt; ，并且 &lt;code&gt;None&lt;/code&gt; 不持有任何价值的变体。通过使用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 枚举，我们可以表达具有可选值的抽象概念，并且由于 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 是通用的，因此无论可选值的类型是什么，我们都可以使用此抽象。</target>
        </trans-unit>
        <trans-unit id="a1dc77bf501a21c3fcf8fcfdb984f36618d4b9d8" translate="yes" xml:space="preserve">
          <source>This demonstrates that we&amp;rsquo;re now using standard output for successful output and standard error for error output as appropriate.</source>
          <target state="translated">这表明我们现在将标准输出用于成功输出，将标准错误用于错误输出。</target>
        </trans-unit>
        <trans-unit id="fab63306db027b7791c0993bab148aa9b72c14e9" translate="yes" xml:space="preserve">
          <source>This description is obviously informal. Making it more precise is expected to proceed as part of a general effort to specify the Rust type checker more precisely.</source>
          <target state="translated">这种描述显然是非正式的。使其更精确是作为更精确地规定Rust类型检查器的普遍努力的一部分。</target>
        </trans-unit>
        <trans-unit id="5155c706e717eca62f9640a389101247c0cf2c80" translate="yes" xml:space="preserve">
          <source>This destructor consists of two components:</source>
          <target state="translated">这个析产器由两个组件组成。</target>
        </trans-unit>
        <trans-unit id="0501267bf2be740a305fdf189b227a4c7486d27e" translate="yes" xml:space="preserve">
          <source>This distinction would also exist in an interpreter. Static checks like syntactic analysis, type checking, and lints should happen before the program is executed regardless of when it is executed.</source>
          <target state="translated">这种区别在解释器中也会存在。语法分析、类型检查和lints等静态检查应该在程序执行之前进行,而不是在程序执行的时候进行。</target>
        </trans-unit>
        <trans-unit id="f074ad4712bf36f567466c2e78802eda538edf52" translate="yes" xml:space="preserve">
          <source>This documentation describes a number of methods and trait implementations on the &lt;code&gt;char&lt;/code&gt; type. For technical reasons, there is additional, separate documentation in &lt;a href=&quot;char/index&quot;&gt;the &lt;code&gt;std::char&lt;/code&gt; module&lt;/a&gt; as well.</source>
          <target state="translated">本文档描述了有关 &lt;code&gt;char&lt;/code&gt; 类型的许多方法和特征实现。由于技术原因，还有额外的，单独的文档&lt;a href=&quot;char/index&quot;&gt;中 &lt;code&gt;std::char&lt;/code&gt; 模块&lt;/a&gt;为好。</target>
        </trans-unit>
        <trans-unit id="68839ac29f4116303cf30db2371868d96097990a" translate="yes" xml:space="preserve">
          <source>This does call the argument's implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这确实调用了参数的&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;的实现。</target>
        </trans-unit>
        <trans-unit id="e9a625eacba45783e02d255cb539fbdd648ae63a" translate="yes" xml:space="preserve">
          <source>This does not include the path to the program as the first argument; it only includes the arguments specified with &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;Command::arg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;Command::args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这不包括程序的路径作为第一个参数。它仅包含&lt;a href=&quot;struct.command#method.arg&quot;&gt; &lt;code&gt;Command::arg&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.command#method.args&quot;&gt; &lt;code&gt;Command::args&lt;/code&gt; &lt;/a&gt;指定的参数。</target>
        </trans-unit>
        <trans-unit id="46fdf1d9a29edff79b3169310e8e3c74c04e6cd6" translate="yes" xml:space="preserve">
          <source>This does not preserve ordering, but is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="translated">这不会保留顺序，而是&lt;em&gt;O&lt;/em&gt;（1）。</target>
        </trans-unit>
        <trans-unit id="cc3143ca0c8ed5c4ad51a7f5632b38d278a744be" translate="yes" xml:space="preserve">
          <source>This does not preserve ordering, but is O(1).</source>
          <target state="translated">这并没有保留排序,但是是O(1)。</target>
        </trans-unit>
        <trans-unit id="302cbd1c584e8c39bda1206e23be2bed7460cc52" translate="yes" xml:space="preserve">
          <source>This does not take ownership of the original allocation and requires no resource management later, but you must not use the pointer after its lifetime.</source>
          <target state="translated">这样做并不占有原始分配的所有权,以后也不需要资源管理,但在指针寿命结束后不得使用。</target>
        </trans-unit>
        <trans-unit id="601f0aa53280d7fb3fab96e73d4cc042d197513d" translate="yes" xml:space="preserve">
          <source>This does so by calling the argument's implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过调用参数的&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;的实现来做到这一点。</target>
        </trans-unit>
        <trans-unit id="7ec03adb1087f5abb7a8507c877e74407679b28c" translate="yes" xml:space="preserve">
          <source>This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 大小为零，则实际上不会分配。</target>
        </trans-unit>
        <trans-unit id="1a27813265527dd550d73a565f67475ec4a26516" translate="yes" xml:space="preserve">
          <source>This effectively does nothing for types which implement &lt;code&gt;Copy&lt;/code&gt;, e.g. integers. Such values are copied and &lt;em&gt;then&lt;/em&gt; moved into the function, so the value persists after this function call.</source>
          <target state="translated">对于实现 &lt;code&gt;Copy&lt;/code&gt; 的类型，例如整数，这实际上不起作用。此类值将被复制，&lt;em&gt;然后&lt;/em&gt;移入函数，因此该值在此函数调用后仍然存在。</target>
        </trans-unit>
        <trans-unit id="eb1f652575dd2244737e0203d7e6859c386e1f92" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI128&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i128&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI128&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i128&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="f67f6cc0c2c10dc19997b3839443098a644f1d26" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI16&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i16&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI16&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i16&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="734061adf87b0795fad2886322ea47c0aec2f2ad" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI32&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI32&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i32&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="00340c6c435ce7c1fdb4cf194be81cf07905d3dd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI64&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i64&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI64&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i64&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="278e3b6e04cd3eac83950c68db7f2e8e510eb775" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i8&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI8&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i8&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="d6a41567af1e9968e9c90e92ec21b8804316cfe8" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroIsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;isize&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroIsize&amp;gt;&lt;/code&gt; 与 &lt;code&gt;isize&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="cf2e6ed40009c7af3e4c82c9a64e0f2f0797bce2" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU128&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u128&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU128&amp;gt;&lt;/code&gt; 与 &lt;code&gt;u128&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="76da8b2ba60cec40f8f5e62e107f1dbcb755bbbb" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU16&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u16&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU16&amp;gt;&lt;/code&gt; 与 &lt;code&gt;u16&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="ccbf5b5bf97bc9198c28f18b82543d27c5b27285" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU32&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u32&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU32&amp;gt;&lt;/code&gt; 是大小为相同 &lt;code&gt;u32&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="538d2876995cecf5e64928ddfeb01ab1a800bbde" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU64&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u64&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU64&amp;gt;&lt;/code&gt; 与 &lt;code&gt;u64&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
