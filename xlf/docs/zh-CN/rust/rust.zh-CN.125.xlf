<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="f18ea48cefb527612333927e42f98b5493e80a96" translate="yes" xml:space="preserve">
          <source>Ancestors::try_from</source>
          <target state="translated">Ancestors::try_from</target>
        </trans-unit>
        <trans-unit id="f07951de2fcfeba585ae159316c166c38d8606b4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_into</source>
          <target state="translated">Ancestors::try_into</target>
        </trans-unit>
        <trans-unit id="0008829b37e7881a29a429bd8ff5a7a5ef753374" translate="yes" xml:space="preserve">
          <source>Ancestors::type_id</source>
          <target state="translated">Ancestors::type_id</target>
        </trans-unit>
        <trans-unit id="04f137aff1969f866b7d2666a9252de9e0efa21b" translate="yes" xml:space="preserve">
          <source>Ancestors::unzip</source>
          <target state="translated">Ancestors::unzip</target>
        </trans-unit>
        <trans-unit id="55dbfc2c3d770eaac08b3c73d87bccce57c4f78d" translate="yes" xml:space="preserve">
          <source>Ancestors::zip</source>
          <target state="translated">Ancestors::zip</target>
        </trans-unit>
        <trans-unit id="49a40db56fe6180d9e3eb242542f45d2d3173d4f" translate="yes" xml:space="preserve">
          <source>AncillaryData</source>
          <target state="translated">AncillaryData</target>
        </trans-unit>
        <trans-unit id="8c3f77779f46bdbd3940ac1fe6a4e53f4cdfa790" translate="yes" xml:space="preserve">
          <source>AncillaryError</source>
          <target state="translated">AncillaryError</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="42b71964be13234f4cbc3e386af8045e5f37b66e" translate="yes" xml:space="preserve">
          <source>And &lt;em&gt;src/front_of_house.rs&lt;/em&gt; gets the definitions from the body of the &lt;code&gt;front_of_house&lt;/code&gt; module, as shown in Listing 7-22.</source>
          <target state="translated">和&lt;em&gt;SRC / front_of_house.rs&lt;/em&gt;得到从身体的定义 &lt;code&gt;front_of_house&lt;/code&gt; 模块，如清单7-22英寸</target>
        </trans-unit>
        <trans-unit id="a66dda047400c5c52222e76fafe04295868d79a8" translate="yes" xml:space="preserve">
          <source>And a very common source of output is standard output:</source>
          <target state="translated">而一个很常见的输出来源就是标准输出。</target>
        </trans-unit>
        <trans-unit id="5cd52670a2b07449cbe1bd4abb403c682ccaf168" translate="yes" xml:space="preserve">
          <source>And finally, for the last example, only &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; work as explicit self parameters. Example:</source>
          <target state="translated">最后，对于最后一个示例，只有 &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;amp;Self&lt;/code&gt; ， &lt;code&gt;Self&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; 用作显式的self参数。例子：</target>
        </trans-unit>
        <trans-unit id="b91a984e8eba980f8ed5afc44476d8d32720a1d5" translate="yes" xml:space="preserve">
          <source>And finally, let&amp;rsquo;s make sure that we don&amp;rsquo;t get any lines when we search for a word that isn&amp;rsquo;t anywhere in the poem, such as &amp;ldquo;monomorphization&amp;rdquo;:</source>
          <target state="translated">最后，让我们确保在搜索诗歌中没有出现的单词时不会出现任何行，例如&amp;ldquo; monomorphization&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="8ddbbced7930dcaf198948383ed803d74e9323cf" translate="yes" xml:space="preserve">
          <source>And finally, the standard library exports a number of standard macros, and &lt;a href=&quot;#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.</source>
          <target state="translated">最后，标准库导出许多标准宏，并&lt;a href=&quot;#macros&quot;&gt;在此页上列出它们&lt;/a&gt;（从技术上讲，并非所有标准宏都由标准库定义-有些是由编译器定义的-但此处记录的内容相同） 。像前奏一样，默认情况下会将标准宏导入所有板条箱中。</target>
        </trans-unit>
        <trans-unit id="01c604c6cbed200d9271efd93c6961cdbaa99ebc" translate="yes" xml:space="preserve">
          <source>And now let's give working examples:</source>
          <target state="translated">现在让我们举出工作实例。</target>
        </trans-unit>
        <trans-unit id="076add01b447af4a01e4ff6b95c8cd6d23f8bbbe" translate="yes" xml:space="preserve">
          <source>And now some working examples:</source>
          <target state="translated">现在是一些工作实例。</target>
        </trans-unit>
        <trans-unit id="3e0adb51e88db164baaa3fd268ad64b534eb5476" translate="yes" xml:space="preserve">
          <source>And so on.</source>
          <target state="translated">以此类推。</target>
        </trans-unit>
        <trans-unit id="965c5135f65b1edbef655afbf975cd109690bf20" translate="yes" xml:space="preserve">
          <source>And so, our final result, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">因此，我们的最终结果为 &lt;code&gt;6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8576d009cd19a7310431c770ccd6d0477a9a38f5" translate="yes" xml:space="preserve">
          <source>And the expected output would look like the following, because both dimensions of &lt;code&gt;rect2&lt;/code&gt; are smaller than the dimensions of &lt;code&gt;rect1&lt;/code&gt; but &lt;code&gt;rect3&lt;/code&gt; is wider than &lt;code&gt;rect1&lt;/code&gt;:</source>
          <target state="translated">预期的输出将类似于以下内容，因为 &lt;code&gt;rect2&lt;/code&gt; 的两个尺寸都小于 &lt;code&gt;rect1&lt;/code&gt; 的尺寸，而 &lt;code&gt;rect3&lt;/code&gt; 的尺寸大于 &lt;code&gt;rect1&lt;/code&gt; 的尺寸：</target>
        </trans-unit>
        <trans-unit id="304a9abb7c8dbb46b1cac5f34e7d81eb70527d19" translate="yes" xml:space="preserve">
          <source>And the following is the same example, except using &lt;a href=&quot;generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;.</source>
          <target state="translated">以下是相同的示例，除了使用&lt;a href=&quot;generics#where-clauses&quot;&gt;where子句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="913d407459e0226b150e7a70e74b4001bb096c87" translate="yes" xml:space="preserve">
          <source>And then usage on the derive macro on a struct:</source>
          <target state="translated">然后在结构体上的派生宏上使用。</target>
        </trans-unit>
        <trans-unit id="16869e8d4badcf1212b889f654db64e52cba8e49" translate="yes" xml:space="preserve">
          <source>And then using said derive macro:</source>
          <target state="translated">然后使用所述派生宏。</target>
        </trans-unit>
        <trans-unit id="fde456d658fb04a2082b8789148df9b0dd8dabdb" translate="yes" xml:space="preserve">
          <source>And then we use it a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">然后我们用它一个二进制箱子把 &quot;42 &quot;打印成标准输出。</target>
        </trans-unit>
        <trans-unit id="57be02e986031e930e9bf37db6620140ea92c664" translate="yes" xml:space="preserve">
          <source>And then we use it in a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">然后我们用它在二进制箱中打印 &quot;42 &quot;到标准输出。</target>
        </trans-unit>
        <trans-unit id="843c5d94071a4fae0f20d3e75ea70e29673c03d4" translate="yes" xml:space="preserve">
          <source>And we can call this function with either variant:</source>
          <target state="translated">而我们可以用任何一种变体来调用这个函数。</target>
        </trans-unit>
        <trans-unit id="406aea8920a159db743c7e055df50170c501f68e" translate="yes" xml:space="preserve">
          <source>And we&amp;rsquo;re done&amp;mdash;all of Listing 17-11 now works! We&amp;rsquo;ve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">至此我们已经完成了，清单17-11中的所有代码现在都可以使用了！我们已经按照博客文章工作流程的规则实现了状态模式。与规则相关的逻辑存在于状态对象中，而不是分散在整个 &lt;code&gt;Post&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d71a2256704824ddf84d5c0504e7d9d40555e056" translate="yes" xml:space="preserve">
          <source>And you make a hard link of the program:</source>
          <target state="translated">而且你要做一个程序的硬链接。</target>
        </trans-unit>
        <trans-unit id="1a652f499d8171d97dc8db68df0dbf0a99d7c3f2" translate="yes" xml:space="preserve">
          <source>AndAnd</source>
          <target state="translated">AndAnd</target>
        </trans-unit>
        <trans-unit id="bcffbb2710fb4ff9f2236988e5b2ed04ecff3723" translate="yes" xml:space="preserve">
          <source>AndEq</source>
          <target state="translated">AndEq</target>
        </trans-unit>
        <trans-unit id="c4af9f801ba386b4d95b5962fd0aee793823a0c6" translate="yes" xml:space="preserve">
          <source>Anonymous type parameters</source>
          <target state="translated">匿名类型参数</target>
        </trans-unit>
        <trans-unit id="f739dc0ff02bf7ebdbbaf543c53bc8d5f32aa9b9" translate="yes" xml:space="preserve">
          <source>Another aspect commonly associated with OOP is the idea of &lt;em&gt;encapsulation&lt;/em&gt;, which means that the implementation details of an object aren&amp;rsquo;t accessible to code using that object. Therefore, the only way to interact with an object is through its public API; code using the object shouldn&amp;rsquo;t be able to reach into the object&amp;rsquo;s internals and change data or behavior directly. This enables the programmer to change and refactor an object&amp;rsquo;s internals without needing to change the code that uses the object.</source>
          <target state="translated">通常与OOP相关的另一个方面是&lt;em&gt;封装&lt;/em&gt;的概念，这意味着使用该对象的代码无法访问对象的实现细节。因此，与对象交互的唯一方法是通过其公共API。使用对象的代码不应能够深入到对象的内部并直接更改数据或行为。这使程序员可以更改和重构对象的内部结构，而无需更改使用该对象的代码。</target>
        </trans-unit>
        <trans-unit id="3244c196f26eb3ebda5753ab0aa6df5308b053cc" translate="yes" xml:space="preserve">
          <source>Another case that causes this error is when a type is imported into a parent module. To fix this, you can follow the suggestion and use File directly or &lt;code&gt;use super::File;&lt;/code&gt; which will import the types from the parent namespace. An example that causes this error is below:</source>
          <target state="translated">导致此错误的另一种情况是将类型导入到父模块中时。要解决此问题，您可以按照建议并直接使用File或 &lt;code&gt;use super::File;&lt;/code&gt; 它将从父名称空间导入类型。导致此错误的示例如下：</target>
        </trans-unit>
        <trans-unit id="f5177285c1540f1a230a9212d6ad08c740059bb0" translate="yes" xml:space="preserve">
          <source>Another case where this error is emitted is when a value is expected, but something else is found:</source>
          <target state="translated">发出这个错误的另一种情况是,当一个值是预期的,但发现了其他东西。</target>
        </trans-unit>
        <trans-unit id="583bae5ce904e4cf097b6105871c304a4243a347" translate="yes" xml:space="preserve">
          <source>Another common use case for hash maps is to look up a key&amp;rsquo;s value and then update it based on the old value. For instance, Listing 8-26 shows code that counts how many times each word appears in some text. We use a hash map with the words as keys and increment the value to keep track of how many times we&amp;rsquo;ve seen that word. If it&amp;rsquo;s the first time we&amp;rsquo;ve seen a word, we&amp;rsquo;ll first insert the value 0.</source>
          <target state="translated">哈希映射的另一个常见用例是查找键的值，然后根据旧值对其进行更新。例如，清单8-26显示了用于计算每个单词在某些文本中出现的次数的代码。我们使用带有单词作为键的哈希图，并增加值以跟踪我们看到该单词的次数。如果这是我们第一次看到一个单词，我们将首先插入值0。</target>
        </trans-unit>
        <trans-unit id="6faac33ab3de2071db8e2f1ae3893ca39a492717" translate="yes" xml:space="preserve">
          <source>Another common way to evaluate an iterator is to use the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">评估迭代器的另一种常用方法是使用&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;方法来产生一个新的集合。</target>
        </trans-unit>
        <trans-unit id="dc4154c9de58b2e0fcab49a95a24b663a485fc7b" translate="yes" xml:space="preserve">
          <source>Another crate that depends on this library would need &lt;code&gt;use&lt;/code&gt; statements that bring the items from &lt;code&gt;art&lt;/code&gt; into scope, specifying the module structure that&amp;rsquo;s currently defined. Listing 14-4 shows an example of a crate that uses the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; items from the &lt;code&gt;art&lt;/code&gt; crate:</source>
          <target state="translated">依赖此库的另一个包装箱将需要 &lt;code&gt;use&lt;/code&gt; 语句，这些语句将 &lt;code&gt;art&lt;/code&gt; 的商品带入范围，并指定当前定义的模块结构。清单14-4显示了一个使用 &lt;code&gt;PrimaryColor&lt;/code&gt; 并 &lt;code&gt;mix&lt;/code&gt; &lt;code&gt;art&lt;/code&gt; 箱中物品的箱子示例：</target>
        </trans-unit>
        <trans-unit id="36e9fb79f8131b77a6b5deaea1a5127794ef21b6" translate="yes" xml:space="preserve">
          <source>Another data type that does not have ownership is the &lt;em&gt;slice&lt;/em&gt;. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</source>
          <target state="translated">&lt;em&gt;slice&lt;/em&gt;也是另一个没有所有权的数据类型。切片使您可以引用集合中连续的元素序列，而不是整个集合。</target>
        </trans-unit>
        <trans-unit id="2188fdee49af653aee0e28e4ac63dee8849194f0" translate="yes" xml:space="preserve">
          <source>Another detail to note is that Rust can&amp;rsquo;t protect you from all kinds of logic errors when you use &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. Recall in Chapter 15 that using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; came with the risk of creating reference cycles, where two &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; values refer to each other, causing memory leaks. Similarly, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; comes with the risk of creating &lt;em&gt;deadlocks&lt;/em&gt;. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you&amp;rsquo;re interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;MutexGuard&lt;/code&gt; offers useful information.</source>
          <target state="translated">要注意的另一个细节是，当您使用 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 时，Rust无法保护您免受各种逻辑错误的影响。在第15章中回顾过，使用 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 存在创建参考周期的风险，其中两个 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值相互引用，从而导致内存泄漏。同样， &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 带有创建&lt;em&gt;死锁&lt;/em&gt;的风险&lt;em&gt;&lt;/em&gt;。当操作需要锁定两个资源并且两个线程各自获得了一个锁，从而导致它们永远等待时，就会发生这种情况。如果您对死锁感兴趣，请尝试创建一个有死锁的Rust程序。然后研究任何语言的互斥锁的缓解僵局的策略，并尝试在Rust中实现它们。 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;MutexGuard&lt;/code&gt; 的标准库API文档提供了有用的信息。</target>
        </trans-unit>
        <trans-unit id="a89f510396bf7e7d6ce47105d5094f9ffdc43c0a" translate="yes" xml:space="preserve">
          <source>Another difference between constants and static variables is that static variables can be mutable. Accessing and modifying mutable static variables is &lt;em&gt;unsafe&lt;/em&gt;. Listing 19-10 shows how to declare, access, and modify a mutable static variable named &lt;code&gt;COUNTER&lt;/code&gt;.</source>
          <target state="translated">常量和静态变量之间的另一个区别是静态变量可以是可变的。访问和修改可变静态变量是&lt;em&gt;不安全的&lt;/em&gt;。清单19-10显示了如何声明，访问和修改名为 &lt;code&gt;COUNTER&lt;/code&gt; 的可变静态变量。</target>
        </trans-unit>
        <trans-unit id="7e6b390982d432e5d51ecddfefa741ac598bed4a" translate="yes" xml:space="preserve">
          <source>Another downside is that we&amp;rsquo;ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods on the &lt;code&gt;State&lt;/code&gt; trait that return &lt;code&gt;self&lt;/code&gt;; however, this would violate object safety, because the trait doesn&amp;rsquo;t know what the concrete &lt;code&gt;self&lt;/code&gt; will be exactly. We want to be able to use &lt;code&gt;State&lt;/code&gt; as a trait object, so we need its methods to be object safe.</source>
          <target state="translated">另一个缺点是我们重复了一些逻辑。为了消除某些重复，我们可以尝试为 &lt;code&gt;request_review&lt;/code&gt; 设置默认实现，并 &lt;code&gt;approve&lt;/code&gt; 返回 &lt;code&gt;self&lt;/code&gt; 的 &lt;code&gt;State&lt;/code&gt; trait 方法。但是，这会违反对象安全性，因为特征不知道具体的 &lt;code&gt;self&lt;/code&gt; 确切是什么。我们希望能够将 &lt;code&gt;State&lt;/code&gt; 用作特征对象，因此我们需要其方法成为对象安全的。</target>
        </trans-unit>
        <trans-unit id="0b90ca84780d33c44fc3e74f14be69eb7fd048f1" translate="yes" xml:space="preserve">
          <source>Another erroneous code example:</source>
          <target state="translated">又是一个错误的代码例子。</target>
        </trans-unit>
        <trans-unit id="b9c6fc1e93014c21a06c17d750322f830024d1b0" translate="yes" xml:space="preserve">
          <source>Another example of a complex NT is &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt;, which matches any fragment of the form &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; where &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; occurs at least once. Note that this complex NT does not have a dedicated separator token.</source>
          <target state="translated">复杂NT的另一个示例是 &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt; ，它匹配 &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; 形式的任何片段；嗨&amp;lt;expr&amp;gt;; ...其中 &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; 至少发生一次。请注意，此复杂的NT没有专用的分隔符。</target>
        </trans-unit>
        <trans-unit id="7ec0f590b55aa6269d2b833239d2434dfe2c8db0" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">非 &lt;code&gt;Sync&lt;/code&gt; 类型的另一个示例是引用计数指针&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;。给定任何引用&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，您可以克隆一个新的&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，以非原子方式修改引用计数。</target>
        </trans-unit>
        <trans-unit id="93c5ab10f51e34387707bf7df6173ca28d162973" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">非 &lt;code&gt;Sync&lt;/code&gt; 类型的另一个示例是引用计数指针&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt;。给定任何引用&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，您可以克隆新的&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，以非原子方式修改引用计数。</target>
        </trans-unit>
        <trans-unit id="5d9b32be0b7923daf9aadae8867f04bd738917c6" translate="yes" xml:space="preserve">
          <source>Another example showing how to keep &lt;code&gt;Cow&lt;/code&gt; in a struct:</source>
          <target state="translated">另一个显示如何将 &lt;code&gt;Cow&lt;/code&gt; 保留在结构中的示例：</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">另一个例子:</target>
        </trans-unit>
        <trans-unit id="73dbef5057ac390e03a6e177bceb38dfa0e2cca7" translate="yes" xml:space="preserve">
          <source>Another implication of the 4-byte fixed size of a &lt;code&gt;char&lt;/code&gt; is that per-&lt;code&gt;char&lt;/code&gt; processing can end up using a lot more memory:</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 的4字节固定大小的另一个含义是，每次进行 &lt;code&gt;char&lt;/code&gt; 处理可能会使用更多的内存：</target>
        </trans-unit>
        <trans-unit id="8ab43d76c6773436cfee7acbc8b6406943d7ca07" translate="yes" xml:space="preserve">
          <source>Another important difference between macros and functions is that you must define macros or bring them into scope &lt;em&gt;before&lt;/em&gt; you call them in a file, as opposed to functions you can define anywhere and call anywhere.</source>
          <target state="translated">宏和函数之间的另一个重要区别是，在文件中调用宏&lt;em&gt;之前&lt;/em&gt;，必须先定义宏或将其置于范围内，而不是可以在任何地方定义和调用的函数。</target>
        </trans-unit>
        <trans-unit id="6f8bbe73702fb41924bac262bfb8595f3c660f2c" translate="yes" xml:space="preserve">
          <source>Another indicator that shows there&amp;rsquo;s room for improvement is the &lt;code&gt;config&lt;/code&gt; part of &lt;code&gt;parse_config&lt;/code&gt;, which implies that the two values we return are related and are both part of one configuration value. We&amp;rsquo;re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we could put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.</source>
          <target state="translated">另一个显示有待改进的指标是 &lt;code&gt;parse_config&lt;/code&gt; 的 &lt;code&gt;config&lt;/code&gt; 部分，这意味着我们返回的两个值是相关的，并且都是一个配置值的一部分。除了将两个值分组为一个元组外，我们目前不在数据结构中传达此含义。我们可以将两个值放到一个结构中，并为每个结构字段赋予一个有意义的名称。这样做将使以后的代码维护人员更容易理解不同值之间的相互关系以及它们的用途。</target>
        </trans-unit>
        <trans-unit id="00e0685682ab1fea96a488f384eaf2fdca89f82c" translate="yes" xml:space="preserve">
          <source>Another kind of generic that we&amp;rsquo;ve already been using is called &lt;em&gt;lifetimes&lt;/em&gt;. Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be. Let&amp;rsquo;s look at how lifetimes do that.</source>
          <target state="translated">我们已经在使用的另一种泛型称为&lt;em&gt;寿命&lt;/em&gt;。生命周期不是确保类型具有我们想要的行为，而是确保只要我们需要引用就有效。让我们看一生如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="310cbb5c9fbbbdff4450ff99ffebe8e97470ef1e" translate="yes" xml:space="preserve">
          <source>Another method, &lt;code&gt;expect&lt;/code&gt;, which is similar to &lt;code&gt;unwrap&lt;/code&gt;, lets us also choose the &lt;code&gt;panic!&lt;/code&gt; error message. Using &lt;code&gt;expect&lt;/code&gt; instead of &lt;code&gt;unwrap&lt;/code&gt; and providing good error messages can convey your intent and make tracking down the source of a panic easier. The syntax of &lt;code&gt;expect&lt;/code&gt; looks like this:</source>
          <target state="translated">另一种方法， &lt;code&gt;expect&lt;/code&gt; ，这是类似的 &lt;code&gt;unwrap&lt;/code&gt; ，让我们也选择了 &lt;code&gt;panic!&lt;/code&gt; 错误信息。使用 &lt;code&gt;expect&lt;/code&gt; 而不是 &lt;code&gt;unwrap&lt;/code&gt; 并提供良好的错误消息可以传达您的意图，并使跟踪恐慌的根源更加容易。语法 &lt;code&gt;expect&lt;/code&gt; 这个样子的：</target>
        </trans-unit>
        <trans-unit id="f5499cba2c47a56c76648e5bfb00e8274cd4700a" translate="yes" xml:space="preserve">
          <source>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust&amp;rsquo;s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call &lt;em&gt;letters&lt;/em&gt;).</source>
          <target state="translated">关于UTF-8的另一点是，从Rust的角度来看，实际上有三种相关的方式来查看字符串：字节，标量值和字素簇（最接近于我们所称的&lt;em&gt;字母&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="81bb35319cfe55cae7a1b6f8b640c268f984543f" translate="yes" xml:space="preserve">
          <source>Another problem you might be facing is this: suppose you've overloaded the &lt;code&gt;+&lt;/code&gt; operator for some type &lt;code&gt;Foo&lt;/code&gt; by implementing the &lt;code&gt;std::ops::Add&lt;/code&gt; trait for &lt;code&gt;Foo&lt;/code&gt;, but you find that using &lt;code&gt;+=&lt;/code&gt; does not work, as in this example:</source>
          <target state="translated">你可能会面临的另一个问题是这样的：假设你已经超载 &lt;code&gt;+&lt;/code&gt; 对于一些类型的操作 &lt;code&gt;Foo&lt;/code&gt; 通过实施 &lt;code&gt;std::ops::Add&lt;/code&gt; 的特质对 &lt;code&gt;Foo&lt;/code&gt; ，但你会发现，使用 &lt;code&gt;+=&lt;/code&gt; 不起作用，如本例：</target>
        </trans-unit>
        <trans-unit id="aac5c18dffed07c8f0aa7695dfba8d6c18e4b19b" translate="yes" xml:space="preserve">
          <source>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn&amp;rsquo;t let you do unsafe operations, you couldn&amp;rsquo;t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let&amp;rsquo;s explore what we can do with unsafe Rust and how to do it.</source>
          <target state="translated">Rust具有不安全的变更自我的另一个原因是底层计算机硬件本质上是不安全的。如果Rust不允许您执行不安全的操作，则您将无法执行某些任务。 Rust需要允许您进行低级系统编程，例如直接与操作系统进行交互，甚至编写自己的操作系统。使用低级系统编程是该语言的目标之一。让我们探索不安全的Rust可以做什么，以及如何去做。</target>
        </trans-unit>
        <trans-unit id="ea0e4d862c74d436d68a36a2f5a91a9f7ba71ea8" translate="yes" xml:space="preserve">
          <source>Another shortcut for struct instantiation is available, used when you need to make a new struct that has the same values as most of a previous struct of the same type, called struct update syntax:</source>
          <target state="translated">另外还有一种结构实例化的快捷方式,当你需要制作一个新的结构,它的值与以前的同类型结构的大部分值相同时使用,称为结构更新语法。</target>
        </trans-unit>
        <trans-unit id="f3ef4925d92f67dd0f9c6ef4b106d217ff19945f" translate="yes" xml:space="preserve">
          <source>Another situation where this might be encountered is when spawning threads:</source>
          <target state="translated">另一种可能遇到的情况是在产线程的时候。</target>
        </trans-unit>
        <trans-unit id="34208ffcc5dda542066ff03ecbdd472bf7d5f1c2" translate="yes" xml:space="preserve">
          <source>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don&amp;rsquo;t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want &lt;code&gt;Cons&lt;/code&gt; variants to own their list, so reorganizing the data structure isn&amp;rsquo;t possible. Let&amp;rsquo;s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</source>
          <target state="translated">避免引用周期的另一种解决方案是重新组织数据结构，以便某些引用表示所有权而有些引用则不。结果，您可以使周期由一些所有权关系和一些非所有权关系组成，并且只有所有权关系会影响是否可以删除值。在清单15-25中，我们始终希望 &lt;code&gt;Cons&lt;/code&gt; 变体拥有其列表，因此无法重组数据结构。让我们看一个示例，该示例使用由父节点和子节点组成的图来查看何时非所有权关系是防止引用周期的合适方法。</target>
        </trans-unit>
        <trans-unit id="561d97b6164c78f724fabd7e84d16f2ca6a5f05e" translate="yes" xml:space="preserve">
          <source>Another style of doc comment, &lt;code&gt;//!&lt;/code&gt;, adds documentation to the item that contains the comments rather than adding documentation to the items following the comments. We typically use these doc comments inside the crate root file (&lt;em&gt;src/lib.rs&lt;/em&gt; by convention) or inside a module to document the crate or the module as a whole.</source>
          <target state="translated">文档注释的另一种样式， &lt;code&gt;//!&lt;/code&gt; ，将文档添加到包含注释的项目，而不是将文档添加到注释之后的项目。我们通常在板条箱根文件（&lt;em&gt;按惯例src / lib.rs&lt;/em&gt;）或模块内部使用这些doc注释，以记录板条箱或整个模块。</target>
        </trans-unit>
        <trans-unit id="7c509361e45630a3070d0b558a9e089279230886" translate="yes" xml:space="preserve">
          <source>Another use case for &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 另一个用例是实现不安全的特征。当特征的至少一种方法具有一些编译器无法验证的不变式时，它是不安全的。我们可以声明一个特点是 &lt;code&gt;unsafe&lt;/code&gt; 通过添加 &lt;code&gt;unsafe&lt;/code&gt; 之前关键字 &lt;code&gt;trait&lt;/code&gt; 和标记性状为实施 &lt;code&gt;unsafe&lt;/code&gt; 太，如清单19-11英寸</target>
        </trans-unit>
        <trans-unit id="bfe5186a552091b0c590be070139e735a13d8759" translate="yes" xml:space="preserve">
          <source>Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</source>
          <target state="translated">newtype模式的另一个用途是在抽象掉一个类型的一些实现细节:例如,如果我们直接使用新类型来限制可用的功能,那么新类型可以暴露出一个与私有内类型的API不同的公共API。</target>
        </trans-unit>
        <trans-unit id="5796386c80b53dfd4fee86ac2eb96a8dcc028b10" translate="yes" xml:space="preserve">
          <source>Another useful feature of &lt;code&gt;impl&lt;/code&gt; blocks is that we&amp;rsquo;re allowed to define functions within &lt;code&gt;impl&lt;/code&gt; blocks that &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; take &lt;code&gt;self&lt;/code&gt; as a parameter. These are called &lt;em&gt;associated functions&lt;/em&gt; because they&amp;rsquo;re associated with the struct. They&amp;rsquo;re still functions, not methods, because they don&amp;rsquo;t have an instance of the struct to work with. You&amp;rsquo;ve already used the &lt;code&gt;String::from&lt;/code&gt; associated function.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 块的另一个有用功能是允许我们在&lt;em&gt;不&lt;/em&gt;以 &lt;code&gt;self&lt;/code&gt; 为参数的 &lt;code&gt;impl&lt;/code&gt; 块中定义函数。这些被称为&lt;em&gt;关联函数，&lt;/em&gt;因为它们与结构关联。它们仍然是函数，而不是方法，因为它们没有可使用的结构实例。您已经使用了 &lt;code&gt;String::from&lt;/code&gt; 关联函数。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30235cc37ef7579d4a5373609eca2f1e91e01f9f" translate="yes" xml:space="preserve">
          <source>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</source>
          <target state="translated">匹配臂的另一个有用的特性是,它们可以绑定到与模式匹配的值的部分。这就是我们如何从枚举变体中提取值的方法。</target>
        </trans-unit>
        <trans-unit id="03644769062de97f25c38104b0372355c4a77983" translate="yes" xml:space="preserve">
          <source>Another way is to do away with the associated type in &lt;code&gt;Maker&lt;/code&gt; and use an input type parameter instead:</source>
          <target state="translated">另一种方法是取消 &lt;code&gt;Maker&lt;/code&gt; 中的关联类型，而使用输入类型参数：</target>
        </trans-unit>
        <trans-unit id="6f7bb901bc2f8efc6ca57a7f109d4ad53f1c9e20" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using iterators and the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. We&amp;rsquo;ll be going into more detail about iterators and their associated methods in the &lt;a href=&quot;ch13-02-iterators&quot;&gt;&amp;rdquo;Processing a Series of Items with Iterators&amp;rdquo; section of Chapter 13&lt;/a&gt;. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">构造哈希映射的另一种方法是在元组的向量上使用迭代器和 &lt;code&gt;collect&lt;/code&gt; 方法，其中每个元组都由一个键及其值组成。我们将在&lt;a href=&quot;ch13-02-iterators&quot;&gt;第13章的&amp;ldquo;使用迭代器处理一系列项目&amp;rdquo;中&lt;/a&gt;详细介绍迭代器及其相关方法。该 &lt;code&gt;collect&lt;/code&gt; 方法收集的数据为若干集合类型，包括 &lt;code&gt;HashMap&lt;/code&gt; 中。例如，如果我们在两个单独的向量中具有团队名称和初始得分，则可以使用 &lt;code&gt;zip&lt;/code&gt; 方法创建一个元组向量，其中&amp;ldquo;蓝色&amp;rdquo;与10配对，依此类推。然后，我们可以使用 &lt;code&gt;collect&lt;/code&gt; 方法将元组的向量转换为哈希图，如清单8-21所示。</target>
        </trans-unit>
        <trans-unit id="ccc69aa411fffd31870708506663671f3a6766b5" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">构造哈希图的另一种方法是在元组的向量上使用 &lt;code&gt;collect&lt;/code&gt; 方法，其中每个元组都由一个键及其值组成。该 &lt;code&gt;collect&lt;/code&gt; 方法收集的数据为若干集合类型，包括 &lt;code&gt;HashMap&lt;/code&gt; 中。例如，如果我们在两个单独的向量中具有团队名称和初始得分，则可以使用 &lt;code&gt;zip&lt;/code&gt; 方法创建一个元组向量，其中&amp;ldquo;蓝色&amp;rdquo;与10配对，依此类推。然后，我们可以使用 &lt;code&gt;collect&lt;/code&gt; 方法将元组的向量转换为哈希图，如清单8-21所示。</target>
        </trans-unit>
        <trans-unit id="56bc825abe2ef1255ee87da2e4f261c23258e491" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">另一种思考 &lt;code&gt;flat_map()&lt;/code&gt; 的方式：&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;的闭包为每个元素返回一个项目，而 &lt;code&gt;flat_map()&lt;/code&gt; 的闭包为每个元素返回一个迭代器。</target>
        </trans-unit>
        <trans-unit id="d1f28d9b77a5082f5c9d67a87d7ff9fdc9ab88db" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">另一种思考 &lt;code&gt;flat_map()&lt;/code&gt; 的方式：&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;的闭包为每个元素返回一个项目，而 &lt;code&gt;flat_map()&lt;/code&gt; 的闭包为每个元素返回一个迭代器。</target>
        </trans-unit>
        <trans-unit id="590fe2daae703b4f29d9d514cb7fe9863489ba23" translate="yes" xml:space="preserve">
          <source>Another way to access union fields is to use pattern matching. Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field. Since pattern matching is like reading the union with a particular field, it has to be placed in &lt;code&gt;unsafe&lt;/code&gt; blocks as well.</source>
          <target state="translated">访问联合字段的另一种方法是使用模式匹配。联合字段上的模式匹配使用与结构模式相同的语法，不同之处在于模式必须恰好指定一个字段。由于模式匹配就像读取具有特定字段的联合，因此也必须将其放置在 &lt;code&gt;unsafe&lt;/code&gt; 块中。</target>
        </trans-unit>
        <trans-unit id="1b9e5f7972ceab35649387701cac506db165c92f" translate="yes" xml:space="preserve">
          <source>Another way to have a collection of multiple values is with an &lt;em&gt;array&lt;/em&gt;. Unlike a tuple, every element of an array must have the same type. Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.</source>
          <target state="translated">收集多个值的另一种方法是使用&lt;em&gt;数组&lt;/em&gt;。与元组不同，数组的每个元素都必须具有相同的类型。Rust中的数组与某些其他语言中的数组不同，因为Rust中的数组具有固定的长度，例如元组。</target>
        </trans-unit>
        <trans-unit id="6b16dbbf7d35ba29c07c44408e5ca0fc777803bb" translate="yes" xml:space="preserve">
          <source>Another way to provide the compiler with enough information, is to specify the generic type parameter:</source>
          <target state="translated">另一种为编译器提供足够信息的方法是指定通用类型参数。</target>
        </trans-unit>
        <trans-unit id="9b14c4635b7e156ee560ca02ddafb5c338efe01a" translate="yes" xml:space="preserve">
          <source>Another way we could implement &lt;code&gt;largest&lt;/code&gt; is for the function to return a reference to a &lt;code&gt;T&lt;/code&gt; value in the slice. If we change the return type to &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;T&lt;/code&gt;, thereby changing the body of the function to return a reference, we wouldn&amp;rsquo;t need the &lt;code&gt;Clone&lt;/code&gt; or &lt;code&gt;Copy&lt;/code&gt; trait bounds and we could avoid heap allocations. Try implementing these alternate solutions on your own!</source>
          <target state="translated">我们可以实现 &lt;code&gt;largest&lt;/code&gt; 另一种方法是使函数返回对切​​片中 &lt;code&gt;T&lt;/code&gt; 值的引用。如果将返回类型更改为 &lt;code&gt;&amp;amp;T&lt;/code&gt; 而不是 &lt;code&gt;T&lt;/code&gt; ，从而更改函数的主体以返回引用，则不需要 &lt;code&gt;Clone&lt;/code&gt; 或 &lt;code&gt;Copy&lt;/code&gt; 特征范围，并且可以避免堆分配。尝试自己实施这些替代解决方案！</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="28a9dd9802c2f2d457b2df1a706228a0fe1e9650" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">任何 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 是&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;零大小&lt;/a&gt;。可以使用&lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;创建它。当将 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 与&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; 一起使用时&lt;/a&gt;，不需要这样做，因为它们自己实现了适当的&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="39acf470f03d64f751336d22936382dc10cf66e8" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;struct.buildhasherdefault#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">任何 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 是&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;零大小&lt;/a&gt;。可以使用&lt;a href=&quot;struct.buildhasherdefault#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;创建它。当将 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 与&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; 一起使用时&lt;/a&gt;，不需要这样做，因为它们自己实现了适当的&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="61c0cc711bc6806236220ae14adf5485763a3373" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;enum&lt;/code&gt; value consumes as much memory as the largest variant for its corresponding &lt;code&gt;enum&lt;/code&gt; type, as well as the size needed to store a discriminant.</source>
          <target state="translated">任何 &lt;code&gt;enum&lt;/code&gt; 值消耗的内存与其对应的 &lt;code&gt;enum&lt;/code&gt; 类型的最大变体一样，以及存储判别式所需的大小。</target>
        </trans-unit>
        <trans-unit id="6ab54097a9523b84f57f773009ba255a131e3917" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;with_capacity&lt;/code&gt; constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. See collection-specific documentation for details. In general, use &lt;code&gt;with_capacity&lt;/code&gt; when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.</source>
          <target state="translated">任何 &lt;code&gt;with_capacity&lt;/code&gt; 构造函数都将指示集合为指定数量的元素分配足够的空间。理想情况下，这将恰好适用于许多元素，但是某些实现细节可能会阻止这种情况。有关详细信息，请参见特定于集合的文档。通常，当您确切知道要插入多少个元素，或者至少在该数目上具有合理的上限时，请使用 &lt;code&gt;with_capacity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b673eb46a7f5984769da2ecfe123198574739d4" translate="yes" xml:space="preserve">
          <source>Any I/O error not part of this list.</source>
          <target state="translated">任何不在此列表中的I/O错误。</target>
        </trans-unit>
        <trans-unit id="49edcccea744a8f077751ea25c38d4fc4cfa0fe8" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of its variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">任何IP地址都可以是第四版或第六版的地址,但不能同时是两种。IP地址的这一特性使得枚举数据结构变得合适,因为枚举值只能是其变体之一。版本四和版本六的地址从根本上说仍然是IP地址,所以当代码处理适用于任何一种IP地址的情况时,应该把它们当作同一种类型。</target>
        </trans-unit>
        <trans-unit id="6867ac894a456ea99c7c6870f309c422acaaf4df" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of the variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">任何IP地址都可以是第四版或第六版的地址,但不能同时是两种。IP地址的这一特性使得枚举数据结构变得合适,因为枚举值只能是其中的一个变体。版本四和版本六的地址从根本上说仍然是IP地址,所以当代码处理适用于任何一种IP地址的情况时,应该把它们当作同一种类型。</target>
        </trans-unit>
        <trans-unit id="771cc11d8125e00769bce8eb3a9472fcb3c21cb2" translate="yes" xml:space="preserve">
          <source>Any character in the 'printable ASCII' range &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; inclusive is not escaped.</source>
          <target state="translated">&amp;ldquo;可打印ASCII&amp;rdquo;范围 &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; (含）范围内的任何字符都不会转义。</target>
        </trans-unit>
        <trans-unit id="3e6eb82cfd1ccce10703d68820085fb1a0e36401" translate="yes" xml:space="preserve">
          <source>Any characters, except this sequence</source>
          <target state="translated">任何字符,除了这个序列</target>
        </trans-unit>
        <trans-unit id="4cd23fb2001ef303a1bdb9cc4bb51ec0898b0bb8" translate="yes" xml:space="preserve">
          <source>Any characters, except those listed</source>
          <target state="translated">除所列的字符外,任何字符</target>
        </trans-unit>
        <trans-unit id="cf63f064edae30139fdd89fa67002f6be993edd6" translate="yes" xml:space="preserve">
          <source>Any conversions allowed by coercion can also be explicitly performed by the &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;type cast operator&lt;/a&gt;, &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">强制转换所允许的任何转换也可以由&lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;类型转换运算符&lt;/a&gt;显式执行， &lt;code&gt;as&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de99d379f5705cbf09c5d5e30200a62d7427ee91" translate="yes" xml:space="preserve">
          <source>Any excess capacity is removed:</source>
          <target state="translated">任何多余的容量都会被移除。</target>
        </trans-unit>
        <trans-unit id="cfff92a36bb4f2aba0bfefa3df53467014699fa5" translate="yes" xml:space="preserve">
          <source>Any implementation where a type appears &lt;a href=&quot;#uncovered-type&quot;&gt;uncovered&lt;/a&gt;. &lt;code&gt;impl&amp;lt;T&amp;gt; Foo for T&lt;/code&gt;, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for T&lt;/code&gt;, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for T&lt;/code&gt;, and &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; are considered blanket impls. However, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; is not a blanket impl, as all instances of &lt;code&gt;T&lt;/code&gt; which appear in this &lt;code&gt;impl&lt;/code&gt; are covered by &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#uncovered-type&quot;&gt;揭露&lt;/a&gt;类型的任何实现。 &lt;code&gt;impl&amp;lt;T&amp;gt; Foo for T&lt;/code&gt; ， &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for T&lt;/code&gt; ， &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for T&lt;/code&gt; ，并 &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; 被认为是毯暗示。但是， &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; 并不是笼统的impl，因为出现在此 &lt;code&gt;impl&lt;/code&gt; 中的 &lt;code&gt;T&lt;/code&gt; 的所有实例都被 &lt;code&gt;Vec&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="4eba9dcc5c9c9c3a4fc6d9f7d5233af8a7847a24" translate="yes" xml:space="preserve">
          <source>Any kind of aggregate constructor (array, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, tuple, ...)</source>
          <target state="translated">任何类型的聚合构造函数（数组， &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;enum&lt;/code&gt; ，元组，...）</target>
        </trans-unit>
        <trans-unit id="a2d418110b6f755d1311536fe4acdfee5af1facd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error.</source>
          <target state="translated">任何类型的文字(字符串、整数等)加上任何后缀都是有效的标记,并且可以传递给宏而不会产生错误。</target>
        </trans-unit>
        <trans-unit id="6f537d5097da9afc6f346b4806da2a5f2a4e11dd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error. The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">任何后缀的文字(字符串、整数等)都是有效的标记,并且可以传递给宏而不会产生错误,宏本身将决定如何解释这种标记以及是否产生错误。宏本身将决定如何解释这样的标记以及是否产生错误。</target>
        </trans-unit>
        <trans-unit id="4cbac428240bad16fb03767cc5cca3e5e71622e2" translate="yes" xml:space="preserve">
          <source>Any non-Unicode sequences are replaced with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">任何非Unicode序列都将用&lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; 替换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3df46fe98310c858bb458ed2bc6017d791596b12" translate="yes" xml:space="preserve">
          <source>Any of the characters in the range</source>
          <target state="translated">范围内的任何一个字符</target>
        </trans-unit>
        <trans-unit id="df4bb3c1fbc6102d5b31f44ab7298372090f0684" translate="yes" xml:space="preserve">
          <source>Any of the characters listed</source>
          <target state="translated">列举的任何人物</target>
        </trans-unit>
        <trans-unit id="e1fe17e124adf671f41a6bcdb30bc09a9767a019" translate="yes" xml:space="preserve">
          <source>Any of the methods provided by a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; trait implemented by &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a type parameter, methods provided by trait bounds on &lt;code&gt;T&lt;/code&gt; are looked up first. Then all remaining methods in scope are looked up.</source>
          <target state="translated">由 &lt;code&gt;T&lt;/code&gt; 实现的&lt;a href=&quot;../visibility-and-privacy&quot;&gt;可见&lt;/a&gt;性状提供的任何方法。如果 &lt;code&gt;T&lt;/code&gt; 是类型参数，则首先查找 &lt;code&gt;T&lt;/code&gt; 上的特征范围提供的方法。然后查找范围内的所有其余方法。</target>
        </trans-unit>
        <trans-unit id="5c8d97ac8cad3dfb222e1fcec0cd986d681f1547" translate="yes" xml:space="preserve">
          <source>Any other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation must not be dereferenced for the duration of the returned borrow. This is trivially the case if no such pointers exist, for example immediately after &lt;code&gt;Arc::new&lt;/code&gt;.</source>
          <target state="translated">在返回借用期间，不得取消引用相同分配的任何其他 &lt;code&gt;Arc&lt;/code&gt; 或&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。如果不存在这样的指针（例如紧接在 &lt;code&gt;Arc::new&lt;/code&gt; 之后），则情况很简单。</target>
        </trans-unit>
        <trans-unit id="0c05e8f1c6956f4765a713498f6a6547d98317e6" translate="yes" xml:space="preserve">
          <source>Any other &lt;code&gt;Rc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation must not be dereferenced for the duration of the returned borrow. This is trivially the case if no such pointers exist, for example immediately after &lt;code&gt;Rc::new&lt;/code&gt;.</source>
          <target state="translated">在返回借用期间，不得取消引用相同分配的任何其他 &lt;code&gt;Rc&lt;/code&gt; 或&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。如果不存在这样的指针（例如紧接在 &lt;code&gt;Rc::new&lt;/code&gt; 之后），则情况很简单。</target>
        </trans-unit>
        <trans-unit id="e19f15fb75a4bf5f47bda7e931808400dd6bf097" translate="yes" xml:space="preserve">
          <source>Any other changes attempted on a post should have no effect. For example, if we try to approve a draft blog post before we&amp;rsquo;ve requested a review, the post should remain an unpublished draft.</source>
          <target state="translated">尝试在帖子上进行的任何其他更改均无效。例如，如果我们在请求审阅之前尝试批准博客文章草稿，则该文章应仍为未发布的草稿。</target>
        </trans-unit>
        <trans-unit id="d6894150447e47d12e66ba741e1dc8f000de5b10" translate="yes" xml:space="preserve">
          <source>Any other chars are given hex escapes of the form '\xNN'.</source>
          <target state="translated">其他的字符都是以'\xNN'的形式进行十六进制转义。</target>
        </trans-unit>
        <trans-unit id="c7e7ce7ad0344363614031d689f8048423505a67" translate="yes" xml:space="preserve">
          <source>Any resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state. However, it does not guarantee that pointers to this memory will remain valid.</source>
          <target state="translated">值所管理的任何资源,如堆内存或文件句柄,都将永远停留在不可到达的状态。但是,它并不能保证指向这个内存的指针会保持有效。</target>
        </trans-unit>
        <trans-unit id="4582f1278b61140a4c03b6946eaab9c9e43377c3" translate="yes" xml:space="preserve">
          <source>Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">任何后缀都会被拒绝在非数字文字标记上,而数字文字标记只接受以下列表中的后缀。</target>
        </trans-unit>
        <trans-unit id="31bced9874925b40b1709b82b080279f57f95fc4" translate="yes" xml:space="preserve">
          <source>Any time a type &lt;code&gt;T&lt;/code&gt; is considered &lt;a href=&quot;#local-type&quot;&gt;local&lt;/a&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; are also considered local. Fundamental type constructors cannot &lt;a href=&quot;#uncovered-type&quot;&gt;cover&lt;/a&gt; other types. Any time the term &quot;covered type&quot; is used, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered.</source>
          <target state="translated">任何时候将类型 &lt;code&gt;T&lt;/code&gt; 视为&lt;a href=&quot;#local-type&quot;&gt;本地&lt;/a&gt;， &lt;code&gt;&amp;amp;T&lt;/code&gt; ， &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 也视为本地。基本类型构造函数不能&lt;a href=&quot;#uncovered-type&quot;&gt;涵盖&lt;/a&gt;其他类型。&amp;ldquo;覆盖型&amp;rdquo;任何时候，该术语在使用时， &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;&amp;amp;T&lt;/code&gt; ， &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ， &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 不认为覆盖。</target>
        </trans-unit>
        <trans-unit id="972a6afc1089fd19efd410e0369cd9e91a4ef0f3" translate="yes" xml:space="preserve">
          <source>Any time a type or function is provided by the standard library and you&amp;rsquo;re not sure what it does or how to use it, use the application programming interface (API) documentation to find out!</source>
          <target state="translated">每当标准库提供类型或函数时，如果您不确定它的用途或用法，请使用应用程序编程接口（API）文档进行查找！</target>
        </trans-unit>
        <trans-unit id="76deb7250dd43b06f05ef65522ed5c978849b0e5" translate="yes" xml:space="preserve">
          <source>Any type composed entirely of &lt;code&gt;Send&lt;/code&gt; types is automatically marked as &lt;code&gt;Send&lt;/code&gt; as well. Almost all primitive types are &lt;code&gt;Send&lt;/code&gt;, aside from raw pointers, which we&amp;rsquo;ll discuss in Chapter 19.</source>
          <target state="translated">任何完全由&amp;ldquo; &lt;code&gt;Send&lt;/code&gt; 类型组成的类型也将自动标记为&amp;ldquo; &lt;code&gt;Send&lt;/code&gt; &amp;rdquo;。除了原始指针，几乎所有基本类型都是 &lt;code&gt;Send&lt;/code&gt; ，我们将在第19章中讨论原始指针。</target>
        </trans-unit>
        <trans-unit id="af69a2cb47235b6ee090b2e8285120ce18b240b2" translate="yes" xml:space="preserve">
          <source>Any type parameter or lifetime parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 的任何类型参数或生存期参数必须至少满足以下条件之一：</target>
        </trans-unit>
        <trans-unit id="4b06ed0f2a9b9712d1ad4ec6082f1ea5cba3b543" translate="yes" xml:space="preserve">
          <source>Any type parameter parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 的任何类型参数参数必须至少满足以下条件之一：</target>
        </trans-unit>
        <trans-unit id="f149c09f36db068ab34499979d351f1c8d5f7f1e" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;Eq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">派生 &lt;code&gt;Eq&lt;/code&gt; 的任何类型都会自动实现此特征，&lt;em&gt;而&lt;/em&gt;不管其类型参数是否实现 &lt;code&gt;Eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="788cf861093b3924fc04a0b5f4dac3cbdc3bb2d9" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;Eq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type-parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">派生 &lt;code&gt;Eq&lt;/code&gt; 的任何类型都会自动实现此特征，&lt;em&gt;而&lt;/em&gt;不管其类型参数是否实现 &lt;code&gt;Eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfadd00c3ae966bd61c993066771bfd5d6d8d45d" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;PartialEq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type-parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">任何派生 &lt;code&gt;PartialEq&lt;/code&gt; 的类型都会自动实现此特征，&lt;em&gt;而&lt;/em&gt;不管其类型参数是否实现 &lt;code&gt;Eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07027ef0df88ca520ae158040613bfcdb04fbd90" translate="yes" xml:space="preserve">
          <source>Any types with interior mutability must also use the &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;cell::UnsafeCell&lt;/code&gt;&lt;/a&gt; wrapper around the value(s) which can be mutated through a shared reference. Failing to doing this is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. For example, &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt;-ing from &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is invalid.</source>
          <target state="translated">具有内部可变性的任何类型还必须在可以通过共享引用进行突变的值周围使用&lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;cell::UnsafeCell&lt;/code&gt; &lt;/a&gt;包装器。未能做到这一点是&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义的行为&lt;/a&gt;。例如，&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt; -ing从 &lt;code&gt;&amp;amp;T&lt;/code&gt; 到 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 是无效的。</target>
        </trans-unit>
        <trans-unit id="4098bab2016a26a2da921c6a4c090c6509eb5934" translate="yes" xml:space="preserve">
          <source>Any use other than with &lt;code&gt;if&lt;/code&gt; statements will probably not have an effect.</source>
          <target state="translated">除 &lt;code&gt;if&lt;/code&gt; 语句外，其他任何使用都可能无效。</target>
        </trans-unit>
        <trans-unit id="910dd93279c47bcced2d261d2b21071bc5cf465a" translate="yes" xml:space="preserve">
          <source>Any::downcast_mut</source>
          <target state="translated">Any::downcast_mut</target>
        </trans-unit>
        <trans-unit id="3142933cd2ff31b31d3f631fe20ea508e96ad05b" translate="yes" xml:space="preserve">
          <source>Any::downcast_ref</source>
          <target state="translated">Any::downcast_ref</target>
        </trans-unit>
        <trans-unit id="47853f41e226da1c34d9eedcdb8b975ed79ec7bc" translate="yes" xml:space="preserve">
          <source>Any::fmt</source>
          <target state="translated">Any::fmt</target>
        </trans-unit>
        <trans-unit id="63f0fc770b243d87075e5d22567fc12df96b560f" translate="yes" xml:space="preserve">
          <source>Any::is</source>
          <target state="translated">Any::is</target>
        </trans-unit>
        <trans-unit id="153b1345e60af7ce7872d3438b64b0f7f8addb2c" translate="yes" xml:space="preserve">
          <source>Any::type_id</source>
          <target state="translated">Any::type_id</target>
        </trans-unit>
        <trans-unit id="4cde3fadbf976f0b359d3c2a1968c555ccde759f" translate="yes" xml:space="preserve">
          <source>Anyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by the Rust team, which is comprised of many topic subteams. There&amp;rsquo;s a full list of the teams &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;on Rust&amp;rsquo;s website&lt;/a&gt;, which includes teams for each area of the project: language design, compiler implementation, infrastructure, documentation, and more. The appropriate team reads the proposal and the comments, writes some comments of their own, and eventually, there&amp;rsquo;s consensus to accept or reject the feature.</source>
          <target state="translated">任何人都可以编写RFC来改进Rust，并且提案由Rust小组审查和讨论，该小组由许多主题子团队组成。&lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;Rust的网站上&lt;/a&gt;有完整的团队列表，其中包括项目每个领域的团队：语言设计，编译器实现，基础结构，文档等。合适的团队阅读提案和评论，写出一些自己的评论，最终，就接受或拒绝功能达成共识。</target>
        </trans-unit>
        <trans-unit id="53fc70bfdc4b06ea1c2fe17e53fbb9c43726838e" translate="yes" xml:space="preserve">
          <source>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</source>
          <target state="translated">除了具有通用类型参数的方法或函数外,当结构或trait的类型参数无法推断时,也会出现这种错误。在这种情况下,并不总是能够使用类型注解,因为所有的候选者都有相同的返回类型。例如</target>
        </trans-unit>
        <trans-unit id="b813c448dbc23e1f367ecbf1266f8f07cadc0bab" translate="yes" xml:space="preserve">
          <source>Apart from lifetime extension, the temporary scope of an expression is the smallest scope that contains the expression and is for one of the following:</source>
          <target state="translated">除寿命扩展外,表达式的临时作用域是包含表达式的最小作用域,并且是为下列之一。</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="56e2c591df0fef929570597dca64284006730141" translate="yes" xml:space="preserve">
          <source>Appending to a String with &lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; 和 &lt;code&gt;push&lt;/code&gt; 附加到字符串</target>
        </trans-unit>
        <trans-unit id="f3f60044b06335eb6c4230e3c39f5e0218445878" translate="yes" xml:space="preserve">
          <source>Appendix</source>
          <target state="translated">Appendix</target>
        </trans-unit>
        <trans-unit id="4c40c194c9cdc4d680691d4aa8fa1913dc98b2c3" translate="yes" xml:space="preserve">
          <source>Appendix A, &amp;ldquo;Keywords,&amp;rdquo; also explains the new raw identifiers feature that enables code written in the 2015 Edition and the 2018 Edition to interoperate.</source>
          <target state="translated">附录A&amp;ldquo;关键字&amp;rdquo;还介绍了新的原始标识符功能，该功能使在2015版和2018版中编写的代码能够互操作。</target>
        </trans-unit>
        <trans-unit id="8415247b515164394b09f1335fc5dabc83b9e17a" translate="yes" xml:space="preserve">
          <source>Appendix A: Keywords</source>
          <target state="translated">附录A:关键词</target>
        </trans-unit>
        <trans-unit id="540243de89d6ff78feccd1151f1eeb23d45eae75" translate="yes" xml:space="preserve">
          <source>Appendix B: Operators and Symbols</source>
          <target state="translated">附录B:运算符和符号</target>
        </trans-unit>
        <trans-unit id="e440a4e5c41dd9d1d57a9a1afc26c19786ef345a" translate="yes" xml:space="preserve">
          <source>Appendix C: Derivable Traits</source>
          <target state="translated">附录C:可衍生特征</target>
        </trans-unit>
        <trans-unit id="41116b5529dd9b48afe443e282c8edc6aed9a707" translate="yes" xml:space="preserve">
          <source>Appendix D - Useful Development Tools</source>
          <target state="translated">附录D-有用的开发工具</target>
        </trans-unit>
        <trans-unit id="707523bd94a1c061f370a00dc35452edc4f5ca2b" translate="yes" xml:space="preserve">
          <source>Appendix D is now titled &amp;ldquo;Useful Development Tools&amp;rdquo; and covers recently released tools that help you write Rust code.</source>
          <target state="translated">附录D现在标题为&amp;ldquo;有用的开发工具&amp;rdquo;，涵盖了最近发布的可帮助您编写Rust代码的工具。</target>
        </trans-unit>
        <trans-unit id="e50a67316708bcdc8cd3a1c83a15ee617b6e1717" translate="yes" xml:space="preserve">
          <source>Appendix E - Editions</source>
          <target state="translated">附录E-版本</target>
        </trans-unit>
        <trans-unit id="db95e2a46f6e17f889e1ec8cb84b232b2ac6a554" translate="yes" xml:space="preserve">
          <source>Appendix F: Translations of the Book</source>
          <target state="translated">附录F:该书的翻译</target>
        </trans-unit>
        <trans-unit id="cd9cd2e1d4c917e818f77ba2a0d93ffcdf7874d2" translate="yes" xml:space="preserve">
          <source>Appendix G - How Rust is Made and &amp;ldquo;Nightly Rust&amp;rdquo;</source>
          <target state="translated">附录G-如何制造锈蚀和&amp;ldquo;夜锈&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="7ea8d3526ea6b8af40ac97da94b0ad40d6cea127" translate="yes" xml:space="preserve">
          <source>Appendix chapters providing rationale and references to languages that influenced the design.</source>
          <target state="translated">附录章节提供了对设计有影响的语言的基本原理和参考。</target>
        </trans-unit>
        <trans-unit id="0d6a0bfa8816321ae3291d75b6bf84f8077fe48b" translate="yes" xml:space="preserve">
          <source>Appendix: Macro Follow-Set Ambiguity Formal Specification</source>
          <target state="translated">附录。宏观跟单含混形式规范。</target>
        </trans-unit>
        <trans-unit id="54e814d184dccc0b7473b24d35812b283adff9c0" translate="yes" xml:space="preserve">
          <source>Appends a given string slice onto the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">将给定的字符串切片附加到此 &lt;code&gt;String&lt;/code&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="bd5ef47a12f2696c33dc462f202e22f6e229647a" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a collection.</source>
          <target state="translated">将一个元素添加到一个集合的后面。</target>
        </trans-unit>
        <trans-unit id="ddf4cf8edbc5fa033e85502f0a84bfe8b2914aec" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a list.</source>
          <target state="translated">将一个元素添加到列表的后面。</target>
        </trans-unit>
        <trans-unit id="9427717eceb820f7ae4720310e1343f09df153f2" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of the &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">将元素追加到 &lt;code&gt;VecDeque&lt;/code&gt; 的背面。</target>
        </trans-unit>
        <trans-unit id="373311f9bb46882cd119d03cfc2b6fa19fdf5ba3" translate="yes" xml:space="preserve">
          <source>Appends the given &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">将给定的&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;追加到此 &lt;code&gt;String&lt;/code&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="f88d43733a3d3b030bf7286e9ed4c303cc3a7d2b" translate="yes" xml:space="preserve">
          <source>Application Binary Interface (ABI)</source>
          <target state="translated">应用二进制接口(ABI)</target>
        </trans-unit>
        <trans-unit id="9a4440ced79c9610e5a61ec32030ae30f58d9a8c" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;), or returns the provided default (if &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">将函数应用于所包含的值（如果&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;），或者返回提供的默认值（如果&lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bed8e79e380caf3902110314a704f53a22b3ecbe" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or computes a default (if not).</source>
          <target state="translated">对包含的值应用一个函数(如果有),或者计算一个默认值(如果没有)。</target>
        </trans-unit>
        <trans-unit id="ef8795473614177b83e201e3db900beeef41c1e2" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or returns the provided default (if not).</source>
          <target state="translated">对包含的值应用一个函数(如果有),或者返回提供的默认值(如果没有)。</target>
        </trans-unit>
        <trans-unit id="a6be2123eb22e6f1506885d0c1439a3655475eac" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result.</source>
          <target state="translated">将函数应用于迭代器的元素,并返回第一个非空结果。</target>
        </trans-unit>
        <trans-unit id="2f579750efee0b6f5e959f71ab15df216a9fb1b9" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个非无结果。&lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7da1899028718ec8a07b6c08455d63f4e3489b90" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个非无结果。&lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f3002a1274a5209b380bd8bf18387ed22cf040f" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个非无结果。&lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67cbbc3631a3803076e70ec9a10a8358879f6e02" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个非无结果。&lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8819d96feaef2f02cd8965c68d9eb2580ebfc977" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个非无结果。&lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c71f5fd4b8bc9dae7fc6bb52c696f533ce8ed924" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error.</source>
          <target state="translated">将函数应用于迭代器的元素,并返回第一个真结果或第一个错误。</target>
        </trans-unit>
        <trans-unit id="fd078bc0e6ebca661ba36b845bc2f34f79671219" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../../../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个真结果或第一个错误。&lt;a href=&quot;../../../iter/trait.iterator#method.try_find&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13f3965e6fc53b243d5a7c2dc2282a44cca3805a" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个真结果或第一个错误。&lt;a href=&quot;../../iter/trait.iterator#method.try_find&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb07d601f2efbf0db36543c96f74916e4858345" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个真结果或第一个错误。&lt;a href=&quot;../iter/trait.iterator#method.try_find&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfe6a04d1d11293ba9f6db79767b686fae8501d1" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个真结果或第一个错误。&lt;a href=&quot;iter/trait.iterator#method.try_find&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="813b671e50d44d7d39a003bdb093dc2cdbf235f8" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将函数应用于迭代器的元素，并返回第一个真结果或第一个错误。&lt;a href=&quot;trait.iterator#method.try_find&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ff8e99aa0f8295d1776562bee993cb0a364606b" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function.</source>
          <target state="translated">应用&amp;ldquo;？&amp;rdquo; 操作员。 &lt;code&gt;Ok(t)&lt;/code&gt; 的返回意味着执行应正常继续，结果为 &lt;code&gt;?&lt;/code&gt; 是值 &lt;code&gt;t&lt;/code&gt; 。返回 &lt;code&gt;Err(e)&lt;/code&gt; 意味着执行应分支到最内层的 &lt;code&gt;catch&lt;/code&gt; 或从函数返回。</target>
        </trans-unit>
        <trans-unit id="d771dbfeb7c050dea75fe4d6749833e3ae20e4ae" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">应用&amp;ldquo;？&amp;rdquo; 操作员。 &lt;code&gt;Ok(t)&lt;/code&gt; 的返回意味着执行应正常继续，结果为 &lt;code&gt;?&lt;/code&gt; 是值 &lt;code&gt;t&lt;/code&gt; 。返回 &lt;code&gt;Err(e)&lt;/code&gt; 意味着执行应分支到最内层的 &lt;code&gt;catch&lt;/code&gt; 或从函数返回。&lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84c127ccde0ff66daa4ff755926ef467d8ab1d62" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">应用&amp;ldquo;？&amp;rdquo; 操作员。 &lt;code&gt;Ok(t)&lt;/code&gt; 的返回意味着执行应正常继续，而结果为 &lt;code&gt;?&lt;/code&gt; 是值 &lt;code&gt;t&lt;/code&gt; 。返回 &lt;code&gt;Err(e)&lt;/code&gt; 意味着执行应分支到最内层的 &lt;code&gt;catch&lt;/code&gt; 或从函数返回。&lt;a href=&quot;trait.try#tymethod.into_result&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6233fb9390747dc2f23a28899738d6cc6a72590f" translate="yes" xml:space="preserve">
          <source>Applying the attribute to a function &lt;code&gt;f&lt;/code&gt; allows code within &lt;code&gt;f&lt;/code&gt; to get a hint of the &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; of the &quot;topmost&quot; tracked call that led to &lt;code&gt;f&lt;/code&gt;'s invocation. At the point of observation, an implementation behaves as if it walks up the stack from &lt;code&gt;f&lt;/code&gt;'s frame to find the nearest frame of an &lt;em&gt;unattributed&lt;/em&gt; function &lt;code&gt;outer&lt;/code&gt;, and it returns the &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; of the tracked call in &lt;code&gt;outer&lt;/code&gt;.</source>
          <target state="translated">应用该属性的功能 &lt;code&gt;f&lt;/code&gt; 允许范围内码 &lt;code&gt;f&lt;/code&gt; 得到一丝&lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;的&amp;ldquo;层次最高的&amp;rdquo;跟踪调用导致 &lt;code&gt;f&lt;/code&gt; 的调用。在观测点，实现行为就好像它走过从堆栈 &lt;code&gt;f&lt;/code&gt; 的帧找到一个最近的框架&lt;em&gt;未归属的&lt;/em&gt;功能 &lt;code&gt;outer&lt;/code&gt; ，它返回&lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;在跟踪通话 &lt;code&gt;outer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8404e9317204d7715d2f49a56717841155af3a5d" translate="yes" xml:space="preserve">
          <source>Approximate desugaring</source>
          <target state="translated">大约的脱糖量</target>
        </trans-unit>
        <trans-unit id="7e15c6fd69af4acca9c9f459c798f3ae0c37890f" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10.</source>
          <target state="translated">以10为基数的有意义的数字的近似数。</target>
        </trans-unit>
        <trans-unit id="741aa1a23115e831e460da0298845488131bda9a" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10. Use &lt;a href=&quot;../primitive.f32#associatedconstant.DIGITS&quot;&gt;&lt;code&gt;f32::DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">以10为基数的有效位数的大概数字。改用&lt;a href=&quot;../primitive.f32#associatedconstant.DIGITS&quot;&gt; &lt;code&gt;f32::DIGITS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8912ed7e59aeef6ce8c4355dd3b80515ddbd4f1" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10. Use &lt;a href=&quot;../primitive.f64#associatedconstant.DIGITS&quot;&gt;&lt;code&gt;f64::DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">以10为基数的有效位数的大概数字。改用&lt;a href=&quot;../primitive.f64#associatedconstant.DIGITS&quot;&gt; &lt;code&gt;f64::DIGITS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="59cfa485c658b8f9969a88c2eb92540fdf722cfd" translate="yes" xml:space="preserve">
          <source>Arc::as_ref</source>
          <target state="translated">Arc::as_ref</target>
        </trans-unit>
        <trans-unit id="2f1c5ec3613e810179b1dde9e1ff629a07f45de3" translate="yes" xml:space="preserve">
          <source>Arc::borrow</source>
          <target state="translated">Arc::borrow</target>
        </trans-unit>
        <trans-unit id="e6381920a9fbe9f6076603c436d6eef9b74e1f24" translate="yes" xml:space="preserve">
          <source>Arc::borrow_mut</source>
          <target state="translated">Arc::borrow_mut</target>
        </trans-unit>
        <trans-unit id="de0c16869f1a3fad5d726dc3e3fba2293f156861" translate="yes" xml:space="preserve">
          <source>Arc::clamp</source>
          <target state="translated">Arc::clamp</target>
        </trans-unit>
        <trans-unit id="9fa492e8fa6e20e1b52a4de7403dbe55ec1b79bf" translate="yes" xml:space="preserve">
          <source>Arc::clone</source>
          <target state="translated">Arc::clone</target>
        </trans-unit>
        <trans-unit id="39cf0d205cd739521ce28938f9a2250155c1bac4" translate="yes" xml:space="preserve">
          <source>Arc::clone_from</source>
          <target state="translated">Arc::clone_from</target>
        </trans-unit>
        <trans-unit id="773d06cfd159d4606ff3014fee5f9931067cf220" translate="yes" xml:space="preserve">
          <source>Arc::clone_into</source>
          <target state="translated">Arc::clone_into</target>
        </trans-unit>
        <trans-unit id="7561059135cbd0c5fbb5238091fd429a9e1b09c1" translate="yes" xml:space="preserve">
          <source>Arc::cmp</source>
          <target state="translated">Arc::cmp</target>
        </trans-unit>
        <trans-unit id="b73ea8e602ed4ab4007a418f3f6cee6a05a73996" translate="yes" xml:space="preserve">
          <source>Arc::default</source>
          <target state="translated">Arc::default</target>
        </trans-unit>
        <trans-unit id="cdd18aaa5e1ccdcb1656e6b3c539ea6dd22d2613" translate="yes" xml:space="preserve">
          <source>Arc::deref</source>
          <target state="translated">Arc::deref</target>
        </trans-unit>
        <trans-unit id="3d5ef1d21d6636272bbb1c82a7af354e776cadde" translate="yes" xml:space="preserve">
          <source>Arc::downcast</source>
          <target state="translated">Arc::downcast</target>
        </trans-unit>
        <trans-unit id="8f4a9849100a7720ad47a02d98c3cc428143986f" translate="yes" xml:space="preserve">
          <source>Arc::downgrade</source>
          <target state="translated">Arc::downgrade</target>
        </trans-unit>
        <trans-unit id="4d05d06001426353e874710f4e01911168266628" translate="yes" xml:space="preserve">
          <source>Arc::drop</source>
          <target state="translated">Arc::drop</target>
        </trans-unit>
        <trans-unit id="d616628ce7e2e600feb8196c85f5e01fa37ae824" translate="yes" xml:space="preserve">
          <source>Arc::eq</source>
          <target state="translated">Arc::eq</target>
        </trans-unit>
        <trans-unit id="541daae394114016fc018c7425373988b033cde5" translate="yes" xml:space="preserve">
          <source>Arc::fmt</source>
          <target state="translated">Arc::fmt</target>
        </trans-unit>
        <trans-unit id="c5939b1aa685e46bfb67eeb83668be8ab9a5dab1" translate="yes" xml:space="preserve">
          <source>Arc::from</source>
          <target state="translated">Arc::from</target>
        </trans-unit>
        <trans-unit id="dea799f19377ba936fa669465a1dea313ae3aa7a" translate="yes" xml:space="preserve">
          <source>Arc::from_raw</source>
          <target state="translated">Arc::from_raw</target>
        </trans-unit>
        <trans-unit id="6910e0ecb20317c068e1ba9e8ebf007d417f95a2" translate="yes" xml:space="preserve">
          <source>Arc::ge</source>
          <target state="translated">Arc::ge</target>
        </trans-unit>
        <trans-unit id="7e24d2d9f75e2ea02439ac0bd0d3b07ceaa736e4" translate="yes" xml:space="preserve">
          <source>Arc::get_mut</source>
          <target state="translated">Arc::get_mut</target>
        </trans-unit>
        <trans-unit id="e94b486a276abc7bcb5888a4d6fc97a6fa8eebaa" translate="yes" xml:space="preserve">
          <source>Arc::gt</source>
          <target state="translated">Arc::gt</target>
        </trans-unit>
        <trans-unit id="f233cce03a62c687a1d4be5e670e3be37d179359" translate="yes" xml:space="preserve">
          <source>Arc::hash</source>
          <target state="translated">Arc::hash</target>
        </trans-unit>
        <trans-unit id="963937d635066d272a6f67596279f6b16956abdb" translate="yes" xml:space="preserve">
          <source>Arc::hash_slice</source>
          <target state="translated">Arc::hash_slice</target>
        </trans-unit>
        <trans-unit id="2b8954f29938fa3429d664d59b2922996301d34a" translate="yes" xml:space="preserve">
          <source>Arc::into</source>
          <target state="translated">Arc::into</target>
        </trans-unit>
        <trans-unit id="24e83cc9b0b264818fc7b3695d912fc8e4d9e845" translate="yes" xml:space="preserve">
          <source>Arc::into_raw</source>
          <target state="translated">Arc::into_raw</target>
        </trans-unit>
        <trans-unit id="921d5aa53e181c2612da9bf23381db35c63bd321" translate="yes" xml:space="preserve">
          <source>Arc::into_raw_non_null</source>
          <target state="translated">Arc::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="f3473006930ab6b55f7aef32c93c0af0f87e7790" translate="yes" xml:space="preserve">
          <source>Arc::le</source>
          <target state="translated">Arc::le</target>
        </trans-unit>
        <trans-unit id="34b95793d03cc8c6cef222cea98c6e99dc74e9e2" translate="yes" xml:space="preserve">
          <source>Arc::lt</source>
          <target state="translated">Arc::lt</target>
        </trans-unit>
        <trans-unit id="eab1ca96353cac811bc765a502fbbe1723278950" translate="yes" xml:space="preserve">
          <source>Arc::make_mut</source>
          <target state="translated">Arc::make_mut</target>
        </trans-unit>
        <trans-unit id="0a9a2e87881627fae4b58af4ea1e4cdaa0c36395" translate="yes" xml:space="preserve">
          <source>Arc::max</source>
          <target state="translated">Arc::max</target>
        </trans-unit>
        <trans-unit id="431ba8a8a73b16f867d8367c027605d9a9f25a4e" translate="yes" xml:space="preserve">
          <source>Arc::min</source>
          <target state="translated">Arc::min</target>
        </trans-unit>
        <trans-unit id="a700586ffae96fc24dca7f29fd88b64a47bae03d" translate="yes" xml:space="preserve">
          <source>Arc::ne</source>
          <target state="translated">Arc::ne</target>
        </trans-unit>
        <trans-unit id="1311cfe952a5208cf9ab108dab2eb693395bbca1" translate="yes" xml:space="preserve">
          <source>Arc::new</source>
          <target state="translated">Arc::new</target>
        </trans-unit>
        <trans-unit id="2c2d4efc7b27aae2edec462666037bcaf500cae7" translate="yes" xml:space="preserve">
          <source>Arc::partial_cmp</source>
          <target state="translated">Arc::partial_cmp</target>
        </trans-unit>
        <trans-unit id="41a523a445899356c297537c4b72fff018176305" translate="yes" xml:space="preserve">
          <source>Arc::pin</source>
          <target state="translated">Arc::pin</target>
        </trans-unit>
        <trans-unit id="1d09dbe8f647daf2ca429c9d36141d61d7d2799f" translate="yes" xml:space="preserve">
          <source>Arc::ptr_eq</source>
          <target state="translated">Arc::ptr_eq</target>
        </trans-unit>
        <trans-unit id="ec8427607c6875d57c1cbb7ae116c8a1b2bc9f8b" translate="yes" xml:space="preserve">
          <source>Arc::strong_count</source>
          <target state="translated">Arc::strong_count</target>
        </trans-unit>
        <trans-unit id="12f7dc5817d10cbbabc6ff3c697a1ca67ff339d5" translate="yes" xml:space="preserve">
          <source>Arc::to_owned</source>
          <target state="translated">Arc::to_owned</target>
        </trans-unit>
        <trans-unit id="dd1da4e8925e8953dfb4aef0354dd388c867af08" translate="yes" xml:space="preserve">
          <source>Arc::to_string</source>
          <target state="translated">Arc::to_string</target>
        </trans-unit>
        <trans-unit id="b36b4607ae74c4708612a87739b787ab550df768" translate="yes" xml:space="preserve">
          <source>Arc::try_from</source>
          <target state="translated">Arc::try_from</target>
        </trans-unit>
        <trans-unit id="450b59e4892b86614294b44b39674630d4067a1f" translate="yes" xml:space="preserve">
          <source>Arc::try_into</source>
          <target state="translated">Arc::try_into</target>
        </trans-unit>
        <trans-unit id="8cc0a8e7a4fa3ddf0be44f0e2f8210b7538bff4d" translate="yes" xml:space="preserve">
          <source>Arc::try_unwrap</source>
          <target state="translated">Arc::try_unwrap</target>
        </trans-unit>
        <trans-unit id="e60b417105d1b796fbb9108c579b5a5a3f60ab78" translate="yes" xml:space="preserve">
          <source>Arc::type_id</source>
          <target state="translated">Arc::type_id</target>
        </trans-unit>
        <trans-unit id="6623270e41b383306513b26dd0972d02a62dabdc" translate="yes" xml:space="preserve">
          <source>Arc::weak_count</source>
          <target state="translated">Arc::weak_count</target>
        </trans-unit>
        <trans-unit id="bcef6163f2366764b97712c1e02d4e8de8728060" translate="yes" xml:space="preserve">
          <source>Archimedes' constant (&amp;pi;)</source>
          <target state="translated">阿基米德常数（&amp;pi;）</target>
        </trans-unit>
        <trans-unit id="02d36a6ada7ba4a678771b24dc19a1d26e06d584" translate="yes" xml:space="preserve">
          <source>Are allowed to be null</source>
          <target state="translated">允许为空</target>
        </trans-unit>
        <trans-unit id="7bcd778277bf4c00f69bda3256c3718425635b4a" translate="yes" xml:space="preserve">
          <source>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</source>
          <target state="translated">是否允许通过同时拥有不可变和可变指针或多个可变指针到同一位置来忽略借用规则。</target>
        </trans-unit>
        <trans-unit id="79232b3ded8b7d0b1c86ea5d989ec5b302602c26" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t guaranteed to point to valid memory</source>
          <target state="translated">不保证指向有效内存</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="11997e344b54f51ca26eed6c34abb35c17719846" translate="yes" xml:space="preserve">
          <source>Args::all</source>
          <target state="translated">Args::all</target>
        </trans-unit>
        <trans-unit id="834e48f2681bde9c6de2a1d6fe4ea459480940da" translate="yes" xml:space="preserve">
          <source>Args::any</source>
          <target state="translated">Args::any</target>
        </trans-unit>
        <trans-unit id="852de3f0c6270398ac654986a4377df5f50c393c" translate="yes" xml:space="preserve">
          <source>Args::borrow</source>
          <target state="translated">Args::borrow</target>
        </trans-unit>
        <trans-unit id="8aa2c84655d80e6196471b5bce3e6eb8f9d79f61" translate="yes" xml:space="preserve">
          <source>Args::borrow_mut</source>
          <target state="translated">Args::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6235293cd6910b3c74977e8687ec90afadb03077" translate="yes" xml:space="preserve">
          <source>Args::by_ref</source>
          <target state="translated">Args::by_ref</target>
        </trans-unit>
        <trans-unit id="4438640d50dfd08974f7aac6bf0d2aecb461c3f5" translate="yes" xml:space="preserve">
          <source>Args::chain</source>
          <target state="translated">Args::chain</target>
        </trans-unit>
        <trans-unit id="fd443c43e63db2a659b5f263c42823b6b670bd44" translate="yes" xml:space="preserve">
          <source>Args::cloned</source>
          <target state="translated">Args::cloned</target>
        </trans-unit>
        <trans-unit id="46277936c8445a042e94cc3a26942468f91253e9" translate="yes" xml:space="preserve">
          <source>Args::cmp</source>
          <target state="translated">Args::cmp</target>
        </trans-unit>
        <trans-unit id="48dd95fc8d6a07728f5a1cf7809d55524bf20034" translate="yes" xml:space="preserve">
          <source>Args::collect</source>
          <target state="translated">Args::collect</target>
        </trans-unit>
        <trans-unit id="9d0c9a3a72db97b3f6cab2b952f231796f20a50c" translate="yes" xml:space="preserve">
          <source>Args::copied</source>
          <target state="translated">Args::copied</target>
        </trans-unit>
        <trans-unit id="4fbeb4376f2e8b5f2155e6dbdec8f0740c8c04c9" translate="yes" xml:space="preserve">
          <source>Args::count</source>
          <target state="translated">Args::count</target>
        </trans-unit>
        <trans-unit id="4a06de4989ebe4016d146a0bb3c59a627e816965" translate="yes" xml:space="preserve">
          <source>Args::cycle</source>
          <target state="translated">Args::cycle</target>
        </trans-unit>
        <trans-unit id="dbd2a1eb1e566bd90b7919caa38a19ccb4685bdf" translate="yes" xml:space="preserve">
          <source>Args::enumerate</source>
          <target state="translated">Args::enumerate</target>
        </trans-unit>
        <trans-unit id="d22f2ebcc4f66631a8b99dffd5e42317b95a23c3" translate="yes" xml:space="preserve">
          <source>Args::eq</source>
          <target state="translated">Args::eq</target>
        </trans-unit>
        <trans-unit id="825fef0560348f1a6b9c4b27b6c58018c4f453ef" translate="yes" xml:space="preserve">
          <source>Args::filter</source>
          <target state="translated">Args::filter</target>
        </trans-unit>
        <trans-unit id="ab08ac4972fbd0c43add6cedcff53d5b9d40bc35" translate="yes" xml:space="preserve">
          <source>Args::filter_map</source>
          <target state="translated">Args::filter_map</target>
        </trans-unit>
        <trans-unit id="86056472eedb8eee7dbef63077919c7204cfa67b" translate="yes" xml:space="preserve">
          <source>Args::find</source>
          <target state="translated">Args::find</target>
        </trans-unit>
        <trans-unit id="e877bf0f63fb53fe48a38a7b49bdba91724d4dc9" translate="yes" xml:space="preserve">
          <source>Args::find_map</source>
          <target state="translated">Args::find_map</target>
        </trans-unit>
        <trans-unit id="09774b60a814c8b4104b1538a3d2232fe023f569" translate="yes" xml:space="preserve">
          <source>Args::flat_map</source>
          <target state="translated">Args::flat_map</target>
        </trans-unit>
        <trans-unit id="5eeb63d240af1b2ec0ce621fdcebe38dd652ee35" translate="yes" xml:space="preserve">
          <source>Args::flatten</source>
          <target state="translated">Args::flatten</target>
        </trans-unit>
        <trans-unit id="2824f41303961ce133138bbb9cdb7c73c49c034e" translate="yes" xml:space="preserve">
          <source>Args::fmt</source>
          <target state="translated">Args::fmt</target>
        </trans-unit>
        <trans-unit id="bdc321df53c7563363bb091073cc745371fec866" translate="yes" xml:space="preserve">
          <source>Args::fold</source>
          <target state="translated">Args::fold</target>
        </trans-unit>
        <trans-unit id="0bfb713bd78f482e7b1b8ccad2fb85c3059b45d0" translate="yes" xml:space="preserve">
          <source>Args::for_each</source>
          <target state="translated">Args::for_each</target>
        </trans-unit>
        <trans-unit id="bf62c774de1d7877320ea0fd8f640a1da6f668ae" translate="yes" xml:space="preserve">
          <source>Args::from</source>
          <target state="translated">Args::from</target>
        </trans-unit>
        <trans-unit id="4b2d02be4c99f1b285f809b3bada4d6e1d5de2c4" translate="yes" xml:space="preserve">
          <source>Args::fuse</source>
          <target state="translated">Args::fuse</target>
        </trans-unit>
        <trans-unit id="e9d47e65f07958eb4c539e9aa4794d4c91301d74" translate="yes" xml:space="preserve">
          <source>Args::ge</source>
          <target state="translated">Args::ge</target>
        </trans-unit>
        <trans-unit id="41716a498dc92ecead97571d6a7701faab3446af" translate="yes" xml:space="preserve">
          <source>Args::gt</source>
          <target state="translated">Args::gt</target>
        </trans-unit>
        <trans-unit id="ffe407b598fd64603f4cdfacf4c22332227c8373" translate="yes" xml:space="preserve">
          <source>Args::inspect</source>
          <target state="translated">Args::inspect</target>
        </trans-unit>
        <trans-unit id="4982b89e7bce55b901b94270e4e00a5ac09ba3e0" translate="yes" xml:space="preserve">
          <source>Args::into</source>
          <target state="translated">Args::into</target>
        </trans-unit>
        <trans-unit id="2fc7d02ccfe30c7d6decfb090f0a5dcabb2e0c43" translate="yes" xml:space="preserve">
          <source>Args::into_iter</source>
          <target state="translated">Args::into_iter</target>
        </trans-unit>
        <trans-unit id="0cc324954d5e5cfc9f0640a45fd39c06463171c8" translate="yes" xml:space="preserve">
          <source>Args::is_empty</source>
          <target state="translated">Args::is_empty</target>
        </trans-unit>
        <trans-unit id="9320ccfba6fb85da2cd8f4ea07146d9e90d55e69" translate="yes" xml:space="preserve">
          <source>Args::is_sorted</source>
          <target state="translated">Args::is_sorted</target>
        </trans-unit>
        <trans-unit id="18a7ac322b2479e407afbb8da7a0d6e559099523" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by</source>
          <target state="translated">Args::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d806d23a84355aca10dbfd0171313e44075d284" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by_key</source>
          <target state="translated">Args::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="c6efefb9b080afb608e934c39e299c62aaaa6fc0" translate="yes" xml:space="preserve">
          <source>Args::last</source>
          <target state="translated">Args::last</target>
        </trans-unit>
        <trans-unit id="04a547ce59955db8d408e3c98a9edc55fc1c82e5" translate="yes" xml:space="preserve">
          <source>Args::le</source>
          <target state="translated">Args::le</target>
        </trans-unit>
        <trans-unit id="f88c3621988f7c3fdb34fd16f1e9ea82cfbcea71" translate="yes" xml:space="preserve">
          <source>Args::len</source>
          <target state="translated">Args::len</target>
        </trans-unit>
        <trans-unit id="01c7bcbbd63e3d113fbbd64d77442cb638b835d1" translate="yes" xml:space="preserve">
          <source>Args::lt</source>
          <target state="translated">Args::lt</target>
        </trans-unit>
        <trans-unit id="039581be23b84f6e55f8a2add1bc6bfa811639f2" translate="yes" xml:space="preserve">
          <source>Args::map</source>
          <target state="translated">Args::map</target>
        </trans-unit>
        <trans-unit id="994f671b6e95e4ae34dd6e2c082281ea8ea61313" translate="yes" xml:space="preserve">
          <source>Args::max</source>
          <target state="translated">Args::max</target>
        </trans-unit>
        <trans-unit id="74a4e2d3f00af26f6a0ad2245e073d3b5a0cd3d2" translate="yes" xml:space="preserve">
          <source>Args::max_by</source>
          <target state="translated">Args::max_by</target>
        </trans-unit>
        <trans-unit id="deb310f6f85b56ebc7fe38e266f44493563fc6cf" translate="yes" xml:space="preserve">
          <source>Args::max_by_key</source>
          <target state="translated">Args::max_by_key</target>
        </trans-unit>
        <trans-unit id="dde4047d67a5b16733c51e9703c57fbdf575a4e4" translate="yes" xml:space="preserve">
          <source>Args::min</source>
          <target state="translated">Args::min</target>
        </trans-unit>
        <trans-unit id="403ed2480b700e9a65c715919e29b948e24f4b97" translate="yes" xml:space="preserve">
          <source>Args::min_by</source>
          <target state="translated">Args::min_by</target>
        </trans-unit>
        <trans-unit id="61041884b34bb5182aa5504e5448d5bac7a830ec" translate="yes" xml:space="preserve">
          <source>Args::min_by_key</source>
          <target state="translated">Args::min_by_key</target>
        </trans-unit>
        <trans-unit id="254900be5bd6dab1a3e1e8f2d8135ce517862048" translate="yes" xml:space="preserve">
          <source>Args::ne</source>
          <target state="translated">Args::ne</target>
        </trans-unit>
        <trans-unit id="d7cb929a8cedef153a932b274a4aba45b153fd66" translate="yes" xml:space="preserve">
          <source>Args::next</source>
          <target state="translated">Args::next</target>
        </trans-unit>
        <trans-unit id="2dcb9f5424d93dea8b755e44bed8488448308f48" translate="yes" xml:space="preserve">
          <source>Args::next_back</source>
          <target state="translated">Args::next_back</target>
        </trans-unit>
        <trans-unit id="7117eeb7949ae721ac3782d5eedc483a09ccac61" translate="yes" xml:space="preserve">
          <source>Args::nth</source>
          <target state="translated">Args::nth</target>
        </trans-unit>
        <trans-unit id="920bfede689288166976e1de3db01783fca343a2" translate="yes" xml:space="preserve">
          <source>Args::nth_back</source>
          <target state="translated">Args::nth_back</target>
        </trans-unit>
        <trans-unit id="827560f3761313e8fff14e1e90ac372f2bcfaccc" translate="yes" xml:space="preserve">
          <source>Args::partial_cmp</source>
          <target state="translated">Args::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fd69506fed5f2e3f675c8f01ed77c7a8573ed9f" translate="yes" xml:space="preserve">
          <source>Args::partition</source>
          <target state="translated">Args::partition</target>
        </trans-unit>
        <trans-unit id="0f80b2cd77c5343960cc6f37513564b206a6f770" translate="yes" xml:space="preserve">
          <source>Args::peekable</source>
          <target state="translated">Args::peekable</target>
        </trans-unit>
        <trans-unit id="d35d46b1d259e3d81a7c87e03f05934ae588d4a7" translate="yes" xml:space="preserve">
          <source>Args::position</source>
          <target state="translated">Args::position</target>
        </trans-unit>
        <trans-unit id="4ed9e8e605899d2c4c96340af8f07ac7b263210f" translate="yes" xml:space="preserve">
          <source>Args::product</source>
          <target state="translated">Args::product</target>
        </trans-unit>
        <trans-unit id="eb295f32cccde70f35d8df7df01c50708f27bd93" translate="yes" xml:space="preserve">
          <source>Args::rev</source>
          <target state="translated">Args::rev</target>
        </trans-unit>
        <trans-unit id="98d2de96a420de7658219d3f9bda5b24ca2443f7" translate="yes" xml:space="preserve">
          <source>Args::rfind</source>
          <target state="translated">Args::rfind</target>
        </trans-unit>
        <trans-unit id="3cc34e3e8eb1da327b82585d5a13fd8b2bb5890e" translate="yes" xml:space="preserve">
          <source>Args::rfold</source>
          <target state="translated">Args::rfold</target>
        </trans-unit>
        <trans-unit id="3a7a7236e75fdfae5572db48f2aad6e6378da2eb" translate="yes" xml:space="preserve">
          <source>Args::rposition</source>
          <target state="translated">Args::rposition</target>
        </trans-unit>
        <trans-unit id="9fc0f79d5cd6405747d8f5be32af5064749f81b9" translate="yes" xml:space="preserve">
          <source>Args::scan</source>
          <target state="translated">Args::scan</target>
        </trans-unit>
        <trans-unit id="12148001c865165a5de07ba3c727c97aab92c761" translate="yes" xml:space="preserve">
          <source>Args::size_hint</source>
          <target state="translated">Args::size_hint</target>
        </trans-unit>
        <trans-unit id="1189df09a529d4be32c97dfca9793d84611fd824" translate="yes" xml:space="preserve">
          <source>Args::skip</source>
          <target state="translated">Args::skip</target>
        </trans-unit>
        <trans-unit id="764acccc052619da2c47813fd259dab289d9bd67" translate="yes" xml:space="preserve">
          <source>Args::skip_while</source>
          <target state="translated">Args::skip_while</target>
        </trans-unit>
        <trans-unit id="904035ea6ead93ad6bd21ffe6010b797797cfccb" translate="yes" xml:space="preserve">
          <source>Args::step_by</source>
          <target state="translated">Args::step_by</target>
        </trans-unit>
        <trans-unit id="d5a7f219c1fc0a0f719ef62e5e91b056ae17a132" translate="yes" xml:space="preserve">
          <source>Args::sum</source>
          <target state="translated">Args::sum</target>
        </trans-unit>
        <trans-unit id="27af1223e3252d8316e5510ef65c11dd18e7e048" translate="yes" xml:space="preserve">
          <source>Args::take</source>
          <target state="translated">Args::take</target>
        </trans-unit>
        <trans-unit id="70510b85e050ccfd0ca156b8552398d830c8ca29" translate="yes" xml:space="preserve">
          <source>Args::take_while</source>
          <target state="translated">Args::take_while</target>
        </trans-unit>
        <trans-unit id="29671ebf88bfe467b330af20810dd95f14bee716" translate="yes" xml:space="preserve">
          <source>Args::try_fold</source>
          <target state="translated">Args::try_fold</target>
        </trans-unit>
        <trans-unit id="11314668861a5fe3812661a0778a42dd4d60ecc6" translate="yes" xml:space="preserve">
          <source>Args::try_for_each</source>
          <target state="translated">Args::try_for_each</target>
        </trans-unit>
        <trans-unit id="a3e7a43251306d98977b3648cb61a36b6b67f71f" translate="yes" xml:space="preserve">
          <source>Args::try_from</source>
          <target state="translated">Args::try_from</target>
        </trans-unit>
        <trans-unit id="ea7b4151424c750739941030cbfa813500f83861" translate="yes" xml:space="preserve">
          <source>Args::try_into</source>
          <target state="translated">Args::try_into</target>
        </trans-unit>
        <trans-unit id="a09bc59807578d3bfcb3f5e6f7f7b11ca71a5fda" translate="yes" xml:space="preserve">
          <source>Args::try_rfold</source>
          <target state="translated">Args::try_rfold</target>
        </trans-unit>
        <trans-unit id="ef5ea75da51804787206df18b378f5490fe6418b" translate="yes" xml:space="preserve">
          <source>Args::type_id</source>
          <target state="translated">Args::type_id</target>
        </trans-unit>
        <trans-unit id="3e828aa1b5449d683bef869c26ce0986ec45e670" translate="yes" xml:space="preserve">
          <source>Args::unzip</source>
          <target state="translated">Args::unzip</target>
        </trans-unit>
        <trans-unit id="468f2b4280fd073d79df60860923a06807813556" translate="yes" xml:space="preserve">
          <source>Args::zip</source>
          <target state="translated">Args::zip</target>
        </trans-unit>
        <trans-unit id="08a635e24e7197ec936245f74886d0fae256f6f3" translate="yes" xml:space="preserve">
          <source>ArgsOs</source>
          <target state="translated">ArgsOs</target>
        </trans-unit>
        <trans-unit id="1699d7288d57eee287607a5a8cf4daa06cbf36b5" translate="yes" xml:space="preserve">
          <source>ArgsOs::all</source>
          <target state="translated">ArgsOs::all</target>
        </trans-unit>
        <trans-unit id="1845d364695de9046a1a2e308d836950518c8379" translate="yes" xml:space="preserve">
          <source>ArgsOs::any</source>
          <target state="translated">ArgsOs::any</target>
        </trans-unit>
        <trans-unit id="b88db8b95877207b42c5e88cfc5b222b32d38f42" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow</source>
          <target state="translated">ArgsOs::borrow</target>
        </trans-unit>
        <trans-unit id="6883c744eb4014b5c2b448f2adc1b25a04e5fc9e" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow_mut</source>
          <target state="translated">ArgsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="54a7160bba6f31fb20a2a3b6f79944613335629e" translate="yes" xml:space="preserve">
          <source>ArgsOs::by_ref</source>
          <target state="translated">ArgsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="45e9d062b28c81d2586823abf5265cf79f0f53c3" translate="yes" xml:space="preserve">
          <source>ArgsOs::chain</source>
          <target state="translated">ArgsOs::chain</target>
        </trans-unit>
        <trans-unit id="06a86328c3295b9577a55fd6532e3d512a4376ad" translate="yes" xml:space="preserve">
          <source>ArgsOs::cloned</source>
          <target state="translated">ArgsOs::cloned</target>
        </trans-unit>
        <trans-unit id="aa33a26c7a85d39e633ece2b7ab215364fa8c21f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cmp</source>
          <target state="translated">ArgsOs::cmp</target>
        </trans-unit>
        <trans-unit id="4444bf776c1fcbbef6e3005b548a29289b32ecc4" translate="yes" xml:space="preserve">
          <source>ArgsOs::collect</source>
          <target state="translated">ArgsOs::collect</target>
        </trans-unit>
        <trans-unit id="efa527796ad53e7b95c87dfbab81f527bd59777a" translate="yes" xml:space="preserve">
          <source>ArgsOs::copied</source>
          <target state="translated">ArgsOs::copied</target>
        </trans-unit>
        <trans-unit id="cf8617f607b90e848c8eda2dcecf733646bd740b" translate="yes" xml:space="preserve">
          <source>ArgsOs::count</source>
          <target state="translated">ArgsOs::count</target>
        </trans-unit>
        <trans-unit id="9774f0ee5373559d8ebaf6e270d32276c2460f0f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cycle</source>
          <target state="translated">ArgsOs::cycle</target>
        </trans-unit>
        <trans-unit id="0c42cc7e9e0e5f5dcbc76f351e7fb1817634bb40" translate="yes" xml:space="preserve">
          <source>ArgsOs::enumerate</source>
          <target state="translated">ArgsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="d5b0b5b450101b6daed6089615021285ab2aa9bc" translate="yes" xml:space="preserve">
          <source>ArgsOs::eq</source>
          <target state="translated">ArgsOs::eq</target>
        </trans-unit>
        <trans-unit id="22ebb6f40c3d512ac39613bf4969beaa463bb89c" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter</source>
          <target state="translated">ArgsOs::filter</target>
        </trans-unit>
        <trans-unit id="ec9b19d64b96da14ed417d0d212d3d54ea4a4759" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter_map</source>
          <target state="translated">ArgsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="f90d91bcb86730d9c77f4746181813b55b242a5f" translate="yes" xml:space="preserve">
          <source>ArgsOs::find</source>
          <target state="translated">ArgsOs::find</target>
        </trans-unit>
        <trans-unit id="8c42c2da49296751bd09d90e62d79798dd8f5449" translate="yes" xml:space="preserve">
          <source>ArgsOs::find_map</source>
          <target state="translated">ArgsOs::find_map</target>
        </trans-unit>
        <trans-unit id="8ae8230900a56717520df737b9d2946aa58958f4" translate="yes" xml:space="preserve">
          <source>ArgsOs::flat_map</source>
          <target state="translated">ArgsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="582b0a8882844e707b1b16686981fe8a3215c0f7" translate="yes" xml:space="preserve">
          <source>ArgsOs::flatten</source>
          <target state="translated">ArgsOs::flatten</target>
        </trans-unit>
        <trans-unit id="42a3165a3645e00a5c082e56522288eb3545955a" translate="yes" xml:space="preserve">
          <source>ArgsOs::fmt</source>
          <target state="translated">ArgsOs::fmt</target>
        </trans-unit>
        <trans-unit id="c973a490f8d75776d7cc21ebc26d8640412d8da5" translate="yes" xml:space="preserve">
          <source>ArgsOs::fold</source>
          <target state="translated">ArgsOs::fold</target>
        </trans-unit>
        <trans-unit id="521243a10a5ee6932b3c00a38bb64a1066346423" translate="yes" xml:space="preserve">
          <source>ArgsOs::for_each</source>
          <target state="translated">ArgsOs::for_each</target>
        </trans-unit>
        <trans-unit id="b3beb1c32ac134bd58a5525cb75b6818caadc2e7" translate="yes" xml:space="preserve">
          <source>ArgsOs::from</source>
          <target state="translated">ArgsOs::from</target>
        </trans-unit>
        <trans-unit id="0467b6e7a5907960746adb88f1797855273e5e38" translate="yes" xml:space="preserve">
          <source>ArgsOs::fuse</source>
          <target state="translated">ArgsOs::fuse</target>
        </trans-unit>
        <trans-unit id="8d918573a70aed631b8ef7e464f6978aeac45512" translate="yes" xml:space="preserve">
          <source>ArgsOs::ge</source>
          <target state="translated">ArgsOs::ge</target>
        </trans-unit>
        <trans-unit id="ed7bd18154ad5939e8306b095fe2d6551d9c5960" translate="yes" xml:space="preserve">
          <source>ArgsOs::gt</source>
          <target state="translated">ArgsOs::gt</target>
        </trans-unit>
        <trans-unit id="f6ab996f18c666c657723e3d6b826e9d4f34afa4" translate="yes" xml:space="preserve">
          <source>ArgsOs::inspect</source>
          <target state="translated">ArgsOs::inspect</target>
        </trans-unit>
        <trans-unit id="118a0e4c62985069de5d564f7e5aeaefdb4f3eee" translate="yes" xml:space="preserve">
          <source>ArgsOs::into</source>
          <target state="translated">ArgsOs::into</target>
        </trans-unit>
        <trans-unit id="6fe469f351f3d71c45f5b8b8a01a85ba417f2962" translate="yes" xml:space="preserve">
          <source>ArgsOs::into_iter</source>
          <target state="translated">ArgsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="52e21117a73746309084ded1b85082f14e2f4f3c" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_empty</source>
          <target state="translated">ArgsOs::is_empty</target>
        </trans-unit>
        <trans-unit id="bc22f51d728c32072e58dab02dc3f74a273221da" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted</source>
          <target state="translated">ArgsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="6ce480c601285e3d630fdd46e557dfb3c792fc47" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by</source>
          <target state="translated">ArgsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="1bd6484be8e79119af4f357c6727e9cce127bfb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by_key</source>
          <target state="translated">ArgsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2960d55410634dcaa01ebfd4efb87d3210b4b30b" translate="yes" xml:space="preserve">
          <source>ArgsOs::last</source>
          <target state="translated">ArgsOs::last</target>
        </trans-unit>
        <trans-unit id="49cd1005a59ab868a13fc3b698fa037af9e3cc25" translate="yes" xml:space="preserve">
          <source>ArgsOs::le</source>
          <target state="translated">ArgsOs::le</target>
        </trans-unit>
        <trans-unit id="9662bed516b84aec77303964e4aba365d517a6ce" translate="yes" xml:space="preserve">
          <source>ArgsOs::len</source>
          <target state="translated">ArgsOs::len</target>
        </trans-unit>
        <trans-unit id="a4fd3a509313cc726b4eb5e364e66dd0311cbccc" translate="yes" xml:space="preserve">
          <source>ArgsOs::lt</source>
          <target state="translated">ArgsOs::lt</target>
        </trans-unit>
        <trans-unit id="b4ee6f488be886ab0828730edfa187e1158ffbf4" translate="yes" xml:space="preserve">
          <source>ArgsOs::map</source>
          <target state="translated">ArgsOs::map</target>
        </trans-unit>
        <trans-unit id="ae8b8dee55299bdeb6e240152d7d260302e580f0" translate="yes" xml:space="preserve">
          <source>ArgsOs::max</source>
          <target state="translated">ArgsOs::max</target>
        </trans-unit>
        <trans-unit id="f393dc70d5755703ad87bcd703e01acde42fd52e" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by</source>
          <target state="translated">ArgsOs::max_by</target>
        </trans-unit>
        <trans-unit id="c3d12b23ad084b94bc1bb5877f3a0e669b6dcbe5" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by_key</source>
          <target state="translated">ArgsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="1877909fb92070e732d578d5a61015d6567d1c05" translate="yes" xml:space="preserve">
          <source>ArgsOs::min</source>
          <target state="translated">ArgsOs::min</target>
        </trans-unit>
        <trans-unit id="1b9560ee3684ef678a7f2060396e14192ebd977a" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by</source>
          <target state="translated">ArgsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce07e6453a52864ecbf5f176d284c9622c84c927" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by_key</source>
          <target state="translated">ArgsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="77abc8099c1b361ea642538729c1cfa9c4ad2af8" translate="yes" xml:space="preserve">
          <source>ArgsOs::ne</source>
          <target state="translated">ArgsOs::ne</target>
        </trans-unit>
        <trans-unit id="94df206ce16974feea2fee745eeb9bededb98233" translate="yes" xml:space="preserve">
          <source>ArgsOs::next</source>
          <target state="translated">ArgsOs::next</target>
        </trans-unit>
        <trans-unit id="0b4bd6a54c1bdb1cb1c37909c4bbdf8ee8eedba4" translate="yes" xml:space="preserve">
          <source>ArgsOs::next_back</source>
          <target state="translated">ArgsOs::next_back</target>
        </trans-unit>
        <trans-unit id="32001a37fe7fa6c38a9dab6e3ccac83215a6af0b" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth</source>
          <target state="translated">ArgsOs::nth</target>
        </trans-unit>
        <trans-unit id="eed0fe5e0346646ed8f493e45f87707e6ef665d0" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth_back</source>
          <target state="translated">ArgsOs::nth_back</target>
        </trans-unit>
        <trans-unit id="76d2262b3586a0b114f133d396c15e36cdbd64ee" translate="yes" xml:space="preserve">
          <source>ArgsOs::partial_cmp</source>
          <target state="translated">ArgsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c88ee3f44d1aaf87a7e7075664272abea7e57c22" translate="yes" xml:space="preserve">
          <source>ArgsOs::partition</source>
          <target state="translated">ArgsOs::partition</target>
        </trans-unit>
        <trans-unit id="b772163bfba047ed1ad9679588037cc0b2a982a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::peekable</source>
          <target state="translated">ArgsOs::peekable</target>
        </trans-unit>
        <trans-unit id="28f42c15452e45ff29cd38077309d81cd1bf23ef" translate="yes" xml:space="preserve">
          <source>ArgsOs::position</source>
          <target state="translated">ArgsOs::position</target>
        </trans-unit>
        <trans-unit id="9c54799fe9d66e9fe809d53c0ad35f91d0345b2d" translate="yes" xml:space="preserve">
          <source>ArgsOs::product</source>
          <target state="translated">ArgsOs::product</target>
        </trans-unit>
        <trans-unit id="24d0c67c7635532e04027af92577d329d52e0d8d" translate="yes" xml:space="preserve">
          <source>ArgsOs::rev</source>
          <target state="translated">ArgsOs::rev</target>
        </trans-unit>
        <trans-unit id="9a893fd65a1fd7e4f90c4c16dad18ae09e1e6440" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfind</source>
          <target state="translated">ArgsOs::rfind</target>
        </trans-unit>
        <trans-unit id="2473c6d05109d83b7921dc7c8d9e3fd3e1540366" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfold</source>
          <target state="translated">ArgsOs::rfold</target>
        </trans-unit>
        <trans-unit id="61e2d2493b8b480b1c184877bc7c4508f85f3e68" translate="yes" xml:space="preserve">
          <source>ArgsOs::rposition</source>
          <target state="translated">ArgsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f7c9d7d4183c0e1185d8f756359b7aa52e99dec6" translate="yes" xml:space="preserve">
          <source>ArgsOs::scan</source>
          <target state="translated">ArgsOs::scan</target>
        </trans-unit>
        <trans-unit id="be9f72e6896d64043f92118bf0351dd06875451e" translate="yes" xml:space="preserve">
          <source>ArgsOs::size_hint</source>
          <target state="translated">ArgsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="dfcbf514097e12c73f97a48d644499d52e01f449" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip</source>
          <target state="translated">ArgsOs::skip</target>
        </trans-unit>
        <trans-unit id="b5cea38564a840936b5adf617a54cb9e1705e9a4" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip_while</source>
          <target state="translated">ArgsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="bd31eff15f1513280f3660b278f44b8403fe5bb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::step_by</source>
          <target state="translated">ArgsOs::step_by</target>
        </trans-unit>
        <trans-unit id="b896b50f4e9946df9f811558add55e6c7f4d9c0e" translate="yes" xml:space="preserve">
          <source>ArgsOs::sum</source>
          <target state="translated">ArgsOs::sum</target>
        </trans-unit>
        <trans-unit id="55f7ee9ef7a277d1da50d3847c5267d10c02f3d6" translate="yes" xml:space="preserve">
          <source>ArgsOs::take</source>
          <target state="translated">ArgsOs::take</target>
        </trans-unit>
        <trans-unit id="67ae1d83993d54c201cebc7e961a4745875403a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::take_while</source>
          <target state="translated">ArgsOs::take_while</target>
        </trans-unit>
        <trans-unit id="6feaa7bb16a2f86b2de35c4152c898840e5c73a7" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_fold</source>
          <target state="translated">ArgsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="4de4927e12902d929342841a0f0a05adc02a2b88" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_for_each</source>
          <target state="translated">ArgsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="ef2e8777c2c6780af369e18d8923c4a5b07b73cc" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_from</source>
          <target state="translated">ArgsOs::try_from</target>
        </trans-unit>
        <trans-unit id="dde21f1986a82cfe6d32ebda71aaf8cffb865725" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_into</source>
          <target state="translated">ArgsOs::try_into</target>
        </trans-unit>
        <trans-unit id="752061f583e2a023f82e25f293fbc12638874e24" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_rfold</source>
          <target state="translated">ArgsOs::try_rfold</target>
        </trans-unit>
        <trans-unit id="9cea18d9f52cf4e66c35caae6f3a3d7426f8ebf1" translate="yes" xml:space="preserve">
          <source>ArgsOs::type_id</source>
          <target state="translated">ArgsOs::type_id</target>
        </trans-unit>
        <trans-unit id="dcc7a51ed1d3dac6d37f7b6f7415fe425b54aac1" translate="yes" xml:space="preserve">
          <source>ArgsOs::unzip</source>
          <target state="translated">ArgsOs::unzip</target>
        </trans-unit>
        <trans-unit id="0477d6e4f174e07114d3143d029569031152c407" translate="yes" xml:space="preserve">
          <source>ArgsOs::zip</source>
          <target state="translated">ArgsOs::zip</target>
        </trans-unit>
        <trans-unit id="bd7faaad666e01c1bc85c0559542193db97f87bb" translate="yes" xml:space="preserve">
          <source>Argument and element separator</source>
          <target state="translated">参数和元素分隔符</target>
        </trans-unit>
        <trans-unit id="0e653d9296c0f3183cfcfa59576a82649ae7862d" translate="yes" xml:space="preserve">
          <source>Argument types</source>
          <target state="translated">参数类型</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a3115a849e9a8fd08f66c020b31248aefac3bb62" translate="yes" xml:space="preserve">
          <source>Arguments for function calls</source>
          <target state="translated">函数调用的参数</target>
        </trans-unit>
        <trans-unit id="599f9cef30e51c86c0307365f585d93f4615d4d0" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">急切地评估传递给 &lt;code&gt;map_or&lt;/code&gt; 的参数；如果您要传递函数调用的结果，建议使用延迟评估的&lt;a href=&quot;enum.option#method.map_or_else&quot;&gt; &lt;code&gt;map_or_else&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0b13e1e9de1f734ef5d809e601926031419d1d8" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">急切地评估传递给 &lt;code&gt;map_or&lt;/code&gt; 的参数；如果您要传递函数调用的结果，建议使用延迟评估的&lt;a href=&quot;enum.result#method.map_or_else&quot;&gt; &lt;code&gt;map_or_else&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60b48e4141151169e113485ecab80a4bb3c30bdc" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">急切地评估传递给 &lt;code&gt;ok_or&lt;/code&gt; 的参数；如果要传递函数调用的结果，建议使用&lt;a href=&quot;#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt;，它是延迟计算的。</target>
        </trans-unit>
        <trans-unit id="c72e63e8acf76e2210299bb8523a4d987e02e598" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">急切地评估传递给 &lt;code&gt;ok_or&lt;/code&gt; 的参数；如果要传递函数调用的结果，建议使用&lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt;，它是延迟计算的。</target>
        </trans-unit>
        <trans-unit id="b34ba4a25e5cb9253c52e9c96f12b4a3b5b442c1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">传递给 &lt;code&gt;or&lt;/code&gt; 渴望评估的论点；如果要传递函数调用的结果，建议使用&lt;a href=&quot;#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt;，它是延迟计算的。</target>
        </trans-unit>
        <trans-unit id="e8e3ad3f9d440f41a4bced3ec981aa2d05bd534c" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">传递给 &lt;code&gt;or&lt;/code&gt; 急切评估的论点；如果要传递函数调用的结果，建议使用&lt;a href=&quot;enum.option#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt;，它是延迟计算的。</target>
        </trans-unit>
        <trans-unit id="3fb2e5d47e33897712d4dff15280a3a0c997b492" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">传递给 &lt;code&gt;or&lt;/code&gt; 急切评估的论点；如果要传递函数调用的结果，建议使用&lt;a href=&quot;enum.result#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt;，它是延迟计算的。</target>
        </trans-unit>
        <trans-unit id="81e7e0f40306bc29fb2793ce221652d077995d0b" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">急切地评估传递给 &lt;code&gt;unwrap_or&lt;/code&gt; 的参数；如果要传递函数调用的结果，建议使用&lt;a href=&quot;#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;，它是延迟计算的。</target>
        </trans-unit>
        <trans-unit id="15ac6e3ce55f8f212059dc3a36cc981d9be8aca1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">急切地评估传递给 &lt;code&gt;unwrap_or&lt;/code&gt; 的参数；如果要传递函数调用的结果，建议使用&lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;，它是延迟计算的。</target>
        </trans-unit>
        <trans-unit id="935c37b281819663d093edd0e6a0df21fc148074" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">急切地评估传递给 &lt;code&gt;unwrap_or&lt;/code&gt; 的参数；如果要传递函数调用的结果，建议使用&lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;，它是延迟计算的。</target>
        </trans-unit>
        <trans-unit id="ca682bb604cd951faf7e687e9dc577ccfb4ccbcc" translate="yes" xml:space="preserve">
          <source>Arguments::borrow</source>
          <target state="translated">Arguments::borrow</target>
        </trans-unit>
        <trans-unit id="02b0d59380fa1adbbfa0a4e488839d014c6a84b9" translate="yes" xml:space="preserve">
          <source>Arguments::borrow_mut</source>
          <target state="translated">Arguments::borrow_mut</target>
        </trans-unit>
        <trans-unit id="beee63977406683694c63c877a281368e8498185" translate="yes" xml:space="preserve">
          <source>Arguments::clone</source>
          <target state="translated">Arguments::clone</target>
        </trans-unit>
        <trans-unit id="9b4336ed72fcc8790d465ff622f1ee33ef64dd5f" translate="yes" xml:space="preserve">
          <source>Arguments::clone_from</source>
          <target state="translated">Arguments::clone_from</target>
        </trans-unit>
        <trans-unit id="9f534ce31b28796358e33f058c8f30771441c413" translate="yes" xml:space="preserve">
          <source>Arguments::clone_into</source>
          <target state="translated">Arguments::clone_into</target>
        </trans-unit>
        <trans-unit id="e2264984672013569ff3cb5667d1fb059d3a9aff" translate="yes" xml:space="preserve">
          <source>Arguments::fmt</source>
          <target state="translated">Arguments::fmt</target>
        </trans-unit>
        <trans-unit id="e6967e42010df585387f1e1ee0a1ddd2861644a6" translate="yes" xml:space="preserve">
          <source>Arguments::from</source>
          <target state="translated">Arguments::from</target>
        </trans-unit>
        <trans-unit id="f7110cbfaa9d19f7a1a5d2f96c337419907bb156" translate="yes" xml:space="preserve">
          <source>Arguments::into</source>
          <target state="translated">Arguments::into</target>
        </trans-unit>
        <trans-unit id="f71fad745c8ecba4adbbf940ce0a934c1bbb9409" translate="yes" xml:space="preserve">
          <source>Arguments::to_owned</source>
          <target state="translated">Arguments::to_owned</target>
        </trans-unit>
        <trans-unit id="2f1106daf75575ebf9ff5096d88d4bd32bee8e3a" translate="yes" xml:space="preserve">
          <source>Arguments::to_string</source>
          <target state="translated">Arguments::to_string</target>
        </trans-unit>
        <trans-unit id="44514fad8f521c67acba588fe00d7592016a908f" translate="yes" xml:space="preserve">
          <source>Arguments::try_from</source>
          <target state="translated">Arguments::try_from</target>
        </trans-unit>
        <trans-unit id="8bb902c723ba932ded5aa3da8d68330e0bd8dfdd" translate="yes" xml:space="preserve">
          <source>Arguments::try_into</source>
          <target state="translated">Arguments::try_into</target>
        </trans-unit>
        <trans-unit id="93c384146f511c59251c10079f21618fcc345340" translate="yes" xml:space="preserve">
          <source>Arguments::type_id</source>
          <target state="translated">Arguments::type_id</target>
        </trans-unit>
        <trans-unit id="52ed5399cec328eed1c4d10b234f6d54945d8379" translate="yes" xml:space="preserve">
          <source>Arithmetic addition</source>
          <target state="translated">算术加法</target>
        </trans-unit>
        <trans-unit id="b6a2b173c28c2d32e0f07c5865706f1a0af1dc82" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and assignment</source>
          <target state="translated">算术加法和赋值</target>
        </trans-unit>
        <trans-unit id="481206dd7e4055d67971a43266f17dd6c8acf74d" translate="yes" xml:space="preserve">
          <source>Arithmetic and Logical Binary Operators</source>
          <target state="translated">算术和逻辑二进制运算符</target>
        </trans-unit>
        <trans-unit id="ba8c163933eb964b78854dfa7b1e1313a4ece109" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operators on integers</source>
          <target state="translated">整数的算术和比较运算符</target>
        </trans-unit>
        <trans-unit id="3a2ccea0b8aef06fcf5a90ab7c705782be897b40" translate="yes" xml:space="preserve">
          <source>Arithmetic division</source>
          <target state="translated">算术除法</target>
        </trans-unit>
        <trans-unit id="dfc8f592565726eb9a5251995ebe9c35af2683f2" translate="yes" xml:space="preserve">
          <source>Arithmetic division and assignment</source>
          <target state="translated">算术除法和赋值</target>
        </trans-unit>
        <trans-unit id="5e0f6d1b7afc18895e08ec06673e25445eca9bd9" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication</source>
          <target state="translated">算术乘法</target>
        </trans-unit>
        <trans-unit id="aed641007b737ba787b84c11db1a76f81a7265ec" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication and assignment</source>
          <target state="translated">算术乘法和赋值</target>
        </trans-unit>
        <trans-unit id="9501694b83625ba1c4c32e0300c7e3ef0ea5895a" translate="yes" xml:space="preserve">
          <source>Arithmetic negation</source>
          <target state="translated">算术否定论</target>
        </trans-unit>
        <trans-unit id="4b7e345ffd8cb02b4c25248f3c2916dd526e2269" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder</source>
          <target state="translated">算术余数</target>
        </trans-unit>
        <trans-unit id="4af14fe332c2fec7e550537a659d27f7672cf52b" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder and assignment</source>
          <target state="translated">算术余数和转让</target>
        </trans-unit>
        <trans-unit id="54604a8945847efcfbb8925458787851115f9296" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction</source>
          <target state="translated">算术减法</target>
        </trans-unit>
        <trans-unit id="40c2d180ceb1daebfda27a7dc052bf6e18437123" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction and assignment</source>
          <target state="translated">算术减法和赋值</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="1fd516c87a7c389dccca9649a7b656d2f047d85d" translate="yes" xml:space="preserve">
          <source>Arity refers to the number of arguments a function or operator takes. For some examples, &lt;code&gt;f(2, 3)&lt;/code&gt; and &lt;code&gt;g(4, 6)&lt;/code&gt; have arity 2, while &lt;code&gt;h(8, 2, 6)&lt;/code&gt; has arity 3. The &lt;code&gt;!&lt;/code&gt; operator has arity 1.</source>
          <target state="translated">Arity是指函数或运算符采用的参数数量。对于某些示例， &lt;code&gt;f(2, 3)&lt;/code&gt; 和 &lt;code&gt;g(4, 6)&lt;/code&gt; 值为2，而 &lt;code&gt;h(8, 2, 6)&lt;/code&gt; 8，2，6 ）的值为3 &lt;code&gt;!&lt;/code&gt; 操作员有礼貌1。</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e88a1d916bd09fa0781281dd0639410541b1c200" translate="yes" xml:space="preserve">
          <source>Array Layout</source>
          <target state="translated">阵列布局</target>
        </trans-unit>
        <trans-unit id="811e7deb41b753134a124c771bc129d2aad4f69f" translate="yes" xml:space="preserve">
          <source>Array and array index expressions</source>
          <target state="translated">数组和数组索引表达式</target>
        </trans-unit>
        <trans-unit id="0844515b5a634fa1753332ae502ec5bc059c9bf4" translate="yes" xml:space="preserve">
          <source>Array and slice indexing expressions</source>
          <target state="translated">阵列和分片索引表达式</target>
        </trans-unit>
        <trans-unit id="1c901b7185d5b71317418dac8afa7a9edb10a639" translate="yes" xml:space="preserve">
          <source>Array expression attributes</source>
          <target state="translated">阵列表达式属性</target>
        </trans-unit>
        <trans-unit id="ff659441b84e2964045ca09a8c18a08d44b84a61" translate="yes" xml:space="preserve">
          <source>Array expressions</source>
          <target state="translated">阵列表达式</target>
        </trans-unit>
        <trans-unit id="b4a857fc21bf592938e9dd2ec1d467878b6cf83e" translate="yes" xml:space="preserve">
          <source>Array literal</source>
          <target state="translated">阵列文字</target>
        </trans-unit>
        <trans-unit id="4935b8502c9911035c4038af29553fcfde8b5706" translate="yes" xml:space="preserve">
          <source>Array literal containing &lt;code&gt;len&lt;/code&gt; copies of &lt;code&gt;expr&lt;/code&gt;</source>
          <target state="translated">包含 &lt;code&gt;expr&lt;/code&gt; 的 &lt;code&gt;len&lt;/code&gt; 个副本的数组文字</target>
        </trans-unit>
        <trans-unit id="235f924c7c3818aed78845bd2de8791d4d3ba101" translate="yes" xml:space="preserve">
          <source>Array literals with repeating syntax, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. The repeated sub-expression is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">具有重复语法的数组文字，其中数组的类型为 &lt;code&gt;[U; n]&lt;/code&gt; 。重复的子表达式是强制转换为 &lt;code&gt;U&lt;/code&gt; 型的强制位置。</target>
        </trans-unit>
        <trans-unit id="41d08ca772cf664e0e365d09949f5835931ea185" translate="yes" xml:space="preserve">
          <source>Array literals, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. Each sub-expression in the array literal is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">数组文字，其中数组的类型为 &lt;code&gt;[U; n]&lt;/code&gt; 。数组文字中的每个子表达式都是强制类型 &lt;code&gt;U&lt;/code&gt; 的强制站点。</target>
        </trans-unit>
        <trans-unit id="5de52c0cb2ce4e0eb71f0c098408cbd13a499a61" translate="yes" xml:space="preserve">
          <source>Array repeat length expressions</source>
          <target state="translated">阵列重复长度表达式</target>
        </trans-unit>
        <trans-unit id="ea9dbd560327931c17a47c31880f0fcea2d052f4" translate="yes" xml:space="preserve">
          <source>Array to pointer cast</source>
          <target state="translated">阵列到指针投射</target>
        </trans-unit>
        <trans-unit id="45de270a590c4d4b0320d8105310eb72bc4364df" translate="yes" xml:space="preserve">
          <source>Array type containing &lt;code&gt;len&lt;/code&gt; instances of &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">包含 &lt;code&gt;len&lt;/code&gt; 个类型的实例的数组 &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51a7c3ed1d5f017cc725067fca3064cb604b7344" translate="yes" xml:space="preserve">
          <source>Array type length expressions</source>
          <target state="translated">阵列类型长度表达式</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">阵列类型</target>
        </trans-unit>
        <trans-unit id="51fa61d38d898a29b7f71e858ac412133bb4aa78" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">如果项目类型也实现 &lt;code&gt;Clone&lt;/code&gt; ，则所有大小的数组类型（例如 &lt;code&gt;[i32; 123456]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c11c5b2f8cc2056c662bde9d8e7265077775fda2" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">如果项目类型也实现了 &lt;code&gt;Copy&lt;/code&gt; ，则所有大小的数组类型（例如 &lt;code&gt;[i32; 123456]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="95c5c33f29f0547a430b0665b6ac583648900bd6" translate="yes" xml:space="preserve">
          <source>ArrayChunks</source>
          <target state="translated">ArrayChunks</target>
        </trans-unit>
        <trans-unit id="5d42cc662a1c24ca3713c4fbd65f30d1d4685e7c" translate="yes" xml:space="preserve">
          <source>ArrayChunksMut</source>
          <target state="translated">ArrayChunksMut</target>
        </trans-unit>
        <trans-unit id="f83b691df0418afaddc970026f4eccfa1541c51f" translate="yes" xml:space="preserve">
          <source>ArrayWindows</source>
          <target state="translated">ArrayWindows</target>
        </trans-unit>
        <trans-unit id="aa557f1be66399eaf12f2be07d75660861cacf56" translate="yes" xml:space="preserve">
          <source>Arrays are laid out so that the &lt;code&gt;nth&lt;/code&gt; element of the array is offset from the start of the array by &lt;code&gt;n * the size of the type&lt;/code&gt; bytes. An array of &lt;code&gt;[T; n]&lt;/code&gt; has a size of &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; and the same alignment of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">排列数组，使数组的 &lt;code&gt;nth&lt;/code&gt; 元素从数组的开头偏移 &lt;code&gt;n * the size of the type&lt;/code&gt; 字节的大小。的阵列 &lt;code&gt;[T; n]&lt;/code&gt; 的大小为 &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; 并且 &lt;code&gt;T&lt;/code&gt; 的对齐方式相同。</target>
        </trans-unit>
        <trans-unit id="02fe2a892020ef77103f56bebff06ee9353b3385" translate="yes" xml:space="preserve">
          <source>Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn&amp;rsquo;t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that &lt;em&gt;is&lt;/em&gt; allowed to grow or shrink in size. If you&amp;rsquo;re unsure whether to use an array or a vector, you should probably use a vector. Chapter 8 discusses vectors in more detail.</source>
          <target state="translated">当您希望将数据分配在堆栈而不是堆上时（当我们在第4章中讨论堆栈和堆时），或者要确保始终有固定数量的元素时，数组很有用。但是，数组不像矢量类型那样灵活。载体是由标准库提供一个类似集合类型&lt;em&gt;是&lt;/em&gt;允许生长或尺寸的缩小。如果不确定使用数组还是向量，则可能应该使用向量。第8章将更详细地讨论向量。</target>
        </trans-unit>
        <trans-unit id="3b3785f54b6fb9b400ea9ab57c87c42e59186241" translate="yes" xml:space="preserve">
          <source>Arrays coerce to &lt;a href=&quot;primitive.slice&quot;&gt;slices (&lt;code&gt;[T]&lt;/code&gt;)&lt;/a&gt;, so a slice method may be called on an array. Indeed, this provides most of the API for working with arrays. Slices have a dynamic size and do not coerce to arrays.</source>
          <target state="translated">数组强制为&lt;a href=&quot;primitive.slice&quot;&gt;slice（ &lt;code&gt;[T]&lt;/code&gt; ）&lt;/a&gt;，因此可以在数组上调用slice方法。实际上，这提供了用于处理数组的大多数API。切片具有动态大小，并且不强制转换为数组。</target>
        </trans-unit>
        <trans-unit id="a5463b6c378c5a1ce536679177693788d8a488ef" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;. This works because &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits are specially known to the compiler.</source>
          <target state="translated">如果元素类型为&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则&lt;em&gt;任何&lt;/em&gt;大小的数组为&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; ;&lt;/a&gt;如果元素类型为&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，则为&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;。之所以&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，是因为复制和&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;特征是编译器特有的。</target>
        </trans-unit>
        <trans-unit id="44fcd591dcf7f314f13f655158af04cf8a3c0c81" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size implement the following traits if the element type allows it:</source>
          <target state="translated">如果元素类型允许，则&lt;em&gt;任何&lt;/em&gt;大小的数组都具有以下特征：</target>
        </trans-unit>
        <trans-unit id="6563ac44bbb67213c7a3f6f4eeedf9dc732e3220" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">如果元素类型允许，则大小范围为0到32（含）的数组将实现&lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; trait。作为权宜之计，特质实现是静态生成的，最大大小为32。</target>
        </trans-unit>
        <trans-unit id="4f9eb669ece946f30cfd95add30aac8bad032e42" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">如果元素类型允许，则大小范围从0到32（含）的数组将实现&lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; trait。作为权宜之计，特质实现是静态生成的，最大大小为32。</target>
        </trans-unit>
        <trans-unit id="e22eb391f81362ae0eac8c4cd60b81a4562599d8" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the following traits if the element type allows it:</source>
          <target state="translated">如果元素类型允许,大小从0到32(含)的数组可以实现以下特性。</target>
        </trans-unit>
        <trans-unit id="3520f70ba3a61ccc1286dbddd33fb0815248aa0b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;if&lt;/code&gt; expressions have their pattern matching variant in &lt;code&gt;if let&lt;/code&gt;, so too do &lt;code&gt;while&lt;/code&gt; expressions with &lt;code&gt;while let&lt;/code&gt;. The &lt;code&gt;while let&lt;/code&gt; expression matches the pattern against the expression, then runs the loop body if pattern matching succeeds, or exits the loop otherwise. We can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; in &lt;code&gt;while let&lt;/code&gt; expressions just like in &lt;code&gt;while&lt;/code&gt;.</source>
          <target state="translated">至于 &lt;code&gt;if&lt;/code&gt; 表达式有自己的模式匹配变体， &lt;code&gt;if let&lt;/code&gt; ，这样做也 &lt;code&gt;while&lt;/code&gt; 表达与 &lt;code&gt;while let&lt;/code&gt; 。的 &lt;code&gt;while let&lt;/code&gt; 表达针对表达模式匹配，那么，如果模式匹配成功运行循环体，或以其他方式退出循环。我们可以使用 &lt;code&gt;break&lt;/code&gt; 并 &lt;code&gt;continue&lt;/code&gt; 在 &lt;code&gt;while let&lt;/code&gt; 表达式中，就像在 &lt;code&gt;while&lt;/code&gt; 中一样。</target>
        </trans-unit>
        <trans-unit id="2be2422a9ce4d7fe654319fa259c94897e3e7b46" translate="yes" xml:space="preserve">
          <source>As IANA assigns new addresses, this method will be updated. This may result in non-reserved addresses being treated as reserved in code that relies on an outdated version of this method.</source>
          <target state="translated">随着IANA分配新的地址,这个方法将被更新。这可能会导致在依赖该方法过时版本的代码中,非保留地址被视为保留。</target>
        </trans-unit>
        <trans-unit id="204e461bb880d4d3e097aeac5f123e90d90ae7f0" translate="yes" xml:space="preserve">
          <source>As Rust automatically calls the destructors of all contained fields, you don't have to implement &lt;code&gt;Drop&lt;/code&gt; in most cases. But there are some cases where it is useful, for example for types which directly manage a resource. That resource may be memory, it may be a file descriptor, it may be a network socket. Once a value of that type is no longer going to be used, it should &quot;clean up&quot; its resource by freeing the memory or closing the file or socket. This is the job of a destructor, and therefore the job of &lt;code&gt;Drop::drop&lt;/code&gt;.</source>
          <target state="translated">由于Rust自动调用所有包含字段的析构函数，因此在大多数情况下，您无需实现 &lt;code&gt;Drop&lt;/code&gt; 。但是在某些情况下它很有用，例如对于直接管理资源的类型。该资源可能是内存，可能是文件描述符，可能是网络套接字。一旦不再使用该类型的值，它应通过释放内存或关闭文件或套接字来&amp;ldquo;清理&amp;rdquo;其资源。这是析构函数的工作，因此也是 &lt;code&gt;Drop::drop&lt;/code&gt; 的工作。</target>
        </trans-unit>
        <trans-unit id="0e9f144fd6603397ae748bc2c2b95fde2038ac9c" translate="yes" xml:space="preserve">
          <source>As a companion to &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; this trait allows a type to borrow as an underlying type by providing a mutable reference. See &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on borrowing as another type.</source>
          <target state="translated">作为&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;的伴侣，此特征允许类型通过提供可变引用来借用作为基础类型。有关&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;另一种类型的更多信息，请参见Borrow &amp;lt;T&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="f044338e83e2522cd461ee6d84f7c5ea2e52e486" translate="yes" xml:space="preserve">
          <source>As a consequence, the hash map breaks if a &lt;code&gt;K&lt;/code&gt; wrapping a &lt;code&gt;Q&lt;/code&gt; value produces a different hash than &lt;code&gt;Q&lt;/code&gt;. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:</source>
          <target state="translated">结果，如果包裹 &lt;code&gt;Q&lt;/code&gt; 值的 &lt;code&gt;K&lt;/code&gt; 产生与 &lt;code&gt;Q&lt;/code&gt; 不同的哈希，则哈希映射将中断。例如，假设您有一个包裹字符串但比较ASCII字母而忽略大小写的类型：</target>
        </trans-unit>
        <trans-unit id="21e6ec20b4bccf73414453b9c7ceac9ffa2614a2" translate="yes" xml:space="preserve">
          <source>As a data collection, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; owns both keys and values. If the key&amp;rsquo;s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key&amp;rsquo;s data. For instance, if the key is a string, then it is likely stored with the hash map as a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, while it should be possible to search using a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;insert&lt;/code&gt; needs to operate on a &lt;code&gt;String&lt;/code&gt; while &lt;code&gt;get&lt;/code&gt; needs to be able to use a &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">作为数据收集，&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt;拥有键和值。但是，如果将密钥的实际数据包装在某种管理类型中，则仍然应该可以使用对密钥数据的引用来搜索值。例如，如果键是一个字符串，则它很可能与哈希图一起存储为&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;，而应该可以使用&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;进行搜索。因此， &lt;code&gt;insert&lt;/code&gt; 需要对 &lt;code&gt;String&lt;/code&gt; 进行操作，而 &lt;code&gt;get&lt;/code&gt; 需要能够使用 &lt;code&gt;&amp;amp;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72b018e0e36049ad8edb2d9275fa43ffbd253ac2" translate="yes" xml:space="preserve">
          <source>As a first example of ownership, we&amp;rsquo;ll look at the &lt;em&gt;scope&lt;/em&gt; of some variables. A scope is the range within a program for which an item is valid. Let&amp;rsquo;s say we have a variable that looks like this:</source>
          <target state="translated">作为所有权的第一个示例，我们将研究一些变量的&lt;em&gt;范围&lt;/em&gt;。范围是程序中项目有效的范围。假设我们有一个看起来像这样的变量：</target>
        </trans-unit>
        <trans-unit id="ec757385247cd107e43eba2a3f4a658f211a87a6" translate="yes" xml:space="preserve">
          <source>As a hack to work around this, we use two separate traits injected by each of the two derives (&lt;code&gt;#[derive(PartialEq)]&lt;/code&gt; and &lt;code&gt;#[derive(Eq)]&lt;/code&gt;) and check that both of them are present as part of structural-match checking.</source>
          <target state="translated">作为解决此问题的技巧，我们使用两个 &lt;code&gt;#[derive(PartialEq)]&lt;/code&gt; （＃[derive（PartialEq）]和 &lt;code&gt;#[derive(Eq)]&lt;/code&gt; ）中的每个注入的两个独立特征，并检查它们是否都存在于结构化-匹配检查。</target>
        </trans-unit>
        <trans-unit id="0024a0a24aed0a7ac58334f18eea8263ecf48ec1" translate="yes" xml:space="preserve">
          <source>As a language, Rust cares a &lt;em&gt;lot&lt;/em&gt; about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can&amp;rsquo;t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</source>
          <target state="translated">作为一门语言，防锈在乎一个&lt;em&gt;很多&lt;/em&gt;关于你的代码的稳定性。我们希望Rust成为您可以立足的坚如磐石的基础，如果事情不断变化，那将是不可能的。同时，如果我们不能尝试新功能，则可能要等到重大缺陷发布后才能再进行更改，否则就无法发现重要缺陷。</target>
        </trans-unit>
        <trans-unit id="c7163ba6f2bf3417c3c81c5ac8d3af7e28902510" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; when a conversion to a type outside the current crate is required.</source>
          <target state="translated">作为库作者，您应该始终喜欢实施&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;，因为&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;提供了更大的灵活性，并免费提供了等效的&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;实现，这要归功于标准库中的全面实施。仅在需要转换为当前包装箱之外的类型时才实现&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c688289e645266d022bd25b11abee98bf47d494f" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. When targeting a version prior to Rust 1.41, it may be necessary to implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; directly when converting to a type outside the current crate.</source>
          <target state="translated">作为库作者，您应该始终喜欢实现&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;，因为&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;提供了更大的灵活性，并免费提供了等效的&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;实现，这要归功于标准库中的全面实现。当针对Rust 1.41之前的版本时，在转换为当前板条箱之外的类型时，可能有必要直接实现&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff562238e6519efc127fd0f82f8c3d4cbe94172e" translate="yes" xml:space="preserve">
          <source>As a more concise alternative, you can use a &lt;code&gt;for&lt;/code&gt; loop and execute some code for each item in a collection. A &lt;code&gt;for&lt;/code&gt; loop looks like the code in Listing 3-5.</source>
          <target state="translated">作为更简洁的选择，您可以使用 &lt;code&gt;for&lt;/code&gt; 循环并为集合中的每个项目执行一些代码。一个 &lt;code&gt;for&lt;/code&gt; 循环类似于清单3-5中的代码。</target>
        </trans-unit>
        <trans-unit id="4b5b050c97f5fa423f8a999dca4b012b9c78134c" translate="yes" xml:space="preserve">
          <source>As a result of this code, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;lol&lt;/code&gt;.</source>
          <target state="translated">作为此代码的结果， &lt;code&gt;s&lt;/code&gt; 将包含 &lt;code&gt;lol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b710b8f0107d2ffba9437950b5808cd39ab806b4" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">结果，此方法将诸如 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; &lt;code&gt;fe81::&lt;/code&gt; 或fe81 ::之类的地址视为单播链接本地地址，而&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt;则不是。如果需要完全符合RFC的严格验证，请改用&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f98a89f1abd2dd1d5bfe499fd5b56372a5800c2" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">结果，此方法将诸如 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; &lt;code&gt;fe81::&lt;/code&gt; 或fe81 ::之类的地址视为单播链接本地地址，而&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt;则不是。如果需要完全符合RFC的严格验证，请使用&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="486c7c23286a7b0e1299ccac2ee0a869b3e82ee5" translate="yes" xml:space="preserve">
          <source>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</source>
          <target state="translated">由于字符串分片由字节序列组成,我们可以通过字节来迭代一个字符串分片。本方法返回这样一个迭代器。</target>
        </trans-unit>
        <trans-unit id="13230333554cf4f41cab6ad4fc5190eeee2538f2" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">由于字符串切片由有效的UTF-8组成，因此我们可以通过&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;遍历字符串切片。此方法返回这两个&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;以及它们的字节位置的迭代器。</target>
        </trans-unit>
        <trans-unit id="437cfa80202d923ee25f6cf5ad0fd2f02cfb01ea" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">由于字符串切片由有效的UTF-8组成，因此我们可以通过&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;遍历字符串切片。此方法返回这样的迭代器。</target>
        </trans-unit>
        <trans-unit id="5e4e8ad23ff47badf3452433750942f67bdc2881" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">由于字符串切片由有效的UTF-8组成，因此我们可以通过&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;遍历字符串切片。此方法返回这两个&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;以及它们的字节位置的迭代器。</target>
        </trans-unit>
        <trans-unit id="b276d81f1ebeb72ef92a468ba3b31b82b8dbf57a" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">由于字符串切片由有效的UTF-8组成，因此我们可以通过&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;遍历字符串切片。此方法返回这样的迭代器。</target>
        </trans-unit>
        <trans-unit id="fb40adb4e231d6bdd9f0bd0f9320f4357a2e82ae" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">由于字符串切片由有效的UTF-8组成，因此我们可以通过&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;遍历字符串切片。此方法返回这两个&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;以及它们的字节位置的迭代器。</target>
        </trans-unit>
        <trans-unit id="bf66f1c269d4394c9cb4445fd4fd600e640f2992" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">由于字符串切片由有效的UTF-8组成，因此我们可以通过&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;遍历字符串切片。此方法返回这样的迭代器。</target>
        </trans-unit>
        <trans-unit id="047a0a2f69f724c14716efaa0063a5ea83e459c4" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">由于字符串切片由有效的UTF-8组成，因此我们可以通过&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;遍历字符串切片。此方法返回这两个&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;以及它们的字节位置的迭代器。</target>
        </trans-unit>
        <trans-unit id="6d408364fefca0ab968a9b16914cf4b387f8e95e" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">由于字符串切片由有效的UTF-8组成，因此我们可以通过&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;遍历字符串切片。此方法返回这样的迭代器。</target>
        </trans-unit>
        <trans-unit id="b4d78aa978dc16456ba4fafe0a526ad6183e3881" translate="yes" xml:space="preserve">
          <source>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '&amp;eacute;' character is one Unicode code point while 'é' is two Unicode code points:</source>
          <target state="translated">与往常一样，请记住，人类对&amp;ldquo;字符&amp;rdquo;的直觉可能不会映射到Unicode的定义。例如，尽管看起来很相似，但'&amp;eacute;'字符是一个Unicode代码点，而'&amp;eacute;'是两个Unicode代码点：</target>
        </trans-unit>
        <trans-unit id="8d82369403176e5c690373478594ff76e764a9ef" translate="yes" xml:space="preserve">
          <source>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not &lt;em&gt;simultaneous&lt;/em&gt; ones:</source>
          <target state="translated">与往常一样，我们可以使用大括号创建新的范围，从而允许多个可变引用，而不能&lt;em&gt;同时&lt;/em&gt;引用：</target>
        </trans-unit>
        <trans-unit id="c5be02ef05f525885a914931855842d0bd0941ea" translate="yes" xml:space="preserve">
          <source>As an example of how to use a mutex, let&amp;rsquo;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</source>
          <target state="translated">作为如何使用互斥锁的示例，让我们从在单线程上下文中使用互斥锁开始，如清单16-12所示：</target>
        </trans-unit>
        <trans-unit id="0a2b1532710f708a62d9bd14aa059c7176218c09" translate="yes" xml:space="preserve">
          <source>As an example of methods on a trait, consider the following:</source>
          <target state="translated">作为一个关于性状的方法的例子,考虑以下内容。</target>
        </trans-unit>
        <trans-unit id="46ce22c9bcccaee92580f06aedfeeb7db04850fe" translate="yes" xml:space="preserve">
          <source>As an example of where you could use either a closure defined inline or a named function, let&amp;rsquo;s look at a use of &lt;code&gt;map&lt;/code&gt;. To use the &lt;code&gt;map&lt;/code&gt; function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</source>
          <target state="translated">作为可以在其中使用闭包定义的内联函数或命名函数的示例，让我们看一下 &lt;code&gt;map&lt;/code&gt; 的用法。要使用 &lt;code&gt;map&lt;/code&gt; 函数将数字向量转换为字符串向量，我们可以使用闭包，如下所示：</target>
        </trans-unit>
        <trans-unit id="37540a09808abda7d1579f892bfd40fb102faf8d" translate="yes" xml:space="preserve">
          <source>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</source>
          <target state="translated">举个例子,清单11-10中有一个愚蠢的函数,打印其参数的值并返回10,还有一个测试通过和一个测试失败。</target>
        </trans-unit>
        <trans-unit id="53691b327422875e6972393627946b878398498e" translate="yes" xml:space="preserve">
          <source>As an example, a macro matcher like &lt;code&gt;$i:expr [ , ]&lt;/code&gt; could in theory be accepted in Rust today, since &lt;code&gt;[,]&lt;/code&gt; cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because &lt;code&gt;[&lt;/code&gt; can start trailing expressions, &lt;code&gt;[&lt;/code&gt; is not a character which can safely be ruled out as coming after an expression. If &lt;code&gt;[,]&lt;/code&gt; were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like &lt;code&gt;$i:expr,&lt;/code&gt; or &lt;code&gt;$i:expr;&lt;/code&gt; would be legal, however, because &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; are legal expression separators. The specific rules are:</source>
          <target state="translated">例如，今天理论上像 &lt;code&gt;$i:expr [ , ]&lt;/code&gt; 这样的宏匹配器今天在Rust中可以被接受，因为 &lt;code&gt;[,]&lt;/code&gt; 不能成为合法表达式的一部分，因此解析始终是明确的。但是，由于 &lt;code&gt;[&lt;/code&gt; 可以开始后面的表达式，所以 &lt;code&gt;[&lt;/code&gt; 不是可以安全地排除在表达式之后的字符。如果 &lt;code&gt;[,]&lt;/code&gt; 在更高版本的Rust中被接受，则该匹配器将变得模棱两可或解析不正确，从而破坏了工作代码。匹配器，例如 &lt;code&gt;$i:expr,&lt;/code&gt; 或 &lt;code&gt;$i:expr;&lt;/code&gt; 是合法的，但是，因为 &lt;code&gt;,&lt;/code&gt; 和 &lt;code&gt;;&lt;/code&gt; 是合法的表达式分隔符。具体规则是：</target>
        </trans-unit>
        <trans-unit id="3c5226f2d8790540dbbe88f9ad68f2409b55a32e" translate="yes" xml:space="preserve">
          <source>As an example, change the &lt;em&gt;src/main.rs&lt;/em&gt; file in your &lt;em&gt;loops&lt;/em&gt; directory to look like this:</source>
          <target state="translated">例如，将&lt;em&gt;loops&lt;/em&gt;目录中的&lt;em&gt;src / main.rs&lt;/em&gt;文件更改为如下所示：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0fd43eedc8fb375dd6813798e9b7e3996a0f09" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our &lt;code&gt;enum&lt;/code&gt; by changing the &lt;code&gt;Quarter&lt;/code&gt; variant to include a &lt;code&gt;UsState&lt;/code&gt; value stored inside it, which we&amp;rsquo;ve done here in Listing 6-4.</source>
          <target state="translated">例如，让我们更改一个枚举变量以将数据保存在其中。从1999年到2008年，美国为一侧的50个州铸造了不同设计的宿舍。没有其他硬币获得国家设计，因此只有四分之一硬币具有这种额外价值。我们可以通过更改 &lt;code&gt;Quarter&lt;/code&gt; 变体以将其添加到我们的 &lt;code&gt;enum&lt;/code&gt; ，以在其中包含存储的 &lt;code&gt;UsState&lt;/code&gt; 值，如清单6-4所示。</target>
        </trans-unit>
        <trans-unit id="d430493784bb7c38b9bfd2132c640f18ef8a2cfc" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s say we want to implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which the orphan rule prevents us from doing directly because the &lt;code&gt;Display&lt;/code&gt; trait and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type are defined outside our crate. We can make a &lt;code&gt;Wrapper&lt;/code&gt; struct that holds an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;; then we can implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; and use the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; value, as shown in Listing 19-23.</source>
          <target state="translated">举个例子，假设我们要在 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 上实现 &lt;code&gt;Display&lt;/code&gt; ，孤立规则阻止了我们直接执行 &lt;code&gt;Display&lt;/code&gt; ，因为Display trait和 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 类型是在板条箱之外定义的。我们可以使 &lt;code&gt;Wrapper&lt;/code&gt; 结构体包含 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的实例；然后我们可以在 &lt;code&gt;Wrapper&lt;/code&gt; 上实现 &lt;code&gt;Display&lt;/code&gt; 并使用 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 值，如清单19-23所示。</target>
        </trans-unit>
        <trans-unit id="0a293358ddd19b42df03eeb78c691469d4c0e122" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s write a library crate that provides the functionality of a restaurant. We&amp;rsquo;ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code.</source>
          <target state="translated">例如，让我们写一个提供餐厅功能的库箱。我们将定义函数的签名，但将它们的主体留空以专注于代码的组织，而不是实际在代码中实现餐厅。</target>
        </trans-unit>
        <trans-unit id="5e1d4bdb076d3e495d340c82a90a7bc9edd4704c" translate="yes" xml:space="preserve">
          <source>As an example, rather than using a list whose items know only about the next item, we&amp;rsquo;ll create a tree whose items know about their children items &lt;em&gt;and&lt;/em&gt; their parent items.</source>
          <target state="translated">作为示例，我们将创建一个树，该树的项知道其子项&lt;em&gt;和&lt;/em&gt;父项，而不是使用其项仅知道下一项的列表。</target>
        </trans-unit>
        <trans-unit id="84057f7bc04baf2d73dfbd111ea89a20d0d17089" translate="yes" xml:space="preserve">
          <source>As an example, recall the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; marker traits we discussed in the &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo;Extensible Concurrency with the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; types. If we implement a type that contains a type that is not &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, such as raw pointers, and we want to mark that type as &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, we must use &lt;code&gt;unsafe&lt;/code&gt;. Rust can&amp;rsquo;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">例如，回想一下我们在第16章&lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo; &lt;/a&gt;具有 &lt;code&gt;Sync&lt;/code&gt; 和 &lt;code&gt;Send&lt;/code&gt; 特性的可扩展并发性&amp;rdquo;部分中讨论的 &lt;code&gt;Sync&lt;/code&gt; 和 &lt;code&gt;Send&lt;/code&gt; 标记特性，如果我们的类型完全由 &lt;code&gt;Send&lt;/code&gt; 和 &lt;code&gt;Sync&lt;/code&gt; 类型组成，则编译器会自动实现这些特性。如果我们实现的类型包含非 &lt;code&gt;Send&lt;/code&gt; 或 &lt;code&gt;Sync&lt;/code&gt; 的类型（例如原始指针），并且想要将该类型标记为 &lt;code&gt;Send&lt;/code&gt; 或 &lt;code&gt;Sync&lt;/code&gt; ，则必须使用 &lt;code&gt;unsafe&lt;/code&gt; 。 Rust无法验证我们的类型是否支持可以安全地跨线程发送或可以从多个线程访问的类型。因此，我们需要手动进行这些检查，并使用 &lt;code&gt;unsafe&lt;/code&gt; 进行指示。</target>
        </trans-unit>
        <trans-unit id="38a88a1bad47211ae1a10e5bfcee84726e1f325e" translate="yes" xml:space="preserve">
          <source>As an example, say we write a function called &lt;code&gt;add_two&lt;/code&gt; that adds 2 to whatever number is passed to it. This function&amp;rsquo;s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you&amp;rsquo;ve learned so far to ensure that, for instance, we aren&amp;rsquo;t passing a &lt;code&gt;String&lt;/code&gt; value or an invalid reference to this function. But Rust &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That&amp;rsquo;s where tests come in.</source>
          <target state="translated">例如，假设我们编写了一个名为 &lt;code&gt;add_two&lt;/code&gt; 的函数，该函数将2传递给传递给它的任何数字。该函数的签名接受一个整数作为参数，并返回一个整数作为结果。当我们实现并编译该函数时，Rust会进行到目前为止所学的所有类型检查和借位检查，以确保例如，我们不会传递 &lt;code&gt;String&lt;/code&gt; 值或对该函数的无效引用。但是Rust &lt;em&gt;无法&lt;/em&gt;检查该函数是否能够准确执行我们的预期，即返回参数加2而不是参数加10或参数减50！那就是测试的地方。</target>
        </trans-unit>
        <trans-unit id="0c46b40f3e5f774d5bd6d946904f04146f347849" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</source>
          <target state="translated">例如，模式 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 和干草堆 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 可能会产生流 &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt; 5、8 ）]</target>
        </trans-unit>
        <trans-unit id="f6b604f8510907ca9fe9178dfcf2a6874e95e6b5" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</source>
          <target state="translated">例如，模式 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 和干草堆 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 可能会产生流 &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt; 4、7 ），Reject（1、4），Reject（0、1）]</target>
        </trans-unit>
        <trans-unit id="4bbd3fe41e9f9da754b12e58c1b62e309d7fedd0" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;.</source>
          <target state="translated">例如，模式 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 和干草堆 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 可能会产生流 &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt; 4、7 ），Reject（1、4），Reject（0、1）]。</target>
        </trans-unit>
        <trans-unit id="877bff60769fbc36114e44fb0843def0fdaa302f" translate="yes" xml:space="preserve">
          <source>As an iterator:</source>
          <target state="translated">作为一个迭代器。</target>
        </trans-unit>
        <trans-unit id="04b8526b20e002ad597cb978c8868c4ab1a90f67" translate="yes" xml:space="preserve">
          <source>As another example, suppose we have a &lt;code&gt;Maker&lt;/code&gt; trait and want to establish a type &lt;code&gt;FooMaker&lt;/code&gt; that makes &lt;code&gt;Foo&lt;/code&gt;s:</source>
          <target state="translated">再举一个例子，假设我们有一个 &lt;code&gt;Maker&lt;/code&gt; 特性，并且想要建立一个使 &lt;code&gt;Foo&lt;/code&gt; 成为 &lt;code&gt;FooMaker&lt;/code&gt; 的类型：</target>
        </trans-unit>
        <trans-unit id="5213c1c4f3b10c9c56042b19c8c0157b715adba7" translate="yes" xml:space="preserve">
          <source>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a &lt;code&gt;buffer&lt;/code&gt; slice of data, an array of 12 &lt;code&gt;coefficients&lt;/code&gt;, and an amount by which to shift data in &lt;code&gt;qlp_shift&lt;/code&gt;. We&amp;rsquo;ve declared the variables within this example but not given them any values; although this code doesn&amp;rsquo;t have much meaning outside of its context, it&amp;rsquo;s still a concise, real-world example of how Rust translates high-level ideas to low-level code.</source>
          <target state="translated">作为另一个示例，以下代码取自音频解码器。解码算法使用线性预测数学运算基于先前样本的线性函数来估计未来值。此代码使用迭代器链对范围内的三个变量进行一些数学运算：数据的 &lt;code&gt;buffer&lt;/code&gt; ，12个 &lt;code&gt;coefficients&lt;/code&gt; 的数组以及将数据 &lt;code&gt;qlp_shift&lt;/code&gt; 。我们在此示例中声明了变量，但未给它们任何值；尽管这段代码在上下文之外没有多大意义，但它仍然是Rust如何将高级构想转换为低级代码的简洁，真实的示例。</target>
        </trans-unit>
        <trans-unit id="50430e10a27b5bcf53132a5539fdc175dfb8f896" translate="yes" xml:space="preserve">
          <source>As can be seen below, &lt;code&gt;else&lt;/code&gt; must be followed by either: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;if let&lt;/code&gt;, or a block &lt;code&gt;{}&lt;/code&gt; and it will return the value of that expression.</source>
          <target state="translated">如下所示， &lt;code&gt;else&lt;/code&gt; 后面必须是： &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;if let&lt;/code&gt; 或一个块 &lt;code&gt;{}&lt;/code&gt; ，它将返回该表达式的值。</target>
        </trans-unit>
        <trans-unit id="ceca2c634722fa77d0d672657c5578a7251142a0" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../i32/index&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">如上所述，&lt;a href=&quot;../i32/index&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;实现了 &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7af5c30f33f1fda6dc417defcc8e46844e2584e3" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">如前所述，&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;实现了 &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0958482afe9fd3c8317c6c0d343e311be75015c7" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&amp;rsquo;s required methods. The &lt;code&gt;Deref&lt;/code&gt; trait, provided by the standard library, requires us to implement one method named &lt;code&gt;deref&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt; and returns a reference to the inner data. Listing 15-10 contains an implementation of &lt;code&gt;Deref&lt;/code&gt; to add to the definition of &lt;code&gt;MyBox&lt;/code&gt;:</source>
          <target state="translated">如第10章所述，要实现特征，我们需要提供特征所需方法的实现。标准库提供的 &lt;code&gt;Deref&lt;/code&gt; 特征要求我们实现一种名为 &lt;code&gt;deref&lt;/code&gt; 的方法，该方法借用 &lt;code&gt;self&lt;/code&gt; 并返回对内部数据的引用。清单15-10包含 &lt;code&gt;Deref&lt;/code&gt; 的实现，以添加到 &lt;code&gt;MyBox&lt;/code&gt; 的定义中：</target>
        </trans-unit>
        <trans-unit id="d5f5ed3e00ea3332f0559aed11908528d1ba499a" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 17, the &lt;code&gt;take&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; takes the &lt;code&gt;Some&lt;/code&gt; variant out and leaves &lt;code&gt;None&lt;/code&gt; in its place. We&amp;rsquo;re using &lt;code&gt;if let&lt;/code&gt; to destructure the &lt;code&gt;Some&lt;/code&gt; and get the thread; then we call &lt;code&gt;join&lt;/code&gt; on the thread. If a worker&amp;rsquo;s thread is already &lt;code&gt;None&lt;/code&gt;, we know that worker has already had its thread cleaned up, so nothing happens in that case.</source>
          <target state="translated">如第17章所述， &lt;code&gt;Option&lt;/code&gt; 的 &lt;code&gt;take&lt;/code&gt; 方法将 &lt;code&gt;Some&lt;/code&gt; 变体取出，并将 &lt;code&gt;None&lt;/code&gt; 保留在其位置。我们正在使用 &lt;code&gt;if let&lt;/code&gt; 来分解 &lt;code&gt;Some&lt;/code&gt; 并获取线程；然后我们在线程上调用 &lt;code&gt;join&lt;/code&gt; 。如果一个工作线程的线程已经是 &lt;code&gt;None&lt;/code&gt; ，我们知道该工作线程的线程已经清理完毕，那么在这种情况下什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="9fd5d9a215556134ab45028a161d57190ff678d3" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 6, we use patterns in the arms of &lt;code&gt;match&lt;/code&gt; expressions. Formally, &lt;code&gt;match&lt;/code&gt; expressions are defined as the keyword &lt;code&gt;match&lt;/code&gt;, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&amp;rsquo;s pattern, like this:</source>
          <target state="translated">如第6章所述，我们在 &lt;code&gt;match&lt;/code&gt; 表达式中使用模式。形式上， &lt;code&gt;match&lt;/code&gt; 表达式定义为关键字 &lt;code&gt;match&lt;/code&gt; ，一个要匹配的值以及一个或多个match臂，其中包括一个模式和一个表达式，如果该值与该arm的模式相匹配，则运行该表达式，如下所示：</target>
        </trans-unit>
        <trans-unit id="b597a68d9b285f7d308e42a0c9a8b37ad1bf7193" translate="yes" xml:space="preserve">
          <source>As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:</source>
          <target state="translated">至于幕后发生的事情,当启用优化后,最终生成的机器代码可能会与代码大相径庭。</target>
        </trans-unit>
        <trans-unit id="e7061cd66862cc7d4e84cb20891d413f4dbad19d" translate="yes" xml:space="preserve">
          <source>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</source>
          <target state="translated">作为函数,它们必须要么返回语法,要么恐慌,要么无休止地循环。返回的语法根据程序宏的种类,要么替换语法,要么添加语法。恐慌会被编译器捕获,并变成一个编译器错误。无休止的循环不会被编译器捕获,会挂起编译器。</target>
        </trans-unit>
        <trans-unit id="fd8f9685a0be8d16b4d260e66976648f0f435f12" translate="yes" xml:space="preserve">
          <source>As humans, we can look at this code and see that &lt;code&gt;string1&lt;/code&gt; is longer than &lt;code&gt;string2&lt;/code&gt; and therefore &lt;code&gt;result&lt;/code&gt; will contain a reference to &lt;code&gt;string1&lt;/code&gt;. Because &lt;code&gt;string1&lt;/code&gt; has not gone out of scope yet, a reference to &lt;code&gt;string1&lt;/code&gt; will still be valid for the &lt;code&gt;println!&lt;/code&gt; statement. However, the compiler can&amp;rsquo;t see that the reference is valid in this case. We&amp;rsquo;ve told Rust that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</source>
          <target state="translated">作为人类，我们可以看一下这段代码，看到 &lt;code&gt;string1&lt;/code&gt; 比 &lt;code&gt;string2&lt;/code&gt; 长，因此 &lt;code&gt;result&lt;/code&gt; 将包含对 &lt;code&gt;string1&lt;/code&gt; 的引用。由于 &lt;code&gt;string1&lt;/code&gt; 尚未超出范围，因此对 &lt;code&gt;string1&lt;/code&gt; 的引用对于 &lt;code&gt;println!&lt;/code&gt; 仍然有效！声明。但是，在这种情况下，编译器看不到引用有效。我们已经告诉Rust， &lt;code&gt;longest&lt;/code&gt; 函数返回的引用的生存期与传入的引用的生存期中的较小者相同。因此，借位检查器不允许清单10-24中的代码可能包含无效的引用。</target>
        </trans-unit>
        <trans-unit id="6d9f4910be4026effcf198634df42e1c4041dff1" translate="yes" xml:space="preserve">
          <source>As in most other programming languages, a Boolean type in Rust has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Booleans are one byte in size. The Boolean type in Rust is specified using &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">与大多数其他编程语言一样，Rust中的布尔类型具有两个可能的值： &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。布尔值的大小为1个字节。Rust中的布尔类型使用 &lt;code&gt;bool&lt;/code&gt; 指定。例如：</target>
        </trans-unit>
        <trans-unit id="45c7aa166fa09685143658300364b92158ea06fe" translate="yes" xml:space="preserve">
          <source>As is the case in &lt;a href=&quot;if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt; expressions&lt;/a&gt;, the scrutinee cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;.</source>
          <target state="translated">就像&lt;a href=&quot;if-expr#if-let-expressions&quot;&gt; &lt;code&gt;if let&lt;/code&gt; 表达式一样&lt;/a&gt;，scrutinee不能是&lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;惰性布尔运算符表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="118d39ec67253c2f49ef6f0a1ef21526ef7b61b3" translate="yes" xml:space="preserve">
          <source>As it turns out, though, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">事实证明，虽然多数性状可以有一个 &lt;code&gt;impl&lt;/code&gt; 的 &lt;code&gt;!&lt;/code&gt; 。以&lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;为例：</target>
        </trans-unit>
        <trans-unit id="a025b290deb94845050bfa62909fd15fe5ae74be" translate="yes" xml:space="preserve">
          <source>As long as your command line parsing logic is small, it can remain in &lt;em&gt;main.rs&lt;/em&gt;.</source>
          <target state="translated">只要您的命令行解析逻辑很小，它就可以保留在&lt;em&gt;main.rs中&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8323a3696731d93f0a84dafc08f2d32df5ef0903" translate="yes" xml:space="preserve">
          <source>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: &lt;em&gt;unit tests&lt;/em&gt; and &lt;em&gt;integration tests&lt;/em&gt;. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</source>
          <target state="translated">如本章开头所述，测试是一门复杂的学科，不同的人使用不同的术语和组织。 Rust社区从两个主要类别来考虑测试：&lt;em&gt;单元测试&lt;/em&gt;和&lt;em&gt;集成测试&lt;/em&gt;。单元测试规模较小，而且更具针对性，可以一次单独测试一个模块，并且可以测试专用接口。集成测试完全在您的库外部，并且以与其他任何外部代码相同的方式使用您的代码，仅使用公共接口，并且每个测试可能使用多个模块。</target>
        </trans-unit>
        <trans-unit id="10eda87545057c2aa683c0bbfe8990122953ece6" translate="yes" xml:space="preserve">
          <source>As mentioned before, trait objects contain pointers to method tables. So, if we have:</source>
          <target state="translated">如前所述,trait对象包含指向方法表的指针。所以,如果我们有:</target>
        </trans-unit>
        <trans-unit id="4761017ad6dee318134842b138bc05d35199a594" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;read_line&lt;/code&gt; puts what the user types into the string we&amp;rsquo;re passing it, but it also returns a value&amp;mdash;in this case, an &lt;a href=&quot;../std/io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. Rust has a number of types named &lt;code&gt;Result&lt;/code&gt; in its standard library: a generic &lt;a href=&quot;../std/result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; as well as specific versions for submodules, such as &lt;code&gt;io::Result&lt;/code&gt;.</source>
          <target state="translated">如前所述， &lt;code&gt;read_line&lt;/code&gt; 将用户键入的内容放入我们要传递的字符串中，但它还会返回一个值，在这种情况下为&lt;a href=&quot;../std/io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;。Rust 在其标准库中具有许多名为 &lt;code&gt;Result&lt;/code&gt; 的类型：通用&lt;a href=&quot;../std/result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;以及子模块的特定版本，例如 &lt;code&gt;io::Result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f7435a393907a8b1c4a2fc1b69a43772076a5c5" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</source>
          <target state="translated">如前所述,由于Rust处理并发的方式很少是语言的一部分,所以很多并发解决方案都是以crate的形式实现的。这些方案比标准库发展得更快,所以一定要在网上搜索当前最先进的crates,以便在多线程情况下使用。</target>
        </trans-unit>
        <trans-unit id="a6f8e14141b394aeafb54cb0af5563e56c04e70c" translate="yes" xml:space="preserve">
          <source>As mentioned in Chapter 2, by default variables are immutable. This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you still have the option to make your variables mutable. Let&amp;rsquo;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</source>
          <target state="translated">如第2章所述，默认情况下变量是不可变的。这是Rust推动您编写代码的一种方式，它利用了Rust提供的安全性和易并发性。但是，您仍然可以选择使变量可变。让我们探讨一下Rust如何以及为什么鼓励您支持不变性，以及为什么有时您可能想要退出。</target>
        </trans-unit>
        <trans-unit id="7641c8a38df92f9203220e805ba01b7f30732a0c" translate="yes" xml:space="preserve">
          <source>As mentioned in the module documentation, threads are usually made to communicate using &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt;, here is how it usually looks.</source>
          <target state="translated">如模块文档中所述，线程通常是使用&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt;进行通信的，这就是它通常的外观。</target>
        </trans-unit>
        <trans-unit id="fad7d9a9d62e3d2756844c471849a76502954355" translate="yes" xml:space="preserve">
          <source>As non-Rust calling conventions do not support unwinding, unwinding past the end of an extern function will cause the process to abort. In LLVM, this is implemented by executing an illegal instruction.</source>
          <target state="translated">由于非 Rust 调用惯例不支持展开,在外部函数结束后展开会导致进程中止。在LLVM中,这是通过执行一条非法指令来实现的。</target>
        </trans-unit>
        <trans-unit id="10482a83c62e485259adbe51b49060ecef064cde" translate="yes" xml:space="preserve">
          <source>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using &lt;strong&gt;transmute&lt;/strong&gt; to convert a fn item into a fn pointer.</source>
          <target state="translated">如上所述，强制意味着大多数代码不必关心这种区别。但是，您可以分辨出使用&lt;strong&gt;transmute&lt;/strong&gt;将fn项转换为fn指针时的区别。</target>
        </trans-unit>
        <trans-unit id="a5cb1839eab079676f60d9f52ac6387e18acb792" translate="yes" xml:space="preserve">
          <source>As noted in the documentation for the type itself, it is essentially an opaque ID, but is guaranteed to be unique for each thread. The returned value is entirely opaque -- only equality testing is stable. Note that it is not guaranteed which values new threads will return, and this may change across Rust versions.</source>
          <target state="translated">正如该类型本身的文档中所指出的,它本质上是一个不透明的ID,但保证每个线程都是唯一的。返回的值是完全不透明的--只有平等测试是稳定的。请注意,不能保证新线程会返回哪些值,这可能会在不同的Rust版本中发生变化。</target>
        </trans-unit>
        <trans-unit id="f7018b1edbbce45316477bb25e1ffd907f9a0adb" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; for their container to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">正如人们所期望的那样，诸如&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; 之&lt;/a&gt;类的基本类型都是&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;，包含它们的简单聚合类型也是如此，例如元组，结构和枚举。基本&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;类型的更多示例包括 &lt;code&gt;&amp;amp;T&lt;/code&gt; 之类的&amp;ldquo;不可变&amp;rdquo;类型，以及具有简单继承的可变性的那些类型，例如&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;和大多数其他集合类型。（通用参数需要&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;，容器才能&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="78cffef75c7264e29f3831c1d70df7b7db90b085" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;code&gt;Sync&lt;/code&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;code&gt;Sync&lt;/code&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;code&gt;Sync&lt;/code&gt; for their container to be &lt;code&gt;Sync&lt;/code&gt;.)</source>
          <target state="translated">正如人们所期望的那样，诸如&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; 之&lt;/a&gt;类的基本类型都是 &lt;code&gt;Sync&lt;/code&gt; ，包含它们的简单聚合类型也是如此，例如元组，结构和枚举。基本 &lt;code&gt;Sync&lt;/code&gt; 类型的更多示例包括 &lt;code&gt;&amp;amp;T&lt;/code&gt; 之类的&amp;ldquo;不可变&amp;rdquo;类型，以及具有简单继承的可变性的那些类型，例如&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;和大多数其他集合类型。（通用参数需要 &lt;code&gt;Sync&lt;/code&gt; ，容器才能 &lt;code&gt;Sync&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="e3262fa97dd64c6174eeff7f6dc1bf92e0938ab9" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;, the whole &lt;code&gt;FEC0::/10&lt;/code&gt; prefix is deprecated. New software must not support site-local addresses.</source>
          <target state="translated">根据&lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;，整个 &lt;code&gt;FEC0::/10&lt;/code&gt; 前缀已弃用。新软件不得支持站点本地地址。</target>
        </trans-unit>
        <trans-unit id="a8a04accdf6a8ca9fa81bf61cc029868f206046f" translate="yes" xml:space="preserve">
          <source>As said above, the &lt;code&gt;derive&lt;/code&gt; attribute is only allowed on structs, unions or enums:</source>
          <target state="translated">如上所述， &lt;code&gt;derive&lt;/code&gt; d属性仅在结构，联合或枚举上被允许：</target>
        </trans-unit>
        <trans-unit id="51aa8d67495f62b66ef894735fcf63e6606dac28" translate="yes" xml:space="preserve">
          <source>As shown in the example above, &lt;code&gt;for&lt;/code&gt; loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the same tag to &lt;code&gt;break&lt;/code&gt; breaks the tagged loop, which is useful for inner loops. It is definitely not a goto.</source>
          <target state="translated">如上例所示，可以使用与生命周期相似的语法（仅在视觉上相似，实际上完全不同）来标记 &lt;code&gt;for&lt;/code&gt; 循环（以及所有其他循环）。赋予相同的标记以 &lt;code&gt;break&lt;/code&gt; 标记循环，这对于内部循环很有用。绝对不是goto。</target>
        </trans-unit>
        <trans-unit id="ea3901788f56444df8cfba46d8496b7c3ef215ae" translate="yes" xml:space="preserve">
          <source>As slices store the length of the sequence they refer to, they have twice the size of pointers to &lt;a href=&quot;marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; types. Also see the reference on &lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;.</source>
          <target state="translated">当切片存储它们所引用的序列的长度时，它们的大小是指向&lt;a href=&quot;marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;类型的指针的两倍。另请参见有关&lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;动态大小类型&lt;/a&gt;的参考。</target>
        </trans-unit>
        <trans-unit id="c276f971f322ddf36b0d0a39caeff0e860e6ee88" translate="yes" xml:space="preserve">
          <source>As stated in the User Datagram Protocol's specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;, UDP is an unordered, unreliable protocol; refer to &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; for TCP primitives.</source>
          <target state="translated">如&lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;中的&amp;ldquo;用户数据报协议&amp;rdquo;规范中所述，UDP是无序，不可靠的协议。有关TCP原语，请参阅&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5379cc453111a9586b0e6132f3432e2017bb8946" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">由于字符串片是字节的片，原始指针指向&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;。该指针将指向字符串切片的第一个字节。</target>
        </trans-unit>
        <trans-unit id="54d4fd727ce2657161522c6ae3a06633673c9cbd" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">由于字符串片是字节的片，原始指针指向&lt;a href=&quot;primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;。该指针将指向字符串切片的第一个字节。</target>
        </trans-unit>
        <trans-unit id="b757bf93c530db10fdab40d9aeca4c3f17d50ad1" translate="yes" xml:space="preserve">
          <source>As such, the &lt;code&gt;from_utf8&lt;/code&gt; family of functions and methods for both &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;fn.from_utf8&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s make use of this error, for example.</source>
          <target state="translated">这样，例如&lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.from_utf8&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;from_utf8&lt;/code&gt; 函数和方法家族都使用此错误。</target>
        </trans-unit>
        <trans-unit id="a7bae3aa148344b33c64086da16dba6a42474602" translate="yes" xml:space="preserve">
          <source>As the author of a data structure you get to decide for each field whether pinning &quot;propagates&quot; to this field or not. Pinning that propagates is also called &quot;structural&quot;, because it follows the structure of the type. In the following subsections, we describe the considerations that have to be made for either choice.</source>
          <target state="translated">作为一个数据结构的作者,你可以决定每个字段的钉入是否会 &quot;传播 &quot;到这个字段。传播的引脚也被称为 &quot;结构性&quot;,因为它遵循类型的结构。在下面的小节中,我们将描述对这两种选择的考虑。</target>
        </trans-unit>
        <trans-unit id="0b86e5cf0a558c007bb8a3eed83a07619a169108" translate="yes" xml:space="preserve">
          <source>As the error message indicates, only &lt;code&gt;u8&lt;/code&gt; can be cast into &lt;code&gt;char&lt;/code&gt;. Example:</source>
          <target state="translated">如错误消息所示，只能将 &lt;code&gt;u8&lt;/code&gt; 强制转换为 &lt;code&gt;char&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="6c037f01ab1e44c1b49068f96530e00f210988e8" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code likely wants to use &lt;a href=&quot;#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.from_le_bytes&quot;&gt;&lt;code&gt;from_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate instead.</source>
          <target state="translated">由于使用了目标平台的本机字节序，因此可移植代码可能希望适当地使用&lt;a href=&quot;#method.from_be_bytes&quot;&gt; &lt;code&gt;from_be_bytes&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.from_le_bytes&quot;&gt; &lt;code&gt;from_le_bytes&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c8bfefec8dafcbb055c2ea433ad31a56feecccd" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code should use &lt;a href=&quot;#method.to_be_bytes&quot;&gt;&lt;code&gt;to_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.to_le_bytes&quot;&gt;&lt;code&gt;to_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate, instead.</source>
          <target state="translated">由于使用了目标平台的本机字节序，因此可移植代码应&lt;a href=&quot;#method.to_be_bytes&quot;&gt; &lt;code&gt;to_be_bytes&lt;/code&gt; &lt;/a&gt;使用to_be_bytes或&lt;a href=&quot;#method.to_le_bytes&quot;&gt; &lt;code&gt;to_le_bytes&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2aae14d23e6b4a7f032b38d8e95a4d1b336b019" translate="yes" xml:space="preserve">
          <source>As this is the only method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">由于这是该特征的唯一方法，因此&lt;a href=&quot;trait.extend&quot;&gt;特征级别的&lt;/a&gt;文档包含更多详细信息。</target>
        </trans-unit>
        <trans-unit id="3b3bf99d81b548977e24e38bef4df0cf86423b5b" translate="yes" xml:space="preserve">
          <source>As this is the only required method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">由于这是此特征唯一需要的方法，因此&lt;a href=&quot;trait.extend&quot;&gt;特征级别的&lt;/a&gt;文档包含更多详细信息。</target>
        </trans-unit>
        <trans-unit id="f292830332806677ad0b0527bf74ceadc350e53c" translate="yes" xml:space="preserve">
          <source>As usual, this output tells us exactly what has gone wrong.</source>
          <target state="translated">像往常一样,这个输出告诉我们到底出了什么问题。</target>
        </trans-unit>
        <trans-unit id="6d6b5c58bde3c21428520a679924eb54e0901d4d" translate="yes" xml:space="preserve">
          <source>As we did with structs, we can define enums to hold generic data types in their variants. Let&amp;rsquo;s take another look at the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum that the standard library provides, which we used in Chapter 6:</source>
          <target state="translated">正如我们对结构所做的那样，我们可以定义枚举以将通用数据类型保存在它们的变量中。让我们再看看标准库提供的 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 枚举，我们在第6章中使用过：</target>
        </trans-unit>
        <trans-unit id="c9b62e53d822366f9040eaf9632aa096cd8d407c" translate="yes" xml:space="preserve">
          <source>As we saw when we printed the vector, the program&amp;rsquo;s name takes up the first value in the vector at &lt;code&gt;args[0]&lt;/code&gt;, so we&amp;rsquo;re starting at index &lt;code&gt;1&lt;/code&gt;. The first argument &lt;code&gt;minigrep&lt;/code&gt; takes is the string we&amp;rsquo;re searching for, so we put a reference to the first argument in the variable &lt;code&gt;query&lt;/code&gt;. The second argument will be the filename, so we put a reference to the second argument in the variable &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">正如我们看到的那样，在打印矢量时，程序的名称占据了矢量中的第一个值 &lt;code&gt;args[0]&lt;/code&gt; ，因此我们从索引 &lt;code&gt;1&lt;/code&gt; 开始。 &lt;code&gt;minigrep&lt;/code&gt; 的第一个参数是我们要搜索的字符串，因此我们在变量 &lt;code&gt;query&lt;/code&gt; 中放置了对第一个参数的引用。第二个参数是文件名，因此我们在变量 &lt;code&gt;filename&lt;/code&gt; 中引用了第二个参数。</target>
        </trans-unit>
        <trans-unit id="387526bcd86a3d932ce8d276666fe3de9ea36fb2" translate="yes" xml:space="preserve">
          <source>As well as overloading the unary &lt;code&gt;*&lt;/code&gt; operator, &lt;a href=&quot;../std/ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; are also used in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">除了重载一元 &lt;code&gt;*&lt;/code&gt; 运算符外，&lt;a href=&quot;../std/ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;还用于&lt;a href=&quot;expressions/method-call-expr&quot;&gt;方法解析&lt;/a&gt;和&lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref强制中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00f0078e7027bdd5fb06a3cdb9f947f1a54e08c1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;, this is unsafe because it cannot verify the validity of the returned pointer, nor can it ensure that the lifetime &lt;code&gt;'a&lt;/code&gt; returned is indeed a valid lifetime for the contained data.</source>
          <target state="translated">与&lt;a href=&quot;#method.as_ref&quot;&gt; &lt;code&gt;as_ref&lt;/code&gt; &lt;/a&gt;，这是不安全的，因为它无法验证返回的指针的有效性，也不能保证一生 &lt;code&gt;'a&lt;/code&gt; 回确实是所包含的数据的有效寿命。</target>
        </trans-unit>
        <trans-unit id="700b249dcaa7ad65d8fbe7b2f99bd14fed03c63b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">与&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt;，由调用方负责确保内部值确实处于初始化状态。在内容尚未完全初始化时调用此方法会立即导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="b569f01826b7a489e1b0df46d3df2feea0987b31" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">与&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt;，由调用方负责确保该值确实处于初始化状态。在内容尚未完全初始化时调用此方法会立即导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="b5a160954fc2e5db9027a60b41aea2242946a496" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the values really are in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">与&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt;，由调用方负责确保值确实处于初始化状态。在内容尚未完全初始化时调用此方法会立即导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="e824f1a2f05ba862631703f190681d4c2dd2b70b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;underscore imports&lt;/a&gt;, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</source>
          <target state="translated">与&lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;下划线导入一样&lt;/a&gt;，宏可以安全地在相同范围内多次发出相同的未命名常量。例如，以下内容不应产生错误：</target>
        </trans-unit>
        <trans-unit id="4c083e9f314596dd1da24d21de9af221cdf99253" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;let&lt;/code&gt; bindings, function arguments are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, so any pattern that is valid in a let binding is also valid as an argument:</source>
          <target state="translated">与 &lt;code&gt;let&lt;/code&gt; 绑定一样，函数参数是不可辩驳的&lt;a href=&quot;../patterns&quot;&gt;模式&lt;/a&gt;，因此在let绑定中有效的任何模式也可用作参数：</target>
        </trans-unit>
        <trans-unit id="021860f0b9c701b01e24f471ef9064ff787c7fc6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;split()&lt;/code&gt;, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</source>
          <target state="translated">与 &lt;code&gt;split()&lt;/code&gt; 一样，如果第一个或最后一个元素匹配，则空切片将是迭代器返回的第一个（或最后一个）项目。</target>
        </trans-unit>
        <trans-unit id="a311c5a68716dfa8ec04c201fd72e1f6bf20977d" translate="yes" xml:space="preserve">
          <source>As with any variable, if we want to be able to change its value, we need to make it mutable using the &lt;code&gt;mut&lt;/code&gt; keyword, as discussed in Chapter 3. The numbers we place inside are all of type &lt;code&gt;i32&lt;/code&gt;, and Rust infers this from the data, so we don&amp;rsquo;t need the &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; annotation.</source>
          <target state="translated">与任何变量一样，如果我们希望能够更改其值，则需要使用 &lt;code&gt;mut&lt;/code&gt; 关键字使其可变，如第3章中所述。我们放入其中的数字均为 &lt;code&gt;i32&lt;/code&gt; 类型，Rust从数据，因此我们不需要 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 批注。</target>
        </trans-unit>
        <trans-unit id="4275e8a23f25e311b7879f2ca06bcf06be2ae3c3" translate="yes" xml:space="preserve">
          <source>As with many types, we create a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; using the associated function &lt;code&gt;new&lt;/code&gt;. To access the data inside the mutex, we use the &lt;code&gt;lock&lt;/code&gt; method to acquire the lock. This call will block the current thread so it can&amp;rsquo;t do any work until it&amp;rsquo;s our turn to have the lock.</source>
          <target state="translated">与许多类型一样，我们使用关联的函数 &lt;code&gt;new&lt;/code&gt; 创建 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 。要访问互斥锁内的数据，我们使用 &lt;code&gt;lock&lt;/code&gt; 方法来获取锁。该调用将阻塞当前线程，因此在轮到我们锁定之前，它无法进行任何工作。</target>
        </trans-unit>
        <trans-unit id="35a5907e5dda02884b0d94275e42a50fca56e187" translate="yes" xml:space="preserve">
          <source>As with regular variables, we specify mutability using the &lt;code&gt;mut&lt;/code&gt; keyword. Any code that reads or writes from &lt;code&gt;COUNTER&lt;/code&gt; must be within an &lt;code&gt;unsafe&lt;/code&gt; block. This code compiles and prints &lt;code&gt;COUNTER: 3&lt;/code&gt; as we would expect because it&amp;rsquo;s single threaded. Having multiple threads access &lt;code&gt;COUNTER&lt;/code&gt; would likely result in data races.</source>
          <target state="translated">与常规变量一样，我们使用 &lt;code&gt;mut&lt;/code&gt; 关键字指定可变性。从 &lt;code&gt;COUNTER&lt;/code&gt; 读取或写入的任何代码都必须位于 &lt;code&gt;unsafe&lt;/code&gt; 块内。这段代码像我们期望的那样编译并输出 &lt;code&gt;COUNTER: 3&lt;/code&gt; ，因为它是单线程的。具有多个线程访问 &lt;code&gt;COUNTER&lt;/code&gt; 可能会导致数据争用。</target>
        </trans-unit>
        <trans-unit id="d8272d2e249bc06a5d6f6ca737f5c0ac8a4d70c5" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">与&lt;a href=&quot;../hash_map/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;类型一样， &lt;code&gt;HashSet&lt;/code&gt; 要求元素实现&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特征。这通常可以通过使用 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 。如果您自己实现这些，那么拥有以下属性非常重要：</target>
        </trans-unit>
        <trans-unit id="3db9d1e08dae612689e0b7adf381cac76d2a83bc" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">与&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;类型一样， &lt;code&gt;HashSet&lt;/code&gt; 要求元素实现&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特征。这通常可以通过使用 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 。如果您自己实现这些，那么拥有以下属性非常重要：</target>
        </trans-unit>
        <trans-unit id="484bca70aea1a557734e7bf929079e6ee00fa7d3" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">与&lt;a href=&quot;hash_map/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;类型一样， &lt;code&gt;HashSet&lt;/code&gt; 要求元素实现&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特征。这通常可以通过使用 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 。如果您自己实现这些，那么拥有以下属性非常重要：</target>
        </trans-unit>
        <trans-unit id="1fb7b19ef9483e218deb8b0d1a3f5269874b86ed" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">与&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;类型一样， &lt;code&gt;HashSet&lt;/code&gt; 要求元素实现&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特征。通常可以使用 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 。如果您自己实现这些，那么拥有以下属性非常重要：</target>
        </trans-unit>
        <trans-unit id="c568bda8aab01e836f5470185110a68fb4739aa1" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">与&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;类型一样， &lt;code&gt;HashSet&lt;/code&gt; 要求元素实现&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特征。通常可以使用 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 。如果您自己实现这些，那么拥有以下属性非常重要：</target>
        </trans-unit>
        <trans-unit id="ae28ea4c57639b6218be246b12eabdfb50b7b74a" translate="yes" xml:space="preserve">
          <source>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</source>
          <target state="translated">与变量一样,如果我们想增加明确性和清晰度,我们可以添加类型注释,但代价是要比严格意义上的必要更冗长。对我们在清单 13-5 中定义的闭包的类型进行注解,就像清单 13-7 中所示的定义一样。</target>
        </trans-unit>
        <trans-unit id="96c2069203f702eae6427926792a296cebb74618" translate="yes" xml:space="preserve">
          <source>As you add more integration tests, you might want to make more than one file in the &lt;em&gt;tests&lt;/em&gt; directory to help organize them; for example, you can group the test functions by the functionality they&amp;rsquo;re testing. As mentioned earlier, each file in the &lt;em&gt;tests&lt;/em&gt; directory is compiled as its own separate crate.</source>
          <target state="translated">当您添加更多集成测试时，您可能希望在&lt;em&gt;tests&lt;/em&gt;目录中制作多个文件来帮助组织它们。例如，您可以按照测试功能对测试功能进行分组。如前所述，&lt;em&gt;tests&lt;/em&gt;目录中的每个文件都被编译为自己的单独板条箱。</target>
        </trans-unit>
        <trans-unit id="064638b9138d50bf7a76d4f1fb8907e6d00d4af4" translate="yes" xml:space="preserve">
          <source>As you also learned in Chapter 1, &lt;code&gt;println!&lt;/code&gt; is a macro that prints a string to the screen:</source>
          <target state="translated">正如您在第1章中了解到的那样， &lt;code&gt;println!&lt;/code&gt; 是在屏幕上打印字符串的宏：</target>
        </trans-unit>
        <trans-unit id="cfbf1a7efc3caed67bc7e41bd453d7589ffb22d8" translate="yes" xml:space="preserve">
          <source>As you can see in the signature of &lt;code&gt;spawn&lt;/code&gt; there are two constraints on both the closure given to &lt;code&gt;spawn&lt;/code&gt; and its return value, let's explain them:</source>
          <target state="translated">正如你在签名见 &lt;code&gt;spawn&lt;/code&gt; 有给在闭合两个两个约束 &lt;code&gt;spawn&lt;/code&gt; 和它的返回值，让我们解释他们：</target>
        </trans-unit>
        <trans-unit id="0420fe0c9530d1e1d147961f14b139b3fe83e9e2" translate="yes" xml:space="preserve">
          <source>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use &lt;code&gt;rustup override&lt;/code&gt; in that project&amp;rsquo;s directory to set the nightly toolchain as the one &lt;code&gt;rustup&lt;/code&gt; should use when you&amp;rsquo;re in that directory:</source>
          <target state="translated">如您所见，稳定的工具链是默认的。大多数Rust用户大部分时间都稳定使用。您可能希望在大多数时间使用稳定的功能，但每晚都在特定项目上使用，因为您关心的是尖端功能。为此，您可以在该项目的目录中使用 &lt;code&gt;rustup override&lt;/code&gt; 将夜间工具链设置为该目录中应使用的一个 &lt;code&gt;rustup&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9d87736b18e618ced4be36c042766a61a7024b14" translate="yes" xml:space="preserve">
          <source>As you can see, this will return the expected, valid items.</source>
          <target state="translated">如你所见,这将返回预期的有效项目。</target>
        </trans-unit>
        <trans-unit id="2afcd0df9449bfb1b32a67c779124a1b65363260" translate="yes" xml:space="preserve">
          <source>As you can see, using the parent modules distinguishes the two &lt;code&gt;Result&lt;/code&gt; types. If instead we specified &lt;code&gt;use std::fmt::Result&lt;/code&gt; and &lt;code&gt;use std::io::Result&lt;/code&gt;, we&amp;rsquo;d have two &lt;code&gt;Result&lt;/code&gt; types in the same scope and Rust wouldn&amp;rsquo;t know which one we meant when we used &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">如您所见，使用父模块可以区分两种 &lt;code&gt;Result&lt;/code&gt; 类型。如果相反，我们指定 &lt;code&gt;use std::fmt::Result&lt;/code&gt; 并 &lt;code&gt;use std::io::Result&lt;/code&gt; ，那么我们将在同一范围内拥有两种 &lt;code&gt;Result&lt;/code&gt; 类型，而Rust在使用 &lt;code&gt;Result&lt;/code&gt; 时将不知道是什么意思。</target>
        </trans-unit>
        <trans-unit id="20722bacbfbb971e3e58847f05a0049adb3a009e" translate="yes" xml:space="preserve">
          <source>As you can see, we&amp;rsquo;ve moved everything into a loop from the guess input prompt onward. Be sure to indent the lines inside the loop another four spaces each and run the program again. Notice that there is a new problem because the program is doing exactly what we told it to do: ask for another guess forever! It doesn&amp;rsquo;t seem like the user can quit!</source>
          <target state="translated">如您所见，我们已将所有内容从猜测输入提示向​​前移动到一个循环中。确保将循环内的行缩进另外四个空格，然后再次运行程序。请注意，这是一个新问题，因为程序正在完全按照我们的要求执行操作：永远要求另一个猜测！用户似乎无法退出！</target>
        </trans-unit>
        <trans-unit id="ac1ee84193bb1d8e87992969494a2311a45eebb9" translate="yes" xml:space="preserve">
          <source>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, &lt;code&gt;{Self}&lt;/code&gt; will substitute to the type (in this case, &lt;code&gt;bool&lt;/code&gt;) that we tried to use.</source>
          <target state="translated">如您所见，可以在大括号中指定类型参数，以在给定情况下用实际类型替换（使用常规格式字符串语法）。此外， &lt;code&gt;{Self}&lt;/code&gt; 将替代我们尝试使用的类型（在这种情况下为 &lt;code&gt;bool&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b2e9ae4479b0983efbf6a5f5ed8ba7b27ba6777d" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">正如你所看到的,在许多方面(除了布局、安全和所有权),联合体的行为与结构体一模一样,这主要是继承了结构体的语法形状的结果。Rust语言的许多未提及的方面也是如此(如隐私、名称解析、类型推理、泛型、特质实现、固有实现、连贯性、模式检查等等等等)。</target>
        </trans-unit>
        <trans-unit id="82fa816a0b7088673d7a49e7db89040e62362916" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety, and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">正如你所看到的,在许多方面(除了布局、安全和所有权),联合体的行为与结构体一模一样,这主要是继承了结构体的语法形状的结果。Rust语言的许多未提及的方面也是如此(如隐私、名称解析、类型推理、泛型、特质实现、固有实现、连贯性、模式检查等等等等)。</target>
        </trans-unit>
        <trans-unit id="b701fb6519447ef85d48d0e79a042ed086034a11" translate="yes" xml:space="preserve">
          <source>As you learned in Chapter 16, &lt;code&gt;thread::spawn&lt;/code&gt; will create a new thread and then run the code in the closure in the new thread. If you run this code and load &lt;em&gt;/sleep&lt;/em&gt; in your browser, then &lt;em&gt;/&lt;/em&gt; in two more browser tabs, you&amp;rsquo;ll indeed see that the requests to &lt;em&gt;/&lt;/em&gt; don&amp;rsquo;t have to wait for &lt;em&gt;/sleep&lt;/em&gt; to finish. But as we mentioned, this will eventually overwhelm the system because you&amp;rsquo;d be making new threads without any limit.</source>
          <target state="translated">正如您在第16章中了解到的那样， &lt;code&gt;thread::spawn&lt;/code&gt; 将创建一个新线程，然后在新线程的闭包中运行代码。如果你运行这段代码和负载&lt;em&gt;/睡&lt;/em&gt;在你的浏览器，那么&lt;em&gt;/&lt;/em&gt;在两个浏览器标签，你会看到确实的请求&lt;em&gt;/&lt;/em&gt;不必等待&lt;em&gt;/睡眠&lt;/em&gt;来完成。但是正如我们提到的那样，这最终将使系统不堪重负，因为您将无限制地创建新线程。</target>
        </trans-unit>
        <trans-unit id="f4d2e2ae7d1d7339cbe38cf89981448ff9804651" translate="yes" xml:space="preserve">
          <source>As you might have guessed, &lt;code&gt;continue&lt;/code&gt; has a &lt;code&gt;!&lt;/code&gt; value. That is, when Rust computes the type of &lt;code&gt;guess&lt;/code&gt;, it looks at both match arms, the former with a value of &lt;code&gt;u32&lt;/code&gt; and the latter with a &lt;code&gt;!&lt;/code&gt; value. Because &lt;code&gt;!&lt;/code&gt; can never have a value, Rust decides that the type of &lt;code&gt;guess&lt;/code&gt; is &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">您可能已经猜到了， &lt;code&gt;continue&lt;/code&gt; 有一个 &lt;code&gt;!&lt;/code&gt; 值。也就是说，当Rust计算 &lt;code&gt;guess&lt;/code&gt; 类型时，它会同时查看两个匹配项，前者的值为 &lt;code&gt;u32&lt;/code&gt; ，后者的值为 &lt;code&gt;!&lt;/code&gt; 。值。因为 &lt;code&gt;!&lt;/code&gt; 永远不会有值，Rust决定 &lt;code&gt;guess&lt;/code&gt; 的类型为 &lt;code&gt;u32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="467cfe4dd8e4d010791398ae5c6bd0fbee6d53ca" translate="yes" xml:space="preserve">
          <source>As you might suspect, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is a smart pointer. More accurately, the call to &lt;code&gt;lock&lt;/code&gt;&lt;em&gt;returns&lt;/em&gt; a smart pointer called &lt;code&gt;MutexGuard&lt;/code&gt;, wrapped in a &lt;code&gt;LockResult&lt;/code&gt; that we handled with the call to &lt;code&gt;unwrap&lt;/code&gt;. The &lt;code&gt;MutexGuard&lt;/code&gt; smart pointer implements &lt;code&gt;Deref&lt;/code&gt; to point at our inner data; the smart pointer also has a &lt;code&gt;Drop&lt;/code&gt; implementation that releases the lock automatically when a &lt;code&gt;MutexGuard&lt;/code&gt; goes out of scope, which happens at the end of the inner scope in Listing 16-12. As a result, we don&amp;rsquo;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</source>
          <target state="translated">您可能会怀疑， &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 是一个智能指针。更准确地说，调用 &lt;code&gt;lock&lt;/code&gt; &lt;em&gt;返回&lt;/em&gt;一个智能指针称为 &lt;code&gt;MutexGuard&lt;/code&gt; ，包裹在一个 &lt;code&gt;LockResult&lt;/code&gt; 我们与呼叫处理 &lt;code&gt;unwrap&lt;/code&gt; 。该 &lt;code&gt;MutexGuard&lt;/code&gt; 智能指针工具 &lt;code&gt;Deref&lt;/code&gt; 在我们内心的数据点; 智能指针还具有 &lt;code&gt;Drop&lt;/code&gt; 实现，当 &lt;code&gt;MutexGuard&lt;/code&gt; 出现时，该实现会自动释放锁超出范围，发生在清单16-12内部范围的末尾。因此，我们不会冒险忘记释放锁并阻止互斥锁被其他线程使用，因为锁释放会自动发生。</target>
        </trans-unit>
        <trans-unit id="e4e495363e711b35cf1aef444d4c023b03ec561b" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, &lt;code&gt;cargo new&lt;/code&gt; generates a &amp;ldquo;Hello, world!&amp;rdquo; program for you. Check out the &lt;em&gt;src/main.rs&lt;/em&gt; file:</source>
          <target state="translated">如您在第一章中所看到的， &lt;code&gt;cargo new&lt;/code&gt; 产生一个&amp;ldquo;你好，世界！程序给你。&lt;em&gt;签&lt;/em&gt;出&lt;em&gt;src / main.rs&lt;/em&gt;文件：</target>
        </trans-unit>
        <trans-unit id="acce671b7472bf5e5eaabe31a3ccfe6aca667c9d" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, the &lt;code&gt;main&lt;/code&gt; function is the entry point into the program:</source>
          <target state="translated">如第1章所述， &lt;code&gt;main&lt;/code&gt; 功能是程序的入口点：</target>
        </trans-unit>
        <trans-unit id="1b995f5c38439d41d9506c07ed8d2188c4fc0f99" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</source>
          <target state="translated">正如你在第6章中所看到的,你可以直接将模式与字元进行匹配。下面的代码给出了一些例子。</target>
        </trans-unit>
        <trans-unit id="fa0b472a10784179b99aa6fee609e3cfddb9cc55" translate="yes" xml:space="preserve">
          <source>As you saw in Listing 17-15, we can write methods that use the syntax &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, which allows the method to take ownership of a &lt;code&gt;Self&lt;/code&gt; value stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. That&amp;rsquo;s exactly what we want to do here, but unfortunately Rust won&amp;rsquo;t let us: the part of Rust that implements behavior when a closure is called isn&amp;rsquo;t implemented using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. So Rust doesn&amp;rsquo;t yet understand that it could use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in this situation to take ownership of the closure and move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如清单17-15所示，我们可以编写使用 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 语法的方法：Box &amp;lt;Self&amp;gt;，它允许该方法取得对存储在 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;Self&lt;/code&gt; 值的所有权。这正是我们要在此处执行的操作，但是很遗憾，Rust不允许我们这样做：Rust在调用闭包时实现行为的部分没有使用 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 。因此Rust仍不了解它可以使用 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 在这种情况下Box &amp;lt;Self&amp;gt;来获得闭包的所有权并将闭包移出 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d8ebbcc7fc2cf4e602d0e1985852befad2da85e" translate="yes" xml:space="preserve">
          <source>As you saw in the guessing game tutorial in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is &lt;em&gt;shadowed&lt;/em&gt; by the second, which means that the second variable&amp;rsquo;s value is what appears when the variable is used. We can shadow a variable by using the same variable&amp;rsquo;s name and repeating the use of the &lt;code&gt;let&lt;/code&gt; keyword as follows:</source>
          <target state="translated">如您在第2章&lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;将猜测与秘密数字进行比较&amp;rdquo;&lt;/a&gt;部分中的猜谜游戏教程中所看到的，您可以声明一个与先前变量同名的新变量，并且该新变量会覆盖先前的变量。 Rustaceans说，第一变量被&lt;em&gt;遮蔽&lt;/em&gt;由第二装置，该装置使得所述第二变量的值是使用该变量时显示的内容。我们可以通过使用相同变量的名称并重复使用 &lt;code&gt;let&lt;/code&gt; 关键字来隐藏变量，如下所示：</target>
        </trans-unit>
        <trans-unit id="c47b398566173be1e06632198f7039025f10ae00" translate="yes" xml:space="preserve">
          <source>As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you&amp;rsquo;ll clarify where to find code that implements a particular feature and where to go to change how a feature works.</source>
          <target state="translated">在编写大型程序时，组织代码非常重要，因为在头脑中跟踪整个程序将变得不可能。通过对相关功能进行分组并用不同的功能分隔代码，您将弄清楚在哪里可以找到实现特定功能的代码，以及在何处更改功能的工作方式。</target>
        </trans-unit>
        <trans-unit id="a48835105e35976d30850d6478e3e8cb37ac0bc5" translate="yes" xml:space="preserve">
          <source>As your project grows, consider using a workspace: it&amp;rsquo;s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between them easier if they are often changed at the same time.</source>
          <target state="translated">随着项目的增长，请考虑使用工作区：比一个大的代码块更容易理解较小的单个组件。此外，如果经常将板条箱同时更改，则将板条箱保存在工作区中可使它们之间的协调更容易。</target>
        </trans-unit>
        <trans-unit id="db2e27ecee3ef7df382d73da5185cf2c81a313eb" translate="yes" xml:space="preserve">
          <source>AsMut</source>
          <target state="translated">AsMut</target>
        </trans-unit>
        <trans-unit id="9dee5144fa49d1023659054cfeb7b935d110f729" translate="yes" xml:space="preserve">
          <source>AsMut::as_mut</source>
          <target state="translated">AsMut::as_mut</target>
        </trans-unit>
        <trans-unit id="fa6cbff29c8fee2a75af18139d6ec5d8bb30e951" translate="yes" xml:space="preserve">
          <source>AsRawFd</source>
          <target state="translated">AsRawFd</target>
        </trans-unit>
        <trans-unit id="bf4b7b3bd11f76d54ac78e508bf69a1df97a73ab" translate="yes" xml:space="preserve">
          <source>AsRawHandle</source>
          <target state="translated">AsRawHandle</target>
        </trans-unit>
        <trans-unit id="bcb7263b347977861cfead462a0183ddbacb93a0" translate="yes" xml:space="preserve">
          <source>AsRawSocket</source>
          <target state="translated">AsRawSocket</target>
        </trans-unit>
        <trans-unit id="ecb4ad32c0bbcb0030bdba05dd0126fda307a2ef" translate="yes" xml:space="preserve">
          <source>AsRef</source>
          <target state="translated">AsRef</target>
        </trans-unit>
        <trans-unit id="ce713a708d26f349ef9d3da2c64c32c52ede1f28" translate="yes" xml:space="preserve">
          <source>AsRef::as_ref</source>
          <target state="translated">AsRef::as_ref</target>
        </trans-unit>
        <trans-unit id="a4ef661b82f652f581223b25a6824dec40ae544d" translate="yes" xml:space="preserve">
          <source>AsciiExt</source>
          <target state="translated">AsciiExt</target>
        </trans-unit>
        <trans-unit id="46e0dda46ad92722f1539fd012c3778f39c3b187" translate="yes" xml:space="preserve">
          <source>AsciiExt::eq_ignore_ascii_case</source>
          <target state="translated">AsciiExt::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="afaf433bc6efc0517fc1bdeb6f7c5eafce3e74d4" translate="yes" xml:space="preserve">
          <source>AsciiExt::is_ascii</source>
          <target state="translated">AsciiExt::is_ascii</target>
        </trans-unit>
        <trans-unit id="a117348e90cbeb6580ea282ea76b737d649c0ce2" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_lowercase</source>
          <target state="translated">AsciiExt::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="014f8e9aa886e527dbae3bd8a29a0232814779eb" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_uppercase</source>
          <target state="translated">AsciiExt::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="ac47518e69af0774bb76855d1ba4fd45ba076dbb" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_lowercase</source>
          <target state="translated">AsciiExt::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e04741744413a75fb42c855cb8f9068dc93b7a29" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_uppercase</source>
          <target state="translated">AsciiExt::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="1b3c2291de90fba8268fb52f3659391950c3a127" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly bracket, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">除了右花括号以外，到目前为止，在添加的代码中仅讨论了以下一行：</target>
        </trans-unit>
        <trans-unit id="f99c599e0e3924b919cda05ade321af8f7909739" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly brackets, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">除了右花括号外，到目前为止，在添加的代码中仅讨论了以下一行：</target>
        </trans-unit>
        <trans-unit id="ccfa1ea33000ed1fdc5e32d6d85a1f23b351c53c" translate="yes" xml:space="preserve">
          <source>Asked how long the string is, you might say 12. However, Rust&amp;rsquo;s answer is 24: that&amp;rsquo;s the number of bytes it takes to encode &amp;ldquo;Здравствуйте&amp;rdquo; in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string&amp;rsquo;s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:</source>
          <target state="translated">问到字符串有多长，您可能会说12。但是，Rust的答案是24：这是在UTF-8中编码&amp;ldquo;Здравствуйте&amp;rdquo;所需的字节数，因为该字符串中的每个Unicode标量值都占用2个字节的存储空间。因此，指向字符串字节的索引并不总是与有效的Unicode标量值相关。为了演示，请考虑以下无效的Rust代码：</target>
        </trans-unit>
        <trans-unit id="e7689cb162bee3d282a7b39ef7b90263d73428fa" translate="yes" xml:space="preserve">
          <source>Assert the results are what you expect.</source>
          <target state="translated">断言结果是你所期望的。</target>
        </trans-unit>
        <trans-unit id="14ec22b40bdfb6faadf461156fa13c1003c498f7" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe</source>
          <target state="translated">AssertUnwindSafe</target>
        </trans-unit>
        <trans-unit id="b22e5cc4bce8496592970be5b25d370d67581697" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow</source>
          <target state="translated">AssertUnwindSafe::borrow</target>
        </trans-unit>
        <trans-unit id="e9b2629172195580950a107f4837fef269c6587e" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow_mut</source>
          <target state="translated">AssertUnwindSafe::borrow_mut</target>
        </trans-unit>
        <trans-unit id="65951f8f36689c68821ae0439274d4a0186d7055" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::call_once</source>
          <target state="translated">AssertUnwindSafe::call_once</target>
        </trans-unit>
        <trans-unit id="846bd763b3f520ae6051ff0597c886f310c2c6ea" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref</source>
          <target state="translated">AssertUnwindSafe::deref</target>
        </trans-unit>
        <trans-unit id="0f7f2436811897e328934158a966a543668732f9" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref_mut</source>
          <target state="translated">AssertUnwindSafe::deref_mut</target>
        </trans-unit>
        <trans-unit id="df50057fe584f587876a9e064fa1ae0b0acfbda2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::fmt</source>
          <target state="translated">AssertUnwindSafe::fmt</target>
        </trans-unit>
        <trans-unit id="d34a0fd3c126015a7f7ea1d7a1780f16da8c0c7f" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::from</source>
          <target state="translated">AssertUnwindSafe::from</target>
        </trans-unit>
        <trans-unit id="bc1f4df4473c05cd44c2d50adf3e2f9062513d4c" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::into</source>
          <target state="translated">AssertUnwindSafe::into</target>
        </trans-unit>
        <trans-unit id="3b850d0a322410d738f80adc8cf728ee8170ee1d" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::poll</source>
          <target state="translated">AssertUnwindSafe::poll</target>
        </trans-unit>
        <trans-unit id="daed5606c5d5daf7eeeb4806493948f969bf4f99" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_from</source>
          <target state="translated">AssertUnwindSafe::try_from</target>
        </trans-unit>
        <trans-unit id="eb82a427dc920b4169ca7e00269601d2ac319ce2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_into</source>
          <target state="translated">AssertUnwindSafe::try_into</target>
        </trans-unit>
        <trans-unit id="9f7d994301cc07488a1ff2b7d4c3da5dab748286" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::type_id</source>
          <target state="translated">AssertUnwindSafe::type_id</target>
        </trans-unit>
        <trans-unit id="caf84242142f24165f73b39c5c6b3d3bc20e5c26" translate="yes" xml:space="preserve">
          <source>Assertions are always checked in both debug and release builds, and cannot be disabled. See &lt;a href=&quot;macro.debug_assert&quot;&gt;&lt;code&gt;debug_assert!&lt;/code&gt;&lt;/a&gt; for assertions that are not enabled in release builds by default.</source>
          <target state="translated">断言始终在调试和发行版本中进行检查，并且不能禁用。参见&lt;a href=&quot;macro.debug_assert&quot;&gt; &lt;code&gt;debug_assert!&lt;/code&gt; &lt;/a&gt;对于默认情况下未在发行版中启用的断言。</target>
        </trans-unit>
        <trans-unit id="e17cdfab7869a902dcf07cf1a4cdf602ea080d95" translate="yes" xml:space="preserve">
          <source>Asserts that a boolean expression is &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">断言布尔表达式在运行时为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cab5457990719d367e9e18b69d1f9cf567a9ba6" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">断言两个表达式彼此相等（使用&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ebf68c5dd99f7adc415f813d7cd9a9965b251c70" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other.</source>
          <target state="translated">断言两个表达式互为相等。</target>
        </trans-unit>
        <trans-unit id="c856365534a0e73e93b9d798530cb553f48e1b9c" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">断言两个表达式彼此不相等（使用&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4b3283be054a95811542a229062df29f52cd4b0a" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other.</source>
          <target state="translated">断言两个表达式互不相等。</target>
        </trans-unit>
        <trans-unit id="6a70c6eb716321451f69851e0a0b3e6de46cfe0a" translate="yes" xml:space="preserve">
          <source>Assignment expressions</source>
          <target state="translated">赋值表达式</target>
        </trans-unit>
        <trans-unit id="db7b4a247e0cd4b439f9a236f4dd17ca687d0c37" translate="yes" xml:space="preserve">
          <source>Assignment of &lt;code&gt;A + B&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt; might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.</source>
          <target state="translated">转让 &lt;code&gt;A + B&lt;/code&gt; 到 &lt;code&gt;A&lt;/code&gt; 可能会被删除，因为总和可以存储在一个临时位置，直到它被打印出来，用全局变量从未得到更新。</target>
        </trans-unit>
        <trans-unit id="fb5a2f19ac5c2fbe53a27d32c54a5315d8390b9c" translate="yes" xml:space="preserve">
          <source>Assignment/equivalence</source>
          <target state="translated">Assignment/equivalence</target>
        </trans-unit>
        <trans-unit id="1ec71ff0ba20c7a0026ccba467326b673793511e" translate="yes" xml:space="preserve">
          <source>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</source>
          <target state="translated">在模式卫士中不允许赋值,因为匹配不能有副作用。副作用可能会改变被匹配的对象或匹配所依赖的环境,从而导致匹配不彻底。例如,如果允许赋值,以下内容将不匹配任何手臂。</target>
        </trans-unit>
        <trans-unit id="681eeaa9b3a793bf0806817da80c3be3c3a0567b" translate="yes" xml:space="preserve">
          <source>Assigns a new value to the memory behind the pinned reference.</source>
          <target state="translated">将一个新的值分配给钉住的引用后面的内存。</target>
        </trans-unit>
        <trans-unit id="b443e8292f53b80a70f9ceabc76037bb4e254686" translate="yes" xml:space="preserve">
          <source>Associated Constants</source>
          <target state="translated">相关常数</target>
        </trans-unit>
        <trans-unit id="aea3ba1170590168c2a8d38c0934f41a1081bd96" translate="yes" xml:space="preserve">
          <source>Associated Constants Examples</source>
          <target state="translated">相关常量示例</target>
        </trans-unit>
        <trans-unit id="eb724e00631164f5e2c7a1805aa66c501706a7b7" translate="yes" xml:space="preserve">
          <source>Associated Functions</source>
          <target state="translated">相关功能</target>
        </trans-unit>
        <trans-unit id="b9d6b786d3dce88371ca3fec1b3f0f5dcc494947" translate="yes" xml:space="preserve">
          <source>Associated Items</source>
          <target state="translated">相关项目</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">相关类型</target>
        </trans-unit>
        <trans-unit id="d854ee9b0fbbb41a1a8293a522b3a7fd759f3935" translate="yes" xml:space="preserve">
          <source>Associated Types Container Example</source>
          <target state="translated">关联类型集装箱示例</target>
        </trans-unit>
        <trans-unit id="6176d44495c67b15b26948f8a03f37c611fcd9c1" translate="yes" xml:space="preserve">
          <source>Associated constants, functions, and types</source>
          <target state="translated">相关的常量、函数和类型</target>
        </trans-unit>
        <trans-unit id="bf8fe32d8bff33aaf1adf4d6ce640603da967659" translate="yes" xml:space="preserve">
          <source>Associated functions and methods</source>
          <target state="translated">相关职能和方法</target>
        </trans-unit>
        <trans-unit id="ca7658fbd81144f975e114c63e67d2067128142d" translate="yes" xml:space="preserve">
          <source>Associated functions are often used for constructors that will return a new instance of the struct. For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square &lt;code&gt;Rectangle&lt;/code&gt; rather than having to specify the same value twice:</source>
          <target state="translated">关联函数通常用于将返回该结构的新实例的构造函数。例如，我们可以提供一个关联的函数，该函数将具有一个维度参数并将其用作宽度和高度，从而使创建正方形 &lt;code&gt;Rectangle&lt;/code&gt; 变得更加容易，而不必两次指定相同的值：</target>
        </trans-unit>
        <trans-unit id="1d8027bfb0422adf6fa755c7366da969f12a3f99" translate="yes" xml:space="preserve">
          <source>Associated functions whose first parameter is named &lt;code&gt;self&lt;/code&gt; are called &lt;em&gt;methods&lt;/em&gt; and may be invoked using the &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;method call operator&lt;/a&gt;, for example, &lt;code&gt;x.foo()&lt;/code&gt;, as well as the usual function call notation.</source>
          <target state="translated">第一个参数称为 &lt;code&gt;self&lt;/code&gt; 的关联函数称为&lt;em&gt;方法&lt;/em&gt;，可以使用&lt;a href=&quot;../expressions/method-call-expr&quot;&gt;方法调用运算符&lt;/a&gt;（例如 &lt;code&gt;x.foo()&lt;/code&gt; )以及通常的函数调用表示法进行调用。</target>
        </trans-unit>
        <trans-unit id="50f4dee25317e303fd0eeee4d556e246ef57db0b" translate="yes" xml:space="preserve">
          <source>Associated item</source>
          <target state="translated">相关项目</target>
        </trans-unit>
        <trans-unit id="4627f0f1df7ed7ad7efce2d0583317bf3d8df511" translate="yes" xml:space="preserve">
          <source>Associated item for a type that cannot be directly named (e.g., &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt;, &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt;, etc.)</source>
          <target state="translated">无法直接命名的类型的关联项目（例如， &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt; ， &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="f0dda5ab7ff2aba410ad872aa8c289173200dd02" translate="yes" xml:space="preserve">
          <source>Associated items are useful when the associated item logically is related to the associating item. For example, the &lt;code&gt;is_some&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; is intrinsically related to Options, so should be associated.</source>
          <target state="translated">当关联项目在逻辑上与关联项目相关时，关联项目很有用。例如， &lt;code&gt;Option&lt;/code&gt; 上的 &lt;code&gt;is_some&lt;/code&gt; 方法与Option本质上相关，因此应将其关联。</target>
        </trans-unit>
        <trans-unit id="13ba4a748e2d8dab765ce941e0df6910e63030e1" translate="yes" xml:space="preserve">
          <source>Associated searcher for this pattern</source>
          <target state="translated">该模式的相关搜索者</target>
        </trans-unit>
        <trans-unit id="ce35cedae86fe81ca2cf2bcb725660816d309811" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 关联类型为Pattern &amp;lt;'a &amp;gt;&amp;gt; :: Searcher。</target>
        </trans-unit>
        <trans-unit id="e195d76e814dc3f6b09416fe019701da4141e61f" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 关联类型为Pattern &amp;lt;'a &amp;gt;&amp;gt; :: Searcher。</target>
        </trans-unit>
        <trans-unit id="da9f3600b580da18821fb0932aa55c1e82dc8484" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 关联类型为Pattern &amp;lt;'a &amp;gt;&amp;gt; :: Searcher。</target>
        </trans-unit>
        <trans-unit id="470b87bc44e9aa3c27db7ff27c851ded51a493f4" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 关联类型。</target>
        </trans-unit>
        <trans-unit id="4b2aeb71be1e33f6aef873e1957563d04f8d17e0" translate="yes" xml:space="preserve">
          <source>Associated types from &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">可以使用来自 &lt;code&gt;Trait&lt;/code&gt; 的关联类型。</target>
        </trans-unit>
        <trans-unit id="b94fe8e8235a5eac0ea7986a3bc24833e5f55164" translate="yes" xml:space="preserve">
          <source>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</source>
          <target state="translated">关联类型可能看起来像一个类似于泛型的概念,因为后者允许我们定义一个函数而不需要指定它能处理什么类型。那么为什么要使用关联类型呢?</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="434de15a9f2e5951652f37ae43c858535ba0b678" translate="yes" xml:space="preserve">
          <source>Assume there are two files in the same directory with the following contents:</source>
          <target state="translated">假设同一目录下有两个文件,内容如下。</target>
        </trans-unit>
        <trans-unit id="a7203654194ae4db3f1b4a3c121163c9fc8267f3" translate="yes" xml:space="preserve">
          <source>Assumes that the &lt;code&gt;VecDeque&lt;/code&gt; is sorted by the key, for instance with &lt;a href=&quot;#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous().sort_by_key()&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">假定 &lt;code&gt;VecDeque&lt;/code&gt; 是按键排序的，例如使用相同的键提取函数通过&lt;a href=&quot;#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous().sort_by_key()&lt;/code&gt; &lt;/a&gt;进行排序。</target>
        </trans-unit>
        <trans-unit id="9c07290f30084dee9d612cccf40372822beeda08" translate="yes" xml:space="preserve">
          <source>Assumes that the slice is sorted by the key, for instance with &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">假定按键对切片进行排序，例如使用相同的键提取函数对&lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt;进行排序。</target>
        </trans-unit>
        <trans-unit id="7da83b920d859bea1ef24ff98129cc3f739b791b" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a mutable slice to them.</source>
          <target state="translated">假设所有的元素都被初始化了,就给它们弄一个可突变的分片。</target>
        </trans-unit>
        <trans-unit id="0d70f82d569a6dc638a5854fc3e366cb50b91e26" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a slice to them.</source>
          <target state="translated">假设所有的元素都被初始化,对它们进行分片。</target>
        </trans-unit>
        <trans-unit id="c924c9518b3ab961e095e1c3fb8fc583399ec253" translate="yes" xml:space="preserve">
          <source>Assuming there&amp;rsquo;s a file named &lt;code&gt;foo.txt&lt;/code&gt; with contents &lt;code&gt;abcdef\n&lt;/code&gt;, create two handles, seek one of them, and read the remaining bytes from the other handle:</source>
          <target state="translated">假设有一个名为 &lt;code&gt;foo.txt&lt;/code&gt; 的文件，其内容为 &lt;code&gt;abcdef\n&lt;/code&gt; ，创建两个句柄，查找其中一个，然后从另一个句柄读取其余字节：</target>
        </trans-unit>
        <trans-unit id="31936e0a0d8572ee4060f19296edebc34a7f6f8c" translate="yes" xml:space="preserve">
          <source>Asterisk glob imports will import items imported with &lt;code&gt;_&lt;/code&gt; in their unnameable form.</source>
          <target state="translated">星号全局导入将以无名形式导入用 &lt;code&gt;_&lt;/code&gt; 导入的项目。</target>
        </trans-unit>
        <trans-unit id="940e0ca02bfde86559dac73ad0f3397300f703e1" translate="yes" xml:space="preserve">
          <source>Async blocks act like a function boundary, much like closures. Therefore, the &lt;code&gt;?&lt;/code&gt; operator and &lt;code&gt;return&lt;/code&gt; expressions both affect the output of the future, not the enclosing function or other context. That is, &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; from within a closure will return the result of &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; as the output of the future. Similarly, if &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; propagates an error, that error is propagated as the result of the future.</source>
          <target state="translated">异步块的作用类似于函数边界，非常类似于闭包。因此， &lt;code&gt;?&lt;/code&gt; 运算符和 &lt;code&gt;return&lt;/code&gt; 表达式都影响将来的输出，而不影响封闭函数或其他上下文。也就是说，从闭包内部 &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; 将返回 &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; 的结果作为future的输出。同样，如果 &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; 传播错误，该错误将作为将来的结果传播。</target>
        </trans-unit>
        <trans-unit id="214d7973c7382a6a34b11e3f97cf5442c859fb3e" translate="yes" xml:space="preserve">
          <source>Async blocks capture variables from their environment using the same &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;capture modes&lt;/a&gt; as closures. Like closures, when written &lt;code&gt;async { .. }&lt;/code&gt; the capture mode for each variable will be inferred from the content of the block. &lt;code&gt;async move { .. }&lt;/code&gt; blocks however will move all referenced variables into the resulting future.</source>
          <target state="translated">异步块使用与闭包相同的&lt;a href=&quot;../types/closure#capture-modes&quot;&gt;捕获模式&lt;/a&gt;从其环境捕获变量。像闭包一样，当 &lt;code&gt;async { .. }&lt;/code&gt; 编写时，将从该块的内容中推断出每个变量的捕获模式。 &lt;code&gt;async move { .. }&lt;/code&gt; 块会将所有引用的变量移动到结果的Future中。</target>
        </trans-unit>
        <trans-unit id="57f9a16fc928066d87c71b1e0690e9ad26edea0a" translate="yes" xml:space="preserve">
          <source>Async context</source>
          <target state="translated">异步上下文</target>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="translated">异步功能</target>
        </trans-unit>
        <trans-unit id="99471e2fa36e20e9d7193c5529dfbf6f52a711a2" translate="yes" xml:space="preserve">
          <source>Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function's body.</source>
          <target state="translated">Async函数在被调用时并不工作:相反,它们将其参数捕获到一个未来中。当轮询时,该未来将执行函数的主体。</target>
        </trans-unit>
        <trans-unit id="c318095156a540e68b8cc7d9ad9ab72fce83a154" translate="yes" xml:space="preserve">
          <source>Asynchronous values.</source>
          <target state="translated">异步值。</target>
        </trans-unit>
        <trans-unit id="0855009c46728a5c8cb9aa53860e3b38d932c17a" translate="yes" xml:space="preserve">
          <source>At</source>
          <target state="translated">At</target>
        </trans-unit>
        <trans-unit id="6aa8b3387e6ffd75791adbf0065888a4924635f2" translate="yes" xml:space="preserve">
          <source>At a high level, a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;. Things get more subtle when discussing types that combine pinned with non-pinned data; &lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;see below&lt;/a&gt; for more details.</source>
          <target state="translated">在较高的层次上，&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;确保任何指针类型 &lt;code&gt;P&lt;/code&gt; 的指针在内存中都具有稳定的位置，这意味着它不能被移动到其他地方，并且只有在被丢弃之前，它的内存才能被释放。我们说指向对象是&amp;ldquo;固定&amp;rdquo;的。当讨论结合固定数据和非固定数据的类型时，事情变得更加微妙。有关更多详细信息，&lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;请参见下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9cacf1832e8829a2c65089757588eeeacfc9330" translate="yes" xml:space="preserve">
          <source>At all times, you must avoid data races. If multiple threads have access to the same &lt;code&gt;UnsafeCell&lt;/code&gt;, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</source>
          <target state="translated">在任何时候，您都必须避免数据争用。如果多个线程可以访问同一个 &lt;code&gt;UnsafeCell&lt;/code&gt; ，则任何写操作都必须在与所有其他访问（或使用原子）相关之前进行适当的更改。</target>
        </trans-unit>
        <trans-unit id="c68169e0fac1472856a75bc093cd4e904a65d3b5" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; (but not both of) one mutable reference or any number of immutable references.</source>
          <target state="translated">在任何给定时间，您可以拥有&lt;em&gt;一个&lt;/em&gt;（但不是全部）一个可变引用或任意数量的不可变引用。</target>
        </trans-unit>
        <trans-unit id="97c27bc0fbd95b57400fcf731e3e7a7d89c5cf2f" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; one mutable reference &lt;em&gt;or&lt;/em&gt; any number of immutable references.</source>
          <target state="translated">在任何时候，你可以拥有&lt;em&gt;任何&lt;/em&gt;一个可变引用&lt;em&gt;或&lt;/em&gt;任意数量不变引用。</target>
        </trans-unit>
        <trans-unit id="b790d9edc1873ab13071956060a912cd284deda5" translate="yes" xml:space="preserve">
          <source>At compile time each implementation of &lt;code&gt;Trait&lt;/code&gt; will produce a table containing the various methods (and other items) related to the implementation.</source>
          <target state="translated">在编译时，每个 &lt;code&gt;Trait&lt;/code&gt; 实现将产生一个表，其中包含与实现相关的各种方法（和其他项）。</target>
        </trans-unit>
        <trans-unit id="26e37b1b35b52ad10610ea1ef12403fe61f658c6" translate="yes" xml:space="preserve">
          <source>At compile time, Rust needs to know how much space a type takes up. One type whose size can&amp;rsquo;t be known at compile time is a &lt;em&gt;recursive type&lt;/em&gt;, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn&amp;rsquo;t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</source>
          <target state="translated">在编译时，Rust需要知道一个类型占用多少空间。&lt;em&gt;递归类型&lt;/em&gt;是一种其大小在编译时未知的&lt;em&gt;类型&lt;/em&gt;，其中一个值本身可以具有另一个相同类型的值。因为值的嵌套理论上可以无限地继续，所以Rust不知道递归类型的值需要多少空间。但是，框的大小是已知的，因此，通过在递归类型定义中插入框，可以拥有递归类型。</target>
        </trans-unit>
        <trans-unit id="b2f9b5afe99b75e0f39f01ec88be93443b074a9d" translate="yes" xml:space="preserve">
          <source>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the &lt;code&gt;Rc::strong_count&lt;/code&gt; function. This function is named &lt;code&gt;strong_count&lt;/code&gt; rather than &lt;code&gt;count&lt;/code&gt; because the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type also has a &lt;code&gt;weak_count&lt;/code&gt;; we&amp;rsquo;ll see what &lt;code&gt;weak_count&lt;/code&gt; is used for in the &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;Preventing Reference Cycles: Turning an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">在程序中引用计数更改的每个点，我们都会打印引用计数，这可以通过调用 &lt;code&gt;Rc::strong_count&lt;/code&gt; 函数获得。该函数被命名为 &lt;code&gt;strong_count&lt;/code&gt; 而不是 &lt;code&gt;count&lt;/code&gt; ,因为 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 类型也具有 &lt;code&gt;weak_count&lt;/code&gt; ；我们将在&lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;防止参考周期：将&lt;/a&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 转换为 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; &amp;rdquo;部分中看到 &lt;code&gt;weak_count&lt;/code&gt; 的用途。</target>
        </trans-unit>
        <trans-unit id="f2afe7e487c0f1c732676abe97c30fdb7bfd5600" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">最初，我们根本没有分配内存，但是当我们追加到字符串时，它会适当地增加其容量。如果我们改为使用&lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt;方法最初分配正确的容量：</target>
        </trans-unit>
        <trans-unit id="dc05814fc863fd7b76fdcfe7f779c72f9533e270" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">最初，我们根本没有分配任何内存，但是当我们追加到字符串后，它会适当地增加其容量。如果我们改为使用&lt;a href=&quot;struct.string#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt;方法最初分配正确的容量：</target>
        </trans-unit>
        <trans-unit id="0295e56a89c227419234a744fcdff39f54bbbd31" translate="yes" xml:space="preserve">
          <source>At its simplest, a test in Rust is a function that&amp;rsquo;s annotated with the &lt;code&gt;test&lt;/code&gt; attribute. Attributes are metadata about pieces of Rust code; one example is the &lt;code&gt;derive&lt;/code&gt; attribute we used with structs in Chapter 5. To change a function into a test function, add &lt;code&gt;#[test]&lt;/code&gt; on the line before &lt;code&gt;fn&lt;/code&gt;. When you run your tests with the &lt;code&gt;cargo test&lt;/code&gt; command, Rust builds a test runner binary that runs the functions annotated with the &lt;code&gt;test&lt;/code&gt; attribute and reports on whether each test function passes or fails.</source>
          <target state="translated">简单来说，Rust中的测试是使用 &lt;code&gt;test&lt;/code&gt; 属性进行注释的函数。属性是关于Rust代码段的元数据；一个例子是我们在第5章中将struct用于 &lt;code&gt;derive&lt;/code&gt; 属性。要将函数更改为测试函数，请在 &lt;code&gt;fn&lt;/code&gt; 之前的行上添加 &lt;code&gt;#[test]&lt;/code&gt; 。当使用 &lt;code&gt;cargo test&lt;/code&gt; 命令运行测试时，Rust会构建一个测试运行程序二进制文件，该二进制文件运行带有 &lt;code&gt;test&lt;/code&gt; 属性注释的功能，并报告每个测试功能是否通过。</target>
        </trans-unit>
        <trans-unit id="37583ea386b39553438667ee1326a11884d8ac4d" translate="yes" xml:space="preserve">
          <source>At least one of either &lt;code&gt;Self&lt;/code&gt; or a generic type parameter of the trait must meet the following grammar, where &lt;code&gt;C&lt;/code&gt; is a nominal type defined within the containing crate:</source>
          <target state="translated">性状的 &lt;code&gt;Self&lt;/code&gt; 或通用类型参数中的至少一个必须满足以下语法，其中 &lt;code&gt;C&lt;/code&gt; 是包含在包装箱中的标称类型：</target>
        </trans-unit>
        <trans-unit id="6340eab1a988a949757faf0b3ab2c9f1d577f929" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is being used to write to the data.</source>
          <target state="translated">至少有一个指针被用来写入数据。</target>
        </trans-unit>
        <trans-unit id="5724aa0694940a76277017d916e0999814aa1912" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a &lt;a href=&quot;../glossary#local-type&quot;&gt;local type&lt;/a&gt;. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="translated">类型 &lt;code&gt;T0..=Tn&lt;/code&gt; 至少一个必须是&lt;a href=&quot;../glossary#local-type&quot;&gt;本地类型&lt;/a&gt;。令 &lt;code&gt;Ti&lt;/code&gt; 为第一个这样的类型。</target>
        </trans-unit>
        <trans-unit id="e87e525060c2b4080d7c34755a062916a4109c19" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a local type. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="translated">类型 &lt;code&gt;T0..=Tn&lt;/code&gt; 至少有一个必须是本地类型。令 &lt;code&gt;Ti&lt;/code&gt; 为第一个这样的类型。</target>
        </trans-unit>
        <trans-unit id="a139025cd9d3b2fee71807f78a3b49ac15b212ef" translate="yes" xml:space="preserve">
          <source>At present few predefined ABI's (like Rust, C, system, etc.) can be used in Rust. Verify that the ABI is predefined. For example you can replace the given ABI from 'Rust'.</source>
          <target state="translated">目前只有少数预定义的 ABI(如 Rust、C、system 等)可以在 Rust 中使用。验证ABI是否是预定义的。例如,你可以从'Rust'中替换给定的ABI。</target>
        </trans-unit>
        <trans-unit id="e2c9357843faff292144d5026ce32c57e9298ff6" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be &quot;contained&quot; to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</source>
          <target state="translated">目前,不允许在借款仍在范围内的情况下出现收益。为了解决这个错误,必须将借据 &quot;包含 &quot;到一个不与孳息重叠的较小的作用域中,或者以其他方式消除该借据。因此,举例来说,我们可以通过删除借贷,只用值存储整数来解决前面的例子。</target>
        </trans-unit>
        <trans-unit id="c58aa6f87c5fb2f5db7b812c6bc9a21b048e36a1" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to pass more than one explicit parameter for a generator.This can be fixed by using at most 1 parameter for the generator. For example, we might resolve the previous example by passing only one parameter.</source>
          <target state="translated">目前,不允许为生成器传递一个以上的显式参数,这可以通过为生成器最多使用一个参数来解决。例如,我们可以通过只传递一个参数来解决前面的例子。</target>
        </trans-unit>
        <trans-unit id="4e36fb08191e884058237321d264d01b5dc6a45f" translate="yes" xml:space="preserve">
          <source>At run-time, when a method needs to be called on the &lt;code&gt;dyn Trait&lt;/code&gt;, the vtable is consulted to get the function pointer and then that function pointer is called.</source>
          <target state="translated">在运行时，当需要在 &lt;code&gt;dyn Trait&lt;/code&gt; 上调用方法时，将查询vtable以获取函数指针，然后调用该函数指针。</target>
        </trans-unit>
        <trans-unit id="acf3e76f07038198aca7a45dd9300fbaa0a3ed8a" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self != other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine the inequality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be unequal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be unequal.</source>
          <target state="translated">在运行时，此函数的行为类似于 &lt;code&gt;self != other&lt;/code&gt; 。但是，在某些情况下（例如，编译时评估），并非总是可以确定两个指针的不相等性，因此此函数可能会虚假地返回 &lt;code&gt;false&lt;/code&gt; ，而这些指针后来实际上是不相等的。但是，当它返回 &lt;code&gt;true&lt;/code&gt; 时，指针将被保证是不相等的。</target>
        </trans-unit>
        <trans-unit id="3ddac349169d1a744bfbed1eee12e4790040330f" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self == other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine equality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be equal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be equal.</source>
          <target state="translated">在运行时，此函数的行为类似于 &lt;code&gt;self == other&lt;/code&gt; 。但是，在某些情况下（例如，编译时评估），并非总是能够确定两个指针的相等性，因此此函数可能会 &lt;code&gt;false&lt;/code&gt; 为随后返回的相等指针返回false。但是，当它返回 &lt;code&gt;true&lt;/code&gt; 时，则保证指针是相等的。</target>
        </trans-unit>
        <trans-unit id="880cb1d1611d41944fc45c1105942f35a2cea331" translate="yes" xml:space="preserve">
          <source>At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</source>
          <target state="translated">在本章的开头,我们说过向量只能存储相同类型的值。这可能很不方便;肯定有一些用例需要存储不同类型的项目列表。幸运的是,一个枚举的变体是在同一个枚举类型下定义的,所以当我们需要在一个向量中存储不同类型的元素时,我们可以定义并使用一个枚举!</target>
        </trans-unit>
        <trans-unit id="b0f9f410d4d3f041a8bbac0598dae49519ac5a0f" translate="yes" xml:space="preserve">
          <source>At the moment the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks have a lot of repetition: they&amp;rsquo;re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let&amp;rsquo;s make the code more concise by pulling out those differences into separate &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">目前， &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块有很多重复：它们都在读取文件并将文件内容写入流中。唯一的区别是状态行和文件名。让我们通过将这些差异分成单独的 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 行来使代码更简洁，这些if和else行将状态行和文件名的值分配给变量；然后，我们可以在代码中无条件地使用这些变量来读取文件并写入响应。清单20-9显示了替换大的 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块之后的结果代码。</target>
        </trans-unit>
        <trans-unit id="b1fe5f0e39ec55eb0cd362275db96ad9cd1656e2" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;.await&lt;/code&gt;, and the &lt;code&gt;Try&lt;/code&gt; operator (&lt;code&gt;?&lt;/code&gt;) are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="translated">目前， &lt;code&gt;for&lt;/code&gt; 循环，在 &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;static&lt;/code&gt; 或 &lt;code&gt;const fn&lt;/code&gt; 中禁止使用 &lt;code&gt;.await&lt;/code&gt; 和 &lt;code&gt;Try&lt;/code&gt; 运算符（ &lt;code&gt;?&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="929c7d4e23e7e49a6c726514ca62a32c23fbe8e1" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt;, as well as the looping constructs &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;loop&lt;/code&gt;, are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="translated">目前，在 &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;static&lt;/code&gt; 或 &lt;code&gt;const fn&lt;/code&gt; 中禁止使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;match&lt;/code&gt; 以及 &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 和 &lt;code&gt;loop&lt;/code&gt; 的循环构造。</target>
        </trans-unit>
        <trans-unit id="1f16df13b8f4c863b823dc86f56453377891952c" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; function. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">目前，我们正在使用 &lt;code&gt;println!&lt;/code&gt; 将所有输出写入终端！功能。大多数终端提供两种输出：用于常规信息的&lt;em&gt;标准输出&lt;/em&gt;（ &lt;code&gt;stdout&lt;/code&gt; ）和用于错误消息的&lt;em&gt;标准错误&lt;/em&gt;（ &lt;code&gt;stderr&lt;/code&gt; ）。这种区别使用户可以选择将程序的成功输出定向到文件，但仍将错误消息打印到屏幕上。</target>
        </trans-unit>
        <trans-unit id="8d5aa8f95e2e92d8aada8f026371cf7b990b2775" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; macro. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">目前，我们正在使用 &lt;code&gt;println!&lt;/code&gt; 将所有输出写入终端！宏。大多数终端提供两种输出：用于常规信息的&lt;em&gt;标准输出&lt;/em&gt;（ &lt;code&gt;stdout&lt;/code&gt; ）和用于错误消息的&lt;em&gt;标准错误&lt;/em&gt;（ &lt;code&gt;stderr&lt;/code&gt; ）。这种区别使用户可以选择将程序的成功输出定向到文件，但仍将错误消息打印到屏幕上。</target>
        </trans-unit>
        <trans-unit id="3818ff95eb637709816bb6cd777c917a43bae444" translate="yes" xml:space="preserve">
          <source>At the time of this writing, an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; is under development. If you want to stick to a standard style across Rust projects, &lt;code&gt;rustfmt&lt;/code&gt; will format your code in a particular style. The Rust team plans to eventually include this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;. So depending on when you read this book, it might already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">在撰写本文时，正在开发一种名为 &lt;code&gt;rustfmt&lt;/code&gt; 的自动格式化工具。如果您要在Rust项目中坚持标准样式， &lt;code&gt;rustfmt&lt;/code&gt; 将以特定样式设置代码格式。Rust团队计划最终将此工具与标准Rust发行版一起包括，例如 &lt;code&gt;rustc&lt;/code&gt; 。因此，取决于您阅读本书的时间，它可能已安装在计算机上！查看在线文档以了解更多详细信息。</target>
        </trans-unit>
        <trans-unit id="1eca2e64861fbf60436be0df95a81ecf4dd4db51" translate="yes" xml:space="preserve">
          <source>At the time of this writing, two Rust editions are available: Rust 2015 and Rust 2018. This book is written using Rust 2018 edition idioms.</source>
          <target state="translated">在撰写本文时,有两个Rust版本。Rust 2015版和Rust 2018版 本书使用Rust 2018版成语编写。</target>
        </trans-unit>
        <trans-unit id="d0b83ac2e98214df1ca34576f6616d27aede53ff" translate="yes" xml:space="preserve">
          <source>At the time, we said not to worry about the inefficient &lt;code&gt;clone&lt;/code&gt; calls because we would remove them in the future. Well, that time is now!</source>
          <target state="translated">当时，我们说不要担心效率低下的 &lt;code&gt;clone&lt;/code&gt; 调用，因为我们将来会删除它们。好吧，那是现在！</target>
        </trans-unit>
        <trans-unit id="bf023d508177d86413d3379134e446a32a09142c" translate="yes" xml:space="preserve">
          <source>At the time, we skipped over some details in this code. In Chapter 6 in &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;The &lt;code&gt;match&lt;/code&gt; Control Flow Operator&amp;rdquo;&lt;/a&gt; section, we discussed that &lt;code&gt;match&lt;/code&gt; arms must all return the same type. So, for example, the following code doesn&amp;rsquo;t work:</source>
          <target state="translated">当时，我们跳过了这段代码中的一些细节。在&lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo; &lt;code&gt;match&lt;/code&gt; 控制流运算符&amp;rdquo;&lt;/a&gt;部分的第6章中，我们讨论了 &lt;code&gt;match&lt;/code&gt; 臂必须全部返回相同的类型。因此，例如，以下代码不起作用：</target>
        </trans-unit>
        <trans-unit id="7ade322c88e63df6a4a8c865c0fa8c7d63812d90" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cargo build&lt;/code&gt; should complete successfully in both &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt;. Let&amp;rsquo;s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your &lt;em&gt;projects&lt;/em&gt; directory using &lt;code&gt;cargo new pancakes&lt;/code&gt;. We need to add &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; as dependencies in the &lt;code&gt;pancakes&lt;/code&gt; crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;. If you&amp;rsquo;re publishing your versions of &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, they would be regular dependencies; if not, you can specify them as &lt;code&gt;path&lt;/code&gt; dependencies as follows:</source>
          <target state="translated">此时，应在 &lt;code&gt;hello_macro&lt;/code&gt; 和 &lt;code&gt;hello_macro_derive&lt;/code&gt; 中成功完成 &lt;code&gt;cargo build&lt;/code&gt; 。让我们将这些包装箱连接到清单19-30中的代码，以查看实际的过程宏！使用 &lt;code&gt;cargo new pancakes&lt;/code&gt; 在您的&lt;em&gt;项目&lt;/em&gt;目录中创建一个新的二进制项目。我们需要在 &lt;code&gt;pancakes&lt;/code&gt; 箱的&lt;em&gt;Cargo.toml中&lt;/em&gt;添加 &lt;code&gt;hello_macro&lt;/code&gt; 和 &lt;code&gt;hello_macro_derive&lt;/code&gt; 作为依赖&lt;em&gt;项&lt;/em&gt;。如果将 &lt;code&gt;hello_macro&lt;/code&gt; 和 &lt;code&gt;hello_macro_derive&lt;/code&gt; 版本发布到&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;，它们将是常规依赖项；如果没有，您可以将它们指定为&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;path&lt;/code&gt; 依赖关系如下：</target>
        </trans-unit>
        <trans-unit id="b945ef4a755c9f52a155f619e7f39f1e0b11da63" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;tic-tac-toe&lt;/code&gt;. With all of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; characters, it&amp;rsquo;s difficult to see what&amp;rsquo;s going on. For more complicated string combining, we can use the &lt;code&gt;format!&lt;/code&gt; macro:</source>
          <target state="translated">此时， &lt;code&gt;s&lt;/code&gt; 将是 &lt;code&gt;tic-tac-toe&lt;/code&gt; 。对于所有的 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;&quot;&lt;/code&gt; 字符，很难看到发生了什么。对于更复杂的字符串组合，我们可以使用 &lt;code&gt;format!&lt;/code&gt; 宏：</target>
        </trans-unit>
        <trans-unit id="bad906bb2d4d513518792ef63a17dbb628e284cd" translate="yes" xml:space="preserve">
          <source>At this point, the first part of the game is done: we&amp;rsquo;re getting input from the keyboard and then printing it.</source>
          <target state="translated">至此，游戏的第一部分完成了：我们从键盘上获取输入，然后进行打印。</target>
        </trans-unit>
        <trans-unit id="645fa0bc97b2e92b8b41b6c72b5e6804e2731419" translate="yes" xml:space="preserve">
          <source>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we&amp;rsquo;ll build on top of this understanding by introducing the &lt;code&gt;String&lt;/code&gt; type.</source>
          <target state="translated">此时，作用域之间以及变量何时有效之间的关系类似于其他编程语言中的关系。现在，我们将通过介绍 &lt;code&gt;String&lt;/code&gt; 类型在此理解之上。</target>
        </trans-unit>
        <trans-unit id="440b2812ba3e248d39262c445df6cb473f1a4cf8" translate="yes" xml:space="preserve">
          <source>At this point, we can build the workspace by running &lt;code&gt;cargo build&lt;/code&gt;. The files in your &lt;em&gt;add&lt;/em&gt; directory should look like this:</source>
          <target state="translated">此时，我们可以通过运行 &lt;code&gt;cargo build&lt;/code&gt; 来构建工作空间。您的&lt;em&gt;添加&lt;/em&gt;目录中的文件应如下所示：</target>
        </trans-unit>
        <trans-unit id="f644530959c577881d3641aeacacd055e0614725" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">在这一点上，我们可以考虑重构搜索功能实现的机会，同时保持测试通过以保持相同的功能。搜索功能中的代码还不错，但是它没有利用迭代器的一些有用功能。我们将在&lt;a href=&quot;ch13-02-iterators&quot;&gt;第13章&lt;/a&gt;返回该示例，在此我们将详细探讨迭代器，并研究如何对其进行改进。</target>
        </trans-unit>
        <trans-unit id="7be13e6f2293ee19341faecbce38cbce6581638c" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in [Chapter 13][ch13], where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">在这一点上，我们可以考虑重构搜索功能实现的机会，同时保持测试通过以保持相同的功能。搜索功能中的代码还不错，但是它没有利用迭代器的一些有用功能。我们将在第13章[ch13]中返回该示例，在此我们将详细探讨迭代器，并研究如何改进迭代器。</target>
        </trans-unit>
        <trans-unit id="12d2e7392939d54c75dd7be38b3f433458f57624" translate="yes" xml:space="preserve">
          <source>At this point, when we call &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt;, deref coercion will take effect on the &lt;code&gt;&amp;amp;&lt;/code&gt; and the &lt;code&gt;Box&lt;/code&gt; so the &lt;code&gt;content&lt;/code&gt; method will ultimately be called on the type that implements the &lt;code&gt;State&lt;/code&gt; trait. That means we need to add &lt;code&gt;content&lt;/code&gt; to the &lt;code&gt;State&lt;/code&gt; trait definition, and that is where we&amp;rsquo;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</source>
          <target state="translated">此时，当我们在 &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; 上调用 &lt;code&gt;content&lt;/code&gt; 时，deref强制将对 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;Box&lt;/code&gt; 生效，因此 &lt;code&gt;content&lt;/code&gt; 方法最终将在实现 &lt;code&gt;State&lt;/code&gt; 特性的类型上调用。这意味着我们需要将 &lt;code&gt;content&lt;/code&gt; 添加到 &lt;code&gt;State&lt;/code&gt; trait定义中，在这里我们将根据所处的状态来确定返回什么内容的逻辑，如清单17-18所示：</target>
        </trans-unit>
        <trans-unit id="41d03c60eead1f80179e902c1b4d9814280d6245" translate="yes" xml:space="preserve">
          <source>At this point, when we try to get a reference to the parent of &lt;code&gt;leaf&lt;/code&gt; by using the &lt;code&gt;upgrade&lt;/code&gt; method, we get a &lt;code&gt;None&lt;/code&gt; value. We see this in the output from the first &lt;code&gt;println!&lt;/code&gt; statement:</source>
          <target state="translated">此时，当我们尝试使用 &lt;code&gt;upgrade&lt;/code&gt; 方法获取对 &lt;code&gt;leaf&lt;/code&gt; 父级的引用时，将获得 &lt;code&gt;None&lt;/code&gt; 值。我们在第一个 &lt;code&gt;println!&lt;/code&gt; 的输出中看到了这一点！声明：</target>
        </trans-unit>
        <trans-unit id="3822c3ca41678f3e73f1513ee4103e0d10a48e3d" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.3.15&lt;/code&gt;.</source>
          <target state="translated">此时，您还会注意到&lt;em&gt;Cargo.lock&lt;/em&gt;文件中发生了更改，注意到您现在使用的 &lt;code&gt;rand&lt;/code&gt; crate 的版本是 &lt;code&gt;0.3.15&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="980ca773a0cc1c507c75dc787b2ebd61a83c58ee" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.5.6&lt;/code&gt;.</source>
          <target state="translated">此时，您还会注意到&lt;em&gt;Cargo.lock&lt;/em&gt;文件中发生了更改，注意到您现在使用的 &lt;code&gt;rand&lt;/code&gt; crate的版本为 &lt;code&gt;0.5.6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace63d2aec4c0fa2eb5be485664adddc5d8c8911" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve seen several ways of using patterns, but patterns don&amp;rsquo;t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We&amp;rsquo;ll discuss these two concepts next.</source>
          <target state="translated">在这一点上，您已经看到了几种使用模式的方法，但是模式在我们可以使用它们的每个地方都不尽相同。在某些地方，模式必须是无可辩驳的。在其他情况下，它们可能是可辩驳的。接下来，我们将讨论这两个概念。</target>
        </trans-unit>
        <trans-unit id="e19eb30ab901969b293ab5f50d80d0816b9dd309" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve successfully built the guessing game. Congratulations!</source>
          <target state="translated">至此，您已经成功构建了猜谜游戏。恭喜你！</target>
        </trans-unit>
        <trans-unit id="632731832807bd949f8afaff185b846c11bff1a6" translate="yes" xml:space="preserve">
          <source>Atomic Reference Counting with &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">用 &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 原子参考计数</target>
        </trans-unit>
        <trans-unit id="81578fbf1ea44596108fd645f27e6431bf82318a" translate="yes" xml:space="preserve">
          <source>Atomic memory orderings</source>
          <target state="translated">原子存储器排序</target>
        </trans-unit>
        <trans-unit id="7d5338021e809e34d20a6b06646a458b5152b9dc" translate="yes" xml:space="preserve">
          <source>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement &lt;code&gt;AtomicI8&lt;/code&gt;. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</source>
          <target state="translated">原子操作可以在指令层使用更大尺寸的原子来实现。例如，某些平台使用4字节原子指令来实现 &lt;code&gt;AtomicI8&lt;/code&gt; 。请注意，此仿真不应影响代码的正确性，这只是需要注意的事情。</target>
        </trans-unit>
        <trans-unit id="8e24008909c0fc6f23ca4f4f874bb53512815caa" translate="yes" xml:space="preserve">
          <source>Atomic operations with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics can also synchronize with a fence.</source>
          <target state="translated">具有&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;语义的原子操作也可以与围栅同步。</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">原子类型</target>
        </trans-unit>
        <trans-unit id="bd540eaa28be66ef79bdb0e6dc9e7f21a135c077" translate="yes" xml:space="preserve">
          <source>Atomic types may be stored in static variables, initialized using the constant initializers like &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt;&lt;code&gt;AtomicBool::new&lt;/code&gt;&lt;/a&gt;. Atomic statics are often used for lazy global initialization.</source>
          <target state="translated">原子类型可以存储在静态变量中，使用诸如&lt;a href=&quot;struct.atomicbool#method.new&quot;&gt; &lt;code&gt;AtomicBool::new&lt;/code&gt; &lt;/a&gt;类的常量初始化程序进行初始化。原子静态常用于惰性全局初始化。</target>
        </trans-unit>
        <trans-unit id="af8191cce263e5511ffa70b9167ccc44038ee579" translate="yes" xml:space="preserve">
          <source>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</source>
          <target state="translated">原子类型提供了线程之间的原始共享内存通信,是其他并发类型的构建模块。</target>
        </trans-unit>
        <trans-unit id="489ec10910f60409e46dc7b2401064ba30bfb22a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of Rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">原子变量可以安全地在线程之间共享（它们实现&lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;），但是它们本身并不提供共享机制并遵循Rust的&lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;线程模型&lt;/a&gt;。共享原子变量的最常见方法是将其放入&lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;（原子引用计数的共享指针）中。</target>
        </trans-unit>
        <trans-unit id="bdcc7b682e49710ce243d11d666d0605dd24412a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">原子变量可以安全地在线程之间共享（它们实现&lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;），但是它们本身并不提供共享机制并遵循rust 的&lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;线程模型&lt;/a&gt;。共享原子变量的最常见方法是将其放入&lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;（原子引用计数的共享指针）中。</target>
        </trans-unit>
        <trans-unit id="6674d00db7a2e69964175c1325e3eccae698e4d3" translate="yes" xml:space="preserve">
          <source>AtomicBool</source>
          <target state="translated">AtomicBool</target>
        </trans-unit>
        <trans-unit id="c3f581e842f52532b7b151cdbc4ce7233b954e8c" translate="yes" xml:space="preserve">
          <source>AtomicI16</source>
          <target state="translated">AtomicI16</target>
        </trans-unit>
        <trans-unit id="29b774c369d481cc7134a7a13427afa21b7fc9cd" translate="yes" xml:space="preserve">
          <source>AtomicI32</source>
          <target state="translated">AtomicI32</target>
        </trans-unit>
        <trans-unit id="d734b8bd0031516fdc53fb6831e8dec9b067b165" translate="yes" xml:space="preserve">
          <source>AtomicI64</source>
          <target state="translated">AtomicI64</target>
        </trans-unit>
        <trans-unit id="e94562e900680db9e18fda42ce322ce7a5e558bf" translate="yes" xml:space="preserve">
          <source>AtomicI8</source>
          <target state="translated">AtomicI8</target>
        </trans-unit>
        <trans-unit id="c2cc2ca63393294d4014028c732f15eca926e7a2" translate="yes" xml:space="preserve">
          <source>AtomicIsize</source>
          <target state="translated">AtomicIsize</target>
        </trans-unit>
        <trans-unit id="7bc45caa3c8c7a6bbad87dd4b67403e414361ce1" translate="yes" xml:space="preserve">
          <source>AtomicPtr</source>
          <target state="translated">AtomicPtr</target>
        </trans-unit>
        <trans-unit id="17a70c0c14e8b2c47d91d2253122896320428148" translate="yes" xml:space="preserve">
          <source>AtomicU16</source>
          <target state="translated">AtomicU16</target>
        </trans-unit>
        <trans-unit id="8840103173e424948e002b5ffec50c44e404d250" translate="yes" xml:space="preserve">
          <source>AtomicU32</source>
          <target state="translated">AtomicU32</target>
        </trans-unit>
        <trans-unit id="32ac2d92ec899ed90a2638fc480a4297cef99b45" translate="yes" xml:space="preserve">
          <source>AtomicU64</source>
          <target state="translated">AtomicU64</target>
        </trans-unit>
        <trans-unit id="a496370705e1f84302673bc11932128de26a2fea" translate="yes" xml:space="preserve">
          <source>AtomicU8</source>
          <target state="translated">AtomicU8</target>
        </trans-unit>
        <trans-unit id="9d9469a55330492f15842defa35b0f1ef07cac12" translate="yes" xml:space="preserve">
          <source>AtomicUsize</source>
          <target state="translated">AtomicUsize</target>
        </trans-unit>
        <trans-unit id="48c5fb201c75414dd3666a318d954dd873099b2d" translate="yes" xml:space="preserve">
          <source>Atomically makes the handle's token available if it is not already.</source>
          <target state="translated">原子化地使句柄的token可用,如果它还没有的话。</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="fe4c2e56ace1dd5cd16118bb6ad5e5256c61db83" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">尝试将 &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; 转换为具体类型。</target>
        </trans-unit>
        <trans-unit id="92df3d44a91e7d67c064d6d725fec8b2e940cc64" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">尝试将 &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; 转换为具体类型。</target>
        </trans-unit>
        <trans-unit id="886d23c3fa7b51635fa7bbdd282f2babcd6cb45c" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the box to a concrete type.</source>
          <target state="translated">试图将盒子降为具体类型。</target>
        </trans-unit>
        <trans-unit id="175cf296f94bed8278b4e811c5245f622f67f97c" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.</source>
          <target state="translated">试图将未来解析为最终值,如果还没有值,则注册当前任务进行唤醒。</target>
        </trans-unit>
        <trans-unit id="0b1794f780a4845e82f1aa618849777a9e5b6e42" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将未来解析为最终值，如果该值尚不可用，请注册当前任务以进行唤醒。&lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55136df45140cab2915451715291fdde1ced9b25" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将未来解析为最终值，如果该值尚不可用，请注册当前任务以进行唤醒。&lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9dc2a85c8ec42aea412c46625d0258c82f5009a" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将未来解析为最终值，如果该值尚不可用，请注册当前任务以进行唤醒。&lt;a href=&quot;trait.future#tymethod.poll&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="856e8b63203e04805b09dd95b9d3481ff3097c22" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an item whereas an extern crate with this name has already been imported.</source>
          <target state="translated">试图导入一个物品,而这个名称的外部箱子已经被导入。</target>
        </trans-unit>
        <trans-unit id="5fc738aa7f6254311ae3614b150f4fe1cec8fe27" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</source>
          <target state="translated">试图导入一个不重要的值。当试图从一个特质中导入一个方法时,可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="2c61d256e7903ca5ede61e01fd8467962bbb349b" translate="yes" xml:space="preserve">
          <source>Attempted to access a field on a primitive type.</source>
          <target state="translated">试图访问一个基元类型的字段。</target>
        </trans-unit>
        <trans-unit id="a54332e7df630f85a467d7ec89246d77c007b643" translate="yes" xml:space="preserve">
          <source>Attempted to access a method like a field.</source>
          <target state="translated">试图访问一个像字段一样的方法。</target>
        </trans-unit>
        <trans-unit id="48f28400d9c83d5af115ff62dc11ba5e26ca8457" translate="yes" xml:space="preserve">
          <source>Attempted to access a non-existent field in a struct.</source>
          <target state="translated">试图访问一个结构中不存在的字段。</target>
        </trans-unit>
        <trans-unit id="03b41486da885815831596a9c99e4264efdf5d06" translate="yes" xml:space="preserve">
          <source>Attempted to access a private field on a struct.</source>
          <target state="translated">试图访问一个结构的私有字段。</target>
        </trans-unit>
        <trans-unit id="a1ad3c1a31bd1ae534677401ea798535b99a38e5" translate="yes" xml:space="preserve">
          <source>Attempted to call something which isn't a function nor a method.</source>
          <target state="translated">试图调用既不是函数也不是方法的东西。</target>
        </trans-unit>
        <trans-unit id="19e440b538f0d8907b6a787acfc5bb52be0236f7" translate="yes" xml:space="preserve">
          <source>Attempted to cast to/from a pointer with an unknown kind.</source>
          <target state="translated">试图投向/投自一个未知类型的指针。</target>
        </trans-unit>
        <trans-unit id="eef4156ee856f3204829c854633733e0594d2319" translate="yes" xml:space="preserve">
          <source>Attempted to dereference a variable which cannot be dereferenced.</source>
          <target state="translated">试图取消引用一个不能取消引用的变量。</target>
        </trans-unit>
        <trans-unit id="1372db0ea32a319cb23e92d2e2d51b6cd2d1a4fb" translate="yes" xml:space="preserve">
          <source>Attempted to pass an invalid type of variable into a variadic function.</source>
          <target state="translated">试图将一个无效的变量类型传递给一个变量函数。</target>
        </trans-unit>
        <trans-unit id="7adfef6b18f86865559fc727494e616e0b3f7f80" translate="yes" xml:space="preserve">
          <source>Attempting to compile now gives us the following output:</source>
          <target state="translated">现在尝试编译,得到以下输出。</target>
        </trans-unit>
        <trans-unit id="e83036683d0914f18e7de7ebbb8a14c9db8b6c5c" translate="yes" xml:space="preserve">
          <source>Attempting to compile this code results in this type error:</source>
          <target state="translated">试图编译这段代码会导致这种类型错误。</target>
        </trans-unit>
        <trans-unit id="71aec9a6c07f86af18ab65ed514253e4a11e1117" translate="yes" xml:space="preserve">
          <source>Attempting to create a &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; iterator from an improperly formatted socket address &lt;code&gt;&amp;amp;str&lt;/code&gt; (missing the port):</source>
          <target state="translated">尝试从格式不正确的套接字地址 &lt;code&gt;&amp;amp;str&lt;/code&gt; （缺少端口）创建&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;迭代器：</target>
        </trans-unit>
        <trans-unit id="ef35b76897ce014407ed31f4f40475dbcd2bb582" translate="yes" xml:space="preserve">
          <source>Attempting to create a raw pointer to an &lt;code&gt;unaligned&lt;/code&gt; struct field with an expression such as &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; creates an intermediate unaligned reference before converting that to a raw pointer. That this reference is temporary and immediately cast is inconsequential as the compiler always expects references to be properly aligned. As a result, using &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; causes immediate &lt;em&gt;undefined behavior&lt;/em&gt; in your program.</source>
          <target state="translated">尝试使用诸如 &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; 这样的表达式创建指向 &lt;code&gt;unaligned&lt;/code&gt; 结构域的原始指针，然后将其转换为原始指针，然后创建一个中间未对齐引用。该引用是临时的，并且立即强制转换是无关紧要的，因为编译器始终希望引用能够正确对齐。结果，将 &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; 会导致程序中立即出现&lt;em&gt;未定义的行为&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="baf8e0e513c1e7d75d1c56986d1f69437e36903e" translate="yes" xml:space="preserve">
          <source>Attempting to create a trait object for a non object-safe trait will trigger this error.</source>
          <target state="translated">试图为一个非对象安全的特质创建一个特质对象会触发这个错误。</target>
        </trans-unit>
        <trans-unit id="fcaf285fe223ac76c6b6f3a248ca791f9480d826" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this lock.</source>
          <target state="translated">试图获得这个锁。</target>
        </trans-unit>
        <trans-unit id="ed9809bcb2ab4f39482ae3c8ecc3990c35b19e02" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this rwlock with shared read access.</source>
          <target state="translated">试图以共享读取权限获取此rwlock。</target>
        </trans-unit>
        <trans-unit id="60ca78e1d1551297af7765e326760c4a38aa394c" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory.</source>
          <target state="translated">试图分配一个内存块。</target>
        </trans-unit>
        <trans-unit id="943f34bb668f31f44c32b4ace4e03989407198f9" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocator#tymethod.allocate&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试分配一块内存。&lt;a href=&quot;alloc/trait.allocator#tymethod.allocate&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="855d837817da86285b7a962a1f7fe2fb0ca3b0f2" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试分配一块内存。&lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c43d8666b34161b53b0b2ccf4916af8bde88930" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocator#tymethod.allocate&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试分配一块内存。&lt;a href=&quot;trait.allocator#tymethod.allocate&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cba17f171bdff89eb9e4d13d3205c5589ee7c0ea" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试分配一块内存。&lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa06f6d37e15f994598953d5d55e85873c353cbb" translate="yes" xml:space="preserve">
          <source>Attempts to collect the exit status of the child if it has already exited.</source>
          <target state="translated">如果孩子已经退出,试图收集孩子的退出状态。</target>
        </trans-unit>
        <trans-unit id="c1be452e1098fe5e2ba823c663805fe4f191d856" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0f700a71652c58da7326026511c609bb65c78a5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1b8bfe658e12622625c1e875a019db8830b0989" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66a76479bea9155fc85828e929db52c84fd63e6c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b97a798e91eb0541c3e3c246eb5e2ac5797cb455" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed691c14807b35b2f2548e2bc752f978c9b573b3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="468a506dd2d83e7c4d19f2315c61b797dc6e4d81" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="501645681c486dcfde763f239c9dbc39c9a89e74" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e87e26b0a7cd242115748e46f0ec96044936078e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a0d914b6e10991069d8605388d14c2b1ca592cd" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="958ed88b5c4639ba37034945d4fa7653d11ec14d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be612cdd6f48c673bcc19746b3317e990d42bddc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c356c6158c8679c2d029abe3620f468bf5b9b89" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42ea0a6247bb234c0382208391062366c8d45afa" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de4b3bab90d338dc97a29e174b6ac89affad0eee" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3306b6d8338537145c4e522fa6d3095a838e24ed" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b8c226a4f3a2e9faf3bd2edc42cfa8c056aa1dc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2350a1a3377e42242cdfb3bcc58bf4230d39faee" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="616abf596e103379ba7981d5f1e76f05a2ea5666" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f894e5fc7159364d10324e42a2aabd76a1311686" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0ae0dea78c18426532483b357c55d9190d0c56e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ef3839c406eb138bd48f980d20053dec4a89576" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18c41b12b6a5c51bf92010b091987428554830e8" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5448bf065e3955c9eea9670b86f542b60f1a0d99" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c5994e4c20d71914f91892cc5ecb435c7068406" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c142214aae8a432d7a06e49f1095d64d5abcf8e1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6debd548d7dfbbbf4dd441963174cff21d7cdf02" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5bd3db3824015309ca5994329cb635606bb61e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9e3ad073d959cecc0ef2f46909df5654f941abe" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27970ce49dac2a260596044481b8209701cc6df9" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cc731c548e3edd60d482acb352eb954334d827f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eaf1693e06446e1b570049dea824ca2f5de4f983" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbf21f7180107143b1c2df0ada7adb608ce576f5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="933cccb563bf70c8384b3537cf5d53af66522f2f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b1923808fa8774e72e6b98f0d83b066dadba4e2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="354ab0355cf5bb942ae945004201e3e00a7b805c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1efb3585f71154fa405501c22aeb01a824f8ab1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c157007b3ce40ab86f83ee061270c2516fbee74c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a3363ae51b3ea763ca696b60555078ab17bcbb4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74c1a1e7cdabd9277cf3f6090aec0cbb69fbae9d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1fa909a8d07ec9bebd2c3a4ba3244aa21e756ab" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fc706f3890ff34068fa3987549fc9e943e12ee7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9406edc100eab7a11042f495f5605472cde3da93" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroI8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9302879ee5829e1588c324186708b8a56fd80bf6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b776a75cae811bf723255d190f55f89b79a29f17" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="332b91f901664ebad9ee86d115e69f5a7a3b4d2e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9f1ac4806f54fa95041af1e83978837424908c0" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9382ddfacff70da4aaa8665a550fdda9aeffbdbe" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30cfff31cec5836c2d435b155797b06f97a88b5a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79e1a0344dcbdab94d2a5a137db0b6fe3077cc05" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b5d4e575e612dc8137f25de68e1c8c2bca6bb80" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0813f21e382c2efbc0af883a820eed2568b9960b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93fb19758341f597fd85cf5eff51cea75139832f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ec588e739f156798bddcb79b1a4f397464f2ee1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroIsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9cb3c9348ff015679d375f740e5de8691a989ad" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78453501b58efe0df37ba60dce757e854979bf0b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1754f440af8e327e3628892e889e890ca0fdfa7a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04f7b535be0370cddd62901980eb0ddf9e3fbcef" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e99899bbe257c97c7294c60c8cbb6dcdaba0937c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50ffacd53f0d563c90eca54db4e3068e8ac7bc58" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c32f0af0599976a74621043264a001a3e32ccab3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99847ce375f1c7bf52ad9dbf9cbe8ebc71c7e0d1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5abc78a9982271a77eb82cbdd6f2e2a5c397b7e8" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c394131db124e9071401792a8209e92dd32cde6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0859484eecde175859b2793704416213e22b608" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72fdb2a4fa84fd42a73a35812e8216884b62fceb" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06fdd2383cf95915cfbafeedd94c6cf3ece1cda1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b8ba1870526b34b3010dfda32d9e6ef25b46c3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="609415cf60341744050aa964021a2dbc6757bce9" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e3cfcd25580562f26787f2a4ece451df14e3410" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22e09395ec650cc77cefa22bbdfa6829f42f4235" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d6c92d747eecea95deef0df11e2de577f89b584" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd6a16a046a47e51b8dbbc17c05fb83363da4079" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="681e0c5dd009397d090a42219e25007f044800b1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbde01dde5e3f3012cf4334646a7f5ef28b672b2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac4a8de77e7ee61e1fc27cc89dab1a66ef82bc93" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ce329fa4a9ee415c158ac8a1274f6e57fb2e20" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1abe67a3e4364a619efb676e5daa3d020ddb2d3f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9bf65adb8592efb46990546bc8cbe35b0283a56" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b6551a1616534f8c2d695ae7db8375e577d6398" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08c2cbaf513eb994bd548c282a61f57637c77f67" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d6851d41e88cb2aaa40c97ac167640ba1262eb3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35ddc3e3dfd9a428705e36e86a5e0594a1b9eff7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60905ee844e93f0259575760c3d1354fd6ee0145" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34b553e368c520708ccfbe33c562a7aac19b19ea" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bbbce1f0f87a53359eb132f6a57b8badd4665c5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroU8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adc18f3bf4b5cd397ebe0fa08f9b0234fe5f4691" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a8feff95241828b618a9f8f2cedee35cf34dbc2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39ef28f0274fbbc17ccd2ed7051a33a172b5845b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bee2c6e9925f66c4b7aa5fa6a1b124e2eb59e5e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f97a59c56e1d9e1b3d6440f468bdeaa5169d29a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="915108f700cb0a82a36eec28483bf51e615c31a7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9d60598f796fd4c7d2797827f8cc377d4829f91" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a888711092f4db9142baf49d1d094a1588d95bc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96596905fbde7e740d6654a8d248b25e64e80725" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a42cd22a3bffa9bab2837c2ad66ee139ebc73564" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94d1fb95e25a0fa6c34caf0d382246658d283ed6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;NonZeroUsize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ba2351b2e57e9559c0f3714a76ac923ea85c4c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;i128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2730452bbdf6d0154f196dd3387e5268fcbaae6d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;i16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89a676b16e76690126c8c689d7093c8a36a6dc3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;i32&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af2f75ee1f964bb69b3471df2010cd26d4f8b3c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;i64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c93de3bc4194ab8f5cef5b860227606b9963f2e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;i8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroI8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6042fa62c1123d272cfaedcf34e40785b595efa5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;isize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;isize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroIsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d44685c697bf86bf627255f318a92026c3067b36" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;u128&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f6c21bb3f0a85bb02b720c0facffc143df545d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;u16&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f25fe04e2aca5c5faadb4cc9021f2c2472cc8a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">试图转换 &lt;code&gt;u32&lt;/code&gt; 到 &lt;code&gt;NonZeroU32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbf97d063f75afad6228d1db287eb0de45a1ab04" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;u64&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89d08d408000b79c0c0f0951f917eed73ebef3a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;u8&lt;/code&gt; 转换为 &lt;code&gt;NonZeroU8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cee9eaea9548154103d038cde6240ee1cc68830" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;usize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;usize&lt;/code&gt; 转换为 &lt;code&gt;NonZeroUsize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d9e42b5d35e242781f009f21f3c5ea257d9b8d7" translate="yes" xml:space="preserve">
          <source>Attempts to converts a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; to a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">尝试将&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; 转换为&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d17c0e55fb5767927f25b2be2aaccc4cffbef7d" translate="yes" xml:space="preserve">
          <source>Attempts to downcast the box to a concrete type.</source>
          <target state="translated">试图将盒子降为具体类型。</target>
        </trans-unit>
        <trans-unit id="2067ade47b4e19fcd748b5622bcd5a578000fa70" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">尝试扩展 &lt;code&gt;ptr&lt;/code&gt; 引用的分配以适合 &lt;code&gt;new_size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f0524b8bf45261cb2e5192b808b5a4a85102e03" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试扩展 &lt;code&gt;ptr&lt;/code&gt; 引用的分配以适合 &lt;code&gt;new_size&lt;/code&gt; 。&lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="610fb844291f2a525fe83689f6eb20dc7f8fe95f" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block.</source>
          <target state="translated">试图扩展内存块。</target>
        </trans-unit>
        <trans-unit id="6aa5063683af7571841f72f0953d587299850850" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocator#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试扩展内存块。&lt;a href=&quot;alloc/trait.allocator#method.grow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27c873a148fefc84fd64a13dc7df4ae1e7fa3719" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试扩展内存块。&lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54633b194aa39ce8f38436cb1feb8f160a116984" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocator#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试扩展内存块。&lt;a href=&quot;trait.allocator#method.grow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adef0a0225d086130a40a297ad3ad900429332c4" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试扩展内存块。&lt;a href=&quot;trait.allocref#method.grow&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14aa482507a26cdd1d3724ec04b0d14909b4ce76" translate="yes" xml:space="preserve">
          <source>Attempts to lock this rwlock with exclusive write access.</source>
          <target state="translated">试图将此rwlock锁定为独有的写权限。</target>
        </trans-unit>
        <trans-unit id="3e149a02e4c5943a78110a9fe37e7dfdc1377a23" translate="yes" xml:space="preserve">
          <source>Attempts to open a file in read-only mode.</source>
          <target state="translated">试图以只读模式打开一个文件。</target>
        </trans-unit>
        <trans-unit id="ce00391cd1170f4f9f1ed2dc7adb3e45ca14e46a" translate="yes" xml:space="preserve">
          <source>Attempts to return a pending value on this receiver without blocking.</source>
          <target state="translated">试图在该接收机上返回一个待定值,而不进行阻塞。</target>
        </trans-unit>
        <trans-unit id="88500c10aaa3c7978ed8857be5643440673d4380" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel without blocking.</source>
          <target state="translated">试图在这个通道上发送一个值而不被阻断。</target>
        </trans-unit>
        <trans-unit id="44fed3b4d1c2db46234c4d30a1056c0ccd124c87" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel, returning it back if it could not be sent.</source>
          <target state="translated">试图在这个通道上发送一个值,如果不能发送则返回。</target>
        </trans-unit>
        <trans-unit id="6da3e262b2372fb386666634b5d39f9d3f7bb80a" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">尝试缩小 &lt;code&gt;ptr&lt;/code&gt; 引用的分配以适合 &lt;code&gt;new_size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9dd72c543bd49d83f78f0fdf1367b07147238f9" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试缩小 &lt;code&gt;ptr&lt;/code&gt; 引用的分配以适合 &lt;code&gt;new_size&lt;/code&gt; 。&lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08f5853268ae278f691eb7a82a1231c55496e49d" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block.</source>
          <target state="translated">试图缩小内存块。</target>
        </trans-unit>
        <trans-unit id="c648c706ee8142ae651a14916b0ab8f1c626c9d5" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocator#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试缩小内存块。&lt;a href=&quot;alloc/trait.allocator#method.shrink&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b70a3bb894ec313a60c83cc036390a2df8753cb7" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试缩小内存块。&lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b1e6da2468f6f1396385de5f3580dfdb6c5c166" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocator#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试缩小内存块。&lt;a href=&quot;trait.allocator#method.shrink&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e65f083a95479e0e7fff8e23938d5ab69fdc1f" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试缩小内存块。&lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d431ee47732f5fda5d822308d953fb6c4ab546af" translate="yes" xml:space="preserve">
          <source>Attempts to sync all OS-internal metadata to disk.</source>
          <target state="translated">试图将所有操作系统内部的元数据同步到磁盘上。</target>
        </trans-unit>
        <trans-unit id="bd1357cf9c16c8860cced8547ac6ac2266fff48b" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="translated">尝试将 &lt;code&gt;Weak&lt;/code&gt; 指针升级为&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;，如果成功，则延迟内部值的下降。</target>
        </trans-unit>
        <trans-unit id="e1a28bf0ca8943d3102fb17a5f930dbd42c32e93" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">尝试将 &lt;code&gt;Weak&lt;/code&gt; 指针升级到&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;，如果成功，则延长该值的寿命。</target>
        </trans-unit>
        <trans-unit id="3f7dd7ca12e8b115613fa365887978f9fb146c24" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="translated">尝试将 &lt;code&gt;Weak&lt;/code&gt; 指针升级到&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;，如果成功，则延迟内部值的删除。</target>
        </trans-unit>
        <trans-unit id="c10f653d6058260dd8df6597f6fc625f0e90a7a2" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">尝试将 &lt;code&gt;Weak&lt;/code&gt; 指针升级到&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;，如果成功，则延长该值的生存期。</target>
        </trans-unit>
        <trans-unit id="4ed9981b4c97d4946f7cc66f3d69625251a285c0" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if &lt;code&gt;deadline&lt;/code&gt; is reached.</source>
          <target state="translated">尝试等待此接收器上的值，如果相应的信道已挂断或已达到 &lt;code&gt;deadline&lt;/code&gt; ，则返回错误。</target>
        </trans-unit>
        <trans-unit id="eea7708f089d17a724b4fe150c8a5b22b7b7cd15" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">尝试等待此接收器上的值，如果相应的信道已挂断，或者等待时间超过 &lt;code&gt;timeout&lt;/code&gt; ，则返回错误。</target>
        </trans-unit>
        <trans-unit id="c5624ed9b3f4c32e9214ed479d11bee18fe54f2a" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.</source>
          <target state="translated">试图在该接收机上等待一个值,如果对应的通道已经挂断,则返回错误。</target>
        </trans-unit>
        <trans-unit id="66681ba198baa628940b6e0e8d1d21d555ae1a8d" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer.</source>
          <target state="translated">试图将整个缓冲区写入该写入器。</target>
        </trans-unit>
        <trans-unit id="50c44c33216c75388385c7158cbb2db3b18cd276" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将整个缓冲区写入此写入器。&lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb65a661c9940f60efcdfd42e570120d00134516" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将整个缓冲区写入此写入器。&lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7537ca8f100350d628ddd2455b7d2b9261e91786" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将整个缓冲区写入此写入器。&lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a079954569cfca76bb04671c6eef0de6f2845b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将整个缓冲区写入此写入器。&lt;a href=&quot;trait.write#method.write_all&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4550331cd75411aa797d05589ea44d59948931" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset.</source>
          <target state="translated">试图从给定的偏移量开始写入整个缓冲区。</target>
        </trans-unit>
        <trans-unit id="bd08d9b38e39a23845ecac7733a7135e68b5844b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试从给定的偏移量开始写入整个缓冲区。&lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd154a661d834b07894c77674ab8ed918e6d062" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer.</source>
          <target state="translated">试图将多个缓冲区写入这个写入器。</target>
        </trans-unit>
        <trans-unit id="fc422df0d6aeefc153e9d11191c7acdab0fee066" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将多个缓冲区写入此编写器。&lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef049b1e411811d76553b0e75329cbd0d79e8485" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将多个缓冲区写入此编写器。&lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59af638438e522a4fe5eaeba810e068e6c90b8b0" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将多个缓冲区写入此编写器。&lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d6a58aa82ce87e3367d27cafec071fe08afba77" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">尝试将多个缓冲区写入此编写器。&lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63578c033690b22f88448dc9020fc65119c91cf5" translate="yes" xml:space="preserve">
          <source>Attribute contains same meta item more than once.</source>
          <target state="translated">属性包含同一个元项目超过一次。</target>
        </trans-unit>
        <trans-unit id="645ef54c5f28a9cf578382e9466764d3ebe4899c" translate="yes" xml:space="preserve">
          <source>Attribute macros</source>
          <target state="translated">属性宏</target>
        </trans-unit>
        <trans-unit id="1a7e3b192d591463acc213e348e2d3be95158e41" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">属性宏由具有 &lt;code&gt;proc_macro_attribute&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;的&lt;a href=&quot;visibility-and-privacy&quot;&gt;公共&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;函数&lt;/a&gt;定义，该属性具有 &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 的签名。第一个&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;是属性名称之后的定界标记树，不包括外部定界符。如果将属性写为裸属性名称，则属性&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;为空。第二个&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;是其余&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;包括其他&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;的&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;。返回的&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;将&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;替换为任意数量的&lt;a href=&quot;items&quot;&gt;物品&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="859156ebbcd8a20df68582e72c9cb8ebb2f8d6d9" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">属性宏由具有 &lt;code&gt;proc_macro_attribute&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;的&lt;a href=&quot;visibility-and-privacy&quot;&gt;公共&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;函数&lt;/a&gt;定义，该属性具有 &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 的签名。第一个&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;是属性名称之后的定界标记树，不包括外部定界符。如果将属性写为裸属性名称，则属性&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;为空。第二个&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;是该&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;的其余部分，包括该&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;上的其他&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;。返回的&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;用任意数量的替换该&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;。这些宏不能扩展为定义新的 &lt;code&gt;macro_rules&lt;/code&gt; 样式宏的语法。</target>
        </trans-unit>
        <trans-unit id="e9cdb4472ce392123fa434d8e8286aab92c7c80b" translate="yes" xml:space="preserve">
          <source>Attribute-like macros</source>
          <target state="translated">类似属性的宏</target>
        </trans-unit>
        <trans-unit id="59290a10bc07737a4a9b4b98cbfa7a104e8da35e" translate="yes" xml:space="preserve">
          <source>Attribute-like macros are similar to custom derive macros, but instead of generating code for the &lt;code&gt;derive&lt;/code&gt; attribute, they allow you to create new attributes. They&amp;rsquo;re also more flexible: &lt;code&gt;derive&lt;/code&gt; only works for structs and enums; attributes can be applied to other items as well, such as functions. Here&amp;rsquo;s an example of using an attribute-like macro: say you have an attribute named &lt;code&gt;route&lt;/code&gt; that annotates functions when using a web application framework:</source>
          <target state="translated">类似于属性的宏类似于自定义的派生宏，但是它们无需为 &lt;code&gt;derive&lt;/code&gt; 属性生成代码，而是允许您创建新的属性。它们也更加灵活：仅 &lt;code&gt;derive&lt;/code&gt; 适用于结构和枚举；属性也可以应用于其他项，例如功能。这是一个使用类似属性的宏的示例：假设您有一个名为 &lt;code&gt;route&lt;/code&gt; 的属性，该属性在使用Web应用程序框架时会注释函数：</target>
        </trans-unit>
        <trans-unit id="ec087a512ee5c8fbe6233f1c1cc119ebd6524585" translate="yes" xml:space="preserve">
          <source>Attribute-like macros that define custom attributes usable on any item</source>
          <target state="translated">类似属性的宏,定义了可用于任何项目的自定义属性。</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="873679be0cfb954acbd8355a7b353607aec111e8" translate="yes" xml:space="preserve">
          <source>Attributes can be classified into the following kinds:</source>
          <target state="translated">属性可分为以下几种:</target>
        </trans-unit>
        <trans-unit id="f75246581fb116635159a5829418eadb80ff6d3d" translate="yes" xml:space="preserve">
          <source>Attributes may be applied to many things in the language:</source>
          <target state="translated">属性可以应用于语言中的许多事物。</target>
        </trans-unit>
        <trans-unit id="54528912cd579e0bc00be1a8a68e351287624bb1" translate="yes" xml:space="preserve">
          <source>Attributes on Implementations</source>
          <target state="translated">实施的属性</target>
        </trans-unit>
        <trans-unit id="37b3e9d71f1e2b7a16d851acde890909a1eeac05" translate="yes" xml:space="preserve">
          <source>Attributes on Modules</source>
          <target state="translated">模块的属性</target>
        </trans-unit>
        <trans-unit id="bd970fc906dcf4e6b3d5342f7f8f7b6b3fc07d29" translate="yes" xml:space="preserve">
          <source>Attributes on Statements</source>
          <target state="translated">语句的属性</target>
        </trans-unit>
        <trans-unit id="002821d69ecf6475cc851545267b8d3000e1ad75" translate="yes" xml:space="preserve">
          <source>Attributes on block expressions</source>
          <target state="translated">块表达式的属性</target>
        </trans-unit>
        <trans-unit id="9c665fd3a622574987a78d02ed515c34731bae9e" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters</source>
          <target state="translated">关闭参数的属性</target>
        </trans-unit>
        <trans-unit id="9b9724999b0840379dc53e44bc7f9fc3b9f933c5" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">闭包参数的属性遵循与&lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;常规函数参数&lt;/a&gt;相同的规则和限制。</target>
        </trans-unit>
        <trans-unit id="ceeb23e9fab4cfc5da27d608e1b53f610954cf73" translate="yes" xml:space="preserve">
          <source>Attributes on extern blocks</source>
          <target state="translated">外部块的属性</target>
        </trans-unit>
        <trans-unit id="2b100159215337704a6b1e09760f5eccf7526a5d" translate="yes" xml:space="preserve">
          <source>Attributes on extern function parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">外部函数参数的属性遵循与&lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;常规函数参数&lt;/a&gt;相同的规则和限制。</target>
        </trans-unit>
        <trans-unit id="59c13f89c0293ca7012e37e58c92591846eac3f7" translate="yes" xml:space="preserve">
          <source>Attributes on function parameters</source>
          <target state="translated">函数参数的属性</target>
        </trans-unit>
        <trans-unit id="ed27ab14062c4e9a4e3408735f20ce008b94ed1f" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters</source>
          <target state="translated">函数指针参数的属性</target>
        </trans-unit>
        <trans-unit id="d19964d112392f9f4c6dafbc3caa5ef3b3d5eb10" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">函数指针参数的属性遵循与&lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;常规函数参数&lt;/a&gt;相同的规则和限制。</target>
        </trans-unit>
        <trans-unit id="3cccaf98e2daf69778514e782644b524ef8bcdb7" translate="yes" xml:space="preserve">
          <source>Attributes on functions</source>
          <target state="translated">职能的属性</target>
        </trans-unit>
        <trans-unit id="05e9060a13a0e0d138adc8680df67a664480dcc8" translate="yes" xml:space="preserve">
          <source>Attributes on match arms</source>
          <target state="translated">火柴臂的属性</target>
        </trans-unit>
        <trans-unit id="2af6ac2f621f1343b06367e7a182dd005ff55bf7" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters</source>
          <target state="translated">方法参数的属性</target>
        </trans-unit>
        <trans-unit id="09d4e80c9597ea7a33de2f4472d2c8f5b6ac76e0" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">方法参数的属性遵循与&lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;常规函数参数&lt;/a&gt;相同的规则和限制。</target>
        </trans-unit>
        <trans-unit id="4692270821bce03e7c9c56f2250b4d84c0ed4e73" translate="yes" xml:space="preserve">
          <source>Augments &lt;code&gt;AllocErr&lt;/code&gt; with a CapacityOverflow variant.</source>
          <target state="translated">使用CapacityOverflow变体增强 &lt;code&gt;AllocErr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18a0388aaf485c373d9fa2601ae76a1e2a8efdf4" translate="yes" xml:space="preserve">
          <source>Austin Group Bugzilla</source>
          <target state="translated">奥斯汀集团Bugzilla</target>
        </trans-unit>
        <trans-unit id="e84cdcfde23e335b70dccbea7484975e25932774" translate="yes" xml:space="preserve">
          <source>Auto Trait Implementations</source>
          <target state="translated">自动特征实施</target>
        </trans-unit>
        <trans-unit id="3210ce5fd6c71ac203dc3858abcda035931c425a" translate="yes" xml:space="preserve">
          <source>Auto implementors</source>
          <target state="translated">自动执行器</target>
        </trans-unit>
        <trans-unit id="883a358e80c549bb53d94b1393e3b00efd025f86" translate="yes" xml:space="preserve">
          <source>Auto traits</source>
          <target state="translated">汽车特征</target>
        </trans-unit>
        <trans-unit id="907a84f140f8fccdc36e6967fab33354d93f68e0" translate="yes" xml:space="preserve">
          <source>Auto traits can also have negative implementations, shown as &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; in the standard library documentation, that override the automatic implementations. For example &lt;code&gt;*mut T&lt;/code&gt; has a negative implementation of &lt;code&gt;Send&lt;/code&gt;, and so &lt;code&gt;*mut T&lt;/code&gt; is not &lt;code&gt;Send&lt;/code&gt;, even if &lt;code&gt;T&lt;/code&gt; is. There is currently no stable way to specify additional negative implementations; they exist only in the standard library.</source>
          <target state="translated">自动特征也可以具有否定的实现，在标准库文档中显示为 &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; ，可以覆盖自动实现。例如， &lt;code&gt;*mut T&lt;/code&gt; 具有否定的 &lt;code&gt;Send&lt;/code&gt; 方法，因此 &lt;code&gt;*mut T&lt;/code&gt; 不是 &lt;code&gt;Send&lt;/code&gt; 方法，即使 &lt;code&gt;T&lt;/code&gt; 是。当前没有稳定的方法来指定其他否定实现。它们仅存在于标准库中。</target>
        </trans-unit>
        <trans-unit id="eed6125b479d147f9973b57bfcd959c6cdf11e7c" translate="yes" xml:space="preserve">
          <source>Auto traits cannot have methods or associated items. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">自动特征不能包含方法或相关项目。有关更多信息，请参阅&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in内置特征RFC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="589d3531f6899aa76d5a037b26ecc86cf31af6da" translate="yes" xml:space="preserve">
          <source>Auto traits may be added as an additional bound to any &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt;, even though normally only one trait is allowed. For instance, &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; is a valid type.</source>
          <target state="translated">即使通常只允许一个特征，也可以将自动特征作为附加绑定添加到任何&lt;a href=&quot;types/trait-object&quot;&gt;特征对象&lt;/a&gt;。例如， &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; 是有效的类型。</target>
        </trans-unit>
        <trans-unit id="7ab019d8f27eff675f0469b46eedbbd5bc764f0c" translate="yes" xml:space="preserve">
          <source>Auto traits such as Send and Sync are an exception to this rule: It's possible to have bounds of one non-builtin trait, plus any number of auto traits. For example, the following compiles correctly:</source>
          <target state="translated">自动特征(如发送和同步)是这一规则的例外:可以有一个非内置特征的边界,加上任意数量的自动特征。例如,下面的编译是正确的。</target>
        </trans-unit>
        <trans-unit id="291824a57cec52e3b37ba600a0c8891145191849" translate="yes" xml:space="preserve">
          <source>Auto-&lt;code&gt;deref&lt;/code&gt; is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent</source>
          <target state="translated">自动 &lt;code&gt;deref&lt;/code&gt; 是不可取的。例如，区分智能指针本身的方法和指针的引用对象</target>
        </trans-unit>
        <trans-unit id="07a06ac20697a76a3d6c77f425115fda11438cdd" translate="yes" xml:space="preserve">
          <source>Automatic Formatting with &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt; 自动格式化</target>
        </trans-unit>
        <trans-unit id="fd22060c7b367de18d29110de1ffaa7a8381ad30" translate="yes" xml:space="preserve">
          <source>Available features</source>
          <target state="translated">可用功能</target>
        </trans-unit>
        <trans-unit id="67ac2af5490a5a8399786f2d57a2cb9f4e9a1f32" translate="yes" xml:space="preserve">
          <source>Await expressions</source>
          <target state="translated">等待表达</target>
        </trans-unit>
        <trans-unit id="e627821b85e700b6a817bfb93d0fa75ca6938994" translate="yes" xml:space="preserve">
          <source>Await expressions are legal only within an &lt;a href=&quot;block-expr#async-context&quot;&gt;async context&lt;/a&gt;, like an &lt;a href=&quot;../items/functions#async-functions&quot;&gt;&lt;code&gt;async fn&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;block-expr#async-blocks&quot;&gt;&lt;code&gt;async&lt;/code&gt; block&lt;/a&gt;. They operate on a &lt;a href=&quot;../../std/future/trait.future&quot;&gt;future&lt;/a&gt;. Their effect is to suspend the current computation until the given future is ready to produce a value.</source>
          <target state="translated">等待表达式仅在&lt;a href=&quot;block-expr#async-context&quot;&gt;异步上下文中&lt;/a&gt;是合法的，如&lt;a href=&quot;../items/functions#async-functions&quot;&gt; &lt;code&gt;async fn&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;block-expr#async-blocks&quot;&gt; &lt;code&gt;async&lt;/code&gt; 块&lt;/a&gt;。他们为&lt;a href=&quot;../../std/future/trait.future&quot;&gt;未来而努力&lt;/a&gt;。它们的作用是暂停当前计算，直到给定的将来准备产生值为止。</target>
        </trans-unit>
        <trans-unit id="25bea30bca4696d831be0e14c1144f604b2efac9" translate="yes" xml:space="preserve">
          <source>Awesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.</source>
          <target state="translated">真棒!我们现在有了一个简单的网络服务器,只用了大约40行Rust代码,就能响应一个页面内容的请求,并对所有其他请求做出404响应。现在,我们用大约40行Rust代码制作了一个简单的Web服务器,它可以用一个页面的内容来响应一个请求,并以404响应来响应所有其他请求。</target>
        </trans-unit>
        <trans-unit id="799c6a1aafdeb5752f0a6da17b30526204336545" translate="yes" xml:space="preserve">
          <source>Awesome! With one tiny final tweak, we will finish the guessing game. Recall that the program is still printing the secret number. That worked well for testing, but it ruins the game. Let&amp;rsquo;s delete the &lt;code&gt;println!&lt;/code&gt; that outputs the secret number. Listing 2-6 shows the final code.</source>
          <target state="translated">太棒了！通过最后的一个小调整，我们将完成猜谜游戏。回想一下该程序仍在打印密码。在测试中效果很好，但是却毁了游戏。让我们删除 &lt;code&gt;println!&lt;/code&gt; 输出密码。清单2-6显示了最终代码。</target>
        </trans-unit>
        <trans-unit id="358de401329e3394893b21243300f3a3bf6b4d17" translate="yes" xml:space="preserve">
          <source>B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log&lt;sub&gt;2&lt;/sub&gt;n). However, in practice the way this is done is &lt;em&gt;very&lt;/em&gt; inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to at very least reconsider the BST strategy.</source>
          <target state="translated">B树表示高速缓存效率与实际最小化搜索中执行的工作量之间的根本折衷。从理论上讲，二分搜索树（BST）是排序图的最佳选择，因为完全平衡的BST执行查找元素所需的理论上最小的比较量（log &lt;sub&gt;2&lt;/sub&gt; n）。但是，实际上，对于现代计算机体系结构而言，完成此操作的效率&lt;em&gt;非常&lt;/em&gt;低。特别是，每个元素都存储在其自己的单独堆分配节点中。这意味着每个插入都会触发堆分配，并且每个比较都应该是缓存未命中。由于在实践中这些都是非常昂贵的事情，因此我们至少不得不重新考虑BST战略。</target>
        </trans-unit>
        <trans-unit id="4ce046eb7e16ef9995c1ff852988df751464fa48" translate="yes" xml:space="preserve">
          <source>BIN_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;]</source>
          <target state="translated">BIN_DIGIT：[ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="93c309eceddcd432100b37d2f21aed97ad5516a1" translate="yes" xml:space="preserve">
          <source>BIN_LITERAL :</source>
          <target state="translated">BIN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="1ce23e42f8a0fadda89f03bff4138edc76257e9f" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT</source>
          <target state="translated">BLOCK_COMMENT</target>
        </trans-unit>
        <trans-unit id="54d41dd6d7f607cbfdbd93df26df009dd384ea37" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT :</source>
          <target state="translated">BLOCK_COMMENT :</target>
        </trans-unit>
        <trans-unit id="46a2a0792f35fba20ff9af816bd7d67867d91ee5" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL</source>
          <target state="translated">BOOLEAN_LITERAL</target>
        </trans-unit>
        <trans-unit id="984b539364047c18d12aa2a5107f4ca7034f1745" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL :</source>
          <target state="translated">BOOLEAN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="25ed99c15ff33b077d8ef4f89cfb12043f799e5c" translate="yes" xml:space="preserve">
          <source>BTreeMap</source>
          <target state="translated">BTreeMap</target>
        </trans-unit>
        <trans-unit id="14b812dd3cb5eae3767a2df53640bea358a44ec3" translate="yes" xml:space="preserve">
          <source>BTreeMap::append</source>
          <target state="translated">BTreeMap::append</target>
        </trans-unit>
        <trans-unit id="4439b2dd76bd007a7ee702af3eca0f027a45eb09" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow</source>
          <target state="translated">BTreeMap::borrow</target>
        </trans-unit>
        <trans-unit id="a411a7ebcb50db356ed987a9d5f1ea3e6fb40efd" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow_mut</source>
          <target state="translated">BTreeMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="0e1837335635833d079465e2a07ece32097ef9ee" translate="yes" xml:space="preserve">
          <source>BTreeMap::clamp</source>
          <target state="translated">BTreeMap::clamp</target>
        </trans-unit>
        <trans-unit id="a5095900a69512f07d67a4318ed72ed754b7ec9a" translate="yes" xml:space="preserve">
          <source>BTreeMap::clear</source>
          <target state="translated">BTreeMap::clear</target>
        </trans-unit>
        <trans-unit id="d9dc0be9a162cd4c9a8d0d87ef461b431cc2996f" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone</source>
          <target state="translated">BTreeMap::clone</target>
        </trans-unit>
        <trans-unit id="b18aa414095cedffcf379ff71fa52f0f3e5a2e30" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_from</source>
          <target state="translated">BTreeMap::clone_from</target>
        </trans-unit>
        <trans-unit id="94cc1d51e045cecb444cb20cb07a89d16ef1abae" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_into</source>
          <target state="translated">BTreeMap::clone_into</target>
        </trans-unit>
        <trans-unit id="7fc5895f7f2221a66d3e8ff613cbb9e54a398512" translate="yes" xml:space="preserve">
          <source>BTreeMap::cmp</source>
          <target state="translated">BTreeMap::cmp</target>
        </trans-unit>
        <trans-unit id="10f80450d5f9791627fc6f70e8eea8d607e5abc1" translate="yes" xml:space="preserve">
          <source>BTreeMap::contains_key</source>
          <target state="translated">BTreeMap::contains_key</target>
        </trans-unit>
        <trans-unit id="237ebd61fd35b922ed92337aaeb092096989c551" translate="yes" xml:space="preserve">
          <source>BTreeMap::default</source>
          <target state="translated">BTreeMap::default</target>
        </trans-unit>
        <trans-unit id="67360895fa8faeb3288ff2a48f56ac5fb63f6cfa" translate="yes" xml:space="preserve">
          <source>BTreeMap::drop</source>
          <target state="translated">BTreeMap::drop</target>
        </trans-unit>
        <trans-unit id="e35986d9fdbf3de52b6c707270d8af046337a4b7" translate="yes" xml:space="preserve">
          <source>BTreeMap::entry</source>
          <target state="translated">BTreeMap::entry</target>
        </trans-unit>
        <trans-unit id="1fd856b6f3486469ed5b9716d4c0ef16fd26570a" translate="yes" xml:space="preserve">
          <source>BTreeMap::eq</source>
          <target state="translated">BTreeMap::eq</target>
        </trans-unit>
        <trans-unit id="2eb6b59d7803ce34a4aebcb1a5cebd29ebb2ace1" translate="yes" xml:space="preserve">
          <source>BTreeMap::extend</source>
          <target state="translated">BTreeMap::extend</target>
        </trans-unit>
        <trans-unit id="14a4894c2a33cba6f17b28aab882b15d8fa0507e" translate="yes" xml:space="preserve">
          <source>BTreeMap::fmt</source>
          <target state="translated">BTreeMap::fmt</target>
        </trans-unit>
        <trans-unit id="f8ff830626694a395da9bcdf07413636ef382d2a" translate="yes" xml:space="preserve">
          <source>BTreeMap::from</source>
          <target state="translated">BTreeMap::from</target>
        </trans-unit>
        <trans-unit id="40d5df351e6a78b82beed9049802e2600890cdef" translate="yes" xml:space="preserve">
          <source>BTreeMap::from_iter</source>
          <target state="translated">BTreeMap::from_iter</target>
        </trans-unit>
        <trans-unit id="42bc9380f48558951feaee861f324b3e97cc339c" translate="yes" xml:space="preserve">
          <source>BTreeMap::ge</source>
          <target state="translated">BTreeMap::ge</target>
        </trans-unit>
        <trans-unit id="fdc4bec6666f5d3bd604897331fbae31d76e02c5" translate="yes" xml:space="preserve">
          <source>BTreeMap::get</source>
          <target state="translated">BTreeMap::get</target>
        </trans-unit>
        <trans-unit id="10123fe58d4d51981db653bb17bb2c5bd1739f48" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_key_value</source>
          <target state="translated">BTreeMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="77ed844b0571d2308549c11d94f75218d5fc647d" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_mut</source>
          <target state="translated">BTreeMap::get_mut</target>
        </trans-unit>
        <trans-unit id="5aeca596bd768adcad438b3384e1977cf6475276" translate="yes" xml:space="preserve">
          <source>BTreeMap::gt</source>
          <target state="translated">BTreeMap::gt</target>
        </trans-unit>
        <trans-unit id="aef92c85a8fd215fe067e91d2cc54253d395041e" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash</source>
          <target state="translated">BTreeMap::hash</target>
        </trans-unit>
        <trans-unit id="cf9f5d8139a53420363c542bee60960cfdf4b73f" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash_slice</source>
          <target state="translated">BTreeMap::hash_slice</target>
        </trans-unit>
        <trans-unit id="9d0f58d76739deb0afae24d930afc89e886727c1" translate="yes" xml:space="preserve">
          <source>BTreeMap::index</source>
          <target state="translated">BTreeMap::index</target>
        </trans-unit>
        <trans-unit id="495b083c76694857a7d488aae7997ecc9b65b8fd" translate="yes" xml:space="preserve">
          <source>BTreeMap::insert</source>
          <target state="translated">BTreeMap::insert</target>
        </trans-unit>
        <trans-unit id="df183dd97d9b53936c9da9b18c544dcca3159f96" translate="yes" xml:space="preserve">
          <source>BTreeMap::into</source>
          <target state="translated">BTreeMap::into</target>
        </trans-unit>
        <trans-unit id="fc4dae35af80d2a787e9d9736c90c00c41315ce5" translate="yes" xml:space="preserve">
          <source>BTreeMap::into_iter</source>
          <target state="translated">BTreeMap::into_iter</target>
        </trans-unit>
        <trans-unit id="34464fef785cdf817cc72448c6950077bd889a22" translate="yes" xml:space="preserve">
          <source>BTreeMap::is_empty</source>
          <target state="translated">BTreeMap::is_empty</target>
        </trans-unit>
        <trans-unit id="f0cc7817b62e10040c3cb5b80461b8e39c5f0f79" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter</source>
          <target state="translated">BTreeMap::iter</target>
        </trans-unit>
        <trans-unit id="db8aca8da8288f53fcb308f1bc4fd2b4cacd2358" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter_mut</source>
          <target state="translated">BTreeMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="17e2b2189c6d71bc1225646a44b2dd0dedd8f47e" translate="yes" xml:space="preserve">
          <source>BTreeMap::keys</source>
          <target state="translated">BTreeMap::keys</target>
        </trans-unit>
        <trans-unit id="9d8ea9a92f24bfb8408ae08918cf32d255567986" translate="yes" xml:space="preserve">
          <source>BTreeMap::le</source>
          <target state="translated">BTreeMap::le</target>
        </trans-unit>
        <trans-unit id="69fcce80124f37da2a3264b3eb42f4416e80e515" translate="yes" xml:space="preserve">
          <source>BTreeMap::len</source>
          <target state="translated">BTreeMap::len</target>
        </trans-unit>
        <trans-unit id="9d226dd3e31bc04059d6780da00c779d71a0c07b" translate="yes" xml:space="preserve">
          <source>BTreeMap::lt</source>
          <target state="translated">BTreeMap::lt</target>
        </trans-unit>
        <trans-unit id="28cb2cc6fd2d128843e6d248dab95763d1010e94" translate="yes" xml:space="preserve">
          <source>BTreeMap::max</source>
          <target state="translated">BTreeMap::max</target>
        </trans-unit>
        <trans-unit id="e204c8d42ea76d6a7764ea9e58274fe5c3bb002d" translate="yes" xml:space="preserve">
          <source>BTreeMap::min</source>
          <target state="translated">BTreeMap::min</target>
        </trans-unit>
        <trans-unit id="b1f505e6c5b1bc5d067a0962eaa8081602c15a7a" translate="yes" xml:space="preserve">
          <source>BTreeMap::ne</source>
          <target state="translated">BTreeMap::ne</target>
        </trans-unit>
        <trans-unit id="553eafd890c40ffaf003fe540a734e36e0e18621" translate="yes" xml:space="preserve">
          <source>BTreeMap::new</source>
          <target state="translated">BTreeMap::new</target>
        </trans-unit>
        <trans-unit id="145a5aeffe19ab72f79646e0207cf635764ce346" translate="yes" xml:space="preserve">
          <source>BTreeMap::partial_cmp</source>
          <target state="translated">BTreeMap::partial_cmp</target>
        </trans-unit>
        <trans-unit id="db1a963168ea048f3f16233197ab263e60b2b507" translate="yes" xml:space="preserve">
          <source>BTreeMap::range</source>
          <target state="translated">BTreeMap::range</target>
        </trans-unit>
        <trans-unit id="3fee919f6744bdc9b2c87f1284d03bd737c587e9" translate="yes" xml:space="preserve">
          <source>BTreeMap::range_mut</source>
          <target state="translated">BTreeMap::range_mut</target>
        </trans-unit>
        <trans-unit id="f730581dfe02c1cd76fc7cd5f47e7e1ec7741713" translate="yes" xml:space="preserve">
          <source>BTreeMap::remove</source>
          <target state="translated">BTreeMap::remove</target>
        </trans-unit>
        <trans-unit id="a37cec31f9d8447344a2cb11b02572d5369eaecb" translate="yes" xml:space="preserve">
          <source>BTreeMap::split_off</source>
          <target state="translated">BTreeMap::split_off</target>
        </trans-unit>
        <trans-unit id="dd1d37326d92e085a2131397045e5968a461a29d" translate="yes" xml:space="preserve">
          <source>BTreeMap::to_owned</source>
          <target state="translated">BTreeMap::to_owned</target>
        </trans-unit>
        <trans-unit id="f4b12905aac1d13f63c54fa99e15b6d767c0949a" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_from</source>
          <target state="translated">BTreeMap::try_from</target>
        </trans-unit>
        <trans-unit id="8714974f74a34a38551f441ede21c0f7c7518766" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_into</source>
          <target state="translated">BTreeMap::try_into</target>
        </trans-unit>
        <trans-unit id="a562c087f2e1443045e2342f53c040d13fff0500" translate="yes" xml:space="preserve">
          <source>BTreeMap::type_id</source>
          <target state="translated">BTreeMap::type_id</target>
        </trans-unit>
        <trans-unit id="fef95975d5290dbd397d0e8018f6118b5b3445f8" translate="yes" xml:space="preserve">
          <source>BTreeMap::values</source>
          <target state="translated">BTreeMap::values</target>
        </trans-unit>
        <trans-unit id="b2e013070087a41fefec42e8c8812a309f157c48" translate="yes" xml:space="preserve">
          <source>BTreeMap::values_mut</source>
          <target state="translated">BTreeMap::values_mut</target>
        </trans-unit>
        <trans-unit id="529df1988796f2371c28af38a10631626e30c033" translate="yes" xml:space="preserve">
          <source>BTreeSet</source>
          <target state="translated">BTreeSet</target>
        </trans-unit>
        <trans-unit id="8863be2c232d70a5eeb4560459b4be5b2c0073a8" translate="yes" xml:space="preserve">
          <source>BTreeSet::append</source>
          <target state="translated">BTreeSet::append</target>
        </trans-unit>
        <trans-unit id="208528633622bb579ebc99572c1cd5b23c0ff3fe" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitand</source>
          <target state="translated">BTreeSet::bitand</target>
        </trans-unit>
        <trans-unit id="8c7f6d7d0bd709c67b308f34e3fdea1982987576" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitor</source>
          <target state="translated">BTreeSet::bitor</target>
        </trans-unit>
        <trans-unit id="b50a2f00b4df89c4fc2d8b38a2151e87a882ff0b" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitxor</source>
          <target state="translated">BTreeSet::bitxor</target>
        </trans-unit>
        <trans-unit id="cccc4bace80a38b5837fc997cc5c49754d796ac4" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow</source>
          <target state="translated">BTreeSet::borrow</target>
        </trans-unit>
        <trans-unit id="c3906f6d078061570593f2fe7b73fa2840328771" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow_mut</source>
          <target state="translated">BTreeSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4aa030ae00992ccd9a53652df9153409be56a2a2" translate="yes" xml:space="preserve">
          <source>BTreeSet::clamp</source>
          <target state="translated">BTreeSet::clamp</target>
        </trans-unit>
        <trans-unit id="7dbd4b9a7ec2f778cf457d4c27e677b1357aa7da" translate="yes" xml:space="preserve">
          <source>BTreeSet::clear</source>
          <target state="translated">BTreeSet::clear</target>
        </trans-unit>
        <trans-unit id="5b30f459964be9100787e5939f482cd8d7073397" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone</source>
          <target state="translated">BTreeSet::clone</target>
        </trans-unit>
        <trans-unit id="050795ce2f3842fb14df3b7b6623ddb813ac2ad6" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_from</source>
          <target state="translated">BTreeSet::clone_from</target>
        </trans-unit>
        <trans-unit id="53b99dc8a6c6498122bd0b00e8114abe2667c8af" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_into</source>
          <target state="translated">BTreeSet::clone_into</target>
        </trans-unit>
        <trans-unit id="de2ebfb73a4bfaed7ca14354db78235b93dbbcb9" translate="yes" xml:space="preserve">
          <source>BTreeSet::cmp</source>
          <target state="translated">BTreeSet::cmp</target>
        </trans-unit>
        <trans-unit id="3e582a8879cbba7048152fe7baf6d319ff38bc16" translate="yes" xml:space="preserve">
          <source>BTreeSet::contains</source>
          <target state="translated">BTreeSet::contains</target>
        </trans-unit>
        <trans-unit id="21aa5487bfe6b638ff9a362eaa67cb633fc82867" translate="yes" xml:space="preserve">
          <source>BTreeSet::default</source>
          <target state="translated">BTreeSet::default</target>
        </trans-unit>
        <trans-unit id="d7c44959c458f0838dfab77ed6b6f2add8735a14" translate="yes" xml:space="preserve">
          <source>BTreeSet::difference</source>
          <target state="translated">BTreeSet::difference</target>
        </trans-unit>
        <trans-unit id="16f9dc4e686355d372b64a80e877507f0084b34a" translate="yes" xml:space="preserve">
          <source>BTreeSet::eq</source>
          <target state="translated">BTreeSet::eq</target>
        </trans-unit>
        <trans-unit id="9edee760d67dfee35cacd64d97c0b93bcecc3eb7" translate="yes" xml:space="preserve">
          <source>BTreeSet::extend</source>
          <target state="translated">BTreeSet::extend</target>
        </trans-unit>
        <trans-unit id="afc2d0e53bf4c5f63abce2f83b8f542897205aac" translate="yes" xml:space="preserve">
          <source>BTreeSet::fmt</source>
          <target state="translated">BTreeSet::fmt</target>
        </trans-unit>
        <trans-unit id="50633916fcf03b37e42d17b8960dc21b40ef24a7" translate="yes" xml:space="preserve">
          <source>BTreeSet::from</source>
          <target state="translated">BTreeSet::from</target>
        </trans-unit>
        <trans-unit id="caf6d0db82051ce20ec56dd44cb0a17ec0b98d23" translate="yes" xml:space="preserve">
          <source>BTreeSet::from_iter</source>
          <target state="translated">BTreeSet::from_iter</target>
        </trans-unit>
        <trans-unit id="be2acc08fadae340b24bbbb5601dcd11b43af4ff" translate="yes" xml:space="preserve">
          <source>BTreeSet::ge</source>
          <target state="translated">BTreeSet::ge</target>
        </trans-unit>
        <trans-unit id="eebfcd72f45c81fa6bcc82833412cbba7e8dc9f6" translate="yes" xml:space="preserve">
          <source>BTreeSet::get</source>
          <target state="translated">BTreeSet::get</target>
        </trans-unit>
        <trans-unit id="692fcfa52c7940ed1e980094be254853ea4f2c35" translate="yes" xml:space="preserve">
          <source>BTreeSet::gt</source>
          <target state="translated">BTreeSet::gt</target>
        </trans-unit>
        <trans-unit id="0546ef8f63c560e2610c71f5ad1ae889cfa00795" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash</source>
          <target state="translated">BTreeSet::hash</target>
        </trans-unit>
        <trans-unit id="4f6fe8cde85490c116cbac4ed558e1916281d86a" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash_slice</source>
          <target state="translated">BTreeSet::hash_slice</target>
        </trans-unit>
        <trans-unit id="eda956eff955ffd9727eb53f2bf7e0715817c65d" translate="yes" xml:space="preserve">
          <source>BTreeSet::insert</source>
          <target state="translated">BTreeSet::insert</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
