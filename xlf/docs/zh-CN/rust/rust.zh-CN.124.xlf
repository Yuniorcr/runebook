<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="6f91f22939adae86de60c33d3fdb16972e0fb724" translate="yes" xml:space="preserve">
          <source>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It&amp;rsquo;s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that&amp;rsquo;s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</source>
          <target state="translated">访问堆中的数据比访问堆栈中的数据要慢，因为您必须遵循指针才能到达那里。如果现代处理器在内存中的跳动较少，则速度会更快。继续类推，考虑一家餐厅的服务器从许多桌子上接订单。在移至下一张桌子之前，将所有订单放在一张桌子上是最有效的。从表A取一个订单，然后从表B取一个订单，再从A取一个订单，再从B取一个订单，这将是一个非常慢的过程。同样，如果处理器可以处理与其他数据接近（如在堆栈上）而不是更远（如可以在堆上）的数据，则可以更好地完成工作。在堆上分配大量空间也可能需要时间。</target>
        </trans-unit>
        <trans-unit id="f239f31c4b24ce084fa39af1811c8d4fc4e10b36" translate="yes" xml:space="preserve">
          <source>Accessing non-&lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt;&lt;code&gt;static&lt;/code&gt; items is considered safe, but some restrictions apply. Most notably, the type of a &lt;code&gt;static&lt;/code&gt; value needs to implement the &lt;a href=&quot;marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait, ruling out interior mutability containers like &lt;a href=&quot;cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../reference/items/static-items&quot;&gt;Reference&lt;/a&gt; for more information.</source>
          <target state="translated">访问非&lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt; &lt;code&gt;static&lt;/code&gt; 项被认为是安全的，但存在一些限制。最值得注意的是， &lt;code&gt;static&lt;/code&gt; 值的类型需要实现&lt;a href=&quot;marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;特征，从而排除内部可变性容器（例如&lt;a href=&quot;cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; )&lt;/a&gt;。有关更多信息，请参见&lt;a href=&quot;../reference/items/static-items&quot;&gt;参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c20e5fc2ccd1b37aea7b882c463d596e55833b83" translate="yes" xml:space="preserve">
          <source>Accessing or Modifying a Mutable Static Variable</source>
          <target state="translated">访问或修改可变静态变量</target>
        </trans-unit>
        <trans-unit id="f13080b643bf72eee286858a8d7c3ab06b544915" translate="yes" xml:space="preserve">
          <source>Accessing unaligned fields directly with e.g. &lt;code&gt;packed.unaligned&lt;/code&gt; is safe however.</source>
          <target state="translated">但是，直接使用例如 &lt;code&gt;packed.unaligned&lt;/code&gt; 访问未对齐字段是安全的。</target>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="translated">Accuracy</target>
        </trans-unit>
        <trans-unit id="edc1ea5ed2dafd896f3493beb6ccad4cc0bfdeb7" translate="yes" xml:space="preserve">
          <source>Accurately documenting your packages will help other users know how and when to use them, so it&amp;rsquo;s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, &lt;code&gt;//&lt;/code&gt;. Rust also has a particular kind of comment for documentation, known conveniently as a &lt;em&gt;documentation comment&lt;/em&gt;, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to &lt;em&gt;use&lt;/em&gt; your crate as opposed to how your crate is &lt;em&gt;implemented&lt;/em&gt;.</source>
          <target state="translated">准确地记录您的软件包将帮助其他用户知道如何以及何时使用它们，因此值得花费时间来编写文档。在第3章中，我们讨论了如何使用两个斜杠 &lt;code&gt;//&lt;/code&gt; 注释Rust代码。Rust还具有一种特殊的&lt;em&gt;文档注释&lt;/em&gt;，通常称为&lt;em&gt;文档注释&lt;/em&gt;，它将生成HTML文档。HTML显示针对打算了解如何&lt;em&gt;使用&lt;/em&gt;板条箱而不是如何&lt;em&gt;实施&lt;/em&gt;板条箱的程序员的公共API项的文档注释的内容。</target>
        </trans-unit>
        <trans-unit id="e550137a8ad5bf001d7b174a7d5416351ea9a342" translate="yes" xml:space="preserve">
          <source>AcqRel</source>
          <target state="translated">AcqRel</target>
        </trans-unit>
        <trans-unit id="9d0903a32f177d84829c27dd98a7a4772b87dcc5" translate="yes" xml:space="preserve">
          <source>Acquire</source>
          <target state="translated">Acquire</target>
        </trans-unit>
        <trans-unit id="6568c1be017add88e3d012e02f41ac58f3e66045" translate="yes" xml:space="preserve">
          <source>Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier.</source>
          <target state="translated">获取--获取锁的障碍。随后的读写发生在屏障之后。</target>
        </trans-unit>
        <trans-unit id="af0f8ed1129c9ddf2134ed1c81b67a9bcb444f5a" translate="yes" xml:space="preserve">
          <source>Acquires a mutable reference to the owned form of the data.</source>
          <target state="translated">获取数据的自有形式的可变引用。</target>
        </trans-unit>
        <trans-unit id="ff3bc67bc303cd10ada41c07bb7edfd939dc9318" translate="yes" xml:space="preserve">
          <source>Acquires a mutex, blocking the current thread until it is able to do so.</source>
          <target state="translated">获取一个mutex,阻塞当前线程,直到它能够这样做。</target>
        </trans-unit>
        <trans-unit id="220a887115abad65ad7317817bfb97307bde3f84" translate="yes" xml:space="preserve">
          <source>Acquires a reference to the value in this TLS key.</source>
          <target state="translated">获取对该TLS密钥的引用。</target>
        </trans-unit>
        <trans-unit id="b36ce9a1808b77b91f2783ae64622ebad2a9cac9" translate="yes" xml:space="preserve">
          <source>Acquires the underlying &lt;code&gt;*mut&lt;/code&gt; pointer.</source>
          <target state="translated">获取基础的 &lt;code&gt;*mut&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="d4158950a66bbaeb08dff05a2933261e57fba1be" translate="yes" xml:space="preserve">
          <source>Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons. Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.</source>
          <target state="translated">获取当前可执行文件的路径是一个特定于平台的操作,可能会因为很多原因而失败。一些错误可能包括,但不限于,文件系统操作失败或一般系统调用失败。</target>
        </trans-unit>
        <trans-unit id="6d8f12c840c97a885d954c4ab3f89cfe39b2655d" translate="yes" xml:space="preserve">
          <source>Active and inert attributes</source>
          <target state="translated">主动和惰性属性</target>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="876182ad9012a6c08f789f1f68ad82ee5e8c99b7" translate="yes" xml:space="preserve">
          <source>Adaptor to chain together two readers.</source>
          <target state="translated">适配器可将两个读卡器连锁在一起。</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="5377ba24487df148115875083e9ad3100b466293" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;'static&lt;/code&gt; requirement to fix them:</source>
          <target state="translated">添加 &lt;code&gt;'static&lt;/code&gt; 要求&amp;rdquo;以对其进行修复：</target>
        </trans-unit>
        <trans-unit id="ca240252f7070cde72a7b776f50be32f04f2fc0d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;reject&lt;/code&gt; method that changes the post&amp;rsquo;s state from &lt;code&gt;PendingReview&lt;/code&gt; back to &lt;code&gt;Draft&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;reject&lt;/code&gt; 方法，将帖子的状态从 &lt;code&gt;PendingReview&lt;/code&gt; 更改回 &lt;code&gt;Draft&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0a1e3ef1e8493d789dbbf3d73ecb2a795cba8db" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="translated">添加仅一两个句子的描述，因为它将与您的箱子一起显示在搜索结果中。对于 &lt;code&gt;license&lt;/code&gt; 字段，您需要提供&lt;em&gt;许可证标识符value&lt;/em&gt;。在&lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux基金会的软件包数据交换（SPDX）&lt;/a&gt;列出你可以使用这个值的标识符。例如，要指定您已使用MIT许可证来许可您的板条箱，请添加 &lt;code&gt;MIT&lt;/code&gt; 标识符：</target>
        </trans-unit>
        <trans-unit id="da701486edb0442db89b592a10ae443b6f2f41f8" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;https://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="translated">添加只是一两个句子的描述，因为它会与您的箱子一起显示在搜索结果中。对于 &lt;code&gt;license&lt;/code&gt; 字段，您需要提供&lt;em&gt;许可证标识符value&lt;/em&gt;。在&lt;a href=&quot;https://spdx.org/licenses/&quot;&gt;Linux基金会的软件包数据交换（SPDX）&lt;/a&gt;列出你可以使用这个值的标识符。例如，要指定您已使用MIT许可证来许可您的板条箱，请添加 &lt;code&gt;MIT&lt;/code&gt; 标识符：</target>
        </trans-unit>
        <trans-unit id="c8594387539a0f2f7158c8875d4643cbc796d8e9" translate="yes" xml:space="preserve">
          <source>Add a getter function:</source>
          <target state="translated">增加一个getter函数。</target>
        </trans-unit>
        <trans-unit id="c563aa838f46cc2ef90bbf765435b526485acbf0" translate="yes" xml:space="preserve">
          <source>Add constraints that must be upheld to use an item.</source>
          <target state="translated">增加使用一个项目必须遵守的限制条件。</target>
        </trans-unit>
        <trans-unit id="0246ebd27a992d5a543dfa759b31edd44f7a3c51" translate="yes" xml:space="preserve">
          <source>Add credentials to the ancillary data.</source>
          <target state="translated">在辅助数据中增加凭证。</target>
        </trans-unit>
        <trans-unit id="290a7219146772de857baff40ff966c8c90e0f42" translate="yes" xml:space="preserve">
          <source>Add file descriptors to the ancillary data.</source>
          <target state="translated">在辅助数据中增加文件描述符。</target>
        </trans-unit>
        <trans-unit id="32aaebe9976898d3881c1a85d7d471c975e08486" translate="yes" xml:space="preserve">
          <source>Add more documentation to &lt;code&gt;ThreadPool&lt;/code&gt; and its public methods.</source>
          <target state="translated">向 &lt;code&gt;ThreadPool&lt;/code&gt; 及其公共方法添加更多文档。</target>
        </trans-unit>
        <trans-unit id="eac54db7026ed63754bb1e0481266ad4560b6f6c" translate="yes" xml:space="preserve">
          <source>Add tests of the library&amp;rsquo;s functionality.</source>
          <target state="translated">添加对该库功能的测试。</target>
        </trans-unit>
        <trans-unit id="584510db3cf556aee671c49783907c6c03f2abe4" translate="yes" xml:space="preserve">
          <source>Add the size of the field.</source>
          <target state="translated">添加字段的大小。</target>
        </trans-unit>
        <trans-unit id="e0ef2ba9581371a273c725b4584816d08df6e970" translate="yes" xml:space="preserve">
          <source>Add::add</source>
          <target state="translated">Add::add</target>
        </trans-unit>
        <trans-unit id="bd166591010a18220168b51497b0b5e84b157433" translate="yes" xml:space="preserve">
          <source>AddAssign</source>
          <target state="translated">AddAssign</target>
        </trans-unit>
        <trans-unit id="6eecef84103332763bac0f11d9776217926be6a9" translate="yes" xml:space="preserve">
          <source>AddAssign::add_assign</source>
          <target state="translated">AddAssign::add_assign</target>
        </trans-unit>
        <trans-unit id="47bc308a358cb72c871f66d0703a1751fa8c3e13" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;rand&lt;/code&gt; as a dependency in &lt;em&gt;Cargo.toml&lt;/em&gt; tells Cargo to download the &lt;code&gt;rand&lt;/code&gt; package and any dependencies from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and make &lt;code&gt;rand&lt;/code&gt; available to our project.</source>
          <target state="translated">在&lt;em&gt;Cargo.toml中将&lt;/em&gt; &lt;code&gt;rand&lt;/code&gt; 添加为依赖项，&lt;em&gt;使&lt;/em&gt; Cargo可以从&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;下载 &lt;code&gt;rand&lt;/code&gt; 包和任何依赖项，并使 &lt;code&gt;rand&lt;/code&gt; 对我们的项目可用。</target>
        </trans-unit>
        <trans-unit id="6951b086bf1e29a4acfdba85666aa713fe81534c" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;use&lt;/code&gt; and a path in a scope is similar to creating a symbolic link in the filesystem. By adding &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; in the crate root, &lt;code&gt;hosting&lt;/code&gt; is now a valid name in that scope, just as though the &lt;code&gt;hosting&lt;/code&gt; module had been defined in the crate root. Paths brought into scope with &lt;code&gt;use&lt;/code&gt; also check privacy, like any other paths.</source>
          <target state="translated">在范围内添加 &lt;code&gt;use&lt;/code&gt; 和路径类似于在文件系统中创建符号链接。通过在 &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; 添加use crate :: front_of_house :: hosting， &lt;code&gt;hosting&lt;/code&gt; 现在在该范围内是有效名称，就像在板条箱根中定义了 &lt;code&gt;hosting&lt;/code&gt; 模块一样。与其他任何路径一样，进入 &lt;code&gt;use&lt;/code&gt; 范围的路径也会检查隐私。</target>
        </trans-unit>
        <trans-unit id="311633e0da4d8767a76b5d94813ce0272b9cb8a9" translate="yes" xml:space="preserve">
          <source>Adding Custom Failure Messages</source>
          <target state="translated">添加自定义故障信息</target>
        </trans-unit>
        <trans-unit id="eb99698d7e26927ef9425258511b7fbda34cd647" translate="yes" xml:space="preserve">
          <source>Adding Metadata to a New Crate</source>
          <target state="translated">为新箱子添加元数据</target>
        </trans-unit>
        <trans-unit id="6ff96d15a4dfd75cd1b39329a2970688120a37e4" translate="yes" xml:space="preserve">
          <source>Adding Useful Functionality with Derived Traits</source>
          <target state="translated">通过衍生特征增加有用的功能。</target>
        </trans-unit>
        <trans-unit id="b2524eeb321c4f1026793239c00d8c1b31c32e31" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; field to your type tells the compiler that your type acts as though it stores a value of type &lt;code&gt;T&lt;/code&gt;, even though it doesn't really. This information is used when computing certain safety properties.</source>
          <target state="translated">向您的类型添加 &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; 字段会告诉编译器，您的类型就像存储类型 &lt;code&gt;T&lt;/code&gt; 的值一样工作，即使实际上并非如此。在计算某些安全属性时会使用此信息。</target>
        </trans-unit>
        <trans-unit id="b87a48eb56569132271d6219a87c7a5229e982a0" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;Self: Sized&lt;/code&gt; bound to these methods will generally make this compile.</source>
          <target state="translated">给这些方法添加一个 &lt;code&gt;Self: Sized&lt;/code&gt; 绑定通常会进行编译。</target>
        </trans-unit>
        <trans-unit id="88b9f27e251e16ee893bec092535b944c26b4aa9" translate="yes" xml:space="preserve">
          <source>Adding a Reference from a Child to Its Parent</source>
          <target state="translated">将子代的参考文献添加到父代</target>
        </trans-unit>
        <trans-unit id="23ab42376e070f08194bffa94071c8449a58479a" translate="yes" xml:space="preserve">
          <source>Adding a Test to a Workspace</source>
          <target state="translated">向工作区添加测试</target>
        </trans-unit>
        <trans-unit id="fd0c9f4d15902bc297e9dbf8af8d2743194e970b" translate="yes" xml:space="preserve">
          <source>Adding a field of type &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indicates that your type owns data of type &lt;code&gt;T&lt;/code&gt;. This in turn implies that when your type is dropped, it may drop one or more instances of the type &lt;code&gt;T&lt;/code&gt;. This has bearing on the Rust compiler's &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;drop check&lt;/a&gt; analysis.</source>
          <target state="translated">添加类型为 &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; 的字段表示您的类型拥有类型 &lt;code&gt;T&lt;/code&gt; 的数据。这又意味着在删除您的类型时，它可能会删除一个或多个类型 &lt;code&gt;T&lt;/code&gt; 的实例。这与Rust编译器的&lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;删除检查&lt;/a&gt;分析有关。</target>
        </trans-unit>
        <trans-unit id="2e98bb73927df33c08944823ebcc88b767156500" translate="yes" xml:space="preserve">
          <source>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running &lt;code&gt;cargo test&lt;/code&gt; will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don&amp;rsquo;t work because the code has changed since the documentation was written. If we run &lt;code&gt;cargo test&lt;/code&gt; with the documentation for the &lt;code&gt;add_one&lt;/code&gt; function from Listing 14-1, we will see a section in the test results like this:</source>
          <target state="translated">在文档注释中添加示例代码块可以帮助演示如何使用您的库，这样做还有一个额外的好处：运行 &lt;code&gt;cargo test&lt;/code&gt; 会将文档中的代码示例作为测试运行！没有什么比带有示例的文档更好。但是没有什么比不起作用的示例更糟糕的了，因为自编写文档以来代码已更改。如果使用清单14-1中 &lt;code&gt;add_one&lt;/code&gt; 函数的文档运行 &lt;code&gt;cargo test&lt;/code&gt; ，我们将在测试结果中看到如下部分：</target>
        </trans-unit>
        <trans-unit id="ceb9b506f927db7479477e625a150623510cf2aa" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; Method that Changes the Behavior of &lt;code&gt;content&lt;/code&gt;</source>
          <target state="translated">添加更改 &lt;code&gt;content&lt;/code&gt; 行为的 &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="718d273106ffd821ac0c7d93c2d34d8556d7365d" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;break&lt;/code&gt; line after &lt;code&gt;You win!&lt;/code&gt; makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;You win!&lt;/code&gt; 后添加 &lt;code&gt;break&lt;/code&gt; 线！当用户正确猜测密码时，使程序退出循环。退出循环还意味着退出程序，因为循环是 &lt;code&gt;main&lt;/code&gt; 的最后一部分。</target>
        </trans-unit>
        <trans-unit id="097cf74b7fb2e319a4766446302ea478dcd635f5" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;mut&lt;/code&gt; keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</source>
          <target state="translated">添加 &lt;code&gt;mut&lt;/code&gt; 关键字会取消引用可变引用。可变性必须匹配参考的可变性。</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="c8217392646c4b940c031f95cbb65a4bfa731556" translate="yes" xml:space="preserve">
          <source>Addition assignment</source>
          <target state="translated">加法作业</target>
        </trans-unit>
        <trans-unit id="b078f9f7ba47f896a06212df108079bcbb1553ff" translate="yes" xml:space="preserve">
          <source>Additional functionality for numerics.</source>
          <target state="translated">数字的附加功能。</target>
        </trans-unit>
        <trans-unit id="2ffc443f11be980490aef62083275ee8c11f674b" translate="yes" xml:space="preserve">
          <source>Additional implementors</source>
          <target state="translated">其他实施者</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">其他信息</target>
        </trans-unit>
        <trans-unit id="0c05d0c23b9a6f9971368dd97467c0d0e294ca18" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">附加参数传递给 &lt;code&gt;format!&lt;/code&gt; 除非给定的名称或位置参数，否则按给定的顺序替换格式字符串中的 &lt;code&gt;{}&lt;/code&gt; ；有关更多信息，请参见&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b89443b71b82e921f27bf8622eec75e5bb710e5e" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">附加参数传递给 &lt;code&gt;format!&lt;/code&gt; 除非指定名称或位置参数，否则以给定的顺序替换格式字符串中的 &lt;code&gt;{}&lt;/code&gt; ；有关更多信息，请参见&lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5cf45e8eb3455f9aeaa5f7fa4c013c3116744f0" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;f32&lt;/code&gt; can represent a couple of special values:</source>
          <target state="translated">此外， &lt;code&gt;f32&lt;/code&gt; 可以代表几个特殊值：</target>
        </trans-unit>
        <trans-unit id="dc3992de92a20dddf33d6770f13a67c41e82f34f" translate="yes" xml:space="preserve">
          <source>Additionally, a type &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; can implement &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; or &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;. This allows it to provide a unsized coercion to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此外，一种类型的 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; 可以实现 &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 当 &lt;code&gt;T&lt;/code&gt; 器具 &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; 或 &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 。这允许它为 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; 提供不定大小的强制。</target>
        </trans-unit>
        <trans-unit id="30e7a03e650ce2c7f3e6f58657d0e770d7ebbede" translate="yes" xml:space="preserve">
          <source>Additionally, even though &lt;code&gt;$crate&lt;/code&gt; allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke &lt;code&gt;call_foo!()&lt;/code&gt; from outside its crate will fail because &lt;code&gt;foo()&lt;/code&gt; is not public.</source>
          <target state="translated">此外，即使 &lt;code&gt;$crate&lt;/code&gt; 允许宏在扩展时引用其自己的条板箱中的项目，其使用也不会影响可见性。引用的项目或宏仍必须在调用站点中可见。在以下示例中，由于 &lt;code&gt;foo()&lt;/code&gt; 不是公共的，因此从其板条箱外部调用 &lt;code&gt;call_foo!()&lt;/code&gt; 的任何尝试都会失败。</target>
        </trans-unit>
        <trans-unit id="8bd65ffd560b03ecf2792061831bdc28c657f4f7" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">此外，如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则在调用 &lt;code&gt;drop_in_place&lt;/code&gt; 之后使用指向的值可能会导致未定义的行为。请注意， &lt;code&gt;*to_drop = foo&lt;/code&gt; 视为有用，因为它将导致该值再次被删除。&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;可用于覆盖数据而不会导致数据被丢弃。</target>
        </trans-unit>
        <trans-unit id="45cbb93035ac4b5290adcbd441c337adab3295a5" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">此外，如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则在调用 &lt;code&gt;drop_in_place&lt;/code&gt; 之后使用指向的值可能会导致未定义的行为。请注意， &lt;code&gt;*to_drop = foo&lt;/code&gt; 视为有用，因为它将导致该值再次被删除。&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;可用于覆盖数据而不会导致数据被丢弃。</target>
        </trans-unit>
        <trans-unit id="4db0827a894435e479c60b5c414ff857b4d8ad46" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">此外，如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则在调用 &lt;code&gt;drop_in_place&lt;/code&gt; 之后使用指向的值可能会导致未定义的行为。请注意， &lt;code&gt;*to_drop = foo&lt;/code&gt; 视为有用，因为它将导致该值再次被删除。&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;可用于覆盖数据而不会导致数据被丢弃。</target>
        </trans-unit>
        <trans-unit id="74bd1999d14b1334b93c7bef28b699b66b0d25fc" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">此外，如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，则在调用 &lt;code&gt;drop_in_place&lt;/code&gt; 之后使用指向的值可能会导致未定义的行为。请注意， &lt;code&gt;*to_drop = foo&lt;/code&gt; 视为有用，因为它将导致该值再次被删除。&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;可用于覆盖数据而不会导致数据被丢弃。</target>
        </trans-unit>
        <trans-unit id="90a70db7c7bfc77bbf274f46c324d605b6ac9ac3" translate="yes" xml:space="preserve">
          <source>Additionally, it does not drop &lt;code&gt;src&lt;/code&gt;. Semantically, &lt;code&gt;src&lt;/code&gt; is moved into the location pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">此外，它不会删除 &lt;code&gt;src&lt;/code&gt; 。语义上， &lt;code&gt;src&lt;/code&gt; 被移到 &lt;code&gt;dst&lt;/code&gt; 指向的位置。</target>
        </trans-unit>
        <trans-unit id="a5ab7ed4a3b0357f6baec92b0d45381b0f7726c3" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">另外，在Unix上，&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;实现了 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt;特性，该特性提供使用&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt;方法消耗其参数，并采用或产生&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 的&lt;/a&gt;向量。</target>
        </trans-unit>
        <trans-unit id="1db4d415a7232a66cc30ffdbd6dbfd6bc3c496f2" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">另外，在Unix上，&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;实现了 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt;特性，该特性提供使用&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt;方法消耗其参数，并采用或产生&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 的&lt;/a&gt;向量。</target>
        </trans-unit>
        <trans-unit id="8bb517701cd0832c45c67c28da4b399a605014b6" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows:ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides a &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;from_wide&lt;/code&gt;&lt;/a&gt; method. The result of this method is an &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; which can be round-tripped to a Windows string losslessly.</source>
          <target state="translated">此外，在Windows上，&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;实现了 &lt;code&gt;std::os::windows:ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt;特性，该特性提供了&lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;from_wide&lt;/code&gt; &lt;/a&gt;方法。此方法的结果是一个&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;，它可以无损地往返于Windows字符串。</target>
        </trans-unit>
        <trans-unit id="0f7d5354cdb11e461595056b1602a23178a20138" translate="yes" xml:space="preserve">
          <source>Additionally, taking a job off the channel queue involves mutating the &lt;code&gt;receiver&lt;/code&gt;, so the threads need a safe way to share and modify &lt;code&gt;receiver&lt;/code&gt;; otherwise, we might get race conditions (as covered in Chapter 16).</source>
          <target state="translated">另外，从通道队列中删除工作需要对 &lt;code&gt;receiver&lt;/code&gt; 进行突变，因此线程需要一种安全的方式来共享和修改 &lt;code&gt;receiver&lt;/code&gt; 。否则，我们可能会遇到竞争条件（如第16章所述）。</target>
        </trans-unit>
        <trans-unit id="0eb5702e98a03d052d40c8aabb340aee4d2332a4" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt; types depend on the kind of computer your program is running on: 64 bits if you&amp;rsquo;re on a 64-bit architecture and 32 bits if you&amp;rsquo;re on a 32-bit architecture.</source>
          <target state="translated">此外， &lt;code&gt;isize&lt;/code&gt; 和 &lt;code&gt;usize&lt;/code&gt; 类型取决于程序运行的计算机类型：如果是64位体系结构，则为64位；如果是32位体系结构，则为32位。</target>
        </trans-unit>
        <trans-unit id="e3aa1d01d453f95734172c24dd2caadad96e569f" translate="yes" xml:space="preserve">
          <source>Additionally, the caller must ensure that writing &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes to the given region of memory results in a valid value of &lt;code&gt;T&lt;/code&gt;. Using a region of memory typed as a &lt;code&gt;T&lt;/code&gt; that contains an invalid value of &lt;code&gt;T&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">此外，调用者必须确保将 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 个字节写入给定的内存区域会导致 &lt;code&gt;T&lt;/code&gt; 的有效值。使用类型为 &lt;code&gt;T&lt;/code&gt; 的内存区域包含无效 &lt;code&gt;T&lt;/code&gt; 值是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="f3d0f5351803248ec3d677cec08967bab902a3b1" translate="yes" xml:space="preserve">
          <source>Additionally, the length of the string will be recalculated from the pointer.</source>
          <target state="translated">此外,字符串的长度将从指针中重新计算。</target>
        </trans-unit>
        <trans-unit id="5c93e6fb82861fecd56783e8c74a9dcd85037abd" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get accessed through any other pointer.</source>
          <target state="translated">另外，返回的生存期 &lt;code&gt;'a&lt;/code&gt; 是任意选择的，不一定反映数据的实际生存期。调用者应确保在此生命周期的持续时间内，该指针指向的内存不会通过任何其他指针访问。</target>
        </trans-unit>
        <trans-unit id="6e203e0080d407af9cc4130e8b5859f062bfa85b" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get written to outside of &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">另外，返回的生存期 &lt;code&gt;'a&lt;/code&gt; 是任意选择的，不一定反映数据的实际生存期。调用者应确保在此生命周期的持续时间内，此指针指向的内存不会被写入 &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb09e099663e4fdfec9970e8541bfc0bbcb8c136" translate="yes" xml:space="preserve">
          <source>Additionally, the return value of this function is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt; which is a type alias of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;(), &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;std::fmt::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Formatting implementations should ensure that they propagate errors from the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; (e.g., when calling &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a result because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.</source>
          <target state="translated">另外，此函数的返回值为&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;，它是&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;(), &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;std::fmt::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 的类型别名。格式化实现应确保它们传播来自&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;错误（例如，在调用&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; 时&lt;/a&gt;）。但是，它们绝不能虚假地返回错误。也就是说，格式化的实现必须并且只能返回一个错误，如果传入的&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;返回错误。这是因为，与功能签名所建议的相反，字符串格式是一项可靠的操作。该函数仅返回结果，因为对基础流的写入可能会失败，并且它必须提供一种方法来将已发生错误的事实传播回堆栈。</target>
        </trans-unit>
        <trans-unit id="c51e0d7d6467942093ff85910240899ecb3312bc" translate="yes" xml:space="preserve">
          <source>Additionally, we can&amp;rsquo;t yet provide the &lt;code&gt;hello_macro&lt;/code&gt; function with default implementation that will print the name of the type the trait is implemented on: Rust doesn&amp;rsquo;t have reflection capabilities, so it can&amp;rsquo;t look up the type&amp;rsquo;s name at runtime. We need a macro to generate code at compile time.</source>
          <target state="translated">另外，我们还无法提供具有默认实现的 &lt;code&gt;hello_macro&lt;/code&gt; 函数，该函数将打印实现特征的类型的名称：Rust没有反射功能，因此它无法在运行时查找类型的名称。我们需要一个宏来在编译时生成代码。</target>
        </trans-unit>
        <trans-unit id="009b5112bedb7bc7f35022f14f637dbf23e46083" translate="yes" xml:space="preserve">
          <source>Additionally, you&amp;rsquo;ll need a linker of some kind. It&amp;rsquo;s likely one is already installed, but when you try to compile a Rust program and get errors indicating that a linker could not execute, that means a linker isn&amp;rsquo;t installed on your system and you&amp;rsquo;ll need to install one manually. C compilers usually come with the correct linker. Check your platform&amp;rsquo;s documentation for how to install a C compiler. Also, some common Rust packages depend on C code and will need a C compiler. Therefore, it might be worth installing one now.</source>
          <target state="translated">此外，您将需要某种链接器。可能已经安装了一个链接器，但是当您尝试编译Rust程序并收到表明链接器无法执行的错误时，这意味着您的系统上没有安装链接器，您需要手动安装一个链接器。C编译器通常带有正确的链接器。查看平台的文档，了解如何安装C编译器。另外，一些常见的Rust软件包依赖C代码，并且需要C编译器。因此，可能值得立即安装一个。</target>
        </trans-unit>
        <trans-unit id="e8f6c433136e97e0a25822d00a70a971083e0df2" translate="yes" xml:space="preserve">
          <source>AddrParseError</source>
          <target state="translated">AddrParseError</target>
        </trans-unit>
        <trans-unit id="4db89e8ded7777748645ac21edd601141065b25a" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow</source>
          <target state="translated">AddrParseError::borrow</target>
        </trans-unit>
        <trans-unit id="ba5e2e5b2d73d903fb597da8809d6182f967fe26" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow_mut</source>
          <target state="translated">AddrParseError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eec3364cb0e6e631bd766aeee8473eb3c5d8b783" translate="yes" xml:space="preserve">
          <source>AddrParseError::cause</source>
          <target state="translated">AddrParseError::cause</target>
        </trans-unit>
        <trans-unit id="c8650de9923d2b7b74fd1fb851b3c0ddd4117148" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone</source>
          <target state="translated">AddrParseError::clone</target>
        </trans-unit>
        <trans-unit id="53ddfe6ad8c3351ba945f5b6cd6f647e3fa91325" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_from</source>
          <target state="translated">AddrParseError::clone_from</target>
        </trans-unit>
        <trans-unit id="08355c15003499e28a7411918357d4a2f001b709" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_into</source>
          <target state="translated">AddrParseError::clone_into</target>
        </trans-unit>
        <trans-unit id="25cb3b50c76347b7f6a85db7c339595baf0f003c" translate="yes" xml:space="preserve">
          <source>AddrParseError::description</source>
          <target state="translated">AddrParseError::description</target>
        </trans-unit>
        <trans-unit id="10b9b968cc3bf94f7c5c39dea8bf21d7dd54888c" translate="yes" xml:space="preserve">
          <source>AddrParseError::eq</source>
          <target state="translated">AddrParseError::eq</target>
        </trans-unit>
        <trans-unit id="49cf29f6a6f46e91fe5234ee3c02c53e59ab7578" translate="yes" xml:space="preserve">
          <source>AddrParseError::fmt</source>
          <target state="translated">AddrParseError::fmt</target>
        </trans-unit>
        <trans-unit id="60405d6d13708e4d85c176a98cb4377bfb7ee9d7" translate="yes" xml:space="preserve">
          <source>AddrParseError::from</source>
          <target state="translated">AddrParseError::from</target>
        </trans-unit>
        <trans-unit id="dbfcfd8a7eba25880c9888cb8208fce8e37c895d" translate="yes" xml:space="preserve">
          <source>AddrParseError::into</source>
          <target state="translated">AddrParseError::into</target>
        </trans-unit>
        <trans-unit id="81cea92a5c59d76a750c2dc91be0b6bebf9c1c4f" translate="yes" xml:space="preserve">
          <source>AddrParseError::ne</source>
          <target state="translated">AddrParseError::ne</target>
        </trans-unit>
        <trans-unit id="85b81474bbc6034c17600e25b324b8f7ff89e65b" translate="yes" xml:space="preserve">
          <source>AddrParseError::source</source>
          <target state="translated">AddrParseError::source</target>
        </trans-unit>
        <trans-unit id="ba1fd539045fde8129efbfd52fe6aba361392170" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_owned</source>
          <target state="translated">AddrParseError::to_owned</target>
        </trans-unit>
        <trans-unit id="e2552e76eca8011ad4e06db73e14e51d90cd4e86" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_string</source>
          <target state="translated">AddrParseError::to_string</target>
        </trans-unit>
        <trans-unit id="ff5f57540e8ea426311cdc19ccc6971134dcdb7f" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_from</source>
          <target state="translated">AddrParseError::try_from</target>
        </trans-unit>
        <trans-unit id="bec376def9a1123d4f124dfc1a6840567151a145" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_into</source>
          <target state="translated">AddrParseError::try_into</target>
        </trans-unit>
        <trans-unit id="26c560bba3044ee670c8f3ee436e252e0e2dad89" translate="yes" xml:space="preserve">
          <source>AddrParseError::type_id</source>
          <target state="translated">AddrParseError::type_id</target>
        </trans-unit>
        <trans-unit id="5cf7a9b41ce47d27a30e791bbfb6bec2ca816fcf" translate="yes" xml:space="preserve">
          <source>Address to pointer cast</source>
          <target state="translated">投向指针的地址</target>
        </trans-unit>
        <trans-unit id="d7aa7412717eb74583761a8560faa539aaf27874" translate="yes" xml:space="preserve">
          <source>Address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">地址类型可以是&lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt;特征的任何实现者。有关具体示例，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="5a1149884af3cef69504ddd9428373fea25aa2ca" translate="yes" xml:space="preserve">
          <source>Addresses returned by the operating system that are not IP addresses are silently ignored.</source>
          <target state="translated">操作系统返回的不是IP地址的地址会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="5915abc490110180d1540b6234219f020e04a70a" translate="yes" xml:space="preserve">
          <source>Adds a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method to an iterator. See its documentation for more information.</source>
          <target state="translated">将&lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt;方法添加到迭代器。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c870f816a116db65c4b82439ff891f426f80ff41" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;usize&lt;/code&gt;, returning &lt;code&gt;None&lt;/code&gt; on overflow.</source>
          <target state="translated">添加一个 &lt;code&gt;usize&lt;/code&gt; ，在溢出时返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31cf127eab5bb935c2abe6cc6bba90f4ae0b71a3" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the list output.</source>
          <target state="translated">在列表输出中添加一个新条目。</target>
        </trans-unit>
        <trans-unit id="15cb5f7efe200723c3b721e295fbebc13dfc9e31" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the map output.</source>
          <target state="translated">在地图输出中添加一个新的条目。</target>
        </trans-unit>
        <trans-unit id="0ef3b59a4597ecf10372b8f11eb26c1a52f2f272" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the set output.</source>
          <target state="translated">在集合输出中添加一个新条目。</target>
        </trans-unit>
        <trans-unit id="60f1cf0bd8c4a027b017ecaa893cb9c74c91f78b" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated struct output.</source>
          <target state="translated">在生成的结构体输出中添加一个新字段。</target>
        </trans-unit>
        <trans-unit id="b8fafafece871a01042ed5a0ab5c6c9b2e80442c" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated tuple struct output.</source>
          <target state="translated">在生成的元组结构输出中添加一个新字段。</target>
        </trans-unit>
        <trans-unit id="0b002c9af6c57cafdfe28d411ed57cf85e2ebe81" translate="yes" xml:space="preserve">
          <source>Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value.</source>
          <target state="translated">向集合中添加一个值,替换现有的与给定值相等的值(如果有的话)。返回被替换的值。</target>
        </trans-unit>
        <trans-unit id="82f4c899437f1a62750b1776b4b1b6599530f1e6" translate="yes" xml:space="preserve">
          <source>Adds a value to the set.</source>
          <target state="translated">向集合中添加一个值。</target>
        </trans-unit>
        <trans-unit id="f1a3f6979754c5ca7c9e4122b44f7541e9636107" translate="yes" xml:space="preserve">
          <source>Adds an argument to pass to the program.</source>
          <target state="translated">添加一个参数传递给程序。</target>
        </trans-unit>
        <trans-unit id="658707171b5a956fa506d45ca2578865d314c2a0" translate="yes" xml:space="preserve">
          <source>Adds an element first in the list.</source>
          <target state="translated">在列表中先添加一个元素。</target>
        </trans-unit>
        <trans-unit id="969d7672cd1e94e2e3f766816cef88b15855a861" translate="yes" xml:space="preserve">
          <source>Adds multiple arguments to pass to the program.</source>
          <target state="translated">添加多个参数传递给程序。</target>
        </trans-unit>
        <trans-unit id="68adca23d26862cb362a13d5d500e729dc911a8b" translate="yes" xml:space="preserve">
          <source>Adds one to this step, returning the result.</source>
          <target state="translated">在本步骤中增加一个,返回结果。</target>
        </trans-unit>
        <trans-unit id="0151250bd8bdb46ad8abec9aa6c7d2adc6f4d3c2" translate="yes" xml:space="preserve">
          <source>Adds or updates multiple environment variable mappings.</source>
          <target state="translated">添加或更新多个环境变量映射。</target>
        </trans-unit>
        <trans-unit id="c1ea158bb2722c6d5db848a523c49d2d1b4ef996" translate="yes" xml:space="preserve">
          <source>Adds support for special Unix file types such as block/character devices, pipes, and sockets.</source>
          <target state="translated">增加对特殊Unix文件类型的支持,如块/字符设备、管道和套接字。</target>
        </trans-unit>
        <trans-unit id="671bf2741316962d688bf4f15b0556af370525fd" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the list output.</source>
          <target state="translated">将条目迭代器的内容添加到列表输出中。</target>
        </trans-unit>
        <trans-unit id="6172d9346f85a8afb18c30e9f6e11792ac6685f3" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the map output.</source>
          <target state="translated">将条目迭代器的内容添加到地图输出中。</target>
        </trans-unit>
        <trans-unit id="45f4916d90bbb31a57ac59c642d372fc8465632a" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the set output.</source>
          <target state="translated">将条目迭代器的内容添加到集合输出中。</target>
        </trans-unit>
        <trans-unit id="525909640b425a3865879f7bf9b4776de0cbde79" translate="yes" xml:space="preserve">
          <source>Adds the key part of a new entry to the map output.</source>
          <target state="translated">在地图输出中添加新条目的关键部分。</target>
        </trans-unit>
        <trans-unit id="82b33d8253f240296388fcf0db6ce4c17b122fb9" translate="yes" xml:space="preserve">
          <source>Adds the value part of a new entry to the map output.</source>
          <target state="translated">将新条目的值部分添加到地图输出中。</target>
        </trans-unit>
        <trans-unit id="64dedb52a39f499be5ddacaf33bea0b6af530c2b" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value.</source>
          <target state="translated">加到当前值,返回之前的值。</target>
        </trans-unit>
        <trans-unit id="fec400f1cdf6c0803479c71a8ae238f9468f9b58" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">加到当前值，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be9a5a4d4b7398c45da8fcba5bded3bbc8f71847" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">加到当前值，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8510188bc5ebdc1c7bffee425e4b31fab3c7278" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">加到当前值，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d050db3800c7dd71e5057e0d9def9358e61a419" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">加到当前值，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1973476bdfd162d29c3bf0eb0f1911803377eae3" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">加到当前值，返回前一个值。通过将&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;传递为 &lt;code&gt;order&lt;/code&gt; ，可以通过 &lt;code&gt;fetch_add&lt;/code&gt; 方法在 &lt;code&gt;std::sync::atomic&lt;/code&gt; 类型上使用此内在函数的稳定版本。例如，&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb6c863d4412a4b55b1d93cf3d5f7516528289e4" translate="yes" xml:space="preserve">
          <source>Advance the internal cursor of the slice.</source>
          <target state="translated">推进切片的内部光标。</target>
        </trans-unit>
        <trans-unit id="b2ed5841682a101d798c6152b62dca74cfea4b15" translate="yes" xml:space="preserve">
          <source>Advance to the next arg.</source>
          <target state="translated">进入下一个论题。</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高级功能</target>
        </trans-unit>
        <trans-unit id="7f4668d91bf23526ef1f05a0e7de95630615e93b" translate="yes" xml:space="preserve">
          <source>Advanced Functions and Closures</source>
          <target state="translated">高级功能和关闭</target>
        </trans-unit>
        <trans-unit id="d5d49bfe71b011aa5e9e308b0bd9089c84c3c245" translate="yes" xml:space="preserve">
          <source>Advanced Traits</source>
          <target state="translated">高级特征</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">高级类型</target>
        </trans-unit>
        <trans-unit id="9b4509b6a0eecdabec69457f9e139e56f305f9a7" translate="yes" xml:space="preserve">
          <source>Advanced functions and closures: function pointers and returning closures</source>
          <target state="translated">高级函数和闭包:函数指针和返回闭包。</target>
        </trans-unit>
        <trans-unit id="9c622feb39e22136f98cc1cfffb6cc56c0cb6ac7" translate="yes" xml:space="preserve">
          <source>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</source>
          <target state="translated">高级特性:关联类型、默认类型参数、完全限定语法、超特性以及与特性相关的新类型模式。</target>
        </trans-unit>
        <trans-unit id="d050af08a92ff2ff0056bb035493a0f2f1620de8" translate="yes" xml:space="preserve">
          <source>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</source>
          <target state="translated">高级类型:更多关于newtype模式、类型别名、never类型和动态大小类型的内容。</target>
        </trans-unit>
        <trans-unit id="bc73315bb680ddc61259cb6b2cc7f603f7017af5" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value.</source>
          <target state="translated">推进迭代器并返回下一个值。</target>
        </trans-unit>
        <trans-unit id="47778efc70c16f19b03a33e09324cdfef37b8397" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">推进迭代器并返回下一个值。&lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5c10d1dad50204036d6641dc96f179feac3c880" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">推进迭代器并返回下一个值。&lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0d17cb524aa65c6531ab7f58b22a2915be47179" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">推进迭代器并返回下一个值。&lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2af190b4bf87220daaa7fcdfebb435d1dda577b1" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">推进迭代器并返回下一个值。&lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ff050bc0f28af247ba9f7e987965071e370a8f" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">推进迭代器并返回下一个值。&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c629d1551783824351df46023949d62af853825" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">使迭代器前进 &lt;code&gt;n&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="c9fef351384b0144be153be53f79c7fc476bedfc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;../../../iter/trait.iterator#method.advance_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41de8018927ed7b54950980aec11f8f12d46606f" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;../../iter/trait.iterator#method.advance_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09741f9824923fbfa016237025da37c62ee69dcc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;../iter/trait.iterator#method.advance_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c3b9d2faa7136ddd042e31d3939c786f1c8da2c" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;iter/trait.iterator#method.advance_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74fde24899e07da847358f17c288cfcfe8ae74ea" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;trait.iterator#method.advance_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d66799c08b5e49880157cde9e0d13d223a5c3a3" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">使迭代器从后向前进 &lt;code&gt;n&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="4f1f4e504d47f61c437fd02db056daa6ec47dc6c" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器从后向前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;../../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d59517951217a4fde7238ff6227ce7834fa1b5e" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器从后向前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34bb721017aea2eeaededef2c5c856023eca871d" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器从后向前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="148c4a64097476a8bb5779b8f3210d3b2962ff05" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">使迭代器从后向前进 &lt;code&gt;n&lt;/code&gt; 个元素。&lt;a href=&quot;trait.doubleendediterator#method.advance_back_by&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc5df98fcac936e0dd69b6d3ac4bff062078ea9f" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;#[test]&lt;/code&gt; we add the &lt;code&gt;#[ignore]&lt;/code&gt; line to the test we want to exclude. Now when we run our tests, &lt;code&gt;it_works&lt;/code&gt; runs, but &lt;code&gt;expensive_test&lt;/code&gt; doesn&amp;rsquo;t:</source>
          <target state="translated">在 &lt;code&gt;#[test]&lt;/code&gt; 之后,我们将 &lt;code&gt;#[ignore]&lt;/code&gt; 行添加到要排除的测试中。现在，当我们运行测试时， &lt;code&gt;it_works&lt;/code&gt; 会运行，但是 &lt;code&gt;expensive_test&lt;/code&gt; test不会：</target>
        </trans-unit>
        <trans-unit id="471c4d510c078cce605f07ee5e3b57ac50f1448c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;crate&lt;/code&gt;, we include each of the successive modules until we make our way to &lt;code&gt;add_to_waitlist&lt;/code&gt;. You can imagine a filesystem with the same structure, and we&amp;rsquo;d specify the path &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; to run the &lt;code&gt;add_to_waitlist&lt;/code&gt; program; using the &lt;code&gt;crate&lt;/code&gt; name to start from the crate root is like using &lt;code&gt;/&lt;/code&gt; to start from the filesystem root in your shell.</source>
          <target state="translated">在创建 &lt;code&gt;crate&lt;/code&gt; 之后，我们将包括每个后续模块，直到我们进入 &lt;code&gt;add_to_waitlist&lt;/code&gt; 为止。您可以想象一个具有相同结构的文件系统，我们将指定路径 &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; 来运行 &lt;code&gt;add_to_waitlist&lt;/code&gt; 程序；使用 &lt;code&gt;crate&lt;/code&gt; 名称从crate根目录开始就像使用 &lt;code&gt;/&lt;/code&gt; 从shell中的文件系统根目录开始。</target>
        </trans-unit>
        <trans-unit id="72900f50989a74635a45f599f7af957665be760a" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;skip_while()&lt;/code&gt;'s job is over, and the rest of the elements are yielded.</source>
          <target state="translated">后 &lt;code&gt;false&lt;/code&gt; 返回， &lt;code&gt;skip_while()&lt;/code&gt; 的工作已经结束，而其余元素都产生。</target>
        </trans-unit>
        <trans-unit id="a8fe2c79e763fccf582bfde64f2cf9442ce9db7c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;take_while()&lt;/code&gt;'s job is over, and the rest of the elements are ignored.</source>
          <target state="translated">后 &lt;code&gt;false&lt;/code&gt; 返回， &lt;code&gt;take_while()&lt;/code&gt; 的工作已经结束，而其余元素都被忽略。</target>
        </trans-unit>
        <trans-unit id="d9d86d37284d13e516ed39f67cc2c963b4451b66" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;leaf&lt;/code&gt; is created, its &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; has a strong count of 1 and a weak count of 0. In the inner scope, we create &lt;code&gt;branch&lt;/code&gt; and associate it with &lt;code&gt;leaf&lt;/code&gt;, at which point when we print the counts, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; will have a strong count of 1 and a weak count of 1 (for &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; with a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt;). When we print the counts in &lt;code&gt;leaf&lt;/code&gt;, we&amp;rsquo;ll see it will have a strong count of 2, because &lt;code&gt;branch&lt;/code&gt; now has a clone of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; of &lt;code&gt;leaf&lt;/code&gt; stored in &lt;code&gt;branch.children&lt;/code&gt;, but will still have a weak count of 0.</source>
          <target state="translated">创建完 &lt;code&gt;leaf&lt;/code&gt; 之后，其 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 的强计数为1，弱计数为0。在内部范围内，我们创建 &lt;code&gt;branch&lt;/code&gt; 并将其与 &lt;code&gt;leaf&lt;/code&gt; 关联，此时，当我们打印计数时， &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; 将具有1的强计数和1的弱计数（对于 &lt;code&gt;leaf.parent&lt;/code&gt; 指向具有 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; &lt;code&gt;branch&lt;/code&gt; ）。当我们在 &lt;code&gt;leaf&lt;/code&gt; 中打印计数时，我们将看到它将具有2的强计数，因为 &lt;code&gt;branch&lt;/code&gt; 现在在 &lt;code&gt;branch.children&lt;/code&gt; 中存储了 &lt;code&gt;leaf&lt;/code&gt; &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 的副本。，但计数仍然为0。</target>
        </trans-unit>
        <trans-unit id="4cde8475e322a79219c56c165831cd534e7a6b56" translate="yes" xml:space="preserve">
          <source>After an iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, future calls may or may not yield &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; again. &lt;code&gt;fuse()&lt;/code&gt; adapts an iterator, ensuring that after a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is given, it will always return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; forever.</source>
          <target state="translated">迭代器返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 后&lt;/a&gt;，将来的调用可能会或可能不会再次产生&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;fuse()&lt;/code&gt; 调整迭代器，确保在给出&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;后，它将永远永远返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="568e22b9792d58baafe078fb9cf96ab4d0418d3f" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;fold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">将闭包应用于迭代器的每个元素后， &lt;code&gt;fold()&lt;/code&gt; 返回累加器。</target>
        </trans-unit>
        <trans-unit id="c5c6fbc1d802b5c2313fc5d60dee8a9485ff2828" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;rfold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">在将此闭包应用于迭代器的每个元素之后， &lt;code&gt;rfold()&lt;/code&gt; 返回累加器。</target>
        </trans-unit>
        <trans-unit id="dbffd4bfa583f6bbb8aa4395e63df871ca521db4" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;v.as_mut_ptr()&lt;/code&gt; and transmitting the ownership of the data to &lt;code&gt;s&lt;/code&gt;, the &lt;code&gt;v&lt;/code&gt; value is invalid. Even when a value is just moved to &lt;code&gt;mem::forget&lt;/code&gt; (which won't inspect it), some types have strict requirements on their values that make them invalid when dangling or no longer owned. Using invalid values in any way, including passing them to or returning them from functions, constitutes undefined behavior and may break the assumptions made by the compiler.</source>
          <target state="translated">在调用 &lt;code&gt;v.as_mut_ptr()&lt;/code&gt; 并将数据所有权传输给 &lt;code&gt;s&lt;/code&gt; 之后， &lt;code&gt;v&lt;/code&gt; 值无效。即使将值移动到 &lt;code&gt;mem::forget&lt;/code&gt; （不会检查它），某些类型对其值也有严格的要求，使它们在悬空或不再拥有时无效。以任何方式使用无效值（包括将它们传递给函数或从函数返回值）会构成未定义的行为，并且可能会破坏编译器所做的假设。</target>
        </trans-unit>
        <trans-unit id="bc617f1ae4108d460b1173f3a7067fe06a8d7ed6" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="translated">调用此函数后，调用者负责先前由 &lt;code&gt;Box&lt;/code&gt; 管理的内存。特别地，考虑到 &lt;code&gt;Box&lt;/code&gt; 所使用的&lt;a href=&quot;index#memory-layout&quot;&gt;内存布局&lt;/a&gt;，调用方应适当销毁 &lt;code&gt;T&lt;/code&gt; 并释放内存。最简单的方法是使用&lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt;函数将原始指针转换回 &lt;code&gt;Box&lt;/code&gt; ，从而允许 &lt;code&gt;Box&lt;/code&gt; 析构函数执行清除操作。</target>
        </trans-unit>
        <trans-unit id="7cad9f1c8273ecabd3f00d51212a63d92e2f707f" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw_in&quot;&gt;&lt;code&gt;Box::from_raw_in&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="translated">调用此函数后，调用者将负责先前由 &lt;code&gt;Box&lt;/code&gt; 管理的内存。特别地，考虑到 &lt;code&gt;Box&lt;/code&gt; 所使用的&lt;a href=&quot;index#memory-layout&quot;&gt;内存布局&lt;/a&gt;，调用方应适当销毁 &lt;code&gt;T&lt;/code&gt; 并释放内存。最简单的方法是使用&lt;a href=&quot;struct.box#method.from_raw_in&quot;&gt; &lt;code&gt;Box::from_raw_in&lt;/code&gt; &lt;/a&gt;函数将原始指针转换回 &lt;code&gt;Box&lt;/code&gt; ，从而允许 &lt;code&gt;Box&lt;/code&gt; 析构函数执行清理操作。</target>
        </trans-unit>
        <trans-unit id="47bfd04ad6639821cf514c2ef1fb0d7b6f63839d" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory. The easiest way to do so is to convert the &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; pointer into a raw pointer and back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">调用此函数后，调用者负责先前由 &lt;code&gt;Box&lt;/code&gt; 管理的内存。特别是，调用方应正确销毁 &lt;code&gt;T&lt;/code&gt; 并释放内存。最简单的方法是将 &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 指针转换为原始指针，然后使用&lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt;函数将其转换回 &lt;code&gt;Box&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e43a947242c53bd7c33db133c10548b5bd4c117" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;String&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;struct.string#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="translated">调用此函数后，调用者将负责先前由 &lt;code&gt;String&lt;/code&gt; 管理的内存。做到这一点的唯一方法是使用&lt;a href=&quot;struct.string#method.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt;函数将原始指针，长度和容量转换回 &lt;code&gt;String&lt;/code&gt; ，从而允许析构函数执行清理。</target>
        </trans-unit>
        <trans-unit id="102d1de8629b57b21dac90f6d521b49048558b05" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Vec&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;Vec&lt;/code&gt; with the &lt;a href=&quot;struct.vec#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="translated">调用此函数后，调用者负责以前由 &lt;code&gt;Vec&lt;/code&gt; 管理的内存。唯一的方法是使用&lt;a href=&quot;struct.vec#method.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt;函数将原始指针，长度和容量转换回 &lt;code&gt;Vec&lt;/code&gt; ，从而允许析构函数执行清理。</target>
        </trans-unit>
        <trans-unit id="abe8789d4d89fe16b0db6cdf88a765be8535c340" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Vec&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;Vec&lt;/code&gt; with the &lt;a href=&quot;struct.vec#method.from_raw_parts_in&quot;&gt;&lt;code&gt;from_raw_parts_in&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="translated">调用此函数后，调用者负责以前由 &lt;code&gt;Vec&lt;/code&gt; 管理的内存。唯一的方法是使用&lt;a href=&quot;struct.vec#method.from_raw_parts_in&quot;&gt; &lt;code&gt;from_raw_parts_in&lt;/code&gt; &lt;/a&gt;函数将原始指针，长度和容量转换回 &lt;code&gt;Vec&lt;/code&gt; ，从而允许析构函数执行清理。</target>
        </trans-unit>
        <trans-unit id="3d10c7bbc7ba580c584a70857a59b76ef027af83" translate="yes" xml:space="preserve">
          <source>After calling this function, the raw pointer is owned by the resulting &lt;code&gt;Box&lt;/code&gt;. Specifically, the &lt;code&gt;Box&lt;/code&gt; destructor will call the destructor of &lt;code&gt;T&lt;/code&gt; and free the allocated memory. For this to be safe, the memory must have been allocated in accordance with the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt; .</source>
          <target state="translated">调用此函数后，原始指针由结果 &lt;code&gt;Box&lt;/code&gt; 拥有。具体来说， &lt;code&gt;Box&lt;/code&gt; 析构函数将调用 &lt;code&gt;T&lt;/code&gt; 的析构函数并释放分配的内存。对于这是安全的，内存必须已经按照分配的&lt;a href=&quot;index#memory-layout&quot;&gt;内存布局&lt;/a&gt;所用 &lt;code&gt;Box&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef76ea7ae2deed3f017eb7251cbd0d7c334a7aaf" translate="yes" xml:space="preserve">
          <source>After changing &lt;code&gt;println!&lt;/code&gt; to &lt;code&gt;eprintln!&lt;/code&gt;, let&amp;rsquo;s run the program again in the same way, without any arguments and redirecting standard output with &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">换 &lt;code&gt;println!&lt;/code&gt; 到 &lt;code&gt;eprintln!&lt;/code&gt; ，让我们以相同的方式再次运行程序，不带任何参数，并使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 重定向标准输出：</target>
        </trans-unit>
        <trans-unit id="93133f68d39862996d0135a231d1905a95e950c2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过&lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; &lt;code&gt;TcpListener&lt;/code&gt; 绑定到套接字地址来创建它之后，它将侦听传入的TCP连接。可以通过调用&lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;或迭代&lt;a href=&quot;#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt;迭代器来接受它们。</target>
        </trans-unit>
        <trans-unit id="06868983dd9010816d16a947a2feebe64fc6c151" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;struct.tcplistener#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过&lt;a href=&quot;struct.tcplistener#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; &lt;code&gt;TcpListener&lt;/code&gt; 绑定到套接字地址来创建它之后，它将侦听传入的TCP连接。可以通过调用&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;或迭代&lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt;迭代器来接受它们。</target>
        </trans-unit>
        <trans-unit id="422e2b7f3798df18a9e41b4f6d8230c5f7fbaae2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">创建后 &lt;code&gt;TcpStream&lt;/code&gt; 通过任一&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; ING到远程主机或&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;荷兰国际集团上的一个连接&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;，数据可以由发送&lt;a href=&quot;../io/trait.read&quot;&gt;读取&lt;/a&gt;和&lt;a href=&quot;../io/trait.write&quot;&gt;写入&lt;/a&gt;到它。</target>
        </trans-unit>
        <trans-unit id="dafc89a72358e6711ac4be0166b7dcfdffe57a68" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;struct.tcpstream#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">创建后 &lt;code&gt;TcpStream&lt;/code&gt; 通过任一&lt;a href=&quot;struct.tcpstream#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;ING到远程主机或&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;荷兰国际集团上的一个连接&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;，数据可以由发送&lt;a href=&quot;../io/trait.read&quot;&gt;读取&lt;/a&gt;和&lt;a href=&quot;../io/trait.write&quot;&gt;写入&lt;/a&gt;到它。</target>
        </trans-unit>
        <trans-unit id="b9be232588db8403f71ee1411aa554678f33dfa7" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">通过&lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; &lt;code&gt;UdpSocket&lt;/code&gt; 绑定到套接字地址来创建之后，可以将数据&lt;a href=&quot;#method.send_to&quot;&gt;发送到&lt;/a&gt;任何其他套接字地址并&lt;a href=&quot;#method.recv_from&quot;&gt;从&lt;/a&gt;其他任何套接字地址接收数据。</target>
        </trans-unit>
        <trans-unit id="394b482d2eb5a6a4fcc8d7fdff6cfe2cd24f75e2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;struct.udpsocket#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;struct.udpsocket#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;struct.udpsocket#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">创建后 &lt;code&gt;UdpSocket&lt;/code&gt; 通过&lt;a href=&quot;struct.udpsocket#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;它荷兰国际集团到套接字地址，数据可以被&lt;a href=&quot;struct.udpsocket#method.send_to&quot;&gt;发送到&lt;/a&gt;和&lt;a href=&quot;struct.udpsocket#method.recv_from&quot;&gt;接收自&lt;/a&gt;任何其它套接字地址。</target>
        </trans-unit>
        <trans-unit id="3fc506cb877752d66797eaa2996ad1bfc89765b7" translate="yes" xml:space="preserve">
          <source>After creating a new &lt;code&gt;Job&lt;/code&gt; instance using the closure we get in &lt;code&gt;execute&lt;/code&gt;, we send that job down the sending end of the channel. We&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can&amp;rsquo;t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use &lt;code&gt;unwrap&lt;/code&gt; is that we know the failure case won&amp;rsquo;t happen, but the compiler doesn&amp;rsquo;t know that.</source>
          <target state="translated">使用闭包创建新的 &lt;code&gt;Job&lt;/code&gt; 实例后，我们进入 &lt;code&gt;execute&lt;/code&gt; ，将其发送到通道的发送端。如果发送失败，我们在 &lt;code&gt;send&lt;/code&gt; 调用 &lt;code&gt;unwrap&lt;/code&gt; 。例如，如果我们停止执行所有线程，这意味着接收端已停止接收新消息，则可能会发生这种情况。目前，我们无法停止线程的执行：只要池存在，我们的线程就会继续执行。我们使用 &lt;code&gt;unwrap&lt;/code&gt; 的原因是我们知道不会发生失败情况，但是编译器却不知道。</target>
        </trans-unit>
        <trans-unit id="458779f7008edf7b181827b22b99edf77f39bc41" translate="yes" xml:space="preserve">
          <source>After dropping the lock, we can print the mutex value and see that we were able to change the inner &lt;code&gt;i32&lt;/code&gt; to 6.</source>
          <target state="translated">删除锁后，我们可以打印互斥锁值，并看到我们能够将内部 &lt;code&gt;i32&lt;/code&gt; 更改为6。</target>
        </trans-unit>
        <trans-unit id="04760e628105c26e60bea171285ea7fc05de2cc2" translate="yes" xml:space="preserve">
          <source>After implementing the trait, we can call the methods on instances of &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; in the same way we call regular methods, like this:</source>
          <target state="translated">实现该特征后，我们可以像调用常规方法一样，在 &lt;code&gt;NewsArticle&lt;/code&gt; 和 &lt;code&gt;Tweet&lt;/code&gt; 实例上调用这些方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="6aee078dffc9ca07e378d1b98649828937e42093" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-21.</source>
          <target state="translated">在学习了第18章中的 &lt;code&gt;while let&lt;/code&gt; 循环之后，您可能想知道为什么我们没有编写清单20-21所示的工作线程代码。</target>
        </trans-unit>
        <trans-unit id="5a81464f303d05310b655ad576139ba2eadc374a" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-22.</source>
          <target state="translated">在学习了第18章中的 &lt;code&gt;while let&lt;/code&gt; 循环之后，您可能想知道为什么我们没有编写清单20-22所示的工作线程代码。</target>
        </trans-unit>
        <trans-unit id="56e7d653965ec5efdfa2c953ebd2075ad09eb04a" translate="yes" xml:space="preserve">
          <source>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the &lt;code&gt;|&lt;/code&gt; operator, the arm would have matched and the program would have printed &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">运行代码后，优先级行为是显而易见的：如果将匹配保护仅应用于使用 &lt;code&gt;|&lt;/code&gt; 指定的值列表中的最终值。运算符，手臂将匹配并且程序将打印 &lt;code&gt;yes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6918a63768fd69dd2401af6cba199a57c7c6b4f3" translate="yes" xml:space="preserve">
          <source>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it&amp;rsquo;s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</source>
          <target state="translated">一段时间后，一旦使用夜间发布的Rust开发人员能够试用新功能，团队成员将讨论该功能，如何每晚进行开发，并决定是否应将其构建为稳定的Rust。如果决定继续前进，则移除特征门，并且现在认为该特征稳定！它使火车进入一个稳定的Rust新版本。</target>
        </trans-unit>
        <trans-unit id="780f735c7776bf172259bb14b7f1d801e95b8329" translate="yes" xml:space="preserve">
          <source>After that statement, we&amp;rsquo;ve again added a temporary &lt;code&gt;println!&lt;/code&gt; statement that prints the value of &lt;code&gt;contents&lt;/code&gt; after the file is read, so we can check that the program is working so far.</source>
          <target state="translated">声明之后，我们再次添加了一个临时 &lt;code&gt;println!&lt;/code&gt; 语句，该语句在读取文件后打印 &lt;code&gt;contents&lt;/code&gt; 的值，因此我们可以检查程序是否正常运行。</target>
        </trans-unit>
        <trans-unit id="96e831200e66693625317e3844fc1e89f068a7a9" translate="yes" xml:space="preserve">
          <source>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the &lt;code&gt;Summary&lt;/code&gt; trait will have the method &lt;code&gt;summarize&lt;/code&gt; defined with this signature exactly.</source>
          <target state="translated">在方法签名之后，我们使用分号代替在大括号内提供实现。实现此特征的每种类型都必须为方法的主体提供其自己的自定义行为。编译器将强制要求具有 &lt;code&gt;Summary&lt;/code&gt; 特征的任何类型都必须使用此签名准确定义方法 &lt;code&gt;summarize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd61e6cd4b0dca5587c3bdc8b19a36c54df5d01a" translate="yes" xml:space="preserve">
          <source>After the parameters, we place curly brackets that hold the body of the closure&amp;mdash;these are optional if the closure body is a single expression. The end of the closure, after the curly brackets, needs a semicolon to complete the &lt;code&gt;let&lt;/code&gt; statement. The value returned from the last line in the closure body (&lt;code&gt;num&lt;/code&gt;) will be the value returned from the closure when it&amp;rsquo;s called, because that line doesn&amp;rsquo;t end in a semicolon; just as in function bodies.</source>
          <target state="translated">在参数之后，我们放置用于括起闭包主体的花括号，如果闭包主体是单个表达式，则这些括号是可选的。闭括号的结尾（大括号后）需要用分号来完成 &lt;code&gt;let&lt;/code&gt; 语句。从闭包主体（ &lt;code&gt;num&lt;/code&gt; ）的最后一行返回的值将是在被调用时从闭包返回的值，因为该行不是以分号结尾。就像在功能主体中一样。</target>
        </trans-unit>
        <trans-unit id="3409f581311196341ada32cc2fb23895a79e2d64" translate="yes" xml:space="preserve">
          <source>After the request line, the remaining lines starting from &lt;code&gt;Host:&lt;/code&gt; onward are headers. &lt;code&gt;GET&lt;/code&gt; requests have no body.</source>
          <target state="translated">在请求行之后，从 &lt;code&gt;Host:&lt;/code&gt; 开始的其余行是标头。 &lt;code&gt;GET&lt;/code&gt; 请求没有内容。</target>
        </trans-unit>
        <trans-unit id="94ada77990e54a7199b314d48e7c28b8866c26f5" translate="yes" xml:space="preserve">
          <source>After these two lines, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;foobar&lt;/code&gt;. The &lt;code&gt;push_str&lt;/code&gt; method takes a string slice because we don&amp;rsquo;t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&amp;rsquo;t able to use &lt;code&gt;s2&lt;/code&gt; after appending its contents to &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">在这两行之后， &lt;code&gt;s&lt;/code&gt; 将包含 &lt;code&gt;foobar&lt;/code&gt; 。该 &lt;code&gt;push_str&lt;/code&gt; 方法需要一个字符串切片，因为我们并不一定要带参数的所有权。例如，清单8-16中的代码显示，如果将 &lt;code&gt;s2&lt;/code&gt; 的内容附加到 &lt;code&gt;s1&lt;/code&gt; 之后仍然无法使用s2，那将是不幸的。</target>
        </trans-unit>
        <trans-unit id="d28bc7bf7124bb617821696b52f238bf37faf9be" translate="yes" xml:space="preserve">
          <source>After they have been consumed, the rest of the elements are yielded. Rather than overriding this method directly, instead override the &lt;code&gt;nth&lt;/code&gt; method.</source>
          <target state="translated">消耗掉它们之后，剩下的元素就会产生。而不是直接覆盖此方法，而是覆盖第 &lt;code&gt;nth&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="d1a8c993e11b907a98ea3122f628acdebbd6b42e" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed &lt;code&gt;libc&lt;/code&gt; and &lt;code&gt;rand_core&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on those to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">更新注册表后，Cargo会检查 &lt;code&gt;[dependencies]&lt;/code&gt; 部分并下载您还没有的任何板条箱。在这种情况下，尽管我们仅将 &lt;code&gt;rand&lt;/code&gt; 列为依赖项，但Cargo也抓取了 &lt;code&gt;libc&lt;/code&gt; 和 &lt;code&gt;rand_core&lt;/code&gt; ，因为 &lt;code&gt;rand&lt;/code&gt; 依赖于它们工作。下载板条箱后，Rust编译它们，然后使用可用的依赖项编译项目。</target>
        </trans-unit>
        <trans-unit id="17378b2abc480d099ee902b5db16470e7091ec08" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed a copy of &lt;code&gt;libc&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on &lt;code&gt;libc&lt;/code&gt; to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">更新注册表后，Cargo会检查 &lt;code&gt;[dependencies]&lt;/code&gt; 部分并下载您还没有的任何板条箱。在这种情况下，尽管我们仅将 &lt;code&gt;rand&lt;/code&gt; 列为依赖项，但Cargo也获取了 &lt;code&gt;libc&lt;/code&gt; 的副本，因为 &lt;code&gt;rand&lt;/code&gt; 依赖 &lt;code&gt;libc&lt;/code&gt; 来工作。下载板条箱后，Rust编译它们，然后使用可用的依赖项编译项目。</target>
        </trans-unit>
        <trans-unit id="9d98c1489e41fbd88598871e5f8d212bbc3f78c5" translate="yes" xml:space="preserve">
          <source>After we define &lt;code&gt;summarize_author&lt;/code&gt;, we can call &lt;code&gt;summarize&lt;/code&gt; on instances of the &lt;code&gt;Tweet&lt;/code&gt; struct, and the default implementation of &lt;code&gt;summarize&lt;/code&gt; will call the definition of &lt;code&gt;summarize_author&lt;/code&gt; that we&amp;rsquo;ve provided. Because we&amp;rsquo;ve implemented &lt;code&gt;summarize_author&lt;/code&gt;, the &lt;code&gt;Summary&lt;/code&gt; trait has given us the behavior of the &lt;code&gt;summarize&lt;/code&gt; method without requiring us to write any more code.</source>
          <target state="translated">之后我们定义 &lt;code&gt;summarize_author&lt;/code&gt; ，我们可以称之为 &lt;code&gt;summarize&lt;/code&gt; 的实例 &lt;code&gt;Tweet&lt;/code&gt; 结构，并默认执行 &lt;code&gt;summarize&lt;/code&gt; 会调用的定义 &lt;code&gt;summarize_author&lt;/code&gt; ，我们已经提供。因为我们已经实现 &lt;code&gt;summarize_author&lt;/code&gt; ，在 &lt;code&gt;Summary&lt;/code&gt; 特点给了我们的行为， &lt;code&gt;summarize&lt;/code&gt; 方法，而不需要我们编写任何代码。</target>
        </trans-unit>
        <trans-unit id="2556b8fd31ff1260ec94fc2ed10873de0af61a38" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve acquired the lock, we can treat the return value, named &lt;code&gt;num&lt;/code&gt; in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; is not an &lt;code&gt;i32&lt;/code&gt;, so we &lt;em&gt;must&lt;/em&gt; acquire the lock to be able to use the &lt;code&gt;i32&lt;/code&gt; value. We can&amp;rsquo;t forget; the type system won&amp;rsquo;t let us access the inner &lt;code&gt;i32&lt;/code&gt; otherwise.</source>
          <target state="translated">获取锁之后，我们可以将返回值（在本例中为 &lt;code&gt;num&lt;/code&gt; )视为对内部数据的可变引用。类型系统确保在使用 &lt;code&gt;m&lt;/code&gt; 中的值之前先获取一个锁： &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; 不是 &lt;code&gt;i32&lt;/code&gt; ，因此我们&lt;em&gt;必须&lt;/em&gt;获取该锁才能使用 &lt;code&gt;i32&lt;/code&gt; 值。我们不能忘记；类型系统不允许我们访问内部 &lt;code&gt;i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eea76bdbc5658f7fad1ad625716859e45f8c384f" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created &lt;em&gt;tests/common/mod.rs&lt;/em&gt;, we can use it from any of the integration test files as a module. Here&amp;rsquo;s an example of calling the &lt;code&gt;setup&lt;/code&gt; function from the &lt;code&gt;it_adds_two&lt;/code&gt; test in &lt;em&gt;tests/integration_test.rs&lt;/em&gt;:</source>
          <target state="translated">创建&lt;em&gt;tests / common / mod.rs之后&lt;/em&gt;，我们可以将其从任何集成测试文件中用作模块。这是从&lt;em&gt;tests / integration_test.rs中&lt;/em&gt;的 &lt;code&gt;it_adds_two&lt;/code&gt; 测试调用 &lt;code&gt;setup&lt;/code&gt; 函数的示例：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43dc84fb12e1a579a9d73c911c37d0ab1b82a9f5" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created the lists in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we add 10 to the value in &lt;code&gt;value&lt;/code&gt;. We do this by calling &lt;code&gt;borrow_mut&lt;/code&gt; on &lt;code&gt;value&lt;/code&gt;, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;Where&amp;rsquo;s the &lt;code&gt;-&amp;gt;&lt;/code&gt; Operator?&amp;rdquo;&lt;/a&gt;) to dereference the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to the inner &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; value. The &lt;code&gt;borrow_mut&lt;/code&gt; method returns a &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, and we use the dereference operator on it and change the inner value.</source>
          <target state="translated">在 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 中创建列表之后，将10添加到value中的 &lt;code&gt;value&lt;/code&gt; 。我们通过在 &lt;code&gt;value&lt;/code&gt; 上调用 &lt;code&gt;borrow_mut&lt;/code&gt; 来做到这一点，该函数使用我们在第5章中讨论过的自动取消引用功能（请参阅&lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo; &lt;code&gt;-&amp;gt;&lt;/code&gt; 运算符在哪里&amp;rdquo;一节&lt;/a&gt;）将 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 取消引用到内部 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 值。该 &lt;code&gt;borrow_mut&lt;/code&gt; 方法返回一个 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 智能指针，并且我们使用在其上的引用操作和改变内的值。</target>
        </trans-unit>
        <trans-unit id="b18bd157b258782bdf4328d729095843e56901f9" translate="yes" xml:space="preserve">
          <source>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler&amp;rsquo;s code so the borrow checker could infer the lifetimes in these situations and wouldn&amp;rsquo;t need explicit annotations.</source>
          <target state="translated">在编写了很多Rust代码之后，Rust团队发现Rust程序员在特定情况下一遍又一遍地输入相同的生命周期注释。这些情况是可以预测的，并遵循一些确定性模式。开发人员将这些模式编程到编译器的代码中，因此借用检查器可以推断出这些情况下的生存期，并且不需要显式注释。</target>
        </trans-unit>
        <trans-unit id="8911f4e8942ad7726d100e32781ae750b7e4baf7" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve installed Rust via &lt;code&gt;rustup&lt;/code&gt;, updating to the latest version is easy. From your shell, run the following update script:</source>
          <target state="translated">通过 &lt;code&gt;rustup&lt;/code&gt; 安装Rust 后，更新到最新版本很容易。在您的外壳中，运行以下更新脚本：</target>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="translated">After:</target>
        </trans-unit>
        <trans-unit id="1d0c9f96248d537407790c171b6d4f7cd1fd7157" translate="yes" xml:space="preserve">
          <source>Again, this is the simplest implementation of the &lt;code&gt;execute&lt;/code&gt; method: it does nothing, but we&amp;rsquo;re trying only to make our code compile. Let&amp;rsquo;s check it again:</source>
          <target state="translated">同样，这是 &lt;code&gt;execute&lt;/code&gt; 方法的最简单实现：它什么也不做，但是我们只是在尝试使我们的代码编译。让我们再次检查一下：</target>
        </trans-unit>
        <trans-unit id="7b6d0c4005bedf77e43140c67158dc3c2786f272" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;re using &lt;code&gt;thread::spawn&lt;/code&gt; to create a new thread and then using &lt;code&gt;move&lt;/code&gt; to move &lt;code&gt;tx&lt;/code&gt; into the closure so the spawned thread owns &lt;code&gt;tx&lt;/code&gt;. The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</source>
          <target state="translated">再次，我们使用 &lt;code&gt;thread::spawn&lt;/code&gt; 创建一个新线程，然后使用 &lt;code&gt;move&lt;/code&gt; 将 &lt;code&gt;tx&lt;/code&gt; 移到闭包中，因此生成的线程拥有 &lt;code&gt;tx&lt;/code&gt; 。产生的线程需要拥有通道的发送端才能通过通道发送消息。</target>
        </trans-unit>
        <trans-unit id="42935bf9ba7e07a25a52edfb6e2d38809a0c1bab" translate="yes" xml:space="preserve">
          <source>Again, you need not specify the full type if the compiler can infer it:</source>
          <target state="translated">同样,如果编译器可以推断出完整的类型,你就不需要指定它。</target>
        </trans-unit>
        <trans-unit id="3cc0e9834230ccbe94275d501fa3b8e31c8d1c62" translate="yes" xml:space="preserve">
          <source>Aha! The first error message indicates that &lt;code&gt;counter&lt;/code&gt; is moved into the closure for the thread associated with &lt;code&gt;handle&lt;/code&gt;. That move is preventing us from capturing &lt;code&gt;counter&lt;/code&gt; when we try to call &lt;code&gt;lock&lt;/code&gt; on it and store the result in &lt;code&gt;num2&lt;/code&gt; in the second thread! So Rust is telling us that we can&amp;rsquo;t move ownership of &lt;code&gt;counter&lt;/code&gt; into multiple threads. This was hard to see earlier because our threads were in a loop, and Rust can&amp;rsquo;t point to different threads in different iterations of the loop. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">啊哈！第一条错误消息指示将 &lt;code&gt;counter&lt;/code&gt; 移入与 &lt;code&gt;handle&lt;/code&gt; 关联的线程的闭包中。当我们尝试对其调用 &lt;code&gt;lock&lt;/code&gt; 并将结果存储在第二个线程中的 &lt;code&gt;num2&lt;/code&gt; 中时，此举使我们无法捕获 &lt;code&gt;counter&lt;/code&gt; ！因此，Rust告诉我们，我们不能将 &lt;code&gt;counter&lt;/code&gt; 所有权转移到多个线程中。这很难在早期看到，因为我们的线程处于循环中，并且Rust无法在循环的不同迭代中指向不同的线程。让我们使用第15章中讨论的多所有权方法修复编译器错误。</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="6c230b19ce360dc47ab1f803ec5d75221398ff9e" translate="yes" xml:space="preserve">
          <source>Alignment::borrow</source>
          <target state="translated">Alignment::borrow</target>
        </trans-unit>
        <trans-unit id="77b6c3d761057550ac535096603085a4ab21f25d" translate="yes" xml:space="preserve">
          <source>Alignment::borrow_mut</source>
          <target state="translated">Alignment::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d45a68b20b4cc6114f5421add49178bf870ce27b" translate="yes" xml:space="preserve">
          <source>Alignment::fmt</source>
          <target state="translated">Alignment::fmt</target>
        </trans-unit>
        <trans-unit id="0912a9a905355e3a6df915cce4fce3e26fba4e82" translate="yes" xml:space="preserve">
          <source>Alignment::from</source>
          <target state="translated">Alignment::from</target>
        </trans-unit>
        <trans-unit id="14750a6b1eb92c0620b2d52bd702a109608e9cb3" translate="yes" xml:space="preserve">
          <source>Alignment::into</source>
          <target state="translated">Alignment::into</target>
        </trans-unit>
        <trans-unit id="b06fe916f5f193304938aca87ce9baf4fe4a81c0" translate="yes" xml:space="preserve">
          <source>Alignment::try_from</source>
          <target state="translated">Alignment::try_from</target>
        </trans-unit>
        <trans-unit id="7e4c9d31924344ef62791e3f5778cc0b64650841" translate="yes" xml:space="preserve">
          <source>Alignment::try_into</source>
          <target state="translated">Alignment::try_into</target>
        </trans-unit>
        <trans-unit id="f8d85378f8bd14502ad4a535bf35eace323f7be0" translate="yes" xml:space="preserve">
          <source>Alignment::type_id</source>
          <target state="translated">Alignment::type_id</target>
        </trans-unit>
        <trans-unit id="1f13dd31cf3795018ba8cb51097f5cee92e51d26" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;items&quot;&gt;item declarations&lt;/a&gt; accept outer attributes while &lt;a href=&quot;items/external-blocks&quot;&gt;external blocks&lt;/a&gt;, &lt;a href=&quot;items/functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt;, and &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt; accept inner attributes.</source>
          <target state="translated">所有&lt;a href=&quot;items&quot;&gt;项目声明都&lt;/a&gt;接受外部属性，而&lt;a href=&quot;items/external-blocks&quot;&gt;外部块&lt;/a&gt;，&lt;a href=&quot;items/functions&quot;&gt;函数&lt;/a&gt;，&lt;a href=&quot;items/implementations&quot;&gt;实现&lt;/a&gt;和&lt;a href=&quot;items/modules&quot;&gt;模块则&lt;/a&gt;接受内部属性。</target>
        </trans-unit>
        <trans-unit id="e7edfb23f380c12b821737c77295267e0d55adfa" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;if&lt;/code&gt; expressions start with the keyword &lt;code&gt;if&lt;/code&gt;, which is followed by a condition. In this case, the condition checks whether or not the variable &lt;code&gt;number&lt;/code&gt; has a value less than 5. The block of code we want to execute if the condition is true is placed immediately after the condition inside curly brackets. Blocks of code associated with the conditions in &lt;code&gt;if&lt;/code&gt; expressions are sometimes called &lt;em&gt;arms&lt;/em&gt;, just like the arms in &lt;code&gt;match&lt;/code&gt; expressions that we discussed in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section of Chapter 2.</source>
          <target state="translated">所有 &lt;code&gt;if&lt;/code&gt; 表达式均以关键字 &lt;code&gt;if&lt;/code&gt; 开头，后跟一个条件。在这种情况下，条件检查变量 &lt;code&gt;number&lt;/code&gt; 的值是否小于5。如果条件为真，我们要执行的代码块将紧接在条件后放在大括号内。与 &lt;code&gt;if&lt;/code&gt; 表达式中的条件相关联的代码块有时称为&lt;em&gt;arm&lt;/em&gt;，就像我们在第2章的&lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;将猜测与秘密数进行比较&amp;rdquo;&lt;/a&gt;一节中讨论的 &lt;code&gt;match&lt;/code&gt; 表达式中的arm一样。</target>
        </trans-unit>
        <trans-unit id="6d770608aae868ce44cc837cd9b78c8161bf1b4b" translate="yes" xml:space="preserve">
          <source>All ASCII</source>
          <target state="translated">所有ASCII码</target>
        </trans-unit>
        <trans-unit id="941b268ba2f8b2e2bf50827de379fcc106a7ae00" translate="yes" xml:space="preserve">
          <source>All Rust compiler versions support any edition that existed prior to that compiler&amp;rsquo;s release, and they can link crates of any supported editions together. Edition changes only affect the way the compiler initially parses code. Therefore, if you&amp;rsquo;re using Rust 2015 and one of your dependencies uses Rust 2018, your project will compile and be able to use that dependency. The opposite situation, where your project uses Rust 2018 and a dependency uses Rust 2015, works as well.</source>
          <target state="translated">所有Rust编译器版本都支持该编译器发行之前存在的任何版本，并且它们可以将任何受支持版本的板条箱链接在一起。版本更改仅影响编译器最初解析代码的方式。因此，如果您使用的是Rust 2015，并且其中一个依赖项使用Rust 2018，则您的项目将可以编译并使用该依赖项。相反的情况也适用，在这种情况下，您的项目使用Rust 2018，而依赖项使用Rust 2015。</target>
        </trans-unit>
        <trans-unit id="7652c7eeda6497653864c68957d9fcd32bd3f053" translate="yes" xml:space="preserve">
          <source>All Unicode</source>
          <target state="translated">所有Unicode</target>
        </trans-unit>
        <trans-unit id="47de5609df925352bb65b1c68fe6d11ef3c5f11f" translate="yes" xml:space="preserve">
          <source>All Unicode characters contained in the raw string body represent themselves, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">原始字符串主体中包含的所有Unicode字符均表示自身，即字符 &lt;code&gt;U+0022&lt;/code&gt; （双引号）（除非后面至少跟开始原始字符串文字时使用的 &lt;code&gt;U+0023&lt;/code&gt; （ &lt;code&gt;#&lt;/code&gt; ）字符相同）或 &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）没有任何特殊含义。</target>
        </trans-unit>
        <trans-unit id="8a1ba3bb13e8cd072a280ba55ff12cd4ec0faacf" translate="yes" xml:space="preserve">
          <source>All access to a static is safe, but there are a number of restrictions on statics:</source>
          <target state="translated">所有对静态的访问都是安全的,但对静态有一些限制。</target>
        </trans-unit>
        <trans-unit id="cc4193fdbde0490cb6df1ff9fd4927655f61fac3" translate="yes" xml:space="preserve">
          <source>All access to the inner value through methods is &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">通过方法对内部值的所有访问都是 &lt;code&gt;unsafe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ceb9b59e717209dd478129622af76401fc92a7ef" translate="yes" xml:space="preserve">
          <source>All accesses performed by functions in this module are &lt;em&gt;non-atomic&lt;/em&gt; in the sense of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic operations&lt;/a&gt; used to synchronize between threads. This means it is undefined behavior to perform two concurrent accesses to the same location from different threads unless both accesses only read from memory. Notice that this explicitly includes &lt;a href=&quot;fn.read_volatile&quot;&gt;&lt;code&gt;read_volatile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;/code&gt;&lt;/a&gt;: Volatile accesses cannot be used for inter-thread synchronization.</source>
          <target state="translated">就用于在线程之间同步的&lt;a href=&quot;../sync/atomic/index&quot;&gt;原子操作而言&lt;/a&gt;，此模块中功能执行的所有访问都是&lt;em&gt;非原子&lt;/em&gt;的。这意味着从两个不同的线程对同一位置执行两次并发访问是不确定的行为，除非两个访问都仅从内存中读取。请注意，这明确包含&lt;a href=&quot;fn.read_volatile&quot;&gt; &lt;code&gt;read_volatile&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.write_volatile&quot;&gt; &lt;code&gt;write_volatile&lt;/code&gt; &lt;/a&gt;：易失性访问不能用于线程间同步。</target>
        </trans-unit>
        <trans-unit id="286be0b8b15ccf1efa39407656b792f78e80afd9" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="translated">所有摊销成本均用于容量耗尽时可能需要调整的大小。如果发生调整大小，则将花费&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）时间。我们的馆藏永远不会自动缩小，因此移除操作不会摊销。在足够多的工序系列中，每次工序的平均成本将确定性地等于给定成本。</target>
        </trans-unit>
        <trans-unit id="5d3e246179e6158acb2b336b6eaaa6c3cd96b12d" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take O(n) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="translated">所有摊销成本都是针对容量耗尽时可能需要调整规模的情况。如果发生调整大小,将需要O(n)时间。我们的藏品永远不会自动缩小,所以删除操作不会被摊销。在一系列足够大的操作中,每次操作的平均成本将确定性地等于给定成本。</target>
        </trans-unit>
        <trans-unit id="ad40505a1a509d19ac8713b0e6d72bf2f8406439" translate="yes" xml:space="preserve">
          <source>All associated functions must either have a &lt;code&gt;where Self: Sized&lt;/code&gt; bound, or</source>
          <target state="translated">所有关联的函数必须具有&amp;ldquo; &lt;code&gt;where Self: Sized&lt;/code&gt; 约束，或</target>
        </trans-unit>
        <trans-unit id="15061bca973f1e3bdfd6bc4220f487a4d9f0fa2e" translate="yes" xml:space="preserve">
          <source>All atomic types in this module are guaranteed to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;lock-free&lt;/a&gt; if they're available. This means they don't internally acquire a global mutex. Atomic types and operations are not guaranteed to be wait-free. This means that operations like &lt;code&gt;fetch_or&lt;/code&gt; may be implemented with a compare-and-swap loop.</source>
          <target state="translated">如果可用，则保证此模块中的所有原子类型都是&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;无锁的&lt;/a&gt;。这意味着他们没有在内部获取全局互斥量。不能保证原子类型和操作无需等待。这意味着可以使用比较交换循环来实现类似 &lt;code&gt;fetch_or&lt;/code&gt; 的操作。</target>
        </trans-unit>
        <trans-unit id="290ed2d52fa06b05e83bf6a12f1d4aa3dca7ba7c" translate="yes" xml:space="preserve">
          <source>All binaries installed with &lt;code&gt;cargo install&lt;/code&gt; are stored in the installation root&amp;rsquo;s &lt;em&gt;bin&lt;/em&gt; folder. If you installed Rust using &lt;em&gt;rustup.rs&lt;/em&gt; and don&amp;rsquo;t have any custom configurations, this directory will be &lt;em&gt;$HOME/.cargo/bin&lt;/em&gt;. Ensure that directory is in your &lt;code&gt;$PATH&lt;/code&gt; to be able to run programs you&amp;rsquo;ve installed with &lt;code&gt;cargo install&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;cargo install&lt;/code&gt; 一起安装的所有二进制文件都存储在安装根目录的&lt;em&gt;bin&lt;/em&gt;文件夹中。如果您使用&lt;em&gt;rustup.rs&lt;/em&gt;安装了Rust，并且没有任何自定义配置，则此目录将为&lt;em&gt;$ HOME / .cargo / bin&lt;/em&gt;。确保该目录位于 &lt;code&gt;$PATH&lt;/code&gt; ，以便能够运行通过 &lt;code&gt;cargo install&lt;/code&gt; 安装的程序。</target>
        </trans-unit>
        <trans-unit id="33d170f2503ad727df2773d3d501af5a7c6f33f7" translate="yes" xml:space="preserve">
          <source>All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; which are banned since they are short-circuiting.</source>
          <target state="translated">除 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 以外的所有布尔运算符 由于它们短路，因此被禁止。</target>
        </trans-unit>
        <trans-unit id="1797e85af758baa0954345dbaa6c305b8c789f74" translate="yes" xml:space="preserve">
          <source>All bytes read from this source will be appended to the specified buffer &lt;code&gt;buf&lt;/code&gt;. This function will continuously call &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; to append more data to &lt;code&gt;buf&lt;/code&gt; until &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; returns either &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt; or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind.</source>
          <target state="translated">从该源读取的所有字节都将附加到指定的缓冲区 &lt;code&gt;buf&lt;/code&gt; 。该函数将连续调用&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;将更多数据附加到 &lt;code&gt;buf&lt;/code&gt; ,直到&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;或非&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误。</target>
        </trans-unit>
        <trans-unit id="7b662763d511d397b2cbc49f35a59edd0871bf65" translate="yes" xml:space="preserve">
          <source>All calls to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="translated">所有在返回的实例上进行&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;操作的调用都将返回 &lt;code&gt;Ok(buf.len())&lt;/code&gt; ,并且不会检查缓冲区的内容。</target>
        </trans-unit>
        <trans-unit id="792e4e8c3b4454b76d09b3a55c5244a2a04987c6" translate="yes" xml:space="preserve">
          <source>All calls to &lt;code&gt;write&lt;/code&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="translated">返回的实例上的所有 &lt;code&gt;write&lt;/code&gt; 操作都将返回 &lt;code&gt;Ok(buf.len())&lt;/code&gt; ,并且不会检查缓冲区的内容。</target>
        </trans-unit>
        <trans-unit id="163ac7eae61cfe370b91ace9f314d434af91aec2" translate="yes" xml:space="preserve">
          <source>All characters contained in the raw string body represent their ASCII encoding, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">原始字符串主体中包含的所有字符均表示其ASCII编码，即字符 &lt;code&gt;U+0022&lt;/code&gt; （双引号）（但后跟至少与开始原始字符串文字一样多的 &lt;code&gt;U+0023&lt;/code&gt; （ &lt;code&gt;#&lt;/code&gt; ）字符除外）或 &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）没有任何特殊含义。</target>
        </trans-unit>
        <trans-unit id="43d6b6384605c36d010e25334a7b59d1666b30b5" translate="yes" xml:space="preserve">
          <source>All closure types implement &lt;a href=&quot;../special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;. Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</source>
          <target state="translated">所有闭包类型都实现&lt;a href=&quot;../special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;。此外，如果封闭类型存储的捕获类型允许，则它具有以下特征：</target>
        </trans-unit>
        <trans-unit id="a34254512b20b7c3c4f4d4cb8623d62bc5f25917" translate="yes" xml:space="preserve">
          <source>All crates have a &lt;em&gt;prelude&lt;/em&gt; that automatically inserts names from a specific module, the &lt;em&gt;prelude module&lt;/em&gt;, into scope of each &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; and an &lt;a href=&quot;items/extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; into the crate root module. By default, the &lt;em&gt;standard prelude&lt;/em&gt; is used. The linked crate is &lt;a href=&quot;../std/index&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;../std/prelude/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所有包装箱都有一个&lt;em&gt;前奏&lt;/em&gt;，可以自动将特定模块（&lt;em&gt;前奏模块）中的&lt;/em&gt;名称插入每个&lt;a href=&quot;items/modules&quot;&gt;模块的&lt;/a&gt;作用域，并将&lt;a href=&quot;items/extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt;插入到包装箱根模块中。默认情况下，使用&lt;em&gt;标准前奏&lt;/em&gt;。链接的板条箱为&lt;a href=&quot;../std/index&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;，而prelude模块为&lt;a href=&quot;../std/prelude/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80e6d9f67f0a7d01f6edd0112ce6e32390cc7b99" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前所有被阻止并且将来的&lt;a href=&quot;../io/trait.read&quot;&gt;读取&lt;/a&gt;将返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab960fd018156ee2b72c293b0f7c46b28b261211" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">当前所有被阻止并且将来的&lt;a href=&quot;../io/trait.read&quot;&gt;读取&lt;/a&gt;将返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6d40cb983863467fc229fa6f4b9f265ef62418a" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.write&quot;&gt;writes&lt;/a&gt; will return an error.</source>
          <target state="translated">当前所有被阻止并且将来的&lt;a href=&quot;../io/trait.write&quot;&gt;写入&lt;/a&gt;将返回错误。</target>
        </trans-unit>
        <trans-unit id="c24e8493495f5eda7feccf15dd8b5779f86db545" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="translated">堆栈中存储的所有数据必须具有已知的固定大小。编译时大小未知或大小可能更改的数据必须存储在堆中。堆的组织性较差：将数据放在堆上时，您需要一定数量的空间。内存分配器在堆中找到一个足够大的空白点，将其标记为正在使用中，并返回一个&lt;em&gt;指针&lt;/em&gt;（即该位置的地址）。此过程称为&lt;em&gt;在堆上分配，&lt;/em&gt;有时缩写为&lt;em&gt;allocating&lt;/em&gt;。将值压入堆栈不被视为分配。由于指针是已知的固定大小，因此可以将指针存储在堆栈上，但是当需要实际数据时，必须遵循指针。</target>
        </trans-unit>
        <trans-unit id="b5ad10491502eb3084d1fb833cddef2d6e97c099" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="translated">堆栈中存储的所有数据必须具有已知的固定大小。相反，在编译时大小未知或大小可能更改的数据必须存储在堆中。堆的组织性较差：将数据放在堆上时，您需要一定数量的空间。操作系统在堆中找到一个足够大的空白点，将其标记为正在使用中，然后返回一个&lt;em&gt;指针&lt;/em&gt;，该&lt;em&gt;指针&lt;/em&gt;是该位置的地址。此过程称为&lt;em&gt;在堆上分配，&lt;/em&gt;有时缩写为&lt;em&gt;allocating&lt;/em&gt;。将值压入堆栈不被视为分配。由于指针是已知的固定大小，因此可以将指针存储在堆栈上，但是当需要实际数据时，必须遵循指针。</target>
        </trans-unit>
        <trans-unit id="c3ab61183db153bdcb93b3db49372bcfa15c64d0" translate="yes" xml:space="preserve">
          <source>All elements of arrays are always initialized, and access to an array is always bounds-checked in safe methods and operators.</source>
          <target state="translated">数组的所有元素总是被初始化,对数组的访问总是在安全方法和操作符中进行边界检查。</target>
        </trans-unit>
        <trans-unit id="7fbb5676d98408c23a91ee3e50ae6931e19803d3" translate="yes" xml:space="preserve">
          <source>All elements of slices are always initialized, and access to a slice is always bounds-checked in safe methods and operators.</source>
          <target state="translated">分片的所有元素总是被初始化,对分片的访问总是在安全方法和操作符中进行边界检查。</target>
        </trans-unit>
        <trans-unit id="5797b6e64335a290bd1264b10ba82cdf81409cc5" translate="yes" xml:space="preserve">
          <source>All fields in a &lt;code&gt;union&lt;/code&gt; are all at the same place in memory which means borrowing one borrows the entire &lt;code&gt;union&lt;/code&gt;, for the same lifetime:</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 中的所有字段都在内存中的同一位置，这意味着借用一个借方将整个 &lt;code&gt;union&lt;/code&gt; 在相同的生命周期内借用：</target>
        </trans-unit>
        <trans-unit id="833e88d98de8f4240c961bc71bc4ebdf6caf04e8" translate="yes" xml:space="preserve">
          <source>All five array values appear in the terminal, as expected. Even though &lt;code&gt;index&lt;/code&gt; will reach a value of &lt;code&gt;5&lt;/code&gt; at some point, the loop stops executing before trying to fetch a sixth value from the array.</source>
          <target state="translated">正如预期的那样，所有五个数组值都出现在终端中。即使 &lt;code&gt;index&lt;/code&gt; 有时会达到 &lt;code&gt;5&lt;/code&gt; 的值，循环也会在尝试从数组中获取第六个值之前停止执行。</target>
        </trans-unit>
        <trans-unit id="9baa2527c7d6929ffc1c3e903b5bd7bcaaf4a17a" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="translated">循环的所有四种类型都支持&lt;a href=&quot;#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 表达式&lt;/a&gt;，&lt;a href=&quot;#continue-expressions&quot;&gt; &lt;code&gt;continue&lt;/code&gt; 表达式&lt;/a&gt;和&lt;a href=&quot;#loop-labels&quot;&gt;标签&lt;/a&gt;。Only &lt;code&gt;loop&lt;/code&gt; 支持&lt;a href=&quot;#break-and-loop-values&quot;&gt;对非平凡值的求值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e11d83f6e553be6952611c97ac05bbc3817eeae9" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="translated">循环的所有四种类型都支持&lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 表达式&lt;/a&gt;，&lt;a href=&quot;loop-expr#continue-expressions&quot;&gt; &lt;code&gt;continue&lt;/code&gt; 表达式&lt;/a&gt;和&lt;a href=&quot;loop-expr#loop-labels&quot;&gt;标签&lt;/a&gt;。Only &lt;code&gt;loop&lt;/code&gt; 支持&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;对非平凡值的评估&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0615d0c10f128d4e7e9a656552c9285eca738194" translate="yes" xml:space="preserve">
          <source>All function items implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所有功能项都实现&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36815ff2f54c1ef032403bd6365a096bb5c32000" translate="yes" xml:space="preserve">
          <source>All function parameters are in the scope of the entire function body, so are dropped last when evaluating the function. Each actual function parameter is dropped after any bindings introduced in that parameter's pattern.</source>
          <target state="translated">所有的函数参数都在整个函数体的范围内,所以在评估函数时,最后放弃。每个实际的函数参数都会在该参数的模式中引入的任何绑定之后被放弃。</target>
        </trans-unit>
        <trans-unit id="c77d0720d55ff4ece3326614a73ddde6503e3179" translate="yes" xml:space="preserve">
          <source>All implementations of &lt;code&gt;Unsize&lt;/code&gt; are provided automatically by the compiler.</source>
          <target state="translated">&lt;code&gt;Unsize&lt;/code&gt; 的所有实现均由编译器自动提供。</target>
        </trans-unit>
        <trans-unit id="94282a18d174676690037624bae4b4b406cb02ee" translate="yes" xml:space="preserve">
          <source>All iterators implement a trait named &lt;code&gt;Iterator&lt;/code&gt; that is defined in the standard library. The definition of the trait looks like this:</source>
          <target state="translated">所有迭代器均实现在标准库中定义的名为 &lt;code&gt;Iterator&lt;/code&gt; 的特征。特征的定义如下所示：</target>
        </trans-unit>
        <trans-unit id="7da42c45b54f4237c99325204711121b9f08beec" translate="yes" xml:space="preserve">
          <source>All kinds of ASCII whitespace are considered:</source>
          <target state="translated">所有种类的ASCII空白都被考虑在内。</target>
        </trans-unit>
        <trans-unit id="3e530c202d9d3c48672f8f7b98a14e41befed3be" translate="yes" xml:space="preserve">
          <source>All kinds of whitespace are considered:</source>
          <target state="translated">各种空白都考虑到了。</target>
        </trans-unit>
        <trans-unit id="9c42bdece20642dd1d10ab718ff507235d349b8d" translate="yes" xml:space="preserve">
          <source>All layouts have an associated non-negative size and a power-of-two alignment.</source>
          <target state="translated">所有的布局都有一个相关的非负数大小和二分之一的幂数排列。</target>
        </trans-unit>
        <trans-unit id="ad65ecd6f4c6a3cd749629f3ba92add5fa618dd9" translate="yes" xml:space="preserve">
          <source>All layouts have an associated size and a power-of-two alignment.</source>
          <target state="translated">所有的布局都有一个相关的尺寸和二分之一的功率排列。</target>
        </trans-unit>
        <trans-unit id="7178a9053518ff1c5e401dc1d4bee4c24f25359b" translate="yes" xml:space="preserve">
          <source>All of</source>
          <target state="translated">所有的</target>
        </trans-unit>
        <trans-unit id="32f70044558e382c5ebf59ec68e9d711cc2cb7b2" translate="yes" xml:space="preserve">
          <source>All of the coefficients get stored in registers, which means accessing the values is very fast. There are no bounds checks on the array access at runtime. All these optimizations that Rust is able to apply make the resulting code extremely efficient. Now that you know this, you can use iterators and closures without fear! They make code seem like it&amp;rsquo;s higher level but don&amp;rsquo;t impose a runtime performance penalty for doing so.</source>
          <target state="translated">所有系数都存储在寄存器中，这意味着访问值非常快。在运行时对数组访问没有边界检查。Rust能够应用的所有这些优化使生成的代码非常高效。现在您已经知道了，您可以不用担心使用迭代器和闭包了！它们使代码看起来像是更高级别的代码，但这样做不会对运行时性能造成影响。</target>
        </trans-unit>
        <trans-unit id="17dabbf042cc2454dd1f0ba98c8b7c6f3be65ec5" translate="yes" xml:space="preserve">
          <source>All of the logic that manages the counts and value dropping is built into &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; and their implementations of the &lt;code&gt;Drop&lt;/code&gt; trait. By specifying that the relationship from a child to its parent should be a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; reference in the definition of &lt;code&gt;Node&lt;/code&gt;, you&amp;rsquo;re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 以及它们对 &lt;code&gt;Drop&lt;/code&gt; 特性的实现都内置了所有管理计数和值下降的逻辑。通过在 &lt;code&gt;Node&lt;/code&gt; 的定义中指定从子级到其父级的关系应为 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 引用，您可以使父级节点指向子级节点，反之亦然，而无需创建引用周期和内存泄漏。</target>
        </trans-unit>
        <trans-unit id="469c3254d30ae896569972fb8c0f6e762f31a91d" translate="yes" xml:space="preserve">
          <source>All of the standard collections provide several iterators for performing bulk manipulation of their contents. The three primary iterators almost every collection should provide are &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;iter_mut&lt;/code&gt;, and &lt;code&gt;into_iter&lt;/code&gt;. Some of these are not provided on collections where it would be unsound or unreasonable to provide them.</source>
          <target state="translated">所有标准集合都提供了几个迭代器，用于对其内容进行批量操作。几乎每个集合都应提供的三个主要迭代器是 &lt;code&gt;iter&lt;/code&gt; ， &lt;code&gt;iter_mut&lt;/code&gt; 和 &lt;code&gt;into_iter&lt;/code&gt; 。其中有些没有提供，可能会不合理或不合理。</target>
        </trans-unit>
        <trans-unit id="7c09f50beeaa399a934ba76d5cc5d913f4961d31" translate="yes" xml:space="preserve">
          <source>All of these are valid &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">所有这些都是有效的 &lt;code&gt;String&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="3488f647e2016335e532591f4617d056149f656a" translate="yes" xml:space="preserve">
          <source>All of these method calls are possible because we specified how the &lt;code&gt;next&lt;/code&gt; method works, and the standard library provides default implementations for other methods that call &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">所有这些方法调用都是可能的，因为我们指定了 &lt;code&gt;next&lt;/code&gt; 方法的工作方式，并且标准库为调用 &lt;code&gt;next&lt;/code&gt; 的其他方法提供了默认实现。</target>
        </trans-unit>
        <trans-unit id="2a8409870b71900361c6e9ce41cc4d8b31f5a720" translate="yes" xml:space="preserve">
          <source>All options are initially set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">所有选项最初都设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cec813890e4d07a2defc7bce522b39b7b6522a4d" translate="yes" xml:space="preserve">
          <source>All other arguments given to the &lt;code&gt;inline&lt;/code&gt; attribute will return this error. Example:</source>
          <target state="translated">赋予 &lt;code&gt;inline&lt;/code&gt; 属性的所有其他参数将返回此错误。例：</target>
        </trans-unit>
        <trans-unit id="01957b2f8a375b806a015963a415dc2f430add14" translate="yes" xml:space="preserve">
          <source>All other arguments given to the &lt;code&gt;instruction_set&lt;/code&gt; attribute will return this error. Example:</source>
          <target state="translated">赋予给 &lt;code&gt;instruction_set&lt;/code&gt; 属性的所有其他参数将返回此错误。例子：</target>
        </trans-unit>
        <trans-unit id="110d2b10be35d17317e6c561cf91a4fabbf8e826" translate="yes" xml:space="preserve">
          <source>All other characters are given hexadecimal Unicode escapes; see &lt;a href=&quot;#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所有其他字符均使用十六进制Unicode转义；参见&lt;a href=&quot;#method.escape_unicode&quot;&gt; &lt;code&gt;escape_unicode&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f76ce538d07b9974a525f600e48b7f5dff4ae16c" translate="yes" xml:space="preserve">
          <source>All other fragment specifiers have no restrictions.</source>
          <target state="translated">所有其他片段指定符没有限制。</target>
        </trans-unit>
        <trans-unit id="fef84ba857bf1c83a92f8d5a5b2d52afc2b3c691" translate="yes" xml:space="preserve">
          <source>All pointers (except for the null pointer) are valid for all operations of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="translated">所有指针（空指针除外）对&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;大小为零的&lt;/a&gt;所有操作均有效。</target>
        </trans-unit>
        <trans-unit id="bcec8da89ce19312f810d6e8b0a4c1c994af8c3f" translate="yes" xml:space="preserve">
          <source>All pointers in Rust are explicit first-class values. They can be moved or copied, stored into data structs, and returned from functions.</source>
          <target state="translated">Rust中的所有指针都是显式的一级值,它们可以移动或复制,存储到数据结构中,并从函数中返回。它们可以被移动或复制,存储到数据结构中,并从函数中返回。</target>
        </trans-unit>
        <trans-unit id="6a33c45e166bf3f976aac4c7eec793b7d8946ca1" translate="yes" xml:space="preserve">
          <source>All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave notes, or &lt;em&gt;comments&lt;/em&gt;, in their source code that the compiler will ignore but people reading the source code may find useful.</source>
          <target state="translated">所有程序员都努力使他们的代码易于理解，但有时需要额外的说明。在这些情况下，程序员在其源代码中留下注释或&lt;em&gt;注释&lt;/em&gt;，编译器将忽略它们，但阅读源代码的人可能会发现有用。</target>
        </trans-unit>
        <trans-unit id="aa0c879bcf5cab9e7f4749d5ede013d5bf918c1f" translate="yes" xml:space="preserve">
          <source>All programs have to manage the way they use a computer&amp;rsquo;s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it&amp;rsquo;s running.</source>
          <target state="translated">所有程序必须在运行时管理它们使用计算机内存的方式。某些语言具有垃圾回收功能，该垃圾回收功能会在程序运行时不断寻找不再使用的内存。在其他语言中，程序员必须显式分配和释放内存。Rust使用第三种方法：通过所有权系统管理内存，该系统具有一组在编译时检查的规则。程序运行时，所有所有权功能都不会减慢其运行速度。</target>
        </trans-unit>
        <trans-unit id="cf610b10a23cb06f62489f071586a11ed04b1ece" translate="yes" xml:space="preserve">
          <source>All reads from the returned reader will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">返回的读取器的所有读取将返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5edadac5bb39f603d58e3300e69ef3e103ed0e48" translate="yes" xml:space="preserve">
          <source>All reads from this reader will succeed by filling the specified buffer with the given byte.</source>
          <target state="translated">所有从这个读取器的读取都会成功,用给定的字节填充指定的缓冲区。</target>
        </trans-unit>
        <trans-unit id="8042ca5a8b0159faa7d15d89ddf16924d0bee8ca" translate="yes" xml:space="preserve">
          <source>All results of &lt;code&gt;next()&lt;/code&gt; need to be identical to the results of &lt;code&gt;next_back()&lt;/code&gt; in reverse order.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; 的所有结果必须与相反的 &lt;code&gt;next_back()&lt;/code&gt; 的结果相同。</target>
        </trans-unit>
        <trans-unit id="051b0a6da7e5a99366866472afe4cedd9c4ae587" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">遵循以下&lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt;语法的所有字符串将导致返回&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ba6c1035e6000e531913744213ce54c88bb453f8" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">遵循以下&lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt;语法的所有字符串都将返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8c2330d9e11176797f3b69c4b492614aa87568d1" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">遵循以下&lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt;语法的所有字符串将导致返回&lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5099415fb85a9568ce08c4de6d590b1962a9de28" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">遵循以下&lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt;语法的所有字符串都将返回&lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d19c4500c8b81bcefce226435a932d9bd67dd1d4" translate="yes" xml:space="preserve">
          <source>All supertraits must also be object safe.</source>
          <target state="translated">所有的超级系统也必须是对象安全的。</target>
        </trans-unit>
        <trans-unit id="3834b26accc0c7926a85719d5492f93bbdde2cd6" translate="yes" xml:space="preserve">
          <source>All the Places Patterns Can Be Used</source>
          <target state="translated">所有可以使用图案的地方</target>
        </trans-unit>
        <trans-unit id="70ddc33f2c0eb4587fa8e2cac6e8f77be9184d95" translate="yes" xml:space="preserve">
          <source>All the code we&amp;rsquo;ve discussed so far has had Rust&amp;rsquo;s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn&amp;rsquo;t enforce these memory safety guarantees: it&amp;rsquo;s called &lt;em&gt;unsafe Rust&lt;/em&gt; and works just like regular Rust, but gives us extra superpowers.</source>
          <target state="translated">到目前为止，我们讨论的所有代码都在编译时强制执行Rust的内存安全保证。但是，Rust内藏有第二种语言，它不能强制执行这些内存安全保证：它被称为&lt;em&gt;不安全的Rust&lt;/em&gt;，其作用与常规的Rust一样，但是为我们提供了额外的超能力。</target>
        </trans-unit>
        <trans-unit id="5d094a6ebf518b356f6cc88f0daffccbeaa88d1a" translate="yes" xml:space="preserve">
          <source>All the floating point types, such as &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">所有浮点类型，例如 &lt;code&gt;f64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49768c9761f944e57fd8b28ffb7ccca3ce0255bf" translate="yes" xml:space="preserve">
          <source>All the integer types, such as &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">所有整数类型，例如 &lt;code&gt;u32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7aad067d2eb4fd66349ef7460833027940768e31" translate="yes" xml:space="preserve">
          <source>All the traits in &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; except &lt;a href=&quot;fmt/trait.pointer&quot;&gt;&lt;code&gt;Pointer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">除&lt;a href=&quot;fmt/trait.pointer&quot;&gt; &lt;code&gt;Pointer&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt;外，&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;所有特征</target>
        </trans-unit>
        <trans-unit id="5fbc378a4bea0c74a504553c4655c69b13216d43" translate="yes" xml:space="preserve">
          <source>All tokens have an associated &lt;code&gt;Span&lt;/code&gt;. A &lt;code&gt;Span&lt;/code&gt; is an opaque value that cannot be modified but can be manufactured. &lt;code&gt;Span&lt;/code&gt;s represent an extent of source code within a program and are primarily used for error reporting. You can modify the &lt;code&gt;Span&lt;/code&gt; of any token.</source>
          <target state="translated">所有令牌都具有关联的 &lt;code&gt;Span&lt;/code&gt; 。甲 &lt;code&gt;Span&lt;/code&gt; 是不能被修改，但可以制造不透明值。 &lt;code&gt;Span&lt;/code&gt; 代表程序中源代码的范围，并且主要用于错误报告。您可以修改任何令牌的 &lt;code&gt;Span&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4b7c6a0fbafa4ae17e0c283d126acf9c731f848" translate="yes" xml:space="preserve">
          <source>All traits define an implicit type parameter &lt;code&gt;Self&lt;/code&gt; that refers to &quot;the type that is implementing this interface&quot;. Traits may also contain additional type parameters. These type parameters, including &lt;code&gt;Self&lt;/code&gt;, may be constrained by other traits and so forth &lt;a href=&quot;generics&quot;&gt;as usual&lt;/a&gt;.</source>
          <target state="translated">所有特征都定义一个隐式类型参数 &lt;code&gt;Self&lt;/code&gt; ，该参数引用&amp;ldquo;正在实现此接口的类型&amp;rdquo;。特性可能还包含其他类型参数。这些类型的参数，包括 &lt;code&gt;Self&lt;/code&gt; ，也可以通过其他性状被约束等等&lt;a href=&quot;generics&quot;&gt;如常&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6af2c7840468532a887d826478745d410145630" translate="yes" xml:space="preserve">
          <source>All type parameters have an implicit bound of &lt;code&gt;Sized&lt;/code&gt;. The special syntax &lt;code&gt;?Sized&lt;/code&gt; can be used to remove this bound if it's not appropriate.</source>
          <target state="translated">所有类型参数都有一个 &lt;code&gt;Sized&lt;/code&gt; 的隐式边界。如果不合适，可以使用特殊语法 &lt;code&gt;?Sized&lt;/code&gt; 删除此边界。</target>
        </trans-unit>
        <trans-unit id="9fcb4ee73e3ea3e00af83f66cf487fb2ad10ff05" translate="yes" xml:space="preserve">
          <source>All types in a tuple struct aren't the same when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="translated">使用 &lt;code&gt;#[simd]&lt;/code&gt; 属性时，元组结构中的所有类型都不相同。</target>
        </trans-unit>
        <trans-unit id="687bde44d55450fc7926f1ddbef8c12777b88228" translate="yes" xml:space="preserve">
          <source>All user-defined composite types (&lt;code&gt;struct&lt;/code&gt;s, &lt;code&gt;enum&lt;/code&gt;s, and &lt;code&gt;union&lt;/code&gt;s) have a &lt;em&gt;representation&lt;/em&gt; that specifies what the layout is for the type. The possible representations for a type are:</source>
          <target state="translated">所有用户定义的复合类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;enum&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; ）都有一个&lt;em&gt;表示形式&lt;/em&gt;，用于指定该类型的布局。类型的可能表示为：</target>
        </trans-unit>
        <trans-unit id="b66aa8bf38f6384faa05e5ba7a817e6473b9a5b6" translate="yes" xml:space="preserve">
          <source>All values have an alignment and size.</source>
          <target state="translated">所有的数值都有一个排列和大小。</target>
        </trans-unit>
        <trans-unit id="6b3bc16295776314b52aa5587d61ce1888ff84c1" translate="yes" xml:space="preserve">
          <source>Alloc</source>
          <target state="translated">Alloc</target>
        </trans-unit>
        <trans-unit id="73c626eee3cffa40774dfe1fcb9f6b9bd69dc64f" translate="yes" xml:space="preserve">
          <source>Alloc::alloc</source>
          <target state="translated">Alloc::alloc</target>
        </trans-unit>
        <trans-unit id="58fa8f803498e5ec9addefde8bfd45a79dbec5ed" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_array</source>
          <target state="translated">Alloc::alloc_array</target>
        </trans-unit>
        <trans-unit id="b50e7d6a8a9d06e47daea96c8b2aea5c45efb165" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_excess</source>
          <target state="translated">Alloc::alloc_excess</target>
        </trans-unit>
        <trans-unit id="889b443e61594610d30213145f921f146db36832" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_one</source>
          <target state="translated">Alloc::alloc_one</target>
        </trans-unit>
        <trans-unit id="a34261c2be453348710c37c58e7b9c83398884d8" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_zeroed</source>
          <target state="translated">Alloc::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="7d3d2688c4fd76b53fe3390539a364662ab17d4b" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc</source>
          <target state="translated">Alloc::dealloc</target>
        </trans-unit>
        <trans-unit id="640d5625de8ef766306d60749a2169115e55e156" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_array</source>
          <target state="translated">Alloc::dealloc_array</target>
        </trans-unit>
        <trans-unit id="7053fc65b9dd32b26e961ddd07f10fe845724b56" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_one</source>
          <target state="translated">Alloc::dealloc_one</target>
        </trans-unit>
        <trans-unit id="c1a3b352f967fd646042d5ec8feb84a7842b4835" translate="yes" xml:space="preserve">
          <source>Alloc::grow_in_place</source>
          <target state="translated">Alloc::grow_in_place</target>
        </trans-unit>
        <trans-unit id="b0c3031aac44345a0cd3601e017910c7886cd822" translate="yes" xml:space="preserve">
          <source>Alloc::realloc</source>
          <target state="translated">Alloc::realloc</target>
        </trans-unit>
        <trans-unit id="50682f5a6557029f4ae580a726dd0a2a8ee83c83" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_array</source>
          <target state="translated">Alloc::realloc_array</target>
        </trans-unit>
        <trans-unit id="71b9b4276801f0c0a766cb281400a5a34452c7e1" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_excess</source>
          <target state="translated">Alloc::realloc_excess</target>
        </trans-unit>
        <trans-unit id="caed8ad7c332dd652a64a2f5a64ee5adce448144" translate="yes" xml:space="preserve">
          <source>Alloc::shrink_in_place</source>
          <target state="translated">Alloc::shrink_in_place</target>
        </trans-unit>
        <trans-unit id="4bdde8e404d1e339cdf8e89ef42138d76fb64cb5" translate="yes" xml:space="preserve">
          <source>Alloc::usable_size</source>
          <target state="translated">Alloc::usable_size</target>
        </trans-unit>
        <trans-unit id="74f9a2a318fbafb57c2a318b7f97cd7f558235f5" translate="yes" xml:space="preserve">
          <source>AllocErr</source>
          <target state="translated">AllocErr</target>
        </trans-unit>
        <trans-unit id="81a1e8e44229166f6c5d59b8b5cdfbd7de11a910" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow</source>
          <target state="translated">AllocErr::borrow</target>
        </trans-unit>
        <trans-unit id="cab0d29cfc07f03d441e5891d8fdae354b136ec1" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow_mut</source>
          <target state="translated">AllocErr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c63e5f5e71fd2207c8a6514237ae70d9dca95cf3" translate="yes" xml:space="preserve">
          <source>AllocErr::cause</source>
          <target state="translated">AllocErr::cause</target>
        </trans-unit>
        <trans-unit id="09ff0aa0e6ca318ce203b20e17f08354650229f1" translate="yes" xml:space="preserve">
          <source>AllocErr::clone</source>
          <target state="translated">AllocErr::clone</target>
        </trans-unit>
        <trans-unit id="777d6911608c872b31c4bdb18d3b776c08a9b8f5" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_from</source>
          <target state="translated">AllocErr::clone_from</target>
        </trans-unit>
        <trans-unit id="b678a089fb922c246660ee4daaf38a5251355da7" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_into</source>
          <target state="translated">AllocErr::clone_into</target>
        </trans-unit>
        <trans-unit id="5df229543f81998e9da115264fa06013a927adb1" translate="yes" xml:space="preserve">
          <source>AllocErr::description</source>
          <target state="translated">AllocErr::description</target>
        </trans-unit>
        <trans-unit id="d2cf0a94fd5cf29c79c5284616875b84972fb312" translate="yes" xml:space="preserve">
          <source>AllocErr::eq</source>
          <target state="translated">AllocErr::eq</target>
        </trans-unit>
        <trans-unit id="5881f4abcdbf06d5924b4a78a521cc0027e69523" translate="yes" xml:space="preserve">
          <source>AllocErr::fmt</source>
          <target state="translated">AllocErr::fmt</target>
        </trans-unit>
        <trans-unit id="270a3da0beb21d444fb57d0c363b8a08cfe0f022" translate="yes" xml:space="preserve">
          <source>AllocErr::from</source>
          <target state="translated">AllocErr::from</target>
        </trans-unit>
        <trans-unit id="98b28dbbeacbc8b3f7530e8cbb0f5369608cd809" translate="yes" xml:space="preserve">
          <source>AllocErr::into</source>
          <target state="translated">AllocErr::into</target>
        </trans-unit>
        <trans-unit id="039711c278e014b513a0be997690fca2416f8474" translate="yes" xml:space="preserve">
          <source>AllocErr::ne</source>
          <target state="translated">AllocErr::ne</target>
        </trans-unit>
        <trans-unit id="ffa94c7186e9f5d1d7bf9c63828fb87e4a775ad5" translate="yes" xml:space="preserve">
          <source>AllocErr::source</source>
          <target state="translated">AllocErr::source</target>
        </trans-unit>
        <trans-unit id="0aeb755570b957275d6d9d5317212dc6a6535090" translate="yes" xml:space="preserve">
          <source>AllocErr::to_owned</source>
          <target state="translated">AllocErr::to_owned</target>
        </trans-unit>
        <trans-unit id="0e17e4e80e3c6af6ed45e6c032cf33d55d346e46" translate="yes" xml:space="preserve">
          <source>AllocErr::to_string</source>
          <target state="translated">AllocErr::to_string</target>
        </trans-unit>
        <trans-unit id="3e40fc0676c76a71ca131dafb97f38662652bfbf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_from</source>
          <target state="translated">AllocErr::try_from</target>
        </trans-unit>
        <trans-unit id="34d1124cc06e84256717b819e1f63b955e0350bf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_into</source>
          <target state="translated">AllocErr::try_into</target>
        </trans-unit>
        <trans-unit id="663b204a54c41c16c072ee135d91fa4be49de349" translate="yes" xml:space="preserve">
          <source>AllocErr::type_id</source>
          <target state="translated">AllocErr::type_id</target>
        </trans-unit>
        <trans-unit id="fc99a18ee7862835928c295e62957162ad4eb462" translate="yes" xml:space="preserve">
          <source>AllocError</source>
          <target state="translated">AllocError</target>
        </trans-unit>
        <trans-unit id="4893f8fbd4cad55fcdd644464bc1fe91c279e953" translate="yes" xml:space="preserve">
          <source>AllocRef</source>
          <target state="translated">AllocRef</target>
        </trans-unit>
        <trans-unit id="7cf8dec3c93750b3604d319f88c1f6b4a582f73b" translate="yes" xml:space="preserve">
          <source>Allocate at compile time. Should not be called at runtime.</source>
          <target state="translated">在编译时分配。不应在运行时调用。</target>
        </trans-unit>
        <trans-unit id="4893c8174f6c1eabc41e7843e70d7ebcff1b1f84" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">按照给定的 &lt;code&gt;layout&lt;/code&gt; 分配内存。</target>
        </trans-unit>
        <trans-unit id="cd02c9bc4eedba216d90a16d722506e0ce680a8a" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;. &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">按照给定的 &lt;code&gt;layout&lt;/code&gt; 分配内存。&lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74c59d8374e4ee1d975ce714a71b5fcdbb7aacac" translate="yes" xml:space="preserve">
          <source>Allocate memory with the global allocator.</source>
          <target state="translated">用全局分配器分配内存。</target>
        </trans-unit>
        <trans-unit id="cfb8411e19f0f79e91b6b66f6609da2b9991a1e5" translate="yes" xml:space="preserve">
          <source>Allocate zero-initialized memory with the global allocator.</source>
          <target state="translated">用全局分配器分配零初始化的内存。</target>
        </trans-unit>
        <trans-unit id="1bfdf7915bd5c3db982b39e0a3309425f8ee260d" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">分配一个适合保存 &lt;code&gt;n&lt;/code&gt; 个 &lt;code&gt;T&lt;/code&gt; 实例的块。</target>
        </trans-unit>
        <trans-unit id="c63c156459af2e92bb9b73d7f0f9844433b5dc2f" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">分配一个适合保存 &lt;code&gt;n&lt;/code&gt; 个 &lt;code&gt;T&lt;/code&gt; 实例的块。&lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed375cd7b209e0c5769df096531bae03a872bbbb" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">分配一个适合保存 &lt;code&gt;T&lt;/code&gt; 实例的块。</target>
        </trans-unit>
        <trans-unit id="02c72ac7d36294390fedc764c2754fe1636d64b1" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">分配一个适合保存 &lt;code&gt;T&lt;/code&gt; 实例的块。&lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76e23de7e691468d4d99aac266130e3bc34f2ea4" translate="yes" xml:space="preserve">
          <source>Allocates an empty &lt;code&gt;PathBuf&lt;/code&gt;.</source>
          <target state="translated">分配一个空的 &lt;code&gt;PathBuf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c08c70aff2d6ac267aff88abe6336b4c67e3719" translate="yes" xml:space="preserve">
          <source>Allocates memory in the given allocator then places &lt;code&gt;x&lt;/code&gt; into it.</source>
          <target state="translated">在给定的分配器中分配内存，然后将 &lt;code&gt;x&lt;/code&gt; 放入其中。</target>
        </trans-unit>
        <trans-unit id="f9ce219d6c4b42c1f87ab6030532c065b1fec11f" translate="yes" xml:space="preserve">
          <source>Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.</source>
          <target state="translated">在堆上分配内存，然后将 &lt;code&gt;x&lt;/code&gt; 放入堆中。</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="e910169c58168ed4f75b19228b519cfb61699e61" translate="yes" xml:space="preserve">
          <source>Allow generic type parameter to be a dynamically sized type</source>
          <target state="translated">允许通用类型参数是一个动态大小的类型。</target>
        </trans-unit>
        <trans-unit id="40680c6330eab7e25541ffbe63efc1d14385635b" translate="yes" xml:space="preserve">
          <source>Allow users to add text content only when a post is in the &lt;code&gt;Draft&lt;/code&gt; state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">仅当帖子处于 &lt;code&gt;Draft&lt;/code&gt; 状态时，才允许用户添加文本内容。提示：让状态对象负责内容的可能更改，但不负责修改 &lt;code&gt;Post&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cb50b4ef5745cf62353aeff34203276011ef50f" translate="yes" xml:space="preserve">
          <source>Allowing Access from Multiple Threads with &lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt;</source>
          <target state="translated">允许从具有 &lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt; 多个线程进行访问</target>
        </trans-unit>
        <trans-unit id="fae2d8f4c50be8a20cdea347ace493568595fcd3" translate="yes" xml:space="preserve">
          <source>Allowing Multiple Guesses with Looping</source>
          <target state="translated">允许循环的多重猜测</target>
        </trans-unit>
        <trans-unit id="7db289670d5f2b576ba5fbc25cdc4ef16295c536" translate="yes" xml:space="preserve">
          <source>Allowing Transference of Ownership Between Threads with &lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt;</source>
          <target state="translated">允许使用 &lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt; 在线程之间转移所有权</target>
        </trans-unit>
        <trans-unit id="fb09e5f22f3b7d16947a2ecaccff480c6609f901" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="translated">几乎总是使用 &lt;code&gt;Vec&lt;/code&gt; 或&lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;代替&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;更好。通常，基于数组的容器速度更快，内存使用效率更高，并且可以更好地利用CPU缓存。</target>
        </trans-unit>
        <trans-unit id="96a3f97ad5d3ab3ce2ee9333276a6a44f6055cf9" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;code&gt;VecDeque&lt;/code&gt; instead of &lt;code&gt;LinkedList&lt;/code&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="translated">几乎总是使用 &lt;code&gt;Vec&lt;/code&gt; 或 &lt;code&gt;VecDeque&lt;/code&gt; 代替 &lt;code&gt;LinkedList&lt;/code&gt; 更好。通常，基于数组的容器速度更快，内存使用效率更高，并且可以更好地利用CPU缓存。</target>
        </trans-unit>
        <trans-unit id="30066ada2ed0aa1faf9262f27c4ed17333b52206" translate="yes" xml:space="preserve">
          <source>Along the way, we&amp;rsquo;ll show how to make our command line tool use features of the terminal that many command line tools use. We&amp;rsquo;ll read the value of an environment variable to allow the user to configure the behavior of our tool. We&amp;rsquo;ll also print error messages to the standard error console stream (&lt;code&gt;stderr&lt;/code&gt;) instead of standard output (&lt;code&gt;stdout&lt;/code&gt;), so, for example, the user can redirect successful output to a file while still seeing error messages onscreen.</source>
          <target state="translated">在此过程中，我们将展示如何使我们的命令行工具使用许多命令行工具使用的终端功能。我们将读取环境变量的值，以允许用户配置工具的行为。我们还将错误消息打印到标准错误控制台流（ &lt;code&gt;stderr&lt;/code&gt; ）而不是标准输出（ &lt;code&gt;stdout&lt;/code&gt; ），因此，例如，用户可以将成功的输出重定向到文件，同时仍在屏幕上看到错误消息。</target>
        </trans-unit>
        <trans-unit id="2cbf8cd5d5a46820a0f6ab73279f92ce571b3bc8" translate="yes" xml:space="preserve">
          <source>Along with being made public via &lt;code&gt;pub&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; can also have an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; added for use in FFI.</source>
          <target state="translated">除了通过 &lt;code&gt;pub&lt;/code&gt; 公开之外， &lt;code&gt;fn&lt;/code&gt; 还可以添加一个&lt;a href=&quot;keyword.extern&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt;以便在FFI中使用。</target>
        </trans-unit>
        <trans-unit id="569f87a8387e1554badafba00588c85d0f8bf792" translate="yes" xml:space="preserve">
          <source>Along with the newtype pattern, Rust provides the ability to declare a &lt;em&gt;type alias&lt;/em&gt; to give an existing type another name. For this we use the &lt;code&gt;type&lt;/code&gt; keyword. For example, we can create the alias &lt;code&gt;Kilometers&lt;/code&gt; to &lt;code&gt;i32&lt;/code&gt; like so:</source>
          <target state="translated">除newtype模式外，Rust还提供了声明&lt;em&gt;类型别名的功能&lt;/em&gt;，以便为现有类型赋予另一个名称。为此，我们使用 &lt;code&gt;type&lt;/code&gt; 关键字。例如，我们可以为 &lt;code&gt;i32&lt;/code&gt; 创建别名 &lt;code&gt;Kilometers&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="6444cb062f09d53622baea0cd17deb96b9dc9f75" translate="yes" xml:space="preserve">
          <source>Also discussed were the &lt;code&gt;Deref&lt;/code&gt; and &lt;code&gt;Drop&lt;/code&gt; traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">还讨论了 &lt;code&gt;Deref&lt;/code&gt; 和 &lt;code&gt;Drop&lt;/code&gt; 特性，它们启用了智能指针的许多功能。我们探讨了可能导致内存泄漏的参考周期，以及如何使用 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 防止它们泄漏。</target>
        </trans-unit>
        <trans-unit id="d6fc1b2f8caf81c693f670285ed3e30e58c8f202" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Iterator&lt;/code&gt; provides a default implementation of methods such as &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; which call &lt;code&gt;next&lt;/code&gt; internally. However, it is also possible to write a custom implementation of methods like &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; if an iterator can compute them more efficiently without calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">还要注意， &lt;code&gt;Iterator&lt;/code&gt; 提供了方法的默认实现，例如 &lt;code&gt;nth&lt;/code&gt; 和 &lt;code&gt;fold&lt;/code&gt; ，它们 &lt;code&gt;next&lt;/code&gt; 内部调用下一步。但是，如果迭代器无需调用 &lt;code&gt;next&lt;/code&gt; 就能更有效地计算它们，则还可以编写方法的自定义实现，例如 &lt;code&gt;nth&lt;/code&gt; 和 &lt;code&gt;fold&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a7fb665b167f214e0e11085759c66fc45c5b538" translate="yes" xml:space="preserve">
          <source>Also note that Cargo build scripts can learn about this feature through &lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;environment variables&lt;/a&gt;. In a build script you can detect the linkage via:</source>
          <target state="translated">另请注意，Cargo构建脚本可以通过&lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;环境变量&lt;/a&gt;了解此功能。在构建脚本中，您可以通过以下方式检测链接：</target>
        </trans-unit>
        <trans-unit id="0d1efc462e5f1fbd3ec91e9a65ca5ad80e9b3a5b" translate="yes" xml:space="preserve">
          <source>Also note that Cargo build scripts can learn about this feature through &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;environment variables&lt;/a&gt;. In a build script you can detect the linkage via:</source>
          <target state="translated">另请注意，Cargo构建脚本可以通过&lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;环境变量&lt;/a&gt;了解此功能。在构建脚本中，您可以通过以下方式检测链接：</target>
        </trans-unit>
        <trans-unit id="729f1c9440272260f81d5cd373556bbc830572f8" translate="yes" xml:space="preserve">
          <source>Also note that the values we get from the calls to &lt;code&gt;next&lt;/code&gt; are immutable references to the values in the vector. The &lt;code&gt;iter&lt;/code&gt; method produces an iterator over immutable references. If we want to create an iterator that takes ownership of &lt;code&gt;v1&lt;/code&gt; and returns owned values, we can call &lt;code&gt;into_iter&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;. Similarly, if we want to iterate over mutable references, we can call &lt;code&gt;iter_mut&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">还要注意，从调用 &lt;code&gt;next&lt;/code&gt; 获得的值是对向量中值的不可变引用。的 &lt;code&gt;iter&lt;/code&gt; 方法生产超过不可改变的引用的迭代器。如果要创建一个拥有 &lt;code&gt;v1&lt;/code&gt; 所有权并返回拥有值的迭代器，则可以调用 &lt;code&gt;into_iter&lt;/code&gt; 而不是 &lt;code&gt;iter&lt;/code&gt; 。同样，如果要遍历可变引用，则可以调用 &lt;code&gt;iter_mut&lt;/code&gt; 而不是 &lt;code&gt;iter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9ce0f5a9623fa773f46d4f2d15f1add40c61350" translate="yes" xml:space="preserve">
          <source>Also note that unwinding into Rust code with a foreign exception (e.g. a an exception thrown from C++ code) is undefined behavior.</source>
          <target state="translated">同时注意,在Rust代码中出现外来异常(例如从C++代码中抛出的异常)的情况下展开卷绕是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="ce251a63845ba69b5ad2fd9f201455284f4f01ee" translate="yes" xml:space="preserve">
          <source>Also note that we switched the type of the &lt;code&gt;t&lt;/code&gt; parameter from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;&amp;amp;T&lt;/code&gt;. Because the type might not be &lt;code&gt;Sized&lt;/code&gt;, we need to use it behind some kind of pointer. In this case, we&amp;rsquo;ve chosen a reference.</source>
          <target state="translated">还要注意，我们将 &lt;code&gt;t&lt;/code&gt; 参数的类型从 &lt;code&gt;T&lt;/code&gt; 切换为 &lt;code&gt;&amp;amp;T&lt;/code&gt; 。由于该类型可能未调整 &lt;code&gt;Sized&lt;/code&gt; ，因此我们需要在某种类型的指针后面使用它。在这种情况下，我们选择了一个参考。</target>
        </trans-unit>
        <trans-unit id="19148a1d1c1b97af52ac182d255aa33cc3c9304e" translate="yes" xml:space="preserve">
          <source>Also of note is the special syntax for &lt;code&gt;Fn&lt;/code&gt; traits (e.g. &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt;). Those interested in the technical details of this can refer to &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;the relevant section in the &lt;em&gt;Rustonomicon&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">还要注意的是 &lt;code&gt;Fn&lt;/code&gt; 特性的特殊语法（例如 &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt; ）。对此技术细节感兴趣的人可以参考&lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;&lt;em&gt;Rustonomicon中&lt;/em&gt;&lt;/a&gt;的相关部分&lt;em&gt;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="57bf42e074718d5ea685f5e68450e52bab2d09dc" translate="yes" xml:space="preserve">
          <source>Also verify that you didn't misspell the import name and that the import exists in the module from where you tried to import it. Example:</source>
          <target state="translated">同时确认您没有拼错导入的名称,并且导入的内容存在于您尝试导入的模块中。例如:</target>
        </trans-unit>
        <trans-unit id="ba09134ec4e68053a65f33dbded8cc605eed58ef" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;ManuallyDrop&lt;/code&gt; prevents us from having to &quot;touch&quot; &lt;code&gt;v&lt;/code&gt; after transferring the ownership to &lt;code&gt;s&lt;/code&gt; &amp;mdash; the final step of interacting with &lt;code&gt;v&lt;/code&gt; to dispose of it without running its destructor is entirely avoided.</source>
          <target state="translated">同样， &lt;code&gt;ManuallyDrop&lt;/code&gt; 防止我们在将所有权转让给 &lt;code&gt;s&lt;/code&gt; 之后不得不&amp;ldquo;接触&amp;rdquo; &lt;code&gt;v&lt;/code&gt; -完全避免了与 &lt;code&gt;v&lt;/code&gt; 进行交互以处置它而不运行其析构函数的最后一步。</target>
        </trans-unit>
        <trans-unit id="9d4cb652a8b78bec628c1d26d0df6d4c9f7c28ed" translate="yes" xml:space="preserve">
          <source>Also, if the type of the expression to the left of the dot is a pointer, it is automatically dereferenced as many times as necessary to make the field access possible. In cases of ambiguity, we prefer fewer autoderefs to more.</source>
          <target state="translated">另外,如果点左边的表达式的类型是一个指针,那么它就会自动去引用,次数越多越好,以使字段访问成为可能。在模棱两可的情况下,我们更希望自动引用次数少而不是多。</target>
        </trans-unit>
        <trans-unit id="56542ee08fdcb89c559a45ec666da5ba100aa6fa" translate="yes" xml:space="preserve">
          <source>Also, it allocates temporary storage half the size of &lt;code&gt;self&lt;/code&gt;, but for short slices a non-allocating insertion sort is used instead.</source>
          <target state="translated">同样，它为 &lt;code&gt;self&lt;/code&gt; 分配一半大小的临时存储，但对于短片，则使用非分配插入排序。</target>
        </trans-unit>
        <trans-unit id="f704331d388fc32203be48400c9dc63ab996ddd9" translate="yes" xml:space="preserve">
          <source>Also, note that &lt;code&gt;vec![expr; 0]&lt;/code&gt; is allowed, and produces an empty vector. This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so be mindful of side effects.</source>
          <target state="translated">另外，请注意 &lt;code&gt;vec![expr; 0]&lt;/code&gt; 允许使用0]，并产生一个空向量。但是，这仍将评估 &lt;code&gt;expr&lt;/code&gt; ，并立即降低结果值，因此请注意副作用。</target>
        </trans-unit>
        <trans-unit id="71671f4bb484f8a1e973c0578cc13715a3aa2105" translate="yes" xml:space="preserve">
          <source>Also, note that because &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; has a private field, the struct needs to provide a public associated function that constructs an instance of &lt;code&gt;Breakfast&lt;/code&gt; (we&amp;rsquo;ve named it &lt;code&gt;summer&lt;/code&gt; here). If &lt;code&gt;Breakfast&lt;/code&gt; didn&amp;rsquo;t have such a function, we couldn&amp;rsquo;t create an instance of &lt;code&gt;Breakfast&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because we couldn&amp;rsquo;t set the value of the private &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">另外，请注意，因为 &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 具有一个私有字段，所以该结构需要提供一个公共的关联函数来构造 &lt;code&gt;Breakfast&lt;/code&gt; 实例（我们在这里将其命名为 &lt;code&gt;summer&lt;/code&gt; ）。如果 &lt;code&gt;Breakfast&lt;/code&gt; 没有这样的功能，我们不能创建的实例 &lt;code&gt;Breakfast&lt;/code&gt; 在 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 因为我们无法设置专用的值 &lt;code&gt;seasonal_fruit&lt;/code&gt; 现场 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="477dbb63bb02aa6d30fe03da09f8465ff169a963" translate="yes" xml:space="preserve">
          <source>Also, note that the function body is wrapped in curly brackets, &lt;code&gt;{}&lt;/code&gt;. Rust requires these around all function bodies. It&amp;rsquo;s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between.</source>
          <target state="translated">另外，请注意，函数主体用大括号 &lt;code&gt;{}&lt;/code&gt; 括起来。Rust在所有功能体中都需要这些。将开头的大括号放在函数声明的同一行上是很好的样式，在两者之间添加一个空格。</target>
        </trans-unit>
        <trans-unit id="8c50010a52d6913ce8428bd39d3014c723f0db3d" translate="yes" xml:space="preserve">
          <source>Also, please be aware that this method is only for special circumstances and is usually not what you want. In case of doubt, use &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">另外，请注意，此方法仅用于特殊情况，通常不是您想要的。如有疑问，请改用&lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f205a44cb9a6329dc5c185e41300997837dbbfe5" translate="yes" xml:space="preserve">
          <source>Also, please be aware that this method is only for special circumstances and is usually not what you want. In case of doubt, use &lt;a href=&quot;struct.refcell#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">另外，请注意，此方法仅适用于特殊情况，通常不是您想要的。如有疑问，请改用&lt;a href=&quot;struct.refcell#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2edbd5a08a0137666e61eca4932691fdf6681fd9" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;bool&lt;/code&gt; implements the &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait, we don't have to worry about the move semantics (just like the integer and float primitives).</source>
          <target state="translated">同样，由于 &lt;code&gt;bool&lt;/code&gt; 实现了&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;特征，因此我们不必担心move语义（就像整数和float原语一样）。</target>
        </trans-unit>
        <trans-unit id="a9b0dcda2ee36870b49794f990ce3f2eb9803892" translate="yes" xml:space="preserve">
          <source>Alternatively there can be exactly two expressions inside the brackets, separated by a semi-colon. The expression after the &lt;code&gt;;&lt;/code&gt; must be a have type &lt;code&gt;usize&lt;/code&gt; and be a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, such as a &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; or a &lt;a href=&quot;../items/constant-items&quot;&gt;constant item&lt;/a&gt;. &lt;code&gt;[a; b]&lt;/code&gt; creates an array containing &lt;code&gt;b&lt;/code&gt; copies of the value of &lt;code&gt;a&lt;/code&gt;. If the expression after the semi-colon has a value greater than 1 then this requires that the type of &lt;code&gt;a&lt;/code&gt; is &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">或者，括号内可以有两个表达式，中间用分号分隔。;之后的表达式 &lt;code&gt;;&lt;/code&gt; 必须是具有 &lt;code&gt;usize&lt;/code&gt; 类型并且是&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;常量表达式&lt;/a&gt;，例如&lt;a href=&quot;../tokens#literals&quot;&gt;文字&lt;/a&gt;或&lt;a href=&quot;../items/constant-items&quot;&gt;常量项&lt;/a&gt;。 &lt;code&gt;[a; b]&lt;/code&gt; 创建包含数组 &lt;code&gt;b&lt;/code&gt; 的值的拷贝 &lt;code&gt;a&lt;/code&gt; 。如果分号后的表达式的值大于1，则这要求 &lt;code&gt;a&lt;/code&gt; 的类型为&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc6c67aa2ed479ece24dfe7dd6029027bbfca2b3" translate="yes" xml:space="preserve">
          <source>Alternatively there can be exactly two expressions inside the brackets, separated by a semi-colon. The expression after the &lt;code&gt;;&lt;/code&gt; must have type &lt;code&gt;usize&lt;/code&gt; and be a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, such as a &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; or a &lt;a href=&quot;../items/constant-items&quot;&gt;constant item&lt;/a&gt;. &lt;code&gt;[a; b]&lt;/code&gt; creates an array containing &lt;code&gt;b&lt;/code&gt; copies of the value of &lt;code&gt;a&lt;/code&gt;. If the expression after the semi-colon has a value greater than 1 then this requires that the type of &lt;code&gt;a&lt;/code&gt; is &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">另外，括号内也可以有两个表达式，中间用分号分隔。;之后的表达式 &lt;code&gt;;&lt;/code&gt; 必须具有 &lt;code&gt;usize&lt;/code&gt; 类型并是一个&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;常量表达式&lt;/a&gt;，如&lt;a href=&quot;../tokens#literals&quot;&gt;文字&lt;/a&gt;或&lt;a href=&quot;../items/constant-items&quot;&gt;常量项&lt;/a&gt;。 &lt;code&gt;[a; b]&lt;/code&gt; 创建包含数组 &lt;code&gt;b&lt;/code&gt; 的值的拷贝 &lt;code&gt;a&lt;/code&gt; 。如果分号后的表达式的值大于1，则这要求 &lt;code&gt;a&lt;/code&gt; 的类型为&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c2b342df42a5ce80106fad6cca3ec251f8df3e4" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; has alignment 1 for all &lt;code&gt;T&lt;/code&gt;, so you can use it if you need to keep the field for some reason:</source>
          <target state="translated">另外， &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; 对于所有 &lt;code&gt;T&lt;/code&gt; 都具有对齐方式1 ，因此如果出于某些原因需要保留该字段，可以使用它：</target>
        </trans-unit>
        <trans-unit id="38449305205a0baadf0d931713ad745060ac7795" translate="yes" xml:space="preserve">
          <source>Alternatively, a paren-less version of the attribute may be used to hint the compiler about inlining opportunity:</source>
          <target state="translated">另外,这个属性的无父版可以用来提示编译器关于内联的机会。</target>
        </trans-unit>
        <trans-unit id="d329c92752ab59bc5a187b9f641894d29c9fd208" translate="yes" xml:space="preserve">
          <source>Alternatively, define a trait locally and implement that instead:</source>
          <target state="translated">或者,在本地定义一个特质,然后实现该特质。</target>
        </trans-unit>
        <trans-unit id="30596c4d15742cc562b249b398f8c80c1a13a17f" translate="yes" xml:space="preserve">
          <source>Alternatively, if the type parameter was intentionally inserted, it must be used. A simple fix is shown below:</source>
          <target state="translated">另外,如果类型参数是故意插入的,则必须使用它。一个简单的修复方法如下所示。</target>
        </trans-unit>
        <trans-unit id="7c8d494311629dbdec7e4dda72d552e11aace0ec" translate="yes" xml:space="preserve">
          <source>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt;:</source>
          <target state="translated">另外，如果我们不控制结构的定义，或者真正需要可变的共享所有权，则可以使用 &lt;code&gt;Rc&lt;/code&gt; 和 &lt;code&gt;RefCell&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a59d2fc84eff79b213967bc64daab09652e8ccb" translate="yes" xml:space="preserve">
          <source>Alternatively, if your type implements &lt;code&gt;Clone&lt;/code&gt; and you need to own the value, consider borrowing and then cloning:</source>
          <target state="translated">另外，如果您的类型实现 &lt;code&gt;Clone&lt;/code&gt; 并且您需要拥有该值，请考虑借用然后克隆：</target>
        </trans-unit>
        <trans-unit id="ed9c6950d0598f33adea6619e4f5e3230fd020da" translate="yes" xml:space="preserve">
          <source>Alternatively, move the other attributes to the contained type:</source>
          <target state="translated">或者,将其他属性移动到包含的类型。</target>
        </trans-unit>
        <trans-unit id="b5cf6202d850db2d8b7a0068cf052fbe7d132528" translate="yes" xml:space="preserve">
          <source>Alternatively, split the pattern:</source>
          <target state="translated">另外,也可以将图案分割开来。</target>
        </trans-unit>
        <trans-unit id="9b111c2948f7df0faec47eb57a97f3c7f99e8980" translate="yes" xml:space="preserve">
          <source>Alternatively, we can consider using the &lt;code&gt;Cell&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt; types to achieve interior mutability through a shared reference. Our example's &lt;code&gt;mutable&lt;/code&gt; function could be redefined as below:</source>
          <target state="translated">另外，我们可以考虑使用 &lt;code&gt;Cell&lt;/code&gt; 和 &lt;code&gt;RefCell&lt;/code&gt; 类型通过共享引用实现内部可变性。我们示例的 &lt;code&gt;mutable&lt;/code&gt; 函数可以如下重新定义：</target>
        </trans-unit>
        <trans-unit id="754e721e3e9779de9d32c607142b98694b9bb365" translate="yes" xml:space="preserve">
          <source>Alternatively, we can move out of &lt;code&gt;fancy_num&lt;/code&gt; into a second &lt;code&gt;fancy_num&lt;/code&gt;:</source>
          <target state="translated">或者，我们可以从 &lt;code&gt;fancy_num&lt;/code&gt; 移到第二个 &lt;code&gt;fancy_num&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da767a10b83371c7ea419ae14469880fbc9efc2b" translate="yes" xml:space="preserve">
          <source>Alternatively, wrapping trait objects requires something like the following:</source>
          <target state="translated">另外,包装特质对象也需要类似下面的东西。</target>
        </trans-unit>
        <trans-unit id="3374923e7cf24250807b521def52524879dd69d5" translate="yes" xml:space="preserve">
          <source>Alternatively, wrapping trait objects requires something:</source>
          <target state="translated">另外,包装特质对象也需要一些东西。</target>
        </trans-unit>
        <trans-unit id="980127d7c92391c13b6615bd3076240a03531f1c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can add the following line to your &lt;em&gt;~/.bash_profile&lt;/em&gt;:</source>
          <target state="translated">另外，您可以&lt;em&gt;将以&lt;/em&gt;下行添加到&lt;em&gt;〜/ .bash_profile中&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="9de397b8421cd9e5ee08981bcb6e02a87c244a79" translate="yes" xml:space="preserve">
          <source>Alternatively, you can also use the struct pattern by using the correct field names and binding them to new identifiers:</source>
          <target state="translated">另外,你也可以使用结构模式,使用正确的字段名并将它们绑定到新的标识符上。</target>
        </trans-unit>
        <trans-unit id="53009511a1501672faf73d204dc3eb7eb0e15f4c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct. For example, &lt;code&gt;NewType&lt;/code&gt; is a newtype over &lt;code&gt;Foo&lt;/code&gt; in &lt;code&gt;struct NewType(Foo)&lt;/code&gt;. Example:</source>
          <target state="translated">或者，您可以创建一个新类型。新类型是包装元组结构。例如， &lt;code&gt;NewType&lt;/code&gt; 是在NEWTYPE &lt;code&gt;Foo&lt;/code&gt; 在 &lt;code&gt;struct NewType(Foo)&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="f44934b9e6665fc0ff65386cfc3a7e7022fcb44e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can obtain a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice from a &lt;code&gt;CString&lt;/code&gt; with the &lt;a href=&quot;#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt; method. Slices produced in this way do &lt;em&gt;not&lt;/em&gt; contain the trailing nul terminator. This is useful when you will be calling an extern function that takes a &lt;code&gt;*const u8&lt;/code&gt; argument which is not necessarily nul-terminated, plus another argument with the length of the string &amp;mdash; like C's &lt;code&gt;strndup()&lt;/code&gt;. You can of course get the slice's length with its &lt;a href=&quot;../primitive.slice#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">或者，您可以使用&lt;a href=&quot;#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt;方法从 &lt;code&gt;CString&lt;/code&gt; 获取 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 切片。以这种方式生成的切片&lt;em&gt;不&lt;/em&gt;包含结尾的nul终止符。当您要调用带有 &lt;code&gt;*const u8&lt;/code&gt; 参数（不一定是nul终止）的extern函数，以及另一个带有字符串长度的参数（如C的 &lt;code&gt;strndup()&lt;/code&gt; )时，此功能很有用。当然，您可以使用&lt;a href=&quot;../primitive.slice#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;方法获取切片的长度。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14ed2547343b0251c75ea8d794d5d3f83b965f7e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can obtain a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice from a &lt;code&gt;CString&lt;/code&gt; with the &lt;a href=&quot;struct.cstring#method.as_bytes&quot;&gt;&lt;code&gt;CString::as_bytes&lt;/code&gt;&lt;/a&gt; method. Slices produced in this way do &lt;em&gt;not&lt;/em&gt; contain the trailing nul terminator. This is useful when you will be calling an extern function that takes a &lt;code&gt;*const u8&lt;/code&gt; argument which is not necessarily nul-terminated, plus another argument with the length of the string &amp;mdash; like C's &lt;code&gt;strndup()&lt;/code&gt;. You can of course get the slice's length with its &lt;a href=&quot;../primitive.slice#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">另外，您可以使用&lt;a href=&quot;struct.cstring#method.as_bytes&quot;&gt; &lt;code&gt;CString::as_bytes&lt;/code&gt; &lt;/a&gt;方法从 &lt;code&gt;CString&lt;/code&gt; 获取 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 切片。以这种方式生成的切片&lt;em&gt;不&lt;/em&gt;包含结尾的nul终止符。当您要调用带有 &lt;code&gt;*const u8&lt;/code&gt; 参数（不一定是nul终止）的extern函数，以及另一个带有字符串长度的参数（如C的 &lt;code&gt;strndup()&lt;/code&gt; )时，此功能很有用。当然，您可以使用&lt;a href=&quot;../primitive.slice#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;方法获取切片的长度。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="fb4db1dca17b4c832ac69c83b18f73ad9aa68bf9" translate="yes" xml:space="preserve">
          <source>Although Rust will let you bind &lt;code&gt;Sized&lt;/code&gt; to a trait, you won't be able to use it to form a trait object later:</source>
          <target state="translated">尽管Rust使您可以将 &lt;code&gt;Sized&lt;/code&gt; 绑定到特征，但是以后将无法使用它来形成特征对象：</target>
        </trans-unit>
        <trans-unit id="18938413590ec4f421c089a648f9b8a820edd657" translate="yes" xml:space="preserve">
          <source>Although UDP is a connectionless protocol, this implementation provides an interface to set an address where data should be sent and received from. After setting a remote address with &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;, data can be sent to and received from that address with &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">尽管UDP是无连接协议，但是此实现提供了一个接口，用于设置一个地址，在该地址处应发送和接收数据。使用&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;设置远程地址后，可以使用&lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;将数据发送到该地址或从该地址接收数据。</target>
        </trans-unit>
        <trans-unit id="543c09d5bf5928a676597cb867e1ef6c78157058" translate="yes" xml:space="preserve">
          <source>Although UDP is a connectionless protocol, this implementation provides an interface to set an address where data should be sent and received from. After setting a remote address with &lt;a href=&quot;struct.udpsocket#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;, data can be sent to and received from that address with &lt;a href=&quot;struct.udpsocket#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.udpsocket#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">尽管UDP是无连接协议，但是此实现提供了一个接口，用于设置一个地址，在该地址处应发送和接收数据。使用&lt;a href=&quot;struct.udpsocket#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;设置远程地址后，可以使用&lt;a href=&quot;struct.udpsocket#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.udpsocket#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;将数据发送到该地址或从该地址接收数据。</target>
        </trans-unit>
        <trans-unit id="6138cf1c64fdfba340547fa72a908d945fa65b3f" translate="yes" xml:space="preserve">
          <source>Although a &lt;code&gt;SystemTime&lt;/code&gt; cannot be directly inspected, the &lt;a href=&quot;constant.unix_epoch&quot;&gt;&lt;code&gt;UNIX_EPOCH&lt;/code&gt;&lt;/a&gt; constant is provided in this module as an anchor in time to learn information about a &lt;code&gt;SystemTime&lt;/code&gt;. By calculating the duration from this fixed point in time, a &lt;code&gt;SystemTime&lt;/code&gt; can be converted to a human-readable time, or perhaps some other string representation.</source>
          <target state="translated">尽管无法直接检查 &lt;code&gt;SystemTime&lt;/code&gt; ，但是在此模块中提供&lt;a href=&quot;constant.unix_epoch&quot;&gt; &lt;code&gt;UNIX_EPOCH&lt;/code&gt; &lt;/a&gt;常数作为及时了解有关 &lt;code&gt;SystemTime&lt;/code&gt; 信息的时间锚点。通过从该固定时间点计算持续时间，可以将 &lt;code&gt;SystemTime&lt;/code&gt; 转换为人类可读的时间，或者可能转换为其他字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="9bf2565395a043df30a2266cce3b26bdd4f8ff03" translate="yes" xml:space="preserve">
          <source>Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is the idiomatic way to bring a function into scope with &lt;code&gt;use&lt;/code&gt;. Bringing the function&amp;rsquo;s parent module into scope with &lt;code&gt;use&lt;/code&gt; so we have to specify the parent module when calling the function makes it clear that the function isn&amp;rsquo;t locally defined while still minimizing repetition of the full path. The code in Listing 7-13 is unclear as to where &lt;code&gt;add_to_waitlist&lt;/code&gt; is defined.</source>
          <target state="translated">尽管清单7-11和7-13都完成了相同的任务，但是清单7-11是 &lt;code&gt;use&lt;/code&gt; 将功能引入作用域的惯用方式。将函数的父模块带入 &lt;code&gt;use&lt;/code&gt; 范围，因此我们在调用函数时必须指定父模块，以便清楚地知道该函数不是本地定义的，同时仍使完整路径的重复最小化。清单7-13中的代码不清楚在 &lt;code&gt;add_to_waitlist&lt;/code&gt; 定义add_to_waitlist。</target>
        </trans-unit>
        <trans-unit id="af1566b2870173a676122bd4c9750a25b9287966" translate="yes" xml:space="preserve">
          <source>Although functional programming languages use cons lists frequently, the cons list isn&amp;rsquo;t a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is a better choice to use. Other, more complex recursive data types &lt;em&gt;are&lt;/em&gt; useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.</source>
          <target state="translated">尽管函数式编程语言经常使用缺点列表，但缺点列表不是Rust中常用的数据结构。大多数时候，当您在Rust中具有项目列表时，使用 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 是一个更好的选择。其他更复杂的递归数据类型在各种情况下&lt;em&gt;也&lt;/em&gt;很有用，但是从cons列表开始，我们可以探索如何让框定义递归数据类型而不会造成太多干扰。</target>
        </trans-unit>
        <trans-unit id="d04af4e6b5ccd4c4682747098fc1db0b02dbd661" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;::&lt;/code&gt; token is allowed before the generics arguments, it is not required because there is no ambiguity like there is in &lt;em&gt;PathInExpression&lt;/em&gt;.</source>
          <target state="translated">尽管 &lt;code&gt;::&lt;/code&gt; 标记在通用参数之前是允许的，但由于与&lt;em&gt;PathInExpression&lt;/em&gt;一样，没有歧义，因此不是必需的。</target>
        </trans-unit>
        <trans-unit id="7bf75499d3d552ee0a87d1fa70ed0a0e35bd067e" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;let&lt;/code&gt; is pointless here, it illustrates the meaning of &lt;code&gt;!&lt;/code&gt;. Since &lt;code&gt;x&lt;/code&gt; is never assigned a value (because &lt;code&gt;return&lt;/code&gt; returns from the entire function), &lt;code&gt;x&lt;/code&gt; can be given type &lt;code&gt;!&lt;/code&gt;. We could also replace &lt;code&gt;return 123&lt;/code&gt; with a &lt;code&gt;panic!&lt;/code&gt; or a never-ending &lt;code&gt;loop&lt;/code&gt; and this code would still be valid.</source>
          <target state="translated">尽管 &lt;code&gt;let&lt;/code&gt; 在这里毫无意义，但它说明了 &lt;code&gt;!&lt;/code&gt; 的含义。。由于 &lt;code&gt;x&lt;/code&gt; 从未分配值（因为 &lt;code&gt;return&lt;/code&gt; 是从整个函数返回的），因此 &lt;code&gt;x&lt;/code&gt; 可以指定类型 &lt;code&gt;!&lt;/code&gt; 。我们也可以代替 &lt;code&gt;return 123&lt;/code&gt; 与 &lt;code&gt;panic!&lt;/code&gt; 或永无止境的 &lt;code&gt;loop&lt;/code&gt; ，此代码仍然有效。</target>
        </trans-unit>
        <trans-unit id="6e8ecdea30a2a1885eeb369d7e2426712a189f17" translate="yes" xml:space="preserve">
          <source>Although the SipHash algorithm is considered to be generally strong, it is not intended for cryptographic purposes. As such, all cryptographic uses of this implementation are &lt;em&gt;strongly discouraged&lt;/em&gt;.</source>
          <target state="translated">尽管SipHash算法通常被认为是很强大的算法，但它并非旨在用于加密目的。因此，&lt;em&gt;强烈建议不要&lt;/em&gt;使用此实现的所有密码用法。</target>
        </trans-unit>
        <trans-unit id="f07ca613351cf8dcbbc0ccd12d8ef0d4721b46b7" translate="yes" xml:space="preserve">
          <source>Although the number of keys and values is growable, each key can only have one value associated with it at a time. When you want to change the data in a hash map, you have to decide how to handle the case when a key already has a value assigned. You could replace the old value with the new value, completely disregarding the old value. You could keep the old value and ignore the new value, only adding the new value if the key &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; already have a value. Or you could combine the old value and the new value. Let&amp;rsquo;s look at how to do each of these!</source>
          <target state="translated">尽管键和值的数量是可以增长的，但是每个键一次只能具有一个关联的值。当您想更改哈希图中的数据时，必须决定在键已经分配了值的情况下如何处理这种情况。您可以用新值替换旧值，而完全不考虑旧值。您可以保留旧值，而忽略新值，仅在键&lt;em&gt;尚无&lt;/em&gt;值时才添加新值。或者，您可以将旧值和新值结合起来。让我们看看如何做这些！</target>
        </trans-unit>
        <trans-unit id="9186f195f5116d4c11a411254011d9afb8932670" translate="yes" xml:space="preserve">
          <source>Although this API is unstable, it is exposed via stable APIs on the &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">尽管此API不稳定，但是它通过&lt;a href=&quot;../../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;类型上的稳定API公开。</target>
        </trans-unit>
        <trans-unit id="d281e954555c8484110a6fecba9e6260dd297fe7" translate="yes" xml:space="preserve">
          <source>Although this code has the same behavior as Listing 9-5, it doesn&amp;rsquo;t contain any &lt;code&gt;match&lt;/code&gt; expressions and is cleaner to read. Come back to this example after you&amp;rsquo;ve read Chapter 13, and look up the &lt;code&gt;unwrap_or_else&lt;/code&gt; method in the standard library documentation. Many more of these methods can clean up huge nested &lt;code&gt;match&lt;/code&gt; expressions when you&amp;rsquo;re dealing with errors.</source>
          <target state="translated">尽管此代码与清单9-5具有相同的行为，但是它不包含任何 &lt;code&gt;match&lt;/code&gt; 表达式，并且更易于阅读。阅读完第13章之后，请回到本示例，并在标准库文档中查找 &lt;code&gt;unwrap_or_else&lt;/code&gt; 方法。处理错误时，这些方法中的许多方法都可以清除巨大的嵌套 &lt;code&gt;match&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="db0fe462f2aa334b05d61f387c6225bd0bc5a2b6" translate="yes" xml:space="preserve">
          <source>Although this code works, duplicating code is tedious and error prone. We also have to update the code in multiple places when we want to change it.</source>
          <target state="translated">虽然这段代码很好用,但是重复的代码很繁琐,而且容易出错。当我们要修改代码时,也要在多个地方更新代码。</target>
        </trans-unit>
        <trans-unit id="bf29b02a8b6e1719f55f981f1d8572dd8539b24f" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;i128::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05e69f2a6bb8b46764f8352e784a84dd0afadb9d" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应该使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;i16::MAX&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="ae2e6d7ac448ad026e808cfe3cdcdd25c692cbe9" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cad1997569aea8b22596a5906b14eaf599d36023" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应该使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;i64::MAX&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="628ef478f32d02057364243517eb61194b2fa937" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应该使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;i8::MAX&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="4e48625fb423a49263c7f7ef3730f1cadc66a1e6" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;isize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;isize::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d04345ef80c5ecd03e51a7345f75034be31a60e" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;i128::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="579ffa98c5f86f05f3788dc02042f9c6df508f9f" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;i16::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da2d071c44ca8237c16fc626e1f05fe6f73717ea" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应该使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;i32::MIN&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="4c915462451daa99c7af198c86febdd1a22d7597" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;i64::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7a387b30a94786833a9b0a30456b3027e1e9fbd" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;i8::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5bf4822c610526f0cdddf4534d5b49b86f74f58" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;isize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;isize::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebb42d33b9e27bf9b56623cf75d8b9afa2233265" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;u128::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a7ac738426df2354794cb8df0537a30a74f6523" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;u16::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e75c91d3cf3b6547d6e61a6969491f50f5e1d3e" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;u32::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="924beee0df8993e339f5ec14d80c789072c86cef" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;u64::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ae4b957aed4f3be97f5bc6a6d75118ff06b3cad" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;u8::MAX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5ebde2d554567a7b7e90cd41cbc8b0acac4a1c2" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应该使用&lt;a href=&quot;#associatedconstant.MAX&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="ad32dc2d3be50a4f8c5fdf28af0d0fed17aa13dc" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;u128::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66ce4a459f9d71da21dd5ea02e3b77c11475a92b" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;u16::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="863866e2fa75d6344d5a22903dbb6eb4e36d7217" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应该使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;u32::MIN&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="f0557ca69022890678ed9741ea9a18e4b1b5c3ca" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;u64::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bc8261189beb72f8e3ea2bfcc325eac36215e34" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;u8::MIN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="018037ac23dbb67a32f73854e405231a6ffce4dc" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;usize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应该使用&lt;a href=&quot;#associatedconstant.MIN&quot;&gt; &lt;code&gt;usize::MIN&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="094096c8e8871948579e001659d96f6f0cd91ded" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; instead and new &lt;code&gt;impl&lt;/code&gt;s can omit it.</source>
          <target state="translated">尽管使用它不会引起编译警告，但是新代码应改为使用&lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; ,&lt;/a&gt;而新的 &lt;code&gt;impl&lt;/code&gt; 可以忽略它。</target>
        </trans-unit>
        <trans-unit id="929ca8c36977dca3461b8596285cdc531c6b81df" translate="yes" xml:space="preserve">
          <source>Although using these constants won&amp;rsquo;t cause compilation warnings, new code should use the associated constants directly on the primitive type.</source>
          <target state="translated">尽管使用这些常量不会引起编译警告，但是新代码应直接在原始类型上使用关联的常量。</target>
        </trans-unit>
        <trans-unit id="ce3c8369369ce1fe72325205b70eb3e2961e011c" translate="yes" xml:space="preserve">
          <source>Although you can&amp;rsquo;t remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency. This is useful when a crate version is broken for one reason or another. In such situations, Cargo supports &lt;em&gt;yanking&lt;/em&gt; a crate version.</source>
          <target state="translated">尽管您无法删除旧版本的板条箱，但可以阻止以后的任何项目将它们添加为新的依赖项。当条板箱版本由于某种原因而损坏时，此功能很有用。在这种情况下，Cargo支持&lt;em&gt;拉动&lt;/em&gt;板条箱版本。</target>
        </trans-unit>
        <trans-unit id="a876dd4a0d144d06dda24f474bedf4412b3d4b86" translate="yes" xml:space="preserve">
          <source>Always empty bottom type for diverging functions</source>
          <target state="translated">分流函数的底型总是空的</target>
        </trans-unit>
        <trans-unit id="30044213367fd946b86a46fbbf0f3c415f92d7bc" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;Err&lt;/code&gt; on arithmetic overflow.</source>
          <target state="translated">总是在算术溢出时返回 &lt;code&gt;Err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81c2dadc15a7e41133f5895d6079a63549a2abb5" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;needle&lt;/code&gt; is an empty slice:</source>
          <target state="translated">总是返回 &lt;code&gt;true&lt;/code&gt; 如果 &lt;code&gt;needle&lt;/code&gt; 为空片，则 true：</target>
        </trans-unit>
        <trans-unit id="0d0ce480d587247832892434b17dbf1b556a5191" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.add(count)&lt;/code&gt; instead when possible, because &lt;code&gt;add&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="translated">一律使用 &lt;code&gt;.add(count)&lt;/code&gt; 尽可能 .add（count），因为 &lt;code&gt;add&lt;/code&gt; 可以使编译器更好地进行优化。</target>
        </trans-unit>
        <trans-unit id="2dbc1421ee3e3a275bd2bb6e8f64943056afdc31" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.offset(count)&lt;/code&gt; instead when possible, because &lt;code&gt;offset&lt;/code&gt; allows the compiler to optimize better. If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">一律使用 &lt;code&gt;.offset(count)&lt;/code&gt; 尽可能 .offset（count），因为 &lt;code&gt;offset&lt;/code&gt; 可以使编译器更好地进行优化。如果需要越过对象边界，请将指针转换为整数，然后在该处进行算术运算。</target>
        </trans-unit>
        <trans-unit id="701562825affe99f99fee809f333cf1e955284e4" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.sub(count)&lt;/code&gt; instead when possible, because &lt;code&gt;sub&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="translated">始终使用 &lt;code&gt;.sub(count)&lt;/code&gt; 尽可能，因为 &lt;code&gt;sub&lt;/code&gt; 允许编译器更好地进行优化。</target>
        </trans-unit>
        <trans-unit id="9fda5d5730cef377a6f455b42dbcfb53fb2ca5ca" translate="yes" xml:space="preserve">
          <source>Among other causes, &lt;code&gt;ParseIntError&lt;/code&gt; can be thrown because of leading or trailing whitespace in the string e.g., when it is obtained from the standard input. Using the &lt;a href=&quot;../primitive.str#method.trim&quot;&gt;&lt;code&gt;str.trim()&lt;/code&gt;&lt;/a&gt; method ensures that no whitespace remains before parsing.</source>
          <target state="translated">除其他原因外，可能会由于字符串中的前导或尾随空格而引发 &lt;code&gt;ParseIntError&lt;/code&gt; ，例如，从标准输入中获取时。使用&lt;a href=&quot;../primitive.str#method.trim&quot;&gt; &lt;code&gt;str.trim()&lt;/code&gt; &lt;/a&gt;方法可确保在解析之前不留空格。</target>
        </trans-unit>
        <trans-unit id="f82aa4d4f03b38410c80f80025c8644ba744b247" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing a string that contains a letter.</source>
          <target state="translated">其中,当解析一个包含字母的字符串时,会构造这个变体。</target>
        </trans-unit>
        <trans-unit id="5a8bbd84610d1c777c353f8f16b14399af3b24f4" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing a string that contains a non-ASCII char.</source>
          <target state="translated">在其他原因中,当解析一个包含非ASCII字符的字符串时,将构造这个变体。</target>
        </trans-unit>
        <trans-unit id="e8d19d51f5faed38ee6324a9eb71c292315da9f7" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing an empty string.</source>
          <target state="translated">在其他原因中,当解析一个空字符串时,将构造这个变体。</target>
        </trans-unit>
        <trans-unit id="1692574d1eb8d1443991c925dc8e2acd8ed2cbd7" translate="yes" xml:space="preserve">
          <source>An &quot;or&quot; pattern was used where the variable bindings are not consistently bound across patterns.</source>
          <target state="translated">在变量绑定不一致的情况下,使用了 &quot;或 &quot;模式。</target>
        </trans-unit>
        <trans-unit id="43d68d3a293f07f835d90c6279bf8faa22ceb0c8" translate="yes" xml:space="preserve">
          <source>An &amp;lsquo;abstract syntax tree&amp;rsquo;, or &amp;lsquo;AST&amp;rsquo;, is an intermediate representation of the structure of the program when the compiler is compiling it.</source>
          <target state="translated">&amp;ldquo;抽象语法树&amp;rdquo;或&amp;ldquo; AST&amp;rdquo;是编译器进行编译时程序结构的中间表示。</target>
        </trans-unit>
        <trans-unit id="db2d4110f56313292c834e1861a95c89c601039f" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">一个&lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法：</target>
        </trans-unit>
        <trans-unit id="c2d78c88964f9736a45223d8f771f07ad6bd857e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">一个&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法：</target>
        </trans-unit>
        <trans-unit id="0a7f0956daf2ce936a64a4b1e04b5752d5af8c85" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt; declares both the type and a number of &lt;em&gt;variants&lt;/em&gt;, each of which is independently named and has the syntax of a struct, tuple struct or unit-like struct.</source>
          <target state="translated">一个&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 项&lt;/a&gt;声明的类型和一些&lt;em&gt;变种&lt;/em&gt;，其中的每一个独立地命名并具有一个结构，元组结构或单元状结构的语法。</target>
        </trans-unit>
        <trans-unit id="eccb90f6f9e2e1cba49165645ca18ce97f7c3bdc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果返回零&lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;传递给此方法：</target>
        </trans-unit>
        <trans-unit id="6c3aa2cd86bdd94aa99cad4f7b2a3826d70a323a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned if an error occurs while flushing the buffer.</source>
          <target state="translated">一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果同时刷新缓冲区发生错误，将被退回。</target>
        </trans-unit>
        <trans-unit id="4a13d2042a47768129ce22a87e727826521c162e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type where the compiler does not know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">一个&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;未施胶类型&lt;/a&gt;是任何类型，其中编译器不知道在编译时间的长度或对准。包含未调整大小类型的任何结构也是未调整大小的。</target>
        </trans-unit>
        <trans-unit id="a6662b5b221b841136c3780ac238b4001369d2fd" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; that is not a member of an &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt;, such as a &lt;em&gt;free function&lt;/em&gt; or a &lt;em&gt;free const&lt;/em&gt;. Contrast to an &lt;a href=&quot;#associated-item&quot;&gt;associated item&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;是不是一个成员&lt;a href=&quot;items/implementations&quot;&gt;实施&lt;/a&gt;，诸如&lt;em&gt;自由函数&lt;/em&gt;或一个&lt;em&gt;自由常量&lt;/em&gt;。与&lt;a href=&quot;#associated-item&quot;&gt;关联项&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="ee613500276e22e6ef67273653d1676ba809144c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; that is not a member of an &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt;, such as a &lt;em&gt;free function&lt;/em&gt; or a &lt;em&gt;free const&lt;/em&gt;. Contrast to an &lt;a href=&quot;glossary#associated-item&quot;&gt;associated item&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;是不是一个成员&lt;a href=&quot;items/implementations&quot;&gt;实施&lt;/a&gt;，诸如&lt;em&gt;自由函数&lt;/em&gt;或一个&lt;em&gt;自由常量&lt;/em&gt;。与&lt;a href=&quot;glossary#associated-item&quot;&gt;关联项&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="dcdff555d3629a9d75bb0e2e48e4c4243e57c8c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt; that applies to a nominal type, not to a trait-type pair. &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;items/implementations&quot;&gt;实施&lt;/a&gt;，适用于额定类型，而不是一个特质型对。&lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;更多&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21e222f83548917bbd7accfb7becfb374f31ef4a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; that binds by reference or mutable reference.</source>
          <target state="translated">通过引用或可变引用绑定的&lt;a href=&quot;patterns#identifier-patterns&quot;&gt;标识符模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b301517253f81d6c23866ea49ad7c91ecb7227ac" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std/keyword.async&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; function used recursion without boxing.</source>
          <target state="translated">一个&lt;a href=&quot;std/keyword.async&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;函数使用递归无拳。</target>
        </trans-unit>
        <trans-unit id="f864e2f214828c68972804234bf4534f4526fce2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; initialized to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt;初始化为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d020d51655a42acae9fc5de2d1ee76334d13d2a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;#[inline(..)]&lt;/code&gt; attribute was incorrectly placed on something other than a function or method.</source>
          <target state="translated">一个 &lt;code&gt;#[inline(..)]&lt;/code&gt; 属性被错误地放置在比的函数或方法以外的内容。</target>
        </trans-unit>
        <trans-unit id="36aa4d3dbc6bef64eda94b67a998204c02c9bc40" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Err&lt;/code&gt; will be returned if an error occurs while flushing the buffer.</source>
          <target state="translated">一个 &lt;code&gt;Err&lt;/code&gt; ，如果同时刷新缓冲区发生错误，将被退回。</target>
        </trans-unit>
        <trans-unit id="93af004a9cc5d8031f1774a01ca4ad5a16a22376" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Instant&lt;/code&gt; is a wrapper around system-specific types and it may behave differently depending on the underlying operating system. For example, the following snippet is fine on Linux but panics on macOS:</source>
          <target state="translated">一个 &lt;code&gt;Instant&lt;/code&gt; 是围绕系统特定类型的包装，它的行为可能不同，具体取决于底层的操作系统上。例如，以下代码段在Linux上可以使用，但在macOS上则可以解决：</target>
        </trans-unit>
        <trans-unit id="08eb1e2f2f021298ee3677019a6bda280ed6f694" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Ordering&lt;/code&gt; is the result of a comparison between two values.</source>
          <target state="translated">一个 &lt;code&gt;Ordering&lt;/code&gt; 是两个值之间的比较结果。</target>
        </trans-unit>
        <trans-unit id="001eb435d69650fbb2db42365be5918489730c71" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;RwLock&lt;/code&gt;, like &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;, will become poisoned on a panic. Note, however, that an &lt;code&gt;RwLock&lt;/code&gt; may only be poisoned if a panic occurs while it is locked exclusively (write mode). If a panic occurs in any reader, then the lock will not be poisoned.</source>
          <target state="translated">一个 &lt;code&gt;RwLock&lt;/code&gt; ，像&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;，将成为中毒的恐慌。但是请注意， &lt;code&gt;RwLock&lt;/code&gt; 只有在独占锁定（写入模式）时发生紧急情况时，才会中毒。如果任何读取器出现紧急情况，则锁不会中毒。</target>
        </trans-unit>
        <trans-unit id="5247e633cc3100e9500337757cb3044553bdf55d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; with a discriminant must specify a &lt;code&gt;#[repr(inttype)]&lt;/code&gt;.</source>
          <target state="translated">具有判别式的 &lt;code&gt;enum&lt;/code&gt; 必须指定 &lt;code&gt;#[repr(inttype)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8b1cbde5060ed31e602542132d6a281bf766f42" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;export_name&lt;/code&gt; attribute contains null characters (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="translated">一个 &lt;code&gt;export_name&lt;/code&gt; 属性包含空字符（ &lt;code&gt;\0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21ec5e4c1f77a0601ab37f0e8a98cf223a18e608" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is equivalent to a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows:</source>
          <target state="translated">一个 &lt;code&gt;if let&lt;/code&gt; 表达式等价于一个&lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 表达式&lt;/a&gt;如下：</target>
        </trans-unit>
        <trans-unit id="2ca624a02ac8519763d7ccacb2b0ad8dad16c279" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is semantically similar to an &lt;code&gt;if&lt;/code&gt; expression but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt; and a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression. If the value of the scrutinee matches the pattern, the corresponding block will execute. Otherwise, flow proceeds to the following &lt;code&gt;else&lt;/code&gt; block if it exists. Like &lt;code&gt;if&lt;/code&gt; expressions, &lt;code&gt;if let&lt;/code&gt; expressions have a value determined by the block that is evaluated.</source>
          <target state="translated">一个 &lt;code&gt;if let&lt;/code&gt; 表达是语义上类似于 &lt;code&gt;if&lt;/code&gt; 表达，但在处的条件表达式的，预计的关键字 &lt;code&gt;let&lt;/code&gt; 后跟一个图案， &lt;code&gt;=&lt;/code&gt; 和&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt;表达。如果检查值与模式匹配，则将执行相应的块。否则，流程前进至以下 &lt;code&gt;else&lt;/code&gt; 块（如果存在）。就像 &lt;code&gt;if&lt;/code&gt; 表达式一样， &lt;code&gt;if let&lt;/code&gt; 表达式的值由要评估的块确定。</target>
        </trans-unit>
        <trans-unit id="eee510cf708477f86b4dc6237cd892de065d1aca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression allows you to branch your code depending on conditions. You provide a condition and then state, &amp;ldquo;If this condition is met, run this block of code. If the condition is not met, do not run this block of code.&amp;rdquo;</source>
          <target state="translated">一个 &lt;code&gt;if&lt;/code&gt; 表达式允许您分支根据条件的代码。您提供一个条件，然后说：&amp;ldquo;如果满足此条件，请运行此代码块。如果不满足条件，请不要运行此代码块。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="23bc01de0e1b8681253f7b567d2d01b7869caf61" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression is a conditional branch in program control. The form of an &lt;code&gt;if&lt;/code&gt; expression is a condition expression, followed by a consequent block, any number of &lt;code&gt;else if&lt;/code&gt; conditions and blocks, and an optional trailing &lt;code&gt;else&lt;/code&gt; block. The condition expressions must have type &lt;code&gt;bool&lt;/code&gt;. If a condition expression evaluates to &lt;code&gt;true&lt;/code&gt;, the consequent block is executed and any subsequent &lt;code&gt;else if&lt;/code&gt; or &lt;code&gt;else&lt;/code&gt; block is skipped. If a condition expression evaluates to &lt;code&gt;false&lt;/code&gt;, the consequent block is skipped and any subsequent &lt;code&gt;else if&lt;/code&gt; condition is evaluated. If all &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else if&lt;/code&gt; conditions evaluate to &lt;code&gt;false&lt;/code&gt; then any &lt;code&gt;else&lt;/code&gt; block is executed. An if expression evaluates to the same value as the executed block, or &lt;code&gt;()&lt;/code&gt; if no block is evaluated. An &lt;code&gt;if&lt;/code&gt; expression must have the same type in all situations.</source>
          <target state="translated">一个 &lt;code&gt;if&lt;/code&gt; 表达在程序控制的条件分支。一的形式 &lt;code&gt;if&lt;/code&gt; 表达式是一个条件表达式，然后随之块，任意数量的 &lt;code&gt;else if&lt;/code&gt; 条件和块，以及可选尾随 &lt;code&gt;else&lt;/code&gt; 块。条件表达式必须具有 &lt;code&gt;bool&lt;/code&gt; 类型。如果条件表达式的计算结果为 &lt;code&gt;true&lt;/code&gt; ，则执行后续块，并跳过所有后续 &lt;code&gt;else if&lt;/code&gt; 或 &lt;code&gt;else&lt;/code&gt; 块。如果条件表达式的计算结果为 &lt;code&gt;false&lt;/code&gt; ，则跳过随后的块，如果评估了条件，则跳过随后的任何 &lt;code&gt;else if&lt;/code&gt; 块。如果所有的 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;else if&lt;/code&gt; 条件评估为 &lt;code&gt;false&lt;/code&gt; ,则执行任何 &lt;code&gt;else&lt;/code&gt; 块。if表达式的值等于已执行块的值，如果没有块，则为 &lt;code&gt;()&lt;/code&gt; 。一个 &lt;code&gt;if&lt;/code&gt; 表达式必须在所有情况下相同的类型。</target>
        </trans-unit>
        <trans-unit id="f4cc3ee1616a9030743a2ead317eecbbfda11446" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression is missing an &lt;code&gt;else&lt;/code&gt; block.</source>
          <target state="translated">一 &lt;code&gt;if&lt;/code&gt; 缺少表达式的 &lt;code&gt;else&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="8f0d0db502cd02811b94f8110c6b6a57d9c4d08b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block has the type &lt;code&gt;()&lt;/code&gt;, so this is a type error. To resolve it, add an &lt;code&gt;else&lt;/code&gt; block having the same type as the &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">没有 &lt;code&gt;else&lt;/code&gt; 块的 &lt;code&gt;if&lt;/code&gt; 表达式具有类型 &lt;code&gt;()&lt;/code&gt; ，因此这是类型错误。要解决这个问题，添加 &lt;code&gt;else&lt;/code&gt; 具有相同类型的块 &lt;code&gt;if&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="86c2bbd51b64dbea789df858c004c474818f64aa" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type expands to a recursive type.</source>
          <target state="translated">一个 &lt;code&gt;impl Trait&lt;/code&gt; 类型扩展到递归类型。</target>
        </trans-unit>
        <trans-unit id="714f0cd77b96bfb041f113fa02745f0b3de0da54" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type must be expandable to a concrete type that contains no &lt;code&gt;impl Trait&lt;/code&gt; types. For example the following example tries to create an &lt;code&gt;impl Trait&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; that is equal to &lt;code&gt;[T, T]&lt;/code&gt;:</source>
          <target state="translated">一个 &lt;code&gt;impl Trait&lt;/code&gt; 类型必须扩展到包含任何具体类型 &lt;code&gt;impl Trait&lt;/code&gt; 的类型。例如，以下示例尝试创建一个等于 &lt;code&gt;[T, T]&lt;/code&gt; 的 &lt;code&gt;impl Trait&lt;/code&gt; 类型 &lt;code&gt;T&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5f9bf65171254b99489d8d01742247cb5f9f2b96" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type must be expandable to a concrete type that contains no &lt;code&gt;impl Trait&lt;/code&gt; types. For example the previous example tries to create an &lt;code&gt;impl Trait&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; that is equal to &lt;code&gt;[T, T]&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;impl Trait&lt;/code&gt; 类型必须扩展到包含任何具体类型 &lt;code&gt;impl Trait&lt;/code&gt; 的类型。例如在前面的例子试图创建一个 &lt;code&gt;impl Trait&lt;/code&gt; 类型 &lt;code&gt;T&lt;/code&gt; 等于 &lt;code&gt;[T, T]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee4fc89f6e27033dd75c8304209d0e35cd3688c5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl&lt;/code&gt; for a &lt;code&gt;#[marker]&lt;/code&gt; trait tried to override an associated item.</source>
          <target state="translated">一个 &lt;code&gt;impl&lt;/code&gt; 为 &lt;code&gt;#[marker]&lt;/code&gt; 性状试图覆盖相关联的项目。</target>
        </trans-unit>
        <trans-unit id="6d1073354ecc9c5e7785479d7d2a13da928ab63a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">值为 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;x&lt;/code&gt; 将返回 &lt;code&gt;T&lt;/code&gt; 的位宽。</target>
        </trans-unit>
        <trans-unit id="80f05b7296f4e1950e87afc07c23f9e722a69148" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">值为 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;x&lt;/code&gt; 将返回 &lt;code&gt;T&lt;/code&gt; 的位宽：</target>
        </trans-unit>
        <trans-unit id="4ce321b8a11937b61aec381eab2e9acd0f2ae8bc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;array&lt;/a&gt; expression&lt;/em&gt; can be written by enclosing zero or more comma-separated expressions of uniform type in square brackets. This produces an array containing each of these values in the order they are written.</source>
          <target state="translated">一个&lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;阵列&lt;/a&gt;表达&lt;/em&gt;可以通过封入零个或多个逗号分隔的方括号中均匀类型的表达式被写入。这将产生一个数组，其中包含按写入顺序排列的每个值。</target>
        </trans-unit>
        <trans-unit id="534dc31a67cf35753f9f6ff5f73b65cd1ba58ab5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;array&lt;/a&gt; expression&lt;/em&gt; can be written by enclosing zero or more comma-separated expressions of uniform type in square brackets. This produces and array containing each of these values in the order they are written.</source>
          <target state="translated">一个&lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;阵列&lt;/a&gt;表达&lt;/em&gt;可以通过封入零个或多个逗号分隔的方括号中均匀类型的表达式被写入。这将产生一个数组，并按写入顺序包含每个这些值。</target>
        </trans-unit>
        <trans-unit id="32616f8cb6d3bd819da208e9fcccc36635a05f1e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;code&gt;extern crate&lt;/code&gt; declaration&lt;/em&gt; specifies a dependency on an external crate. The external crate is then bound into the declaring scope as the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; provided in the &lt;code&gt;extern crate&lt;/code&gt; declaration. The &lt;code&gt;as&lt;/code&gt; clause can be used to bind the imported crate to a different name.</source>
          <target state="translated">一个&lt;em&gt; &lt;code&gt;extern crate&lt;/code&gt; 声明&lt;/em&gt;指定的外部箱的依赖。然后将外部箱子作为 &lt;code&gt;extern crate&lt;/code&gt; 声明中提供的&lt;a href=&quot;../identifiers&quot;&gt;标识符&lt;/a&gt;绑定到声明范围。的 &lt;code&gt;as&lt;/code&gt; 子句可用于将导入的板条箱绑定到一个不同的名称。</target>
        </trans-unit>
        <trans-unit id="13494e1cedf4f5c5ecdcb7c07e83d0cd9827df20" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;absolute path&lt;/em&gt; starts from a crate root by using a crate name or a literal &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">一个&lt;em&gt;绝对路径&lt;/em&gt;从一箱根通过使用板条箱名称或文字开始 &lt;code&gt;crate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86fdc788150826ae707ba926f5a66e96063c57f9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;assignment expression&lt;/em&gt; consists of a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; followed by an equals sign (&lt;code&gt;=&lt;/code&gt;) and a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;. Such an expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;.</source>
          <target state="translated">一个&lt;em&gt;赋值表达式&lt;/em&gt;由一个的&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;地方表达&lt;/a&gt;后跟一个等号（ &lt;code&gt;=&lt;/code&gt; ）和&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;值表达式&lt;/a&gt;。这样的表达式始终具有&lt;a href=&quot;../types/tuple&quot;&gt; &lt;code&gt;unit&lt;/code&gt; 类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca56087cc708820efe9481bf7313fdab4a040e22" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant declaration&lt;/em&gt; declares a signature for associated constant definitions. It is written as &lt;code&gt;const&lt;/code&gt;, then an identifier, then &lt;code&gt;:&lt;/code&gt;, then a type, finished by a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">一个&lt;em&gt;相关的常数声明&lt;/em&gt;声明了相关的常量定义的签名。它先写为 &lt;code&gt;const&lt;/code&gt; ，然后是标识符，然后是 &lt;code&gt;:&lt;/code&gt; ，然后是类型，并以 &lt;code&gt;;&lt;/code&gt; 结束。。</target>
        </trans-unit>
        <trans-unit id="ec29836d6b0ec5f807474f5934209d4fe8c7bb83" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant definition&lt;/em&gt; defines a constant associated with a type. It is written the same as a &lt;a href=&quot;constant-items&quot;&gt;constant item&lt;/a&gt;.</source>
          <target state="translated">一个&lt;em&gt;相关联的常数的定义&lt;/em&gt;定义了与类型相关联的常数。它的书写方式与&lt;a href=&quot;constant-items&quot;&gt;常量项&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="c9d2944c74176d8d6fa13f7d573ee85d9e742d32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function declaration&lt;/em&gt; declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">一个&lt;em&gt;相关的函数声明&lt;/em&gt;声明了一个相关的函数定义的签名。它被写为一个功能项，除了功能主体被 &lt;code&gt;;&lt;/code&gt; 代替。。</target>
        </trans-unit>
        <trans-unit id="dce2c17d462060e477f166e6bcfabaf54ef17987" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function definition&lt;/em&gt; defines a function associated with another type. It is written the same as a &lt;a href=&quot;../types/function-item&quot;&gt;function item&lt;/a&gt;.</source>
          <target state="translated">一个&lt;em&gt;相关联的功能的定义&lt;/em&gt;定义了与另一种类型的相关联的功能。它的写法与&lt;a href=&quot;../types/function-item&quot;&gt;功能项&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="ddd6d9f2bd71f652e6f6a519a466ea3ae43a3bff" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type declaration&lt;/em&gt; declares a signature for associated type definitions. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, and finally an optional list of trait bounds.</source>
          <target state="translated">一个&lt;em&gt;相关的类型声明&lt;/em&gt;声明了一个签名相关的类型定义。它被写为 &lt;code&gt;type&lt;/code&gt; ，然后是一个&lt;a href=&quot;../identifiers&quot;&gt;标识符&lt;/a&gt;，最后是一个可选的特征范围列表。</target>
        </trans-unit>
        <trans-unit id="9bd2e844486eba2a5ee0638c6e470984a319e1bf" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type definition&lt;/em&gt; defines a type alias on another type. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, then an &lt;code&gt;=&lt;/code&gt;, and finally a &lt;a href=&quot;../types#type-expressions&quot;&gt;type&lt;/a&gt;.</source>
          <target state="translated">一个&lt;em&gt;相关联的类型的定义&lt;/em&gt;定义了另一种类型的一个类型别名。它被写为 &lt;code&gt;type&lt;/code&gt; ，然后是&lt;a href=&quot;../identifiers&quot;&gt;标识符&lt;/a&gt;，然后是 &lt;code&gt;=&lt;/code&gt; ，最后是&lt;a href=&quot;../types#type-expressions&quot;&gt;类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d29048068c2d4e137f184a7dcfb9e91e3a77ac3e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async block&lt;/em&gt; is a variant of a block expression which evaluates to a &lt;em&gt;future&lt;/em&gt;. The final expression of the block, if present, determines the result value of the future.</source>
          <target state="translated">一个&lt;em&gt;异步块&lt;/em&gt;是将计算得到一个块表达的变体&lt;em&gt;的未来&lt;/em&gt;。块的最终表达式（如果存在）确定未来的结果值。</target>
        </trans-unit>
        <trans-unit id="335c18325b2749c2db5132eb57bce1ffbfa512dc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute&lt;/em&gt; is a general, free-form metadatum that is interpreted according to name, convention, and language and compiler version. Attributes are modeled on Attributes in &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, with the syntax coming from &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C#).</source>
          <target state="translated">一个&lt;em&gt;属性&lt;/em&gt;是根据名字，惯例，语言和编译器版本解释的一般，自由形式的元数据。属性是根据&lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335中的&lt;/a&gt;属性建模的，语法来自&lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt;（C＃）。</target>
        </trans-unit>
        <trans-unit id="7486c611897561f3f092f583b562152c09bc11bb" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute&lt;/em&gt; is a general, free-form metadatum that is interpreted according to name, convention, language, and compiler version. Attributes are modeled on Attributes in &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, with the syntax coming from &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C#).</source>
          <target state="translated">一个&lt;em&gt;属性&lt;/em&gt;是根据名字，惯例，语言和编译器版本解释的一般，自由形式的元数据。属性以&lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335中的&amp;ldquo;&lt;/a&gt;属性&amp;rdquo;为模型，其语法来自&lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt;（C＃）。</target>
        </trans-unit>
        <trans-unit id="8f90d06fddc7c21886a0949a73d97b908062294c" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumerated type&lt;/em&gt; is a nominal, heterogeneous disjoint union type, denoted by the name of an &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt;. &lt;sup&gt;&lt;a href=&quot;#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">一个&lt;em&gt;枚举类型&lt;/em&gt;是标称的，异构不相交并型，由一个的名称表示&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 项&lt;/a&gt;。&lt;sup&gt;&lt;a href=&quot;#enumtype&quot;&gt;1个&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fe8d0e2999c5dfed50da51262f087365afa14a25" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumerated type&lt;/em&gt; is a nominal, heterogeneous disjoint union type, denoted by the name of an &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt;. &lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">一个&lt;em&gt;枚举类型&lt;/em&gt;是标称的，异构不相交并型，由一个的名称表示&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 项&lt;/a&gt;。&lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1个&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="519b32460e4cf24cbf7584ec56a2b57870f1cdef" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumeration&lt;/em&gt;, also referred to as &lt;em&gt;enum&lt;/em&gt; is a simultaneous definition of a nominal &lt;a href=&quot;../types/enum&quot;&gt;enumerated type&lt;/a&gt; as well as a set of &lt;em&gt;constructors&lt;/em&gt;, that can be used to create or pattern-match values of the corresponding enumerated type.</source>
          <target state="translated">一个&lt;em&gt;枚举&lt;/em&gt;，也被称为&lt;em&gt;枚举&lt;/em&gt;是标称的同时定义&lt;a href=&quot;../types/enum&quot;&gt;枚举类型&lt;/a&gt;以及一组&lt;em&gt;构造函数&lt;/em&gt;，可以被用来创建或相应的枚举类型的模式匹配的值。</target>
        </trans-unit>
        <trans-unit id="670995bec677d5fc81f3189dbec41d6de7da346c" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;example term&lt;/em&gt; is an example of a term being defined.</source>
          <target state="translated">一个&lt;em&gt;示例性术语&lt;/em&gt;是所定义的术语的例子。</target>
        </trans-unit>
        <trans-unit id="03f2bd4498afb61074c0d1568fbae87b71b0a6a3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;expression statement&lt;/em&gt; is one that evaluates an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; and ignores its result. As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.</source>
          <target state="translated">一个&lt;em&gt;表达式语句&lt;/em&gt;是一个计算一个&lt;a href=&quot;expressions&quot;&gt;表达式&lt;/a&gt;，而忽略它的结果。通常，表达式语句的目的是触发评估表达式的效果。</target>
        </trans-unit>
        <trans-unit id="4c66d5e565f712d67ccd031da7fc185642328c03" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;extending pattern&lt;/em&gt; is either</source>
          <target state="translated">一个&lt;em&gt;延伸的图案&lt;/em&gt;或者是</target>
        </trans-unit>
        <trans-unit id="111aa957a35f04452bf335357f4b5845abfce6b9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;implementation&lt;/em&gt; is an item that associates items with an &lt;em&gt;implementing type&lt;/em&gt;. Implementations are defined with the keyword &lt;code&gt;impl&lt;/code&gt; and contain functions that belong to an instance of the type that is being implemented or to the type statically.</source>
          <target state="translated">一个&lt;em&gt;执行&lt;/em&gt;是相关联与项目的项目&lt;em&gt;实施类型&lt;/em&gt;。实现是用关键字 &lt;code&gt;impl&lt;/code&gt; 定义的，并且包含属于正在实现的类型的实例或静态属于该类型的函数。</target>
        </trans-unit>
        <trans-unit id="26714676268e63e4c19e025e4e919231c94ab7b4" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer literal&lt;/em&gt; has one of four forms:</source>
          <target state="translated">一个&lt;em&gt;整数文本&lt;/em&gt;有以下四种形式之一：</target>
        </trans-unit>
        <trans-unit id="3b04f25de241c42aa4cc17d61d52253aec0db163" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer&lt;/em&gt; is a number without a fractional component. We used one integer type in Chapter 2, the &lt;code&gt;u32&lt;/code&gt; type. This type declaration indicates that the value it&amp;rsquo;s associated with should be an unsigned integer (signed integer types start with &lt;code&gt;i&lt;/code&gt;, instead of &lt;code&gt;u&lt;/code&gt;) that takes up 32 bits of space. Table 3-1 shows the built-in integer types in Rust. Each variant in the Signed and Unsigned columns (for example, &lt;code&gt;i16&lt;/code&gt;) can be used to declare the type of an integer value.</source>
          <target state="translated">一个&lt;em&gt;整数&lt;/em&gt;是没有小数部分的数。在第2章中，我们使用了一种整数类型，即 &lt;code&gt;u32&lt;/code&gt; 类型。此类型声明指示与之关联的值应为占用32位空间的无符号整数（有符号整数类型以 &lt;code&gt;i&lt;/code&gt; 开头，而不是 &lt;code&gt;u&lt;/code&gt; ）。表3-1显示了Rust中的内置整数类型。 Signed和Unsigned列中的每个变体（例如 &lt;code&gt;i16&lt;/code&gt; ）都可以用来声明整数值的类型。</target>
        </trans-unit>
        <trans-unit id="c86645edb5b5b0c86e3d214a4daf335142eb0487" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item declaration statement&lt;/em&gt; has a syntactic form identical to an &lt;a href=&quot;items&quot;&gt;item declaration&lt;/a&gt; within a &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt;. Declaring an item within a statement block restricts its scope to the block containing the statement. The item is not given a &lt;a href=&quot;paths#canonical-paths&quot;&gt;canonical path&lt;/a&gt; nor are any sub-items it may declare. The exception to this is that associated items defined by &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</source>
          <target state="translated">一个&lt;em&gt;项目声明陈述&lt;/em&gt;具有语法形式相同的&lt;a href=&quot;items&quot;&gt;项声明&lt;/a&gt;一个内&lt;a href=&quot;items/modules&quot;&gt;模块&lt;/a&gt;。在语句块中声明一项将其范围限制为包含该语句的块。该项目没有&lt;a href=&quot;paths#canonical-paths&quot;&gt;规范的路径，&lt;/a&gt;也没有声明任何子项目。唯一的例外是，只要可以访问由&lt;a href=&quot;items/implementations&quot;&gt;实现&lt;/a&gt;定义的关联项目，则在外部作用域中仍然可以访问该项目，如果适用，则可以访问特征。在其他方面，其含义与在模块内部声明项目相同。</target>
        </trans-unit>
        <trans-unit id="7cb6bea3f24f939f1296c8f5c8b195169146ee81" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item&lt;/em&gt; is a component of a crate. Items are organized within a crate by a nested set of &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. Every crate has a single &quot;outermost&quot; anonymous module; all further items within the crate have &lt;a href=&quot;paths&quot;&gt;paths&lt;/a&gt; within the module tree of the crate.</source>
          <target state="translated">一个&lt;em&gt;项目&lt;/em&gt;是一个板条箱的组件。项目是由一组嵌套的&lt;a href=&quot;items/modules&quot;&gt;模块&lt;/a&gt;在一个条板箱内组织的。每个板条箱都有一个&amp;ldquo;最外层&amp;rdquo;匿名模块；板条箱中的所有其他项目在板条箱的模块树中均具有&lt;a href=&quot;paths&quot;&gt;路径&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8df47e4537a8816a2744d87425d00def520f575a" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;octal literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+006F&lt;/code&gt; (&lt;code&gt;0o&lt;/code&gt;) and continues as any mixture (with at least one digit) of octal digits and underscores.</source>
          <target state="translated">一个&lt;em&gt;八进制文字&lt;/em&gt;与字符序列开始 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+006F&lt;/code&gt; （ &lt;code&gt;0o&lt;/code&gt; ），并继续作为八进制数字和下划线的任何混合物（至少一位）。</target>
        </trans-unit>
        <trans-unit id="a141d1e8af86d54f8339e504d3e1c56051728a15" translate="yes" xml:space="preserve">
          <source>An Example Program Using Structs</source>
          <target state="translated">一个使用Structs的示例程序</target>
        </trans-unit>
        <trans-unit id="5aefcb56dc6b861369f867948d8b3b7d49377bfe" translate="yes" xml:space="preserve">
          <source>An I/O Project: Building a Command Line Program</source>
          <target state="translated">一个I/O项目。建立一个命令行程序</target>
        </trans-unit>
        <trans-unit id="0827868381963388a6304543297f7f95e42e9164" translate="yes" xml:space="preserve">
          <source>An IP address, either IPv4 or IPv6.</source>
          <target state="translated">一个IP地址,可以是IPv4或IPv6。</target>
        </trans-unit>
        <trans-unit id="ac4cbc9b22ca704cfdd900cac5407adcf23c5edb" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing an unspecified address: 0.0.0.0</source>
          <target state="translated">一个IPv4地址,代表一个未指定的地址。0.0.0.0</target>
        </trans-unit>
        <trans-unit id="d2e22ab3badaaaa01e7375dd220a2065ca03f949" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing the broadcast address: 255.255.255.255</source>
          <target state="translated">代表广播地址的IPv4地址。255.255.255.255</target>
        </trans-unit>
        <trans-unit id="5f0e70a5e365495e2ae4d74f302988b1f303a907" translate="yes" xml:space="preserve">
          <source>An IPv4 address with the address pointing to localhost: 127.0.0.1.</source>
          <target state="translated">一个IPv4地址,地址指向localhost:127.0.0.1。</target>
        </trans-unit>
        <trans-unit id="c9d68f8900e66f00bfbfd5b6cf93e7f299173890" translate="yes" xml:space="preserve">
          <source>An IPv4 address.</source>
          <target state="translated">一个IPv4地址。</target>
        </trans-unit>
        <trans-unit id="5bb8e3b87105ecbe9c8ed2a2e3a9821088df2706" translate="yes" xml:space="preserve">
          <source>An IPv4 socket address.</source>
          <target state="translated">一个IPv4套接字地址。</target>
        </trans-unit>
        <trans-unit id="a30848e04ae8ee9ab468ffa0929f622538606ceb" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing localhost: &lt;code&gt;::1&lt;/code&gt;.</source>
          <target state="translated">代表localhost的IPv6地址：:: &lt;code&gt;::1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e145c57ced7f65d6f3f83ddc10fbd40d1da4596" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing the unspecified address: &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">IPv6地址表示未指定地址： &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee7dda9f630704f82008f3562e22d445246045b1" translate="yes" xml:space="preserve">
          <source>An IPv6 address.</source>
          <target state="translated">一个IPv6地址。</target>
        </trans-unit>
        <trans-unit id="51d9d6e575aa92d12e0b2c0fb0d5fdcf4923ff85" translate="yes" xml:space="preserve">
          <source>An IPv6 socket address.</source>
          <target state="translated">一个IPv6套接字地址。</target>
        </trans-unit>
        <trans-unit id="bb7fb098f948c20be5364a0797d6630c8f71fe36" translate="yes" xml:space="preserve">
          <source>An RAII implementation of a &quot;scoped lock&quot; of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.</source>
          <target state="translated">一个 &quot;范围锁 &quot;的mutex的RAII实现。当这个结构被丢弃(脱离范围)时,锁将被解锁。</target>
        </trans-unit>
        <trans-unit id="445fdaee68caea7b120e9af421a1f499e812ae92" translate="yes" xml:space="preserve">
          <source>An additional advantage of using Cargo is that the commands are the same no matter which operating system you&amp;rsquo;re working on. So, at this point, we&amp;rsquo;ll no longer provide specific instructions for Linux and macOS versus Windows.</source>
          <target state="translated">使用Cargo的另一个优点是，无论您使用的是哪种操作系统，命令都相同。因此，在这一点上，我们将不再提供针对Linux和macOS与Windows的特定说明。</target>
        </trans-unit>
        <trans-unit id="71d51fdd16cd827000271f90af417efeb9cea05f" translate="yes" xml:space="preserve">
          <source>An address associated with a Unix socket.</source>
          <target state="translated">一个与Unix套接字相关联的地址。</target>
        </trans-unit>
        <trans-unit id="13ebc470b9c08ca083e04f253e5b3a814fa55f28" translate="yes" xml:space="preserve">
          <source>An anchor in time which can be used to create new &lt;code&gt;SystemTime&lt;/code&gt; instances or learn about where in time a &lt;code&gt;SystemTime&lt;/code&gt; lies.</source>
          <target state="translated">时间锚，可用于创建新的 &lt;code&gt;SystemTime&lt;/code&gt; 实例或了解 &lt;code&gt;SystemTime&lt;/code&gt; 的时间。</target>
        </trans-unit>
        <trans-unit id="0b2bb6c8ec3576952f4aecc99eb5bbbbf4cbd659" translate="yes" xml:space="preserve">
          <source>An array is a fixed-size sequence of &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. The array type is written as &lt;code&gt;[T; N]&lt;/code&gt;. The size is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt; that evaluates to a &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数组是类型为 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;N&lt;/code&gt; 个元素的固定大小序列。数组类型写为 &lt;code&gt;[T; N]&lt;/code&gt; N]。大小是一个&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;常数表达式&lt;/a&gt;，计算结果为&lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65f427918d6366c3545d7bcd1528880b6655f86b" translate="yes" xml:space="preserve">
          <source>An array is a fixed-size sequence of &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. The array type is written as &lt;code&gt;[T; N]&lt;/code&gt;. The size is an expression that evaluates to a &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数组是 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;N&lt;/code&gt; 个元素的固定大小序列。数组类型写为 &lt;code&gt;[T; N]&lt;/code&gt; N]。大小是一个表达式，可以评估为&lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d98f60a77f0bbfa809e448ded22428fbfae4e33e" translate="yes" xml:space="preserve">
          <source>An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:</source>
          <target state="translated">数组是在堆栈上分配的单块内存。你可以使用索引来访问一个数组的元素,就像这样。</target>
        </trans-unit>
        <trans-unit id="a7bac5ec811f30188ce6fd849b796ac2d30ffddc" translate="yes" xml:space="preserve">
          <source>An array itself is not iterable:</source>
          <target state="translated">数组本身是不可迭代的。</target>
        </trans-unit>
        <trans-unit id="f510f3fd4950ebae5518ce0880fd83877599bc5e" translate="yes" xml:space="preserve">
          <source>An array or slice pattern required more elements than were present in the matched array.</source>
          <target state="translated">一个数组或切片模式所需要的元素比匹配数组中存在的元素多。</target>
        </trans-unit>
        <trans-unit id="005f7187c479dcce2321a163ab284d4855025280" translate="yes" xml:space="preserve">
          <source>An array or slice pattern was matched against some other type.</source>
          <target state="translated">一个数组或切片模式与其他一些类型进行了匹配。</target>
        </trans-unit>
        <trans-unit id="910b39cfa9beb5c32b52af8b271e7bb38ba1d4da" translate="yes" xml:space="preserve">
          <source>An array without a fixed length was pattern-matched.</source>
          <target state="translated">一个没有固定长度的数组被模式匹配。</target>
        </trans-unit>
        <trans-unit id="9f6ee782e8b3dacab5901a68a88743cdf8f6df8d" translate="yes" xml:space="preserve">
          <source>An array, sometimes also called a fixed-size array or an inline array, is a value describing a collection of elements, each selected by an index that can be computed at run time by the program. It occupies a contiguous region of memory.</source>
          <target state="translated">数组,有时也称为固定大小的数组或内联数组,是一个描述元素集合的值,每个元素由一个索引选择,可以在运行时由程序计算。它占据了内存的一个连续区域。</target>
        </trans-unit>
        <trans-unit id="f5926a4f64969381cfadf3083ad59aa47fe8cee7" translate="yes" xml:space="preserve">
          <source>An assignment operator was used on a non-place expression.</source>
          <target state="translated">在一个非位置表达式上使用了一个赋值运算符。</target>
        </trans-unit>
        <trans-unit id="0369538fab9323882e54c1420899b941701d5cc4" translate="yes" xml:space="preserve">
          <source>An associated const has been referenced in a pattern.</source>
          <target state="translated">在一个模式中引用了一个关联的const。</target>
        </trans-unit>
        <trans-unit id="653f3f2885d5dd5f232a75cd2c5ed4a07f552285" translate="yes" xml:space="preserve">
          <source>An associated const was implemented when another trait item was expected.</source>
          <target state="translated">当预期有另一个特质项时,实现了一个关联的const。</target>
        </trans-unit>
        <trans-unit id="704af6b84f8ec0b7b57fdf7ea0ff93aa51a032a6" translate="yes" xml:space="preserve">
          <source>An associated const was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">当预期有另一个特质项时,实现了一个关联的const。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="597e595feda6e78ec52004cc35588610f09289b1" translate="yes" xml:space="preserve">
          <source>An associated constant whose name does not match any of the associated constants in the trait was used when implementing the trait.</source>
          <target state="translated">在实现该特质时,使用了一个名称与特质中任何关联常量不匹配的关联常量。</target>
        </trans-unit>
        <trans-unit id="ac10e51ff90ef78acbd226706348e7754e0cff2c" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter), but an implementation of the trait declared the same function to be static.</source>
          <target state="translated">特质的关联函数被定义为方法（即，采用 &lt;code&gt;self&lt;/code&gt; 参数），但是特质的实现将同一函数声明为静态。</target>
        </trans-unit>
        <trans-unit id="825b9fd38095eee93e418cc09ae8f9ace5e1f868" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be static, but an implementation of the trait declared the same function to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter).</source>
          <target state="translated">特质的关联函数被定义为静态的，但特质的实现将同一函数声明为方法（即，采用 &lt;code&gt;self&lt;/code&gt; 参数）。</target>
        </trans-unit>
        <trans-unit id="a1184c06942df2b68acc5d480218b30a08f0c9d0" translate="yes" xml:space="preserve">
          <source>An associated item is an item that is associated with another item. Associated items are defined in &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; and declared in &lt;a href=&quot;items/traits&quot;&gt;traits&lt;/a&gt;. Only functions, constants, and type aliases can be associated. Contrast to a &lt;a href=&quot;#free-item&quot;&gt;free item&lt;/a&gt;.</source>
          <target state="translated">关联项目是与另一个项目关联的项目。关联的项目在&lt;a href=&quot;items/implementations&quot;&gt;实现&lt;/a&gt;中定义，并在&lt;a href=&quot;items/traits&quot;&gt;特征中&lt;/a&gt;声明。只能关联函数，常量和类型别名。对比&lt;a href=&quot;#free-item&quot;&gt;免费项目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1035c9277b00c3deebef8eabfe1b836a5766b141" translate="yes" xml:space="preserve">
          <source>An associated item is an item that is associated with another item. Associated items are defined in &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; and declared in &lt;a href=&quot;items/traits&quot;&gt;traits&lt;/a&gt;. Only functions, constants, and type aliases can be associated. Contrast to a &lt;a href=&quot;glossary#free-item&quot;&gt;free item&lt;/a&gt;.</source>
          <target state="translated">关联项目是与另一个项目关联的项目。关联的项目在&lt;a href=&quot;items/implementations&quot;&gt;实现&lt;/a&gt;中定义，并在&lt;a href=&quot;items/traits&quot;&gt;特征中&lt;/a&gt;声明。只能关联函数，常量和类型别名。对比&lt;a href=&quot;glossary#free-item&quot;&gt;免费项目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ced942872757a981c250f3840769940a97d69e7c" translate="yes" xml:space="preserve">
          <source>An associated item wasn't found in the given type.</source>
          <target state="translated">在给定类型中没有找到相关的项目。</target>
        </trans-unit>
        <trans-unit id="7d46370a3ccac2f9ec0235a03f2055e6765250fa" translate="yes" xml:space="preserve">
          <source>An associated type binding was done outside of the type parameter declaration and &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">关联的类型绑定是在类型参数声明和 &lt;code&gt;where&lt;/code&gt; 子句之外完成的。</target>
        </trans-unit>
        <trans-unit id="9116723797d95c7e68863b40ba3626f52a6ce11f" translate="yes" xml:space="preserve">
          <source>An associated type binding was done outside of the type parameter declaration and &lt;code&gt;where&lt;/code&gt; clause. Erroneous code example:</source>
          <target state="translated">关联的类型绑定是在类型参数声明和 &lt;code&gt;where&lt;/code&gt; 子句之外完成的。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="37ff7ecac0e044a097c6ebca208c9701778e86ec" translate="yes" xml:space="preserve">
          <source>An associated type value was specified more than once.</source>
          <target state="translated">相关类型值被指定了一次以上。</target>
        </trans-unit>
        <trans-unit id="247841afd59307a4cdd6a2a4e665f214e72f4dc2" translate="yes" xml:space="preserve">
          <source>An associated type was implemented when another trait item was expected.</source>
          <target state="translated">当预期有另一个性状项时,就实施了一个关联类型。</target>
        </trans-unit>
        <trans-unit id="01d78cadc098f0f8d19a172d639f50a5e45d007b" translate="yes" xml:space="preserve">
          <source>An associated type was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">当预期有另一个特质项时,实现了一个关联类型。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="907ca33cb695a944297042466b1a4f3511ae0a97" translate="yes" xml:space="preserve">
          <source>An associated type wasn't specified for a trait object.</source>
          <target state="translated">没有为特质对象指定关联类型。</target>
        </trans-unit>
        <trans-unit id="57e68f500f344ba1542de979c138dbc82f1b75b2" translate="yes" xml:space="preserve">
          <source>An associated type whose name does not match any of the associated types in the trait was used when implementing the trait.</source>
          <target state="translated">在实现该特质时,使用了名称不符合特质中任何关联类型的关联类型。</target>
        </trans-unit>
        <trans-unit id="ca2d4322730aa4a674f88f33ea28a7a44379f38a" translate="yes" xml:space="preserve">
          <source>An asterisk &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">星号 &lt;code&gt;.*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b4e5a645b1ce82ee08ed7b0b7215a18a0a85f802" translate="yes" xml:space="preserve">
          <source>An async function is roughly equivalent to a function that returns &lt;a href=&quot;../types/impl-trait&quot;&gt;&lt;code&gt;impl Future&lt;/code&gt;&lt;/a&gt; and with an &lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt;&lt;code&gt;async move&lt;/code&gt; block&lt;/a&gt; as its body:</source>
          <target state="translated">异步函数大致等效于返回&lt;a href=&quot;../types/impl-trait&quot;&gt; &lt;code&gt;impl Future&lt;/code&gt; &lt;/a&gt;并以&lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt; &lt;code&gt;async move&lt;/code&gt; 块&lt;/a&gt;作为主体的函数：</target>
        </trans-unit>
        <trans-unit id="fcbf33b833d8349f917a7e3318533a910b1e01c0" translate="yes" xml:space="preserve">
          <source>An asynchronous, infinitely buffered channel. The &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(Sender, Receiver)&lt;/code&gt; tuple where all sends will be &lt;strong&gt;asynchronous&lt;/strong&gt; (they never block). The channel conceptually has an infinite buffer.</source>
          <target state="translated">异步，无限缓冲的通道。的&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;函数将返回一个 &lt;code&gt;(Sender, Receiver)&lt;/code&gt; 的元组，其中所有发送将是&lt;strong&gt;异步&lt;/strong&gt;（它们永远不会阻塞）。从概念上讲，通道具有无限缓冲区。</target>
        </trans-unit>
        <trans-unit id="f387b126eb53d62fa04e8482ab5a1aac01b56bf6" translate="yes" xml:space="preserve">
          <source>An atomic fence.</source>
          <target state="translated">原子围栏。</target>
        </trans-unit>
        <trans-unit id="a37a15efc349a5896258ef2d831759eaab050729" translate="yes" xml:space="preserve">
          <source>An atomic integer initialized to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">初始化为 &lt;code&gt;0&lt;/code&gt; 的原子整数。</target>
        </trans-unit>
        <trans-unit id="ae4be8bb4563b5c446bf4ec14a3a559fbf234d0d" translate="yes" xml:space="preserve">
          <source>An attempt to implement the &lt;code&gt;Copy&lt;/code&gt; trait for a struct failed because one of the fields does not implement &lt;code&gt;Copy&lt;/code&gt;. To fix this, you must implement &lt;code&gt;Copy&lt;/code&gt; for the mentioned field. Note that this may not be possible, as in the example of</source>
          <target state="translated">尝试实现结构的 &lt;code&gt;Copy&lt;/code&gt; 特征失败，因为其中一个字段未实现 &lt;code&gt;Copy&lt;/code&gt; 。要解决此问题，您必须为提到的字段实施&amp;ldquo; &lt;code&gt;Copy&lt;/code&gt; &amp;rdquo;。请注意，这可能是不可能的，例如</target>
        </trans-unit>
        <trans-unit id="2c5fbb1197d035a7f4fa92b6ea1f62d369096169" translate="yes" xml:space="preserve">
          <source>An attempt to implement the &lt;code&gt;Copy&lt;/code&gt; trait for an enum failed because one of the variants does not implement &lt;code&gt;Copy&lt;/code&gt;. To fix this, you must implement &lt;code&gt;Copy&lt;/code&gt; for the mentioned variant. Note that this may not be possible, as in the example of</source>
          <target state="translated">尝试为枚举实现 &lt;code&gt;Copy&lt;/code&gt; trait的尝试失败，因为其中一个变体未实现 &lt;code&gt;Copy&lt;/code&gt; 。要解决此问题，您必须为提到的变体实现 &lt;code&gt;Copy&lt;/code&gt; 。请注意，这可能是不可能的，例如</target>
        </trans-unit>
        <trans-unit id="b71c2935e96e5f7fe3e3f35ad00fd7b30920019f" translate="yes" xml:space="preserve">
          <source>An attempt to index into a type which doesn't implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait was performed.</source>
          <target state="translated">尝试索引到未实现 &lt;code&gt;std::ops::Index&lt;/code&gt; 特征的类型。</target>
        </trans-unit>
        <trans-unit id="51757a13968190cd3655b5b9aeefd9a5c033b3d1" translate="yes" xml:space="preserve">
          <source>An attempt to use index on a type which doesn't implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait was performed.</source>
          <target state="translated">尝试在未实现 &lt;code&gt;std::ops::Index&lt;/code&gt; 特征的类型上使用index 。</target>
        </trans-unit>
        <trans-unit id="8b97d7ea40069db8f20f10d06addb087be36d0ac" translate="yes" xml:space="preserve">
          <source>An attempt was made to access an associated constant through either a generic type parameter or &lt;code&gt;Self&lt;/code&gt;. This is not supported yet. An example causing this error is shown below:</source>
          <target state="translated">试图通过泛型类型参数或 &lt;code&gt;Self&lt;/code&gt; 访问关联的常量。目前尚不支持。导致此错误的示例如下所示：</target>
        </trans-unit>
        <trans-unit id="b710e02452ddf90fa51364201e945e5cc61639f6" translate="yes" xml:space="preserve">
          <source>An attempt was made to assign to a borrowed value.</source>
          <target state="translated">试图赋予借来的价值。</target>
        </trans-unit>
        <trans-unit id="1bdf1eb8c23bfc6042e5dd9af78ec4f5f794fefe" translate="yes" xml:space="preserve">
          <source>An attempt was made to constrain an associated type.</source>
          <target state="translated">试图对关联类型进行约束。</target>
        </trans-unit>
        <trans-unit id="8febb37ae18b2d657b2615e5b330d2a55118441d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a concrete specialization of a generic type. An example is shown below:</source>
          <target state="translated">试图在通用类型的具体专长上实现 &lt;code&gt;Drop&lt;/code&gt; 。一个例子如下所示：</target>
        </trans-unit>
        <trans-unit id="26819bff2d7a8100bea5239c764f0f0d26036cba" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a specialization of a generic type.</source>
          <target state="translated">试图在通用类型的特殊化上实现 &lt;code&gt;Drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ba79d4404f5653d6f77e24331c8ba336aac40d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a specialization of a generic type. An example is shown below:</source>
          <target state="translated">试图在通用类型的特殊化上实现 &lt;code&gt;Drop&lt;/code&gt; 。一个例子如下所示：</target>
        </trans-unit>
        <trans-unit id="c55e6f81b7dc27d46319cedb33bad7716f5297f4" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement Drop on a trait, which is not allowed: only structs and enums can implement Drop. An example causing this error:</source>
          <target state="translated">试图在一个特质上实现Drop,但这是不允许的:只有结构和枚举可以实现Drop。导致该错误的一个例子。</target>
        </trans-unit>
        <trans-unit id="e153b913d67d75c58662cead8cf242032c80e00b" translate="yes" xml:space="preserve">
          <source>An attempt was made to mutate data using a non-mutable reference. This commonly occurs when attempting to assign to a non-mutable reference of a mutable reference (&lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt;).</source>
          <target state="translated">尝试使用非可变引用对数据进行突变。当尝试分配给可变引用（ &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; ）的非可变引用时，通常会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="ca0f2abce0a16f2ca7a56625ca020df6fd2125b3" translate="yes" xml:space="preserve">
          <source>An attempt was made to retrieve an associated type, but the type was ambiguous.</source>
          <target state="translated">试图检索一个相关的类型,但该类型是模糊的。</target>
        </trans-unit>
        <trans-unit id="adb3222e10ca68a4902e2fef67ce06d659218b60" translate="yes" xml:space="preserve">
          <source>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</source>
          <target state="translated">试图检索一个关联的类型,但类型含糊不清。例如:</target>
        </trans-unit>
        <trans-unit id="89de6efbf294db50ea9580038de7bf4a99c6cc2d" translate="yes" xml:space="preserve">
          <source>An attempted conversion that consumes &lt;code&gt;self&lt;/code&gt;, which may or may not be expensive.</source>
          <target state="translated">消耗 &lt;code&gt;self&lt;/code&gt; 的尝试转换，可能会或可能不会很昂贵。</target>
        </trans-unit>
        <trans-unit id="2be91cd4a4fec9bf78dc3a63f6f2d68f35c2bdbd" translate="yes" xml:space="preserve">
          <source>An attempted implementation of a trait method has the wrong number of function parameters.</source>
          <target state="translated">一个试图实现的特质方法有错误的函数参数数量。</target>
        </trans-unit>
        <trans-unit id="9d8894f1f89d7bc71fd853d9276ef9750108ee20" translate="yes" xml:space="preserve">
          <source>An attempted implementation of a trait method has the wrong number of type or const parameters.</source>
          <target state="translated">一个试图实现的特质方法有错误的类型或常量参数。</target>
        </trans-unit>
        <trans-unit id="863f680a55f734bd0dbbca55a32cd8aa13a2d823" translate="yes" xml:space="preserve">
          <source>An attribute is either active or inert. During attribute processing, &lt;em&gt;active attributes&lt;/em&gt; remove themselves from the thing they are on while &lt;em&gt;inert attributes&lt;/em&gt; stay on.</source>
          <target state="translated">属性是活动的或惰性的。在属性处理期间，&lt;em&gt;活动属性&lt;/em&gt;将自己从它们所处的事物中移除，而&lt;em&gt;惰性属性则&lt;/em&gt;保持不变。</target>
        </trans-unit>
        <trans-unit id="de85bca69e396a8c71433fa18f072a410a4fc345" translate="yes" xml:space="preserve">
          <source>An auto trait was declared with a method or an associated item.</source>
          <target state="translated">一个自动特征被声明为方法或关联项目。</target>
        </trans-unit>
        <trans-unit id="8f22761bfa3bdfb0003204a934bf1010c9716a93" translate="yes" xml:space="preserve">
          <source>An empty buffer returned indicates that the stream has reached EOF.</source>
          <target state="translated">返回的空缓冲区表示流已经达到了EOF。</target>
        </trans-unit>
        <trans-unit id="dc01027756efda949405e0e59c0d834ec342e061" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">空的迭代器返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="442cf9396651f26f54eeff92f4dde433d7f72454" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">空的迭代器返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3ba001b1a53998b8d224cd77e4663359ef99e71" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the one value of the type.</source>
          <target state="translated">一个空迭代器返回该类型的一个值。</target>
        </trans-unit>
        <trans-unit id="54261d577d85895bf8c09d3febd150e6fae82418" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the zero value of the type.</source>
          <target state="translated">空迭代器返回该类型的零值。</target>
        </trans-unit>
        <trans-unit id="b0823d0a93b876d1ef3cd6f73de147b3c9881c3f" translate="yes" xml:space="preserve">
          <source>An empty sequence is lexicographically less than any non-empty sequence.</source>
          <target state="translated">一个空序列在词法上小于任何非空序列。</target>
        </trans-unit>
        <trans-unit id="95f62854280c7cd5daf0c2b6b4a29d4a8c72ac30" translate="yes" xml:space="preserve">
          <source>An endpoint of a range of keys.</source>
          <target state="translated">一个键的范围的端点。</target>
        </trans-unit>
        <trans-unit id="ee713135dbae7e11e49962ea65b30c33678861ed" translate="yes" xml:space="preserve">
          <source>An entity already exists, often a file.</source>
          <target state="translated">一个实体已经存在,通常是一个文件。</target>
        </trans-unit>
        <trans-unit id="2db4e2025a972767c9444bca8e88e9a77524203e" translate="yes" xml:space="preserve">
          <source>An entity was not found, often a file.</source>
          <target state="translated">没有找到一个实体,通常是一个文件。</target>
        </trans-unit>
        <trans-unit id="c5a4a196ff419cb4ace58ac8718f985652b454f9" translate="yes" xml:space="preserve">
          <source>An enum with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one variants.</source>
          <target state="translated">具有表示提示 &lt;code&gt;repr(transparent)&lt;/code&gt; 的枚举具有零个或多个变体。</target>
        </trans-unit>
        <trans-unit id="3dc999ff5594fd4673ff8dbd7678f9024bdecf27" translate="yes" xml:space="preserve">
          <source>An enumeration of possible errors associated with a &lt;a href=&quot;type.trylockresult&quot;&gt;&lt;code&gt;TryLockResult&lt;/code&gt;&lt;/a&gt; which can occur while trying to acquire a lock, from the &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on an &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与相关联的可能的错误的枚举&lt;a href=&quot;type.trylockresult&quot;&gt; &lt;code&gt;TryLockResult&lt;/code&gt; &lt;/a&gt;同时试图获取锁，从可能发生&lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt;方法上的&lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09fd334e73fd76483600e0a3e0818465278a8c4f" translate="yes" xml:space="preserve">
          <source>An error indicating invalid UTF-8 when converting a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个错误，指示将&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;转换为&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;时，UTF-8无效。</target>
        </trans-unit>
        <trans-unit id="7e00442ed63dafefaa24c2855dc12cc641d5d806" translate="yes" xml:space="preserve">
          <source>An error indicating that a nul byte was not in the expected position.</source>
          <target state="translated">一个错误,表明一个nul字节不在预期位置。</target>
        </trans-unit>
        <trans-unit id="607c0a59f40344c6d402da3d92f1e4d75c5c8d03" translate="yes" xml:space="preserve">
          <source>An error indicating that an interior nul byte was found.</source>
          <target state="translated">一个错误,表明发现了一个内部nul字节。</target>
        </trans-unit>
        <trans-unit id="2239ba3f9f1a9c04aabf258d44bc7c635e911959" translate="yes" xml:space="preserve">
          <source>An error of the &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is non-fatal and the read operation should be retried if there is nothing else to do.</source>
          <target state="translated">&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误不是致命错误，如果没有其他事情要做，则应重试读取操作。</target>
        </trans-unit>
        <trans-unit id="ff800591cb202807f317ec28fbc572d02357615d" translate="yes" xml:space="preserve">
          <source>An error of the &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is non-fatal and the write operation should be retried if there is nothing else to do.</source>
          <target state="translated">&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的错误不是致命错误，如果没有其他事情要做，则应重试写入操作。</target>
        </trans-unit>
        <trans-unit id="597ff1fa4b12094e64ed86609fbee72af9e8d564" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.bufwriter#method.into_inner&quot;&gt;&lt;code&gt;BufWriter::into_inner&lt;/code&gt;&lt;/a&gt; which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.</source>
          <target state="translated">&lt;a href=&quot;struct.bufwriter#method.into_inner&quot;&gt; &lt;code&gt;BufWriter::into_inner&lt;/code&gt; &lt;/a&gt;返回的错误，将写出缓冲区时发生的错误与可用于从条件中恢复的缓冲区写对象合并在一起。</target>
        </trans-unit>
        <trans-unit id="b6ad7c556d901c0beffc94b348b6d4d9e1e99f53" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.localkey#method.try_with&quot;&gt;&lt;code&gt;LocalKey::try_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.localkey#method.try_with&quot;&gt; &lt;code&gt;LocalKey::try_with&lt;/code&gt; &lt;/a&gt;返回的错误。</target>
        </trans-unit>
        <trans-unit id="4a2bb23cc4bff912e225e8d82c808ebe1116d273" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.refcell#method.try_borrow&quot;&gt;&lt;code&gt;RefCell::try_borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.refcell#method.try_borrow&quot;&gt; &lt;code&gt;RefCell::try_borrow&lt;/code&gt; &lt;/a&gt;返回的错误。</target>
        </trans-unit>
        <trans-unit id="49b49c608a0a48a5c64a8db743785c3d4f2cbc87" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.refcell#method.try_borrow_mut&quot;&gt;&lt;code&gt;RefCell::try_borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.refcell#method.try_borrow_mut&quot;&gt; &lt;code&gt;RefCell::try_borrow_mut&lt;/code&gt; &lt;/a&gt;返回的错误。</target>
        </trans-unit>
        <trans-unit id="6a9d323634dc21ac2ba61947c9f4ada5b0523975" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;code&gt;into_inner&lt;/code&gt; which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.</source>
          <target state="translated">由 &lt;code&gt;into_inner&lt;/code&gt; 返回的错误，该错误将写出缓冲区时发生的错误与可用于从条件中恢复的缓冲区写对象合并在一起。</target>
        </trans-unit>
        <trans-unit id="408e9c71ed3bc2aa80ae9ddbf31a37ecbe128d0c" translate="yes" xml:space="preserve">
          <source>An error returned from &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt;&lt;code&gt;Path::strip_prefix&lt;/code&gt;&lt;/a&gt; if the prefix was not found.</source>
          <target state="translated">如果找不到前缀，则从&lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt; &lt;code&gt;Path::strip_prefix&lt;/code&gt; &lt;/a&gt;返回错误。</target>
        </trans-unit>
        <trans-unit id="788504f3aa85eadb6d0636b88bca37c397dba8e3" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; function on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;函数返回的错误。</target>
        </trans-unit>
        <trans-unit id="9fec5ed88196e94f3e7939be6668b9ce8dfe54d0" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;Sender::send&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;SyncSender::send&lt;/code&gt;&lt;/a&gt; function on &lt;strong&gt;channel&lt;/strong&gt;s.</source>
          <target state="translated">从&lt;strong&gt;通道&lt;/strong&gt; s 上的&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;Sender::send&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;SyncSender::send&lt;/code&gt; &lt;/a&gt;函数返回的错误。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b947bf8292263975edc2c833eac5521f6b3d5e94" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;code&gt;duration_since&lt;/code&gt; and &lt;code&gt;elapsed&lt;/code&gt; methods on &lt;code&gt;SystemTime&lt;/code&gt;, used to learn how far in the opposite direction a system time lies.</source>
          <target state="translated">从 &lt;code&gt;SystemTime&lt;/code&gt; 的 &lt;code&gt;duration_since&lt;/code&gt; 和 &lt;code&gt;elapsed&lt;/code&gt; 方法返回的错误，用于了解系统时间在相反方向上的距离。</target>
        </trans-unit>
        <trans-unit id="3cc3caad00d427c67aa297b2ffd580ffa8825463" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because a call to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returned &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当由于&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用返回操作&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;而无法完成操作时，返回错误。</target>
        </trans-unit>
        <trans-unit id="f51f86543e577fd1d558ef170de94a1b52743f0b" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because a call to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returned &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;调用返回&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;导致操作无法完成时，返回错误。</target>
        </trans-unit>
        <trans-unit id="b05482ca3068a6de89ef72655084867c49191841" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because an &quot;end of file&quot; was reached prematurely.</source>
          <target state="translated">由于过早地达到 &quot;文件结束 &quot;而无法完成操作时,返回一个错误。</target>
        </trans-unit>
        <trans-unit id="9c4fdb1f9f1ace5ab60797b01c282f3c5da7046e" translate="yes" xml:space="preserve">
          <source>An error returned when parsing a &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;../primitive.bool#method.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt; fails</source>
          <target state="translated">解析时，返回一个错误 &lt;code&gt;bool&lt;/code&gt; 使用&lt;a href=&quot;../primitive.bool#method.from_str&quot;&gt; &lt;code&gt;from_str&lt;/code&gt; 均被&lt;/a&gt;失败</target>
        </trans-unit>
        <trans-unit id="b2cc322b72612b3329e40408b842ec85e5b854bf" translate="yes" xml:space="preserve">
          <source>An error returned when parsing a &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt; fails</source>
          <target state="translated">解析时，返回一个错误 &lt;code&gt;bool&lt;/code&gt; 使用&lt;a href=&quot;trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;from_str&lt;/code&gt; 均被&lt;/a&gt;失败</target>
        </trans-unit>
        <trans-unit id="01956aad1d91d0a3eaa910ec372ba76608859bfc" translate="yes" xml:space="preserve">
          <source>An error that can be returned when decoding UTF-16 code points.</source>
          <target state="translated">解码UTF-16码点时可能返回的错误。</target>
        </trans-unit>
        <trans-unit id="3533bcb297f1b2a750fb10891e22e5dd49940449" translate="yes" xml:space="preserve">
          <source>An error when parsing a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">解析 &lt;code&gt;String&lt;/code&gt; 时发生错误。</target>
        </trans-unit>
        <trans-unit id="a8c4d17e195207f5a989ac26b5a78606dcbba09d" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing a char.</source>
          <target state="translated">解析一个字符时可能返回的错误。</target>
        </trans-unit>
        <trans-unit id="6080f2ccd647721dacbdd21e9d94b2a3bec77e1f" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing a float.</source>
          <target state="translated">解析float时可能返回的错误。</target>
        </trans-unit>
        <trans-unit id="8d76e3522dda33b8ed78bf99a4c5562182d54f08" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing an IP address or a socket address.</source>
          <target state="translated">解析IP地址或套接字地址时可能返回的错误。</target>
        </trans-unit>
        <trans-unit id="c7b106b5fd117686f0aceb67097fd3cef2a189bf" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing an integer.</source>
          <target state="translated">解析一个整数时可能返回的错误。</target>
        </trans-unit>
        <trans-unit id="0c10923efe360df9a8a2484a223be28df23ba6ae" translate="yes" xml:space="preserve">
          <source>An evaluation of a trait requirement overflowed.</source>
          <target state="translated">对某一性状要求的评价充溢了。</target>
        </trans-unit>
        <trans-unit id="1d7c5a9fd1d469b89a9d56899ca1f50026a1dd32" translate="yes" xml:space="preserve">
          <source>An example implementation for a domain in which two books are considered the same book if their ISBN matches, even if the formats differ:</source>
          <target state="translated">一个领域的实现例子,在这个领域中,如果两本书的ISBN匹配,即使格式不同,也被认为是同一本书。</target>
        </trans-unit>
        <trans-unit id="68ff7c567c0520a3da56cf3b0e9741fe24004f8f" translate="yes" xml:space="preserve">
          <source>An example implementation of the trait:</source>
          <target state="translated">该特征的一个实施例。</target>
        </trans-unit>
        <trans-unit id="28b14342433cafd1cb0863789fedb01f7530bff9" translate="yes" xml:space="preserve">
          <source>An example is a generic struct holding a function pointer. In this case, the implementation of &lt;code&gt;Clone&lt;/code&gt; cannot be &lt;code&gt;derive&lt;/code&gt;d, but can be implemented as:</source>
          <target state="translated">一个示例是包含函数指针的通用结构。在这种情况下， &lt;code&gt;Clone&lt;/code&gt; 的实现不能 &lt;code&gt;derive&lt;/code&gt; d，但可以实现为：</target>
        </trans-unit>
        <trans-unit id="da1a4e43cf80966a8d5beb99e7207867287f3da9" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;use&lt;/code&gt; declarations:</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; 声明的示例：</target>
        </trans-unit>
        <trans-unit id="f512d81d83647ae47cd90bcb76d95f7b8768001b" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;for&lt;/code&gt; loop over the contents of an array:</source>
          <target state="translated">数组内容的 &lt;code&gt;for&lt;/code&gt; 循环示例：</target>
        </trans-unit>
        <trans-unit id="fee9699f2c385a5203b6e01e13cf6011f2fcd8a4" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;match&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 表达式的示例：</target>
        </trans-unit>
        <trans-unit id="cfd1afa80d53786d32ba47458c2ed4379f4003bf" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;return&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 表达式的示例：</target>
        </trans-unit>
        <trans-unit id="9c5bf1e5202001a02f36098e504bd7cb0fe28030" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;struct&lt;/code&gt; item and its use:</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 项及其用法的示例：</target>
        </trans-unit>
        <trans-unit id="3c2199ab0dce170bc0714704fc232fd68c69b281" translate="yes" xml:space="preserve">
          <source>An example of a &lt;em&gt;recursive&lt;/em&gt; type and its use:</source>
          <target state="translated">&lt;em&gt;递归&lt;/em&gt;类型及其用法的示例：</target>
        </trans-unit>
        <trans-unit id="0f62525fdcd99f7d466515d9585c0c13357e1b2b" translate="yes" xml:space="preserve">
          <source>An example of a common associated function is a &lt;code&gt;new&lt;/code&gt; function that returns a value of the type the associated function is associated with.</source>
          <target state="translated">常见关联函数的示例是一个 &lt;code&gt;new&lt;/code&gt; 函数，该函数返回与该关联函数关联的类型的值。</target>
        </trans-unit>
        <trans-unit id="6a351aa1ff4672ddb51a26e9d5f1e845614b350b" translate="yes" xml:space="preserve">
          <source>An example of a for loop over a series of integers:</source>
          <target state="translated">一个在一系列整数上进行for循环的例子。</target>
        </trans-unit>
        <trans-unit id="9bcd2ce89adc17fbe7648c05a09884aa0d701978" translate="yes" xml:space="preserve">
          <source>An example of a module:</source>
          <target state="translated">一个模块的例子。</target>
        </trans-unit>
        <trans-unit id="8e8435c013addb39ce3eb498c3c558d414e6f6ad" translate="yes" xml:space="preserve">
          <source>An example of a necessary use of parentheses is when calling a function pointer that is a member of a struct:</source>
          <target state="translated">一个必须使用括号的例子是,当调用一个结构成员的函数指针时。</target>
        </trans-unit>
        <trans-unit id="056ff1cdb43a917deab8c9dc0f118b2d9dd496e8" translate="yes" xml:space="preserve">
          <source>An example of a non-&lt;code&gt;Send&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. If two threads attempt to clone &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;s that point to the same reference-counted value, they might try to update the reference count at the same time, which is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; doesn't use atomic operations. Its cousin &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;sync::Arc&lt;/code&gt;&lt;/a&gt; does use atomic operations (incurring some overhead) and thus is &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">非 &lt;code&gt;Send&lt;/code&gt; 类型的一个示例是引用计数指针&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt;。如果两个线程尝试克隆指向相同引用计数值的&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;，则它们可能会尝试同时更新引用计数，这是&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义的行为，&lt;/a&gt;因为&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;不使用原子操作。它的表亲&lt;a href=&quot;../sync/struct.arc&quot;&gt; &lt;code&gt;sync::Arc&lt;/code&gt; &lt;/a&gt;确实使用了原子操作（会产生一些开销），因此它是 &lt;code&gt;Send&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e38ec369f62f9a0e9cf71faa19b5cb843376b06e" translate="yes" xml:space="preserve">
          <source>An example of a parenthesized expression:</source>
          <target state="translated">小括号表达式的一个例子。</target>
        </trans-unit>
        <trans-unit id="f06523b9f614521a822acb49c6502314b5223a29" translate="yes" xml:space="preserve">
          <source>An example of a trait object:</source>
          <target state="translated">特质对象的一个例子。</target>
        </trans-unit>
        <trans-unit id="f97a42d4af253ea16c2f098f9cd1358538ff9ccc" translate="yes" xml:space="preserve">
          <source>An example of a trait that can&amp;rsquo;t be derived is &lt;code&gt;Display&lt;/code&gt;, which handles formatting for end users. You should always consider the appropriate way to display a type to an end user. What parts of the type should an end user be allowed to see? What parts would they find relevant? What format of the data would be most relevant to them? The Rust compiler doesn&amp;rsquo;t have this insight, so it can&amp;rsquo;t provide appropriate default behavior for you.</source>
          <target state="translated">无法派生的特征示例是 &lt;code&gt;Display&lt;/code&gt; ，它可以为最终用户处理格式。您应该始终考虑向最终用户显示类型的适当方法。允许最终用户看到类型的哪些部分？他们认为哪些部分相关？哪种数据格式与它们最相关？Rust编译器没有这种见识，因此无法为您提供适当的默认行为。</target>
        </trans-unit>
        <trans-unit id="b2a6dc626aff375aa4d434c66ea264d4dc08b800" translate="yes" xml:space="preserve">
          <source>An example of a trait whose methods are not object safe is the standard library&amp;rsquo;s &lt;code&gt;Clone&lt;/code&gt; trait. The signature for the &lt;code&gt;clone&lt;/code&gt; method in the &lt;code&gt;Clone&lt;/code&gt; trait looks like this:</source>
          <target state="translated">标准库的&amp;ldquo; &lt;code&gt;Clone&lt;/code&gt; 特征就是其方法不是对象安全的特征的一个示例。 &lt;code&gt;Clone&lt;/code&gt; 特征中的 &lt;code&gt;clone&lt;/code&gt; 方法的签名如下所示：</target>
        </trans-unit>
        <trans-unit id="5e81f6611106899f0be7f5a0792978a45ad55dd8" translate="yes" xml:space="preserve">
          <source>An example of a tuple type and its use:</source>
          <target state="translated">一个元组类型及其使用的例子。</target>
        </trans-unit>
        <trans-unit id="363c341cbe13044b212571253c8a33caae78cd45" translate="yes" xml:space="preserve">
          <source>An example of an &lt;code&gt;as&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 表达式的示例：</target>
        </trans-unit>
        <trans-unit id="a2db905e306fb4833044bdd9885bb27ab8f76d7f" translate="yes" xml:space="preserve">
          <source>An example of an &lt;code&gt;enum&lt;/code&gt; item and its use:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 项及其用法的示例：</target>
        </trans-unit>
        <trans-unit id="9260a714aba6105dd14cba9d58f3d41f31de6503" translate="yes" xml:space="preserve">
          <source>An example of an empty type is &lt;code&gt;enum Empty { }&lt;/code&gt;. So, the following will work:</source>
          <target state="translated">空类型的一个示例是 &lt;code&gt;enum Empty { }&lt;/code&gt; 。因此，以下将起作用：</target>
        </trans-unit>
        <trans-unit id="ff969b10a01ab50464488192aa66638be2ebf171" translate="yes" xml:space="preserve">
          <source>An example of combining the above rules of &lt;code&gt;path&lt;/code&gt; attributes on inline modules and nested modules within (applies to both mod-rs and non-mod-rs files):</source>
          <target state="translated">结合上述内联模块和嵌套模块上的 &lt;code&gt;path&lt;/code&gt; 属性规则的示例（适用于mod-rs和non-mod-rs文件）：</target>
        </trans-unit>
        <trans-unit id="6e09c1385fee93fd5fa2b4010458a4fc489b7a97" translate="yes" xml:space="preserve">
          <source>An example of implementing the formatting traits would look like:</source>
          <target state="translated">实现格式化特征的例子是这样的。</target>
        </trans-unit>
        <trans-unit id="fa098562087edb062353d3aa89708207a19b395b" translate="yes" xml:space="preserve">
          <source>An example of matching non-exhaustively on the above enum is provided below:</source>
          <target state="translated">下面提供了一个对上述枚举进行非详尽匹配的例子。</target>
        </trans-unit>
        <trans-unit id="7ef19768d994b2224d1f41bd49faef1709c5e7ef" translate="yes" xml:space="preserve">
          <source>An example of panic:</source>
          <target state="translated">恐慌的一个例子。</target>
        </trans-unit>
        <trans-unit id="884b0dfdd5d082bb94960ecce28dc9f3e6d384f8" translate="yes" xml:space="preserve">
          <source>An example of re-exporting:</source>
          <target state="translated">一个再出口的例子。</target>
        </trans-unit>
        <trans-unit id="708c005211a8b1e93ec9aac2ad4a16e9c3bc2bc3" translate="yes" xml:space="preserve">
          <source>An example of this error:</source>
          <target state="translated">这种错误的一个例子。</target>
        </trans-unit>
        <trans-unit id="1d989db348ecf6096ab3ac95d001072dec12efa1" translate="yes" xml:space="preserve">
          <source>An example of this is when generating a new struct and an impl for it:</source>
          <target state="translated">这方面的一个例子是,当生成一个新的结构并为其生成一个内含结构时。</target>
        </trans-unit>
        <trans-unit id="9b7f946fdd8d8a22da86833c61b5461d61a9c5be" translate="yes" xml:space="preserve">
          <source>An example of using tuple patterns:</source>
          <target state="translated">一个使用元组模式的例子。</target>
        </trans-unit>
        <trans-unit id="62347f606509b323a7de02a2bce976170f493c84" translate="yes" xml:space="preserve">
          <source>An example of what not to do and how this relates to &lt;code&gt;read_unaligned&lt;/code&gt; is:</source>
          <target state="translated">一个不执行的操作以及它与 &lt;code&gt;read_unaligned&lt;/code&gt; 的关系的示例是：</target>
        </trans-unit>
        <trans-unit id="6f16face177ebc3cd353bb963c0ea872b0ace950" translate="yes" xml:space="preserve">
          <source>An example of what not to do and how this relates to &lt;code&gt;write_unaligned&lt;/code&gt; is:</source>
          <target state="translated">不做什么以及与 &lt;code&gt;write_unaligned&lt;/code&gt; 的关系的一个示例是：</target>
        </trans-unit>
        <trans-unit id="64eb812bfe0819a20f7b7755d2742025cd360a65" translate="yes" xml:space="preserve">
          <source>An example of what will and will not work for &lt;code&gt;use&lt;/code&gt; items:</source>
          <target state="translated">有关 &lt;code&gt;use&lt;/code&gt; 项将适用和不适用的示例：</target>
        </trans-unit>
        <trans-unit id="8365f135946b3f7b044d8cfd3fa7997f776027f4" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Clone&lt;/code&gt; is required is when calling the &lt;code&gt;to_vec&lt;/code&gt; method on a slice. The slice doesn&amp;rsquo;t own the type instances it contains, but the vector returned from &lt;code&gt;to_vec&lt;/code&gt; will need to own its instances, so &lt;code&gt;to_vec&lt;/code&gt; calls &lt;code&gt;clone&lt;/code&gt; on each item. Thus, the type stored in the slice must implement &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="translated">何时需要 &lt;code&gt;Clone&lt;/code&gt; 一个示例是在切片上调用 &lt;code&gt;to_vec&lt;/code&gt; 方法。切片不拥有其包含的类型实例，但是从 &lt;code&gt;to_vec&lt;/code&gt; 返回的向量将需要拥有其实例，因此 &lt;code&gt;to_vec&lt;/code&gt; 在每个项目上调用 &lt;code&gt;clone&lt;/code&gt; 。因此，切片中存储的类型必须实现 &lt;code&gt;Clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaf3c4aa1a7d59f2304836782308596d0ae75f64" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Eq&lt;/code&gt; is required is for keys in a &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; so the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; can tell whether two keys are the same.</source>
          <target state="translated">&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 键何时需要 &lt;code&gt;Eq&lt;/code&gt; 的示例，因此 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 可以判断两个键是否相同。</target>
        </trans-unit>
        <trans-unit id="e410ff694a089e824c24843049bae108ce880220" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Hash&lt;/code&gt; is required is in storing keys in a &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; to store data efficiently.</source>
          <target state="translated">何时需要 &lt;code&gt;Hash&lt;/code&gt; 一个示例是将密钥存储在 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 以有效存储数据。</target>
        </trans-unit>
        <trans-unit id="13874d9be8af151d397c4923d18c3e3bb505d451" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Ord&lt;/code&gt; is required is when storing values in a &lt;code&gt;BTreeSet&amp;lt;T&amp;gt;&lt;/code&gt;, a data structure that stores data based on the sort order of the values.</source>
          <target state="translated">需要 &lt;code&gt;Ord&lt;/code&gt; 的一个示例是将值存储在 &lt;code&gt;BTreeSet&amp;lt;T&amp;gt;&lt;/code&gt; ，BTreeSet &amp;lt;T&amp;gt;是一种根据值的排序顺序存储数据的数据结构。</target>
        </trans-unit>
        <trans-unit id="309f6d59bf7b6968dcfb2187e53fc8e9c9c42a01" translate="yes" xml:space="preserve">
          <source>An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It&amp;rsquo;s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 elements:</source>
          <target state="translated">一个程序可能需要使用数组而不是向量的示例是在一个程序中，该程序需要知道一年中各个月份的名称。这样的程序不太可能需要添加或删除月份，因此您可以使用数组，因为您知道它将始终包含12个元素：</target>
        </trans-unit>
        <trans-unit id="f42b2c8e58eff03a7089947fa8ffae92137b9b5f" translate="yes" xml:space="preserve">
          <source>An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It&amp;rsquo;s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 items:</source>
          <target state="translated">一个程序可能需要使用数组而不是向量的示例是在一个程序中，该程序需要知道一年中各个月份的名称。这样的程序不太可能需要添加或删除月份，因此您可以使用数组，因为您知道它将始终包含12个项目：</target>
        </trans-unit>
        <trans-unit id="bd0712d619a2d60e4c146e231ccdfbad8aba4743" translate="yes" xml:space="preserve">
          <source>An example of where you would want to only accept &lt;code&gt;fn&lt;/code&gt; and not closures is when interfacing with external code that doesn&amp;rsquo;t have closures: C functions can accept functions as arguments, but C doesn&amp;rsquo;t have closures.</source>
          <target state="translated">与不带闭包的外部代码交互时，您只希望接受 &lt;code&gt;fn&lt;/code&gt; 而不接受闭包的示例：C函数可以接受函数作为参数，而C没有闭包。</target>
        </trans-unit>
        <trans-unit id="e73f9f6c8b4fbcf9f4fd470408b5fff3f081d3b9" translate="yes" xml:space="preserve">
          <source>An example using a closure:</source>
          <target state="translated">一个使用封闭的例子。</target>
        </trans-unit>
        <trans-unit id="6d3969065ec2f88aef65174e1f6ffa620b0c83f2" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;Binop&lt;/code&gt; is defined as a function pointer type:</source>
          <target state="translated">将 &lt;code&gt;Binop&lt;/code&gt; 定义为函数指针类型的示例：</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一个例子:</target>
        </trans-unit>
        <trans-unit id="9b338a4ae7f343a1618fa43d10bfc2df436ea62d" translate="yes" xml:space="preserve">
          <source>An exclusive bound.</source>
          <target state="translated">独家绑定。</target>
        </trans-unit>
        <trans-unit id="0a0f5c759335e3ef134a90149eb082ea59cf661b" translate="yes" xml:space="preserve">
          <source>An executing Rust program consists of a collection of native OS threads, each with their own stack and local state. Threads can be named, and provide some built-in support for low-level synchronization.</source>
          <target state="translated">一个正在执行的 Rust 程序由本机操作系统线程的集合组成,每个线程都有自己的堆栈和本地状态,线程可以命名,并提供一些内置的低级同步支持。线程可以被命名,并为低级同步提供一些内置支持。</target>
        </trans-unit>
        <trans-unit id="12c993ee363617797c480ae0e7fa61fa88f7540e" translate="yes" xml:space="preserve">
          <source>An explicit conversion from a &lt;code&gt;&amp;amp;str&lt;/code&gt; to a String is done as follows:</source>
          <target state="translated">从 &lt;code&gt;&amp;amp;str&lt;/code&gt; 到String 的显式转换如下：</target>
        </trans-unit>
        <trans-unit id="9863ad7a484538312614b219ee23d089bab88f2a" translate="yes" xml:space="preserve">
          <source>An expression enclosed in parentheses evaluates to the result of the enclosed expression. Parentheses can be used to explicitly specify evaluation order within an expression.</source>
          <target state="translated">被括号括起来的表达式会评价被括起来的表达式的结果。括号可以用来明确指定一个表达式中的计算顺序。</target>
        </trans-unit>
        <trans-unit id="b0b2d07f6ff343f37bbb2da0dbd07ed7ea53cb5d" translate="yes" xml:space="preserve">
          <source>An expression is a combination of values, constants, variables, operators and functions that evaluate to a single value, with or without side-effects.</source>
          <target state="translated">表达式是数值、常量、变量、运算符和函数的组合,它们的计算结果是一个单一的数值,有或没有副作用。</target>
        </trans-unit>
        <trans-unit id="8a470e20ec20f9f17fbbac4266c615aa43cc21c3" translate="yes" xml:space="preserve">
          <source>An expression may have two roles: it always produces a &lt;em&gt;value&lt;/em&gt;, and it may have &lt;em&gt;effects&lt;/em&gt; (otherwise known as &quot;side effects&quot;). An expression &lt;em&gt;evaluates to&lt;/em&gt; a value, and has effects during &lt;em&gt;evaluation&lt;/em&gt;. Many expressions contain sub-expressions (operands). The meaning of each kind of expression dictates several things:</source>
          <target state="translated">表达式可能有两个作用：它总是产生一个&lt;em&gt;value&lt;/em&gt;，并且它可能具有&lt;em&gt;作用&lt;/em&gt;（否则称为&amp;ldquo;副作用&amp;rdquo;）。表达式&lt;em&gt;求&lt;/em&gt;值，并在&lt;em&gt;求&lt;/em&gt;值过程中&lt;em&gt;起作用&lt;/em&gt;。许多表达式包含子表达式（操作数）。每种表达方式的含义规定了几件事：</target>
        </trans-unit>
        <trans-unit id="894873bc5f587b4733b17f7dfb18b0f3059d2176" translate="yes" xml:space="preserve">
          <source>An expression that consists of only a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt; or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement. The type of &lt;a href=&quot;expressions&quot;&gt;&lt;em&gt;ExpressionWithBlock&lt;/em&gt;&lt;/a&gt; expressions when used as statements must be the unit type.</source>
          <target state="translated">如果仅在语句允许的上下文中使用，则仅包含&lt;a href=&quot;expressions/block-expr&quot;&gt;块表达式&lt;/a&gt;或控制流表达式的表达式可以省略结尾的分号。这可能导致在将其解析为独立语句和作为另一个表达式的一部分之间产生歧义。在这种情况下，它被解析为一条语句。当用作语句时，&lt;a href=&quot;expressions&quot;&gt;&lt;em&gt;ExpressionWithBlock&lt;/em&gt;&lt;/a&gt;表达式的类型必须是单位类型。</target>
        </trans-unit>
        <trans-unit id="3db9b6e5300ec2a35e045cae789d7d65bc1644c2" translate="yes" xml:space="preserve">
          <source>An extension trait for concatenating slices</source>
          <target state="translated">用于连接切片的扩展特征</target>
        </trans-unit>
        <trans-unit id="12147a5a52fb5c2a1b9d7472abd1e716e6699134" translate="yes" xml:space="preserve">
          <source>An external crate dependency can be declared without binding its name in scope by using an underscore with the form &lt;code&gt;extern crate foo as _&lt;/code&gt;. This may be useful for crates that only need to be linked, but are never referenced, and will avoid being reported as unused.</source>
          <target state="translated">通过使用下划线，形式为 &lt;code&gt;extern crate foo as _&lt;/code&gt; 可以声明外部crate依赖项，而无需在范围内绑定其名称。这对于只需要链接但从未被引用过的板条箱很有用，并且可以避免被报告为未使用的板条箱。</target>
        </trans-unit>
        <trans-unit id="af0969299b70206aefe5265b359a29ba784a7b81" translate="yes" xml:space="preserve">
          <source>An feature unstable in &lt;code&gt;const&lt;/code&gt; contexts was used.</source>
          <target state="translated">使用了在 &lt;code&gt;const&lt;/code&gt; 上下文中不稳定的功能。</target>
        </trans-unit>
        <trans-unit id="67fba469014e18ca2e89e6de19c923fe7de4bee7" translate="yes" xml:space="preserve">
          <source>An identifier is any nonempty ASCII string of the following form:</source>
          <target state="translated">标识符是以下形式的任何非空的ASCII字符串。</target>
        </trans-unit>
        <trans-unit id="c175628788a43110a89b193ae816462d4cf2d2a4" translate="yes" xml:space="preserve">
          <source>An identifier is bound more than once in a pattern.</source>
          <target state="translated">一个标识符在一个模式中绑定一次以上。</target>
        </trans-unit>
        <trans-unit id="b2a87fc4bed852d77bc4439f4f9b01dff5c6624b" translate="yes" xml:space="preserve">
          <source>An identifier that is neither defined nor a struct was used.</source>
          <target state="translated">既没有定义也没有使用结构的标识符。</target>
        </trans-unit>
        <trans-unit id="804d52ee70392ba486d9daf55c4a0571322cd6a0" translate="yes" xml:space="preserve">
          <source>An identifier was used like a function name or a value was expected and the identifier exists but it belongs to a different namespace.</source>
          <target state="translated">标识符的使用就像函数名称一样,或者是期望值,而标识符存在,但它属于不同的命名空间。</target>
        </trans-unit>
        <trans-unit id="21a7adea588a50a532e49278e2f1d4c02481c073" translate="yes" xml:space="preserve">
          <source>An identity function that &lt;em&gt;&lt;strong&gt;hints&lt;/strong&gt;&lt;/em&gt; to the compiler to be maximally pessimistic about what &lt;code&gt;black_box&lt;/code&gt; could do.</source>
          <target state="translated">一个标识函数，它&lt;em&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;/em&gt;编译器对 &lt;code&gt;black_box&lt;/code&gt; 可能执行的操作极为悲观。</target>
        </trans-unit>
        <trans-unit id="a9dd54d260c1e67a0aa0b597f6cdb8722318da30" translate="yes" xml:space="preserve">
          <source>An identity function.</source>
          <target state="translated">一个身份函数;</target>
        </trans-unit>
        <trans-unit id="f4072cccbc13fd032256ab05516201c0d8df3e68" translate="yes" xml:space="preserve">
          <source>An if-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding instead. For instance:</source>
          <target state="translated">if-let模式尝试匹配该模式，如果匹配成功，则输入主体。如果匹配是不可辩驳的（当匹配不能失败时），请使用常规的 &lt;code&gt;let&lt;/code&gt; -binding。例如：</target>
        </trans-unit>
        <trans-unit id="a0284d91e655684ff663495c42199a2c25a3b7b6" translate="yes" xml:space="preserve">
          <source>An immutable variable was reassigned.</source>
          <target state="translated">一个不可更改的变量被重新分配。</target>
        </trans-unit>
        <trans-unit id="4ba45e243c916e58a2890a2d541b968fddd22dd8" translate="yes" xml:space="preserve">
          <source>An implementation can take type and lifetime parameters, which can be used in the rest of the implementation. Type parameters declared for an implementation must be used at least once in either the trait or the implementing type of an implementation. Implementation parameters are written directly after the &lt;code&gt;impl&lt;/code&gt; keyword.</source>
          <target state="translated">一个实现可以采用类型和生存期参数，这些参数可以在实现的其余部分中使用。为实现声明的类型参数必须在实现的特征或实现类型中至少使用一次。实现参数直接写在 &lt;code&gt;impl&lt;/code&gt; 关键字之后。</target>
        </trans-unit>
        <trans-unit id="7debed941ec31b919fee56e16fed7f3d43603fb5" translate="yes" xml:space="preserve">
          <source>An implementation cannot be chosen unambiguously because of lack of information.</source>
          <target state="translated">由于缺乏信息,不能毫不含糊地选择实施。</target>
        </trans-unit>
        <trans-unit id="5c1c04198ba70d5ee214d020749cca1de7fc7d00" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Alloc&lt;/code&gt; can allocate, reallocate, and deallocate arbitrary blocks of data described via &lt;code&gt;Layout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Alloc&lt;/code&gt; 的实现可以分配，重新分配和取消分配通过 &lt;code&gt;Layout&lt;/code&gt; 描述的任意数据块。</target>
        </trans-unit>
        <trans-unit id="da7ec04c76427d5dd969fd2e136866257e58eb1e" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;AllocRef&lt;/code&gt; can allocate, grow, shrink, and deallocate arbitrary blocks of data described via &lt;a href=&quot;struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AllocRef&lt;/code&gt; 的实现可以分配，增长，缩小和取消分配通过&lt;a href=&quot;struct.layout&quot;&gt; &lt;code&gt;Layout&lt;/code&gt; &lt;/a&gt;描述的任意数据块。</target>
        </trans-unit>
        <trans-unit id="baf455213042b2250778e00516f43e9464f4756f" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Allocator&lt;/code&gt; can allocate, grow, shrink, and deallocate arbitrary blocks of data described via &lt;a href=&quot;struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator&lt;/code&gt; 的实现可以分配，增长，缩小和取消分配通过&lt;a href=&quot;struct.layout&quot;&gt; &lt;code&gt;Layout&lt;/code&gt; &lt;/a&gt;描述的任意数据块。</target>
        </trans-unit>
        <trans-unit id="99623634884bf4add6cdc497873712ce416c8fd4" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAnd&lt;/code&gt; for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitAnd&lt;/code&gt; 的实现，用于 &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 的包装器。</target>
        </trans-unit>
        <trans-unit id="0e2ff6912f2ce30546aa9104a9c9d196708332bf" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAnd&lt;/code&gt; for a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitAnd&lt;/code&gt; 的实现，用于 &lt;code&gt;bool&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="5f6dfa411cba86305e5e9cd742f9f63d63776e67" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAndAssign&lt;/code&gt; that lifts the &lt;code&gt;&amp;amp;=&lt;/code&gt; operator to a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitAndAssign&lt;/code&gt; 的实现，将 &lt;code&gt;&amp;amp;=&lt;/code&gt; 运算符提升为 &lt;code&gt;bool&lt;/code&gt; 的包装器。</target>
        </trans-unit>
        <trans-unit id="b3e86b6af5dd68737dcc690c4ff3a487a1934868" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitOr&lt;/code&gt; for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">用于 &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 的包装器的 &lt;code&gt;BitOr&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="e8149ba6d1631c707939091192745b37494deb7b" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitOr&lt;/code&gt; for a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitOr&lt;/code&gt; 的实现，用于 &lt;code&gt;bool&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="ce43f6aba41bb7af32e0d6e55432c6b3ca8d7e1a" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitXor&lt;/code&gt; that lifts &lt;code&gt;^&lt;/code&gt; to a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitXor&lt;/code&gt; 的实现，将 &lt;code&gt;^&lt;/code&gt; 提升为 &lt;code&gt;bool&lt;/code&gt; 的包装器。</target>
        </trans-unit>
        <trans-unit id="65cb4db18d08218407844613de42d9029080f521" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitXor&lt;/code&gt; trait for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitXor&lt;/code&gt; 特征的实现，用于 &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 周围的包装器。</target>
        </trans-unit>
        <trans-unit id="b5b904d460aff616075d9ff33295d995d4012b99" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Neg&lt;/code&gt; for &lt;code&gt;Sign&lt;/code&gt;, which allows the use of &lt;code&gt;-&lt;/code&gt; to negate its value.</source>
          <target state="translated">&lt;code&gt;Neg&lt;/code&gt; for &lt;code&gt;Sign&lt;/code&gt; 的实现，它允许使用 &lt;code&gt;-&lt;/code&gt; 取反其值。</target>
        </trans-unit>
        <trans-unit id="873b42d4cd981f821fbfc718a707b146669b45da" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Not&lt;/code&gt; for &lt;code&gt;Answer&lt;/code&gt;, which enables the use of &lt;code&gt;!&lt;/code&gt; to invert its value.</source>
          <target state="translated">&lt;code&gt;Not&lt;/code&gt; for &lt;code&gt;Answer&lt;/code&gt; 的实现，可以使用 &lt;code&gt;!&lt;/code&gt; 转化其价值。</target>
        </trans-unit>
        <trans-unit id="b6ef2365698efd5099fd68eb5d996513953b40b7" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shl&lt;/code&gt; that lifts the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operation on integers to a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">的实现 &lt;code&gt;Shl&lt;/code&gt; 是举起 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 上整数操作，围绕包装 &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e679f132f9bdc673ab7525c566b308cef626454" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shl&lt;/code&gt; that spins a vector leftward by a given amount.</source>
          <target state="translated">&lt;code&gt;Shl&lt;/code&gt; 的实现，将向量向左旋转给定数量。</target>
        </trans-unit>
        <trans-unit id="4b9ea2f9d110fb7b7d2e508e8eb895f2a6c76af4" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;ShlAssign&lt;/code&gt; for a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ShlAssign&lt;/code&gt; 的实现，用于包装 &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdc99f650e402a714069613aef9bb0ab1a03fe00" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shr&lt;/code&gt; that lifts the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operation on integers to a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Shr&lt;/code&gt; 的实现，将整数的 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 操作提升为 &lt;code&gt;usize&lt;/code&gt; 的包装器。</target>
        </trans-unit>
        <trans-unit id="00b6c1f0f935bcc3f078a1d4c1fb779815701d8c" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shr&lt;/code&gt; that spins a vector rightward by a given amount.</source>
          <target state="translated">&lt;code&gt;Shr&lt;/code&gt; 的实现，将向量向右旋转给定数量。</target>
        </trans-unit>
        <trans-unit id="fef3f9c26a074ccf18bb7e56e8695a2a73f26459" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;ShrAssign&lt;/code&gt; for a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ShrAssign&lt;/code&gt; 的实现，用于包装 &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0109084bf6e2896150bb542f8a8637f2cff32f1" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;poll&lt;/code&gt; should strive to return quickly, and should not block. Returning quickly prevents unnecessarily clogging up threads or event loops. If it is known ahead of time that a call to &lt;code&gt;poll&lt;/code&gt; may end up taking awhile, the work should be offloaded to a thread pool (or something similar) to ensure that &lt;code&gt;poll&lt;/code&gt; can return quickly.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 的实现应努力迅速返回，而不应阻止。快速返回可防止不必要地阻塞线程或事件循环。如果提前知道 &lt;code&gt;poll&lt;/code&gt; 调用可能要花费一段时间，则应将工作卸载到线程池（或类似的线程）中，以确保 &lt;code&gt;poll&lt;/code&gt; 可以快速返回。</target>
        </trans-unit>
        <trans-unit id="350059cec8495b6fd084c91dd06a8c1a8c6277a2" translate="yes" xml:space="preserve">
          <source>An implementation of SipHash 2-4.</source>
          <target state="translated">SipHash 2-4的实现。</target>
        </trans-unit>
        <trans-unit id="8a3dd636510b68fa6befc892111d7637911e62f8" translate="yes" xml:space="preserve">
          <source>An implementation of a trait doesn't match the type constraint.</source>
          <target state="translated">一个特质的实现不符合类型约束。</target>
        </trans-unit>
        <trans-unit id="a7c410f2271131f6e26f4c1a6c01fb2def54994c" translate="yes" xml:space="preserve">
          <source>An import was unresolved.</source>
          <target state="translated">一个进口没有解决。</target>
        </trans-unit>
        <trans-unit id="29610251a6990ca267c18a3b17be65ef65d80c1f" translate="yes" xml:space="preserve">
          <source>An important part of the process of learning Rust is learning how to read the error messages the compiler displays: these will guide you toward working code. As such, we&amp;rsquo;ll provide many examples that don&amp;rsquo;t compile along with the error message the compiler will show you in each situation. Know that if you enter and run a random example, it may not compile! Make sure you read the surrounding text to see whether the example you&amp;rsquo;re trying to run is meant to error. Ferris will also help you distinguish code that isn&amp;rsquo;t meant to work:</source>
          <target state="translated">学习Rust的过程的重要部分是学习如何读取编译器显示的错误消息：这些将指导您使用有效的代码。这样，我们将提供许多未编译的示例，以及编译器将在每种情况下向您显示的错误消息。要知道，如果您输入并运行一个随机示例，则该示例可能无法编译！确保阅读了周围的文字，以查看您尝试运行的示例是否有误。Ferris还将帮助您区分不起作用的代码：</target>
        </trans-unit>
        <trans-unit id="9068331ccd5e98287382db124205efdfb79f7cfb" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that the type &lt;code&gt;fmt::Error&lt;/code&gt; should not be confused with &lt;a href=&quot;../io/struct.error&quot;&gt;&lt;code&gt;std::io::Error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;std::error::Error&lt;/code&gt;&lt;/a&gt;, which you may also have in scope.</source>
          <target state="translated">要记住的重要一点是，不要将 &lt;code&gt;fmt::Error&lt;/code&gt; 类型与&lt;a href=&quot;../io/struct.error&quot;&gt; &lt;code&gt;std::io::Error&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../error/trait.error&quot;&gt; &lt;code&gt;std::error::Error&lt;/code&gt; &lt;/a&gt;混淆，您也可以在范围内使用它们。</target>
        </trans-unit>
        <trans-unit id="8f9e81cf6c354fdfd3e66804e1f412009da97856" translate="yes" xml:space="preserve">
          <source>An inclusive bound.</source>
          <target state="translated">一个包容的约束。</target>
        </trans-unit>
        <trans-unit id="192433a73b5ee226652b56c2bf60e3939daf0558" translate="yes" xml:space="preserve">
          <source>An inclusive range needs an end in order to &lt;em&gt;include&lt;/em&gt; it. If you just need a start and no end, use a non-inclusive range (with &lt;code&gt;..&lt;/code&gt;):</source>
          <target state="translated">一个包容范围需要一个末端，以&lt;em&gt;包括&lt;/em&gt;它。如果您只需要起点而不是终点，请使用非包含范围（带有 &lt;code&gt;..&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="50920c083a024a331ce9d74584285d9788301b90" translate="yes" xml:space="preserve">
          <source>An inclusive range was used with no end.</source>
          <target state="translated">采用的是包罗万象的范围,没有尽头。</target>
        </trans-unit>
        <trans-unit id="387b0473c559329b38860546da1e2cce85651e8f" translate="yes" xml:space="preserve">
          <source>An incompatible cast was attempted.</source>
          <target state="translated">尝试了一种不兼容的投。</target>
        </trans-unit>
        <trans-unit id="890a9e60cf506bc22c185b6e6eaa04f58d616d41" translate="yes" xml:space="preserve">
          <source>An incorrect number of generic arguments were provided.</source>
          <target state="translated">提供的通用参数数量不正确。</target>
        </trans-unit>
        <trans-unit id="3ffd66f253621f41011842348ba63bd0896ca4ec" translate="yes" xml:space="preserve">
          <source>An incorrect visibility restriction was specified.</source>
          <target state="translated">指定的可见性限制不正确。</target>
        </trans-unit>
        <trans-unit id="c9900f693c2e1b5744366ed3318b36a718fcf770" translate="yes" xml:space="preserve">
          <source>An infinite endpoint. Indicates that there is no bound in this direction.</source>
          <target state="translated">一个无限的端点。表示这个方向没有边界。</target>
        </trans-unit>
        <trans-unit id="f2f7f4bb84396a832ec236ff6b02e7c811f6141c" translate="yes" xml:space="preserve">
          <source>An inherent implementation is defined as the sequence of the &lt;code&gt;impl&lt;/code&gt; keyword, generic type declarations, a path to a nominal type, a where clause, and a bracketed set of associable items.</source>
          <target state="translated">固有的实现方式定义为 &lt;code&gt;impl&lt;/code&gt; 关键字，通用类型声明，名义类型的路径，where子句以及方括号括起来的集合的顺序。</target>
        </trans-unit>
        <trans-unit id="5e6c6207529ca7e8b2b41ce66b1a1399c7520ae8" translate="yes" xml:space="preserve">
          <source>An inherent implementation was defined for a type outside the current crate.</source>
          <target state="translated">为当前箱子之外的类型定义了一个固有的实现。</target>
        </trans-unit>
        <trans-unit id="506894b4a872753e6bf88eaab162c1ca6bc0d7d6" translate="yes" xml:space="preserve">
          <source>An inherent implementation was defined for something which isn't a struct, enum, union, or trait object.</source>
          <target state="translated">一个固有的实现被定义为不是结构、枚举、联合或特质对象的东西。</target>
        </trans-unit>
        <trans-unit id="110853947b6a8113db0327e6e5f3081c7c63d981" translate="yes" xml:space="preserve">
          <source>An inherent implementation was marked unsafe.</source>
          <target state="translated">一个固有的执行被标记为不安全。</target>
        </trans-unit>
        <trans-unit id="cb3f4eca6453d0b265cd70c611dfbbd1e320cc15" translate="yes" xml:space="preserve">
          <source>An inner doc comment was used in an invalid context.</source>
          <target state="translated">在一个无效的上下文中使用了一个内部文档注释。</target>
        </trans-unit>
        <trans-unit id="eaca7587ab66134ebcc5c9d98dddc7a6d1b623fb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;DirEntry&lt;/code&gt; represents an entry inside of a directory on the filesystem. Each entry can be inspected via methods to learn about the full path or possibly other metadata through per-platform extension traits.</source>
          <target state="translated">&lt;code&gt;DirEntry&lt;/code&gt; 的实例表示文件系统上目录内部的一个条目。可以通过方法检查每个条目，以通过每个平台的扩展特征了解完整路径或可能的其他元数据。</target>
        </trans-unit>
        <trans-unit id="1fbc585e6de8e6bcaf356cf9f8023d57041f924e" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Layout&lt;/code&gt; describes a particular layout of memory. You build a &lt;code&gt;Layout&lt;/code&gt; up as an input to give to an allocator.</source>
          <target state="translated">&lt;code&gt;Layout&lt;/code&gt; 的实例描述了内存的特定布局。您建立一个 &lt;code&gt;Layout&lt;/code&gt; 作为输入以分配给分配器。</target>
        </trans-unit>
        <trans-unit id="b190fdcf2cbfcbc1313cacaba62570eb78c828a4" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;code&gt;File&lt;/code&gt; can be read and/or written depending on what options it was opened with. Files also implement &lt;a href=&quot;../io/trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; to alter the logical cursor that the file contains internally.</source>
          <target state="translated">可以使用打开文件的选项来读取和/或写入 &lt;code&gt;File&lt;/code&gt; 的实例。文件还实现了&lt;a href=&quot;../io/trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;来更改文件内部包含的逻辑光标。</target>
        </trans-unit>
        <trans-unit id="4022f91af4f41ee796badb832f4f942b0dd3666a" translate="yes" xml:space="preserve">
          <source>An integer (&lt;code&gt;i*&lt;/code&gt;/&lt;code&gt;u*&lt;/code&gt;), floating point value (&lt;code&gt;f*&lt;/code&gt;), or raw pointer obtained from &lt;a href=&quot;http://llvm.org/docs/LangRef.html#undefined-values&quot;&gt;uninitialized memory&lt;/a&gt;, or uninitialized memory in a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">整数（ &lt;code&gt;i*&lt;/code&gt; / &lt;code&gt;u*&lt;/code&gt; ），浮点值（ &lt;code&gt;f*&lt;/code&gt; ）或从 &lt;code&gt;str&lt;/code&gt; 中未&lt;a href=&quot;http://llvm.org/docs/LangRef.html#undefined-values&quot;&gt;初始化的内存&lt;/a&gt;或未初始化的内存获得的原始指针。</target>
        </trans-unit>
        <trans-unit id="633635f22724539e9ddd7e7cb1e102a34d52eb44" translate="yes" xml:space="preserve">
          <source>An integer (&lt;code&gt;i*&lt;/code&gt;/&lt;code&gt;u*&lt;/code&gt;), floating point value (&lt;code&gt;f*&lt;/code&gt;), or raw pointer obtained from &lt;a href=&quot;https://llvm.org/docs/LangRef.html#undefined-values&quot;&gt;uninitialized memory&lt;/a&gt;, or uninitialized memory in a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">整数（ &lt;code&gt;i*&lt;/code&gt; / &lt;code&gt;u*&lt;/code&gt; ），浮点值（ &lt;code&gt;f*&lt;/code&gt; ）或从 &lt;code&gt;str&lt;/code&gt; 中未&lt;a href=&quot;https://llvm.org/docs/LangRef.html#undefined-values&quot;&gt;初始化的内存&lt;/a&gt;或未初始化的内存获得的原始指针。</target>
        </trans-unit>
        <trans-unit id="f4459da0411b29eac8078029351bbb76f00d3282" translate="yes" xml:space="preserve">
          <source>An integer &lt;code&gt;.N&lt;/code&gt;:</source>
          <target state="translated">整数 &lt;code&gt;.N&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="908da2eafc06fe6ced0bd1b3ca560bd9a2e72aa4" translate="yes" xml:space="preserve">
          <source>An integer or name followed by dollar sign &lt;code&gt;.N$&lt;/code&gt;:</source>
          <target state="translated">整数或名称后跟美元符号 &lt;code&gt;.N$&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d652b1aec455b9a1399356989d1b6e7890b6c2cf" translate="yes" xml:space="preserve">
          <source>An integer that is known not to equal zero.</source>
          <target state="translated">一个已知不等于零的整数。</target>
        </trans-unit>
        <trans-unit id="23e972eabcd349c601672f385dadf7a600ee560a" translate="yes" xml:space="preserve">
          <source>An integer type which can be safely shared between threads.</source>
          <target state="translated">一个可以在线程之间安全共享的整数类型。</target>
        </trans-unit>
        <trans-unit id="7738cea88357f8684a294b13f985119f27bc796a" translate="yes" xml:space="preserve">
          <source>An intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout</source>
          <target state="translated">来自用户的强度数字,在用户请求锻炼时指定,以表明他们想要的是低强度的锻炼还是高强度的锻炼。</target>
        </trans-unit>
        <trans-unit id="ff8d693a0bfcced7e1e8e51c1bf01052178e048b" translate="yes" xml:space="preserve">
          <source>An interface for dealing with iterators.</source>
          <target state="translated">用于处理迭代器的接口。</target>
        </trans-unit>
        <trans-unit id="22e5648e52f9b0472e117269511bde8fb3cbbf6f" translate="yes" xml:space="preserve">
          <source>An internet socket address, either IPv4 or IPv6.</source>
          <target state="translated">一个互联网套接字地址,可以是IPv4或IPv6。</target>
        </trans-unit>
        <trans-unit id="854d43a414a4b60a4e76077619d9f002787508df" translate="yes" xml:space="preserve">
          <source>An intrinsic is a function available for use in a given programming language whose implementation is handled specially by the compiler. In order to fix this error, just declare a function.</source>
          <target state="translated">固有函数是指在给定的编程语言中可以使用的函数,其实现由编译器特别处理。为了解决这个错误,只需声明一个函数。</target>
        </trans-unit>
        <trans-unit id="0e442cff22b27f71ce2c2ce15532cf3a41eb6841" translate="yes" xml:space="preserve">
          <source>An intrinsic is a function available for use in a given programming language whose implementation is handled specially by the compiler. In order to fix this error, just declare a function. Example:</source>
          <target state="translated">固有函数是指在给定的编程语言中可以使用的函数,其实现由编译器特别处理。为了解决这个错误,只需声明一个函数。例子</target>
        </trans-unit>
        <trans-unit id="d4ed3f185066b7aaf4eec2eeca59086039ee692c" translate="yes" xml:space="preserve">
          <source>An intrinsic was declared without being a function.</source>
          <target state="translated">在没有成为函数的情况下,声明了一个固有函数。</target>
        </trans-unit>
        <trans-unit id="4c83eebd7c224b0a142aede3c5ec04a66d472405" translate="yes" xml:space="preserve">
          <source>An invalid &lt;code&gt;self&lt;/code&gt; import was made.</source>
          <target state="translated">无效的 &lt;code&gt;self&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="82555301e5ea450f3a2a3340087105706f32de3a" translate="yes" xml:space="preserve">
          <source>An invalid cast was attempted.</source>
          <target state="translated">试图进行无效的投掷。</target>
        </trans-unit>
        <trans-unit id="03180be565388e3e9bc81cc13b92d02f2dbb9f6d" translate="yes" xml:space="preserve">
          <source>An invalid input operand constraint was passed to the &lt;code&gt;llvm_asm&lt;/code&gt; macro (third line).</source>
          <target state="translated">无效的输入操作数约束已传递给 &lt;code&gt;llvm_asm&lt;/code&gt; 宏（第三行）。</target>
        </trans-unit>
        <trans-unit id="8c5bb35712d552d14538dee6299b1809a75931fc" translate="yes" xml:space="preserve">
          <source>An invalid left-hand side expression was used on an assignment operation.</source>
          <target state="translated">在赋值操作中使用了无效的左手边表达式。</target>
        </trans-unit>
        <trans-unit id="9a8cc59d01bca4002162d9e4ee195fba0f67e5eb" translate="yes" xml:space="preserve">
          <source>An invalid lint attribute has been given.</source>
          <target state="translated">给出了一个无效的lint属性。</target>
        </trans-unit>
        <trans-unit id="b45ca9e360736d39967051ef73e9a974697dc538" translate="yes" xml:space="preserve">
          <source>An invalid lint attribute has been given. Erroneous code example:</source>
          <target state="translated">给出了一个无效的lint属性。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="7afc8f120588eda0a5e01c8b52b3b7d783b74baf" translate="yes" xml:space="preserve">
          <source>An invalid meta-item was used inside an attribute.</source>
          <target state="translated">在属性中使用了无效的元项。</target>
        </trans-unit>
        <trans-unit id="381c4fb826f13d2ae3a70efbf639e550ce3d899e" translate="yes" xml:space="preserve">
          <source>An invalid name was used for a lifetime parameter.</source>
          <target state="translated">终身参数使用了无效的名称。</target>
        </trans-unit>
        <trans-unit id="ca168fbcb5da1644a515cf8441248863a3fd9251" translate="yes" xml:space="preserve">
          <source>An invalid number of arguments was given when calling a closure.</source>
          <target state="translated">调用闭包时给出的参数数量无效。</target>
        </trans-unit>
        <trans-unit id="7d49fec3c8ae574bb2ce4cd00863f78f3ce2c2fa" translate="yes" xml:space="preserve">
          <source>An invalid number of arguments was passed when calling a function.</source>
          <target state="translated">调用函数时传递了无效的参数数。</target>
        </trans-unit>
        <trans-unit id="fd1272a4d79b74d35bfe264d5c84667b1b0428f6" translate="yes" xml:space="preserve">
          <source>An invalid number of type parameters was given to an intrinsic function.</source>
          <target state="translated">给予一个固有函数的类型参数数量无效。</target>
        </trans-unit>
        <trans-unit id="cc8a5020b458d81f8e941d19c95ab2d679341b81" translate="yes" xml:space="preserve">
          <source>An invalid syntax was passed to the second argument of an &lt;code&gt;llvm_asm&lt;/code&gt; macro line.</source>
          <target state="translated">无效的语法传递给 &lt;code&gt;llvm_asm&lt;/code&gt; 宏行的第二个参数。</target>
        </trans-unit>
        <trans-unit id="a410192aae8c1c9efe2c778af8302870ee71f57b" translate="yes" xml:space="preserve">
          <source>An item usage is ambiguous.</source>
          <target state="translated">一个项目的用法是模糊的。</target>
        </trans-unit>
        <trans-unit id="b5e68274b8d847f0c6926331f1e39e6fca71b9fd" translate="yes" xml:space="preserve">
          <source>An item was added on a negative impl.</source>
          <target state="translated">一个项目是以消极的方式增加的。</target>
        </trans-unit>
        <trans-unit id="a6cc9e350b081b1e617d64ca09e5f7073fb94361" translate="yes" xml:space="preserve">
          <source>An item which isn't a unit struct, a variant, nor a constant has been used as a match pattern.</source>
          <target state="translated">一个不是单元结构、变体或常量的项目被用作匹配模式。</target>
        </trans-unit>
        <trans-unit id="b44509fac7828279e76e0b5a94ab5171cb157956" translate="yes" xml:space="preserve">
          <source>An iterator able to yield elements from both ends.</source>
          <target state="translated">一个能够从两端产生元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="a79f20c0e35d15b48bb2797970d35b63c3629a31" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator.</source>
          <target state="translated">一个类似于&lt;a href=&quot;#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;的迭代器适配器，它持有内部状态并生成一个新的迭代器。</target>
        </trans-unit>
        <trans-unit id="2e43d9b7345ad03f5ced2dcd31e711c42d237584" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个类似于&lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;的迭代器适配器，它持有内部状态并生成一个新的迭代器。&lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="773601e7cb6c7b2cb91410d40c83395d2f5a2aba" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个类似于&lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;的迭代器适配器，它持有内部状态并生成一个新的迭代器。&lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8c9fb31213d58aac0ffdd0c9178139dd13dff6e" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个类似于&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;的迭代器适配器，它持有内部状态并生成一个新的迭代器。&lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fabf413b8f61a0afd7c5f9433f5804c39c0d2697" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个类似于&lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;的迭代器适配器，它持有内部状态并生成一个新的迭代器。&lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d2199c2efde5116c38701a8b589ced48670c6b8" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator.</source>
          <target state="translated">一个类似于&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;的迭代器适配器，它持有内部状态并生成一个新的迭代器。</target>
        </trans-unit>
        <trans-unit id="1597ff1cbb678de32b1737072c75c63f3cb34a01" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个类似于&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;的迭代器适配器，它持有内部状态并生成一个新的迭代器。&lt;a href=&quot;trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f7d60e521538ea62f876d5c70c545dc3addec69" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于[ &lt;code&gt;fold&lt;/code&gt; ] 的迭代器适配器，它保持内部状态并生成新的迭代器。&lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a650dc159a2fda49c7766be96685d0f790f13a0" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于[ &lt;code&gt;fold&lt;/code&gt; ] 的迭代器适配器，它保持内部状态并生成新的迭代器。&lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e898bdaf274bb7754df65ccfb97b6bd04568d2d" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于[ &lt;code&gt;fold&lt;/code&gt; ] 的迭代器适配器，它保持内部状态并生成新的迭代器。&lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2996431c0507a4a842fe331c88d08e4bb45dcce" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于[ &lt;code&gt;fold&lt;/code&gt; ] 的迭代器适配器，它保持内部状态并生成新的迭代器。&lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae7a2ef58596a8f574790d9946d5c7b0d3e0427f" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">类似于[ &lt;code&gt;fold&lt;/code&gt; ] 的迭代器适配器，它保持内部状态并生成新的迭代器。&lt;a href=&quot;trait.iterator#method.scan&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ad9db34c1f6ac7b97514886d275ac1277b33c65" translate="yes" xml:space="preserve">
          <source>An iterator for stepping iterators by a custom amount.</source>
          <target state="translated">自定义数量的步进迭代器。</target>
        </trans-unit>
        <trans-unit id="25debeb61a2ecc2a431e58a161838a09b915993a" translate="yes" xml:space="preserve">
          <source>An iterator has a method, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, which when called, returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt;. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(Item)&lt;/code&gt;&lt;/a&gt; as long as there are elements, and once they've all been exhausted, will return &lt;code&gt;None&lt;/code&gt; to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; again may or may not eventually start returning &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(Item)&lt;/code&gt;&lt;/a&gt; again at some point (for example, see &lt;a href=&quot;../sync/mpsc/struct.tryiter&quot;&gt;&lt;code&gt;TryIter&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">迭代器具有&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;方法，该方法在调用时将返回&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt; 。只要有元素，&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(Item)&lt;/code&gt; &lt;/a&gt;，一旦所有元素用尽，将返回 &lt;code&gt;None&lt;/code&gt; 指示迭代已完成。各个迭代器可能选择恢复迭代，因此再次调用&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;可能会或可能最终不会在某个时候再次开始返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(Item)&lt;/code&gt; &lt;/a&gt;（例如，请参见&lt;a href=&quot;../sync/mpsc/struct.tryiter&quot;&gt; &lt;code&gt;TryIter&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fb45f260d1289d4ddcd0c03f93e3cf026ce37b59" translate="yes" xml:space="preserve">
          <source>An iterator has a method, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, which when called, returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt;. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;Some(Item)&lt;/code&gt; as long as there are elements, and once they've all been exhausted, will return &lt;code&gt;None&lt;/code&gt; to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; again may or may not eventually start returning &lt;code&gt;Some(Item)&lt;/code&gt; again at some point.</source>
          <target state="translated">迭代器具有&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;方法，该方法在调用时将返回&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt; 。只要有元素，&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;将返回 &lt;code&gt;Some(Item)&lt;/code&gt; ，一旦所有元素用尽，将返回 &lt;code&gt;None&lt;/code&gt; 表示迭代已完成。各个迭代器可以选择恢复迭代，因此再次调用&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;可能会或可能最终不会在某个点开始再次返回 &lt;code&gt;Some(Item)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e31522f53dadc02b86f505f8fd01b611f6643e8b" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.</source>
          <target state="translated">一个迭代器方法,对迭代器中的每个项目应用一个易错函数,在第一个错误处停止,并返回该错误。</target>
        </trans-unit>
        <trans-unit id="eacb362cba384eacfe624626c78db089eba4406f" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../../../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，该方法将易错函数应用于迭代器中的每个项目，在第一个错误处停止并返回该错误。&lt;a href=&quot;../../../iter/trait.iterator#method.try_for_each&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca00c28d4b5a3134e86a3f660b2fa54093267401" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，该方法将易错函数应用于迭代器中的每个项目，在第一个错误处停止并返回该错误。&lt;a href=&quot;../../iter/trait.iterator#method.try_for_each&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1489bd41c8525121e45484ed737c4171e974de0" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，该方法将易错函数应用于迭代器中的每个项目，在第一个错误处停止并返回该错误。&lt;a href=&quot;../iter/trait.iterator#method.try_for_each&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33c934134cacb66bd994968f86b620a631318b91" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，该方法将易错函数应用于迭代器中的每个项目，在第一个错误处停止并返回该错误。&lt;a href=&quot;iter/trait.iterator#method.try_for_each&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19bfdbf913f10e6bc3776600b92d9135c032b4bf" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，该方法将易错函数应用于迭代器中的每个项目，在第一个错误处停止并返回该错误。&lt;a href=&quot;trait.iterator#method.try_for_each&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b59c2e3f2042ddc5a53ef66ef4d7b79f1fb5301" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value.</source>
          <target state="translated">一个迭代器方法,只要成功返回,就应用一个函数,产生一个单一的最终值。</target>
        </trans-unit>
        <trans-unit id="117fd8070a23ba82f744d90c448b1e5813b4d282" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../../../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个迭代器方法，它只要成功返回就应用函数，并产生单个最终值。&lt;a href=&quot;../../../iter/trait.iterator#method.try_fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ee1c8bd3a25e2ebef94ba8c0d6405c27ca7226b" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个迭代器方法，它只要成功返回就应用函数，并产生单个最终值。&lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c658b3e624db269551bf93242408ef5c42e5fea9" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个迭代器方法，它只要成功返回就应用函数，并产生单个最终值。&lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a5362af3855236bb52258529c3514119a249eab" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个迭代器方法，它只要成功返回就应用函数，并产生单个最终值。&lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="22eb23eabd6f5888b0f6233654a7d6b3279d1ac7" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一个迭代器方法，它只要成功返回就应用函数，并产生单个最终值。&lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d551693bdcaedeac0547d596669a3c5c5179447" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value.</source>
          <target state="translated">一个应用函数的迭代方法,产生一个单一的最终值。</target>
        </trans-unit>
        <trans-unit id="31400216ecaba12666aff645bec4ca26c5ba43ea" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">应用函数的迭代器方法，产生一个最终值。&lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="958c160388552a918125f55bba9e086f54f71484" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">应用函数的迭代器方法，产生一个最终值。&lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5eddc2fc826e92b735803187068d19d4e441542e" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">应用函数的迭代器方法，产生一个最终值。&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062b8bbee99bc123d00bd6ddb37a2091ecaee57f" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">应用函数的迭代器方法，产生一个最终值。&lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="760ff7a591ac95e16cd7be5b9667ba1c820bc96e" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">应用函数的迭代器方法，产生一个最终值。&lt;a href=&quot;trait.iterator#method.fold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4cfaa2271cf9f33fe50ead23cff9cf9b29c2c97" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back.</source>
          <target state="translated">迭代器方法,将迭代器的元素从后面开始减少到一个单一的最终值。</target>
        </trans-unit>
        <trans-unit id="c9c712bf49f750f238c96785e7e704d976a72f0e" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，从背面开始，将迭代器的元素减少为单个最终值。&lt;a href=&quot;../../iter/trait.doubleendediterator#method.rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b44201682fdbcad5c8da77522b47e4b7fc4a3dc1" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;../iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，从背面开始，将迭代器的元素减少为单个最终值。&lt;a href=&quot;../iter/trait.doubleendediterator#method.rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc53bae551d78289c9703ed2a397d1c3b35f285e" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，从背面开始，将迭代器的元素减少为单个最终值。&lt;a href=&quot;iter/trait.doubleendediterator#method.rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="836f4f2e3fffc61e14c382d8890f27b7a367beeb" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">一种迭代器方法，从背面开始，将迭代器的元素减少为单个最终值。&lt;a href=&quot;trait.doubleendediterator#method.rfold&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2acafc012d5ccce6e7696757b55337a6d4029a3" translate="yes" xml:space="preserve">
          <source>An iterator of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt; over the string encoded as UTF-16.</source>
          <target state="translated">&lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;的迭代器，编码为UTF-16的字符串。</target>
        </trans-unit>
        <trans-unit id="143fd7db785baccd8bb8346c04f451192a09006a" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and its ancestors.</source>
          <target state="translated">&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;及其祖先的迭代器。</target>
        </trans-unit>
        <trans-unit id="554dfaab9d83066a6b95354b7620556448cb3449" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;a href=&quot;trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;的迭代器</target>
        </trans-unit>
        <trans-unit id="aef63e9607a8ec1f5f596fca15621080fd76af72" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;code&gt;u8&lt;/code&gt; values of a reader.</source>
          <target state="translated">读取器的 &lt;code&gt;u8&lt;/code&gt; 值的迭代器。</target>
        </trans-unit>
        <trans-unit id="34e3362281b15b977d0a61ac8c5fcd00a6511c9c" translate="yes" xml:space="preserve">
          <source>An iterator over a mutable reference to the &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;变量的可变引用上进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="c74c624cf35ae570735e4b7f11b57db582409878" translate="yes" xml:space="preserve">
          <source>An iterator over a mutable reference to the &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个对&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;变量的可变引用的迭代器。</target>
        </trans-unit>
        <trans-unit id="f4de84f3b1b68ec9fb8cadcc939ec573f412a94a" translate="yes" xml:space="preserve">
          <source>An iterator over a reference to the &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;变体的引用的迭代器。</target>
        </trans-unit>
        <trans-unit id="8cd69f81931caab64a8dceae843c42a8b1faa3e1" translate="yes" xml:space="preserve">
          <source>An iterator over a reference to the &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个对&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;变量的引用的迭代器。</target>
        </trans-unit>
        <trans-unit id="3dc6f80802c085f551ddaf86ddf6e8acc1dc310c" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">从切片的开头开始，以（不重叠）块（一次 &lt;code&gt;N&lt;/code&gt; 个元素）的形式在切片上进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="6d2aa423fb037ba3e42490b4a4869e7a989a8b38" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">从切片的开头开始，以（不重叠）块（一次为 &lt;code&gt;chunk_size&lt;/code&gt; 元素）的形式在切片上进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="51ba4c3e078709e91115e94720e3b32e5a3519a2" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the end of the slice.</source>
          <target state="translated">从切片的末尾开始，以（不重叠）块（一次为 &lt;code&gt;chunk_size&lt;/code&gt; 元素）的形式在切片上进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="d8851ef0d971f6cf3a6b130edee19da50b2e6eeb" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">在切片上迭代（不重叠）的可变块（一次 &lt;code&gt;N&lt;/code&gt; 个元素）中的迭代器，从切片的开头开始。</target>
        </trans-unit>
        <trans-unit id="b727a794715c05c6c1c0cd0cd6149d40bd7c3a04" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">在切片上迭代（不重叠）的可变块（一次， &lt;code&gt;chunk_size&lt;/code&gt; 元素）中的迭代器，从切片的开头开始。</target>
        </trans-unit>
        <trans-unit id="590e04be01e914183b27d18dc8eff4e3ae5668f0" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the end of the slice.</source>
          <target state="translated">从切片的末尾开始，在（不重叠的）可变块（一次为 &lt;code&gt;chunk_size&lt;/code&gt; 元素）中的切片上进行迭代。</target>
        </trans-unit>
        <trans-unit id="68ad6606a48079fe489aab3faf8c6e3a26b992ca" translate="yes" xml:space="preserve">
          <source>An iterator over a snapshot of the environment variables of this process.</source>
          <target state="translated">这个进程的环境变量快照的迭代器。</target>
        </trans-unit>
        <trans-unit id="a94e3f24bb1eb1ba2fd58ebddc9b4d9dba8309a8" translate="yes" xml:space="preserve">
          <source>An iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 中条目子范围的迭代器。</target>
        </trans-unit>
        <trans-unit id="d03569c5a9963027ad22996c9e0b70fb1554a87f" translate="yes" xml:space="preserve">
          <source>An iterator over a sub-range of items in a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 中项目子范围的迭代器。</target>
        </trans-unit>
        <trans-unit id="ce0b01e77f645194e2b6b751858aec640161f669" translate="yes" xml:space="preserve">
          <source>An iterator over an &lt;a href=&quot;trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; and its sources.</source>
          <target state="translated">一个&lt;a href=&quot;trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;及其源的迭代器。</target>
        </trans-unit>
        <trans-unit id="f19c5dd669fe6f36f81a65798f7219d0079a694d" translate="yes" xml:space="preserve">
          <source>An iterator over incoming connections to a &lt;a href=&quot;struct.unixlistener&quot;&gt;&lt;code&gt;UnixListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对与&lt;a href=&quot;struct.unixlistener&quot;&gt; &lt;code&gt;UnixListener&lt;/code&gt; 的&lt;/a&gt;传入连接进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="4d7488e2fccb6b43b42e67c9ea07cad9428b393b" translate="yes" xml:space="preserve">
          <source>An iterator over messages on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;a href=&quot;struct.receiver#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;struct.receiver#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;创建的在&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;上的消息上进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="034a20701e995ae32aa63104e2d5dff0ab5db4e6" translate="yes" xml:space="preserve">
          <source>An iterator over overlapping subslices of length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">在长度 &lt;code&gt;size&lt;/code&gt; 重叠的子切片上进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="ba3bd9fb0e96735ece0b2069d478b585f0d8e7fe" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.</source>
          <target state="translated">迭代器在由匹配谓词函数的元素分隔的子切面上进行迭代,限于给定的切面数,从切面的末端开始。</target>
        </trans-unit>
        <trans-unit id="24b57b67d67808582aa0647134f85aea733abfd0" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.</source>
          <target state="translated">迭代器在由匹配谓词函数的元素分隔的子切面上进行迭代,限制在给定的分割数量。</target>
        </trans-unit>
        <trans-unit id="7f751853b227571562b0215c1381b97b30029d0a" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.</source>
          <target state="translated">从分片的末端开始,对由匹配谓词函数的元素分隔的子分片进行迭代。</target>
        </trans-unit>
        <trans-unit id="6a41aa74d34fd0ce2985da917544c4f35cf020f9" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function.</source>
          <target state="translated">迭代器在由匹配谓词函数的元素分隔的子片上。</target>
        </trans-unit>
        <trans-unit id="e1f02e8fb3b3f7adf4ed8a711ed0b9c2ca4cda3e" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of &lt;code&gt;self&lt;/code&gt;, separated by characters matched by a pattern and yielded in reverse order.</source>
          <target state="translated">在 &lt;code&gt;self&lt;/code&gt; 的子字符串上进行迭代的迭代器，该子字符串由与模式匹配的字符分隔，并以相反的顺序产生。</target>
        </trans-unit>
        <trans-unit id="61c715ce9520941f9108744caef70fb9d86c6529" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">给定字符串切片的子字符串的迭代器，由模式分隔，最多只能返回 &lt;code&gt;n&lt;/code&gt; 个项目。</target>
        </trans-unit>
        <trans-unit id="44ffc34ab178359db4b3169f249d963fd153689b" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</source>
          <target state="translated">在给定字符串分片的子串上进行迭代,以模式匹配的字符分隔,并以反向顺序产生。</target>
        </trans-unit>
        <trans-unit id="f65e61a07278abe6a5b629cd21c031c73243b0de" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</source>
          <target state="translated">迭代给定字符串分片的子串,用模式匹配的字符分隔。</target>
        </trans-unit>
        <trans-unit id="537813cfc78da0abdca4b435c9341ecf42939302" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">从字符串的末尾开始，在此字符串切片的子字符串上进行迭代的迭代器，由模式分隔，限制为最多返回 &lt;code&gt;n&lt;/code&gt; 个项目。</target>
        </trans-unit>
        <trans-unit id="02d9a6b83a0665db88c523e6eaff227f1f6e5ae9" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by characters matched by a pattern.</source>
          <target state="translated">迭代这个字符串分片的子串,用模式匹配的字符分隔。</target>
        </trans-unit>
        <trans-unit id="a2052e6e3b1c0165802cd6417a16b0838afc588a" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by &lt;code&gt;split&lt;/code&gt; in that &lt;code&gt;split_inclusive&lt;/code&gt; leaves the matched part as the terminator of the substring.</source>
          <target state="translated">在此字符串片段的子字符串上的迭代器，该迭代器由与模式匹配的字符分隔。与 &lt;code&gt;split&lt;/code&gt; 产生的迭代器的不同之处在于 &lt;code&gt;split_inclusive&lt;/code&gt; 将匹配的部分保留为子字符串的终止符。</target>
        </trans-unit>
        <trans-unit id="0ef8a4c9f98576b84451f0afffc7c456b9562b40" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s of a string slice, and their positions.</source>
          <target state="translated">在字符串切片的&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;及其位置上进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="6dbafa08f3b2b12e80351b71ca200a8528053590" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s of a string slice.</source>
          <target state="translated">字符串切片的&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;的迭代器。</target>
        </trans-unit>
        <trans-unit id="94f1d147d9aa55e9343a89220481dd294b3c1ca7" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;s of a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slices.</source>
          <target state="translated">作为&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;切片的&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; 上&lt;/a&gt;的迭代器。</target>
        </trans-unit>
        <trans-unit id="81b7c7eac770fb32d5f49a8fa6788046e188a635" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;s of a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在迭代器&lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt;是个的&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0046da9ead2fd2c36a6a2fa82a2d2ece3e53ebf5" translate="yes" xml:space="preserve">
          <source>An iterator over the arguments of a process, yielding a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; value for each argument.</source>
          <target state="translated">在进程的参数上进行迭代的迭代器，为每个参数生成一个&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="ebb5d1c5d63504b0108ad325cad0bf7d2676c9ed" translate="yes" xml:space="preserve">
          <source>An iterator over the arguments of a process, yielding an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; value for each argument.</source>
          <target state="translated">在进程的参数上进行迭代的迭代器，为每个参数生成&lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="db156c74a7f7733ec8d2fb32dcfb0fa41d392992" translate="yes" xml:space="preserve">
          <source>An iterator over the bytes of a string slice.</source>
          <target state="translated">字符串分片字节的迭代器。</target>
        </trans-unit>
        <trans-unit id="3d759394e80e7fa435aa3e0e0304961fda1ff609" translate="yes" xml:space="preserve">
          <source>An iterator over the command arguments.</source>
          <target state="translated">命令参数的迭代器。</target>
        </trans-unit>
        <trans-unit id="bc24e95b2a3b7911eb4e4a74052e9fbce963a97d" translate="yes" xml:space="preserve">
          <source>An iterator over the command environment variables.</source>
          <target state="translated">命令环境变量的迭代器。</target>
        </trans-unit>
        <trans-unit id="e870ff1a2a9d31100b2ac9cb6ffbae140349bbde" translate="yes" xml:space="preserve">
          <source>An iterator over the contents of an instance of &lt;code&gt;BufRead&lt;/code&gt; split on a particular byte.</source>
          <target state="translated">对 &lt;code&gt;BufRead&lt;/code&gt; 实例的内容进行迭代的迭代器，将其拆分为特定的字节。</target>
        </trans-unit>
        <trans-unit id="df77d35e2c4e122e560661a4bc012ddb30bf89c7" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within &lt;code&gt;self&lt;/code&gt;, yielded in reverse order along with the index of the match.</source>
          <target state="translated">对 &lt;code&gt;self&lt;/code&gt; 内某个模式的不相交匹配进行迭代的迭代器，其结果与匹配索引的顺序相反。</target>
        </trans-unit>
        <trans-unit id="f7d549ea470a7ac3f5b7f05549ca71296a3cf479" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within the given string slice.</source>
          <target state="translated">在给定的字符串分片中,对不相交匹配的模式进行迭代。</target>
        </trans-unit>
        <trans-unit id="4e8c4e320605a2ab4ab8ef1e11e40919b14ac665" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</source>
          <target state="translated">迭代器,遍历这个字符串分片中的不相交匹配的模式,以及匹配开始的索引。</target>
        </trans-unit>
        <trans-unit id="bf644211cc86eb9babefe771489adf416b34d943" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.</source>
          <target state="translated">迭代这个字符串分片内的不相交匹配的模式,按反向顺序产生。</target>
        </trans-unit>
        <trans-unit id="a4b7288e219c65d73a3e6a54b4428c628926ca26" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;BinaryHeap&lt;/code&gt; 元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="60a4b99de7b2aa615fb862b4ef6662bf265a07b3" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">对 &lt;code&gt;LinkedList&lt;/code&gt; 的元素进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="2f97f18a1c5aa5746176c6f51c4eafd84be2fce3" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 的元素上的迭代器。</target>
        </trans-unit>
        <trans-unit id="91db6e4ce90dbed18c33044e96c535db60789527" translate="yes" xml:space="preserve">
          <source>An iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 条目的迭代器。</target>
        </trans-unit>
        <trans-unit id="89075f098d105168914ad089684eab6ab82bd15c" translate="yes" xml:space="preserve">
          <source>An iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 条目的迭代器。</target>
        </trans-unit>
        <trans-unit id="6598ccbf021650c51246c68845640e9702eed23d" translate="yes" xml:space="preserve">
          <source>An iterator over the escaped version of a byte.</source>
          <target state="translated">迭代一个字节的转义版本。</target>
        </trans-unit>
        <trans-unit id="56eb86799cc14570dbdb72543cfaf21c05c1abe2" translate="yes" xml:space="preserve">
          <source>An iterator over the items of a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 的项的迭代器。</target>
        </trans-unit>
        <trans-unit id="d5fd2e8685f9eef9092473bf82703d995770cb96" translate="yes" xml:space="preserve">
          <source>An iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 的项目上的迭代器。</target>
        </trans-unit>
        <trans-unit id="c8ce67dcd74b8165190d1c5586f09c2e5112934e" translate="yes" xml:space="preserve">
          <source>An iterator over the keys of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 的键的迭代器。</target>
        </trans-unit>
        <trans-unit id="6ab13d3c24ccbf1b667994220cf1ff47151b518f" translate="yes" xml:space="preserve">
          <source>An iterator over the keys of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 的键的迭代器。</target>
        </trans-unit>
        <trans-unit id="bdb3c68f21440272514f422ef05c2d524b30604a" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of a string, as string slices.</source>
          <target state="translated">字符串的迭代器,作为字符串切片。</target>
        </trans-unit>
        <trans-unit id="47a35066a39c1ed7b30ce9f4878b660c0a1e7474" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of a string.</source>
          <target state="translated">字符串的迭代器。</target>
        </trans-unit>
        <trans-unit id="4cce7f5b74c3be64996357d548c448d7d2f4462a" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of an instance of &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;BufRead&lt;/code&gt; 实例的行上进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="cc70893f07fa207bd53da767c3e857dc38ff1063" translate="yes" xml:space="preserve">
          <source>An iterator over the mutable subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">向量的可变子切片上的迭代器，该子切片由与 &lt;code&gt;pred&lt;/code&gt; 匹配的元素分隔。</target>
        </trans-unit>
        <trans-unit id="a3ce41435c2e05d485713b80e3d67f84041531ab" translate="yes" xml:space="preserve">
          <source>An iterator over the non-ASCII-whitespace substrings of a string, separated by any amount of ASCII whitespace.</source>
          <target state="translated">一个迭代器,遍历字符串的非ASCII空格子串,用任意数量的ASCII空格分隔。</target>
        </trans-unit>
        <trans-unit id="98639edcf075ef0bbd56694e6fd8f3ab5801fa3b" translate="yes" xml:space="preserve">
          <source>An iterator over the non-whitespace substrings of a string, separated by any amount of whitespace.</source>
          <target state="translated">字符串的非空格子串的迭代器,由任意数量的空格分隔。</target>
        </trans-unit>
        <trans-unit id="f6d3a015ca8e0813b9d2a570221365ce0bb7b9f3" translate="yes" xml:space="preserve">
          <source>An iterator over the subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;, starting from the end of the slice.</source>
          <target state="translated">在向量的子切片上进行迭代的迭代器，这些迭代器由与 &lt;code&gt;pred&lt;/code&gt; 匹配的元素分隔，从切片的末尾开始。</target>
        </trans-unit>
        <trans-unit id="82456e1206b372bf7ea9d2f45cb440546d002943" translate="yes" xml:space="preserve">
          <source>An iterator over the subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">在向量的子切片上进行迭代的迭代器，这些子切片由与 &lt;code&gt;pred&lt;/code&gt; 匹配的元素分隔。</target>
        </trans-unit>
        <trans-unit id="551626c835c28af1e23d1b77fa736e5fca587fd5" translate="yes" xml:space="preserve">
          <source>An iterator over the value in &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; 的&lt;/a&gt;&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;变体中的值的迭代器。</target>
        </trans-unit>
        <trans-unit id="2ad0a62fd20b029d94f3ea06e170d6042fc65d39" translate="yes" xml:space="preserve">
          <source>An iterator over the value in a &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;变体中对值进行迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="06914df7e2feff75ffe46782ed50136c93cfaa1b" translate="yes" xml:space="preserve">
          <source>An iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 的值的迭代器。</target>
        </trans-unit>
        <trans-unit id="25879aa8de242e212254e6f312a25f5c0bfcd32b" translate="yes" xml:space="preserve">
          <source>An iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 的值的迭代器。</target>
        </trans-unit>
        <trans-unit id="1d5f58fc7c0c008712ec4e6eb8559eb52c39ce18" translate="yes" xml:space="preserve">
          <source>An iterator produced by &lt;code&gt;repeat_with()&lt;/code&gt; is not a &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;. If you need &lt;code&gt;repeat_with()&lt;/code&gt; to return a &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;, please open a GitHub issue explaining your use case.</source>
          <target state="translated">由 &lt;code&gt;repeat_with()&lt;/code&gt; 产生的迭代器不是&lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;。如果您需要 &lt;code&gt;repeat_with()&lt;/code&gt; 返回&lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;，请打开GitHub问题，说明您的用例。</target>
        </trans-unit>
        <trans-unit id="28ebf2a599d5ab4a921fbe241809a3d3600be3e5" translate="yes" xml:space="preserve">
          <source>An iterator produced by &lt;code&gt;repeat_with()&lt;/code&gt; is not a &lt;code&gt;DoubleEndedIterator&lt;/code&gt;. If you need &lt;code&gt;repeat_with()&lt;/code&gt; to return a &lt;code&gt;DoubleEndedIterator&lt;/code&gt;, please open a GitHub issue explaining your use case.</source>
          <target state="translated">由 &lt;code&gt;repeat_with()&lt;/code&gt; 产生的迭代器不是 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 。如果您需要 &lt;code&gt;repeat_with()&lt;/code&gt; 返回 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; ，请打开GitHub问题，说明您的用例。</target>
        </trans-unit>
        <trans-unit id="57a784df1f13cfa8da5679e054cc8033f6fabdb2" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on BTreeMap.</source>
          <target state="translated">通过在 &lt;code&gt;drain_filter&lt;/code&gt; 上调用rain_filter生成的迭代器。</target>
        </trans-unit>
        <trans-unit id="8506c9bfb6eed5d29b225ea0333e263b7b9b1840" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on BTreeSet.</source>
          <target state="translated">通过在 &lt;code&gt;drain_filter&lt;/code&gt; 上调用rain_filter产生的迭代器。</target>
        </trans-unit>
        <trans-unit id="c51b3a9a86a32de916b3441f5cc928b34139d94d" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on LinkedList.</source>
          <target state="translated">通过在LinkedList上调用 &lt;code&gt;drain_filter&lt;/code&gt; 产生的迭代器。</target>
        </trans-unit>
        <trans-unit id="d90f64072c9b86fb5e160826e11d54a35519d306" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on Vec.</source>
          <target state="translated">通过在Vec上调用 &lt;code&gt;drain_filter&lt;/code&gt; 产生的迭代器。</target>
        </trans-unit>
        <trans-unit id="e2f38bdab7ee3f88662413a8d0762d07987cc9e4" translate="yes" xml:space="preserve">
          <source>An iterator that always continues to yield &lt;code&gt;None&lt;/code&gt; when exhausted.</source>
          <target state="translated">迭代器在耗尽后始终继续产生 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d75b48632d15091a831b75304f768ce72229865c" translate="yes" xml:space="preserve">
          <source>An iterator that attempts to yield all pending values for a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;a href=&quot;struct.receiver#method.try_iter&quot;&gt;&lt;code&gt;try_iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个尝试生成&lt;a href=&quot;struct.receiver#method.try_iter&quot;&gt; &lt;code&gt;try_iter&lt;/code&gt; &lt;/a&gt;创建的&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; 的&lt;/a&gt;所有未决值的迭代器。</target>
        </trans-unit>
        <trans-unit id="0c0e45d489e23ad54f254e3c451b03c3ad3633b8" translate="yes" xml:space="preserve">
          <source>An iterator that calls a function with a reference to each element before yielding it.</source>
          <target state="translated">一个迭代器,在产生元素之前,调用一个对每个元素有引用的函数。</target>
        </trans-unit>
        <trans-unit id="51a9a929e3e766e1bc15473a2edf034711e9603a" translate="yes" xml:space="preserve">
          <source>An iterator that clones the elements of an underlying iterator.</source>
          <target state="translated">一个克隆底层迭代器元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="d2287777325ba0f8a82eefc9f82886c5e6c0375c" translate="yes" xml:space="preserve">
          <source>An iterator that copies the elements of an underlying iterator.</source>
          <target state="translated">一个复制底层迭代器元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="11b5eb68a058f133076c97a53287f7350b19b4ed" translate="yes" xml:space="preserve">
          <source>An iterator that decodes UTF-16 encoded code points from an iterator of &lt;code&gt;u16&lt;/code&gt;s.</source>
          <target state="translated">一个迭代器，它从 &lt;code&gt;u16&lt;/code&gt; 的迭代器解码UTF-16编码的代码点。</target>
        </trans-unit>
        <trans-unit id="a7c2f22f759edefd0c02e7989a0830d2b9927824" translate="yes" xml:space="preserve">
          <source>An iterator that filters the elements of &lt;code&gt;iter&lt;/code&gt; with &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="translated">一个用 &lt;code&gt;predicate&lt;/code&gt; 过滤 &lt;code&gt;iter&lt;/code&gt; 元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="538c0bdbb5f2579b6454154f638e3b2235b91db1" translate="yes" xml:space="preserve">
          <source>An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.</source>
          <target state="translated">扁平化一级嵌套的迭代器,可以变成迭代器的东西。</target>
        </trans-unit>
        <trans-unit id="9dbf52f6fb3a5236b83ac424b9036cbd60fd5a39" translate="yes" xml:space="preserve">
          <source>An iterator that infinitely &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;s connections on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个迭代器，它无限期地&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;上的s连接。</target>
        </trans-unit>
        <trans-unit id="81a5d4ccf76ade25979b7f90350112e1ade77257" translate="yes" xml:space="preserve">
          <source>An iterator that iterates two other iterators simultaneously.</source>
          <target state="translated">同时迭代其他两个迭代器的迭代器。</target>
        </trans-unit>
        <trans-unit id="ca3c41a43b14bf4c961d798c07db548fe5c4306e" translate="yes" xml:space="preserve">
          <source>An iterator that knows its exact length.</source>
          <target state="translated">一个知道其确切长度的迭代器。</target>
        </trans-unit>
        <trans-unit id="6bd3d7d181c5f76ada28bd405c55b98768c1a53e" translate="yes" xml:space="preserve">
          <source>An iterator that links two iterators together, in a chain.</source>
          <target state="translated">将两个迭代器连接在一起的迭代器,在一个链上。</target>
        </trans-unit>
        <trans-unit id="fd413348f096597213f95708520a2a2ee8e8c6ff" translate="yes" xml:space="preserve">
          <source>An iterator that maps each element to an iterator, and yields the elements of the produced iterators.</source>
          <target state="translated">一个将每个元素映射到迭代器的迭代器,并产生产生迭代器的元素。</target>
        </trans-unit>
        <trans-unit id="e00fb1707b378038f217f0122cb5c2c693a99ce9" translate="yes" xml:space="preserve">
          <source>An iterator that maps the values of &lt;code&gt;iter&lt;/code&gt; with &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该值映射的迭代器 &lt;code&gt;iter&lt;/code&gt; 用 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c89c4d0277ad0dbe70fcef9f7526e1d26306d3c4" translate="yes" xml:space="preserve">
          <source>An iterator that moves out of a vector.</source>
          <target state="translated">一个从向量中移动出来的迭代器。</target>
        </trans-unit>
        <trans-unit id="18d1634bc6586ab56c39fac0a163c9d8e2300d06" translate="yes" xml:space="preserve">
          <source>An iterator that only accepts elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;Some(_)&lt;/code&gt;.</source>
          <target state="translated">一个仅在 &lt;code&gt;predicate&lt;/code&gt; 返回 &lt;code&gt;Some(_)&lt;/code&gt; 时才接受元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="5d780c4556be41e5ade58ccb90a4cb9745c8a4a0" translate="yes" xml:space="preserve">
          <source>An iterator that only accepts elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">一个仅在 &lt;code&gt;predicate&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 时才接受元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="ca756e17e11dd720fde75ad3acbb4dc61da5a0b9" translate="yes" xml:space="preserve">
          <source>An iterator that only iterates over the first &lt;code&gt;n&lt;/code&gt; iterations of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">一个仅迭代 &lt;code&gt;iter&lt;/code&gt; 的前 &lt;code&gt;n&lt;/code&gt; 个迭代的迭代器。</target>
        </trans-unit>
        <trans-unit id="473994edf3f2b12636ecfbae9c0cf95e9976442a" translate="yes" xml:space="preserve">
          <source>An iterator that rejects elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，它在 &lt;code&gt;predicate&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 时拒绝元素。</target>
        </trans-unit>
        <trans-unit id="0464de53ba73fee454800ae2dd5fef9380113b90" translate="yes" xml:space="preserve">
          <source>An iterator that repeats an element endlessly.</source>
          <target state="translated">一个无限重复一个元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="7f0331c06c1f3247687712e4a8fa91faa255da79" translate="yes" xml:space="preserve">
          <source>An iterator that repeats elements of type &lt;code&gt;A&lt;/code&gt; endlessly by applying the provided closure &lt;code&gt;F: FnMut() -&amp;gt; A&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，通过应用提供的闭包 &lt;code&gt;F: FnMut() -&amp;gt; A&lt;/code&gt; 无限地重复类型 &lt;code&gt;A&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="4f71391fe387efdecec312046c6dd55bbf198321" translate="yes" xml:space="preserve">
          <source>An iterator that repeats endlessly.</source>
          <target state="translated">一个无休止地重复的迭代器。</target>
        </trans-unit>
        <trans-unit id="905426af2dba7f51c454090a12d4200524fdd44c" translate="yes" xml:space="preserve">
          <source>An iterator that reports an accurate length using size_hint.</source>
          <target state="translated">一个使用size_hint报告准确长度的迭代器。</target>
        </trans-unit>
        <trans-unit id="6e8e68927103c8756bd8e724310ac62f637e383b" translate="yes" xml:space="preserve">
          <source>An iterator that skips over &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">跳过 &lt;code&gt;iter&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 个元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="cc8fdbf15929bf39a9148cd3ad1f02b7e2f3e8e1" translate="yes" xml:space="preserve">
          <source>An iterator that splits an environment variable into paths according to platform-specific conventions.</source>
          <target state="translated">一个迭代器,根据平台特定的约定将环境变量分割成路径。</target>
        </trans-unit>
        <trans-unit id="57ccd12f7079988974d92028c7ca992c2e3dc8d6" translate="yes" xml:space="preserve">
          <source>An iterator that strings two iterators together.</source>
          <target state="translated">一个将两个迭代器串在一起的迭代器。</target>
        </trans-unit>
        <trans-unit id="277e34f21de2c1bcf08658ea7180ea41a724c7da" translate="yes" xml:space="preserve">
          <source>An iterator that uses &lt;code&gt;f&lt;/code&gt; to both filter and map elements from &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，使用 &lt;code&gt;f&lt;/code&gt; 来过滤和映射 &lt;code&gt;iter&lt;/code&gt; 中的元素。</target>
        </trans-unit>
        <trans-unit id="d1c29ab729712117252122597b1f8dee40693e18" translate="yes" xml:space="preserve">
          <source>An iterator that when yielding an item will have taken at least one element from its underlying &lt;a href=&quot;trait.sourceiter&quot;&gt;&lt;code&gt;SourceIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个迭代器，当生成一个项目时，它将从其基础&lt;a href=&quot;trait.sourceiter&quot;&gt; &lt;code&gt;SourceIter&lt;/code&gt; 中&lt;/a&gt;获取至少一个元素。</target>
        </trans-unit>
        <trans-unit id="290a4df52520d8c2cd218b2c5a66207c17bd76b5" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;None&lt;/code&gt; forever after the underlying iterator yields &lt;code&gt;None&lt;/code&gt; once.</source>
          <target state="translated">迭代器，产量 &lt;code&gt;None&lt;/code&gt; 底层迭代器的产量后永远 &lt;code&gt;None&lt;/code&gt; 一次。</target>
        </trans-unit>
        <trans-unit id="8077f46e4926a9ba2fe0c3a0111f99b3bfd0cee7" translate="yes" xml:space="preserve">
          <source>An iterator that yields a single element of type &lt;code&gt;A&lt;/code&gt; by applying the provided closure &lt;code&gt;F: FnOnce() -&amp;gt; A&lt;/code&gt;.</source>
          <target state="translated">通过应用提供的闭包 &lt;code&gt;F: FnOnce() -&amp;gt; A&lt;/code&gt; 产生类型 &lt;code&gt;A&lt;/code&gt; 的单个元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="f74ed23fee03be7f9726d86e04759a8cdc7c98f8" translate="yes" xml:space="preserve">
          <source>An iterator that yields an element exactly once.</source>
          <target state="translated">一个迭代器,只产生一次元素。</target>
        </trans-unit>
        <trans-unit id="d839e72a6966bc49a09991c75f6ebb8c0f577f86" translate="yes" xml:space="preserve">
          <source>An iterator that yields nothing.</source>
          <target state="translated">一个什么都不产生的迭代器。</target>
        </trans-unit>
        <trans-unit id="5c4e0833b181576427135eb9c8df2d3b1200509f" translate="yes" xml:space="preserve">
          <source>An iterator that yields the current count and the element during iteration.</source>
          <target state="translated">一个迭代器,在迭代过程中产生当前计数和元素。</target>
        </trans-unit>
        <trans-unit id="13cc9cc84ea0ac8db6860e2d362f3768df8c56c8" translate="yes" xml:space="preserve">
          <source>An iterator that yields the literal escape code of a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">产生 &lt;code&gt;char&lt;/code&gt; 字面量转义码的迭代器。</target>
        </trans-unit>
        <trans-unit id="f37b0b305dd49cedb47e6f8dfa5f3a2bdad3bf67" translate="yes" xml:space="preserve">
          <source>An iterator to maintain state while iterating another iterator.</source>
          <target state="translated">一个迭代器在迭代另一个迭代器时保持状态。</target>
        </trans-unit>
        <trans-unit id="47ba4cac2215dd1a04b338eb0e4a94df69cf3c0f" translate="yes" xml:space="preserve">
          <source>An iterator visiting all elements in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a T&lt;/code&gt;.</source>
          <target state="translated">一个以任意顺序访问所有元素的迭代器。迭代器元素类型是 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7550894b7d1bb85e45b801eaeed48efa989854c0" translate="yes" xml:space="preserve">
          <source>An iterator visiting all key-value pairs in arbitrary order, with mutable references to the values. The iterator element type is &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a mut V)&lt;/code&gt;.</source>
          <target state="translated">迭代器以任意顺序访问所有键值对，并带有对值的可变引用。迭代器元素的类型为 &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a mut V)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b08b2653f7dcb8dc940ed24069740a24ab5b76a" translate="yes" xml:space="preserve">
          <source>An iterator visiting all key-value pairs in arbitrary order. The iterator element type is &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a V)&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，以任意顺序访问所有键值对。迭代器元素类型为 &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a V)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a52b26a20f6e5a2edebe10f6f90cf9507490a85c" translate="yes" xml:space="preserve">
          <source>An iterator visiting all keys in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a K&lt;/code&gt;.</source>
          <target state="translated">迭代器以任意顺序访问所有键。迭代器元素类型是 &lt;code&gt;&amp;amp;'a K&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cee3468b8b5e0fdd5a440c2d5df35c4c2db2ae90" translate="yes" xml:space="preserve">
          <source>An iterator visiting all values in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a V&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，以任意顺序访问所有值。迭代器元素类型是 &lt;code&gt;&amp;amp;'a V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ae307f212519994d8b694a5d942377f4aec4823" translate="yes" xml:space="preserve">
          <source>An iterator visiting all values mutably in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a mut V&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，它以任意顺序可变地访问所有值。迭代器元素类型是 &lt;code&gt;&amp;amp;'a mut V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="211d7c1adc8a12b57341be994e857003e54c6bbd" translate="yes" xml:space="preserve">
          <source>An iterator where each iteration calls the provided closure &lt;code&gt;F: FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，每次迭代调用提供的闭包 &lt;code&gt;F: FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33d8e5b7da8d4676782754a628f4083ffd272c18" translate="yes" xml:space="preserve">
          <source>An iterator which uses a closure to determine if an element should be removed.</source>
          <target state="translated">一个迭代器,它使用一个闭包来确定是否应该删除一个元素。</target>
        </trans-unit>
        <trans-unit id="c53ddbd1d3e296430ed20afa68efda72ca0ded32" translate="yes" xml:space="preserve">
          <source>An iterator with a &lt;code&gt;peek()&lt;/code&gt; that returns an optional reference to the next element.</source>
          <target state="translated">一个带有 &lt;code&gt;peek()&lt;/code&gt; 的迭代器，它返回对下一个元素的可选引用。</target>
        </trans-unit>
        <trans-unit id="c9cd5154a20293338cfe2c0c0c884bc897a9a0cb" translate="yes" xml:space="preserve">
          <source>An new iterator where each successive item is computed based on the preceding one.</source>
          <target state="translated">一个新的迭代器,每一个连续的项目都是基于前一个项目计算的。</target>
        </trans-unit>
        <trans-unit id="a64664459e6bcefaf4f866fe61f4c89bbbc6e913" translate="yes" xml:space="preserve">
          <source>An non-ascii identifier was used in an invalid context.</source>
          <target state="translated">在无效的情况下使用了一个非ascii标识符。</target>
        </trans-unit>
        <trans-unit id="767a832ec64e700730e273e825321e36a3ef86e1" translate="yes" xml:space="preserve">
          <source>An occupied entry.</source>
          <target state="translated">一个被占领的入口。</target>
        </trans-unit>
        <trans-unit id="678664bfa424da9fc0ca21e4760f29b4b952648d" translate="yes" xml:space="preserve">
          <source>An optional item</source>
          <target state="translated">可选项目</target>
        </trans-unit>
        <trans-unit id="d7f5308e6f605cdab4dbb8b387f9c93de98d0922" translate="yes" xml:space="preserve">
          <source>An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">如果一个订单（对于所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ）为：</target>
        </trans-unit>
        <trans-unit id="e7c75396d6933448cc7456d6beaf9cf648ea0ef5" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is equal to another.</source>
          <target state="translated">一个比较值等于另一个值的排序。</target>
        </trans-unit>
        <trans-unit id="09dba8210b3d0ce590a3a5f065b62a6a8ab493fb" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is greater than another.</source>
          <target state="translated">一个比较值大于另一个值的排序。</target>
        </trans-unit>
        <trans-unit id="a2c8ca4c96fc50eebfe4b351916be57d1bf56d8c" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is less than another.</source>
          <target state="translated">一个比较值小于另一个比较值的排序。</target>
        </trans-unit>
        <trans-unit id="38792f39e0fa160ba176220b302fc6518c1e2555" translate="yes" xml:space="preserve">
          <source>An owned permission to join on a thread (block on its termination).</source>
          <target state="translated">一个拥有的加入线程的权限(在线程终止时阻止)。</target>
        </trans-unit>
        <trans-unit id="8c3512dc7441f7c48feb0adfb2813ca8cbecd465" translate="yes" xml:space="preserve">
          <source>An owned, mutable path (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">拥有的可变路径（类似于&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e84205a36cc39374bcb7d05c1b1547f37b9b5189" translate="yes" xml:space="preserve">
          <source>An owning iterator over messages on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;strong&gt;Receiver::into_iter&lt;/strong&gt;.</source>
          <target state="translated">一个拥有超过迭代器上的消息&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;，通过创建&lt;strong&gt;接收机:: into_iter&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="83bd664b01b4716a8aced24a8192a6358972a99f" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">拥有 &lt;code&gt;BinaryHeap&lt;/code&gt; 元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="34718a674d09c2eb637513ac6f89289f300970ef" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;LinkedList&lt;/code&gt; 的元素上拥有的迭代器。</target>
        </trans-unit>
        <trans-unit id="f6f353b2a400a09971f91285403f6b780ae991c4" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;VecDeque&lt;/code&gt; 的元素上拥有的迭代器。</target>
        </trans-unit>
        <trans-unit id="77a86a6c2dd3031f17c5e8abfe6100f81887dd42" translate="yes" xml:space="preserve">
          <source>An owning iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 的条目上的所有者迭代器。</target>
        </trans-unit>
        <trans-unit id="209ab8cbe2152f0b0d82c7256751114f7cd068b9" translate="yes" xml:space="preserve">
          <source>An owning iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 条目上的所有者迭代器。</target>
        </trans-unit>
        <trans-unit id="ef6f78f2a2dbde9b33ceeac921bd77fbb502b5bc" translate="yes" xml:space="preserve">
          <source>An owning iterator over the items of a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;BTreeSet&lt;/code&gt; 的项目上拥有的迭代器。</target>
        </trans-unit>
        <trans-unit id="427fdeccedc75e2673269080f0ce6c0924e6c1bd" translate="yes" xml:space="preserve">
          <source>An owning iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 的项目上拥有的迭代器。</target>
        </trans-unit>
        <trans-unit id="63f91fac0583c8f40d303b24662fb74f3439b187" translate="yes" xml:space="preserve">
          <source>An owning iterator over the keys of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 的键上的所有者迭代器。</target>
        </trans-unit>
        <trans-unit id="3d2eac75b0f121647617969553f50d0b9466ca4f" translate="yes" xml:space="preserve">
          <source>An owning iterator over the keys of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 的键上的拥有的迭代器。</target>
        </trans-unit>
        <trans-unit id="c812167dc1a9620fc28974d42c5f815dace73059" translate="yes" xml:space="preserve">
          <source>An owning iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 的值的拥有者迭代器。</target>
        </trans-unit>
        <trans-unit id="e996a80994408e932109330c3a7b8f4f5821448e" translate="yes" xml:space="preserve">
          <source>An owning iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 的值上的拥有的迭代器。</target>
        </trans-unit>
        <trans-unit id="b9b2d7fe27e12071feb7334cad3f7f83e9e84aa2" translate="yes" xml:space="preserve">
          <source>An unary operator was used on a type which doesn't implement it.</source>
          <target state="translated">在一个没有实现单利运算的类型上使用了单利运算。</target>
        </trans-unit>
        <trans-unit id="dcb71e1bf306a3b27e4be98207d51ae66d320fdd" translate="yes" xml:space="preserve">
          <source>An unbounded range (&lt;code&gt;..&lt;/code&gt;).</source>
          <target state="translated">无限范围（ &lt;code&gt;..&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="17e397882c6b5d98ce823af67a0207c6b4f0a351" translate="yes" xml:space="preserve">
          <source>An unboxed trait object was used as a return value.</source>
          <target state="translated">一个未装箱的特质对象被用作返回值。</target>
        </trans-unit>
        <trans-unit id="77330b9c19314a31717caeb5c6b57d3f4259e03a" translate="yes" xml:space="preserve">
          <source>An unchecked assertion allows a program in an inconsistent state to keep running, which might have unexpected consequences but does not introduce unsafety as long as this only happens in safe code. The performance cost of assertions, however, is not measurable in general. Replacing &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;debug_assert!&lt;/code&gt; is thus only encouraged after thorough profiling, and more importantly, only in safe code!</source>
          <target state="translated">未检查的断言允许处于不一致状态的程序继续运行，这可能会带来意想不到的后果，但不会引入不安全性，只要这种不安全性仅在安全代码中发生即可。但是，断言的性能成本通常无法衡量。替换&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;用 &lt;code&gt;debug_assert!&lt;/code&gt; 因此，只有在进行彻底分析后才鼓励这样做，更重要的是，仅在安全代码中才鼓励这样做！</target>
        </trans-unit>
        <trans-unit id="3caad6b327abced5bae6f8ff205241ca33ed53ab" translate="yes" xml:space="preserve">
          <source>An unchecked assertion allows a program in an inconsistent state to keep running, which might have unexpected consequences but does not introduce unsafety as long as this only happens in safe code. The performance cost of assertions, is however, not measurable in general. Replacing &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;debug_assert!&lt;/code&gt; is thus only encouraged after thorough profiling, and more importantly, only in safe code!</source>
          <target state="translated">未检查的断言允许处于不一致状态的程序继续运行，这可能会带来意想不到的后果，但不会引入不安全性，只要这仅在安全代码中发生即可。但是，断言的性能成本通常无法衡量。替换&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;用 &lt;code&gt;debug_assert!&lt;/code&gt; 因此，只有在进行彻底分析后才鼓励这样做，更重要的是，只有在安全代码中才鼓励这样做！</target>
        </trans-unit>
        <trans-unit id="442287d37e019d0e550c26e6f3dfcfb70e25272a" translate="yes" xml:space="preserve">
          <source>An undeclared crate, module, or type was used.</source>
          <target state="translated">使用了一个未申报的箱子、模块或类型。</target>
        </trans-unit>
        <trans-unit id="490b1d248ac38d604233cacff667b31a463976df" translate="yes" xml:space="preserve">
          <source>An undeclared label was used.</source>
          <target state="translated">使用了一个未申报的标签。</target>
        </trans-unit>
        <trans-unit id="5cc74f4a7dec23f15c6176f5d92410a97be0cd49" translate="yes" xml:space="preserve">
          <source>An undeclared lifetime was used.</source>
          <target state="translated">使用了未申报的寿命。</target>
        </trans-unit>
        <trans-unit id="fc0bdd57bc131e7f23a48af9227bf2c7b9e2b4dd" translate="yes" xml:space="preserve">
          <source>An undeclared type or module was used.</source>
          <target state="translated">使用了一个未声明的类型或模块。</target>
        </trans-unit>
        <trans-unit id="62b209ea92b4732aa055c2148d6eb87f3bf6ae79" translate="yes" xml:space="preserve">
          <source>An undefined atomic operation function was declared.</source>
          <target state="translated">声明了一个未定义的原子操作函数。</target>
        </trans-unit>
        <trans-unit id="edf946e9423b88dbc97c6f1ffa6e16764af6cd52" translate="yes" xml:space="preserve">
          <source>An underscore &lt;code&gt;_&lt;/code&gt; character has been used as the identifier for a lifetime.</source>
          <target state="translated">下划线 &lt;code&gt;_&lt;/code&gt; 字符已被用作一生的标识符。</target>
        </trans-unit>
        <trans-unit id="5c74d6c9b38a67d2a5eb623d75e946df289a3fbc" translate="yes" xml:space="preserve">
          <source>An unknown &quot;kind&quot; was specified for a link attribute.</source>
          <target state="translated">为一个链接属性指定了一个未知的 &quot;种类&quot;。</target>
        </trans-unit>
        <trans-unit id="2dbef161c3305374da24ca6e3ae9cdc7bdefe6b4" translate="yes" xml:space="preserve">
          <source>An unknown &quot;kind&quot; was specified for a link attribute. Erroneous code example:</source>
          <target state="translated">为一个链接属性指定了一个未知的 &quot;种类&quot;。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="a5956e957dc8b784f0e077b9955dd790db201d80" translate="yes" xml:space="preserve">
          <source>An unknown argument was given to the &lt;code&gt;inline&lt;/code&gt; attribute.</source>
          <target state="translated">给 &lt;code&gt;inline&lt;/code&gt; 属性提供了未知参数。</target>
        </trans-unit>
        <trans-unit id="7d952bcfdbb1c8f63e3755c7054750e6c464627c" translate="yes" xml:space="preserve">
          <source>An unknown argument was given to the &lt;code&gt;instruction_set&lt;/code&gt; attribute.</source>
          <target state="translated">未知参数被赋予了 &lt;code&gt;instruction_set&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="55c4e65153fb4fac3f59b06b3332f14a29b39777" translate="yes" xml:space="preserve">
          <source>An unknown external lang item was used.</source>
          <target state="translated">使用了一个未知的外部lang项目。</target>
        </trans-unit>
        <trans-unit id="9a99f6d07dc4d8ba35aa89128cc34d06dd11ce0f" translate="yes" xml:space="preserve">
          <source>An unknown external lang item was used. Erroneous code example:</source>
          <target state="translated">使用了一个未知的外部lang项目。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="1356f6d3a3c2ce1216defe8b6863fd5e9393d5fa" translate="yes" xml:space="preserve">
          <source>An unknown field was specified into a structure.</source>
          <target state="translated">一个未知的字段被指定到一个结构中。</target>
        </trans-unit>
        <trans-unit id="672bd73128faa09c7f440466e9f29739ad4de42d" translate="yes" xml:space="preserve">
          <source>An unknown field was specified into an enum's structure variant.</source>
          <target state="translated">一个未知的字段被指定到一个枚举的结构变体中。</target>
        </trans-unit>
        <trans-unit id="bee5691463189269e4f427b52c0849d39e9df4f5" translate="yes" xml:space="preserve">
          <source>An unknown intrinsic function was declared.</source>
          <target state="translated">申报了一个未知的固有函数。</target>
        </trans-unit>
        <trans-unit id="e8a840a4e189fb8e18f90b5fe877d384d51d1d3c" translate="yes" xml:space="preserve">
          <source>An unknown lint was used on the command line.</source>
          <target state="translated">在命令行中使用了未知的绒毛。</target>
        </trans-unit>
        <trans-unit id="d472ec49c42739263d3ec941f6cf5b5468a2d3b2" translate="yes" xml:space="preserve">
          <source>An unknown meta item was used.</source>
          <target state="translated">使用了一个未知的元项目。</target>
        </trans-unit>
        <trans-unit id="a940cccd136dc43c95bcfd2c10667fe77e672634" translate="yes" xml:space="preserve">
          <source>An unknown predicate was used inside the &lt;code&gt;cfg&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 属性内使用了未知谓词。</target>
        </trans-unit>
        <trans-unit id="99aaced696882b10f70ccb01859e75fc7704670e" translate="yes" xml:space="preserve">
          <source>An unknown tool name was found in a scoped lint.</source>
          <target state="translated">在一个有范围的棉絮中发现了一个未知的工具名称。</target>
        </trans-unit>
        <trans-unit id="676d0b3b83f48e6af11d16fc5aee8adc4d048290" translate="yes" xml:space="preserve">
          <source>An unknown tuple struct/variant has been used.</source>
          <target state="translated">使用了一个未知的元组结构/变量。</target>
        </trans-unit>
        <trans-unit id="c12ae2fbe23adbaee9a27dcd9a18b88d8f9167df" translate="yes" xml:space="preserve">
          <source>An unnamed address:</source>
          <target state="translated">一个不知名的地址。</target>
        </trans-unit>
        <trans-unit id="91f0af616d741e6aae624d3d1dd86d853eef5383" translate="yes" xml:space="preserve">
          <source>An unnecessary type or const parameter was given in a type alias.</source>
          <target state="translated">在类型别名中给出了一个不必要的类型或常量参数。</target>
        </trans-unit>
        <trans-unit id="f156b900d9fe99f8832687ac7404efd74f0ba00f" translate="yes" xml:space="preserve">
          <source>An unpoisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">无毒的&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3386e5166859dc07663dec10855432efda42e389" translate="yes" xml:space="preserve">
          <source>An unpoisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">无毒的 &lt;code&gt;Once&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="940487cb36b1ca715dc9f782d9f8a844e917518b" translate="yes" xml:space="preserve">
          <source>An unreachable label was used.</source>
          <target state="translated">使用了一个无法到达的标签。</target>
        </trans-unit>
        <trans-unit id="9a03f5a8f224f5f2ce3d5df647878dfe5aac207b" translate="yes" xml:space="preserve">
          <source>An unresolved name was used.</source>
          <target state="translated">使用了一个未解决的名字。</target>
        </trans-unit>
        <trans-unit id="261553d92051fa692c480d6d0e6fd303bf5038fd" translate="yes" xml:space="preserve">
          <source>An unsafe trait was implemented without an unsafe implementation.</source>
          <target state="translated">一个不安全的性状被实施了,却没有一个不安全的实施。</target>
        </trans-unit>
        <trans-unit id="084105813293c7ee4385ace5ee9239e1a67b6d57" translate="yes" xml:space="preserve">
          <source>An unstable feature in &lt;code&gt;const&lt;/code&gt; contexts was used.</source>
          <target state="translated">在 &lt;code&gt;const&lt;/code&gt; 上下文中使用了不稳定的功能。</target>
        </trans-unit>
        <trans-unit id="c801b4c85f18e94f7cb6ce228ae449c345e89b49" translate="yes" xml:space="preserve">
          <source>An unstable feature was used.</source>
          <target state="translated">使用了一个不稳定的功能。</target>
        </trans-unit>
        <trans-unit id="2837c8cb90a7a15d78fb3ebeda3b87105514ef73" translate="yes" xml:space="preserve">
          <source>An unsupported expression was used inside a const context.</source>
          <target state="translated">在const上下文中使用了一个不支持的表达式。</target>
        </trans-unit>
        <trans-unit id="ad604b2507c78bd47c93ad249e197a918e7208ca" translate="yes" xml:space="preserve">
          <source>An unsupported representation was attempted on a zero-variant enum.</source>
          <target state="translated">在一个零变量枚举上尝试了一个不支持的表示。</target>
        </trans-unit>
        <trans-unit id="999140d65b2dddb09bc1533f2a2a2de632081b87" translate="yes" xml:space="preserve">
          <source>Anatomy of a Rust Program</source>
          <target state="translated">锈蚀程序的解剖</target>
        </trans-unit>
        <trans-unit id="f96afdd93db8b2e4f4aa8b97a7ac6e4f106649a9" translate="yes" xml:space="preserve">
          <source>Ancestors</source>
          <target state="translated">Ancestors</target>
        </trans-unit>
        <trans-unit id="a69185f73b3266ea2ea0196235a7920d98b23569" translate="yes" xml:space="preserve">
          <source>Ancestors::all</source>
          <target state="translated">Ancestors::all</target>
        </trans-unit>
        <trans-unit id="5d0f93422db0f668490adf089654ecece89c57a9" translate="yes" xml:space="preserve">
          <source>Ancestors::any</source>
          <target state="translated">Ancestors::any</target>
        </trans-unit>
        <trans-unit id="c4d070344a11e561f295e6e7e6205f761d5798b6" translate="yes" xml:space="preserve">
          <source>Ancestors::borrow</source>
          <target state="translated">Ancestors::borrow</target>
        </trans-unit>
        <trans-unit id="a84c8539090bc4c2974d99b05a787e636ebe0acb" translate="yes" xml:space="preserve">
          <source>Ancestors::borrow_mut</source>
          <target state="translated">Ancestors::borrow_mut</target>
        </trans-unit>
        <trans-unit id="334238f85474f459cc0ffaef3421caf90b07c6e6" translate="yes" xml:space="preserve">
          <source>Ancestors::by_ref</source>
          <target state="translated">Ancestors::by_ref</target>
        </trans-unit>
        <trans-unit id="6fdc4e3375706d83d8aecc92a22ee70bff5dfab4" translate="yes" xml:space="preserve">
          <source>Ancestors::chain</source>
          <target state="translated">Ancestors::chain</target>
        </trans-unit>
        <trans-unit id="dce0f9cae4b8d7222a0b11c873b249cd98da26b3" translate="yes" xml:space="preserve">
          <source>Ancestors::clone</source>
          <target state="translated">Ancestors::clone</target>
        </trans-unit>
        <trans-unit id="31848f144e07d27fc7390a8c92d56ab88474c213" translate="yes" xml:space="preserve">
          <source>Ancestors::clone_from</source>
          <target state="translated">Ancestors::clone_from</target>
        </trans-unit>
        <trans-unit id="35f7611233faafb5be9d7d385104097f21e72511" translate="yes" xml:space="preserve">
          <source>Ancestors::clone_into</source>
          <target state="translated">Ancestors::clone_into</target>
        </trans-unit>
        <trans-unit id="0d02f4a4459ad43a2bc9f83a20b48ce81eb5eefc" translate="yes" xml:space="preserve">
          <source>Ancestors::cloned</source>
          <target state="translated">Ancestors::cloned</target>
        </trans-unit>
        <trans-unit id="67ff55ec2d9537e58736a03fd50c337049b761f0" translate="yes" xml:space="preserve">
          <source>Ancestors::cmp</source>
          <target state="translated">Ancestors::cmp</target>
        </trans-unit>
        <trans-unit id="0d35d199d39196de0523350cd24a1241424fa231" translate="yes" xml:space="preserve">
          <source>Ancestors::collect</source>
          <target state="translated">Ancestors::collect</target>
        </trans-unit>
        <trans-unit id="4865b6ff2a1901685d10435c12cf071b254d3a62" translate="yes" xml:space="preserve">
          <source>Ancestors::copied</source>
          <target state="translated">Ancestors::copied</target>
        </trans-unit>
        <trans-unit id="f28d6b4a44e14f0d15c4f132d556116c210c1c84" translate="yes" xml:space="preserve">
          <source>Ancestors::count</source>
          <target state="translated">Ancestors::count</target>
        </trans-unit>
        <trans-unit id="a6a740680e9008614345c582b8e1985861829875" translate="yes" xml:space="preserve">
          <source>Ancestors::cycle</source>
          <target state="translated">Ancestors::cycle</target>
        </trans-unit>
        <trans-unit id="0810bcf20fe4de2312f283ad13e930eaa61b0c30" translate="yes" xml:space="preserve">
          <source>Ancestors::enumerate</source>
          <target state="translated">Ancestors::enumerate</target>
        </trans-unit>
        <trans-unit id="f443387bf4a86a6cc1330d9f2c4d3b913b1c1dd0" translate="yes" xml:space="preserve">
          <source>Ancestors::eq</source>
          <target state="translated">Ancestors::eq</target>
        </trans-unit>
        <trans-unit id="796eb87c3af9fac554be5d4ec57ca702d510701f" translate="yes" xml:space="preserve">
          <source>Ancestors::filter</source>
          <target state="translated">Ancestors::filter</target>
        </trans-unit>
        <trans-unit id="d1822e4ea409150f5e23e24201bc84ef25560137" translate="yes" xml:space="preserve">
          <source>Ancestors::filter_map</source>
          <target state="translated">Ancestors::filter_map</target>
        </trans-unit>
        <trans-unit id="1e6cc0ef677409077aa639becd452ada01ece8d8" translate="yes" xml:space="preserve">
          <source>Ancestors::find</source>
          <target state="translated">Ancestors::find</target>
        </trans-unit>
        <trans-unit id="657aafc8bbaf8304573fbc00e24419ba040782a9" translate="yes" xml:space="preserve">
          <source>Ancestors::find_map</source>
          <target state="translated">Ancestors::find_map</target>
        </trans-unit>
        <trans-unit id="beeb7e3fb0fbc04618a5300c980c6f59ed075dcd" translate="yes" xml:space="preserve">
          <source>Ancestors::flat_map</source>
          <target state="translated">Ancestors::flat_map</target>
        </trans-unit>
        <trans-unit id="47bd10eda5c1ca25f0cc303ef197cbc1220d1b53" translate="yes" xml:space="preserve">
          <source>Ancestors::flatten</source>
          <target state="translated">Ancestors::flatten</target>
        </trans-unit>
        <trans-unit id="a456cec1879b2b70a77233841a841755191a8a86" translate="yes" xml:space="preserve">
          <source>Ancestors::fmt</source>
          <target state="translated">Ancestors::fmt</target>
        </trans-unit>
        <trans-unit id="1f02f420430d3894ec9ecddf11dd94365e77ac19" translate="yes" xml:space="preserve">
          <source>Ancestors::fold</source>
          <target state="translated">Ancestors::fold</target>
        </trans-unit>
        <trans-unit id="3ca5818636166fd5b398f8e40a922c894b0abbb6" translate="yes" xml:space="preserve">
          <source>Ancestors::for_each</source>
          <target state="translated">Ancestors::for_each</target>
        </trans-unit>
        <trans-unit id="4264a030cb324bfbad2fa80a46e42c679803a0c3" translate="yes" xml:space="preserve">
          <source>Ancestors::from</source>
          <target state="translated">Ancestors::from</target>
        </trans-unit>
        <trans-unit id="32047f73315575a8e50a462155406bb910ceed17" translate="yes" xml:space="preserve">
          <source>Ancestors::fuse</source>
          <target state="translated">Ancestors::fuse</target>
        </trans-unit>
        <trans-unit id="41f1796019df27f1dc523c24819d1254f099c660" translate="yes" xml:space="preserve">
          <source>Ancestors::ge</source>
          <target state="translated">Ancestors::ge</target>
        </trans-unit>
        <trans-unit id="f1594f0c385b82f3427f45ed26a50d1dac4fa05e" translate="yes" xml:space="preserve">
          <source>Ancestors::gt</source>
          <target state="translated">Ancestors::gt</target>
        </trans-unit>
        <trans-unit id="dd54e2ff77b477361ff6376d5b04afaad6a7ef21" translate="yes" xml:space="preserve">
          <source>Ancestors::inspect</source>
          <target state="translated">Ancestors::inspect</target>
        </trans-unit>
        <trans-unit id="1bc8d1bb95f4aedebacf2a84051d097086c1cc75" translate="yes" xml:space="preserve">
          <source>Ancestors::into</source>
          <target state="translated">Ancestors::into</target>
        </trans-unit>
        <trans-unit id="6f7bdf57cf985a0498067e483576359d43c33000" translate="yes" xml:space="preserve">
          <source>Ancestors::into_iter</source>
          <target state="translated">Ancestors::into_iter</target>
        </trans-unit>
        <trans-unit id="e4f570f8f86838a0b2f0996de24967465582d845" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted</source>
          <target state="translated">Ancestors::is_sorted</target>
        </trans-unit>
        <trans-unit id="8fa7773f21437bd02461103d0f128fe2f328180a" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted_by</source>
          <target state="translated">Ancestors::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="da156b45c81720439526b87f492a4b80dde53f7a" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted_by_key</source>
          <target state="translated">Ancestors::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6bf6d1d6ec433eb2498f88c1821e2e8d204490c9" translate="yes" xml:space="preserve">
          <source>Ancestors::last</source>
          <target state="translated">Ancestors::last</target>
        </trans-unit>
        <trans-unit id="6182ceed3235394e0830f635f2568ba50e3e7bb2" translate="yes" xml:space="preserve">
          <source>Ancestors::le</source>
          <target state="translated">Ancestors::le</target>
        </trans-unit>
        <trans-unit id="ba00a013a0f8fd57e29b01f66afccf088e1d0023" translate="yes" xml:space="preserve">
          <source>Ancestors::lt</source>
          <target state="translated">Ancestors::lt</target>
        </trans-unit>
        <trans-unit id="b588193780984cc7ebdb2f28a2c09aad1660160a" translate="yes" xml:space="preserve">
          <source>Ancestors::map</source>
          <target state="translated">Ancestors::map</target>
        </trans-unit>
        <trans-unit id="aa73ed60029c8667bd3541a6cd43b17d298a34bc" translate="yes" xml:space="preserve">
          <source>Ancestors::max</source>
          <target state="translated">Ancestors::max</target>
        </trans-unit>
        <trans-unit id="ab6d430bbae01a6904e8639546e74aa743ec4546" translate="yes" xml:space="preserve">
          <source>Ancestors::max_by</source>
          <target state="translated">Ancestors::max_by</target>
        </trans-unit>
        <trans-unit id="3f9a117ba2cfb9ce3093457ddf5a2896b25c3699" translate="yes" xml:space="preserve">
          <source>Ancestors::max_by_key</source>
          <target state="translated">Ancestors::max_by_key</target>
        </trans-unit>
        <trans-unit id="d86ac9020bc2e94f4de10dd0521bc6648555300a" translate="yes" xml:space="preserve">
          <source>Ancestors::min</source>
          <target state="translated">Ancestors::min</target>
        </trans-unit>
        <trans-unit id="d1a3237b0f7d1400e70026876d1a9e1edfd954fb" translate="yes" xml:space="preserve">
          <source>Ancestors::min_by</source>
          <target state="translated">Ancestors::min_by</target>
        </trans-unit>
        <trans-unit id="4a76ef60a157a414e53965e7b20bdb80a42a93c5" translate="yes" xml:space="preserve">
          <source>Ancestors::min_by_key</source>
          <target state="translated">Ancestors::min_by_key</target>
        </trans-unit>
        <trans-unit id="5d2760f02e37aabc523ea5766e6897c5ccc56a0b" translate="yes" xml:space="preserve">
          <source>Ancestors::ne</source>
          <target state="translated">Ancestors::ne</target>
        </trans-unit>
        <trans-unit id="94b5fbd4a6186842bbae09888725d74af29ff76c" translate="yes" xml:space="preserve">
          <source>Ancestors::next</source>
          <target state="translated">Ancestors::next</target>
        </trans-unit>
        <trans-unit id="061044f738cb0378794d00307372b84bda535007" translate="yes" xml:space="preserve">
          <source>Ancestors::nth</source>
          <target state="translated">Ancestors::nth</target>
        </trans-unit>
        <trans-unit id="104a8aab4cf5a11201b887398168f2f5e1f87087" translate="yes" xml:space="preserve">
          <source>Ancestors::partial_cmp</source>
          <target state="translated">Ancestors::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bed7abfd1f96e21405eb173c4d15c03b456d92a5" translate="yes" xml:space="preserve">
          <source>Ancestors::partition</source>
          <target state="translated">Ancestors::partition</target>
        </trans-unit>
        <trans-unit id="84cd0d32c4daeda367ba0a2ae2e2b6a7ff4841da" translate="yes" xml:space="preserve">
          <source>Ancestors::peekable</source>
          <target state="translated">Ancestors::peekable</target>
        </trans-unit>
        <trans-unit id="b4ddc60ef630227f7ade5b8c560fef259500316e" translate="yes" xml:space="preserve">
          <source>Ancestors::position</source>
          <target state="translated">Ancestors::position</target>
        </trans-unit>
        <trans-unit id="7a31ee815f86cdd427869f86ea4e16e837ac74a5" translate="yes" xml:space="preserve">
          <source>Ancestors::product</source>
          <target state="translated">Ancestors::product</target>
        </trans-unit>
        <trans-unit id="b560f4cdd9c918e68c647f28819fc526f4443425" translate="yes" xml:space="preserve">
          <source>Ancestors::rev</source>
          <target state="translated">Ancestors::rev</target>
        </trans-unit>
        <trans-unit id="2d6150b963da3a5f8bb4fbcf3bede9ac1d149eac" translate="yes" xml:space="preserve">
          <source>Ancestors::rposition</source>
          <target state="translated">Ancestors::rposition</target>
        </trans-unit>
        <trans-unit id="33695d4fc7bd02cc81076a7f065f59ae331ce9d8" translate="yes" xml:space="preserve">
          <source>Ancestors::scan</source>
          <target state="translated">Ancestors::scan</target>
        </trans-unit>
        <trans-unit id="a71e116d1152775af982054ee8766888b8c17bf5" translate="yes" xml:space="preserve">
          <source>Ancestors::size_hint</source>
          <target state="translated">Ancestors::size_hint</target>
        </trans-unit>
        <trans-unit id="1492747daf21eb6d17932ae78e4e1bb6900ec817" translate="yes" xml:space="preserve">
          <source>Ancestors::skip</source>
          <target state="translated">Ancestors::skip</target>
        </trans-unit>
        <trans-unit id="7ccb1c50d003cbcf82f746c7c89b476d0db40ef9" translate="yes" xml:space="preserve">
          <source>Ancestors::skip_while</source>
          <target state="translated">Ancestors::skip_while</target>
        </trans-unit>
        <trans-unit id="2d680c75e7e0a20bba67113ba634c0b9819ec275" translate="yes" xml:space="preserve">
          <source>Ancestors::step_by</source>
          <target state="translated">Ancestors::step_by</target>
        </trans-unit>
        <trans-unit id="bb4081cc4c0735468e080f3f00abdd7bfc4c7b73" translate="yes" xml:space="preserve">
          <source>Ancestors::sum</source>
          <target state="translated">Ancestors::sum</target>
        </trans-unit>
        <trans-unit id="b184ac7bf98e724a647631566c8e7b44261ba11d" translate="yes" xml:space="preserve">
          <source>Ancestors::take</source>
          <target state="translated">Ancestors::take</target>
        </trans-unit>
        <trans-unit id="551d6d8baae9a0ead4f49097f5951591191f29fd" translate="yes" xml:space="preserve">
          <source>Ancestors::take_while</source>
          <target state="translated">Ancestors::take_while</target>
        </trans-unit>
        <trans-unit id="f38b2d2e57427d6c5d34e24a9e37978f181043c7" translate="yes" xml:space="preserve">
          <source>Ancestors::to_owned</source>
          <target state="translated">Ancestors::to_owned</target>
        </trans-unit>
        <trans-unit id="bd8e948ee34c84cdc8f1385bf9b2d83abdbf9fb4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_fold</source>
          <target state="translated">Ancestors::try_fold</target>
        </trans-unit>
        <trans-unit id="46ad3f23b6a14805c5bb02a0abccbaa9ad1f0c58" translate="yes" xml:space="preserve">
          <source>Ancestors::try_for_each</source>
          <target state="translated">Ancestors::try_for_each</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
